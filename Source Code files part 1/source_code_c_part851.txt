 max(cx, sizeMin.cx), max(cy, sizeMin.cy), fSwp);

    //  Update scroll parameters
    if (fLayoutFlags & BLF_CALCSCROLL)
    {
        SetScrollInfo(SB_HORZ, &_siHorz, TRUE);
        SetScrollInfo(SB_VERT, &_siVert, TRUE);
    }
}


void CFileSearchBand::Scroll(int nBar, UINT uSBCode, int nNewPos /*optional*/)
{
    int         nDeltaMax;
    SCROLLINFO  *psbi;
    const LONG  nLine = 8;

    psbi = (SB_HORZ == nBar) ? &_siHorz : &_siVert;
    nDeltaMax = (psbi->nMax - psbi->nPage) + 1;
    
    switch (uSBCode)
    {
        case SB_LEFT:
            psbi->nPos--;
            break;
        case SB_RIGHT:
            psbi->nPos++;
            break;
        case SB_LINELEFT:
            psbi->nPos = max(psbi->nPos - nLine, 0);
            break;
        case SB_LINERIGHT:
            psbi->nPos = min(psbi->nPos + nLine, nDeltaMax);
            break;
        case SB_PAGELEFT:
            psbi->nPos = max(psbi->nPos - (int)psbi->nPage, 0);
            break;
        case SB_PAGERIGHT:
            psbi->nPos = min(psbi->nPos + (int)psbi->nPage, nDeltaMax);
            break;
        case SB_THUMBTRACK:
            psbi->nPos = nNewPos;
            break;
        case SB_THUMBPOSITION:
            psbi->nPos = nNewPos;
            break;
        case SB_ENDSCROLL:
            return;
    }
    psbi->fMask = SIF_POS;
    SetScrollInfo(nBar, psbi, TRUE);
    UpdateLayout(BLF_ALL &~ BLF_CALCSCROLL /*no need to recalc scroll state data*/);
}


//  WM_HSCROLL/WM_VSCROLL handler
LRESULT CFileSearchBand::OnScroll(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Scroll((WM_HSCROLL == nMsg) ? SB_HORZ : SB_VERT, 
            LOWORD(wParam), HIWORD(wParam));
    return 0;
}


void CFileSearchBand::EnsureVisible(LPCRECT lprc /* in screen coords */)
{
    ASSERT(lprc);
    RECT rc = *lprc;
    RECT rcClient;
    RECT vertexDeltas;
    SIZE scrollDelta;
    
    ::MapWindowPoints(HWND_DESKTOP, m_hWnd, (LPPOINT)&rc, POINTSPERRECT);
    GetClientRect(&rcClient);

    BOOL fTaller = RECTHEIGHT(rc) > RECTHEIGHT(rcClient);
    BOOL fFatter = RECTWIDTH(rc) > RECTWIDTH(rcClient);

    //  Store deltas at each vertex
    SetRect(&vertexDeltas, 
             rc.left   - rcClient.left,
             rc.top    - rcClient.top,
             rc.right  - rcClient.right,
             rc.bottom - rcClient.bottom);

    //  Compute scroll deltas
    scrollDelta.cx = (vertexDeltas.left < 0) ? vertexDeltas.left :
                     (vertexDeltas.right > 0 && !fFatter) ? vertexDeltas.right :
                     0;

    scrollDelta.cy = (vertexDeltas.top < 0) ? vertexDeltas.top :
                     (vertexDeltas.bottom > 0 && !fTaller) ? vertexDeltas.bottom :
                     0;
    
    //  Scroll into view as necessary.
    if (scrollDelta.cx)
    {
        _siHorz.fMask = SIF_POS;
        _siHorz.nPos  += scrollDelta.cx;
        SetScrollInfo(SB_HORZ, &_siHorz, TRUE);
    }

    if (scrollDelta.cy)
    {
        _siVert.fMask = SIF_POS;
        _siVert.nPos  += scrollDelta.cy;
        SetScrollInfo(SB_VERT, &_siVert, TRUE);
    }

    UpdateLayout(BLF_ALL &~ BLF_CALCSCROLL);
}


HRESULT CFileSearchBand::TranslateAccelerator(MSG *pmsg)
{
    return CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
            ::TranslateAcceleratorPriv(this, pmsg, m_spClientSite);
}


HRESULT CFileSearchBand::TranslateAcceleratorInternal(MSG *pmsg, IOleClientSite * pocs)
{
    CBandDlg* pdlg = BandDlg();
    ASSERT(pdlg);

    if (::IsChild(pdlg->Hwnd(), pmsg->hwnd))
    {
        //  Permit tabbing out of pane:
        int nDir;
        if ((nDir = IsVK_TABCycler(pmsg)) != 0)
        {
            if (nDir > 0 && (pmsg->hwnd == pdlg->GetLastTabItem()))
                return S_FALSE;
            if (nDir < 0 && (pmsg->hwnd == pdlg->GetFirstTabItem()))
                return S_FALSE;
        }

        //  try base class handler
        if (S_OK == pdlg->TranslateAccelerator(pmsg))
            return S_OK;
    }
    else if (IsDialogMessage(pmsg))
        return S_OK;

    return IOleInPlaceActiveObjectImpl<CFileSearchBand>::TranslateAccelerator(pmsg);
}


//  Determines whether the the specified message is keyboard input intended
//  to scroll the pane.    If the pane is scrolled as a result of the
//  message, the function returns TRUE; otherwise it returns FALSE.
BOOL CFileSearchBand::IsKeyboardScroll(MSG* pmsg)
{
    if (pmsg->message == WM_KEYDOWN && 
        (GetKeyState(VK_CONTROL) & 0x8000) != 0 &&
        pmsg->wParam != VK_CONTROL)
    {
        int     nBar    = SB_VERT;
        UINT    uSBCode;
        int     nNewPos = 0;
        BOOL    bEditCtl = _IsEditWindowClass(pmsg->hwnd);
        BOOL    bScroll = TRUE;

        //  Some of the following CTRL-key combinations are
        //  not valid pane scroll keys if the target child window is an
        //  edit control.

        switch (pmsg->wParam)
        {
            case VK_UP:
                uSBCode = SB_LINELEFT;
                break;
            case VK_DOWN:
                uSBCode = SB_LINERIGHT;
                break;
            case VK_PRIOR:
                uSBCode = SB_PAGELEFT;
                break;
            case VK_NEXT:
                uSBCode = SB_PAGERIGHT;
                break;
            case VK_END:
                uSBCode = SB_THUMBPOSITION;
                nNewPos = _siVert.nMax - _siVert.nPage;
                break;
            case VK_HOME:
                uSBCode = SB_THUMBPOSITION;
                nNewPos = 0;
                break;
            case VK_LEFT:
                bScroll = !bEditCtl;
                nBar    = SB_HORZ;
                uSBCode = SB_LINELEFT;
                break;
            case VK_RIGHT:
                bScroll = !bEditCtl;
                nBar = SB_HORZ;
                uSBCode = SB_LINERIGHT;
                break;

            default:
                return FALSE;
        }

        //  scroll only if we have to; reduce flicker.
        if (bScroll && ((SB_VERT == nBar && _siVert.nMax != 0) ||
                        (SB_HORZ == nBar && _siHorz.nMax != 0)))
        {
            Scroll(nBar, uSBCode, nNewPos);
            return TRUE; 
        }
    }
    return FALSE;
}


//  Determines whether the indicated key should be passed to the top
//  level browser frame.
BOOL CFileSearchBand::IsBrowserAccelerator(MSG *pmsg)
{
    if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
    {
        BOOL bCombobox     = _IsComboWindowClass(pmsg->hwnd);
        BOOL bComboDropped = (BOOL)(bCombobox ? ::SendMessage(pmsg->hwnd, CB_GETDROPPEDSTATE, 0, 0) : FALSE);
        BOOL bEditCtl      = _IsEditWindowClass(pmsg->hwnd);

        //  Keys that we treat WITHOUT regard to state of CTRL key:
        if (VK_F4 == pmsg->wParam && bCombobox) // should toggle dropped/close-up of combo.
            return FALSE;

        //  Keys that we treat WITH regard to state of CTRL key:
        if ((GetKeyState(VK_CONTROL) & 0x8000) != 0)
        {
            //  Edit cut copy paste?
            if (bEditCtl)
            {
                switch (pmsg->wParam)  {
                    case 'C': case 'X': case 'V': case 'Z':
                        return FALSE;
                }
            }
            return TRUE; // all other CTRL-key combinations are browser keys.
        }
        else
        {
            switch (pmsg->wParam)
            {
            //  browser accelerators that may be shunted by edit controls.
            case VK_BACK:
                return !bEditCtl;

            if (VK_ESCAPE == pmsg->wParam)  // should close up the combo.
                return bComboDropped;

            default:
                if (pmsg->wParam >= VK_F1 && pmsg->wParam <= VK_F24)
                    return TRUE;
            }
        }
    }
    return FALSE;
}


HRESULT CFileSearchBand::IsDlgMessage(HWND hwnd, MSG *pmsg)
{
    //  handle tab cycling (Let browser handle F6)
    if (!IsVK_TABCycler(pmsg) || pmsg->wParam == VK_F6)
    {
        if (IsBrowserAccelerator(pmsg))
        {
            IShellBrowser* psb = GetTopLevelBrowser();
            return (psb && S_OK == psb->TranslateAcceleratorSB(pmsg, 0)) ?
                S_OK : S_FALSE;
        }
    }
    
    //  send through dialog manager
    if (::IsDialogMessage((hwnd != NULL ? hwnd : m_hWnd), pmsg))
        return S_OK;
        
    //  not handled.
    return S_FALSE ;
}

IShellBrowser* CFileSearchBand::GetTopLevelBrowser()
{
    if (NULL == _psb)
        IUnknown_QueryService(BandSite(), SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &_psb));

    return _psb;
}

void CFileSearchBand::FinalRelease()
{
    //  ATL 2.1 has a bug in class unregistration.  Here's
    //  the work around:
    UnregisterClass(GetWndClassInfo().m_wc.lpszClassName, 
                     GetWndClassInfo().m_wc.hInstance);
    GetWndClassInfo().m_atom = 0;

    SetSite(NULL);
}

//-----------------------------//
//  IDeskBand : IDockingWindow


STDMETHODIMP CFileSearchBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
    _dwBandID = dwBandID;
    _dwBandViewMode = dwViewMode;

    if (pdbi->dwMask & DBIM_MINSIZE)
    {
        pdbi->ptMinSize.x = _sizeMin.cx;
        pdbi->ptMinSize.y = _sizeMin.cy;
    }

    if (pdbi->dwMask & DBIM_MAXSIZE)
    {
        pdbi->ptMaxSize.x = _sizeMax.cx;
        pdbi->ptMaxSize.y = _sizeMax.cy;
    }

    if (pdbi->dwMask & DBIM_INTEGRAL)
    {
        pdbi->ptIntegral.x = 
        pdbi->ptIntegral.y = 1;
    }

    if (pdbi->dwMask & DBIM_ACTUAL)
    {
        pdbi->ptActual.x =
        pdbi->ptActual.y = 0;
    }

    if (pdbi->dwMask & DBIM_TITLE)
    {
        TCHAR szTitle[256];
        EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_BANDCAPTION, 
                           szTitle, ARRAYSIZE(szTitle)));
        SHTCharToUnicode(szTitle, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    }

    if (pdbi->dwMask & DBIM_MODEFLAGS)
    {
        pdbi->dwModeFlags = DBIMF_NORMAL|DBIMF_VARIABLEHEIGHT|DBIMF_DEBOSSED|DBIMF_BKCOLOR;
    }

    if (pdbi->dwMask & DBIM_BKCOLOR)
    {
        pdbi->crBkgnd = GetSysColor(COLOR_3DFACE);
    }

    return S_OK;
}


BOOL CFileSearchBand::IsBandDebut()
{
    HKEY hkey;
    BOOL bRet = TRUE;
    if (NULL == (hkey = GetBandRegKey(FALSE)))
        return bRet;

    BYTE rgData[128];
    DWORD cbData = sizeof(rgData);
    DWORD dwType;

    //  Hack alert:  we should maintain our own initialization reg value rather than using IE's
    //  barsize entry.
    DWORD dwRet = RegQueryValueEx(hkey, TEXT("BarSize"), NULL, &dwType, rgData, &cbData);
   
    if ((ERROR_SUCCESS == dwRet || ERROR_MORE_DATA == dwRet) && cbData > 0)
        bRet = FALSE;
        
    RegCloseKey(hkey);
    return bRet;    
}


//  Hack alert:  we should maintain our own reg key rather than using IE's
#define FSB_REGKEYFMT TEXT("Software\\Microsoft\\Internet Explorer\\Explorer Bars\\%s")

int CFileSearchBand::MakeBandKey(OUT LPTSTR pszKey, IN UINT cchKey)
{
    TCHAR   szClsid[GUIDSTR_MAX+1];
    SHStringFromGUID(CLSID_FileSearchBand, szClsid, ARRAYSIZE(szClsid));
    return wnsprintf(pszKey, cchKey, FSB_REGKEYFMT, szClsid);
}


int CFileSearchBand::MakeBandSubKey(IN LPCTSTR pszSubKey, OUT LPTSTR pszKey, IN UINT cchKey)
{
    TCHAR szBandKey[MAX_PATH];
    int cchRet = MakeBandKey(szBandKey, ARRAYSIZE(szBandKey));

    if (cchRet > 0)
    {
        StrCpyN(pszKey, szBandKey, cchKey);
        if (pszSubKey && *pszSubKey && (cchKey - cchRet) > 1)
        {
            StrCatBuff(pszKey, TEXT("\\"), cchKey);
            cchRet++;

            StrCpyN(pszKey + cchRet, pszSubKey, cchKey - cchRet);
            return lstrlen(pszKey);
        }
    }
    return 0;
}


HKEY CFileSearchBand::GetBandRegKey(BOOL bCreateAlways)
{
    HKEY    hkey = NULL;
    TCHAR   szKey[MAX_PATH];

    if (MakeBandKey(szKey, ARRAYSIZE(szKey)) > 0)
    {
        if (bCreateAlways)
        {
            DWORD dwDisp;
            if (ERROR_SUCCESS != 
                RegCreateKeyEx(HKEY_CURRENT_USER, szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                   KEY_READ | KEY_WRITE, NULL, &hkey, &dwDisp))
                hkey = NULL;
        }
        else
        {
            if (ERROR_SUCCESS != 
                RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_READ | KEY_WRITE, &hkey))
                hkey = NULL;
        }
    }

    return hkey;
}


void CFileSearchBand::SetDeskbandWidth(int cx)
{
    SIZE sizeMin = _sizeMin, 
         sizeMax = _sizeMax;
    RECT rc;

    //  Bandsite hack: make sizemin == sizemax equal to
    //  explicitly set band width:
    GetWindowRect(&rc);

    //  note: you shouldn't be setting width if we're not a band.
    ASSERT(DBIF_VIEWMODE_VERTICAL == _dwBandViewMode);

    //  note: height and width are reversed for vertical bands like us.
    _sizeMin.cx = _sizeMax.cx = -1; // ignore height
    _sizeMin.cy = _sizeMax.cy = cx; // assign new width.

    BandInfoChanged(); // force the site to enforce the desired size.

    _sizeMin = sizeMin;
    _sizeMax = sizeMax;

    // restore previous min/max.   If we're to do it right now,
    // we'd be overrided by bandsite, who tries to establish the 
    // infoband width after we're done.
    PostMessage(WMU_BANDINFOUPDATE, 0, 0); 
}


//  WMU_BANDINFOUPDATE handler
LRESULT CFileSearchBand::OnBandInfoUpdate(UINT, WPARAM, LPARAM, BOOL&)
{
    BandInfoChanged();
    return 0;
}


//  Notifies the band site that DESKBANDINFO has changed
HRESULT CFileSearchBand::BandInfoChanged()
{
    ASSERT(_dwBandID != (DWORD)-1);
    VARIANTARG v = {0};
    v.vt = VT_I4;
    v.lVal = _dwBandID;
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, &v, NULL);
}


STDMETHODIMP CFileSearchBand::ShowDW(BOOL fShow)
{
    if (::IsWindow(m_hWnd))
    {
        ShowWindow(fShow ? SW_SHOW : SW_HIDE);
        AddButtons(fShow);
        if (fShow && BandDlg() && ::IsWindow(BandDlg()->Hwnd()))
            BandDlg()->RemoveToolbarTurds(_siVert.nPos);
        
        BandDlg()->OnBandShow(fShow);
    }

    // Since we are now ready to display the band, we will send the
    // message that sub dialogs can begin their delayed initialization
    if (fShow && !_bSendFinishedDisplaying)
    {
        HWND hwndFindFiles = _dlgFSearch.Hwnd();
        if (hwndFindFiles)
        {
            if (::PostMessage(hwndFindFiles, WMU_BANDFINISHEDDISPLAYING, 0, 0))
            {
                _bSendFinishedDisplaying = TRUE;
            }
        }
    }
    return S_OK;
}


STDMETHODIMP CFileSearchBand::CloseDW(DWORD dwReserved)
{
    if (::IsWindow(m_hWnd))
        DestroyWindow();

    return S_OK;
}

STDMETHODIMP CFileSearchBand::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved)
{
    return S_OK;
}

//  IObjectWithSite

STDMETHODIMP CFileSearchBand::SetSite(IUnknown* pSite)
{
    ATOMICRELEASE(_psb);    // free this guy just in case

    AdvertiseBand(pSite ? TRUE : FALSE);

    IUnknown_Set(&_punkSite, pSite);

    if (_punkSite)
    {
        HWND hwndSite;
        if (SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwndSite)))
        {
            RECT rcPos;
            SetRect(&rcPos, 0, 0, 100, 400);
            m_hWnd = Create(hwndSite, rcPos, NULL, 
                             WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_HSCROLL|WS_VSCROLL, 0, 0);
        }
        _fDeskBand = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CFileSearchBand::FindFilesOrFolders(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
    return ShowBandDialog(SRCID_SFileSearch,  
                           bNavigateToResults, bDefaultFocusCtl);
}


STDMETHODIMP CFileSearchBand::FindComputer(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
    return ShowBandDialog(SRCID_SFindComputer,
                           bNavigateToResults, bDefaultFocusCtl);
}


STDMETHODIMP CFileSearchBand::FindPrinter(
    BOOL bNavigateToResults, 
    BOOL bDefaultFocusCtl)
{
#ifdef __PSEARCH_BANDDLG__
    return ShowBandDialog(SRCID_SFindPrinter,
                           bNavigateToResults, bDefaultFocusCtl);

#else  __PSEARCH_BANDDLG__

    HRESULT hr = E_FAIL;
    ASSERT(BandSite());

    IShellDispatch2* psd2;
    hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                           IID_PPV_ARG(IShellDispatch2, &psd2));
    if (SUCCEEDED(hr))
    {
        hr = psd2->FindPrinter(NULL, NULL, NULL) ;
        psd2->Release();
    }
    return hr ;

#endif __PSEARCH_BANDDLG__
}

STDMETHODIMP CFileSearchBand::FindPeople(BOOL bNavigateToResults, BOOL bDefaultFocusCtl)
{
    IObjectWithSite* pows;
    HRESULT hr = CoCreateInstance(CLSID_SearchAssistantOC, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows));
    if (SUCCEEDED(hr))
    {
        hr = pows->SetSite(BandSite());
        if (SUCCEEDED(hr))
        {
            ISearchAssistantOC* psaoc;
            hr = pows->QueryInterface(IID_PPV_ARG(ISearchAssistantOC, &psaoc));
            if (SUCCEEDED(hr))
            {
                hr = psaoc->FindPeople();
                psaoc->Release();
            }
        }
        pows->Release();
    }
    return hr;
}


STDMETHODIMP CFileSearchBand::FindOnWeb(BOOL bNavigateToResults, BOOL bDefaultFocusCtl)
{
    IObjectWithSite* pows;
    HRESULT hr = CoCreateInstance(CLSID_SearchAssistantOC, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows));
    if (SUCCEEDED(hr))
    {
        hr = pows->SetSite(BandSite());
        if (SUCCEEDED(hr))
        {
            ISearchAssistantOC* psaoc;
            hr = pows->QueryInterface(IID_PPV_ARG(ISearchAssistantOC, &psaoc));
            if (SUCCEEDED(hr))
            {
                hr = psaoc->FindOnWeb();
                psaoc->Release();
            }
        }
        pows->Release();
    }
    return hr;
}

//  Make ourself available to clients of IWebBrowser2 by assigning
//  a VT_UNKNOWN property to the browser.
HRESULT CFileSearchBand::AdvertiseBand(BOOL bAdvertise)
{
    if (!BandSite())
        return E_UNEXPECTED;

    HRESULT hr = E_FAIL;
    IShellBrowser* psb = GetTopLevelBrowser();
    if (psb) 
    {
        IWebBrowser2* pwb;
        hr = IUnknown_QueryService(psb, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pwb));
        if (SUCCEEDED(hr))
        {
            BSTR bstrFileSearchBand;
            hr = BSTRFromCLSID(CLSID_FileSearchBand, &bstrFileSearchBand);
            if (SUCCEEDED(hr))
            {
                if (bAdvertise)
                {
                    IUnknown *punk;
                    hr = QueryInterface(IID_PPV_ARG(IUnknown, &punk));
                    if (SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_UNKNOWN;
                        var.punkVal = punk;
                        hr = pwb->PutProperty(bstrFileSearchBand, var);

                        punk->Release();
                    }
                }
                else
                {
                    VARIANT var;
                    hr = pwb->GetProperty(bstrFileSearchBand, &var);
                    if (SUCCEEDED(hr))
                    {
                        if (VT_UNKNOWN == var.vt)
                        {
                            VARIANT varTmp = {0};
                            hr = pwb->PutProperty(bstrFileSearchBand, varTmp);
                        }
                        VariantClear(&var);
                    }
                }
                SysFreeString(bstrFileSearchBand);
            }
            pwb->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFileSearchBand::GetSite(REFIID riid, void **ppvSite)
{
    *ppvSite = NULL;
    return _punkSite ? _punkSite->QueryInterface(riid, ppvSite) : E_FAIL;
}

//  IInputObject
STDMETHODIMP CFileSearchBand::HasFocusIO()
{
    HWND hwndFocus = GetFocus();
    return (::IsWindow(m_hWnd) && (m_hWnd == hwndFocus || IsChild(hwndFocus))) ?
           S_OK : S_FALSE;
}

STDMETHODIMP CFileSearchBand::TranslateAcceleratorIO(MSG *pmsg)
{
    return TranslateAccelerator(pmsg);
}

STDMETHODIMP CFileSearchBand::UIActivateIO(BOOL fActivate, MSG *pmsg)
{
    if (fActivate)
        AutoActivate();
    
    CBandDlg* pdlg = BandDlg();
    if (pdlg)
    {
        if (fActivate)
        {
            //  Handle tabbing into pane
            int  nDir = IsVK_TABCycler(pmsg);
            HWND hwndTarget = (nDir < 0) ? pdlg->GetLastTabItem() :
                              (nDir > 0) ? pdlg->GetFirstTabItem() :
                                           NULL;
            if (hwndTarget)
                ::SetFocus(hwndTarget);
            else if (!pdlg->RestoreFocus())
                ::SetFocus(pdlg->Hwnd());
        }
        else
        {
            pdlg->RememberFocus(NULL);
        }
    }
    return S_OK;
}

//  IOleCommandTarget
STDMETHODIMP CFileSearchBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup)
    {    
        if (IsEqualGUID(*pguidCmdGroup, CGID_FileSearchBand))
        {
            switch (nCmdID)
            {
            case FSTBID_NEW:
                if (_pBandDlg)
                {
                    _pBandDlg->Clear();
                    _pBandDlg->LayoutControls(); 
                    UpdateLayout(BLF_ALL);
                    SetFocus();
                    _pBandDlg->SetDefaultFocus();
                }
                return S_OK;

            case FSTBID_HELP:
                if (_pBandDlg)
                    _pBandDlg->ShowHelp(NULL);
                return S_OK;
            }
        }
    }
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CFileSearchBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_FileSearchBand))
    {
        //  Infotip text for toolbar buttons:
        if (pCmdText)
        {
            ASSERT(1 == cCmds);
            UINT nIDS = 0;
            pCmdText->cwActual = 0;
            switch (prgCmds[0].cmdID)
            {
                case iFSTBID_NEW:
                case FSTBID_NEW:
                    nIDS = IDS_FSEARCH_NEWINFOTIP;
                    break;
                case iFSTBID_HELP:
                case FSTBID_HELP:
                    nIDS = IDS_FSEARCH_HELPINFOTIP;
                    break;
            }
            if (nIDS)
                pCmdText->cwActual = LoadStringW(HINST_THISDLL, nIDS, pCmdText->rgwz, pCmdText->cwBuf);
                    
            return pCmdText->cwActual > 0 ? S_OK : E_FAIL;
        }
    }
    return OLECMDERR_E_UNKNOWNGROUP;
}


//  IServiceProvider
STDMETHODIMP CFileSearchBand::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

//  IPersistStream
STDMETHODIMP CFileSearchBand::IsDirty(void)
{
    return S_FALSE;
}

STDMETHODIMP CFileSearchBand::Load(IStream *pStm) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSearchBand::Save(IStream *pStm, BOOL fClearDirty) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSearchBand::GetSizeMax(ULARGE_INTEGER *pcbSize) 
{
    return E_NOTIMPL;
}


//  IPersist
STDMETHODIMP CFileSearchBand::GetClassID(CLSID *pClassID) 
{
    *pClassID = CLSID_FileSearchBand;
    return S_OK;
}

// CMetrics impl

CMetrics::CMetrics()
    :   _hbrBkgnd(NULL),
        _hbrBorder(NULL),
        _hfBold(NULL)
{ 
    ZeroMemory(&_ptExpandOrigin, sizeof(_ptExpandOrigin));
    ZeroMemory(&_rcCheckBox, sizeof(_rcCheckBox));
    ZeroMemory(_rghiconCaption, sizeof(_rghiconCaption));
    CreateResources(); 
}


void CMetrics::Init(HWND hwndDlg)
{
    _cyTightMargin = _PixelsForDbu(hwndDlg, 3, FALSE);
    _cyLooseMargin = 2 * _cyTightMargin;
    _cxCtlMargin   = _PixelsForDbu(hwndDlg, 7, TRUE);
}


BOOL CMetrics::CreateResources()
{
    _hbrBkgnd = CreateSolidBrush(BkgndColor());
    _hbrBorder= CreateSolidBrush(BorderColor());
    return _hbrBkgnd != NULL && _hbrBorder != NULL;
}


BOOL CMetrics::GetWindowLogFont(HWND hwnd, OUT LOGFONT* plf)
{
    HFONT hf = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
    
    if (hf)
    {
        if (sizeof(*plf) == GetObject(hf, sizeof(*plf), plf))
            return TRUE;
    }
    return FALSE;
}


HFONT CMetrics::BoldFont(HWND hwndDlg)
{
    if (NULL == _hfBold)
    {
        LOGFONT lf;
        if (GetWindowLogFont(hwndDlg, &lf))
        {
            lf.lfWeight = FW_BOLD;
            SHAdjustLOGFONT(&lf); // locale-specific adjustments
            _hfBold = CreateFontIndirect(&lf);
        }
    }
    return _hfBold;
}


HICON CMetrics::CaptionIcon(UINT nIDIconResource)
{
    for (int i = 0; i < ARRAYSIZE(_icons); i++)
    {
        if (_icons[i] == nIDIconResource)
        {
            if (NULL == _rghiconCaption[i])
            {
                _rghiconCaption[i] = (HICON)LoadImage(
                    HINST_THISDLL, MAKEINTRESOURCE(nIDIconResource), 
                    IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
            }
            return _rghiconCaption[i];
        }
    }
    return NULL;
}


void CMetrics::DestroyResources()
{
    if (_hbrBkgnd)
    {
        DeleteObject(_hbrBkgnd);
        _hbrBkgnd = NULL;
    }

    if (_hbrBorder)
    {
        DeleteObject(_hbrBorder);
        _hbrBorder = NULL;
    }

    if (_hfBold)
    {
        DeleteObject(_hfBold);
        _hfBold = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(_icons); i++)
    {
        if (_rghiconCaption[i])
        {
            DestroyIcon(_rghiconCaption[i]);
            _rghiconCaption[i] = NULL;
        }
    }
}


void CMetrics::OnWinIniChange(HWND hwndDlg)
{
    DestroyResources();

    //  Force resource regen
    CreateResources();
    
    //  Force font regen
    BoldFont(hwndDlg);

    Init(hwndDlg);
}

// returns:
//      S_OK        -> uptodate
//      S_FALSE     -> not up to date
//      FAILED()    -> volume not CIed

STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine)
{
    HRESULT hr = E_FAIL;
    CI_STATE state = {0};
    state.cbStruct = sizeof(state);
    if (SUCCEEDED(CIState(pszCatalog, pszMachine, &state)))
    {
        BOOL fUpToDate = ((0 == state.cDocuments) &&
                          (0 == (state.eState & CI_STATE_SCANNING)) &&
                          (0 == (state.eState & CI_STATE_READING_USNS)) &&
                          (0 == (state.eState & CI_STATE_STARTING)) &&
                          (0 == (state.eState & CI_STATE_RECOVERING)));
        if (fUpToDate)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

// returns:
//      S_OK        -> uptodate
//      S_FALSE     -> not up to date
//      FAILED()    -> volume not CIed

STDAPI PathUptodate(LPCWSTR pszPath)
{
    HRESULT hr = E_FAIL;

    WCHAR wszMachine[32], wszCatalog[MAX_PATH];
    DWORD cchMachine = ARRAYSIZE(wszMachine), cchCatalog = ARRAYSIZE(wszCatalog);

    if (S_OK == LocateCatalogsW(pszPath, 0, wszMachine, &cchMachine, wszCatalog, &cchCatalog))
    {
        hr = CatalogUptodate(wszCatalog, wszMachine);
    }
    return hr;
}

HRESULT LocalDrivesContentUpToDate()
{
    HRESULT hr = S_OK;      // assume yes
    DWORD dwDriveMask = GetLogicalDrives();
    
    for (int i = 0; i < 26; i++)
    {
        if (dwDriveMask & 1)
        {
            if (!IsRemovableDrive(i) && !IsRemoteDrive(i))
            {
                WCHAR wszPath[4];
                PathBuildRoot(wszPath, i);

                if (S_FALSE == PathUptodate(wszPath))
                {
                    hr = S_FALSE;
                    break;
                }
            }
        }
        dwDriveMask >>= 1;
    }
    return hr;
}

HRESULT QueryCIStatus(DWORD *pdwStatus, BOOL *pbConfigAccess)
{
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(pdwStatus);
    *pdwStatus = 0;
    if (pbConfigAccess)
        *pbConfigAccess = FALSE;
    
    SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm)
    {
        SC_HANDLE hService = NULL;
        //  Test permission to muck around with service
        if (pbConfigAccess)
        {
            hService = OpenService(hScm, L"cisvc", 
                SERVICE_START |SERVICE_STOP | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS);
            if (hService)
            {
                *pbConfigAccess = TRUE;
            }
        }
        //  Query service status
        if (NULL == hService)
            hService = OpenService(hScm, L"cisvc", SERVICE_QUERY_STATUS);

        if (hService)
        {
            SERVICE_STATUS status;
            if (!QueryServiceStatus(hService, &status))
                dwErr = GetLastError();
            else
                *pdwStatus = status.dwCurrentState;

            CloseServiceHandle(hService); 
        }
        else
            dwErr = GetLastError();

        CloseServiceHandle(hScm); 
    }
    else
        dwErr = GetLastError();

    return HRESULT_FROM_WIN32(dwErr);
}

STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission)
{
    *pbRunning = *pbIndexed = *pbPermission = FALSE;

    DWORD dwStatus = 0;
    HRESULT hr = QueryCIStatus(&dwStatus, pbPermission);
    if (SUCCEEDED(hr))
    {
        switch (dwStatus)
        {
        case SERVICE_START_PENDING:
        case SERVICE_RUNNING:
        case SERVICE_CONTINUE_PENDING:
            *pbRunning = TRUE;
        }
    }

    if (*pbRunning)
        *pbIndexed = *pbPermission ? (S_OK == LocalDrivesContentUpToDate()) : TRUE;

    return hr;
}

STDAPI StartStopCI(BOOL bStart)
{
    DWORD dwErr = ERROR_SUCCESS;
    SERVICE_STATUS  status;

    SC_HANDLE hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScm)
    {
        DWORD dwAccess = SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | (bStart ? SERVICE_START : SERVICE_STOP);
        SC_HANDLE hService = OpenService(hScm, L"cisvc", dwAccess);
        if (hService)
        {
            if (QueryServiceStatus(hService, &status))
            {
                dwErr = ChangeServiceConfig(hService, SERVICE_NO_CHANGE,
                                             bStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                                             SERVICE_NO_CHANGE, NULL, NULL, 
                                             NULL, NULL, NULL, NULL, NULL);
                // we'll ignore return value
        
                if (bStart)
                {
                    if (SERVICE_PAUSED == status.dwCurrentState ||
                        SERVICE_PAUSE_PENDING == status.dwCurrentState)
                        dwErr = ControlService(hService, SERVICE_CONTROL_CONTINUE, &status) ? 
                                    ERROR_SUCCESS : GetLastError();
                    else
                    {
                        dwErr = StartService(hService, 0, NULL) ? ERROR_SUCCESS : GetLastError();
                        if (ERROR_SERVICE_ALREADY_RUNNING == dwErr)
                            dwErr = ERROR_SUCCESS;
                    }
                }
                else
                {
                    dwErr = ControlService(hService, SERVICE_CONTROL_STOP, &status) ? 
                                    ERROR_SUCCESS : GetLastError();
                }
            }
            else
                dwErr = GetLastError();

            CloseServiceHandle(hService); 
        }
        else
            dwErr = GetLastError();

        CloseServiceHandle(hScm); 
    }
    else
        dwErr = GetLastError();

    return HRESULT_FROM_WIN32(dwErr);
}


inline BOOL IsWhite(WCHAR ch)
{
    return L' ' == ch || L'\t' == ch || L'\n' == ch || L'\r' == ch;
}

inline BOOL IsParens(WCHAR ch)
{
    return L'(' == ch || L')' == ch;
}


//  Skips whitespace
static LPCWSTR SkipWhiteAndParens(IN LPCWSTR pwszTest)
{
    while(pwszTest && *pwszTest && 
           (IsWhite(*pwszTest) || IsParens(*pwszTest)))
        pwszTest = CharNextW(pwszTest);

    return (pwszTest && *pwszTest) ? pwszTest : NULL;
}


//  Determines whether the indicated keyword is found in the specified
//  prefix and/or suffix context.  If successful, return value is address
//  of first character beyond the keyword context; otherwise NULL.
static LPCWSTR IsKeywordContext(
    IN LPCWSTR pwszTest, 
    IN OPTIONAL WCHAR chPrefix, 
    IN OPTIONAL LPCWSTR pwszKeyword, 
    IN OPTIONAL WCHAR chSuffix,
    IN OPTIONAL WCHAR chSuffix2)
{
    if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
        return NULL;
    
    if (chPrefix)
    {
        if (chPrefix != *pwszTest)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }

    if (pwszKeyword)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (StrStrIW(pwszTest, pwszKeyword) != pwszTest)
            return NULL;
        pwszTest += lstrlenW(pwszKeyword);
    }

    if (chSuffix)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (*pwszTest != chSuffix)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }

    if (chSuffix2)
    {
        if ((pwszTest = SkipWhiteAndParens(pwszTest)) == NULL)
            return NULL;
        if (*pwszTest != chSuffix2)
            return NULL;
        pwszTest = CharNextW(pwszTest);
    }
    return pwszTest;
}

BOOL IsTripoliV1Token(LPCWSTR pwszQuery, LPCWSTR *ppwszOut /* trailing text */)
{
    *ppwszOut = NULL;
    LPCWSTR pwsz;

    //  Find the token
    if ((pwsz = IsKeywordContext(pwszQuery, L'#', NULL, 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'$', L"contents", 0, 0)) != NULL)
    {
        *ppwszOut = pwsz;
        return TRUE;
    }

    return FALSE;
}


BOOL IsTripoliV2Token(LPCWSTR pwszQuery, LPCWSTR *ppwszOut /* trailing text */)
{
    *ppwszOut = NULL;
    LPCWSTR pwsz;

    //  Find the token
    if ((pwsz = IsKeywordContext(pwszQuery, L'{', L"phrase", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"freetext", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"prop", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"regex", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"coerce", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"ve", L'}', 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"weight", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"vector", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'{', L"generate", 0, 0)) != NULL ||
        (pwsz = IsKeywordContext(pwszQuery, L'@', NULL, 0, 0)) != NULL)
    {
        *ppwszOut = pwsz;
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) IsCiQuery(const VARIANT *pvarRaw, VARIANT *pvarQuery, ULONG *pulDialect)
{
    BOOL bBang = FALSE;

    VariantInit(pvarQuery);

    *pulDialect = 0;        // invalid value (valid values are > 0)

    if (pvarRaw->vt != VT_BSTR || NULL == pvarRaw->bstrVal || 0 == *pvarRaw->bstrVal)
        return FALSE;

    LPCWSTR pwsz = pvarRaw->bstrVal;
    //  text beginning w/ '!' indicates that this text is a CI query.
    //  but it must be very first character (not even spaces are allowed)
    if (pwsz && *pwsz)
    {
        if (L'!' == *pwsz)
        {
            //  skip over '!'
            bBang = TRUE;
            
            if ((pwsz = CharNextW(pwsz)) == NULL || 0 == *pwsz)
                return FALSE;
                
            //  fall through...
        }
    }

    pwsz = SkipWhiteAndParens(pwsz);

    if (pwsz && *pwsz)
    {
        //  text looking like a query token
        if (pwsz && *pwsz)
        {
            LPCWSTR pwszMore, pwszTemp;
            // @ is valid in both tripoli v1 & v2 but it has extended usage in v2 so 
            // we put it as v2 token only
            if (IsTripoliV2Token(pwsz, &pwszMore))
                *pulDialect = ISQLANG_V2;
            // no else here because if @ is used in combination w/ some v1 token
            // we want the query to be v1.
            if (IsTripoliV1Token(pwsz, &pwszTemp))
            {
                *pulDialect = ISQLANG_V1;
                pwszMore  = pwszTemp;
            }

            if (*pulDialect)
            {
                // See if there is anything substantial past the query tokens
                pwszMore = SkipWhiteAndParens(pwszMore);
                if (pwszMore && *pwszMore)
                {
                    InitVariantFromStr(pvarQuery, pwsz);
                    return TRUE;
                }
            }
            else
            {
                if (bBang)
                {
                    InitVariantFromStr(pvarQuery, pwsz);
                    *pulDialect = ISQLANG_V1; // just pick one
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}

// needed for ATL goo
LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

STDAPI CFileSearchBand_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = CreateFromRegKey(REGSTR_PATH_EXPLORER, TEXT("FileFindBandHook"), riid, ppv);
    if (FAILED(hr))
        hr = CComCreator< CComObject< CFileSearchBand > >::CreateInstance((void *)pUnkOuter, IID_IUnknown, (void **)ppv);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filtgrep.cpp ===
//  10/12/99    scotthan    created

#include "shellprv.h"
#include "filtgrep.h"
#include <ntquery.h>
#include <filterr.h>


class CGrepTokens // maintains an index of unicode and ansi grep tokens.
{
public:
    STDMETHODIMP            Initialize(UINT nCodepage, LPCWSTR pwszMatch, LPCWSTR pwszExclude, BOOL bCaseSensitive);
    STDMETHODIMP_(void)     Reset();
    STDMETHODIMP_(BOOL)     GrepW(LPCWSTR pwszText);
    STDMETHODIMP_(BOOL)     GrepA(LPCSTR pwszText);
    
    STDMETHODIMP GetMatchTokens(OUT LPWSTR pszTokens, UINT cchTokens) const;
    STDMETHODIMP GetExcludeTokens(OUT LPWSTR pszTokens, UINT cchTokens) const;

private:
    UINT    _nCodepage;
    LPWSTR  _pszMatchW, _pszExcludeW;   // raw strings, unicode
    LPSTR   _pszMatchA, _pszExcludeA;   // raw strings, ansi

    LPCWSTR *_rgpszMatchW, *_rgpszExcludeW; // token index, unicode
    LPCSTR  *_rgpszMatchA, *_rgpszExcludeA; // token index, ansi

    LONG    _cMatch, _cExclude; // token counts
    
    LPWSTR  (__stdcall * _pfnStrStrW)(LPCWSTR, LPCWSTR);
    LPSTR   (__stdcall * _pfnStrStrA)(LPCSTR, LPCSTR);

public:
    //  Ctor, Dtor
    CGrepTokens()
        :   _nCodepage(0), _cMatch(0), _cExclude(0), _pfnStrStrW(StrStrIW), _pfnStrStrA(StrStrIA),
            _pszMatchW(NULL), _pszExcludeW(NULL), _rgpszMatchW(NULL), _rgpszExcludeW(NULL),
            _pszMatchA(NULL), _pszExcludeA(NULL), _rgpszMatchA(NULL), _rgpszExcludeA(NULL) {}
    ~CGrepTokens()    { Reset(); }

};


class CGrepBuffer // auxilliary class: per-thread grep buffer
{
public:
    CGrepBuffer(ULONG dwThreadID)  :  _dwThreadID(dwThreadID), _pszBuf(NULL), _cchBuf(0) {}
    virtual ~CGrepBuffer()  {delete [] _pszBuf;}
    
    STDMETHODIMP          Alloc(ULONG cch);
    STDMETHODIMP_(BOOL)   IsThread(ULONG dwThread) const {return dwThread == _dwThreadID;}
    STDMETHODIMP_(LPWSTR) Buffer()  { return _pszBuf; }

    #define DEFAULT_GREPBUFFERSIZE  0x00FF  // +1 = 1 page.

private:
    LPWSTR _pszBuf;
    ULONG  _cchBuf;
    ULONG  _dwThreadID;
};


//  Makes a heap copy of a widechar string
LPWSTR _AllocAndCopyString(LPCWSTR pszSrc, UINT cch = -1)
{
    if (pszSrc)
    {
        if ((int)cch < 0) // must cast to "int" since cch is a UINT
            cch = lstrlenW(pszSrc);
        LPWSTR pszRet = new WCHAR[cch + 1];
        if (pszRet)
        {
            // no StrCpyN, this is a double-NULL list
            CopyMemory(pszRet, pszSrc, sizeof(*pszSrc) * cch);
            pszRet[cch] = 0;
            return pszRet;
        }
    }
    return NULL;
}


//  Makes an ansi copy of a widechar string
LPSTR _AllocAndCopyAnsiString(UINT nCodepage, LPCWSTR pszSrc, UINT cch = -1)
{
    if (pszSrc)
    {
        if ((int)cch < 0) // must cast to "int" since cch is a UINT
            cch = lstrlenW(pszSrc);
        int cchBuf = WideCharToMultiByte(nCodepage, 0, pszSrc, cch, NULL, 0, NULL, NULL);
        LPSTR pszRet = new CHAR[cchBuf+1];
        if (pszRet)
        {
            int cchRet = WideCharToMultiByte(nCodepage, 0, pszSrc, cch, pszRet, cchBuf, NULL, NULL);
            pszRet[cchRet] = 0;
            return pszRet;
        }
    }
    return NULL;
}


//  CGrepBuffer impl



STDMETHODIMP CGrepBuffer::Alloc(ULONG cch)
{
    LPWSTR pszBuf = NULL;
    if (cch)
    {
        if (_pszBuf && _cchBuf >= cch)
            return S_OK;

        pszBuf = new WCHAR[cch+1];
        if (NULL == pszBuf)
            return E_OUTOFMEMORY;

        *pszBuf = 0;
    }

    delete [] _pszBuf;
    _pszBuf = pszBuf;
    _cchBuf = cch;
    
    return _pszBuf != NULL ? S_OK : S_FALSE ;
}


//  CGrepTokens impl



//  Counts the number of characters in a string containing NULL-delimited tokens ("foo\0bloke\0TheEnd\0\0")
LONG _GetTokenListLength(LPCWSTR pszList, LONG* pcTokens = NULL)
{
    LONG cchRet = 0;
    if (pcTokens) *pcTokens = 0;

    if (pszList && *pszList)
    {
        LPCWSTR pszToken, pszPrev; 
        int     i = 0;
        
        for (pszToken = pszPrev = pszList;
             pszToken && *pszToken;)
        {
            if (pcTokens) 
                (*pcTokens)++;
            
            pszToken += lstrlenW(pszToken) + 1, 
            cchRet += (DWORD)(pszToken - pszPrev) ;
            pszPrev = pszToken;
        }
    }
        
    return cchRet;
}



//  wide version: Counts and/or indexes NULL-delimited string tokens ("foo\0bloke\0TheEnd\0\0")
LONG _IndexTokensW(LPCWSTR pszList, LPCWSTR* prgszTokens = NULL)
{
    LONG cRet = 0;
    if (pszList && *pszList)
    {
        LPCWSTR psz = pszList;
        for (int i = 0; psz && *psz; psz += (lstrlenW(psz) + 1), i++)
        {
            if (prgszTokens)
                prgszTokens[i] = psz;
            cRet++;
        }
    }
    return cRet;
}


//  ansi version: Counts and/or indexes NULL-delimited string tokens ("foo\0bloke\0TheEnd\0\0")
LONG _IndexTokensA(LPCSTR pszList, LPCSTR* prgszTokens = NULL)
{
    LONG cRet = 0;
    if (pszList && *pszList)
    {
        LPCSTR psz = pszList;
        for (int i = 0; psz && *psz; psz += (lstrlenA(psz) + 1), i++)
        {
            if (prgszTokens)
                prgszTokens[i] = psz;
            cRet++;
        }
    }
    return cRet;
}


//  wide version: Allocates a string token index and indexes a string of NULL-delimited tokens.
STDMETHODIMP _AllocAndIndexTokensW(LONG cTokens, LPCWSTR pszList, LPCWSTR** pprgszTokens)
{
    if (cTokens)
    {
        if (NULL == (*pprgszTokens = new LPCWSTR[cTokens]))
            return E_OUTOFMEMORY;
    
        if (cTokens != _IndexTokensW(pszList, *pprgszTokens))
        {
            delete [] (*pprgszTokens);
            *pprgszTokens = NULL;
            return E_FAIL;
        }
    }
    return S_OK;
}


//  ansi version: Allocates a string token index and indexes a string of NULL-delimited tokens.
STDMETHODIMP _AllocAndIndexTokensA(LONG cTokens, LPCSTR pszList, LPCSTR** pprgszTokens)
{
    if (cTokens)
    {
        if (NULL == (*pprgszTokens = new LPCSTR[cTokens]))
            return E_OUTOFMEMORY;
    
        if (cTokens != _IndexTokensA(pszList, *pprgszTokens))
        {
            delete [] (*pprgszTokens);
            *pprgszTokens = NULL;
            return E_FAIL;
        }
    }
    return S_OK;
}


//  Frees unicode and ansi token lists and corresponding indices.
void _FreeUniAnsiTokenList(
    OUT LPWSTR*   ppszListW,
    OUT LPSTR*    ppszListA,
    OUT LPCWSTR** pprgTokensW,
    OUT LPCSTR**  pprgTokensA)
{
    delete [] *ppszListW;   *ppszListW = NULL;
    delete [] *ppszListA;   *ppszListA = NULL;
    delete [] *pprgTokensW; *pprgTokensW = NULL;
    delete [] *pprgTokensA; *pprgTokensA = NULL;
}


//  Allocates unicode and ansi token lists and corresponding indices.
STDMETHODIMP _AllocUniAnsiTokenList(
    UINT          nCodepage,
    LPCWSTR       pszList, 
    OUT LPWSTR*   ppszListW,
    OUT LPSTR*    ppszListA,
    OUT LONG*     pcTokens,
    OUT LPCWSTR** pprgTokensW,
    OUT LPCSTR**  pprgTokensA)
{
    HRESULT hr = S_FALSE;
    LONG cTokens = 0;
    UINT cch = _GetTokenListLength(pszList, &cTokens);

    *ppszListW   = NULL;
    *ppszListA   = NULL;
    *pprgTokensW = NULL;
    *pprgTokensA = NULL;
    *pcTokens    = 0;

    if (cTokens)
    {
        hr = E_OUTOFMEMORY;
        
        if (NULL == (*ppszListW = _AllocAndCopyString(pszList, cch)))
            goto failure_exit;

        if (NULL == (*ppszListA = _AllocAndCopyAnsiString(nCodepage, pszList, cch)))
            goto failure_exit;

        if (FAILED((hr = _AllocAndIndexTokensW(cTokens, *ppszListW, pprgTokensW))))
            goto failure_exit;

        if (FAILED((hr = _AllocAndIndexTokensA(cTokens, *ppszListA, pprgTokensA))))
            goto failure_exit;

        *pcTokens = cTokens;
        hr = S_OK;
    }
    return hr;

failure_exit:
    _FreeUniAnsiTokenList(ppszListW, ppszListA, pprgTokensW, pprgTokensA);
    return hr;
}


STDMETHODIMP CGrepTokens::Initialize(UINT nCodepage, LPCWSTR pszMatch, LPCWSTR pszExclude, BOOL bCaseSensitive)
{
    HRESULT hr = E_INVALIDARG;
    Reset();

    BOOL bMatchString   = (pszMatch && *pszMatch);
    BOOL bExcludeString = (pszExclude && *pszExclude);

    if (!(bMatchString || bExcludeString))
        return E_INVALIDARG;

    _nCodepage = nCodepage;

    if (bCaseSensitive)
    {
        _pfnStrStrW = StrStrW;
        _pfnStrStrA = StrStrA;
    }
    else
    {
        _pfnStrStrW = StrStrIW;
        _pfnStrStrA = StrStrIA;
    }

    if (bMatchString)
    {
        if (FAILED((hr = _AllocUniAnsiTokenList(nCodepage, pszMatch,
            &_pszMatchW, &_pszMatchA, &_cMatch, &_rgpszMatchW, &_rgpszMatchA))))
        {
            return hr;
        }
    }
    
    if (bExcludeString)
    {
        if (FAILED((hr = _AllocUniAnsiTokenList(nCodepage, pszExclude,
            &_pszExcludeW, &_pszExcludeA, &_cExclude, &_rgpszExcludeW, &_rgpszExcludeA))))
        {
            return hr;
        }
    }

    return hr;
}

// S_OK we have some match tokens, S_FALSE otherwise

STDMETHODIMP CGrepTokens::GetMatchTokens(OUT LPWSTR pszMatch, UINT cchMatch) const
{
    HRESULT hr = (_pszMatchW && *_pszMatchW) ? S_OK : S_FALSE;
    if (pszMatch)
    {
        hr = StringCchCopy(pszMatch, cchMatch, _pszMatchW ? _pszMatchW : L"");
    }
    return hr;
}

// S_OK we have some exclude tokens, S_FALSE otherwise

STDMETHODIMP CGrepTokens::GetExcludeTokens(OUT LPWSTR pszExclude, UINT cchExclude) const
{
    HRESULT hr = (_pszExcludeW && *_pszExcludeW) ? S_OK : S_FALSE;
    if (pszExclude)
    {
        hr = StringCchCopy(pszExclude, cchExclude, _pszExcludeW ? _pszExcludeW : L"");
    }
    return hr;
}

void CGrepTokens::Reset()
{
    _FreeUniAnsiTokenList(&_pszMatchW, &_pszMatchA, &_rgpszMatchW, &_rgpszMatchA);
    _FreeUniAnsiTokenList(&_pszExcludeW, &_pszExcludeA, &_rgpszExcludeW, &_rgpszExcludeA);
    _cMatch = _cExclude = 0;
    _nCodepage = 0;
}


STDMETHODIMP_(BOOL) CGrepTokens::GrepW(LPCWSTR pszText)
{
    BOOL bMatch = FALSE;
    if (pszText)
    {
        BOOL bExclude = FALSE;
     
        for (int i = 0; i < _cMatch; i++)
        {
            if (_pfnStrStrW(pszText, _rgpszMatchW[i]))
            {
                bMatch = TRUE;
                break;
            }
        }

        for (i = 0; i < _cExclude; i++)
        {
            if (_pfnStrStrW(pszText, _rgpszExcludeW[i]))
            {
                bExclude = TRUE;
                break;
            }
        }
    
        if (_cMatch && _cExclude)
            return bMatch || !_cExclude;
        if (_cExclude)
            return !bExclude;
    }
    return bMatch;
}

STDMETHODIMP_(BOOL) CGrepTokens::GrepA(LPCSTR pszText)
{
    BOOL bMatch = FALSE;
    if (pszText)
    {
        BOOL bExclude = FALSE;
        for (int i = 0; i < _cMatch; i++)
        {
            if (_pfnStrStrA(pszText, _rgpszMatchA[i]))
            {
                bMatch = TRUE;
                break;
            }
        }

        for (i = 0; i < _cExclude; i++)
        {
            if (_pfnStrStrA(pszText, _rgpszExcludeA[i]))
            {
                bExclude = TRUE;
                break;
            }
        }
    
        if (_cMatch && _cExclude)
            return bMatch || !_cExclude;
        if (_cExclude)
            return !bExclude;
    }
    return bMatch;
}

inline STDMETHODIMP_(BOOL) _IsEqualAttribute(const FULLPROPSPEC& fps, REFFMTID fmtid, PROPID propid)
{
    return IsEqualGUID(fmtid, fps.guidPropSet) && 
                        PRSPEC_PROPID == fps.psProperty.ulKind &&
                        propid == fps.psProperty.propid;
}


STDMETHODIMP_(BOOL) _PropVariantGrep(PROPVARIANT* pvar, CGrepTokens* pTokens)
{
    BOOL bRet = FALSE;

    switch(pvar->vt)
    {
    case VT_LPWSTR:
        bRet = pTokens->GrepW(pvar->pwszVal);
        break;

    case VT_BSTR:
        bRet = pTokens->GrepW(pvar->bstrVal);
        break;

    case VT_LPSTR:
        bRet = pTokens->GrepA(pvar->pszVal);
        break;

    case VT_VECTOR|VT_LPWSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->calpwstr.cElems; i++)
                bRet = pTokens->GrepW(pvar->calpwstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_BSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->cabstr.cElems; i++)
                bRet = pTokens->GrepW(pvar->cabstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_LPSTR:
        {
            for (UINT i = 0; !bRet && i < pvar->calpstr.cElems; i++)
                bRet = pTokens->GrepA(pvar->calpstr.pElems[i]);
            break;
        }

    case VT_VECTOR|VT_VARIANT:
        {
            for (UINT i = 0; !bRet && i < pvar->capropvar.cElems; i++)
                bRet = _PropVariantGrep(pvar->capropvar.pElems + i, pTokens);
            break;
        }

    case VT_BSTR|VT_ARRAY:
        {
            //  Only grep 1-dimensional arrays.
            UINT cDims = SafeArrayGetDim(pvar->parray);
            if (cDims == 1)
            {
                LONG lBound, uBound;
                if (SUCCEEDED(SafeArrayGetLBound(pvar->parray, 1, &lBound)) &&
                    SUCCEEDED(SafeArrayGetUBound(pvar->parray, 1, &uBound)) && 
                    uBound > lBound)
                {
                    BSTR *rgpbstr;
                    if (SUCCEEDED(SafeArrayAccessData(pvar->parray, (void **)&rgpbstr)))
                    {
                        for (int i = 0; !bRet && i <= (uBound - lBound); i++)
                        {
                            bRet = pTokens->GrepW(rgpbstr[i]);
                        }
                        SafeArrayUnaccessData(pvar->parray);
                    }
                }
            }
            else if (cDims > 1)
            {
                ASSERT(FALSE);    // we didn't expect > 1 dimension on bstr arrays!
            }
            break;
        }
    }
    return bRet;
}

CFilterGrep::CFilterGrep() 
    :   _hdpaGrepBuffers(NULL),
        _pTokens(NULL),
        _dwFlags(0),
        _pwszContentRestricted(NULL),
        _pwszPropertiesRestricted(NULL)
{ 
}

CFilterGrep::~CFilterGrep()  
{ 
    _ClearGrepBuffers();
    delete [] _pwszContentRestricted;
    delete [] _pwszPropertiesRestricted;
    delete _pTokens;
    if (_fcritsec)
    {
        DeleteCriticalSection(&_critsec);
    }
}


STDMETHODIMP CFilterGrep::InitSelf(void)
{
    if (_fcritsec == FALSE)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_critsec, 0))
        {
            return E_FAIL;
        }
        _fcritsec = TRUE;
    }
    return S_OK;
}

STDMETHODIMP CFilterGrep::Initialize(UINT nCodepage, LPCWSTR pszMatch, LPCWSTR pszExclude, DWORD dwFlags)
{
    Reset();
    
    if ((0 == (dwFlags & (FGIF_BLANKETGREP|FGIF_GREPFILENAME))) ||
        !((pszMatch && *pszMatch) || (pszExclude && *pszExclude)))
        return E_INVALIDARG;

    if (!(_pTokens || (_pTokens = new CGrepTokens) != NULL))
        return E_OUTOFMEMORY;

    _dwFlags = dwFlags;

    return _pTokens->Initialize(nCodepage, pszMatch, pszExclude, BOOLIFY(dwFlags & FGIF_CASESENSITIVE));
}


STDMETHODIMP CFilterGrep::Reset()
{
    if (_pTokens)
        _pTokens->Reset();
    _dwFlags = 0;
    return S_OK;
}

// converts non critical errors into S_FALSE, other return as FAILED(hr)
HRESULT _MapFilterCriticalError(HRESULT hr)
{
    switch (hr)
    {
    case FILTER_E_END_OF_CHUNKS:
    case FILTER_E_NO_MORE_TEXT:
    case FILTER_E_NO_MORE_VALUES:
    case FILTER_W_MONIKER_CLIPPED:
    case FILTER_E_NO_TEXT:
    case FILTER_E_NO_VALUES:
    case FILTER_E_EMBEDDING_UNAVAILABLE:
    case FILTER_E_LINK_UNAVAILABLE:
        hr = S_FALSE;
        break;
    }
    return hr;
}

// returns:
// S_OK match
// S_FALSE did not match

STDMETHODIMP CFilterGrep::Grep(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszName)
{
    HRESULT hr = S_FALSE;
    BOOL bHit = FALSE;
    ULONG ulFlags = IFILTER_FLAGS_OLE_PROPERTIES;   // default to try to use pss
    ULONG dwThread = GetCurrentThreadId();
    
    if (NULL == _pTokens)
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (_IsRestrictedFileType(pszName))
        return S_FALSE;

    // Grep the filename.
    if ((_dwFlags & FGIF_GREPFILENAME) && _pTokens->GrepW(pszName))
    {
        return S_OK;
    }

    IFilter *pFilter;
    if (SUCCEEDED(psf->BindToStorage(pidl, NULL, IID_PPV_ARG(IFilter, &pFilter))))
    {
        __try
        {
            hr = pFilter->Init(IFILTER_INIT_CANON_PARAGRAPHS |
                IFILTER_INIT_CANON_HYPHENS |
                IFILTER_INIT_CANON_SPACES |
                IFILTER_INIT_APPLY_INDEX_ATTRIBUTES |
                IFILTER_INIT_INDEXING_ONLY,
                0, 0, &ulFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_ABORT;
        }

        while (!bHit && (S_OK == hr))
        {
            STAT_CHUNK stat;
    
            __try
            {
                hr = pFilter->GetChunk(&stat);
                while ((S_OK == hr) && (0 == (stat.flags & (CHUNK_TEXT | CHUNK_VALUE))))
                {
                    TraceMsg(TF_WARNING, "CFilterGrep::Grep encountered bad/unknown type for chunk; skipping.");
                    hr = pFilter->GetChunk(&stat);
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_ABORT;
            }
    
            hr = _MapFilterCriticalError(hr);   // convert filter errors into S_FALSE
    
            if (S_OK == hr)
            {
                ULONG grfDescriminate = (_dwFlags & FGIF_BLANKETGREP);
        
                if (FGIF_BLANKETGREP == grfDescriminate ||
                    (_IsEqualAttribute(stat.attribute, FMTID_Storage, PID_STG_CONTENTS) ?
                    FGIF_GREPPROPERTIES == grfDescriminate : FGIF_GREPCONTENT == grfDescriminate))
                {
                    if (((stat.flags & CHUNK_VALUE) && S_OK == _GrepValue(pFilter, &stat)) ||
                        ((stat.flags & CHUNK_TEXT) && S_OK == _GrepText(pFilter, &stat, dwThread)))
                    {
                        bHit = TRUE;
                    }
                }
            }
        }
        pFilter->Release();
    }
    
    // Grep OLE/NFF properties if appropriate
    if (SUCCEEDED(hr))
    {
        if (!bHit && (ulFlags & IFILTER_FLAGS_OLE_PROPERTIES) && (_dwFlags & FGIF_BLANKETGREP))
        {
            IPropertySetStorage *pps;
            if (SUCCEEDED(psf->BindToStorage(pidl, NULL, IID_PPV_ARG(IPropertySetStorage, &pps))))
            {
                hr = _GrepProperties(pps);
                bHit = (S_OK == hr);
                pps->Release();
            }
        }
    }
    
    if (SUCCEEDED(hr))
        hr = bHit ? S_OK : S_FALSE;
    return hr;
}


STDMETHODIMP CFilterGrep::_GrepValue(IFilter* pFilter, STAT_CHUNK* pstat)
{
    PROPVARIANT* pvar = NULL;
    HRESULT      hr;

    __try
    {
        hr = pFilter->GetValue(&pvar);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_ABORT;
    }

    if (SUCCEEDED(hr))
    {
        hr = _PropVariantGrep(pvar, _pTokens) ? S_OK : S_FALSE;
        PropVariantClear(pvar);
        CoTaskMemFree(pvar);
    }
    return hr;
}

//  Greps OLE/NFF properties.
STDMETHODIMP CFilterGrep::_GrepProperties(IPropertySetStorage *pss)
{
    BOOL bHit = FALSE;
    
    IEnumSTATPROPSETSTG* pEnumSet;
    
    if (SUCCEEDED(pss->Enum(&pEnumSet)))
    {
        STATPROPSETSTG statSet[8];
        DWORD cSets = 0;
        while (!bHit && 
               SUCCEEDED(pEnumSet->Next(ARRAYSIZE(statSet), statSet, &cSets)) && cSets)
        {
            for (UINT i = 0; !bHit && i < cSets; i++)
            {
                IPropertyStorage *pstg;
                if (SUCCEEDED(pss->Open(statSet[i].fmtid, STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, &pstg)))
                {
                     bHit = (S_OK == _GrepEnumPropStg(pstg));
                     pstg->Release();
                }
            }
        }
        pEnumSet->Release();
    }
    
    return bHit ? S_OK : S_FALSE;
}

#define PROPGREPBUFSIZE  16

//  Reads and greps a block of properties described by a 
//  caller-supplied array of PROPSPECs.
STDMETHODIMP CFilterGrep::_GrepPropStg(IPropertyStorage *pstg, ULONG cspec, PROPSPEC rgspec[])
{
    PROPVARIANT rgvar[PROPGREPBUFSIZE] = {0}, // stack buffer
                *prgvar = rgvar;
    BOOL        bHit = FALSE;

    if (cspec > ARRAYSIZE(rgvar)) // stack buffer large enough?
    {
        if (NULL == (prgvar = new PROPVARIANT[cspec]))
            return E_OUTOFMEMORY;
    }

    //  Read properties:

    HRESULT hr = pstg->ReadMultiple(cspec, rgspec, prgvar);
    if (SUCCEEDED(hr))
    {
        for (UINT i = 0; i < cspec; i++)
        {
            if (!bHit)
                bHit = _PropVariantGrep(prgvar + i, _pTokens);
            PropVariantClear(rgvar + i);
        }
    }

    if (prgvar != rgvar)
        delete [] prgvar;

    if (SUCCEEDED(hr))
        return bHit ? S_OK : S_FALSE;

    return hr;
}

//  Enumerates and greps all properties in a property set
STDMETHODIMP CFilterGrep::_GrepEnumPropStg(IPropertyStorage* pstg)
{
    BOOL bHit = FALSE;
    IEnumSTATPROPSTG* pEnumStg;
    if (SUCCEEDED(pstg->Enum(&pEnumStg)))
    {
        STATPROPSTG statProp[PROPGREPBUFSIZE];
        DWORD cProps;

        while (!bHit && 
               SUCCEEDED(pEnumStg->Next(ARRAYSIZE(statProp), statProp, &cProps)) && cProps)
        {
            PROPSPEC rgspec[PROPGREPBUFSIZE] = {0};
            for (UINT i = 0; (i < cProps) && (i < ARRAYSIZE(rgspec)); i++)
            {
                rgspec[i].ulKind = PRSPEC_PROPID;
                rgspec[i].propid = statProp[i].propid;
                CoTaskMemFree(statProp[i].lpwstrName);
            }

            bHit = (S_OK == _GrepPropStg(pstg, cProps, rgspec));
        }
        
        pEnumStg->Release();
    }

    return bHit ? S_OK : S_FALSE;
}


//  Reports whether the indicated unicode character is a 
//  word-breaking character.
inline BOOL _IsWordBreakCharW(IN LPWSTR pszBuf, IN ULONG ich)
{
    WORD wChar;
    return GetStringTypeW(CT_CTYPE1, pszBuf + ich, 1, &wChar) 
           && (wChar & (C1_SPACE|C1_PUNCT|C1_CNTRL|C1_BLANK));
}


//  Finds the last word-breaking character.
LPWSTR _FindLastWordBreakW(IN LPWSTR pszBuf, IN ULONG cch)
{
    while(--cch)
    {
        if (_IsWordBreakCharW(pszBuf, cch))
            return pszBuf + cch;
    }
    return NULL;
}


// {c1243ca0-bf96-11cd-b579-08002b30bfeb}
const CLSID CLSID_PlainTextFilter = {0xc1243ca0, 0xbf96, 0x11cd, {0xb5, 0x79, 0x08, 0x00, 0x2b, 0x30, 0xbf, 0xeb}};

void _ReplaceNulsWithSpaces(LPWSTR pszBuf, UINT cch)
{
    LPWSTR pszEnd = pszBuf + cch;
    while (pszBuf < pszEnd)
    {
        if (*pszBuf == 0)
        {
            *pszBuf = TEXT(' ');
        }
        pszBuf++;
    }
}

STDMETHODIMP CFilterGrep::_GrepText(IFilter* pFilter, STAT_CHUNK* pstat, DWORD dwThreadID)
{
    ASSERT(pstat);

    LPWSTR  pszBuf = NULL;
    ULONG   cchBuf = pstat->cwcLenSource ? 
                pstat->cwcLenSource : DEFAULT_GREPBUFFERSIZE;
    
    HRESULT hr = _GetThreadGrepBuffer(dwThreadID, cchBuf, &pszBuf);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszFetch = pszBuf, 
               pszTail  = NULL;
        ULONG  cchFetch = cchBuf, 
               cchTail  = 0;
   
        //  Fetch first block of text

        __try
        {
            hr = pFilter->GetText(&cchFetch, pszFetch);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_ABORT;
        }

        CLSID clsid = {0};    
        IUnknown_GetClassID(pFilter, &clsid);   // to workaround a bug in the text filter

        while (SUCCEEDED(hr) && cchFetch)
        {
            ASSERT((cchFetch + cchTail) <= cchBuf);

            _ReplaceNulsWithSpaces(pszBuf, cchFetch + cchTail);     // Let us work over binary files too
            pszBuf[cchFetch + cchTail] = 0; // don't trust filter to zero-terminate buffer.

            // When you get the FILTER_S_LAST_TEXT, that's it, you'll get no more text, so treat the tail part as part of the text
            if (hr == FILTER_S_LAST_TEXT)
            {
                pszTail = NULL;
                cchTail = 0;
            }
            else if (CLSID_PlainTextFilter == clsid)
            {
                // CLSID_PlainText filter always returns S_OK, instead of FILTER_S_LAST_TEXT, this forces us to scan
                // the entire chunk now, AND (see below) to pass it off as a tail for scanning next chunk too.
                // pszTail and cchTail are set below.
            }
            else
            {
                pszTail = _FindLastWordBreakW(pszBuf, cchFetch + cchTail);
                if (pszTail)
                {
                    // Break on word boundary and leave remainder (tail) for next iteration
                    *pszTail = TEXT('\0');
                    pszTail++;
                    cchTail = lstrlenW(pszTail);
                }
                else
                {
                    // Wow, big block, with no word break, search its entirety.
                    // REVIEW:  cross chunk items won't be found
                    pszTail = NULL;
                    cchTail = 0;
                }
            }

            //  do the string scan
            if (_pTokens->GrepW(pszBuf))
            {
                *pszBuf = 0;
                return S_OK;
            }
            else if (FILTER_S_LAST_TEXT == hr)
            {
                *pszBuf = 0;
                return S_FALSE;
            }

            //  prepare for next fetch...

            // If it is the plaintext filter, grab the tail anyway, even though we've tested it already
            // WinSE 25867

            if (CLSID_PlainTextFilter == clsid)
            {
                pszTail = _FindLastWordBreakW(pszBuf, cchFetch + cchTail);
                if (pszTail)
                {
                    *pszTail = TEXT('\0');
                    pszTail++;
                    cchTail = lstrlenW(pszTail);
                }
                else
                {
                    pszTail = NULL;
                    cchTail = 0;
                }
            }

            //  prepare for next fetch...
            *pszBuf  = 0;
            pszFetch = pszBuf;
            cchFetch = cchBuf;

            //  If there is a tail to deal with, move it to the front of
            //  the buffer and prepare to have the next block of incoming text
            //  appended to the tail..
            if (pszTail && cchTail)
            {
                MoveMemory(pszBuf, pszTail, cchTail * sizeof(*pszTail));
                pszBuf[cchTail] = 0;
                pszFetch += cchTail;
                cchFetch -= cchTail;
            }

            //  Fetch next block of text.
            __try
            {
                hr = pFilter->GetText(&cchFetch, pszFetch);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_ABORT;
            }
        }
    }

    if (SUCCEEDED(hr) || FILTER_E_NO_MORE_TEXT == hr || FILTER_E_NO_TEXT == hr)
        return S_FALSE;

    return hr;
}


//  Returns a grep buffer of the requested size for the specified thread.
STDMETHODIMP CFilterGrep::_GetThreadGrepBuffer(
    DWORD dwThreadID, 
    ULONG cchNeed, 
    LPWSTR* ppszBuf)
{
    ASSERT(dwThreadID);
    ASSERT(cchNeed > 0);
    ASSERT(ppszBuf);

    HRESULT hr = E_FAIL;
    *ppszBuf = NULL;
    
    _EnterCritical();
    
    if (_hdpaGrepBuffers || (_hdpaGrepBuffers = DPA_Create(4)) != NULL)
    {
        CGrepBuffer *pgb, *pgbCached = NULL;

        for (int i = 0, cnt = DPA_GetPtrCount(_hdpaGrepBuffers); i < cnt; i++)
        {
            pgb = (CGrepBuffer*)DPA_FastGetPtr(_hdpaGrepBuffers, i);
            if (pgb->IsThread(dwThreadID))
            {
                pgbCached = pgb;
                hr = pgbCached->Alloc(cchNeed);
                if (S_OK == hr)
                    *ppszBuf = pgbCached->Buffer();
                break;
            }
        }
        
        if (NULL == pgbCached) //  not cached?
        {
            if ((pgb = new CGrepBuffer(dwThreadID)) != NULL)
            {
                hr = pgb->Alloc(cchNeed);
                if (S_OK == hr)
                {
                    *ppszBuf = pgb->Buffer();
                    DPA_AppendPtr(_hdpaGrepBuffers, pgb);
                }
                else
                    delete pgb;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    _LeaveCritical();
    return hr;
}


//  Clears grep buffer for all threads
STDMETHODIMP_(void) CFilterGrep::_ClearGrepBuffers()
{
    _EnterCritical();

    if (_hdpaGrepBuffers)
    {
        while(DPA_GetPtrCount(_hdpaGrepBuffers))
        {
            CGrepBuffer* pgb = (CGrepBuffer*)DPA_DeletePtr(_hdpaGrepBuffers, 0);
            delete pgb;
        }

        DPA_Destroy(_hdpaGrepBuffers);
        _hdpaGrepBuffers = NULL;
    }

    _LeaveCritical();
}


//  Reports whether the file type is restricted from full-text grep.
STDMETHODIMP_(BOOL) CFilterGrep::_IsRestrictedFileType(LPCWSTR pwszFile)
{
    return FALSE;
}

STDMETHODIMP CFilterGrep::GetMatchTokens(OUT LPWSTR pszTokens, UINT cchTokens) const
{
    HRESULT hr = _pTokens ? _pTokens->GetMatchTokens(pszTokens, cchTokens) : S_FALSE;
    if (S_OK != hr && pszTokens)
        *pszTokens = 0;
    return hr;
}


STDMETHODIMP CFilterGrep::GetExcludeTokens(OUT LPWSTR pszTokens, UINT cchTokens) const
{
    HRESULT hr = _pTokens ? _pTokens->GetExcludeTokens(pszTokens, cchTokens) : S_FALSE;
    if (S_OK != hr && pszTokens)
        *pszTokens = 0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findcmd.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "dspsprt.h"
#include "findfilter.h"
#include "cowsite.h"
#include "cobjsafe.h"
#include "cnctnpt.h"
#include "stdenum.h"
#include "exdisp.h"
#include "exdispid.h"
#include "shldisp.h"
#include "shdispid.h"
#include "dataprv.h"
#include "ids.h"
#include "views.h"
#include "findband.h"

#define WM_DF_SEARCHPROGRESS        (WM_USER + 42)
#define WM_DF_ASYNCPROGRESS         (WM_USER + 43)
#define WM_DF_SEARCHSTART           (WM_USER + 44)
#define WM_DF_SEARCHCOMPLETE        (WM_USER + 45)
#define WM_DF_FSNOTIFY              (WM_USER + 46)

STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

typedef struct 
{
    BSTR        bstrName;
    VARIANT     vValue;
} CMD_CONSTRAINT; 

typedef struct _foo_
{
    LPTSTR  pszDotType;
    LPTSTR  pszDefaultValueMatch;
    LPTSTR  pszGuid;                // If NULL, patch either pszDefaultValueMatch, or pszDotType whichever you find
} TYPE_FIX_ENTRY;

class CFindCmd : public ISearchCommandExt,
                   public CImpIDispatch, 
                   public CObjectWithSite, 
                   public IConnectionPointContainer,
                   public IProvideClassInfo2,
                   public CSimpleData,
                   public IRowsetWatchNotify,
                   public IFindControllerNotify
{    
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // IConnectionPointContainer
    STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

    // IProvideClassInfo
    STDMETHOD(GetClassInfo)(ITypeInfo **ppTI);

    // IProvideClassInfo2
    STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID *pGUID);

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite);

    // ISearchCommandExt
    STDMETHOD(ClearResults)(void);
    STDMETHOD(NavigateToSearchResults)(void);
    STDMETHOD(get_ProgressText)(BSTR *pbs);
    STDMETHOD(SaveSearch)(void);
    STDMETHOD(RestoreSearch)(void);
    STDMETHOD(GetErrorInfo)(BSTR *pbs,  int *phr);
    STDMETHOD(SearchFor)(int iFor);
    STDMETHOD(GetScopeInfo)(BSTR bsScope, int *pdwScopeInfo);
    STDMETHOD(RestoreSavedSearch)(VARIANT *pvarFile);
    STDMETHOD(Execute)(VARIANT *RecordsAffected, VARIANT *Parameters, long Options);
    STDMETHOD(AddConstraint)(BSTR Name, VARIANT Value);        
    STDMETHOD(GetNextConstraint)(VARIANT_BOOL fReset, DFConstraint **ppdfc);

    // IRowsetWatchNotify
    STDMETHODIMP OnChange(IRowset *prowset, DBWATCHNOTIFY eChangeReason);

    // IFindControllerNotify
    STDMETHODIMP DoSortOnColumn(UINT iCol, BOOL fSameCol);
    STDMETHODIMP StopSearch(void);
    STDMETHODIMP GetItemCount(UINT *pcItems);
    STDMETHODIMP SetItemCount(UINT cItems);
    STDMETHODIMP ViewDestroyed();

    CFindCmd();
    HRESULT Init(void);

    int _CompareCallback(IShellFolder *psf, IFindFolder *pff, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    static int _CompareCallbackStub(void *p1, void *p2, LPARAM lParam);

private:
    ~CFindCmd();
    HRESULT _GetSearchIDList(LPITEMIDLIST *ppidl);
    HRESULT _SetEmptyText(UINT nID);
    HRESULT _Clear();
    void _SelectResults();
    HWND _GetWindow();

    struct THREAD_PARAMS {
        CFindCmd    *pThis;
        IFindEnum   *penum;
        IShellFolder        *psf;
        IFindFolder         *pff;
        IShellFolderView    *psfv;
    };

    struct DEFER_UPDATE_DIR {
        struct DEFER_UPDATE_DIR *pdudNext;
        LPITEMIDLIST            pidl;
        BOOL                    fRecurse;
    };

    // Internal class to handle notifications from top level browser
    class CWBEvents2: public DWebBrowserEvents, DWebBrowserEvents2
    {
    public:
        STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void) { return _pcdfc->AddRef();}
        STDMETHOD_(ULONG, Release)(void) { return _pcdfc->Release();}
    
        // (DwebBrowserEvents)IDispatch
        STDMETHOD(GetTypeInfoCount)(UINT * pctinfo) { return E_NOTIMPL;}
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL;}
        STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) { return E_NOTIMPL;}
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

        // Some helper functions...
        void SetOwner(CFindCmd *pcdfc) { _pcdfc = pcdfc; }  // Don't addref as part of larger object... }
        void SetWaiting(BOOL fWait) {_fWaitingForNavigate = fWait;}

    protected:
        // Internal variables...
        CFindCmd *_pcdfc;     // pointer to top object... could cast, but...
        BOOL _fWaitingForNavigate;   // Are we waiting for the navigate to search resluts?
    };

    friend class CWBEvents2;
    CWBEvents2              _cwbe;
    IConnectionPoint        *_pcpBrowser;   // hold onto browsers connection point;
    ULONG                   _dwCookie;      // Cookie returned by Advise

    HRESULT                 _UpdateFilter(IFindFilter *pfilter);
    void                    _ClearConstraints();
    static DWORD CALLBACK   _ThreadProc(void *pv);
    void                    _DoSearch(IFindEnum *penum, IShellFolder *psf, IFindFolder *pff, IShellFolderView *psfv);
    HRESULT                 _Start(BOOL fNavigateIfFail, int iCol, LPCITEMIDLIST pidlUpdate);
    HRESULT                 _Cancel();
    HRESULT                 _Init(THREAD_PARAMS **ppParams, int iCol, LPCITEMIDLIST pidlUpdate);
    static HRESULT          _FreeThreadParams(THREAD_PARAMS *ptp);
    HRESULT                 _ExecData_Init();
    HRESULT                 _EnsureResultsViewIsCurrent(IUnknown *punk);
    HRESULT                 _ExecData_Release();
    BOOL                    _SetupBrowserCP();
    void cdecl              _NotifyProgressText(UINT ids,...);
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void                    _PTN_SearchProgress(void);
    void                    _PTN_AsyncProgress(int nPercentComplete, DWORD cAsync);
    void                    _PTN_SearchComplete(HRESULT hr, BOOL fAbort);
    void                    _OnChangeNotify(LONG code, LPITEMIDLIST *ppidl);
    void                    _DeferHandleUpdateDir(LPCITEMIDLIST pidl, BOOL bRecurse);
    void                    _ClearDeferUpdateDirList();
    void                    _ClearItemDPA(HDPA hdpa);
    HRESULT                 _SetLastError(HRESULT hr);
    void                    _SearchResultsCLSID(CLSID *pclsid) { *pclsid = _clsidResults; };
    IUnknown*               _GetObjectToPersist();
    HRESULT                 _ForcedUnadvise(void);
    void                    _PostMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT                 _GetShellView(REFIID riid, void **ppv);
    BOOL                    _FixPersistHandler(LPCTSTR pszBase, LPCTSTR pszDefaultHandler);
    void                    _ProcessTypes(const TYPE_FIX_ENTRY *ptfeTypes, UINT cTypes, TCHAR *pszClass);
    void                    _FixBrokenTypes(void);

    // These are the things that the second thread will use during it's processing...
    struct {
        CRITICAL_SECTION    csSearch;
        BOOL                fcsSearch;
        HWND                hwndThreadNotify;
        HDPA                hdpa;
        DWORD               dwTimeLastNotify;   
        BOOL                fFilesAdded : 1;
        BOOL                fDirChanged : 1;
        BOOL                fUpdatePosted : 1;
    } _updateParams; // Pass callback params through this object to avoid alloc/free cycle

    struct {
        IShellFolder        *psf;
        IShellFolderView    *psfv;
        IFindFolder         *pff;
        TCHAR               szProgressText[MAX_PATH];
    } _execData;

private:
    LONG                _cRef;
    HDSA                _hdsaConstraints;
    DWORD               _cExecInProgress;
    BOOL                _fAsyncNotifyReceived;
    BOOL                _fDeferRestore;
    BOOL                _fDeferRestoreTried;
    BOOL                _fContinue;
    BOOL                _fNew;
    CConnectionPoint    _cpEvents;
    OLEDBSimpleProviderListener *_pListener;
    HDPA                _hdpaItemsToAdd1;
    HDPA                _hdpaItemsToAdd2;
    TCHAR               _szProgressText[MAX_PATH+40];   // progress text leave room for chars...
    LPITEMIDLIST        _pidlUpdate;                    // Are we processing an updatedir?
    LPITEMIDLIST        _pidlRestore;                   // pidl to do restore from...
    struct DEFER_UPDATE_DIR *_pdudFirst;                  // Do we have any defered update dirs?
    HRESULT             _hrLastError;                   // the last error reported.
    UINT                _uStatusMsgIndex;               // Files or computers found...
    CRITICAL_SECTION    _csThread;
    BOOL                _fcsThread;
    DFBSAVEINFO         _dfbsi;
    CLSID               _clsidResults;
};


class CFindConstraint: public DFConstraint, public CImpIDispatch 
{    
public:
    // IUnknown
    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);        
    STDMETHOD_(ULONG, Release)(void);

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT * pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // DFConstraint
    STDMETHOD(get_Name)(BSTR *pbs);
    STDMETHOD(get_Value)(VARIANT *pvar);

    CFindConstraint(BSTR bstr, VARIANT var);
private:
    ~CFindConstraint();
    LONG                _cRef;
    BSTR                _bstr;
    VARIANT             _var;
};

CFindCmd::CFindCmd() : CImpIDispatch(LIBID_Shell32, 1, 0, IID_ISearchCommandExt), CSimpleData(&_pListener)
{
    _cRef = 1;
    _fAsyncNotifyReceived = 0;
    _fContinue = TRUE;
    ASSERT(NULL == _pidlRestore);

    ASSERT(_cExecInProgress == 0);

    _clsidResults = CLSID_DocFindFolder;    // default

    _cpEvents.SetOwner(SAFECAST(this, ISearchCommandExt *), &DIID_DSearchCommandEvents);
}

HRESULT CFindCmd::Init(void)
{
    _hdsaConstraints = DSA_Create(sizeof(CMD_CONSTRAINT), 4);
    if (!_hdsaConstraints)
        return E_OUTOFMEMORY;

    if (!_updateParams.fcsSearch)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_updateParams.csSearch, 0))
        {
            return E_FAIL;
        }
        _updateParams.fcsSearch = TRUE;
    }

    if (!_fcsThread)
    {
        if (!InitializeCriticalSectionAndSpinCount(&_csThread,0))
        {
            return E_FAIL;
        }
        _fcsThread = TRUE;
    }

    return S_OK;
}

CFindCmd::~CFindCmd()
{
    if (_updateParams.hwndThreadNotify)
    {
        // make sure no outstanding fsnotifies registered.
        SHChangeNotifyDeregisterWindow(_updateParams.hwndThreadNotify);
        DestroyWindow(_updateParams.hwndThreadNotify);
    }

    _ClearConstraints();
    DSA_Destroy(_hdsaConstraints);
    _ExecData_Release();

    if (_updateParams.fcsSearch)
    {
        DeleteCriticalSection(&_updateParams.csSearch);
    }

    if (_fcsThread)
    {
        DeleteCriticalSection(&_csThread);
    }

    // Make sure we have removed all outstanding update dirs...
    _ClearDeferUpdateDirList();

    if (_hdpaItemsToAdd1)
        DPA_Destroy(_hdpaItemsToAdd1);

    if (_hdpaItemsToAdd2)
        DPA_Destroy(_hdpaItemsToAdd2);

    ILFree(_pidlRestore);
}

STDMETHODIMP CFindCmd::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindCmd, ISearchCommandExt),
        QITABENTMULTI(CFindCmd, IDispatch, ISearchCommandExt),
        QITABENT(CFindCmd, IProvideClassInfo2),
        QITABENTMULTI(CFindCmd, IProvideClassInfo,IProvideClassInfo2),
        QITABENT(CFindCmd, IObjectWithSite),
        QITABENT(CFindCmd, IConnectionPointContainer),
        QITABENT(CFindCmd, OLEDBSimpleProvider),
        QITABENT(CFindCmd, IRowsetWatchNotify),
        QITABENT(CFindCmd, IFindControllerNotify),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindCmd::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindCmd::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDispatch implementation

STDMETHODIMP CFindCmd::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFindCmd::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFindCmd::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP CFindCmd::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

// ADOCommand implementation, dual interface method callable via script

STDMETHODIMP CFindCmd::AddConstraint(BSTR bstrName, VARIANT vValue)
{
    HRESULT hr = E_OUTOFMEMORY;

    CMD_CONSTRAINT dfcc = {0};
    dfcc.bstrName = SysAllocString(bstrName);
    if (dfcc.bstrName)
    {
        hr = VariantCopy(&dfcc.vValue, &vValue);
        if (SUCCEEDED(hr))
        {
            if (DSA_ERR == DSA_InsertItem(_hdsaConstraints, DSA_APPEND, &dfcc))
            {
                SysFreeString(dfcc.bstrName);
                VariantClear(&dfcc.vValue);
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            SysFreeString(dfcc.bstrName);
        }
    }
    return hr;
}

STDMETHODIMP CFindCmd::GetNextConstraint(VARIANT_BOOL fReset, DFConstraint **ppdfc)
{
    *ppdfc = NULL;

    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr))
    {
        BSTR bName;
        VARIANT var;
        VARIANT_BOOL fFound;
        hr = pfilter->GetNextConstraint(fReset, &bName, &var, &fFound);
        if (SUCCEEDED(hr))
        {
            if (!fFound)
            {
                // need a simple way to signal end list, how about an empty name string?
                bName = SysAllocString(L"");
            }
            CFindConstraint *pdfc = new CFindConstraint(bName, var);
            if (pdfc)
            {
                hr = pdfc->QueryInterface(IID_PPV_ARG(DFConstraint, ppdfc));
                pdfc->Release();
            }
            else
            {
                // error release stuff we allocated.
                hr = E_OUTOFMEMORY;
                SysFreeString(bName);
                VariantClear(&var);
            }
        }
        pfilter->Release();
    }
    return hr;
}

HRESULT CFindCmd::_UpdateFilter(IFindFilter *pfilter)
{
    HRESULT hr = S_OK;

    pfilter->ResetFieldsToDefaults();

    int cNumParams = DSA_GetItemCount(_hdsaConstraints); 
    for (int iItem = 0; iItem < cNumParams; iItem++)
    {
        CMD_CONSTRAINT *pdfcc = (CMD_CONSTRAINT *)DSA_GetItemPtr(_hdsaConstraints, iItem);
        if (pdfcc)
        {
            hr = pfilter->UpdateField(pdfcc->bstrName, pdfcc->vValue);
        }
    }

    // And clear out the constraint list...
    _ClearConstraints();
    return hr;
}

void CFindCmd::_ClearConstraints()
{
    int cNumParams = DSA_GetItemCount(_hdsaConstraints); 
    for (int iItem = 0; iItem < cNumParams; iItem++)
    {
        CMD_CONSTRAINT *pdfcc = (CMD_CONSTRAINT *)DSA_GetItemPtr(_hdsaConstraints, iItem);
        if (pdfcc)
        {
            SysFreeString(pdfcc->bstrName);
            VariantClear(&pdfcc->vValue);
        }
    }
    DSA_DeleteAllItems(_hdsaConstraints);
}

void cdecl CFindCmd::_NotifyProgressText(UINT ids,...)
{
    BOOL fOk = FALSE;

    va_list ArgList;
    va_start(ArgList, ids);
    LPTSTR psz = _ConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(ids), &ArgList);
    va_end(ArgList);

    if (psz)
    {
        HRESULT hr = StringCchCopy(_szProgressText, ARRAYSIZE(_szProgressText), psz);
        if (SUCCEEDED(hr))
        {
            fOk = TRUE;
        }

        LocalFree(psz);
    }

    if (!fOk)
    {
        _szProgressText[0] = 0;
    }

    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_PROGRESSTEXT);
}

STDAPI CDocFindCommand_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFindCmd *pfc = new CFindCmd();
    if (pfc)
    {
        hr = pfc->Init();
        if (SUCCEEDED(hr))
            hr = pfc->QueryInterface(riid, ppv);
        pfc->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;    
}


int CFindCmd::_CompareCallback(IShellFolder *psf, IFindFolder *pff, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    int iResult = pff->GetFolderIndex(pidl1) - pff->GetFolderIndex(pidl2);

    if (iResult == 0)
    {
        WCHAR szName1[MAX_PATH], szName2[MAX_PATH];

        iResult = 1;        // If we fail, at least return a non-equal indicator

        // Get the name for 1 - We use SHGDN_FORADDRESSBAR for perf, if you
        // check out the pff->GetDisplayNameOf you'll see that it tries to
        // trink SHGDN_INFOLDER to ~SHGND_INFOLDER so that name comparisons
        // use the full name.  We've already distinguished folders above, so
        // for speed we can avoid that with SHGDN_FORADDRESSBAR.
        HRESULT hr = DisplayNameOf(psf, pidl1, SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szName1, ARRAYSIZE(szName1));
        if (SUCCEEDED(hr))
        {
            // Get the name for 2
            hr = DisplayNameOf(psf, pidl2, SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szName2, ARRAYSIZE(szName2));
            if (SUCCEEDED(hr))
            {
                // Compare and set value
                iResult = StrCmpICW(szName1, szName2);
            }
        }
    }
    return iResult;
}

typedef struct
{
    CFindCmd *pthis;
    IShellFolder *psf;
    IFindFolder *pff;
} CFC_CALLBACK_INFO;

int CFindCmd::_CompareCallbackStub(void *p1, void *p2, LPARAM lParam)
{
    CFC_CALLBACK_INFO *pcci = (CFC_CALLBACK_INFO *)lParam;

    LPITEMIDLIST pidl1 = (LPITEMIDLIST)p1;
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)p2;

    return pcci->pthis->_CompareCallback(pcci->psf, pcci->pff, pidl1, pidl2);
}


void CFindCmd::_PTN_SearchProgress(void)
{
    HRESULT hr = S_OK;
    HDPA hdpa = _updateParams.hdpa;
    if (hdpa) 
    {
        // Ok lets swap things out from under other thread so that we can process it and still
        // let the other thread run...
        EnterCriticalSection(&_updateParams.csSearch);

        if (_updateParams.hdpa == _hdpaItemsToAdd2)
            _updateParams.hdpa = _hdpaItemsToAdd1;
        else
            _updateParams.hdpa = _hdpaItemsToAdd2;

        // say that we don't have any thing here such that other thread will reset up...
        _updateParams.fFilesAdded = FALSE;
        BOOL fDirChanged = _updateParams.fDirChanged;
        _updateParams.fDirChanged = FALSE;

        LeaveCriticalSection(&_updateParams.csSearch);

        int cItemsToAdd = DPA_GetPtrCount(hdpa);

        if (!_execData.pff)
            return;
            
        int iItem;
        _execData.pff->GetItemCount(&iItem);
        int iItemStart = iItem + 1;     // needed for notifies 1 based.

        if (cItemsToAdd)
        {
            if (_fContinue)
            {
                // Are we in an updatedir?  If so then need to do merge, else...
                if (_pidlUpdate)
                {
                    UINT iFolderIndexMin;
                    UINT iFolderIndexMax;
                    UINT iFolderIndex;
                    LPITEMIDLIST pidl;
                    int cItems = iItem;        
                    CFC_CALLBACK_INFO cci;

                    cci.pthis = this;
                    cci.psf = _execData.psf;    // these are weak references
                    cci.pff = _execData.pff;    // these are weak references

                    pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, 0);
                    iFolderIndexMin = _execData.pff->GetFolderIndex(pidl);
                    pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, cItemsToAdd-1);
                    iFolderIndexMax = _execData.pff->GetFolderIndex(pidl);

                    int i;
                    for (int j = cItems - 1; j >= 0; j--)
                    {
                        FIND_ITEM *pfi;
                        _execData.pff->GetItem(j, &pfi);

                        if (pfi && (pfi->dwState & CDFITEM_STATE_MAYBEDELETE) != 0)
                        {
                            iFolderIndex = _execData.pff->GetFolderIndex(&pfi->idl);

                            if (iFolderIndex >= iFolderIndexMin && iFolderIndex <= iFolderIndexMax)
                            {
                                i = DPA_Search(hdpa, &pfi->idl, 0, _CompareCallbackStub, (LPARAM)&cci, DPAS_SORTED);

                                if (DPA_ERR != i)
                                {
                                    pfi->dwState &= ~CDFITEM_STATE_MAYBEDELETE;
                                    pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                                    DPA_DeletePtr(hdpa, i);
                                    ILFree(pidl);
                                }
                            }
                        }
                    }

                    for (i = DPA_GetPtrCount(hdpa) - 1; i >= 0; i--)
                    {
                        pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, i);

                        // Not already in the list so add it...
                        hr = _execData.pff->AddPidl(iItem, pidl, -1, NULL);
                        if (SUCCEEDED(hr))
                        {
                            iItem++;
                        }

                        DPA_DeletePtr(hdpa, i);
                        ILFree(pidl);
                    }
                    if (iItem && _execData.psfv)
                    {
                        hr = _execData.psfv->SetObjectCount(iItem, SFVSOC_NOSCROLL);
                    }
                } 
                else 
                {
                    if (_pListener)
                        _pListener->aboutToInsertRows(iItemStart, cItemsToAdd);
                    
                    for (int i = 0; i < cItemsToAdd; i++) 
                    {
                        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_FastGetPtr(hdpa, i);
                        hr = _execData.pff->AddPidl(iItem, pidl, -1, NULL);
                        if (SUCCEEDED(hr))
                            iItem++;
                        ILFree(pidl);   // AddPidl makes a copy
                    }
        
                    if (iItem >= iItemStart)
                    {
                        if (_execData.psfv)
                            hr = _execData.psfv->SetObjectCount(iItem, SFVSOC_NOSCROLL);
                
                        _execData.pff->SetItemsChangedSinceSort();
                        _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_UPDATE);
                    }

                    if (_pListener) 
                    {
                        _pListener->insertedRows(iItemStart, cItemsToAdd);
                        _pListener->rowsAvailable(iItemStart, cItemsToAdd);
                    }
                }
            }
            else  // _fContinue
            {
                for (int i = 0; i < cItemsToAdd; i++)
                {
                    ILFree((LPITEMIDLIST)DPA_FastGetPtr(hdpa, i));
                }
            }
            DPA_DeleteAllPtrs(hdpa);
        }

        if (fDirChanged) 
        {
            _NotifyProgressText(IDS_SEARCHING, _execData.szProgressText);
        }
    }
    
    _updateParams.dwTimeLastNotify = GetTickCount();
    _updateParams.fUpdatePosted = FALSE;
}

void CFindCmd::_PTN_AsyncProgress(int nPercentComplete, DWORD cAsync)
{
    if (!_execData.pff)
        return;
    // Async case try just setting the count...
    _execData.pff->SetAsyncCount(cAsync);
    if (_execData.psfv) 
    {
        // -1 for the first item means verify visible items only
        _execData.pff->ValidateItems(_execData.psfv, -1, -1, FALSE);
        _execData.psfv->SetObjectCount(cAsync, SFVSOC_NOSCROLL);
    }

    _execData.pff->SetItemsChangedSinceSort();
    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_UPDATE);
    _NotifyProgressText(IDS_SEARCHINGASYNC, cAsync, nPercentComplete);
}

void CFindCmd::_ClearItemDPA(HDPA hdpa)
{
    if (hdpa)
    {
        EnterCriticalSection(&_updateParams.csSearch);
        int cItems = DPA_GetPtrCount(hdpa);
        for (int i = 0; i < cItems; i++) 
        {
            ILFree((LPITEMIDLIST)DPA_GetPtr(hdpa, i));
        }
        DPA_DeleteAllPtrs(hdpa);
        LeaveCriticalSection(&_updateParams.csSearch);
    }
}

void CFindCmd::_PTN_SearchComplete(HRESULT hr, BOOL fAbort)
{
    int iItem;

    // someone clicked on new button -- cannot set no files found text in listview
    // because we'll overwrite enter search criteria to begin
    if (!_fNew)
        _SetEmptyText(IDS_FINDVIEWEMPTY);
    _SetLastError(hr);

    // _execData.pff is NULL when Searh is complete by navigating away from the search page
    if (!_execData.pff)
    {
        // do clean up of hdpaToItemsToadd1 and 2
        // make sure all items in buffer 1 and 2 are empty
        _ClearItemDPA(_hdpaItemsToAdd1);
        _ClearItemDPA(_hdpaItemsToAdd2);
    }
    else
    {
        // if we have a _pidlUpdate are completing an update
        if (_pidlUpdate)
        {
            int i, cPidf;
            UINT uItem;

            _execData.pff->GetItemCount(&i);
            for (; i-- > 0;)
            {
                // Pidl at start of structure...
                FIND_ITEM *pfi;
                HRESULT hr = _execData.pff->GetItem(i, &pfi);
                if (SUCCEEDED(hr) && pfi->dwState & CDFITEM_STATE_MAYBEDELETE)
                {
                    _execData.psfv->RemoveObject(&pfi->idl, &uItem);
                }
            }                  

            ILFree(_pidlUpdate);
            _pidlUpdate = NULL;

            // clear the update dir flags
            _execData.pff->GetFolderListItemCount(&cPidf);
            for (i = 0; i < cPidf; i++)
            {
                FIND_FOLDER_ITEM *pdffli;
            
                if (SUCCEEDED(_execData.pff->GetFolderListItem(i, &pdffli)))
                    pdffli->fUpdateDir = FALSE;
            }
        }

        // Release our reference count on the searching.
        if (_cExecInProgress)
            _cExecInProgress--;

        // Tell everyone the final count and that we are done...
        // But first check if there are any cached up Updatedirs to be processed...
        if (_pdudFirst) 
        {
            // first unlink the first one...
            struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
            _pdudFirst = pdud->pdudNext;

            if (_execData.pff->HandleUpdateDir(pdud->pidl, pdud->fRecurse)) 
            {
                // Need to spawn sub-search on this...
                _Start(FALSE, -1, pdud->pidl);
            }
            ILFree(pdud->pidl);
            LocalFree((HLOCAL)pdud);
        } 
        else 
        {
            if (_execData.psfv) 
            {
                // validate all the items we pulled in already
                _execData.pff->ValidateItems(_execData.psfv, 0, -1, TRUE);
            }
            _execData.pff->GetItemCount(&iItem);
            _NotifyProgressText(_uStatusMsgIndex, iItem);
            if (!fAbort)
                _SelectResults();
        }
    }

    // weird connection point corruption can happen here.  somehow the number of sinks is 0 but 
    // some of the array entries are non null thus causing fault.  this problem does not want to 
    // repro w/ manual testing or debug binaries, only sometimes after an automation run.  when
    // it happens it is too late to figure out what happened so just patch it here.
    if (_cpEvents._HasSinks())
        _cpEvents.InvokeDispid(fAbort ? DISPID_SEARCHCOMMAND_ABORT : DISPID_SEARCHCOMMAND_COMPLETE);
}

// see if we need to restart the search based on an update dir

BOOL ShouldRestartSearch(LPCITEMIDLIST pidl)
{ 
    BOOL fRestart = TRUE;   // assume we should, non file system pidls

    WCHAR szPath[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // Check if this is either a network drive or a remote drive:
        if (PathIsRemote(szPath))
        {
            // If we can find the CI catalogs for the drive on the other machine, then we do
            // not want to search.

            WCHAR wszCatalog[MAX_PATH], wszMachine[32];
            ULONG cchCatalog = ARRAYSIZE(wszCatalog), cchMachine = ARRAYSIZE(wszMachine);

            fRestart = (S_OK != LocateCatalogsW(szPath, 0, wszMachine, &cchMachine, wszCatalog, &cchCatalog));
        }
        else if (-1 != PathGetDriveNumber(szPath))
        {
            // It is a local dirve...
            // Is this machine running the content indexer (CI)?

            BOOL fCiRunning, fCiIndexed, fCiPermission;
            GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);

            fRestart = !fCiRunning || !fCiIndexed;  // restart if not running or not fully indexed
        }
    }
    
    return fRestart;
}

void CFindCmd::_OnChangeNotify(LONG code, LPITEMIDLIST *ppidl)
{
    LPITEMIDLIST pidlT;
    UINT idsMsg;
    UINT cItems;

    if (!_execData.pff)
    {
        _ExecData_Init();

        // If we are running async then for now ignore notifications...
        // Unless we have cached all of the items...
        if (!_execData.pff)
            return; // we do not have anything to listen...
    }

    // see if we want to process the notificiation or not.
    switch (code)
    {
    case SHCNE_RENAMEFOLDER:    // With trashcan this is what we see...
    case SHCNE_RENAMEITEM:      // With trashcan this is what we see...
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_UPDATEITEM:
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        // Process this one out of place
        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, *ppidl, NULL);
        break;

    case SHCNE_UPDATEDIR:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_UPDATEDIR, pidl=0x%X",*ppidl);
        if (ShouldRestartSearch(*ppidl)) 
        {
            BOOL bRecurse = (ppidl[1] != NULL);
            if (_cExecInProgress) 
            {
                _DeferHandleUpdateDir(*ppidl, bRecurse);
            } 
            else 
            {
                if (_execData.pff->HandleUpdateDir(*ppidl, bRecurse)) 
                {
                    // Need to spawn sub-search on this...
                    _Start(FALSE, -1, *ppidl);
                }
            }
        }
        return;

    default:
        return;     // we are not interested in this event
    }

    //
    // Now we need to see if the item might be in our list
    // First we need to extract off the last part of the id list
    // and see if the contained id entry is in our list.  If so we
    // need to see if can get the defview find the item and update it.
    //

    _execData.pff->MapToSearchIDList(*ppidl, FALSE, &pidlT);

    switch (code)
    {
    case SHCNE_RMDIR:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_RMDIR, pidl=0x%X",*ppidl);
        _execData.pff->HandleRMDir(_execData.psfv, *ppidl);
        if (pidlT)
        {
            _execData.psfv->RemoveObject(pidlT, &idsMsg);
        }
        break;

    case SHCNE_DELETE:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_DELETE, pidl=0x%X",*ppidl);
        if (pidlT)
        {
            _execData.psfv->RemoveObject(pidlT, &idsMsg);
        }
        break;

    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        if (pidlT)
        {
            // If the two items dont have the same parent, we will go ahead
            // and remove it...
            LPITEMIDLIST pidl1;
            if (SUCCEEDED(_execData.pff->GetParentsPIDL(pidlT, &pidl1)))
            {
                LPITEMIDLIST pidl2 = ILClone(ppidl[1]);
                if (pidl2)
                {
                    ILRemoveLastID(pidl2);
                    if (!ILIsEqual(pidl1, pidl2))
                    {
                        _execData.psfv->RemoveObject(pidlT, &idsMsg);

                        // And maybe add it back to the end... of the list
                        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], NULL);
                    }
                    else
                    {
                        // The object is in same folder so must be rename...
                        // And maybe add it back to the end... of the list
                        _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], pidlT);
                    }
                    ILFree(pidl2);
                }
                ILFree(pidl1);
            }
        }
        else
        {
            _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, ppidl[1], NULL);
        }
        break;

    case SHCNE_UPDATEITEM:
        TraceMsg(TF_DOCFIND, "DocFind got notify SHCNE_UPDATEITEM, pidl=0x%X",*ppidl);
        if (pidlT)
            _execData.pff->UpdateOrMaybeAddPidl(_execData.psfv, *ppidl, pidlT);
        break;
    }

    // Update the count...
    _execData.psfv->GetObjectCount(&cItems);
    _NotifyProgressText(_uStatusMsgIndex, cItems);

    ILFree(pidlT);
}                          

// Ok we need to add a defer

void CFindCmd::_DeferHandleUpdateDir(LPCITEMIDLIST pidl, BOOL bRecurse)
{
    // See if we already have some items in the list which are lower down in the tree if so we
    // can replace it.  Or is there one that is higher up, in which case we can ignore it...

    struct DEFER_UPDATE_DIR *pdudPrev = NULL;
    struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
    while (pdud) 
    {
        if (ILIsParent(pdud->pidl, pidl, FALSE))
            return;     // Already one in the list that will handle this one...
        if (ILIsParent(pidl, pdud->pidl, FALSE))
            break;
        pdudPrev = pdud;
        pdud = pdud->pdudNext;
    }

    // See if we found one that we can replace...
    if (pdud) 
    {
        LPITEMIDLIST pidlT = ILClone(pidl);
        if (pidlT) 
        {
            ILFree(pdud->pidl);
            pdud->pidl = pidlT;

            // See if there are others...
            pdudPrev = pdud;
            pdud = pdud->pdudNext;
            while (pdud) 
            {
                if (ILIsParent(pidl, pdud->pidl, FALSE)) 
                {
                    // Yep lets trash this one.
                    ILFree(pdud->pidl);
                    pdudPrev->pdudNext = pdud->pdudNext;
                    pdud = pdudPrev;    // Let it fall through to setup to look at next...
                }
                pdudPrev = pdud;
                pdud = pdud->pdudNext;
            }
        }
    }
    else 
    {
        // Nope simply add us in to the start of the list.
        pdud = (struct DEFER_UPDATE_DIR*)LocalAlloc(LPTR, sizeof(struct DEFER_UPDATE_DIR));
        if (!pdud)
            return; // Ooop could not alloc...
        pdud->pidl = ILClone(pidl);
        if (!pdud->pidl) 
        {
            LocalFree((HLOCAL)pdud);
            return;
        }
        pdud->fRecurse = bRecurse;
        pdud->pdudNext = _pdudFirst;
        _pdudFirst = pdud;
    }
}

void CFindCmd::_ClearDeferUpdateDirList()
{
    // Cancel any Pending updatedirs also.    
    while (_pdudFirst) 
    {
        struct DEFER_UPDATE_DIR *pdud = _pdudFirst;
        _pdudFirst = pdud->pdudNext;
        ILFree(pdud->pidl);
        LocalFree((HLOCAL)pdud);
    }
}

LRESULT CALLBACK CFindCmd::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CFindCmd* pThis = (CFindCmd*)GetWindowLongPtr(hwnd, 0);
    LRESULT lRes = 0;
    switch (uMsg)
    {
    case WM_DESTROY:
        SetWindowLong(hwnd, 0, 0); // make sure we don't deref pThis
        break;

    case WM_DF_FSNOTIFY:
        {
            LPITEMIDLIST *ppidl;
            LONG lEvent;
            LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
            if (pshcnl)
            {
                if (pThis)
                    pThis->_OnChangeNotify(lEvent, ppidl);
                SHChangeNotification_Unlock(pshcnl);
            }
        }
        break;
        
    case WM_DF_SEARCHPROGRESS:
        pThis->_PTN_SearchProgress();
        pThis->Release();
        break;

    case WM_DF_ASYNCPROGRESS:
        pThis->_PTN_AsyncProgress((int)wParam, (DWORD)lParam);
        pThis->Release();
        break;

    case WM_DF_SEARCHSTART:
        pThis->_cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_START);
        pThis->_SetEmptyText(IDS_FINDVIEWEMPTYBUSY);
        pThis->Release();
        break;

    case WM_DF_SEARCHCOMPLETE:
        pThis->_PTN_SearchComplete((HRESULT)wParam, (BOOL)lParam);
        pThis->Release();
        break;

    default:
        lRes = ::DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }
    return lRes;
}

// test to see if the view is in a mode where many items are displayed
BOOL LotsOfItemsInView(IUnknown *punkSite)
{
    BOOL bLotsOfItemsInView = FALSE;

    IFolderView * pfv;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        UINT uViewMode;
        bLotsOfItemsInView = SUCCEEDED(pfv->GetCurrentViewMode(&uViewMode)) &&
            ((FVM_ICON == uViewMode) || (FVM_SMALLICON == uViewMode));
        pfv->Release();
    }
    return bLotsOfItemsInView;
}

void CFindCmd::_DoSearch(IFindEnum *penum, IShellFolder *psf, IFindFolder *pff, IShellFolderView *psfv)
{
    BOOL fAbort = FALSE;
    CFC_CALLBACK_INFO cci;

    cci.pthis = this;
    cci.psf = psf;    // these are weak references
    cci.pff = pff;    // these are weak references

    BOOL bLotsOfItems = LotsOfItemsInView(psfv);

    EnterCriticalSection(&_csThread);

    // previous thread might have exited but we're still processing search complete message
    if (_cExecInProgress > 1) 
        Sleep(1000); // give it a chance to finish

    _updateParams.hdpa = NULL;
    _updateParams.fFilesAdded = FALSE;
    _updateParams.fDirChanged = FALSE;
    _updateParams.fUpdatePosted = FALSE;

    _PostMessage(WM_DF_SEARCHSTART, 0, 0);

    // Now see if this is an Sync or an Async version of the search...

    HRESULT hr = S_OK;

    BOOL fQueryIsAsync = penum->FQueryIsAsync();
    if (fQueryIsAsync)
    {
        DBCOUNTITEM dwTotalAsync;
        BOOL fDone;
        int nPercentComplete;
        while (S_OK == (hr = penum->GetAsyncCount(&dwTotalAsync, &nPercentComplete, &fDone)))
        {
            if (!_fContinue) 
            {
                fAbort = TRUE;
                break;
            }

            _PostMessage(WM_DF_ASYNCPROGRESS, (WPARAM)nPercentComplete, (LPARAM)dwTotalAsync);

            // If we are done we can simply let the ending callback tell of the new count...
            if (fDone) 
                break;

            // sleep .3 or 1.5 sec
            Sleep(bLotsOfItems ? 1500 : 300); // wait between looking again...
        }
    }

    if (!fQueryIsAsync || (fQueryIsAsync == DF_QUERYISMIXED))
    {
        int state, cItemsSearched = 0, cFoldersSearched = 0, cFoldersSearchedPrev = 0;

        _updateParams.hdpa = _hdpaItemsToAdd1;    // Assume first one now...
        _updateParams.dwTimeLastNotify = GetTickCount();

        LPITEMIDLIST pidl;
        while (S_OK == (hr = penum->Next(&pidl, &cItemsSearched, &cFoldersSearched, &_fContinue, &state)))
        {
            if (state == GNF_DONE) 
                break;  // no more

            if (!_fContinue) 
            {                        
                fAbort = TRUE;
                break;
            }

            // See if we should abort
            if (state == GNF_MATCH)
            {   
                EnterCriticalSection(&_updateParams.csSearch);
                DPA_AppendPtr(_updateParams.hdpa, pidl);
                _updateParams.fFilesAdded = TRUE;
                LeaveCriticalSection(&_updateParams.csSearch);
            }

            if (cFoldersSearchedPrev != cFoldersSearched)
            {
                _updateParams.fDirChanged = TRUE;
                cFoldersSearchedPrev = cFoldersSearched;
            }

            if (!_updateParams.fUpdatePosted &&
                (_updateParams.fDirChanged || _updateParams.fFilesAdded))
            {
                if ((GetTickCount() - _updateParams.dwTimeLastNotify) > 200)
                {
                    DPA_Sort(_updateParams.hdpa, _CompareCallbackStub, (LPARAM)&cci);
                    _updateParams.fUpdatePosted = TRUE;
                    _PostMessage(WM_DF_SEARCHPROGRESS, 0, 0);
                }
            }
        }

        DPA_Sort(_updateParams.hdpa, _CompareCallbackStub, (LPARAM)&cci);

        _PostMessage(WM_DF_SEARCHPROGRESS, 0, 0);
    }

    if (hr != S_OK) 
    {
        fAbort = TRUE;
    }

    _PostMessage(WM_DF_SEARCHCOMPLETE, (WPARAM)hr, (LPARAM)fAbort);

    LeaveCriticalSection(&_csThread);
}

DWORD CALLBACK CFindCmd::_ThreadProc(void *pv)
{
    THREAD_PARAMS *pParams = (THREAD_PARAMS *)pv;
    pParams->pThis->_DoSearch(pParams->penum, pParams->psf, pParams->pff, pParams->psfv);
    _FreeThreadParams(pParams);
    return 0;
}

HRESULT CFindCmd::_Cancel()
{
    _ClearDeferUpdateDirList();

    if (DSA_GetItemCount(_hdsaConstraints) == 0) 
    {
        _fContinue = FALSE; // Cancel current query if we have a null paramter collection
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFindCmd::_Init(THREAD_PARAMS **ppParams, int iCol, LPCITEMIDLIST pidlUpdate)
{
    *ppParams = new THREAD_PARAMS;
    if (NULL == *ppParams)
        return E_OUTOFMEMORY;

    // Clear any previous registrations...
    SHChangeNotifyDeregisterWindow(_updateParams.hwndThreadNotify);

    // Prepare to execute the query
    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr)) 
    {
        // We do not need to update the filter if this is done as part of an FSNOTIFY or a Sort...
        if ((iCol >= 0) || pidlUpdate || SUCCEEDED(hr = _UpdateFilter(pfilter))) 
        {
            _execData.szProgressText[0] = 0; 

            pfilter->DeclareFSNotifyInterest(_updateParams.hwndThreadNotify, WM_DF_FSNOTIFY);
            pfilter->GetStatusMessageIndex(0, &_uStatusMsgIndex);

            DWORD dwFlags;
            hr = pfilter->PrepareToEnumObjects(_GetWindow(), &dwFlags);
            if (SUCCEEDED(hr)) 
            {
                hr = pfilter->EnumObjects(_execData.psf, pidlUpdate, dwFlags, iCol, 
                        _execData.szProgressText, SAFECAST(this, IRowsetWatchNotify*), &(*ppParams)->penum);

                if (SUCCEEDED(hr))
                {
                    (*ppParams)->psf = _execData.psf;
                    _execData.psf->AddRef();
                    (*ppParams)->pff = _execData.pff;
                    _execData.pff->AddRef();
                    (*ppParams)->psfv = _execData.psfv;
                    _execData.psfv->AddRef();
                }
            }
        }
        pfilter->Release();
    }

    // Fill in the exec params

    (*ppParams)->pThis = this;
    AddRef();   // ExecParams_Free will release this interface addref...

    if (FAILED(hr) || ((*ppParams)->penum == NULL))
    {
        _FreeThreadParams(*ppParams);        
        *ppParams = NULL;
    } 

    return hr;
}

HRESULT CFindCmd::_FreeThreadParams(THREAD_PARAMS *pParams)
{
    if (!pParams)
        return S_OK;

    // Don't use atomic release as this a pointer to a class not an interface.
    CFindCmd *pThis = pParams->pThis;
    pParams->pThis = NULL;
    pThis->Release();

    ATOMICRELEASE(pParams->penum);
    ATOMICRELEASE(pParams->psf);
    ATOMICRELEASE(pParams->pff);
    ATOMICRELEASE(pParams->psfv);

    delete pParams;
    
    return S_OK;
}

HRESULT CFindCmd::_ExecData_Release()
{
    ATOMICRELEASE(_execData.psf);
    ATOMICRELEASE(_execData.psfv);
    if (_execData.pff)
        _execData.pff->SetControllerNotifyObject(NULL);   // release back pointer to us...
    ATOMICRELEASE(_execData.pff);
    _cExecInProgress = 0; // we must be in process of shutting down at least...
    
    return S_OK;
}

HRESULT CFindCmd::_EnsureResultsViewIsCurrent(IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFolder;
    if (S_OK == SHGetIDListFromUnk(punk, &pidlFolder))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(_GetSearchIDList(&pidl)))
        {
            if (ILIsEqual(pidlFolder, pidl))
                hr = S_OK;
            ILFree(pidl);
        }
        ILFree(pidlFolder);
    }
    return hr;
}

// the search results view callback proffeerd itself and we can use that 
// to get a hold of defview and can program it

HRESULT CFindCmd::_GetShellView(REFIID riid, void **ppv)
{
    return IUnknown_QueryService(_punkSite, SID_DocFindFolder, riid, ppv);
}

HRESULT CFindCmd::_ExecData_Init()
{
    _ExecData_Release();

    IFolderView *pfv;
    HRESULT hr = _GetShellView(IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr)) 
    {
        IShellFolder *psf;
        hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr)) 
        {
            IFindFolder *pff;
            hr = psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff));
            if (SUCCEEDED(hr)) 
            {
                hr = _EnsureResultsViewIsCurrent(psf);
                if (SUCCEEDED(hr)) 
                {
                    IShellFolderView *psfv;
                    hr = pfv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv));
                    if (SUCCEEDED(hr)) 
                    {
                        IUnknown_Set((IUnknown **)&_execData.pff, pff);
                        IUnknown_Set((IUnknown **)&_execData.psf, psf);
                        IUnknown_Set((IUnknown **)&_execData.psfv, psfv);
                        _execData.pff->SetControllerNotifyObject(SAFECAST(this, IFindControllerNotify*));
                        psfv->Release();
                    }
                }
                pff->Release();
            }
            psf->Release();
        }
        pfv->Release();
    }

    if (FAILED(hr))
        _ExecData_Release();
    else
        SetShellFolder(_execData.psf);
    
    return hr;
}

BOOL CFindCmd::_SetupBrowserCP()
{
    if (!_dwCookie)
    {
        _cwbe.SetOwner(this);   // make sure our owner is set...

        // register ourself with the Defview to get any events that they may generate...
        IServiceProvider *pspTLB;
        HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTLB));
        if (SUCCEEDED(hr)) 
        {
            IConnectionPointContainer *pcpc;
            hr = pspTLB->QueryService(IID_IExpDispSupport, IID_PPV_ARG(IConnectionPointContainer, &pcpc));
            if (SUCCEEDED(hr)) 
            {
                hr = ConnectToConnectionPoint(SAFECAST(&_cwbe, DWebBrowserEvents*), DIID_DWebBrowserEvents2,
                                              TRUE, pcpc, &_dwCookie, &_pcpBrowser);
                pcpc->Release();
            }
            pspTLB->Release();
        }
    }

    if (_dwCookie)
        _cwbe.SetWaiting(TRUE);

    return _dwCookie ? TRUE : FALSE;
}

HRESULT CFindCmd::_Start(BOOL fNavigateIfFail, int iCol, LPCITEMIDLIST pidlUpdate)
{
    if (_cExecInProgress)
        return E_UNEXPECTED;

    if (!_hdpaItemsToAdd1) 
    {
        _hdpaItemsToAdd1 = DPA_CreateEx(64, GetProcessHeap());
        if (!_hdpaItemsToAdd1)
            return E_OUTOFMEMORY;
    }

    if (!_hdpaItemsToAdd2) 
    {
        _hdpaItemsToAdd2 = DPA_CreateEx(64, GetProcessHeap());
        if (!_hdpaItemsToAdd2)
            return E_OUTOFMEMORY;
    }

    if (!_updateParams.hwndThreadNotify) 
    {
        _updateParams.hwndThreadNotify = SHCreateWorkerWindow(_WndProc, NULL, 0, 0, 0, this);
        if (!_updateParams.hwndThreadNotify) 
            return E_OUTOFMEMORY;
    }

    HRESULT hr = _ExecData_Init();
    if (FAILED(hr)) 
    {
        if (fNavigateIfFail) 
        {
            if (_SetupBrowserCP())
                NavigateToSearchResults();
        }
        // Return S_False so that when we check if this succeeded in finddlg, we wee that it 
        // did, and therefore let the animation run.  If we return a failure code here, we
        // will stop the animation.  This will only hapen when we are navigating to the search
        // results as well as starting the search.
        return S_FALSE;
    }

    THREAD_PARAMS *ptp;
    hr = _Init(&ptp, iCol, pidlUpdate);
    if (SUCCEEDED(hr)) 
    {
        // See if we should be saving away the selection...
        if (iCol >= 0)
            _execData.pff->RememberSelectedItems();

        // If this is an update then we need to remember our IDList else clear list...
        if (pidlUpdate) 
        {
            _pidlUpdate = ILClone(pidlUpdate);
        } 
        else 
        {
            _Clear();   // tell defview to delete everything
        }

        if (ptp != NULL)
        {
            _execData.pff->SetAsyncEnum(ptp->penum);

            // Start the query
            _cExecInProgress++;
            _fContinue = TRUE;
            _fNew = FALSE;

            if (SHCreateThread(_ThreadProc, ptp, CTF_COINIT, NULL))
            {
                hr = S_OK;
            }
            else
            {
                _cExecInProgress--;
                _FreeThreadParams(ptp);
                _SetEmptyText(IDS_FINDVIEWEMPTY);
            }
        }
        else
        {
            BOOL fAbort = FALSE;

            _fContinue = TRUE;
            _fNew = FALSE;

            _PostMessage(WM_DF_SEARCHCOMPLETE, (WPARAM)hr, (LPARAM)fAbort);

            _SetEmptyText(IDS_FINDVIEWEMPTY);
        }
    }
    else
        hr = _SetLastError(hr);

    return hr; 
}

HRESULT CFindCmd::_SetLastError(HRESULT hr) 
{
    if (HRESULT_FACILITY(hr) == FACILITY_SEARCHCOMMAND) 
    {
        _hrLastError = hr;
        hr = S_FALSE; // Don't error out script...
        _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_ERROR);
    }
    return hr;
}

STDMETHODIMP CFindCmd::Execute(VARIANT *RecordsAffected, VARIANT *Parameters, long Options)
{
    if (Options == 0)
        return _Cancel();

    _FixBrokenTypes();

    return _Start(TRUE, -1, NULL);
}

// IConnectionPointContainer

STDMETHODIMP CFindCmd::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1, _cpEvents.CastToIConnectionPoint());
}

STDMETHODIMP CFindCmd::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    if (IsEqualIID(iid, DIID_DSearchCommandEvents) || 
        IsEqualIID(iid, IID_IDispatch)) 
    {
        *ppCP = _cpEvents.CastToIConnectionPoint();
    } 
    else 
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}

// IProvideClassInfo2 methods

STDMETHODIMP CFindCmd::GetClassInfo(ITypeInfo **ppTI)
{
    return GetTypeInfoFromLibId(0, LIBID_Shell32, 1, 0, CLSID_DocFindCommand, ppTI);
}

STDMETHODIMP CFindCmd::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID) 
    {
        *pGUID = DIID_DSearchCommandEvents;
        return S_OK;
    }
    
    *pGUID = GUID_NULL;
    return E_FAIL;
}


STDMETHODIMP CFindCmd::SetSite(IUnknown *punkSite)
{
    if (!punkSite) 
    {
        if (!_cExecInProgress) 
        {
            _ExecData_Release();
        }
        _fContinue = FALSE; // Cancel existing queries

        // See if we have a connection point... If so unadvise now...
        if (_dwCookie) 
        {
            _pcpBrowser->Unadvise(_dwCookie);
            ATOMICRELEASE(_pcpBrowser);
            _dwCookie = 0;
        }

        // Bug #199671
        // Trident won't call UnAdvise and they except ActiveX Controls
        // to use IOleControl::Close() to do their own UnAdvise, and hope
        // nobody will need events after that.  I don't impl IOleControl so
        // we need to do the same thing during IObjectWithSite::SetSite(NULL)
        // and hope someone won't want to reparent us.  This is awkward but
        // saves Trident some perf so we will tolerate it.
        EVAL(SUCCEEDED(_cpEvents.UnadviseAll()));
    }

    return CObjectWithSite::SetSite(punkSite);
}

void CFindCmd::_SelectResults()
{
    if (_execData.psfv)
    {
        //  If there are any items...
        UINT cItems = 0;
        if (SUCCEEDED(_execData.psfv->GetObjectCount(&cItems)) && cItems > 0)
        {
            IShellView* psv;
            if (SUCCEEDED(_execData.psfv->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
            {
                //  If none are selected (don't want to rip the user's selection out of his hand)...
                UINT cSelected = 0;
                if (SUCCEEDED(_execData.psfv->GetSelectedCount(&cSelected)) && cSelected == 0)
                {
                    //  Retrieve the pidl for the first item in the list...
                    LPITEMIDLIST pidlFirst = NULL;
                    if (SUCCEEDED(_execData.psfv->GetObject(&pidlFirst,  0)))
                    {
                        //  Give it the focus
                        psv->SelectItem(pidlFirst, SVSI_FOCUSED | SVSI_ENSUREVISIBLE);
                    }
                }

                //  Activate the view.
                psv->UIActivate(SVUIA_ACTIVATE_FOCUS);
                psv->Release();
            }
        }
    }
}

STDMETHODIMP CFindCmd::ClearResults(void)
{
    HRESULT hr = _Clear();

    if (SUCCEEDED(hr))
    {
        _fNew = TRUE;
        _SetEmptyText(IDS_FINDVIEWEMPTYINIT);
    }

    return hr ;
}

HRESULT CFindCmd::_Clear()
{
    // Tell defview to delete everything.
    if (_execData.psfv)
    {
        UINT u;
        _execData.psfv->RemoveObject(NULL, &u);
    }

    // And cleanup our folderList
    if (_execData.pff)
    {
        _execData.pff->ClearItemList();
        _execData.pff->ClearFolderList();
    }
    return S_OK;
}

HRESULT CFindCmd::_SetEmptyText(UINT nIDEmptyText)
{
    IShellFolderViewCB *psfvcb;
    HRESULT hr = IUnknown_QueryService(_execData.psfv, SID_ShellFolderViewCB, IID_PPV_ARG(IShellFolderViewCB, &psfvcb));
    if (SUCCEEDED(hr))
    {
        TCHAR szEmptyText[128];
        LoadString(HINST_THISDLL, nIDEmptyText, szEmptyText, ARRAYSIZE(szEmptyText));

        hr = psfvcb->MessageSFVCB(SFVM_SETEMPTYTEXT, 0, (LPARAM)szEmptyText);
        psfvcb->Release();
    }
    return hr;
}

HRESULT CFindCmd::_GetSearchIDList(LPITEMIDLIST *ppidl)
{
    CLSID clsid;
    _SearchResultsCLSID(&clsid);
    return ILCreateFromCLSID(clsid, ppidl);
}

STDMETHODIMP CFindCmd::NavigateToSearchResults(void)
{
    IShellBrowser *psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr)) 
    {
        LPITEMIDLIST pidl;
        hr = _GetSearchIDList(&pidl);
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidl,  SBSP_SAMEBROWSER | SBSP_ABSOLUTE | SBSP_WRITENOHISTORY);
            ILFree(pidl);
        }
        psb->Release();
    }
    return hr;
}

IUnknown* CFindCmd::_GetObjectToPersist()
{
    IOleObject *pole = NULL;
    
    IShellView *psv;
    HRESULT hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
    if (SUCCEEDED(hr)) 
    {
        psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IOleObject, &pole));
        psv->Release();
    }

    return (IUnknown *)pole;
}

void CFindCmd::_PostMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{    
    AddRef();  // to be released after processing of the message bellow
    if (!PostMessage(_updateParams.hwndThreadNotify, uMsg, wParam, lParam))
    {
        Release();
    }
}

HWND CFindCmd::_GetWindow()
{
    HWND hwnd;
    return SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwnd)) ? hwnd : NULL;
}

STDMETHODIMP CFindCmd::SaveSearch(void)
{
    IFindFilter *pfilter;
    HRESULT hr = _execData.pff->GetFindFilter(&pfilter);
    if (SUCCEEDED(hr))
    {
        IShellView *psv;
        hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr)) 
        {
            IUnknown* punk = _GetObjectToPersist(); // NULL is OK

            _execData.pff->Save(pfilter, _GetWindow(), &_dfbsi, psv, punk);

            ATOMICRELEASE(punk);

            psv->Release();
        }
        pfilter->Release();
    }

    return hr;
}

STDMETHODIMP CFindCmd::RestoreSearch(void)
{
    // let script know that a restore happened...
    _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_RESTORE);
    return S_OK;
}

STDMETHODIMP CFindCmd::StopSearch(void)
{
    if (_cExecInProgress)
        return _Cancel();

    return S_OK;
}

STDMETHODIMP CFindCmd::GetItemCount(UINT *pcItems)
{
    if (_execData.psfv)
    {
        return _execData.psfv->GetObjectCount(pcItems);
    }
    return E_FAIL;
}

STDMETHODIMP CFindCmd::SetItemCount(UINT cItems)
{
    if (_execData.psfv)
    {
        return _execData.psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
    }
    return E_FAIL;
}

STDMETHODIMP CFindCmd::ViewDestroyed()
{
    _ExecData_Release();
    return S_OK;
}

STDMETHODIMP CFindCmd::get_ProgressText(BSTR *pbs)
{

    *pbs = SysAllocStringT(_szProgressText);
    return *pbs ? S_OK : E_OUTOFMEMORY;
}

//------ error string mappings ------//
static const UINT error_strings[] =
{
    SCEE_CONSTRAINT,   IDS_DOCFIND_CONSTRAINT,
    SCEE_PATHNOTFOUND, IDS_DOCFIND_PATHNOTFOUND,
    SCEE_INDEXSEARCH,  IDS_DOCFIND_SCOPEERROR,
    SCEE_CASESENINDEX, IDS_DOCFIND_CI_NOT_CASE_SEN,
};

STDMETHODIMP CFindCmd::GetErrorInfo(BSTR *pbs,  int *phr)
{
    int nCode     = HRESULT_CODE(_hrLastError);
    UINT uSeverity = HRESULT_SEVERITY(_hrLastError);

    if (phr)
        *phr = nCode;
    
    if (pbs)
    {    
        UINT nIDString = 0;
        *pbs = NULL;

        for(int i = 0; i < ARRAYSIZE(error_strings); i += 2)
        {
            if (error_strings[i] == (UINT)nCode)
            {
                nIDString =  error_strings[i+1];
                break ;
            }
        }

        if (nIDString)
        {
            WCHAR wszMsg[MAX_PATH];
            EVAL(LoadStringW(HINST_THISDLL, nIDString, wszMsg, ARRAYSIZE(wszMsg)));
            *pbs = SysAllocString(wszMsg);
        }
        else
            *pbs = SysAllocString(L"");
    }
    
    return S_OK;
}

STDMETHODIMP CFindCmd::SearchFor(int iFor)
{
    if (SCE_SEARCHFORFILES == iFor)
    {
        _clsidResults = CLSID_DocFindFolder;
    }
    else if (SCE_SEARCHFORCOMPUTERS == iFor)
    {
        _clsidResults = CLSID_ComputerFindFolder;
    }
    return S_OK;
}

STDMETHODIMP CFindCmd::GetScopeInfo(BSTR bsScope, int *pdwScopeInfo)
{
    *pdwScopeInfo = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CFindCmd::RestoreSavedSearch(VARIANT *pvarFile)
{
    if (pvarFile && pvarFile->vt != VT_EMPTY)
    {
        LPITEMIDLIST pidl = VariantToIDList(pvarFile); 
        if (pidl)
        {
            ILFree(_pidlRestore);
            _pidlRestore = pidl ;
        }
    }

    if (_pidlRestore)
    {
        IShellView *psv;
        HRESULT hr = _GetShellView(IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr)) 
        {
            psv->Release();

            if (SUCCEEDED(_ExecData_Init()))
            {
                _execData.pff->RestoreSearchFromSaveFile(_pidlRestore, _execData.psfv);
                _cpEvents.InvokeDispid(DISPID_SEARCHCOMMAND_RESTORE);
                ILFree(_pidlRestore);
                _pidlRestore = NULL;
            }
        }
        else if (!_fDeferRestoreTried)
        {
            // appears to be race condition to load
            TraceMsg(TF_WARNING, "CFindCmd::MaybeRestoreSearch - _GetShellView failed...");
            _fDeferRestore = TRUE;
            if (!_SetupBrowserCP())
                _fDeferRestore = FALSE;
        }
    }
    return S_OK;
}

STDMETHODIMP CFindCmd::OnChange(IRowset *prowset, DBWATCHNOTIFY eChangeReason)
{
    _fAsyncNotifyReceived = TRUE;
    return S_OK;
}

STDMETHODIMP CFindCmd::DoSortOnColumn(UINT iCol, BOOL fSameCol)
{
    IFindEnum *pdfEnumAsync;

    if (S_OK == _execData.pff->GetAsyncEnum(&pdfEnumAsync))
    {
        // If the search is still running we will restart with the other column else we
        // will make sure all of the items have been cached and let the default processing happen
        if (!fSameCol && _cExecInProgress)
        {
            // We should try to sort on the right column...
            _Start(FALSE, iCol, NULL);
            return S_FALSE; // tell system to not do default processing.
        }

        _execData.pff->CacheAllAsyncItems();
    }
    return S_OK;    // let it do default processing.

}

// Implemention of our IDispatch to hookup to the top level browsers connnection point...
STDMETHODIMP CFindCmd::CWBEvents2::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFindCmd::CWBEvents2, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CFindCmd::CWBEvents2, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        QITABENTMULTI2(CFindCmd::CWBEvents2, DIID_DWebBrowserEvents, DWebBrowserEvents),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CFindCmd::CWBEvents2::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    if (_fWaitingForNavigate) 
    {
        if ((dispidMember == DISPID_NAVIGATECOMPLETE) || 
            (dispidMember == DISPID_DOCUMENTCOMPLETE)) 
        {
            // Assume this is ours... Should maybe check parameters...
            _fWaitingForNavigate = FALSE;

            // Now see if it is a case where we are to restore the search...
            if (_pcdfc->_fDeferRestore)
            {
                _pcdfc->_fDeferRestore = FALSE;
                _pcdfc->_fDeferRestoreTried = TRUE;
                _pcdfc->RestoreSavedSearch(NULL);
            }
            else
                return _pcdfc->_Start(FALSE, -1, NULL);
        }
    }
    return S_OK;
}

#define MAX_DEFAULT_VALUE   40      // Longest of all of the below pszDefaultValueMatch strings (plus slop)
#define MAX_KEY_PH_NAME     70      // "CLSID\{GUID}\PersistentHandler" (plus slop)

const TYPE_FIX_ENTRY g_tfeTextTypes[] =
{
    { TEXT(".rtf"), NULL,                               NULL                                           },
};

const TYPE_FIX_ENTRY g_tfeNullTypes[] =
{
    { TEXT(".mdb"), TEXT("Access.Application.10"),      TEXT("{73A4C9C1-D68D-11D0-98BF-00A0C90DC8D9}") },
    { TEXT(".msg"), TEXT("msgfile"),                    NULL                                           },
    { TEXT(".sc2"), TEXT("SchedulePlus.Application.7"), TEXT("{0482E074-C5B7-101A-82E0-08002B36A333}") },
    { TEXT(".wll"), TEXT("Word.Addin.8"),               NULL                                           },
};

//
// rtf is listed twice, once above for TextTypes (to fix when office
// un-installed) and once here as an OfficeType (to fix when office
// is re-installed).  Uninstalled = TextFilter,  Reinstalled = OfficeFilter
//
const TYPE_FIX_ENTRY g_tfeOfficeTypes[] =
{
    { TEXT(".rtf"), TEXT("Word.RTF.8"),                 TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".doc"), TEXT("Word.Document.8"),            TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".dot"), TEXT("Word.Template.8"),            TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".pot"), TEXT("PowerPoint.Template.8"),      TEXT("{64818D11-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".pps"), TEXT("PowerPoint.SlideShow.8"),     TEXT("{64818D10-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".ppt"), TEXT("PowerPoint.Show.8"),          TEXT("{64818D10-4F9B-11CF-86EA-00AA00B929E8}") },
    { TEXT(".rtf"), TEXT("Word.RTF.8"),                 TEXT("{00020906-0000-0000-C000-000000000046}") },
    { TEXT(".xlb"), TEXT("Excel.Sheet.8"),              TEXT("{00020820-0000-0000-C000-000000000046}") },
    { TEXT(".xlc"), TEXT("Excel.Chart.8"),              TEXT("{00020821-0000-0000-C000-000000000046}") },
    { TEXT(".xls"), TEXT("Excel.Sheet.8"),              TEXT("{00020820-0000-0000-C000-000000000046}") },
    { TEXT(".xlt"), TEXT("Excel.Template"),             TEXT("{00020820-0000-0000-C000-000000000046}") },
};

const TYPE_FIX_ENTRY g_tfeHtmlTypes[] =
{
    { TEXT(".asp"), TEXT("aspfile"),                    NULL                                           },
    { TEXT(".htx"), TEXT("htxfile"),                    NULL                                           },
};

BOOL CFindCmd::_FixPersistHandler(LPCTSTR pszBase, LPCTSTR pszDefaultHandler)
{
    TCHAR szPHName[MAX_KEY_PH_NAME];
    LONG lr;
    HKEY hkeyPH;
    HKEY hkeyBase;
    HRESULT hr;

    hr = StringCchPrintf(szPHName, ARRAYSIZE(szPHName), TEXT("%s\\PersistentHandler"), pszBase);
    if (FAILED(hr))
    {
        return FALSE;
    }

    lr = RegOpenKeyEx(HKEY_CLASSES_ROOT, szPHName, NULL, KEY_QUERY_VALUE, &hkeyPH);
    if (lr == ERROR_SUCCESS)
    {
        // We found an existing PersistHandler key, leave it alone
        RegCloseKey(hkeyPH);
        return TRUE;
    }

    lr = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszBase, NULL, KEY_QUERY_VALUE, &hkeyBase);
    if (lr != ERROR_SUCCESS)
    {
        // We didn't find the base key (normally "CLSID\\{GUID}"), get out
        return FALSE;
    }
    RegCloseKey(hkeyBase);

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT, szPHName, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyPH, NULL);
    if (lr != ERROR_SUCCESS)
    {
        // We couldn't create the ...\PersistHandler key, get out
        return FALSE;
    }

    // Able to create the ...\PersistHandler key, write out the default handler
    lr = RegSetValue(hkeyPH, NULL, REG_SZ, pszDefaultHandler, lstrlen(pszDefaultHandler));
    RegCloseKey(hkeyPH);

    // Success if write succeeded
    return (lr == ERROR_SUCCESS);
}

void CFindCmd::_ProcessTypes(
    const TYPE_FIX_ENTRY *ptfeTypes,
    UINT cTypes,
    TCHAR *pszClass)
{
    UINT iType;
    LONG lr;
    HKEY hkeyType;

    for (iType = 0; iType < cTypes; iType++)
    {
        lr = RegOpenKeyEx(HKEY_CLASSES_ROOT, ptfeTypes[iType].pszDotType, NULL, KEY_QUERY_VALUE, &hkeyType);
        if (lr == ERROR_SUCCESS)
        {
            //
            // If it has a default value to match, repair that (if it exists).
            // If there is no default value to match, just repair the .foo type
            //
            if (ptfeTypes[iType].pszDefaultValueMatch)
            {
                TCHAR szDefaultValue[MAX_DEFAULT_VALUE];
                lr = SHRegGetString(hkeyType, NULL, NULL, szDefaultValue, ARRAYSIZE(szDefaultValue));
                if (lr == ERROR_SUCCESS)
                {
                    if (lstrcmp(szDefaultValue,ptfeTypes[iType].pszDefaultValueMatch) == 0)
                    {
                        if (ptfeTypes[iType].pszGuid == NULL)
                        {
                            // Fix either the progid or the type, whichever we can
                            if (!_FixPersistHandler(ptfeTypes[iType].pszDefaultValueMatch,pszClass))
                            {
                                 _FixPersistHandler(ptfeTypes[iType].pszDotType,pszClass);
                            }
                        }
                        else
                        {
                            // Fix the persist handler for the guid, since its specified
                            TCHAR szPHName[MAX_KEY_PH_NAME];

                            HRESULT hr = StringCchPrintf(szPHName, ARRAYSIZE(szPHName), TEXT("CLSID\\%s"), ptfeTypes[iType].pszGuid);
                            if (SUCCEEDED(hr))
                            {
                                _FixPersistHandler(szPHName, pszClass);
                            }
                        }
                    }
                }
            }
            else
            {
                _FixPersistHandler(ptfeTypes[iType].pszDotType, pszClass);
            }
            RegCloseKey(hkeyType);
        }
        else if (lr == ERROR_FILE_NOT_FOUND)
        {
            //
            // .foo doesn't exist - this can happen because of bad un-install program
            // Create .foo and .foo\PersistentHandler
            //
            lr = RegCreateKeyEx(HKEY_CLASSES_ROOT, ptfeTypes[iType].pszDotType, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyType, NULL);
            if (lr == ERROR_SUCCESS)
            {
                _FixPersistHandler(ptfeTypes[iType].pszDotType, pszClass);
                RegCloseKey(hkeyType);
            }
        }
    }
}

void CFindCmd::_FixBrokenTypes(void)
{
    _ProcessTypes(g_tfeNullTypes,   ARRAYSIZE(g_tfeNullTypes),   TEXT("{098f2470-bae0-11cd-b579-08002b30bfeb}"));
    _ProcessTypes(g_tfeTextTypes,   ARRAYSIZE(g_tfeTextTypes),   TEXT("{5e941d80-bf96-11cd-b579-08002b30bfeb}"));
    _ProcessTypes(g_tfeOfficeTypes, ARRAYSIZE(g_tfeOfficeTypes), TEXT("{98de59a0-d175-11cd-a7bd-00006b827d94}"));
    _ProcessTypes(g_tfeHtmlTypes,   ARRAYSIZE(g_tfeHtmlTypes),   TEXT("{eec97550-47a9-11cf-b952-00aa0051fe20}"));
}

CFindConstraint::CFindConstraint(BSTR bstr, VARIANT var) : CImpIDispatch(LIBID_Shell32, 1, 0, IID_DFConstraint)
{
    _cRef = 1;
    _bstr = bstr;
    _var = var;
}

CFindConstraint::~CFindConstraint()
{
    SysFreeString(_bstr);
    VariantClear(&_var);
}

STDMETHODIMP CFindConstraint::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindConstraint, DFConstraint),                  // IID_DFConstraint
        QITABENTMULTI(CFindConstraint, IDispatch, DFConstraint),  // IID_IDispatch
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindConstraint::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindConstraint::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFindConstraint::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CFindConstraint::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CFindConstraint::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP CFindConstraint::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CFindConstraint::get_Name(BSTR *pbs)
{
    *pbs = SysAllocString(_bstr);
    return *pbs? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindConstraint::get_Value(VARIANT *pvar)
{
    VariantInit(pvar);
    return VariantCopy(pvar, &_var);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\finddlg.h ===
// finddlg.h : Declaration of the file search band dialog classes

#ifndef __FSEARCH_DLGS_H__
#define __FSEARCH_DLGS_H__

#pragma warning(disable:4127) // conditional expression is constant

#include "resource.h"       // main symbols
#include <shdispid.h>
#include "atldisp.h"
#include "ids.h"

class CFileSearchBand;     // top-level (band/OC) window

class CBandDlg;            // base class for top-level dialogs
    class CSearchCmdDlg;       // base class for band dlgs that employ an ISearchCmdExt interface
        class CFindFilesDlg;       // top level file system search dialog
        class CFindComputersDlg;   // top level net search dialog
    class CFindPrintersDlg;    // top level printer search dialog

class CSubDlg;             // base class for subordinate dialogs
    class CDateDlg;            // file date subordinate dialog
    class CTypeDlg;            // file type subordinate dialog
    class CSizeDlg;            // file size subordinate dialog
    class CAdvancedDlg;        // advanced options subordinate dialog

interface IStringMru;

//  private messages posted to subdialogs
#define WMU_COMBOPOPULATIONCOMPLETE     (WM_USER+0x200) // (wParam: HWND of combo).
#define WMU_STATECHANGE                 (WM_USER+0x201) // 
#define WMU_UPDATELAYOUT                (WM_USER+0x202) // (wParam: Band layout flags (BLF_)).
#define WMU_RESTORESEARCH               (WM_USER+0x203) // (wParam: n/a, lParam: n/a, ret: n/a).
#define WMU_BANDINFOUPDATE              (WM_USER+0x204) // (wParam: NULL).
#define WMU_NAMESPACERECONCILE          (WM_USER+0x205) // (wParam: n/a, LPARAM: n/a).
#define WMU_BANDFINISHEDDISPLAYING      (WM_USER+0x306) // (wParam: NULL).

//  async state data
typedef struct tagFSEARCHTHREADSTATE
{
    HWND      hwndCtl;
    int       cItems;
    void*     pvParam;
    ULONG     Reserved;
    BOOL      fComplete;
    BOOL      fCancel;
    IUnknown* punkBand;

    //  constructor:
    tagFSEARCHTHREADSTATE() 
        :   hwndCtl(NULL), 
            cItems(0), 
            pvParam(NULL),
            Reserved(0),
            fComplete(FALSE),
            fCancel(FALSE),
            punkBand(NULL)
            {}
    ~tagFSEARCHTHREADSTATE() { ATOMICRELEASE(punkBand); }

} FSEARCHTHREADSTATE;


class CSubDlg // base class for subordinate dialogs
{
public:
    CSubDlg(CFileSearchBand* pfsb) : _pfsb(pfsb), _hwnd(NULL), _pBandDlg(NULL) {}
    virtual ~CSubDlg() {}

    HWND      Hwnd() const                       { return _hwnd; }
    void      SetBandDlg(CBandDlg* pBandDlg)   { _pBandDlg = pBandDlg; }
    CBandDlg* BandDlg() const                    { return _pBandDlg; }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd) PURE;
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue) PURE;
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual int  GetIdealDeskbandWidth() const { return -1;}
    virtual BOOL Validate()     { return TRUE; }
    virtual void Clear() PURE;
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave) {}
    virtual void OnWinIniChange()   {}
    virtual void DoDelayedInit()    {}          //  Called after search band displayed.

protected:
    BEGIN_MSG_MAP(CSubDlg)
        MESSAGE_HANDLER(WM_NCCALCSIZE, OnNcCalcsize)
        MESSAGE_HANDLER(WM_NCPAINT, OnNcPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColor)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        COMMAND_CODE_HANDLER(BN_SETFOCUS, OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(EN_SETFOCUS, OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(CBN_SETFOCUS, OnChildSetFocusCmd)
        NOTIFY_CODE_HANDLER(NM_SETFOCUS, OnChildSetFocusNotify) 
        COMMAND_CODE_HANDLER(BN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(EN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnChildKillFocusCmd)
        NOTIFY_CODE_HANDLER(NM_KILLFOCUS,   OnChildKillFocusNotify) 
        NOTIFY_CODE_HANDLER(CBEN_ENDEDIT,   OnComboExEndEdit) 
    END_MSG_MAP()

    LRESULT OnNcCalcsize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnNcPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnCtlColor(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnChildSetFocusCmd(WORD, WORD, HWND, BOOL&); 
    LRESULT OnChildSetFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnChildKillFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildKillFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnComboExEndEdit(int, LPNMHDR, BOOL&);

    void _Attach(HWND hwnd)    { _hwnd = hwnd; }
    CFileSearchBand* _pfsb;
    CBandDlg*        _pBandDlg;

private:
    HWND _hwnd;
};


// file date subordinate dialog
class CDateDlg : public CDialogImpl<CDateDlg>,
                 public CSubDlg
{
public:
    CDateDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CDateDlg() {}

    enum { IDD = DLG_FSEARCH_DATE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual BOOL Validate();
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CDateDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,       OnSize)
        NOTIFY_CODE_HANDLER(UDN_DELTAPOS, OnMonthDaySpin) 
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick)
        COMMAND_HANDLER(IDC_RECENT_MONTHS, EN_KILLFOCUS, OnMonthsKillFocus)
        COMMAND_HANDLER(IDC_RECENT_DAYS,   EN_KILLFOCUS, OnDaysKillFocus)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD,WORD,HWND,BOOL&);
    LRESULT OnMonthsKillFocus(WORD,WORD,HWND,BOOL&);
    LRESULT OnDaysKillFocus(WORD,WORD,HWND,BOOL&);
    LRESULT OnMonthDaySpin(int, LPNMHDR, BOOL&);

    //  utility methods
    void    EnableControls();
};


// file size subordinate dialog
class CSizeDlg : public CDialogImpl<CSizeDlg>,
                 public CSubDlg
{
public:
    CSizeDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CSizeDlg() {}

    enum { IDD = DLG_FSEARCH_SIZE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CSizeDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_FILESIZE_SPIN, UDN_DELTAPOS, OnSizeSpin) 
        COMMAND_HANDLER(IDC_FILESIZE, EN_KILLFOCUS, OnSizeKillFocus)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSizeSpin(int, LPNMHDR, BOOL&);
    LRESULT OnSizeKillFocus(WORD,WORD,HWND,BOOL&);
};


// CTypeDlg - file type subordinate dialog
class CTypeDlg : public CDialogImpl<CTypeDlg>,
                 public CSubDlg
{
public:
    CTypeDlg(CFileSearchBand* pfsb);
    ~CTypeDlg();

    enum { IDD = DLG_FSEARCH_TYPE };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();
    virtual void OnWinIniChange();
    virtual void DoDelayedInit();              //  Called after search band displayed.

protected:
    BEGIN_MSG_MAP(CTypeDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,       OnSize)
        MESSAGE_HANDLER(WMU_COMBOPOPULATIONCOMPLETE, OnComboPopulationComplete)
        MESSAGE_HANDLER(WM_DESTROY,    OnDestroy)
        NOTIFY_HANDLER(IDC_FILE_TYPE, CBEN_DELETEITEM, OnFileTypeDeleteItem) 
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnFileTypeDeleteItem(int, LPNMHDR, BOOL&);
    LRESULT OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&);

    //  utility methods
    static HRESULT  AddItemNotify(ULONG, PCBXITEM, LPARAM);
    static DWORD    FileAssocThreadProc(void* pv);
    static INT_PTR  _FindExtension(HWND hwndCombo, TCHAR* pszExt);

    //  data
    FSEARCHTHREADSTATE  _threadState;
    TCHAR               _szRestoredExt[MAX_PATH];
};


// CAdvancedDlg - advanced options subordinate dialog
class CAdvancedDlg : public CDialogImpl<CAdvancedDlg>,
                     public CSubDlg

{
public:
    CAdvancedDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb) {}
    ~CAdvancedDlg() {}
    enum { IDD = DLG_FSEARCH_ADVANCED };

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void Clear();

protected:
    BEGIN_MSG_MAP(CAdvancedDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
};


class COptionsDlg : public CDialogImpl<COptionsDlg>,
                    public CSubDlg

{
public:
    COptionsDlg(CFileSearchBand* pfsb);
    ~COptionsDlg() {}

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave);
    virtual BOOL GetMinSize(LPSIZE pSize);
    virtual BOOL Validate();
    virtual void Clear();
    virtual void OnWinIniChange();

    void UpdateSearchCmdStateUI(DISPID dispid = 0);
    LONG QueryHeight(LONG cx, LONG cy);
    virtual HWND GetBottomItem();

    BOOL IsAdvancedOptionChecked(UINT nID)    {
        return _dlgAdvanced.IsDlgButtonChecked(nID) ? TRUE : FALSE ;
    }
    void TakeFocus();
    void DoDelayedInit();

    enum { IDD = DLG_FSEARCH_OPTIONS };

protected:
    BEGIN_MSG_MAP(COptionsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,   OnInitDialog)
        MESSAGE_HANDLER(WM_SIZE,         OnSize)
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick)
        NOTIFY_HANDLER(IDC_INDEX_SERVER, NM_CLICK,  OnIndexServerClick)
        NOTIFY_HANDLER(IDC_INDEX_SERVER, NM_RETURN, OnIndexServerClick)
    CHAIN_MSG_MAP(CSubDlg)
    END_MSG_MAP()

    //  messsage handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD,WORD,HWND,BOOL&);
    LRESULT OnIndexServerClick(int, LPNMHDR, BOOL&);

    //  utility methods
    void LayoutControls(int cx = -1, int cy = -1);
    void SizeToFit(BOOL bScrollBand = FALSE);

    //  data
private:
    //  private subdialog identifiers
    enum SUBDLGID
    {
        SUBDLG_DATE,
        SUBDLG_TYPE,
        SUBDLG_SIZE,
        SUBDLG_ADVANCED,

        SUBDLG_Count
    };
    
    //  subdialog instances
    CDateDlg          _dlgDate;
    CTypeDlg          _dlgType;
    CSizeDlg          _dlgSize;
    CAdvancedDlg      _dlgAdvanced;

    //  subdialog data definition block.
    typedef struct {
        UINT nIDCheck;
        CSubDlg* pDlg;
        SIZE sizeDlg;
        RECT rcCheck;
        RECT rcDlg;
    } _SUBDLG;
    _SUBDLG      _subdlgs[SUBDLG_Count];
    
    //  misc
    UINT _nCIStatusText; 
};

// top level dialog base class
class CBandDlg
{
public:
    CBandDlg(CFileSearchBand* pfsb);
    ~CBandDlg();

    HWND Hwnd() const           { return _hwnd; }

    //  manditory overrideables
    virtual HWND Create(HWND hwndParent) = 0;
    virtual UINT GetIconID() const = 0;
    virtual UINT GetCaptionID() const = 0;
    virtual UINT GetCaptionDivID() const = 0;

    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void RemoveToolbarTurds(int cyOffset);

    //  optional overrideables
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate()     { return TRUE; }
    virtual void Clear() {};
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual BOOL GetIdealSize(HWND hwndOC, LPSIZE pSize) const;
    virtual int  GetIdealDeskbandWidth() const { return -1; }
    virtual void SetDefaultFocus();
    virtual HWND GetFirstTabItem() const    { return NULL; }
    virtual HWND GetLastTabItem() const     { return NULL; }
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    virtual void NavigateToResults(IWebBrowser2* pwb2) {}
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave) {}
    virtual HWND ShowHelp(HWND hwndOwner) { return NULL; }
    virtual void OnWinIniChange()    {}
    virtual void WndPosChanging(HWND hwndOC, LPWINDOWPOS pwp);
    virtual void RememberFocus(HWND hwndFocus);
    virtual BOOL RestoreFocus();

    virtual void OnBandShow(BOOL bShow)   {}          //**band** show/hide handler
    virtual void OnBandDialogShow(BOOL bShow)   {}    //band **dialog** show/hide handler
    virtual HRESULT SetScope(IN VARIANT* pvarScope, BOOL bTrack = FALSE);
    virtual HRESULT GetScope(OUT VARIANT* pvarScope);
    virtual HRESULT SetQueryFile(IN VARIANT* pvarScope);
    virtual HRESULT GetQueryFile(OUT VARIANT* pvarScope);

    virtual BOOL    SearchInProgress() const { return FALSE; };
    virtual void    StopSearch() {};
protected:
    BEGIN_MSG_MAP(CBandDlg)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnCtlColorStatic)
        COMMAND_CODE_HANDLER(BN_SETFOCUS,   OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(EN_SETFOCUS,   OnChildSetFocusCmd)
        COMMAND_CODE_HANDLER(CBN_SETFOCUS,  OnChildSetFocusCmd)
        NOTIFY_CODE_HANDLER(NM_SETFOCUS,    OnChildSetFocusNotify) 

        COMMAND_CODE_HANDLER(BN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(EN_KILLFOCUS,  OnChildKillFocusCmd)
        COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnChildKillFocusCmd)
        NOTIFY_CODE_HANDLER(NM_KILLFOCUS,   OnChildKillFocusNotify) 
        NOTIFY_CODE_HANDLER(CBEN_ENDEDIT,   OnComboExEndEdit) 
    END_MSG_MAP()

    // message handlers
    LRESULT OnPaint(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnCtlColorStatic(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchLink(int, LPNMHDR, BOOL&);
    LRESULT OnEditChange(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildSetFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildSetFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnChildKillFocusCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnChildKillFocusNotify(int, LPNMHDR, BOOL&);
    LRESULT OnComboExEndEdit(int, LPNMHDR, BOOL&);

    //  utility methods:
    void _Attach(HWND hwnd)    { _hwnd = hwnd; }
    void _BeautifyCaption(UINT nIDCaption, UINT nIDIcon=0, UINT nIDIconResource=0);
    void _LayoutCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDDiv, LONG cxDlg);
    void _LayoutSearchLinks(UINT nIDCaption, UINT nIDDiv, BOOL bShowDiv, 
                             LONG left, LONG right, LONG yMargin, LONG& yStart, 
                             const int rgLinkIDs[], LONG cLinkIDs);

    CFileSearchBand* _pfsb;      // master band object
    VARIANT          _varScope0;
    VARIANT          _varQueryFile0;
    HWND             _hwndLastFocus;

private:
    HWND             _hwnd;
};

inline BOOL CBandDlg::GetMinSize(HWND hwndOC, LPSIZE pSize) const { 
    pSize->cx = pSize->cy = 0; return TRUE;
}

inline BOOL CBandDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2) { 
    *ppac2 = NULL; return FALSE;
}

//  Band dialog as searchCmdExt object wrap and event sink.
class CSearchCmdDlg : public DSearchCommandEvents, public CBandDlg
{
public:
    CSearchCmdDlg(CFileSearchBand* pfsb);
    ~CSearchCmdDlg();
    
    // ISearchCommandExt event sink

    //  IUnknown
    STDMETHOD (QueryInterface) (REFIID riid, void** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods 
    STDMETHOD(GetTypeInfoCount)(UINT*)              { return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo**) { return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR**, UINT, LCID, DISPID*) { return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);

    //  CBandDlg overrides
    virtual HWND Create(HWND hwndParent) = 0;
    virtual void Clear();
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);


    //  CSearchCmdDlg methods
    ISearchCommandExt* GetSearchCmd();
    virtual BOOL SearchInProgress() const { return _fSearchInProgress; }
    BOOL         SearchAborted() const    { return _fSearchAborted; }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd) { return E_NOTIMPL; }
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue) { return E_NOTIMPL; }

    HRESULT      StartSearch();
    virtual void StopSearch();
    HRESULT      SetQueryFile(IN VARIANT* pvarScope);

    HRESULT      DisconnectEvents();
    static void  EnableStartStopButton(HWND hwndBtn, BOOL bEnable);

    //  Overrideables
    virtual int  GetSearchType() const = 0; // ret: SCE_SEARCHFORxxx
    virtual HWND GetAnimation() { return NULL ; }

    virtual void UpdateSearchCmdStateUI(DISPID dispid = 0);
    virtual BOOL OnSearchCmdError(HRESULT hr, LPCTSTR pszError);
    virtual void UpdateStatusText();
    virtual void StartStopAnimation(BOOL bStart) ;
    virtual void RestoreSearch() {};
    virtual void OnBandShow(BOOL bShow) ;

protected:
    BOOL ProcessCmdError();

    BEGIN_MSG_MAP(CSearchCmdDlg)
        MESSAGE_HANDLER(WMU_RESTORESEARCH, OnRestoreSearch)
    CHAIN_MSG_MAP(CBandDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnRestoreSearch(UINT, WPARAM, LPARAM, BOOL&);

protected:
    //  utility methods
    HRESULT Execute(BOOL bStart);
    
    //  data
    IConnectionPoint*   _pcp;
    DWORD               _dwConnection;
    ISearchCommandExt*  _pSrchCmd;
    BOOL                _fSearchInProgress,
                        _fSearchAborted,
                        _fOnDestroy;
};

// top level dialog for Search for Files and Folders UI
class CFindFilesDlg : public CDialogImpl<CFindFilesDlg>, 
                      public CSearchCmdDlg
{
public:
    CFindFilesDlg(CFileSearchBand* pfsb);
    ~CFindFilesDlg();

    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_FSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_FSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual int  GetIdealDeskbandWidth() const;
    virtual void NavigateToResults(IWebBrowser2* pwb2);
    virtual HWND ShowHelp(HWND hwndOwner);

    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);

    virtual int  GetSearchType() const  { return SCE_SEARCHFORFILES; }
    virtual HWND GetAnimation() { return GetDlgItem(IDC_FSEARCH_ICON); }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    STDMETHOD (RestoreConstraint)(const BSTR bstrName, const VARIANT* pValue);
    virtual void UpdateSearchCmdStateUI(DISPID eventID = 0);
    virtual void RestoreSearch();
    virtual void LoadSaveUIState(UINT nIDCtl, BOOL bSave);
    virtual BOOL OnSearchCmdError(HRESULT hr, LPCTSTR pszError);


    BOOL SetDefaultScope();
    virtual void OnBandShow(BOOL bShow);
    virtual void OnBandDialogShow(BOOL bShow);

    virtual HRESULT SetScope(IN VARIANT* pvarScope, BOOL bTrack = FALSE);
    BOOL AssignNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszNamespace, BOOL bPassive /*only if no current selection*/);
    void OnWinIniChange();

    enum { IDD = DLG_FSEARCH_MAIN };

    BEGIN_MSG_MAP(CFindFilesDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WMU_COMBOPOPULATIONCOMPLETE, OnComboPopulationComplete)
        MESSAGE_HANDLER(WMU_STATECHANGE, OnStateChange)
        MESSAGE_HANDLER(WMU_UPDATELAYOUT, OnUpdateLayout) 
        MESSAGE_HANDLER(WMU_NAMESPACERECONCILE, OnNamespaceReconcileMsg)
        MESSAGE_HANDLER(WMU_BANDFINISHEDDISPLAYING, OnBandFinishedDisplaying);
        COMMAND_HANDLER(IDC_FILESPEC,   EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_GREPTEXT,   EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_EDITCHANGE, OnNamespaceEditChange)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_SELENDOK, OnNamespaceSelEndOk)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_SELENDCANCEL, OnNamespaceReconcileCmd)
        COMMAND_HANDLER(IDC_NAMESPACE,  CBN_DROPDOWN, OnNamespaceReconcileCmd)
        COMMAND_CODE_HANDLER(BN_CLICKED, OnBtnClick);
        NOTIFY_HANDLER(IDC_NAMESPACE, CBEN_DELETEITEM, OnNamespaceDeleteItem) 
        NOTIFY_HANDLER(IDC_NAMESPACE, CBEN_ENDEDIT, OnNamespaceReconcileNotify) 
        NOTIFY_HANDLER(IDC_SEARCHLINK_OPTIONS,   NM_CLICK, OnOptions)
        NOTIFY_HANDLER(IDC_SEARCHLINK_OPTIONS,   NM_RETURN, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     NM_CLICK, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     NM_RETURN, OnOptions)
        NOTIFY_HANDLER(IDC_GROUPBTN_OPTIONS,     GBN_QUERYBUDDYHEIGHT, OnQueryOptionsHeight)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)

        CHAIN_MSG_MAP(CSearchCmdDlg) // fall through to base class handlers
    END_MSG_MAP()

protected:
    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnStateChange(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnTimer(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnUpdateLayout(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBtnClick(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceDeleteItem(int, LPNMHDR, BOOL&);
    LRESULT OnNamespaceEditChange(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceSelEndOk(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceReconcileCmd(WORD, WORD, HWND, BOOL&);
    LRESULT OnNamespaceReconcileNotify(int, LPNMHDR, BOOL&);
    LRESULT OnNamespaceReconcileMsg(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnOptions(int, LPNMHDR, BOOL&);
    LRESULT OnQueryOptionsHeight(int, LPNMHDR, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBandFinishedDisplaying(UINT, WPARAM, LPARAM, BOOL&);

private:
    //  misc utility methods
    void                _ShowOptions(BOOL bShow = TRUE);
    LPARAM              _GetComboData(UINT id, INT_PTR idx);

    //  namespace scoping
    BOOL                _SetPreassignedScope();
    BOOL                _SetFolderScope();
    BOOL                _SetLocalDefaultScope();
    void                _ShowNamespaceEditImage(BOOL bShow);

    //  ad hoc namespace handling
    BOOL                _PathFixup(LPTSTR pszDst, UINT cchDst, LPCTSTR pszSrc);
    BOOL                _ShouldReconcileNamespace();
    void                _UIReconcileNamespace(BOOL bAsync = FALSE);
    INT_PTR             _ReconcileNamespace(OPTIONAL BOOL bAsync = FALSE);
    INT_PTR             _AddNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bSelectItem);

    //  namespace browsing
    void                _BrowseAndAssignNamespace();
    HRESULT             _BrowseForNamespace(LPTSTR pszPath, UINT cchPath, LPITEMIDLIST* ppidlRet);
    static int          _BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);

    //  more namespace helpers
    BOOL                _IsSearchableFolder(LPCITEMIDLIST pidlFolder);
    HRESULT             _GetTargetNamespace(IEnumIDList **ppenum);
    IEnumIDList         *_GetItems(INT_PTR i);
    INT_PTR             _FindNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl);

private:
    //  namespace combo thread
    static HRESULT      AddNamespaceItemNotify(ULONG, PCBXITEM, LPARAM);
    static DWORD        NamespaceThreadProc(void *pv);

    //  data
    COptionsDlg         _dlgOptions;
    FSEARCHTHREADSTATE  _threadState;
    TCHAR               _szInitialNames[MAX_PATH],          // SHGDN_NORMAL
                        _szInitialPath[MAX_PATH];           // SHGDN_FORPARSING
    LPITEMIDLIST        _pidlInitial;                       // Stores the initial PDIL                   
    TCHAR               _szCurrentPath[MAX_PATH];
    TCHAR               _szLocalDrives[MAX_URL_STRING];
    ULONG               _dwWarningFlags;        // docfind warning bits.
    BOOL                _dwRunOnceWarningFlags; 

    LRESULT             _iCurNamespace;     // combobox item index for currently selected namespace.
    BOOL                _fDebuted,          // this band dialog has been displayed before.
                        _bScoped,           // ve assigned a value to the namespace combo.
                        _fNamespace,        // TRUE if the user has been typing in the namespace combo.
                        _fDisplayOptions;   // Search Options group box is displayed

    IAutoComplete2*     _pacGrepText;       // 'Containing Text' autocomplete object    
    IStringMru*         _pmruGrepText;      // 'Containing Text' mru object
    IAutoComplete2*     _pacFileSpec;       // 'Files Named' autocomplete object    
    IStringMru*         _pmruFileSpec;      // 'Files Named' mru object

    enum {
        TRACKSCOPE_NONE,
        TRACKSCOPE_GENERAL,
        TRACKSCOPE_SPECIFIC,
    } ;
    ULONG               _fTrackScope;       // defines scope-tracking behavior.  See TRACKSCOPE_xxx flags
    BOOL                _fBandFinishedDisplaying; // TRUE if we have already resceived WMU_BANDFINISHEDDISPLAYING
};

inline HWND CFindFilesDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindFilesDlg>::Create(hwndParent);
}

#ifdef __PSEARCH_BANDDLG__

// CFindPrintersDlg - top level dialog for Search for Printers UI
class CFindPrintersDlg : public CDialogImpl<CFindPrintersDlg>,
                         public CBandDlg
{
public:
    CFindPrintersDlg(CFileSearchBand* pfsb);
    ~CFindPrintersDlg();

    // overrides of CBandDlg    
    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_PSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_PSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void OnWinIniChange();

    enum { IDD = DLG_PSEARCH };

protected:
    BEGIN_MSG_MAP(CFindPrintersDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER(IDC_PSEARCH_NAME,      EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_PSEARCH_LOCATION,  EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_PSEARCH_MODEL,     EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_SEARCH_START,      BN_CLICKED,  OnSearchStartBtn)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_COMPUTERS, NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)
    CHAIN_MSG_MAP(CBandDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchStartBtn(WORD, WORD, HWND, BOOL&);
};

inline HWND CFindPrintersDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindPrintersDlg>::Create(hwndParent);
}
#endif __PSEARCH_BANDDLG__


// CFindComputersDlg - top level dialog for Search for Computers UI
class CFindComputersDlg : public CDialogImpl<CFindComputersDlg>,
                          public CSearchCmdDlg
{
public:
    CFindComputersDlg(CFileSearchBand* pfsb);
    ~CFindComputersDlg();

    // overrides of CBandDlg    
    virtual HWND Create(HWND hwndParent);
    virtual UINT GetIconID() const       { return IDC_CSEARCH_ICON; }
    virtual UINT GetCaptionID() const    { return IDC_CSEARCH_CAPTION; }
    virtual UINT GetCaptionDivID() const { return IDC_FSEARCH_DIV1; }
    virtual void LayoutControls(int cx = -1, int cy = -1);
    virtual BOOL Validate();
    virtual void Clear();
    virtual BOOL GetMinSize(HWND hwndOC, LPSIZE pSize) const;
    virtual void NavigateToResults(IWebBrowser2* pwb2);

    virtual HWND ShowHelp(HWND hwndOwner);
    virtual HWND GetFirstTabItem() const;
    virtual HWND GetLastTabItem() const;
    virtual BOOL GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2);
    STDMETHOD (TranslateAccelerator)(MSG *pmsg);
    virtual void OnWinIniChange();
    
    virtual int  GetSearchType() const  { return SCE_SEARCHFORCOMPUTERS; }
    virtual HWND GetAnimation() { return GetDlgItem(IDC_CSEARCH_ICON); }

    STDMETHOD (AddConstraints)(ISearchCommandExt* pSrchCmd);
    virtual void UpdateStatusText();
    virtual void RestoreSearch();

    enum { IDD = DLG_CSEARCH };

protected:

    BEGIN_MSG_MAP(CFindComputersDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        COMMAND_HANDLER(IDC_CSEARCH_NAME,      EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_SEARCH_START,      BN_CLICKED,  OnSearchStartBtn)
        COMMAND_HANDLER(IDC_SEARCH_STOP,       BN_CLICKED,  OnSearchStopBtn)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_FILES,     NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PRINTERS,  NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_PEOPLE,    NM_RETURN, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_CLICK, OnSearchLink)
        NOTIFY_HANDLER(IDC_SEARCHLINK_INTERNET,  NM_RETURN, OnSearchLink)
    CHAIN_MSG_MAP(CSearchCmdDlg)
    END_MSG_MAP()

    //  message handlers
    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSearchStartBtn(WORD, WORD, HWND, BOOL&);
    LRESULT OnSearchStopBtn(WORD, WORD, HWND, BOOL&);

    //  data
    IAutoComplete2*     _pacComputerName;    // 'Files Named' autocomplete object    
    IStringMru*         _pmruComputerName;   // 'Files Named' mru object
};

inline HWND CFindComputersDlg::Create(HWND hwndParent) {
    return CDialogImpl<CFindComputersDlg>::Create(hwndParent);
}


DECLARE_INTERFACE_(IStringMru, IUnknown)
{
    // *** IStringMru specific methods ***
    STDMETHOD(Add)(LPCOLESTR pwszAdd) PURE;
};
extern const IID IID_IStringMru;


class CStringMru : public IStringMru, public IEnumString
{
public:
    static  HRESULT CreateInstance(HKEY hKey, LPCTSTR szSubKey, LONG cMaxStrings, BOOL bCaseSensitive,
                                    REFIID riid, void ** ppv); 
protected:
    // IUnknown
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IStringMru
    virtual STDMETHODIMP Add(LPCOLESTR pwsz);  // adds or promotes a string

    // IEnumString
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum)    { return E_NOTIMPL; }

private:
    CStringMru();
    ~CStringMru();

    HRESULT _Open();
    HRESULT _Read(OUT OPTIONAL LONG* pcRead = NULL /*count of strings read*/);
    HRESULT _Write(OUT OPTIONAL LONG* pcWritten = NULL /*count of strings written*/);
    HRESULT _Promote(LONG iString);
    void    _Close();
    void    _Delete();
    void    _Clear(); 

    HKEY    _hKey,
            _hKeyRoot;
    TCHAR   _szSubKey[MAX_PATH];
    LONG    _cRef;
    BOOL    _bCaseSensitive;
    LONG    _cMax;
    LONG    _iString;
    HDPA    _hdpaStrings;
};

//  DivWindow registration
#define  DIVWINDOW_CLASS     TEXT("DivWindow")

#define  DWM_FIRST          (WM_USER+0x300)
#define  DWM_SETHEIGHT      (DWM_FIRST+0)   // WPARAM: height in pixels, LPARAM: n/a, ret: BOOL
#define  DWM_SETBKCOLOR     (DWM_FIRST+1)   // WPARAM: COLORREF, LPARAM: n/a, ret: BOOL

//--------------------//
//  Helper macros
#define POINTSPERRECT   (sizeof(RECT)/sizeof(POINT))

//---------------------//
//  Misc utility
LONG _PixelsForDbu(HWND hwndDlg, LONG cDbu, BOOL bHorz);

#endif //__FSEARCH_DLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findband.h ===
// findband.h : Declaration of the CFileSearchBand

#ifndef __FSEARCH_H__
#define __FSEARCH_H__

#include "unicpp/stdafx.h"
#include "atldisp.h"    
#include "shcombox.h"   // shell combo methods
#include "finddlg.h"

class CFindFilesDlg;

#define FILESEARCHCTL_CLASS     TEXT("ShellFileSearchControl")

//  Band layout flags passed thru CFileSearchBand::UpdateLayout().
#define BLF_CALCSCROLL       0x00000001 // recalc scroll bars
#define BLF_SCROLLWINDOW     0x00000002 // scroll subdialog
#define BLF_RESIZECHILDREN   0x00000004 // resize subdialog
#define BLF_ALL              0xFFFFFFFF // do all layout ops

const UINT _icons[] = {
    //  replaced icons for fsearch, csearch with riff animations.
    IDI_PSEARCH,
};


//  CMetrics: maintains ctl metrics and resources.
class CMetrics
{
public:
    CMetrics();
    ~CMetrics() 
    { 
        DestroyResources(); 
    }

    void  Init(HWND hwndDlg);
    void  OnWinIniChange(HWND hwndDlg);
    static COLORREF TextColor()   { return GetSysColor(COLOR_WINDOWTEXT); }
    static COLORREF BkgndColor()  { return GetSysColor(COLOR_WINDOW); }
    static COLORREF BorderColor() { return GetSysColor(COLOR_WINDOWTEXT); }
    const HBRUSH&   BkgndBrush() const  { return _hbrBkgnd; }
    const HBRUSH&   BorderBrush() const { return _hbrBorder; }

    POINT&  ExpandOrigin() { return _ptExpandOrigin; }
    RECT&   CheckBoxRect() { return _rcCheckBox; }
    int&    TightMarginY() { return _cyTightMargin; }
    int&    LooseMarginY() { return _cyLooseMargin; }
    int&    CtlMarginX()   { return _cxCtlMargin; }
    HFONT   BoldFont(HWND hwndDlg);
    HICON   CaptionIcon(UINT nIDIconResource);

protected:
    BOOL    CreateResources();
    VOID    DestroyResources();
    static  BOOL GetWindowLogFont(HWND hwnd, OUT LOGFONT* plf);

    
    HBRUSH  _hbrBkgnd;
    HBRUSH  _hbrBorder;
    POINT   _ptExpandOrigin; // left-top origin of subdlg expansion 
    RECT    _rcCheckBox;     // size of a check box
    int     _cyTightMargin;  // v. distance between two tightly associated controls.
    int     _cyLooseMargin;  // v. distance between two loosely associated controls.
    int     _cxCtlMargin;    // distance between left or right dlg border and child window border.
    HFONT   _hfBold;         // Bold font
    HICON   _rghiconCaption[ARRAYSIZE(_icons)];
};

class ATL_NO_VTABLE CFileSearchBand : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFileSearchBand, &CLSID_FileSearchBand>,
    public CComControl<CFileSearchBand>,
    public CStockPropImpl<CFileSearchBand, IFileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32>,
    public IProvideClassInfo2Impl<&CLSID_FileSearchBand, NULL, &LIBID_Shell32>,
    public IPersistStreamInitImpl<CFileSearchBand>,
    public IPersistStorageImpl<CFileSearchBand>,
    public IQuickActivateImpl<CFileSearchBand>,
    public IOleControlImpl<CFileSearchBand>,
    public IOleInPlaceActiveObjectImpl<CFileSearchBand>,
    public IViewObjectExImpl<CFileSearchBand>,
    public IOleInPlaceObjectWindowlessImpl<CFileSearchBand>,
    public IDataObjectImpl<CFileSearchBand>,
    public ISpecifyPropertyPagesImpl<CFileSearchBand>,

    public IDeskBand,
    public IObjectWithSite,
    public IPersistStream,
    public IInputObject,
    public IServiceProvider,
    public IOleCommandTarget,

    //  Must derive from CShell32AtlIDispatch<> and not IOleObjecImpl 
    //  if this control resides in shell32.dll
    public CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
{
public:
    CFileSearchBand();
    ~CFileSearchBand();
    static  CWndClassInfo& GetWndClassInfo();
    HWND    Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL, 
                    DWORD dwStyle = WS_CHILD|WS_VISIBLE, DWORD dwExStyle = 0, UINT nID = 0);
    void    SetDeskbandWidth(int cx);
    void    FinalRelease();

public:
    BOOL        IsDeskBand() const       { return _fDeskBand; }
    static BOOL IsBandDebut();
    CMetrics&   GetMetrics()             { return _metrics; }
    static int  MakeBandKey(OUT LPTSTR pszKey, IN UINT cchKey);
    static int  MakeBandSubKey(IN LPCTSTR pszSubKey, OUT LPTSTR pszKey, IN UINT cchKey);
    static HKEY GetBandRegKey(BOOL bForceCreate = FALSE);
    void        UpdateLayout(ULONG fLayoutFlags = BLF_ALL);
    void        EnsureVisible(LPCRECT lprc /* in screen coords */);
    BOOL        IsKeyboardScroll(MSG* pmsg);
    HRESULT     IsDlgMessage(HWND hwnd, LPMSG pmsg);
    HRESULT     AutoActivate();

    void        SetDirty(BOOL bDirty = TRUE);
    BOOL        IsDirty() const          { return _fDirty; }
    BOOL        IsValid() const          { return _fValid; }

    IUnknown*       BandSite()           { return _punkSite ? _punkSite : (IUnknown*)m_spClientSite; }
    IOleClientSite* OleClientSite()      { return m_spClientSite; }

    DECLARE_NO_REGISTRY();

    BEGIN_COM_MAP(CFileSearchBand)
        COM_INTERFACE_ENTRY(IFileSearchBand)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IViewObjectEx)
        COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY(IOleControl)
        COM_INTERFACE_ENTRY(IOleObject)
        COM_INTERFACE_ENTRY(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistStorage)
        //COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)

        COM_INTERFACE_ENTRY_IID(IID_IDeskBand,IDeskBand)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY_IID(IID_IInputObject,IInputObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
        COM_INTERFACE_ENTRY(IPersistStream)
    END_COM_MAP()


public:
    BEGIN_PROPERTY_MAP(CFileSearchBand)
        // PROP_ENTRY("Property Description", dispid, clsid)
        PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    //  message map
    BEGIN_MSG_MAP(CFileSearchBand)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_SIZE, OnSize)
        MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
        MESSAGE_HANDLER(WM_SETTINGCHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WM_WININICHANGE,  OnWinIniChange)
        MESSAGE_HANDLER(WMU_BANDINFOUPDATE, OnBandInfoUpdate)
    END_MSG_MAP()

    //---------------------//
    //  Message handling
protected:
    LRESULT OnCreate(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnScroll(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnSize(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnMouseActivate(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnWinIniChange(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnBandInfoUpdate(UINT, WPARAM, LPARAM, BOOL&);

public:
    // IFileSearchBand methods
    STDMETHOD (SetFocus)();
    STDMETHOD (SetSearchParameters)(IN BSTR* pbstrSearchID, 
                                     IN VARIANT_BOOL bNavToResults,
                                     IN OPTIONAL VARIANT *pvarScope, 
                                     IN OPTIONAL VARIANT* pvarQueryFile);
    STDMETHOD (get_SearchID)(OUT BSTR* pbstrSearchID);
    STDMETHOD (get_Scope)(OUT VARIANT *pvarScope);
    STDMETHOD (get_QueryFile)(OUT VARIANT *pvarFile);

    STDMETHOD (FindFilesOrFolders)(BOOL bNavigateToResults = FALSE, 
                                    BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindComputer)(BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindPrinter) (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindPeople)  (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);
    STDMETHOD (FindOnWeb)   (BOOL bNavigateToResults = FALSE, 
                              BOOL bDefaultFocusCtl = FALSE);

    HRESULT OnDraw(ATL_DRAWINFO& di)    { return S_OK; }
    STDMETHOD (SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect); 

    //  CShell32AtlIDispatch/IOleObject methods
    STDMETHOD (PrivateQI)(REFIID iid, void** ppvObject);
    STDMETHOD (DoVerbUIActivate)(LPCRECT prcPosRect, HWND hwndParent);
    STDMETHOD (TranslateAcceleratorInternal)(MSG *pMsg, IOleClientSite * pocs);

    // IViewObjectEx methods
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    //  IOleInPlaceActiveObject methods
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg);

    //  IDeskBand
    STDMETHOD (GetBandInfo)(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);

    //  IDockingWindow
    STDMETHOD (ShowDW)(BOOL fShow);
    STDMETHOD (CloseDW)(DWORD dwReserved);
    STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);
    
    //  IOleWindow
    STDMETHOD (GetWindow)(HWND * lphwnd)              { *lphwnd = m_hWnd; return ::IsWindow(m_hWnd) ? S_OK : S_FALSE; }
    STDMETHOD (ContextSensitiveHelp)(BOOL fEnterMode) { return E_NOTIMPL; }

    //  IObjectWithSite
    STDMETHOD (SetSite)(IUnknown* punkSite);
    STDMETHOD (GetSite)(REFIID riid, void** ppunkSite);

    //  IInputObject
    STDMETHOD (HasFocusIO)(void);
    STDMETHOD (TranslateAcceleratorIO)(LPMSG lpMsg);
    STDMETHOD (UIActivateIO)(BOOL fActivate, LPMSG lpMsg);

    //  IOleCommandTarget
    STDMETHOD (QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHOD (Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    //  IServiceProvider
    STDMETHOD (QueryService)(REFGUID guidService, REFIID riid, void** ppv);

    //  IPersist
    STDMETHOD (GetClassID)(CLSID *pClassID); //

    //  IPersistStream
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(IStream *pStm); //
    STDMETHOD (Save)(IStream *pStm, BOOL fClearDirty); //
    STDMETHOD (GetSizeMax)(ULARGE_INTEGER *pcbSize);

    BOOL  SearchInProgress() const 
    {   
        if (_pBandDlg)
            return _pBandDlg->SearchInProgress();
        return FALSE;
    };
    void  StopSearch() 
    {
        if (_pBandDlg)
            _pBandDlg->StopSearch();
    };

private:
    CBandDlg*           GetBandDialog(REFGUID guidSearch);
    HRESULT             ShowBandDialog(REFGUID guidSearch, 
                                        BOOL bNavigateToResults = FALSE, 
                                        BOOL bDefaultFocusCtl = FALSE /* force focus to the band's default control */);
    HRESULT             AdvertiseBand(BOOL bAdvertise);
    HRESULT             BandInfoChanged();
    void                AddButtons(BOOL);
    BOOL                LoadImageLists();
    void                LayoutControls(int cx, int cy, ULONG fLayoutFlags = BLF_ALL);
    void                EnableControls();
    void                Scroll(int nBar, UINT uSBCode, int nNewPos = 0);
    IShellBrowser*      GetTopLevelBrowser();
    BOOL                IsBrowserAccelerator(LPMSG pmsg);

    CBandDlg*           BandDlg();

    CFindFilesDlg       _dlgFSearch;
    CFindComputersDlg   _dlgCSearch;
#ifdef __PSEARCH_BANDDLG__
    CFindPrintersDlg    _dlgPSearch;
#endif __PSEARCH_BANDDLG__
    CBandDlg*           _pBandDlg;     // the active/visible band.
    GUID                _guidSearch;   // the GUID of the active/visible band.

    CMetrics            _metrics;
    SIZE                _sizeMin,
                        _sizeMax;
    IUnknown*           _punkSite;
    SCROLLINFO          _siHorz,
                        _siVert;
    BITBOOL             _fValid : 1,
                        _fDirty : 1,
                        _fDeskBand : 1,
                        _fStrings : 1;
    DWORD               _dwBandID,
                        _dwBandViewMode;
    HIMAGELIST          _hilHot,       // toolbar image lists
                        _hilDefault;
    IShellBrowser*      _psb;          // top-level browser.
    LONG_PTR            _cbOffset;
    BOOL                _bSendFinishedDisplaying;   // Have we sent FileType box message to start new thread?
};

// Index Server control

// these are in ntquery.h

//  Query dialects:
#ifndef ISQLANG_V1
#define ISQLANG_V1 1 
#endif  //ISQLANG_V1

#ifndef ISQLANG_V2
#define ISQLANG_V2 2
#endif  //ISQLANG_V2

STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission);
STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine);
STDAPI StartStopCI(BOOL bStart);
STDAPI_(BOOL) IsCiQuery(const VARIANT* pvarRaw, OUT VARIANT* pvarQuery, OUT ULONG* pulDialect);

#endif //__FSEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\finddlg.cpp ===
#include "shellprv.h"
#include "findband.h"
#include "finddlg.h"
#include "findfilter.h"     // DFW_xxx warning flags.
#include "enumidlist.h"

void DivWindow_RegisterClass();

//  Namespace picker combo methods.
STDAPI PopulateNamespaceCombo(HWND hwndComboEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam);

#define MAX_EDIT                256
#define SUBDLG_BORDERWIDTH      0
#define MIN_NAMESPACELIST_WIDTH 140
#define MIN_FILEASSOCLIST_WIDTH 175

#define LSUIS_WARNING  1  // LoadSaveUIState warning flags

int  CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgTemplate, BOOL* pbNoWarn);
int  CCISettingsDlg_DoModal(HWND hwndParent);

BOOL IsConstraintName(LPCWSTR pwszConstraint, LPCWSTR pwszName)
{
    return pwszName && (0 == StrCmpIW(pwszName, pwszConstraint));
}

BOOL _GetWindowSize(HWND hwndDlg, SIZE *pSize)
{
    RECT rc;
    if (::GetClientRect(hwndDlg, &rc))
    {
        pSize->cx = RECTWIDTH(rc);
        pSize->cy = RECTHEIGHT(rc);
        return TRUE;
    }
    return FALSE;
}

BOOL _ModifyWindowStyle(HWND hwnd, DWORD dwAdd, DWORD dwRemove)
{
    ASSERT(dwAdd || dwRemove);

    if (IsWindow(hwnd))
    {
        DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
        if (dwAdd)
            dwStyle |= dwAdd;
        if (dwRemove)
            dwStyle &= ~dwRemove;
        SetWindowLong(hwnd, GWL_STYLE, dwStyle);
        return TRUE;
    }
    return FALSE;
}


BOOL _EnforceNumericEditRange(
    IN HWND hwndDlg, 
    IN UINT nIDEdit, 
    IN UINT nIDSpin,
    IN LONG nLow, 
    IN LONG nHigh, 
    IN BOOL bSigned = FALSE)
{
    BOOL bRet   = FALSE;
    BOOL bReset = FALSE;
    LONG lRet   = -1;

    if (nIDSpin)
    {
        lRet = (LONG)SendDlgItemMessage(hwndDlg, nIDSpin, UDM_GETPOS, 0, 0);
        bRet = 0 == HIWORD(lRet);
    }
    
    if (!bRet)
        lRet = (LONG)GetDlgItemInt(hwndDlg, nIDEdit, &bRet, bSigned);

    if (lRet < nLow)
    {
        lRet = nLow;
        bReset = TRUE;
    }
    else if (lRet > nHigh)
    {
        lRet = nHigh;
        bReset = TRUE;
    }

    if (bReset)
        SetDlgItemInt(hwndDlg, nIDEdit, lRet, bSigned);

    return bRet;
}


BOOL _IsDirectoryServiceAvailable()
{
    BOOL bRet = FALSE;

    IShellDispatch2* psd;
    if (SUCCEEDED(CoCreateInstance(CLSID_Shell, 0, CLSCTX_INPROC_SERVER,
                                     IID_PPV_ARG(IShellDispatch2, &psd))))
    {
        BSTR bstrName = SysAllocString(L"DirectoryServiceAvailable");
        if (bstrName)
        {
            VARIANT varRet = {0};
            if (SUCCEEDED(psd->GetSystemInformation(bstrName, &varRet)))
            {
                ASSERT(VT_BOOL == varRet.vt);
                bRet = varRet.boolVal;
            }
            SysFreeString(bstrName);
        }
        psd->Release();
    }
    return bRet;
}


//  Calculates number of pixels for dialog template units
LONG _PixelsForDbu(HWND hwndDlg, LONG cDbu, BOOL bHorz)
{
    RECT rc = {0,0,0,0};
    if (bHorz)
        rc.right = cDbu;
    else
        rc.bottom = cDbu;

    if (MapDialogRect(hwndDlg, &rc))
        return bHorz ? RECTWIDTH(rc) : RECTHEIGHT(rc);
    return 0;
}


//  Retrieves a localizable horizontal or vertical metric value from
//  the resource module.
LONG _GetResourceMetric(HWND hwndDlg, UINT nIDResource, BOOL bHorz /*orientation of metric*/)
{
    TCHAR szMetric[48];
    if (!EVAL(LoadString(HINST_THISDLL, nIDResource,
                           szMetric, ARRAYSIZE(szMetric))))
        return 0;

    LONG n = StrToInt(szMetric);
    return _PixelsForDbu(hwndDlg, n, bHorz);
}


//  Calculates the date nDays + nMonths from pstSrc.   nDays and/or nMonths
//  can be negative values.
BOOL _CalcDateOffset(const SYSTEMTIME* pstSrc, int nDays, int nMonths, OUT SYSTEMTIME* pstDest)
{
    ASSERT(pstSrc);
    ASSERT(pstDest);
    
    //  Subtract 90 days from current date and stuff in date low range
    FILETIME   ft;
    SystemTimeToFileTime(pstSrc, &ft);

    LARGE_INTEGER t;
    t.LowPart = ft.dwLowDateTime;
    t.HighPart = ft.dwHighDateTime;

    nDays += MulDiv(nMonths, 1461 /*days per 4 yrs*/, 48 /*months per 4 yrs*/);   
    t.QuadPart += Int32x32To64(nDays * 24 /*hrs per day*/ * 3600 /*seconds per hr*/,
                                10000000 /*100 ns intervals per sec*/);
    ft.dwLowDateTime = t.LowPart;
    ft.dwHighDateTime = t.HighPart;
    FileTimeToSystemTime(&ft, pstDest);
    return TRUE;
}


//  Loads a string into a combo box and assigns the string resource ID value
//  to the combo item's data.
BOOL _LoadStringToCombo(HWND hwndCombo, int iPos, UINT idString, LPARAM lpData)
{
    TCHAR szText[MAX_EDIT];
    if (LoadString(HINST_THISDLL, idString, szText, ARRAYSIZE(szText)))
    {
        INT_PTR idx = ::SendMessage(hwndCombo, CB_INSERTSTRING, iPos, (LPARAM)szText);
        if (idx != CB_ERR)
        {
            ::SendMessage(hwndCombo, CB_SETITEMDATA, idx, lpData);
            return TRUE;
        }
    }
    return FALSE;
}


//  Retrieves combo item's data.  If idx == CB_ERR, the currently selected
//  item's data will be retrieved.
LPARAM _GetComboData(HWND hwndCombo, INT_PTR idx = CB_ERR)
{
    if (CB_ERR == idx)
        idx = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (CB_ERR == idx)
        return idx;

    return (LPARAM)::SendMessage(hwndCombo, CB_GETITEMDATA, idx, 0);
}


//  Selects combo item with matching data, and returns the index
//  of the selected item.
INT_PTR _SelectComboData(HWND hwndCombo, LPARAM lpData)
{
    for (INT_PTR i = 0, cnt = SendMessage(hwndCombo, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        LPARAM lParam = SendMessage(hwndCombo, CB_GETITEMDATA, i, 0);
        if (lParam != CB_ERR && lParam == lpData)
        {
            SendMessage(hwndCombo, CB_SETCURSEL, i, 0);
            return i;
        }
    }
    return CB_ERR;
}


BOOL _IsPathList(LPCTSTR pszPath)
{
    return pszPath ? StrChr(pszPath, TEXT(';')) != NULL : FALSE;
}


HRESULT _IsPathValidUNC(HWND hWndParent, BOOL fNetValidate, LPCTSTR pszPath)
{
    HRESULT hr = S_OK;

    if (PathIsUNC(pszPath))
    {
        if (fNetValidate)
        {
            NETRESOURCE nr = {0};
            TCHAR szPathBuffer[MAX_PATH];

            hr = StringCchCopy(szPathBuffer, ARRAYSIZE(szPathBuffer), pszPath);
            if (SUCCEEDED(hr))
            {
                nr.dwType = RESOURCETYPE_DISK;
                nr.lpRemoteName = szPathBuffer;

                if (NO_ERROR != WNetAddConnection3(hWndParent, &nr, NULL, NULL,
                    CONNECT_TEMPORARY | CONNECT_INTERACTIVE))
                {
                    hr = E_FILE_NOT_FOUND;
                }
            }
            else
            {
                hr = E_FILE_NOT_FOUND;      // Handle it like it's a bad file name
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

BOOL _IsFullPathMinusDriveLetter(LPCTSTR pszPath)
{
    if (NULL == pszPath || PathIsUNC(pszPath))
        return FALSE;
    ASSERT(!PathIsRelative(pszPath));

    // Eat whitespace
    for (; (0 != *pszPath) && (TEXT(' ') == *pszPath) ; pszPath = CharNext(pszPath));

    return TEXT('\\') == *pszPath &&
            -1 == PathGetDriveNumber(pszPath);
}

BOOL _PathLooksLikeFilePattern(LPCTSTR pszPath)
{
    return StrPBrk(pszPath, TEXT("?*")) != NULL;
}


BOOL _PathIsDblSlash(LPCTSTR pszPath)
{
    return pszPath && (pszPath[0] == TEXT('\\')) && (pszPath[1] == TEXT('\\'));
}


BOOL _PathIsUNCServerShareOrSub(LPCTSTR pszPath)
{
    int cSlash = 0;
    if (_PathIsDblSlash(pszPath))
    {
        for (LPTSTR psz = (LPTSTR)pszPath; psz && *psz; psz = CharNext(psz))
        {
            if (*psz == TEXT('\\'))
                cSlash++;
        }
    }
    return cSlash >= 3;
}


BOOL _IsPathLocalHarddrive(LPCTSTR pszPath)
{
    int iDrive = PathGetDriveNumber(pszPath);
    if (iDrive != -1)
    {
        TCHAR szRoot[16];
        return DRIVE_FIXED == GetDriveType(PathBuildRoot(szRoot, iDrive));
    }
    return FALSE;
}


// from an object in the browser and it's site find the current pidl of what
// we are looking at

HRESULT _GetCurrentFolderIDList(IUnknown* punkSite, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr)) 
    {
        IShellView* psv;
        hr = psb->QueryActiveShellView(&psv);
        if (SUCCEEDED(hr)) 
        {
            IFolderView *pfv;
            hr = psv->QueryInterface(IID_PPV_ARG(IFolderView, &pfv));
            if (SUCCEEDED(hr)) 
            {
                IShellFolder* psf;
                hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf));
                if (SUCCEEDED(hr)) 
                {
                    hr = SHGetIDListFromUnk(psf, ppidl);
                    psf->Release();
                }
                pfv->Release();
            }
            psv->Release();
        }
        psb->Release();
    }
    return hr;
}

HRESULT _PathValidate(LPCTSTR pszPath, HWND hWndParent, BOOL fNetValidate)
{
    HRESULT hr = _IsPathValidUNC(hWndParent, fNetValidate, pszPath);
    if (S_OK == hr)
    {
        // We are done.
    }
    else if (E_FILE_NOT_FOUND != hr)
    {
        if (_IsPathList(pszPath) || PathIsSlow(pszPath, -1))
        {
            hr = S_OK;  // Skip check for slow files.
        }
        else
        {
            DWORD dwAttr;

            if (PathIsRelative(pszPath) || _IsFullPathMinusDriveLetter(pszPath))
            {
                hr = E_FILE_NOT_FOUND; // don't accept anything but a fully qualified path at this point.
                dwAttr = -1;
            }
            else
            {
                dwAttr = GetFileAttributes(pszPath);  // Does it exist?
    
                if (-1 == dwAttr)
                {
                    HRESULT hrFromPrepareForWrite = S_OK;

                    // Maybe the disk isn't inserted, so allow the user
                    // the chance to insert it.
                    if (hWndParent)
                    {
                        hrFromPrepareForWrite = SHPathPrepareForWrite(hWndParent, NULL, pszPath, SHPPFW_IGNOREFILENAME);
                        if (SUCCEEDED(hrFromPrepareForWrite))
                            dwAttr = GetFileAttributes(pszPath);  // Does it exist now?
                    }

                    // If SHPathPrepareForWrite() displays UI, then they will return HRESULT_FROM_WIN32(ERROR_CANCELLED)
                    // so that the callers (us) will skip displaying our UI.  If this is the case, when propagate that error.
                    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hrFromPrepareForWrite)
                    {
                        hr = hrFromPrepareForWrite;
                    }
                    else
                    {
                        if (-1 == dwAttr)
                            hr = E_FILE_NOT_FOUND;    // It doesn't exist.
                        else
                            hr = S_OK;      // It exists now.
                    }
                }
            }
        }
    }
    return hr;
}

BOOL _FmtError(UINT nIDFmt, LPCTSTR pszSub, LPTSTR szBuf, int cchBuf)
{
    TCHAR szFmt[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, nIDFmt, szFmt, ARRAYSIZE(szFmt))))
    {
        StringCchPrintf(szBuf, cchBuf, szFmt, pszSub);  // ok to truncate
        return TRUE;
    }
    return FALSE;
}

//  Retrieves the window text as a variant value of the specified type.
HRESULT _GetWindowValue(HWND hwndDlg, UINT nID, VARIANT* pvar)
{
    TCHAR szText[MAX_EDIT];
    LPTSTR pszText;
    if (::GetDlgItemText(hwndDlg, nID, szText, ARRAYSIZE(szText)))
        pszText = szText;
    else
        pszText = NULL;

    return InitVariantFromStr(pvar, pszText);
}


//  Loads the window text from a string resource.
BOOL _LoadWindowText(HWND hwnd, UINT nIDString)
{
    TCHAR szText[MAX_PATH];
    if (LoadString(HINST_THISDLL, nIDString, szText, ARRAYSIZE(szText)))
        return SetWindowText(hwnd, szText);
    return FALSE;
}


//  Retrieves the window text as a variant value of the specified type.
HRESULT _SetWindowValue(HWND hwndDlg, UINT nID, const VARIANT* pvar)
{
    switch (pvar->vt)
    {
    case VT_BSTR:
        SetDlgItemTextW(hwndDlg, nID, pvar->bstrVal);
        break;

    case VT_UI4:
        SetDlgItemInt(hwndDlg, nID, pvar->uiVal, FALSE);
        break;
        
    case VT_I4:
        SetDlgItemInt(hwndDlg, nID, pvar->lVal, TRUE);
        break;

    default:
        return E_NOTIMPL;
    }
    return S_OK;
}

//  Adds a named constraint to the specified search command extension object
HRESULT _AddConstraint(ISearchCommandExt* pSrchCmd, LPCWSTR pwszConstraint, VARIANT* pvarValue)
{
    HRESULT hr;
    BSTR bstrConstraint = SysAllocString(pwszConstraint);
    if (bstrConstraint)
    {
        hr = pSrchCmd->AddConstraint(bstrConstraint, *pvarValue);
        SysFreeString(bstrConstraint);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

void _PaintDlg(HWND hwndDlg, const CMetrics& metrics, HDC hdcPaint = NULL, LPCRECT prc = NULL)
{
    RECT rcPaint /* rcLine */;
    HDC  hdc = hdcPaint;

    if (NULL == hdcPaint)
        hdc = GetDC(hwndDlg);

    if (prc == NULL)
    {
        GetClientRect(hwndDlg, &rcPaint);
        prc = &rcPaint;
    }

    FillRect(hdc, prc, metrics.BkgndBrush());
        
    if (NULL == hdcPaint)
        ReleaseDC(hwndDlg, hdc);
}


void _EnsureVisible(HWND hwndDlg, HWND hwndVis, CFileSearchBand* pfsb)
{
    ASSERT(pfsb);
    ASSERT(::IsWindow(hwndDlg));
    ASSERT(::IsWindow(hwndVis));
    
    RECT rcDlg, rcVis, rcX;
    GetWindowRect(hwndDlg, &rcDlg);
    GetWindowRect(hwndVis, &rcVis);

    if (IntersectRect(&rcX, &rcDlg, &rcVis))
        pfsb->EnsureVisible(&rcX);
}


inline BOOL _IsKeyPressed(int virtkey)
{
    return (GetKeyState(virtkey) & 8000) != 0;
}


HWND _CreateDivider(HWND hwndParent, UINT nIDC, const POINT& pt, int nThickness = 1, HWND hwndAfter = NULL)
{
    HWND hwndDiv = CreateWindowEx(0, DIVWINDOW_CLASS, NULL,
                                   WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE,
                                   pt.x, pt.y, 400, 1, hwndParent, 
                                   IntToPtr_(HMENU, nIDC), HINST_THISDLL, NULL);
    if (IsWindow(hwndDiv))
    {
        if (IsWindow(hwndAfter))
            SetWindowPos(hwndDiv, hwndAfter, 0,0,0,0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);

        SendMessage(hwndDiv, DWM_SETHEIGHT, nThickness, 0);
        return hwndDiv;
    }
    return NULL;
}


HWND _CreateLinkWindow(HWND hwndParent, UINT nIDC, const POINT& pt, UINT nIDCaption, BOOL bShow = TRUE)
{
    DWORD dwStyle = WS_CHILD|WS_TABSTOP|WS_CLIPSIBLINGS;
    if (bShow)
        dwStyle |= WS_VISIBLE;
    
    HWND hwndCtl = CreateWindowEx(0, WC_LINK, NULL, dwStyle,
                                   pt.x, pt.y, 400, 18, hwndParent, 
                                   IntToPtr_(HMENU, nIDC), HINST_THISDLL, NULL);
        
    if (IsWindow(hwndCtl))
    {
        _LoadWindowText(hwndCtl, nIDCaption);
        return hwndCtl;
    }

    return NULL;
}


BOOL _EnableLink(HWND hwndLink, BOOL bEnable)
{
    LWITEM item;
    item.mask       = LWIF_ITEMINDEX|LWIF_STATE;
    item.stateMask  = LWIS_ENABLED;
    item.state      = bEnable ? LWIS_ENABLED : 0;
    item.iLink      = 0;

    return (BOOL)SendMessage(hwndLink, LWM_SETITEM, 0, (LPARAM)&item);
}


int _CreateSearchLinks(HWND hwndDlg, const POINT& pt, UINT nCtlIDdlg /* ctl ID of link to hwndDlg */)
{
    const UINT rgCtlID[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        IDC_SEARCHLINK_INTERNET,
    };
    const UINT rgCaptionID[] = {
        IDS_FSEARCH_SEARCHLINK_FILES,
        IDS_FSEARCH_SEARCHLINK_COMPUTERS,
        IDS_FSEARCH_SEARCHLINK_PRINTERS,
        IDS_FSEARCH_SEARCHLINK_PEOPLE,
        IDS_FSEARCH_SEARCHLINK_INTERNET,
    };
    int  cLinks = 0;
    BOOL bDSEnabled = _IsDirectoryServiceAvailable();

    for (int i = 0; i < ARRAYSIZE(rgCtlID); i++)
    {
        //  block creation of csearch, psearch search links 
        //  if Directory Service is not available.
        if (((IDC_SEARCHLINK_PRINTERS == rgCtlID[i]) && rgCtlID[i] != nCtlIDdlg && !bDSEnabled)
        ||  (IDC_SEARCHLINK_FILES == rgCtlID[i] && SHRestricted(REST_NOFIND)))
        {
            continue;
        }
        
        if (_CreateLinkWindow(hwndDlg, rgCtlID[i], pt, rgCaptionID[i]))
                cLinks++;
    }

    //  Disable link to current dialog:
    _EnableLink(GetDlgItem(hwndDlg, nCtlIDdlg), FALSE);

    return cLinks;
}


void _LayoutLinkWindow(
    IN HWND hwnd,     // parent window
    IN LONG left,     // left position of link
    IN LONG right,    // right position of link
    IN LONG yMargin,  // vertical padding between links
    IN OUT LONG& y,   // IN: where to start (RECT::top).  OUT: where the last link was positioned (RECT::bottom).
    IN const int nCtlID) // ctl ID 
{
    HWND hwndLink;
    
    if (nCtlID > 0)
    {
        hwndLink = GetDlgItem(hwnd, nCtlID);
        RECT rcLink;
        if (!IsWindow(hwndLink))
            return;

        ::GetWindowRect(hwndLink, &rcLink);
        ::MapWindowRect(NULL, hwnd, &rcLink);
        rcLink.left  = left;
        rcLink.right = right;

        int cyIdeal = (int)::SendMessage(hwndLink, LWM_GETIDEALHEIGHT, RECTWIDTH(rcLink), 0);
        if (cyIdeal >= 0)
            rcLink.bottom = rcLink.top + cyIdeal;

        OffsetRect(&rcLink, 0, y - rcLink.top);
        y = rcLink.bottom;

        ::SetWindowPos(hwndLink, NULL, 
                        rcLink.left, rcLink.top, 
                        RECTWIDTH(rcLink), RECTHEIGHT(rcLink),
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }
    else if (nCtlID < 0)
    {
        //  this is a divider window
        hwndLink = GetDlgItem(hwnd, -nCtlID);
        ::SetWindowPos(hwndLink, NULL, left, y + yMargin/2, right - left, 1, 
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }
    y += yMargin;
}


void _LayoutLinkWindows(
    IN HWND hwnd,     // parent window
    IN LONG left,     // left position of links
    IN LONG right,    // right position of links
    IN LONG yMargin,  // vertical padding between links
    IN OUT LONG& y,   // IN: where to start (RECT::top).  OUT: where the last link was positioned (RECT::bottom).
    IN const int rgCtlID[],// array of link ctl IDs.  use IDC_SEPARATOR for separators
    IN LONG cCtlID)  // number of array elements to layout in rgCtlID.
{
    for (int i = 0; i < cCtlID; i++)
        _LayoutLinkWindow(hwnd, left, right, yMargin, y, rgCtlID[i]);
}

//  Retrieves AutoComplete flags
//
#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define BOOL_NOT_SET                        0x00000005

DWORD _GetAutoCompleteSettings()
{
    DWORD dwACOptions = 0;

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, TEXT("Always Use Tab"), FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


//  Initializes and enables an MRU autocomplete list on the specified
//  edit control
HRESULT _InitializeMru(HWND hwndEdit, IAutoComplete2** ppAutoComplete, LPCTSTR pszSubKey, IStringMru** ppStringMru)
{
    *ppAutoComplete = NULL;
    *ppStringMru = NULL;

    HRESULT hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER,
                                   IID_PPV_ARG(IAutoComplete2, ppAutoComplete));
    if (SUCCEEDED(hr))
    {
        TCHAR szKey[MAX_PATH];
        if (CFileSearchBand::MakeBandSubKey(pszSubKey, szKey, ARRAYSIZE(szKey)) > 0)
        {
            hr = CStringMru::CreateInstance(HKEY_CURRENT_USER, szKey, 25, FALSE, 
                                             IID_PPV_ARG(IStringMru, ppStringMru));
            if (SUCCEEDED(hr))
            {
                hr = (*ppAutoComplete)->Init(hwndEdit, *ppStringMru, NULL, NULL);
            }
        }
        else
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        (*ppAutoComplete)->SetOptions(_GetAutoCompleteSettings());
        (*ppAutoComplete)->Enable(TRUE);
    }
    else
    {
        ATOMICRELEASE((*ppAutoComplete));        
        ATOMICRELEASE((*ppStringMru));        
    }

    return hr;
}

HRESULT _AddMruStringFromWindow(IStringMru* pmru, HWND hwnd)
{
    ASSERT(::IsWindow(hwnd));
    HRESULT hr = E_FAIL;

    if (pmru)
    {
        TCHAR szText[MAX_PATH * 3];
        if (GetWindowTextW(hwnd, szText, ARRAYSIZE(szText)) > 0)
            hr = pmru->Add(szText);
        else
            hr = S_FALSE;
    }
    return hr;
}


HRESULT _TestAutoCompleteDropDownState(IAutoComplete2* pac2, DWORD dwTest)
{
    IAutoCompleteDropDown* pacdd;
    HRESULT hr = pac2->QueryInterface(IID_PPV_ARG(IAutoCompleteDropDown, &pacdd));
    if (SUCCEEDED(hr))
    {
        DWORD dwFlags;
        if (SUCCEEDED((hr = pacdd->GetDropDownStatus(&dwFlags, NULL))))
            hr = (dwFlags & dwTest) ? S_OK : S_FALSE;
        pacdd->Release();
    }
    return hr;
}

inline HWND _IndexServiceHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("isconcepts.chm"), HH_DISPLAY_TOPIC, 0);
}

LRESULT CSubDlg::OnNcCalcsize(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    InflateRect((LPRECT)lParam, -SUBDLG_BORDERWIDTH, -SUBDLG_BORDERWIDTH);
    return 0;
}

LRESULT CSubDlg::OnNcPaint(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    RECT    rc;
    HDC     hdc;
    HBRUSH  hbr = _pfsb->GetMetrics().BorderBrush();
    
    GetWindowRect(Hwnd(), &rc);
    OffsetRect(&rc, -rc.left, -rc.top);
    
    if (hbr && (hdc = GetWindowDC(Hwnd())) != NULL)
    {
        for (int i=0; i < SUBDLG_BORDERWIDTH; i++)
        {
            FrameRect(hdc, &rc, hbr);
            InflateRect(&rc, -1, -1);
        }

        ReleaseDC(Hwnd(), hdc);
    }
    
    return 0;
}


LRESULT CSubDlg::OnCtlColor(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    SetTextColor((HDC)wParam, _pfsb->GetMetrics().TextColor());
    SetBkColor((HDC)wParam, _pfsb->GetMetrics().BkgndColor());
    return (LRESULT)_pfsb->GetMetrics().BkgndBrush();
}

LRESULT CSubDlg::OnPaint(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Just going to call BeginPaint and EndPaint.  All
    //  painting done in WM_ERASEBKGND handler to avoid flicker.
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(_hwnd, &ps);
    if (hdc)
    {
        EndPaint(_hwnd, &ps);
    }
    return 0;
}

LRESULT CSubDlg::OnSize(UINT, WPARAM, LPARAM, BOOL&)
{
    ASSERT(::IsWindow(Hwnd())); // was _Attach() called, e.g. from WM_INITDIALOG?
    _PaintDlg(Hwnd(), _pfsb->GetMetrics());
    ValidateRect(Hwnd(), NULL);
    return 0;
}

LRESULT CSubDlg::OnEraseBkgnd(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    _PaintDlg(Hwnd(), _pfsb->GetMetrics(), (HDC)wParam);
    ValidateRect(Hwnd(), NULL);
    return TRUE;
}

STDMETHODIMP CSubDlg::TranslateAccelerator(MSG *pmsg)
{
    if (_pfsb->IsKeyboardScroll(pmsg))
        return S_OK;

    return _pfsb->IsDlgMessage(Hwnd(), pmsg);
}

LRESULT CSubDlg::OnChildSetFocusCmd(WORD wNotifyCode, WORD wID, HWND hwndCtl, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, hwndCtl, _pfsb);
    bHandled = FALSE;
    return 0;
}

LRESULT CSubDlg::OnChildSetFocusNotify(int, NMHDR *pnmh, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, pnmh->hwndFrom, _pfsb);
    bHandled = FALSE;
    return 0;
}

LRESULT CSubDlg::OnChildKillFocusCmd(WORD, WORD, HWND hwndCtl, BOOL&)
{
    if (_pBandDlg)
        _pBandDlg->RememberFocus(hwndCtl);
    return 0;
}

LRESULT CSubDlg::OnChildKillFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    if (_pBandDlg)
        _pBandDlg->RememberFocus(pnmh->hwndFrom);
    return 0;
}

LRESULT CSubDlg::OnComboExEndEdit(int, NMHDR *pnmh, BOOL&)
{
    if (CBENF_KILLFOCUS == ((NMCBEENDEDIT*)pnmh)->iWhy)
    {
        if (_pBandDlg)
            _pBandDlg->RememberFocus(pnmh->hwndFrom);
    }
    return 0;
}


// CDateDlg impl

#define RECENTMONTHSRANGE_HIGH      999  
#define RECENTDAYSRANGE_HIGH        RECENTMONTHSRANGE_HIGH
#define RECENTMONTHSRANGE_HIGH_LEN  3 // count of digits in RECENTMONTHSRANGE_HIGH
#define RECENTDAYSRANGE_HIGH_LEN    RECENTMONTHSRANGE_HIGH_LEN
#define RECENTMONTHSRANGE_LOW       1
#define RECENTDAYSRANGE_LOW         RECENTMONTHSRANGE_LOW


LRESULT CDateDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT(_pfsb);
    _Attach(m_hWnd);

    HWND hwndCombo = GetDlgItem(IDC_WHICH_DATE);

    SendDlgItemMessage(IDC_RECENT_MONTHS_SPIN, UDM_SETRANGE32, 
                        RECENTMONTHSRANGE_HIGH, RECENTMONTHSRANGE_LOW);
    SendDlgItemMessage(IDC_RECENT_DAYS_SPIN, UDM_SETRANGE32, 
                        RECENTDAYSRANGE_HIGH, RECENTDAYSRANGE_LOW);

    SendDlgItemMessage(IDC_RECENT_MONTHS, EM_LIMITTEXT, RECENTMONTHSRANGE_HIGH_LEN, 0);
    SendDlgItemMessage(IDC_RECENT_DAYS,   EM_LIMITTEXT, RECENTDAYSRANGE_HIGH_LEN, 0);

    SYSTEMTIME st[2] = {0};

    // lower limit -- dos date does not support anything before 1/1/1980
    st[0].wYear = 1980;
    st[0].wMonth = 1;
    st[0].wDay = 1;
    // upper limit
    st[1].wYear = 2099;
    st[1].wMonth = 12;
    st[1].wDay = 31;
    SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_SETRANGE, GDTR_MIN | GDTR_MAX, (LPARAM)st);
    SendDlgItemMessage(IDC_DATERANGE_END,   DTM_SETRANGE, GDTR_MIN | GDTR_MAX, (LPARAM)st);
    
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_MODIFIED_DATE, IDS_FSEARCH_MODIFIED_DATE);
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_CREATION_DATE, IDS_FSEARCH_CREATION_DATE);
    _LoadStringToCombo(hwndCombo, -1, IDS_FSEARCH_ACCESSED_DATE, IDS_FSEARCH_ACCESSED_DATE);

    Clear();

    return TRUE;  // Let the system set the focus
}

BOOL CDateDlg::Validate()
{
    return TRUE;
}

STDMETHODIMP CDateDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    VARIANT var;
    BOOL    bErr;
    UINT_PTR nIDString = _GetComboData(GetDlgItem(IDC_WHICH_DATE));

    HRESULT hr;
#if 1
    hr = InitVariantFromStr(&var, 
        (IDS_FSEARCH_MODIFIED_DATE == nIDString) ? L"Write" :
        (IDS_FSEARCH_CREATION_DATE == nIDString) ? L"Create" : L"Access");
#else
    var.vt = VT_UI4;
    var.ulVal = (IDS_FSEARCH_MODIFIED_DATE == nIDString) ? 1 :
                (IDS_FSEARCH_CREATION_DATE == nIDString) ? 2 :
                (IDS_FSEARCH_ACCESSED_DATE == nIDString) ? 3 : 0;
    hr = S_OK;
    ASSERT(var.ulVal);
#endif

    if (SUCCEEDED(hr))
    {
        hr = _AddConstraint(pSrchCmd, L"WhichDate", &var);
        VariantClear(&var);
    }
    
    if (IsDlgButtonChecked(IDC_USE_RECENT_MONTHS))
    {
        var.vt = VT_I4;
        var.ulVal = (ULONG)SendDlgItemMessage(IDC_RECENT_MONTHS_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
        if (!bErr)
            hr = _AddConstraint(pSrchCmd, L"DateNMonths", &var);

    }
    else if (IsDlgButtonChecked(IDC_USE_RECENT_DAYS))
    {
        var.vt = VT_I4;
        var.ulVal = (ULONG)SendDlgItemMessage(IDC_RECENT_DAYS_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
        if (!bErr)
            hr = _AddConstraint(pSrchCmd, L"DateNDays", &var);
    }
    else if (IsDlgButtonChecked(IDC_USE_DATE_RANGE))     
    {
        SYSTEMTIME stBegin, stEnd;

        var.vt = VT_DATE;

        LRESULT lRetBegin = SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_GETSYSTEMTIME, 0, (LPARAM)&stBegin);
        LRESULT lRetEnd   = SendDlgItemMessage(IDC_DATERANGE_END,   DTM_GETSYSTEMTIME, 0, (LPARAM)&stEnd);

        if (GDT_VALID == lRetBegin && GDT_VALID == lRetEnd)
        {
#ifdef DEBUG
            FILETIME ft;
            //validate that we were passed a correct date
            //SystemTimeToFileTime calls internal API IsValidSystemTime.
            //This will save us from OLE Automation bug# 322789

            // the only way we can get a date is through date/time picker
            // control which should validate the dates so just assert...
            ASSERT(SystemTimeToFileTime(&stBegin, &ft));
#endif
            SystemTimeToVariantTime(&stBegin, &var.date);
            hr = _AddConstraint(pSrchCmd, L"DateGE", &var);
#ifdef DEBUG
            ASSERT(SystemTimeToFileTime(&stEnd, &ft));
#endif

            SystemTimeToVariantTime(&stEnd, &var.date);
            hr = _AddConstraint(pSrchCmd, L"DateLE", &var);
        }
    }
    
    return hr;
}


//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CDateDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    HRESULT hr = E_FAIL;
    BOOL    bUseMonths = FALSE,
            bUseDays = FALSE,
            bUseRange = FALSE;
            
    if (IsConstraintName(L"WhichDate", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt)
        UINT nIDS = pValue->lVal == 1 ? IDS_FSEARCH_MODIFIED_DATE :
                    pValue->lVal == 2 ? IDS_FSEARCH_CREATION_DATE :
                    pValue->lVal == 3 ? IDS_FSEARCH_ACCESSED_DATE : 0;

        if (nIDS != 0)
            _SelectComboData(GetDlgItem(IDC_WHICH_DATE), nIDS);

        return nIDS == IDS_FSEARCH_MODIFIED_DATE /*default*/ ? 
                       S_FALSE /* don't open */: S_OK /* open */;
    }
    
    if (IsConstraintName(L"DateNMonths", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt);
        bUseMonths = TRUE;
        _SetWindowValue(m_hWnd, IDC_RECENT_MONTHS, pValue);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateNDays", bstrName))
    {
        ASSERT(VT_I4 == pValue->vt);
        bUseDays = TRUE;
        _SetWindowValue(m_hWnd, IDC_RECENT_DAYS, pValue);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateGE", bstrName))
    {
        ASSERT(VT_DATE == pValue->vt);
        bUseRange = TRUE;

        SYSTEMTIME st;
        VariantTimeToSystemTime(pValue->date, &st);
        SendDlgItemMessage(IDC_DATERANGE_BEGIN, DTM_SETSYSTEMTIME, 0, (LPARAM)&st);
        hr = S_OK;
    }
    else if (IsConstraintName(L"DateLE", bstrName))
    {
        ASSERT(VT_DATE == pValue->vt);
        bUseRange = TRUE;

        SYSTEMTIME st;
        VariantTimeToSystemTime(pValue->date, &st);
        SendDlgItemMessage(IDC_DATERANGE_END, DTM_SETSYSTEMTIME, 0, (LPARAM)&st);
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        CheckDlgButton(IDC_USE_RECENT_MONTHS, bUseMonths);
        CheckDlgButton(IDC_USE_RECENT_DAYS,   bUseDays);
        CheckDlgButton(IDC_USE_DATE_RANGE,    bUseRange);
        EnableControls();
    }

    return hr;
}


void CDateDlg::Clear()
{
    SendDlgItemMessage(IDC_WHICH_DATE, CB_SETCURSEL, 0, 0);

    CheckDlgButton(IDC_USE_RECENT_MONTHS, 0);
    SetDlgItemInt(IDC_RECENT_MONTHS, 1, FALSE);

    CheckDlgButton(IDC_USE_RECENT_DAYS, 0);
    SetDlgItemInt(IDC_RECENT_DAYS, 1, FALSE);

    CheckDlgButton(IDC_USE_DATE_RANGE, 1);

    SYSTEMTIME stNow, stPrev;
    GetLocalTime(&stNow);
    SendDlgItemMessage(IDC_DATERANGE_END, DTM_SETSYSTEMTIME, 0, (LPARAM)&stNow);

    //  Subtract 90 days from current date and stuff in date low range
    _CalcDateOffset(&stNow, 0, -1 /* 1 month ago */, &stPrev);
    SendDlgItemMessage(IDC_DATERANGE_BEGIN,  DTM_SETSYSTEMTIME, 0, (LPARAM)&stPrev);

    EnableControls();
}


LRESULT CDateDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    ValidateRect(NULL);

    RECT rc;
    HWND hwndCtl = GetDlgItem(IDC_WHICH_DATE);
    ASSERT(hwndCtl);
    
    ::GetWindowRect(hwndCtl, &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.right = pts.x - _pfsb->GetMetrics().CtlMarginX();
    
    ::SetWindowPos(GetDlgItem(IDC_WHICH_DATE), NULL, 0, 0, 
                    RECTWIDTH(rc), RECTHEIGHT(rc),
                    SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    return 0;
}


LRESULT CDateDlg::OnMonthDaySpin(int nIDSpin, NMHDR *pnmh, BOOL& bHandled)
{
    LPNMUPDOWN pud = (LPNMUPDOWN)pnmh;
    pud->iDelta *= -1; // increments of 1 month/day
    return 0;
}


LRESULT CDateDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    EnableControls();
    return 0;
}


LRESULT CDateDlg::OnMonthsKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_RECENT_MONTHS, IDC_RECENT_MONTHS_SPIN,
                              RECENTMONTHSRANGE_LOW, RECENTMONTHSRANGE_HIGH);
    return 0;
}


LRESULT CDateDlg::OnDaysKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_RECENT_DAYS, IDC_RECENT_DAYS_SPIN,
                             RECENTDAYSRANGE_LOW, RECENTDAYSRANGE_HIGH);
    return 0;
}


void CDateDlg::EnableControls()
{
    UINT nSel = IsDlgButtonChecked(IDC_USE_RECENT_MONTHS) ? IDC_USE_RECENT_MONTHS :
                IsDlgButtonChecked(IDC_USE_RECENT_DAYS) ? IDC_USE_RECENT_DAYS :
                IsDlgButtonChecked(IDC_USE_DATE_RANGE) ? IDC_USE_DATE_RANGE : 0;

    ::EnableWindow(GetDlgItem(IDC_RECENT_MONTHS),      IDC_USE_RECENT_MONTHS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_MONTHS_SPIN), IDC_USE_RECENT_MONTHS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_DAYS),        IDC_USE_RECENT_DAYS == nSel);
    ::EnableWindow(GetDlgItem(IDC_RECENT_DAYS_SPIN),   IDC_USE_RECENT_DAYS == nSel);
    ::EnableWindow(GetDlgItem(IDC_DATERANGE_BEGIN),    IDC_USE_DATE_RANGE == nSel);
    ::EnableWindow(GetDlgItem(IDC_DATERANGE_END),      IDC_USE_DATE_RANGE == nSel);
}


// CSizeDlg impl


#define FILESIZERANGE_LOW       0
#define FILESIZERANGE_HIGH      99999999
#define FILESIZERANGE_HIGH_LEN  8 // count of digits in FILESIZERANGE_HIGH


LRESULT CSizeDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);

    HWND hwndCombo = GetDlgItem(IDC_WHICH_SIZE);
    SendDlgItemMessage(IDC_FILESIZE_SPIN, UDM_SETRANGE32,
                        FILESIZERANGE_HIGH, FILESIZERANGE_LOW /*Kb*/);
    SendDlgItemMessage(IDC_FILESIZE, EM_LIMITTEXT, FILESIZERANGE_HIGH_LEN, 0);

    _LoadStringToCombo(hwndCombo, -1, 
                        IDS_FSEARCH_SIZE_GREATEREQUAL, 
                        IDS_FSEARCH_SIZE_GREATEREQUAL);
    _LoadStringToCombo(hwndCombo, -1, 
                        IDS_FSEARCH_SIZE_LESSEREQUAL, 
                        IDS_FSEARCH_SIZE_LESSEREQUAL);

    Clear();

    return TRUE;  // Let the system set the focus
}


STDMETHODIMP CSizeDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    VARIANT var;
    BOOL    bErr = FALSE;
    HRESULT hr = S_FALSE;
    UINT_PTR nIDString = _GetComboData(GetDlgItem(IDC_WHICH_SIZE));

    var.vt = VT_UI8;
    // this will be limited to ~4000GB due to the size of the data in the control
    var.ullVal = (ULONG)SendDlgItemMessage(IDC_FILESIZE_SPIN, UDM_GETPOS32, 0, (LPARAM)&bErr);
    
    if (!bErr)
    {
        var.ullVal *= 1024; // KB to bytes.
        LPCWSTR pwszConstraint = (IDS_FSEARCH_SIZE_GREATEREQUAL == nIDString) ? 
                                    L"SizeGE" :
                                 (IDS_FSEARCH_SIZE_LESSEREQUAL == nIDString) ? 
                                    L"SizeLE" : NULL;

        if (pwszConstraint)
            hr = _AddConstraint(pSrchCmd, pwszConstraint, &var);
    }

    return hr;
}


//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CSizeDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    HRESULT hr = E_FAIL;
    UINT    nID = 0;

    if (IsConstraintName(L"SizeGE", bstrName))
    {
        nID = IDS_FSEARCH_SIZE_GREATEREQUAL;
        hr = S_OK;
    }
    else if (IsConstraintName(L"SizeLE", bstrName))
    {
        nID = IDS_FSEARCH_SIZE_LESSEREQUAL;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        ASSERT(VT_UI8 == pValue->vt);
        ULONG ulSize = pValue->ullVal/1024; // convert bytes to KB
        SetDlgItemInt(IDC_FILESIZE, ulSize, FALSE);

        ASSERT(nID != 0);
        _SelectComboData(GetDlgItem(IDC_WHICH_SIZE), nID);
    }
    
    return hr;
}



void CSizeDlg::Clear()
{
    SendDlgItemMessage(IDC_WHICH_SIZE, CB_SETCURSEL, 0, 0);
    SetDlgItemInt(IDC_FILESIZE, 0, FALSE);    
}


LRESULT CSizeDlg::OnSizeSpin(int nIDSpin, NMHDR *pnmh, BOOL& bHandled)
{
    LPNMUPDOWN pud = (LPNMUPDOWN)pnmh;
    pud->iDelta *= -10;  // increments of 10KB
    return 0;
}


LRESULT CSizeDlg::OnSizeKillFocus(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    _EnforceNumericEditRange(m_hWnd, IDC_FILESIZE, IDC_FILESIZE_SPIN,
                              FILESIZERANGE_LOW, FILESIZERANGE_HIGH);
    return 0;
}

CTypeDlg::CTypeDlg(CFileSearchBand* pfsb) : CSubDlg(pfsb)
{
    *_szRestoredExt = 0;
}

CTypeDlg::~CTypeDlg()
{
}

LRESULT CTypeDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND        hwndCombo = GetDlgItem(IDC_FILE_TYPE);
    HIMAGELIST  hil = GetSystemImageListSmallIcons();

    _Attach(m_hWnd);
    ::SendMessage(hwndCombo, CBEM_SETEXTENDEDSTYLE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);
    
    ::SendMessage(hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM)hil);
    ::SendMessage(hwndCombo, CBEM_SETEXSTYLE, 0, 0);
    return TRUE;  // Let the system set the focus
}

STDMETHODIMP CTypeDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    LPTSTR  pszText;
    HRESULT hr = S_FALSE;

    if (GetFileAssocComboSelItemText(GetDlgItem(IDC_FILE_TYPE), &pszText) >= 0 && pszText)
    {
        VARIANT var = {0};
        if (*pszText && 
            SUCCEEDED(InitVariantFromStr(&var, pszText)) &&
            SUCCEEDED(_AddConstraint(pSrchCmd, L"FileType", &var)))
        {
            hr = S_OK;
        }
        VariantClear(&var);
        LocalFree((HLOCAL)pszText);
    }
    
    return hr;
}

//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CTypeDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"FileType", bstrName))
    {
        ASSERT(VT_BSTR == pValue->vt);
        
        HRESULT hr = StringCchCopy(_szRestoredExt, ARRAYSIZE(_szRestoredExt), pValue->bstrVal);
        if (SUCCEEDED(hr))
        {
            INT_PTR i = _FindExtension(GetDlgItem(IDC_FILE_TYPE), _szRestoredExt);
            if (i != CB_ERR)
            {
                SendDlgItemMessage(IDC_FILE_TYPE, CB_SETCURSEL, i, 0);
                *_szRestoredExt = 0;
            }

            return S_OK;
        }

        *_szRestoredExt = 0;    // throw away invalid data
    }
    return E_FAIL;
}

INT_PTR CTypeDlg::_FindExtension(HWND hwndCombo, TCHAR* pszExt)
{
    INT_PTR i, cnt = ::SendMessage(hwndCombo, CB_GETCOUNT, 0, 0);
    LPTSTR  pszData;
    BOOL    bAllFileTypes = pszExt && (lstrcmp(TEXT("*.*"), pszExt) == 0);
    TCHAR   szExt[MAX_PATH];

    if (!bAllFileTypes)
    {
        //  Remove wildcard characters.
        LPTSTR pszSrc = pszExt, pszDest = szExt;
        for (;; pszSrc = CharNext(pszSrc))
        {
            if (TEXT('*') == *pszSrc)
                pszSrc = CharNext(pszSrc);

            if ((*(pszDest++) = *pszSrc) == 0)
                break;
        }
        pszExt = szExt;
    }

    if (pszExt && (bAllFileTypes || *pszExt))
    {
        for (i = 0; i < cnt; i++)
        {
            pszData = (LPTSTR)::SendMessage(hwndCombo, CB_GETITEMDATA, i, 0);
            if (bAllFileTypes && (FILEASSOCIATIONSID_ALLFILETYPES == (UINT_PTR)pszData))
                return i;

            if (pszData != (LPTSTR)FILEASSOCIATIONSID_ALLFILETYPES &&
                pszData != (LPTSTR)CB_ERR && 
                pszData != NULL)
            {
                if (0 == StrCmpI(pszExt, pszData))
                    return i;
            }
        }
    }
    return CB_ERR;
}

void CTypeDlg::Clear()
{
    //  Assign combo selection to 'all file types':
    HWND hwndCombo = GetDlgItem(IDC_FILE_TYPE);
    for (INT_PTR i = 0, cnt = ::SendMessage(hwndCombo, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        if (FILEASSOCIATIONSID_ALLFILETYPES == _GetComboData(hwndCombo, i))
        {
            ::SendMessage(hwndCombo, CB_SETCURSEL, i, 0);
            break;
        }
    }
    _szRestoredExt[0] = 0;
}

LRESULT CTypeDlg::OnFileTypeDeleteItem(int idCtrl, NMHDR *pnmh, BOOL& bHandled)
{
    return DeleteFileAssocComboItem(pnmh);
}

LRESULT CTypeDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    ValidateRect(NULL);

    RECT rc;
    HWND hwndCtl = GetDlgItem(IDC_FILE_TYPE);
    ASSERT(hwndCtl);
    
    ::GetWindowRect(hwndCtl, &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.right = pts.x - _pfsb->GetMetrics().CtlMarginX();
    
    ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                    RECTWIDTH(rc), RECTHEIGHT(rc),
                    SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    return 0;
}

DWORD CTypeDlg::FileAssocThreadProc(void* pv)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)pv;
    CTypeDlg* pThis = (CTypeDlg*)pState->pvParam;

    if (PopulateFileAssocCombo(pState->hwndCtl, AddItemNotify, (LPARAM)pv) != E_ABORT)
    {
        ::PostMessage(::GetParent(pState->hwndCtl), WMU_COMBOPOPULATIONCOMPLETE, (WPARAM)pState->hwndCtl, 0);
    }

    pState->fComplete = TRUE;

    ATOMICRELEASE(pState->punkBand);
    return 0;
}

HRESULT CTypeDlg::AddItemNotify(ULONG fAction, PCBXITEM pItem, LPARAM lParam)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)lParam;
    ASSERT(pState);
    ASSERT(pState->hwndCtl);

    //  Do we want to abort combo population thread?
    if (fAction & CBXCB_ADDING && pState->fCancel)
        return E_ABORT;

    //  Set the current selection to 'all file types'
    if (fAction & CBXCB_ADDED)
    {
        BOOL bAllTypesItem = (FILEASSOCIATIONSID_ALLFILETYPES == pItem->lParam);
        
        CTypeDlg* pThis = (CTypeDlg*)pState->pvParam;
        ASSERT(pThis);
        
        //  If this item is the one restored from a saved query
        //  override any current selection and select it.
        if (*pThis->_szRestoredExt && !bAllTypesItem && pItem->lParam && 
            0 == lstrcmpi((LPCTSTR)pItem->lParam, pThis->_szRestoredExt))
        {
            ::SendMessage(pState->hwndCtl, CB_SETCURSEL, pItem->iItem, 0);
            *pThis->_szRestoredExt = 0;
        }
        //  If this item is the default ('all file types') and 
        //  nothing else is selected, select it.
        else if (bAllTypesItem)
        {
            if (CB_ERR == ::SendMessage(pState->hwndCtl, CB_GETCURSEL, 0, 0))
                ::SendMessage(pState->hwndCtl, CB_SETCURSEL, pItem->iItem, 0);
        }
    }
    return S_OK;
}

LRESULT CTypeDlg::OnComboPopulationComplete(UINT, WPARAM, LPARAM, BOOL&)
{
    // remove briefcase from type combo because briefcases no longer use this
    // extension (now they store clsid in desktop.ini
    INT_PTR iBfc = _FindExtension(GetDlgItem(IDC_FILE_TYPE), TEXT(".bfc"));
    if (iBfc != CB_ERR)
    {
        SendDlgItemMessage(IDC_FILE_TYPE, CB_DELETESTRING, (WPARAM)iBfc, 0);
    }
    
    if (*_szRestoredExt)
    {
        INT_PTR iSel = _FindExtension(GetDlgItem(IDC_FILE_TYPE), _szRestoredExt);
        if (iSel != CB_ERR)
        {
            SendDlgItemMessage(IDC_FILE_TYPE, CB_SETCURSEL, (WPARAM)iSel, 0);
            *_szRestoredExt = 0;
        }
    }
        
    return 0;
}

// Called when we are finished doing all the work to display the search band.
// We then launch the thread to populate the file type drop down.  By delaying this 
// until now, we can speed up the band loading.
// No return becuase it's called async.
void CTypeDlg::DoDelayedInit()
{
    //  Launch thread to populate the file types combo.
    _threadState.hwndCtl = GetDlgItem(IDC_FILE_TYPE);
    _threadState.pvParam = this;
    _threadState.fComplete = FALSE;
    _threadState.fCancel   = FALSE;

    if (SUCCEEDED(SAFECAST(_pfsb, IFileSearchBand*)->QueryInterface(IID_PPV_ARG(IUnknown, &_threadState.punkBand))))
    {
        if (!SHCreateThread(FileAssocThreadProc, &_threadState, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(_threadState.punkBand);
        }
    }
}


LRESULT CTypeDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)  
{ 
    _threadState.fCancel = TRUE; 
    bHandled = FALSE; 
    return 0;
}


void CTypeDlg::OnWinIniChange()
{
    SendDlgItemMessage(IDC_FILE_TYPE, CB_SETDROPPEDWIDTH,
                        _PixelsForDbu(m_hWnd, MIN_FILEASSOCLIST_WIDTH, TRUE), 0);
}


LRESULT CAdvancedDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);
    Clear();
    return TRUE;  // Let the system set the focus
}

HRESULT AddButtonConstraintPersist(ISearchCommandExt* pSrchCmd, LPCWSTR pszConstraint, HWND hwndButton)
{

    BOOL bValue = SendMessage(hwndButton, BM_GETCHECK, 0, 0) == BST_CHECKED;
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), pszConstraint,
                    REG_DWORD, &bValue, sizeof(bValue), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

    VARIANT var = {0};
    var.vt = VT_BOOL;
    var.boolVal = bValue ? VARIANT_TRUE : 0;

    return _AddConstraint(pSrchCmd, pszConstraint, &var);
}

STDMETHODIMP CAdvancedDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    AddButtonConstraintPersist(pSrchCmd, L"SearchSystemDirs",  GetDlgItem(IDC_USE_SYSTEMDIRS));
    AddButtonConstraintPersist(pSrchCmd, L"SearchHidden",      GetDlgItem(IDC_SEARCH_HIDDEN));
    AddButtonConstraintPersist(pSrchCmd, L"IncludeSubFolders", GetDlgItem(IDC_USE_SUBFOLDERS));
    AddButtonConstraintPersist(pSrchCmd, L"CaseSensitive",     GetDlgItem(IDC_USE_CASE));
    AddButtonConstraintPersist(pSrchCmd, L"SearchSlowFiles",   GetDlgItem(IDC_USE_SLOW_FILES));
    return S_OK;
}

//  S_FALSE: constraint restored to UI.  S_OK: subdialog should be opened.
//  E_FAIL: constraint must be for some other subdlg.
STDMETHODIMP CAdvancedDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"IncludeSubFolders", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_SUBFOLDERS, pValue->lVal);
        return S_FALSE;    // this is a default. don't force open the subdialog.
    }

    if (IsConstraintName(L"CaseSensitive", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_CASE, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchSlowFiles", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt);
        CheckDlgButton(IDC_USE_SLOW_FILES, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchSystemDirs", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt || VT_UI4 == pValue->vt);
        CheckDlgButton(IDC_USE_SYSTEMDIRS, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    if (IsConstraintName(L"SearchHidden", bstrName))
    {
        ASSERT(VT_BOOL == pValue->vt || VT_I4 == pValue->vt || VT_UI4 == pValue->vt);
        CheckDlgButton(IDC_SEARCH_HIDDEN, pValue->lVal);
        return pValue->lVal ? S_OK : S_FALSE;
    }

    return E_FAIL;
}

void CheckDlgButtonPersist(HWND hdlg, UINT id, LPCTSTR pszOption, BOOL bDefault)
{
    BOOL bValue = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), pszOption, FALSE, bDefault);
    CheckDlgButton(hdlg, id, bValue);
}

void CAdvancedDlg::Clear()
{
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SYSTEMDIRS,   L"SearchSystemDirs",  IsOS(OS_ANYSERVER));
    CheckDlgButtonPersist(m_hWnd, IDC_SEARCH_HIDDEN,    L"SearchHidden",      FALSE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SUBFOLDERS,   L"IncludeSubFolders", TRUE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_CASE,         L"CaseSensitive",     FALSE);
    CheckDlgButtonPersist(m_hWnd, IDC_USE_SLOW_FILES,   L"SearchSlowFiles",   FALSE);
}

COptionsDlg::COptionsDlg(CFileSearchBand* pfsb)
    :   CSubDlg(pfsb),
        _dlgDate(pfsb),
        _dlgSize(pfsb),
        _dlgType(pfsb),
        _dlgAdvanced(pfsb)
{
    // Verify that it initialized to 0's
    ASSERT(0 == _nCIStatusText);

    ZeroMemory(_subdlgs, sizeof(_subdlgs));
    #define SUBDLG_ENTRY(idx, idCheck, dlg)  \
        { _subdlgs[idx].nIDCheck = idCheck; _subdlgs[idx].pDlg = &dlg; }

    SUBDLG_ENTRY(SUBDLG_DATE, IDC_USE_DATE, _dlgDate);
    SUBDLG_ENTRY(SUBDLG_TYPE, IDC_USE_TYPE, _dlgType);
    SUBDLG_ENTRY(SUBDLG_SIZE, IDC_USE_SIZE, _dlgSize);
    SUBDLG_ENTRY(SUBDLG_ADVANCED, IDC_USE_ADVANCED, _dlgAdvanced);
}

LRESULT COptionsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    _Attach(m_hWnd);
    _dlgDate.SetBandDlg(_pBandDlg);
    _dlgSize.SetBandDlg(_pBandDlg);
    _dlgType.SetBandDlg(_pBandDlg);
    _dlgAdvanced.SetBandDlg(_pBandDlg);

    //  Gather some metrics from the fresh dialog template...
    CMetrics& metrics = _pfsb->GetMetrics();
    RECT rc[3] = {0};

    ASSERT(::IsWindow(GetDlgItem(IDC_USE_DATE)));
    ASSERT(::IsWindow(GetDlgItem(IDC_USE_TYPE)));
    ASSERT(::IsWindow(GetDlgItem(IDC_USE_ADVANCED)));

    ::GetWindowRect(GetDlgItem(IDC_USE_DATE), rc + 0);
    ::GetWindowRect(GetDlgItem(IDC_USE_TYPE), rc + 1);
    ::GetWindowRect(GetDlgItem(IDC_USE_ADVANCED), rc + 2);
    for (int i = 0; i < ARRAYSIZE(rc); i++)
    {
        // MapWindowPoints is mirroring aware only if you pass two points
        ::MapWindowRect(NULL, m_hWnd, &rc[i]);
    }    

    metrics.ExpandOrigin().y = rc[0].top;
    metrics.CheckBoxRect()   = rc[2];
    OffsetRect(&metrics.CheckBoxRect(), -rc[0].left, -rc[0].top);
    
    //  Create subdialogs and collect native sizes.
    if (_dlgDate.Create(m_hWnd))
        _GetWindowSize(_dlgDate, &_subdlgs[SUBDLG_DATE].sizeDlg);

    if (_dlgSize.Create(m_hWnd))
        _GetWindowSize(_dlgSize, &_subdlgs[SUBDLG_SIZE].sizeDlg);

    if (_dlgType.Create(m_hWnd))
        _GetWindowSize(_dlgType, &_subdlgs[SUBDLG_TYPE].sizeDlg);

    if (_dlgAdvanced.Create(m_hWnd))
        _GetWindowSize(_dlgAdvanced, &_subdlgs[SUBDLG_ADVANCED].sizeDlg);

    //  Create index server link window    
    POINT pt = {0};
    HWND hwndCI = _CreateLinkWindow(m_hWnd, IDC_INDEX_SERVER, 
                                     pt, IDS_FSEARCH_CI_DISABLED_LINK);
    UpdateSearchCmdStateUI();

    //  Layout controls
    LayoutControls();

    return TRUE;
}


void COptionsDlg::OnWinIniChange()
{
    CSubDlg::OnWinIniChange();
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
        _subdlgs[i].pDlg->OnWinIniChange();
}

void COptionsDlg::LoadSaveUIState(UINT nIDCtl, BOOL bSave) 
{
}

LRESULT COptionsDlg::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    _PaintDlg(m_hWnd, _pfsb->GetMetrics());
    LayoutControls(pts.x, pts.y);
    return 0;
}


void COptionsDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }

    HDWP hdwp = BeginDeferWindowPos(1 + (ARRAYSIZE(_subdlgs) * 2));
    if (hdwp)
    {
        CMetrics& metrics = _pfsb->GetMetrics();
        POINT ptOrigin = metrics.ExpandOrigin();

        //  For each checkbox and associated subdialog...
        for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
        {
            //  Calculate checkbox position
            HWND hwndCheck = GetDlgItem(_subdlgs[i].nIDCheck);
            ASSERT(hwndCheck);
    
            SetRect(&_subdlgs[i].rcCheck, 
                     ptOrigin.x, ptOrigin.y,
                     ptOrigin.x + RECTWIDTH(metrics.CheckBoxRect()),
                     ptOrigin.y + RECTHEIGHT(metrics.CheckBoxRect()));

            //  Calculate subdialog position
            ULONG dwDlgFlags = SWP_NOACTIVATE;

            if (IsDlgButtonChecked(_subdlgs[i].nIDCheck))
            {
                //  position the checkbox's dialog immediately below.
                SetRect(&_subdlgs[i].rcDlg, 
                         _subdlgs[i].rcCheck.left, _subdlgs[i].rcCheck.bottom,
                         cx - 1, _subdlgs[i].rcCheck.bottom  + _subdlgs[i].sizeDlg.cy);
                dwDlgFlags |= SWP_SHOWWINDOW;

                ptOrigin.y = _subdlgs[i].rcDlg.bottom + metrics.TightMarginY();
            }
            else
            {
                ptOrigin.y = _subdlgs[i].rcCheck.bottom + metrics.TightMarginY();        
                dwDlgFlags |= SWP_HIDEWINDOW;
            }

            //  Reposition the pair
            ::DeferWindowPos(hdwp, _subdlgs[i].pDlg->Hwnd(), hwndCheck, 
                            _subdlgs[i].rcDlg.left,
                            _subdlgs[i].rcDlg.top,
                            RECTWIDTH(_subdlgs[i].rcDlg),
                            RECTHEIGHT(_subdlgs[i].rcDlg),
                            dwDlgFlags);

            ::DeferWindowPos(hdwp, hwndCheck, NULL, 
                            _subdlgs[i].rcCheck.left,
                            _subdlgs[i].rcCheck.top,
                            RECTWIDTH(_subdlgs[i].rcCheck),
                            RECTHEIGHT(_subdlgs[i].rcCheck),
                            SWP_NOZORDER|SWP_NOACTIVATE);
        }

        _LayoutLinkWindow(m_hWnd, metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                           ptOrigin.y, IDC_INDEX_SERVER);

        EndDeferWindowPos(hdwp);
    }
}


//  Assigns focus to the options dialog.   This cannot be done by
//  simply setting focus to the options dialog, which is a child
//  of another dialog; USER will simply assign focus to the parent dialog.
//  So we need to explicitly set focus to our first child.
void COptionsDlg::TakeFocus()
{
    for (HWND hwndCtl = GetWindow(GW_CHILD);
        ::IsWindow(hwndCtl);
         hwndCtl = ::GetWindow(hwndCtl, GW_HWNDNEXT))
    {
        ULONG dwStyle = ::GetWindowLong(hwndCtl, GWL_STYLE);
        if (dwStyle & WS_TABSTOP)
        {
            ::SetFocus(hwndCtl);
            break;
        }
    }
}

//  Note that we do not care about returning results from this, as it will
//  be started asynchronously.
void COptionsDlg::DoDelayedInit()
{
    //  have subdialogs do delayed initialization
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        _subdlgs[i].pDlg->DoDelayedInit();
    }
}

LONG COptionsDlg::QueryHeight(LONG cx /* proposed width */, LONG cy /* proposed height */)
{
    HWND hwndBottommost = GetBottomItem();
    RECT rcThis, rcBottommost;

    //  Retrieve the current height of the bottommost link window.
    GetWindowRect(&rcThis);
    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, GetParent(), &rcThis);
    ::MapWindowRect(NULL, GetParent(), &rcBottommost);

    //  If, at the specified width, we compute a height for the bottommost 
    //  linkwindow that is different from its current height (e.g, due to word wrap),
    //  we'll compute a new window rect that will 
    LONG cyBottommost = (LONG)::SendMessage(hwndBottommost, LWM_GETIDEALHEIGHT, 
                                           cx - (_pfsb->GetMetrics().CtlMarginX() * 2), 0);
    
    if (cyBottommost > 0 && cyBottommost != RECTHEIGHT(rcBottommost))
        rcThis.bottom = rcBottommost.top + cyBottommost + _pfsb->GetMetrics().TightMarginY();

    return RECTHEIGHT(rcThis);
}

BOOL COptionsDlg::GetMinSize(SIZE *pSize)
{
    pSize->cx = pSize->cy = 0;

    HWND hwndBottom = GetBottomItem();

    if (!::IsWindow(hwndBottom))
        return FALSE;

    RECT rcBottom;
    ::GetWindowRect(hwndBottom, &rcBottom);
    ::MapWindowRect(NULL, m_hWnd, &rcBottom);

    pSize->cx = 0;
    pSize->cy = rcBottom.bottom;

    return TRUE;
}

HWND COptionsDlg::GetBottomItem()
{
    HWND hwndBottom = GetDlgItem(IDC_INDEX_SERVER);
    ASSERT(::IsWindow(hwndBottom))
    return hwndBottom;
}

void COptionsDlg::UpdateSearchCmdStateUI(DISPID dispid)
{
    UINT nStatusText;
    BOOL fCiRunning, fCiIndexed, fCiPermission;
    GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);

    if (fCiRunning)
    {
        if (fCiPermission)
            //  we have permission to distinguish between ready and busy
            nStatusText = fCiIndexed ? IDS_FSEARCH_CI_READY_LINK : IDS_FSEARCH_CI_BUSY_LINK;
        else
            //  no permission to distinguish between ready and busy; we'll
            //  just say it's enabled.
            nStatusText = IDS_FSEARCH_CI_ENABLED_LINK;
    }
    else
    {
        nStatusText = IDS_FSEARCH_CI_DISABLED_LINK;
    }

    TCHAR szCaption[MAX_PATH];
    if (nStatusText != _nCIStatusText &&
        EVAL(LoadString(HINST_THISDLL, nStatusText, szCaption, ARRAYSIZE(szCaption))))
    {
        SetDlgItemText(IDC_INDEX_SERVER, szCaption);
        _nCIStatusText = nStatusText;
        LayoutControls();
        SizeToFit(FALSE);
    }
}

STDMETHODIMP COptionsDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    HRESULT hrRet = S_OK;
    //  have subdialogs add their constraints
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        if (::IsWindowVisible(_subdlgs[i].pDlg->Hwnd()))
        {
            HRESULT hr = _subdlgs[i].pDlg->AddConstraints(pSrchCmd);
            if (FAILED(hr))
                hrRet = hr;
        }       
    }
    return hrRet;
}


STDMETHODIMP COptionsDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    //  Try subordinate dialogs.
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        HRESULT hr = _subdlgs[i].pDlg->RestoreConstraint(bstrName, pValue);

        if (S_OK == hr)  // open the dialog
        {
            CheckDlgButton(_subdlgs[i].nIDCheck, TRUE);
            LayoutControls();
            SizeToFit();
        }

        //  if success, we're done.
        if (SUCCEEDED(hr))
            return hr;

        //  otherwise, try next subdialog.
    }
    return E_FAIL;
}


STDMETHODIMP COptionsDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CSubDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Query subdialogs
    if (_dlgDate.IsChild(pmsg->hwnd) &&
        S_OK == _dlgDate.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgType.IsChild(pmsg->hwnd) &&
        S_OK == _dlgType.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgSize.IsChild(pmsg->hwnd) &&
        S_OK == _dlgSize.TranslateAccelerator(pmsg))
        return S_OK;

    if (_dlgAdvanced.IsChild(pmsg->hwnd) &&
        S_OK == _dlgAdvanced.TranslateAccelerator(pmsg))
        return S_OK;

    return _pfsb->IsDlgMessage(Hwnd(), pmsg);
}


BOOL COptionsDlg::Validate()
{
    //  have subdialogs do validatation
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        if (::IsWindowVisible(_subdlgs[i].pDlg->Hwnd()))
            if (!_subdlgs[i].pDlg->Validate())
                return FALSE;
    }
    return TRUE;
}


void COptionsDlg::Clear()
{
    //  have subdialogs clear themselves.
    for (int i = 0; i < ARRAYSIZE(_subdlgs); i++)
    {
        _subdlgs[i].pDlg->Clear();
        CheckDlgButton(_subdlgs[i].nIDCheck, FALSE);
    }
    LayoutControls();
    SizeToFit();
}


LRESULT COptionsDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
#ifdef DEBUG
    //  Is this a sub-dialog expansion/contraction?
    BOOL bIsSubDlgBtn = FALSE;
    for (int i = 0; i < ARRAYSIZE(_subdlgs) && !bIsSubDlgBtn; i++)
    {
        if (nID == _subdlgs[i].nIDCheck)
            bIsSubDlgBtn = TRUE;
    }
    ASSERT(bIsSubDlgBtn);
#endif DEBUG
    
    LoadSaveUIState(nID, TRUE); // persist it.

    LayoutControls();
    SizeToFit(!IsDlgButtonChecked(nID));
        //  don't need to scroll the band if we've expanded a subdialog,
        //  but we do if we've contracted one.

    return 0;
}


void COptionsDlg::SizeToFit(BOOL bScrollBand)
{
    SIZE size;
    GetMinSize(&size);
    size.cy += _pfsb->GetMetrics().TightMarginY();
    SetWindowPos(NULL, 0, 0, size.cx, size.cy, SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);

    ULONG dwLayoutFlags = BLF_ALL;
    if (!bScrollBand)
        dwLayoutFlags &= ~BLF_SCROLLWINDOW;    
    
    ::SendMessage(GetParent(), WMU_UPDATELAYOUT, dwLayoutFlags, 0);
}


LRESULT COptionsDlg::OnIndexServerClick(int idCtl, NMHDR *pnmh, BOOL&)
{
    BOOL fCiRunning, fCiIndexed, fCiPermission = FALSE;
    
    HRESULT hr = GetCIStatus(&fCiRunning, &fCiIndexed, &fCiPermission);
    if (SUCCEEDED(hr) && fCiPermission)
    {
        //  CI is idle or not runnning.  Show status dialog.
        if (IDOK == CCISettingsDlg_DoModal(GetDlgItem(IDC_INDEX_SERVER)))
        {
            // reflect any state change in UI.
            ::PostMessage(GetParent(), WMU_STATECHANGE, 0, 0); 
        }
    }
    else
    {
        //  No permission? display CI help.
        _IndexServiceHelp(NULL);
    }
        
    return 0;
}






// CBandDlg impl



CBandDlg::CBandDlg(CFileSearchBand* pfsb)
    :   _pfsb(pfsb)
{
    // Verify that it initialized to FALSE/NULL
    ASSERT(NULL == _hwnd);
    ASSERT(NULL == _hwndLastFocus);
    
    VariantInit(&_varScope0);
    VariantInit(&_varQueryFile0);
}


CBandDlg::~CBandDlg()
{
    VariantClear(&_varScope0);
    VariantClear(&_varQueryFile0);
}


STDMETHODIMP CBandDlg::TranslateAccelerator(MSG *pmsg)
{
    if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
    {
        IAutoComplete2* pac2;
        if (GetAutoCompleteObjectForWindow(pmsg->hwnd, &pac2))
        {
            if (S_OK == _TestAutoCompleteDropDownState(pac2, ACDD_VISIBLE))
            {
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
                pac2->Release();
                return S_OK;
            }
            pac2->Release();
        }
    }
    
    //  Check for Ctrl+Nav Key:
    if (_pfsb->IsKeyboardScroll(pmsg))
        return S_OK;
    return S_FALSE;
}


void CBandDlg::SetDefaultFocus()
{
    HWND hwndFirst = GetFirstTabItem();
    if (IsWindow(hwndFirst))
        SetFocus(hwndFirst);
}


void CBandDlg::RememberFocus(HWND hwndFocus)
{
    if (!IsWindow(hwndFocus))
    {
        _hwndLastFocus = NULL;
        hwndFocus = GetFocus();
    }

    if (IsChild(_hwnd, hwndFocus))
        _hwndLastFocus = hwndFocus;
}


BOOL CBandDlg::RestoreFocus()
{
    if (IsWindow(_hwndLastFocus))
    {
        if (IsWindowVisible(_hwndLastFocus) && IsWindowEnabled(_hwndLastFocus))
        {
            SetFocus(_hwndLastFocus);
            return TRUE;
        }
    }
    else
        _hwndLastFocus = NULL;
    
    return FALSE;
}


LRESULT CBandDlg::OnChildSetFocusCmd(WORD, WORD, HWND hwndCtl, BOOL& bHandled)
{
    _EnsureVisible(_hwnd, hwndCtl, _pfsb);
    return 0;
}


LRESULT CBandDlg::OnChildSetFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    _EnsureVisible(_hwnd, pnmh->hwndFrom, _pfsb);
    return 0;
}


LRESULT CBandDlg::OnChildKillFocusCmd(WORD, WORD, HWND hwndCtl, BOOL&)
{
    _hwndLastFocus = hwndCtl;
    return 0;
}


LRESULT CBandDlg::OnChildKillFocusNotify(int, NMHDR *pnmh, BOOL&)
{
    _hwndLastFocus = pnmh->hwndFrom;
    return 0;
}


LRESULT CBandDlg::OnComboExEndEdit(int, NMHDR *pnmh, BOOL&)
{
    if (CBEN_ENDEDIT == pnmh->code)
    {
        if (CBENF_KILLFOCUS == ((NMCBEENDEDIT*)pnmh)->iWhy)
            _hwndLastFocus = pnmh->hwndFrom;
    }
    return 0;
}


void CBandDlg::WndPosChanging(HWND hwndOC, LPWINDOWPOS pwp)
{
    SIZE sizeMin;
    if (0 == (pwp->flags & SWP_NOSIZE) && GetMinSize(hwndOC, &sizeMin))
    {
        if (pwp->cx < sizeMin.cx)
            pwp->cx = sizeMin.cx;

        if (pwp->cy < sizeMin.cy)
            pwp->cy = sizeMin.cy;
    }        
}


LRESULT CBandDlg::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);

    LayoutControls(pts.x, pts.y);
    return 0;
}


void CBandDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(_hwnd, &rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }
    _LayoutCaption(GetIconID(), GetCaptionID(), GetCaptionDivID(), cx);
}


BOOL CBandDlg::GetIdealSize(HWND hwndOC, SIZE *psize) const
{
    ASSERT(psize);
    psize->cx = psize->cy = 0;

    if (!IsWindow(Hwnd()))
        return FALSE;

    SIZE sizeMin;
    if (GetMinSize(hwndOC, &sizeMin))
    {
        RECT rcClient;
        ::GetClientRect(hwndOC, &rcClient);

        psize->cx = (RECTWIDTH(rcClient) < sizeMin.cx) ? sizeMin.cx : RECTWIDTH(rcClient);
        psize->cy = sizeMin.cy;            
        return TRUE;
    }
    
    return FALSE;
}

LRESULT CBandDlg::OnPaint(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Just going to call BeginPaint and EndPaint.  All
    //  painting done in WM_ERASEBKGND handler to avoid flicker.
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(_hwnd, &ps);
    if (hdc)
        EndPaint(_hwnd, &ps);
    return 0;
}

LRESULT CBandDlg::OnEraseBkgnd(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    ASSERT(::IsWindow(_hwnd)); // was _Attach() called, e.g. from WM_INITDIALOG?
    _PaintDlg(_hwnd, _pfsb->GetMetrics(), (HDC)wParam);
    ValidateRect(_hwnd, NULL);
    return TRUE;   
}

LRESULT CBandDlg::OnCtlColorStatic(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    SetTextColor((HDC)wParam, _pfsb->GetMetrics().TextColor());
    SetBkColor((HDC)wParam, _pfsb->GetMetrics().BkgndColor());
    return (LRESULT)_pfsb->GetMetrics().BkgndBrush();
}

//  Hack method to remove turds left after showing band toolbar.
//  Methinks this is a USER issue. [scotthan]
void CBandDlg::RemoveToolbarTurds(int cyOffset)
{
    RECT rcUpdate;
    GetClientRect(_hwnd, &rcUpdate);

    HWND hwndCtl = GetDlgItem(_hwnd, GetCaptionDivID());
    if (hwndCtl)
    {
        RECT rc;
        GetWindowRect(hwndCtl, &rc);
        ::MapWindowRect(NULL, _hwnd, &rc);
        rcUpdate.bottom = rc.bottom;
        OffsetRect(&rcUpdate, 0, cyOffset);

        InvalidateRect(_hwnd, &rcUpdate, TRUE);
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    hwndCtl = GetDlgItem(_hwnd, GetIconID());
    if (hwndCtl)
    {
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    hwndCtl = GetDlgItem(_hwnd, GetCaptionID());
    if (hwndCtl)
    {
        InvalidateRect(hwndCtl, NULL, TRUE);
        UpdateWindow(hwndCtl);
    }

    UpdateWindow(_hwnd);
}


void CBandDlg::_BeautifyCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDIconResource)
{
    //  Do some cosmetic and initialization stuff
    HFONT hf = _pfsb->GetMetrics().BoldFont(_hwnd);
    if (hf)
        SendDlgItemMessage(_hwnd, nIDCaption, WM_SETFONT, (WPARAM)hf, 0);

    if (nIDIcon && nIDIconResource)
    {
        HICON hiconCaption = _pfsb->GetMetrics().CaptionIcon(nIDIconResource);
        if (hiconCaption)
            SendDlgItemMessage(_hwnd, nIDIcon, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hiconCaption);
    }
}


void CBandDlg::_LayoutCaption(UINT nIDCaption, UINT nIDIcon, UINT nIDDiv, LONG cxDlg)
{
    RECT rcIcon, rcCaption;
    LONG cxMargin = _pfsb->GetMetrics().CtlMarginX();

    GetWindowRect(GetDlgItem(_hwnd, nIDIcon), &rcIcon);
    GetWindowRect(GetDlgItem(_hwnd, nIDCaption), &rcCaption);
    ::MapWindowRect(NULL, _hwnd, &rcIcon);
    ::MapWindowRect(NULL, _hwnd, &rcCaption);

    int nTop = max(rcIcon.bottom, rcCaption.bottom) + _PixelsForDbu(_hwnd, 1, FALSE);

    SetWindowPos(GetDlgItem(_hwnd, nIDDiv), GetDlgItem(_hwnd, nIDCaption),
                  cxMargin, nTop, cxDlg - (cxMargin * 2), 2, SWP_NOACTIVATE);              
}



void CBandDlg::_LayoutSearchLinks(UINT nIDCaption, UINT nIDDiv, BOOL bShowDiv, LONG left, LONG right, LONG yMargin, 
                                   LONG& yStart, const int rgLinkIDs[], LONG cLinkIDs)
{
    //  Position divider
    if (bShowDiv != 0)
    {
        RECT rcDiv;
        SetRect(&rcDiv, left, yStart, right, yStart + 1);
        SetWindowPos(GetDlgItem(_hwnd, nIDDiv), GetDlgItem(_hwnd, nIDCaption),
                      rcDiv.left, rcDiv.top, RECTWIDTH(rcDiv), RECTHEIGHT(rcDiv),
                      SWP_NOACTIVATE|SWP_SHOWWINDOW);

        yStart += yMargin;
    }
    else
        ShowWindow(GetDlgItem(_hwnd, nIDDiv), SW_HIDE);

    //  Position caption
    RECT rcCaption;
    GetWindowRect(GetDlgItem(_hwnd, nIDCaption), &rcCaption);
    ::MapWindowRect(NULL, _hwnd, &rcCaption);
    OffsetRect(&rcCaption, left - rcCaption.left, yStart - rcCaption.top);
    SetWindowPos(GetDlgItem(_hwnd, nIDCaption), NULL, 
                  left, yStart, 0,0,
                  SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    yStart += RECTHEIGHT(rcCaption) + yMargin;

    //  Position links
    _LayoutLinkWindows(_hwnd, left, right, yMargin, yStart, rgLinkIDs, cLinkIDs);
}


LRESULT CBandDlg::OnEditChange(WORD, WORD, HWND, BOOL&)
{
    _pfsb->SetDirty();
    return 0;
}


LRESULT CBandDlg::OnSearchLink(int nID, LPNMHDR, BOOL&)
{
    ASSERT(_pfsb);

    _pfsb->StopSearch();
    switch (nID)
    {
    case IDC_SEARCHLINK_FILES:
        _pfsb->FindFilesOrFolders(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_COMPUTERS:
        _pfsb->FindComputer(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_PRINTERS:
        _pfsb->FindPrinter(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_PEOPLE:
        _pfsb->FindPeople(FALSE, TRUE);
        break;

    case IDC_SEARCHLINK_INTERNET:
        _pfsb->FindOnWeb(FALSE, TRUE);
        break;
    }
    return 0;
}


//  Invoked when a client calls IFileSearchBand::SetSearchParameters() 
HRESULT CBandDlg::SetScope(IN VARIANT* pvarScope, BOOL bTrack)
{
    HRESULT hr = S_OK;

    VariantClear(&_varScope0);
    
    //  cache the scope
    if (pvarScope)
        hr = VariantCopy(&_varScope0, pvarScope);

    return hr;
}


HRESULT CBandDlg::GetScope(OUT VARIANT* pvarScope)
{ 
    //  retrieve the scope
    if (!pvarScope)
        return E_INVALIDARG;

    HRESULT hr = VariantCopy(pvarScope, &_varScope0);

    return SUCCEEDED(hr) ? (VT_EMPTY == _varScope0.vt ? S_FALSE : S_OK) : hr;
}


HRESULT CBandDlg::SetQueryFile(IN VARIANT* pvarFile)
{
    return VariantCopy(&_varQueryFile0, pvarFile);
}


HRESULT CBandDlg::GetQueryFile(OUT VARIANT* pvarFile)
{
    //  retrieve the filename of the query to restore.
    if (!pvarFile)
        return E_INVALIDARG;

    VariantInit(pvarFile);
    HRESULT hr = VariantCopy(pvarFile, &_varQueryFile0);

    return SUCCEEDED(hr) ? (VT_EMPTY == _varQueryFile0.vt ? S_FALSE : S_OK) : hr;
}


// CFindFilesDlg impl

#define FSEARCHMAIN_TABFIRST      IDC_FILESPEC
#define FSEARCHMAIN_TABLAST       IDC_SEARCHLINK_INTERNET
#define FSEARCHMAIN_BOTTOMMOST    IDC_SEARCHLINK_INTERNET // bottom-most control
#define FSEARCHMAIN_RIGHTMOST     IDC_SEARCH_STOP         // right-most control
#define UISTATETIMER              1
#define UISTATETIMER_DELAY        4000


CFindFilesDlg::CFindFilesDlg(CFileSearchBand* pfsb)
    :   CSearchCmdDlg(pfsb),
        _dlgOptions(pfsb),
        _iCurNamespace(CB_ERR),
        _fTrackScope(TRACKSCOPE_SPECIFIC),
        _dwWarningFlags(DFW_DEFAULT),
        _dwRunOnceWarningFlags(DFW_DEFAULT)
{
    // Since we use the zero initializer for COM objects, all variables should
    // be initialized to NULL/FALSE/0
    ASSERT(FALSE == _bScoped);
    ASSERT(FALSE == _fDisplayOptions);
    ASSERT(FALSE == _fNamespace);
    ASSERT(FALSE == _fDebuted);
    ASSERT(FALSE == _fBandFinishedDisplaying);
    ASSERT(NULL  == _pacGrepText);
    ASSERT(NULL  == _pmruGrepText);
    ASSERT(NULL  == _pacFileSpec);
    ASSERT(NULL  == _pmruFileSpec);
    ASSERT(0     == *_szInitialPath);
    ASSERT(0     == *_szInitialNames);
    ASSERT(0     == *_szCurrentPath);
    ASSERT(0     == *_szLocalDrives);
    ASSERT(NULL  == _pidlInitial);
}

CFindFilesDlg::~CFindFilesDlg()
{
    ATOMICRELEASE(_pacGrepText);
    ATOMICRELEASE(_pmruGrepText);
    ATOMICRELEASE(_pacFileSpec);
    ATOMICRELEASE(_pmruFileSpec);
    ILFree(_pidlInitial);
}

//  Scope to a default namespace.
BOOL CFindFilesDlg::SetDefaultScope()
{
    //  If we've already assigned a scope, bail early
    if (_bScoped) 
        return TRUE;

    //  Try establiblishing the preassigned (_szInitialXXX) scope:
    BOOL bScoped = _SetPreassignedScope();
    if (!bScoped)
    {
        //  Try setting scope to the current shell folder of the active view...
        bScoped = _SetFolderScope();
        if (!bScoped)
        {
            //  set it to the hard-coded shell default folder
            bScoped = _SetLocalDefaultScope();
        }
    }

    return bScoped;
}


//  Assignes the namespace control to the preassigned scope saved in
//  _szInitialNames/_szInitialPath/_pidlInitial
BOOL CFindFilesDlg::_SetPreassignedScope()
{
    BOOL bScoped = FALSE;
    if (*_szInitialNames || *_szInitialPath || _pidlInitial)
        bScoped = AssignNamespace(_szInitialPath, _pidlInitial, _szInitialNames, FALSE);

    return bScoped;
}

STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf);

//  Scope to the namespace of the current shell folder view
BOOL CFindFilesDlg::_SetFolderScope()
{
    BOOL bScoped = FALSE;
    ASSERT(_pfsb->BandSite());

    LPITEMIDLIST pidl;
    if (SUCCEEDED(_GetCurrentFolderIDList(_pfsb->BandSite(), &pidl)))
    {
        // Get the display name/path.  IF it is an FTP site, then we need to get the name
        // as though it is for the address bar becasue when we call SHGetPathFromIDList,
        // it returns "" for FTP sites.  
        IShellFolder *psf = NULL;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf)))
        && IsFTPFolder(psf))
        {
            SHGetNameAndFlags(pidl, SHGDN_FORADDRESSBAR, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
            SHGetNameAndFlags(pidl, SHGDN_FORPARSING, _szInitialPath, ARRAYSIZE(_szInitialNames), NULL);
        }
        else
        {
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
            SHGetPathFromIDList(pidl, _szInitialPath);  // file system path only here!
        }

        if (psf)
        {
            psf->Release();
        }

        // Store the pidl for use later if we are starting it async
        _pidlInitial = ILClone(pidl);
        
        //  if we're tracking the scope loosely...
        if ((TRACKSCOPE_GENERAL == _fTrackScope) && _IsPathLocalHarddrive(_szInitialPath))
        {
            //  scope to local default scope
            *_szInitialNames = *_szInitialPath = 0;
            bScoped = _SetLocalDefaultScope();
        }
        else if (_threadState.fComplete /* finished populating namespace combo */ && 
                 _szInitialPath[0])
        {
            bScoped = AssignNamespace(_szInitialPath, pidl, _szInitialNames, FALSE);
        }
        ILFree(pidl);
    }

    return bScoped;
}


//  Scope to the hard-coded shell default namespace.
BOOL CFindFilesDlg::_SetLocalDefaultScope()
{
    BOOL bScoped = FALSE;

    //  Initialize fallback initial namespace

    // default to Local Hard Drives if possible
    if (_szLocalDrives[0] &&
        AssignNamespace(NULL, NULL, _szLocalDrives, FALSE))
    {
        bScoped = TRUE;
    }
    else
    {        
        TCHAR szDesktopPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szDesktopPath)) &&
            AssignNamespace(NULL, NULL, szDesktopPath, FALSE))
        {
            bScoped = TRUE;
        }
    }
    
    //  If we failed, this means that the namespace combo hasn't
    //  been populated yet.   
    //  We just sit tight, cuz the populating thread will fall back on
    //  the LocalDefaultScope.
    return bScoped;
}


//  search **band** show/hide handler
void CFindFilesDlg::OnBandShow(BOOL fShow)
{
    CSearchCmdDlg::OnBandShow(fShow);
    if (fShow)
    {
        //  Establish the first showing's band width
        if (!_fDebuted && _pfsb->IsBandDebut())
        {
            _pfsb->SetDeskbandWidth(GetIdealDeskbandWidth());
            _fDebuted = TRUE;
        }
        
        //  If we're tracking the scope to the current folder shell view,
        //  update it now, as it may have changed.
        if (_fTrackScope != TRACKSCOPE_NONE)
        {
            _bScoped = FALSE;
            _SetFolderScope();
        }
        
        //  restart our UI state timer
        SetTimer(UISTATETIMER, UISTATETIMER_DELAY);
    }
    else
    {
        //  we're being hidden so stop updating our state indicators.
        KillTimer(UISTATETIMER);
    }
}


//  search band **dialog** show/hide handler
void CFindFilesDlg::OnBandDialogShow(BOOL fShow)
{
    CSearchCmdDlg::OnBandDialogShow(fShow);

    if (fShow)
    {
        //  If we're tracking the scope to the current folder shell view,
        //  update it now, as it may have changed.
        if (_fTrackScope != TRACKSCOPE_NONE)
        {
            _bScoped = FALSE;
            _SetFolderScope();
        }
    }
}


//  Explicit scoping method.   This will be called if a client
//  called IFileSearchBand::SetSearchParameters with a non-NULL scope.
HRESULT CFindFilesDlg::SetScope(IN VARIANT* pvarScope, BOOL bTrack)
{
    HRESULT hr = CBandDlg::SetScope(pvarScope, bTrack);
    
    if (S_OK != hr)
        return hr;

    LPITEMIDLIST pidlSearch = VariantToIDList(&_varScope0);
    if (pidlSearch)
    {
        SHGetNameAndFlags(pidlSearch, SHGDN_FORPARSING,  _szInitialPath, ARRAYSIZE(_szInitialPath), NULL);
        SHGetNameAndFlags(pidlSearch, SHGDN_NORMAL, _szInitialNames, ARRAYSIZE(_szInitialNames), NULL);
        ILFree(pidlSearch);

        //  Did we get one?   
        if (*_szInitialNames || *_szInitialPath)
        {
            if (_bScoped)
            {
                //  If we've already scoped, update the namespace combo.
                //  Track if succeed and requested.
                if (AssignNamespace(_szInitialPath, NULL, _szInitialNames, FALSE) && bTrack)
                    _fTrackScope = TRACKSCOPE_SPECIFIC;
            }
            else 
            {
                //  Not already scoped.   We've assigned our initial namespace,
                //  let the namespace thread completion handler update
                //  the combo
                if (bTrack)
                    _fTrackScope = TRACKSCOPE_SPECIFIC;
            }
        }
    }
    return S_OK;
}


LRESULT CFindFilesDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _Attach(m_hWnd);
    _dlgOptions.SetBandDlg(this);

    //  Register specialty window classes.
    DivWindow_RegisterClass();
    GroupButton_RegisterClass();
    
    //  Initialize some metrics
    CMetrics&   metrics = _pfsb->GetMetrics();
    RECT        rc;

    _pfsb->GetMetrics().Init(m_hWnd);

    // SHAutoComplete(::GetWindow(GetDlgItem(IDC_NAMESPACE), GW_CHILD), SHACF_FILESYS_DIRS);

    ::GetWindowRect(GetDlgItem(IDC_FILESPEC), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    metrics.ExpandOrigin().x = rc.left;

    //  Position start, stop buttons.
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    int cxBtn = _GetResourceMetric(m_hWnd, IDS_FSEARCH_STARTSTOPWIDTH, TRUE);
    if (cxBtn > 0)
    {
        rc.right = rc.left + cxBtn;
    
        ::SetWindowPos(GetDlgItem(IDC_SEARCH_START), NULL, 
                        rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    
        OffsetRect(&rc, cxBtn + _PixelsForDbu(m_hWnd, 12, TRUE), 0);
        ::SetWindowPos(GetDlgItem(IDC_SEARCH_STOP), NULL, 
                        rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                        SWP_NOZORDER|SWP_NOACTIVATE);
    }

    //  Create subdialogs and collect native sizes.
    _dlgOptions.Create(m_hWnd);
    ASSERT(::IsWindow(_dlgOptions));

    //  Load settings
    LoadSaveUIState(0, FALSE);

    //  Show/Hide the "Search" Options subdialog
    _dlgOptions.ShowWindow(_fDisplayOptions ? SW_SHOW : SW_HIDE);

    //  Create 'link' child controls
    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;

    //  Create 'Search Options' link and group button
    _CreateLinkWindow(m_hWnd, IDC_SEARCHLINK_OPTIONS, pt, 
                       IDS_FSEARCH_SEARCHLINK_OPTIONS, !_fDisplayOptions);

    TCHAR szGroupBtn[128];
    EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_GROUPBTN_OPTIONS, 
                      szGroupBtn, ARRAYSIZE(szGroupBtn)));
    HWND hwndGrpBtn = CreateWindowEx(0, GROUPBUTTON_CLASS, szGroupBtn, 
                                      WS_CHILD|WS_BORDER|WS_TABSTOP, pt.x, pt.y, 400, 18, 
                                      m_hWnd, (HMENU)IDC_GROUPBTN_OPTIONS, HINST_THISDLL, NULL);
    if (::IsWindow(hwndGrpBtn))
    {
        ::SendMessage(hwndGrpBtn, GBM_SETBUDDY, 
                       (WPARAM)_dlgOptions.m_hWnd, (LPARAM)GBBF_HRESIZE|GBBF_VSLAVE);
        ::ShowWindow(GetDlgItem(IDC_GROUPBTN_OPTIONS), _fDisplayOptions ? SW_SHOW : SW_HIDE);
    }
                    
    //  Create cross-navigation links
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_FILES);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_FSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    //  Do some cosmetic and initialization stuff
    OnWinIniChange();

    _InitializeMru(GetDlgItem(IDC_FILESPEC), &_pacFileSpec, 
                    TEXT("FilesNamedMRU"), &_pmruFileSpec);
    _InitializeMru(GetDlgItem(IDC_GREPTEXT), &_pacGrepText, 
                    TEXT("ContainingTextMRU"), &_pmruGrepText);

    SendDlgItemMessage(IDC_FILESPEC, EM_LIMITTEXT, MAX_EDIT, 0);
    SendDlgItemMessage(IDC_GREPTEXT, EM_LIMITTEXT, MAX_EDIT, 0);

    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXTENDEDSTYLE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
            CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);
    
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETIMAGELIST, 0, (LPARAM)GetSystemImageListSmallIcons());
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXSTYLE, 0, 0);

    //  Enable the cue banners for the edit boxes:
    TCHAR szCaption[128];
    LoadString(HINST_THISDLL, IDS_FIND_CUEBANNER_FILE, szCaption, ARRAYSIZE(szCaption));
    SendDlgItemMessage(IDC_FILESPEC, EM_SETCUEBANNER, 0, (LPARAM) szCaption);

    LoadString(HINST_THISDLL, IDS_FIND_CUEBANNER_GREP, szCaption, ARRAYSIZE(szCaption));
    SendDlgItemMessage(IDC_GREPTEXT, EM_SETCUEBANNER, 0, (LPARAM) szCaption); 

    //  Bias the input reader towards file names
    SetModeBias(MODEBIASMODE_FILENAME);

    //  Launch thread to populate the namespaces combo.
    _threadState.hwndCtl   = GetDlgItem(IDC_NAMESPACE);
    _threadState.pvParam   = this;
    _threadState.fComplete = FALSE;
    _threadState.fCancel   = FALSE;

    if (SUCCEEDED(SAFECAST(_pfsb, IFileSearchBand*)->QueryInterface(IID_PPV_ARG(IUnknown, &_threadState.punkBand))))
    {
        if (!SHCreateThread(NamespaceThreadProc, &_threadState, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(_threadState.punkBand);
        }
    }

    //  Layout our subdialogs and update state representation...
    LayoutControls();
    UpdateSearchCmdStateUI();

    SetTimer(UISTATETIMER, UISTATETIMER_DELAY);

    return TRUE;  // Let the system set the focus
}


LRESULT CFindFilesDlg::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // paint the background
    _PaintDlg(m_hWnd, _pfsb->GetMetrics(), (HDC)wParam); 
    
    if (_fDisplayOptions)
        // ensure that the group button is updated.
        SendDlgItemMessage(IDC_GROUPBTN_OPTIONS, WM_NCPAINT, (WPARAM)1, 0);
    
    //  validate our work.
    ValidateRect(NULL);
    return TRUE;   
}


void CFindFilesDlg::OnWinIniChange()
{
    CBandDlg::OnWinIniChange();

    //  redisplay animated icon
    HWND hwndIcon = GetDlgItem(IDC_FSEARCH_ICON);
    Animate_Close(hwndIcon);
    Animate_OpenEx(hwndIcon, HINST_THISDLL, MAKEINTRESOURCE(IDA_FINDFILE));
    SendDlgItemMessage(IDC_NAMESPACE, CB_SETDROPPEDWIDTH, 
                        _PixelsForDbu(m_hWnd, MIN_NAMESPACELIST_WIDTH, TRUE), 0);

    _BeautifyCaption(IDC_FSEARCH_CAPTION);

    _dlgOptions.OnWinIniChange();
}


LRESULT CFindFilesDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
{
    KillTimer(UISTATETIMER);
    StopSearch();
    if (_pSrchCmd)
    {
        DisconnectEvents();
        IUnknown_SetSite(_pSrchCmd, NULL);
    }
    _threadState.fCancel = TRUE;
    _fOnDestroy = TRUE;
    bHandled = FALSE;
    return 0;
}

BOOL CFindFilesDlg::Validate()
{
    return _dlgOptions.Validate();
}

STDMETHODIMP CFindFilesDlg::AddConstraints(ISearchCommandExt *pSrchCmd)
{
    HRESULT hr;
    VARIANT var = {0};

    TCHAR szPath[MAX_URL_STRING];

    // If the user enters a path as a filename, it will recognize it as a path and replace
    // the filename with just the file portion and the namespace with the path.
    if (::GetDlgItemText(m_hWnd, IDC_FILESPEC, szPath, ARRAYSIZE(szPath)) > 0)
    {
        if (StrChr(szPath, TEXT('\\')) != NULL)
        {
            if (!_PathLooksLikeFilePattern(szPath) &&
                (PathIsUNCServer(szPath) /* string test: \\server */|| 
                 _PathIsUNCServerShareOrSub(szPath) /* string test: \\server\share */ ||
                  PathIsDirectory(szPath)) /* this actually tests existence */)
            {
                ::SetDlgItemText(m_hWnd, IDC_FILESPEC, TEXT("*.*"));
                AssignNamespace(szPath, NULL, NULL, FALSE);
            }
            else
            {
                // just use the prefix for the file spec & the root for the location
                TCHAR szRoot[MAX_URL_STRING];

                hr = StringCchCopy(szRoot, ARRAYSIZE(szRoot), szPath);  // should always fit - both same size
                if (SUCCEEDED(hr))
                {
                    if (PathRemoveFileSpec(szRoot) && szRoot[0] != 0)
                    {
                        PathStripPath(szPath);
                        ::SetDlgItemText(m_hWnd, IDC_FILESPEC, szPath);
                        AssignNamespace(szRoot, NULL, NULL, FALSE);
                    }
                }
            }
        }
    }

    // If _ReconcileNamespace could not add an item to the combo box for 
    // the path entered, then it means that the path is likely invalid. 
    // Get the path and check it here.  
    IEnumIDList *penum;
    hr = _GetTargetNamespace(&penum);
    if (SUCCEEDED(hr))
    {
        var.vt = VT_UNKNOWN;
        penum->QueryInterface(IID_PPV_ARG(IUnknown, &var.punkVal));

        hr = _AddConstraint(pSrchCmd, L"LookIn", &var);

        VariantClear(&var);
    }
    else
    {
        GetDlgItemText(IDC_NAMESPACE, szPath, ARRAYSIZE(szPath));
        hr = _PathValidate(szPath, GetParent(), TRUE);
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(InitVariantFromStr(&var, szPath)))
            {
                hr = _AddConstraint(pSrchCmd, L"LookIn", &var);
                VariantClear(&var);
            }
        }
        else
        {
            // _PathValidate's SHPathPrepareForWrite may have already displayed error
            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                TCHAR szMsg[MAX_URL_STRING];
                if (_FmtError(IDS_FSEARCH_INVALIDFOLDER_FMT, szPath, szMsg, ARRAYSIZE(szMsg)))
                    ShellMessageBox(HINST_THISDLL, GetParent(), szMsg, NULL, MB_OK | MB_ICONASTERISK);
            }
            ::SetFocus(GetDlgItem(IDC_NAMESPACE));
        }
    }

    if (SUCCEEDED(hr))
    {
        //  Add 'Files Named' constraint
        if (S_OK == _GetWindowValue(m_hWnd, IDC_FILESPEC, &var))
        {
            hr = _AddConstraint(pSrchCmd, L"Named", &var);
            if (SUCCEEDED(hr))
                _AddMruStringFromWindow(_pmruFileSpec, GetDlgItem(IDC_FILESPEC));
            VariantClear(&var);
        }

        //  Add 'Containing Text' constraint
        if (S_OK == _GetWindowValue(m_hWnd, IDC_GREPTEXT, &var))
        {
            VARIANT varQuery;
            ULONG ulDialect;
            BOOL fCiQuery = IsCiQuery(&var, &varQuery, &ulDialect);
            if (fCiQuery)
            {
                hr = _AddConstraint(pSrchCmd, L"IndexedSearch", &varQuery);
                if (SUCCEEDED(hr))
                {
                    _AddMruStringFromWindow(_pmruGrepText, GetDlgItem(IDC_GREPTEXT));
                
                    VariantClear(&var);
                    var.vt = VT_UI4;
                    var.ulVal = ulDialect;
                    hr = _AddConstraint(pSrchCmd, L"QueryDialect", &var);
                }
            }
            else
            {
                //  add to 'containing text' constraint
                hr = _AddConstraint(pSrchCmd, L"ContainingText", &var);
                if (SUCCEEDED(hr))
                    _AddMruStringFromWindow(_pmruGrepText, GetDlgItem(IDC_GREPTEXT));
            }
            VariantClear(&varQuery);
            VariantClear(&var);
        }

        //  Warning flags
    
        if (_dwRunOnceWarningFlags != DFW_DEFAULT) 
        {
            // re-run the query w/ temporary warning bits.
            var.ulVal = _dwRunOnceWarningFlags;
            var.vt    = VT_UI4;
            //_dwRunOnceWarningFlags = DFW_DEFAULT; cannot reset it here in case of error, must preserve them
       
            hr = _AddConstraint(pSrchCmd, L"WarningFlags", &var);
        }
        else if (_dwWarningFlags != DFW_DEFAULT)
        {
            var.ulVal = _dwWarningFlags;
            var.vt    = VT_UI4;
            hr = _AddConstraint(pSrchCmd, L"WarningFlags", &var);
        }
    
        VariantClear(&var);

        hr = _dlgOptions.AddConstraints(pSrchCmd);
    }

    return hr;
}


STDMETHODIMP CFindFilesDlg::RestoreConstraint(const BSTR bstrName, const VARIANT* pValue)
{
    if (IsConstraintName(L"Named", bstrName))
    {
        _SetWindowValue(m_hWnd, IDC_FILESPEC, pValue);
        return S_FALSE;
    }

    if (IsConstraintName(L"IndexedSearch", bstrName))
    {
        ASSERT(VT_BSTR == pValue->vt);
        if (pValue->bstrVal)
        {
            int cch = lstrlenW(pValue->bstrVal) + 2;
            LPWSTR pwszVal = new WCHAR[cch];
            if (pwszVal)
            {
                *pwszVal = L'!';
                StringCchCat(pwszVal, cch, pValue->bstrVal);   // truncation ok
            }
        
            ::SetDlgItemTextW(m_hWnd, IDC_GREPTEXT, pwszVal);
            if (pwszVal)
                delete [] pwszVal;
        }
        return S_FALSE;
    }

    if (IsConstraintName(L"ContainingText", bstrName))
    {
        _SetWindowValue(m_hWnd, IDC_GREPTEXT, pValue);
        return S_FALSE;
    }

    HRESULT hr = _dlgOptions.RestoreConstraint(bstrName, pValue);

    if (S_OK == hr) // opened a dialog
        _ShowOptions(TRUE);

    if (SUCCEEDED(hr))
        return hr;   
   
    return E_FAIL;
}


void CFindFilesDlg::RestoreSearch()
{
    DFConstraint* pdfc = NULL;
    HRESULT hr;
    BOOL    bMore = TRUE;
    ISearchCommandExt* pSrchCmd = GetSearchCmd();

    if (NULL == pSrchCmd)
        return;

    CSearchCmdDlg::Clear();

    // we'll anchor to any restored scope, or the default
    _fTrackScope = TRACKSCOPE_GENERAL;

    for (hr = pSrchCmd->GetNextConstraint(TRUE, &pdfc);
         S_OK == hr && bMore;
         hr = pSrchCmd->GetNextConstraint(FALSE, &pdfc))
    {
        BSTR bstrName = NULL;

        if (S_OK == (hr = pdfc->get_Name(&bstrName)) && bstrName)
        {
            if (*bstrName == 0)
                bMore = FALSE;   // no more constraints.
            else
            {
                VARIANT varValue = {0};
                hr = pdfc->get_Value(&varValue);
                if (S_OK == hr)
                {
                    //  If this is the 'lookin' value, cache the path.
                    if (IsConstraintName(L"LookIn", bstrName))
                    {
                        if (VT_BSTR == varValue.vt && varValue.bstrVal)
                        {
                            //  Assign path and clear display name (which we don't know or care about).
                            if (_bScoped)
                                AssignNamespace(varValue.bstrVal, NULL, NULL, FALSE);
                            else
                            {
                                StringCchCopy(_szInitialPath, ARRAYSIZE(_szInitialPath), varValue.bstrVal); // truncation ok
                                *_szInitialNames = 0;
                            }
                        }
                    }
                    else
                        RestoreConstraint(bstrName, &varValue);    
                    VariantClear(&varValue);
                }
            }
            SysFreeString(bstrName);
        }

        pdfc->Release();
    }
    LayoutControls();
    _pfsb->UpdateLayout();
}

HRESULT FirstIDList(IEnumIDList *penum, LPITEMIDLIST *ppidl)
{
    penum->Reset();
    return penum->Next(1, ppidl, NULL);
}

HRESULT CFindFilesDlg::_GetTargetNamespace(IEnumIDList **ppenum)
{
    *ppenum = NULL;

    // We don't trust the comboex to handle the edit text properly so try to compensate...
    TCHAR szText[MAX_PATH];
    GetDlgItemText(IDC_NAMESPACE, szText, ARRAYSIZE(szText));
    INT_PTR iCurSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if (CB_ERR != iCurSel)
    {
        UINT cchItem = SendDlgItemMessage(IDC_NAMESPACE, CB_GETLBTEXTLEN, (WPARAM)iCurSel, (LPARAM)0);
        if (cchItem != CB_ERR)
        {
            TCHAR *pszItemName = (TCHAR *)LocalAlloc(LPTR, (cchItem+1)*sizeof(TCHAR));

            if (pszItemName != NULL)
            {
                if (CB_ERR == SendDlgItemMessage(IDC_NAMESPACE, CB_GETLBTEXT, (WPARAM)iCurSel, (LPARAM)pszItemName))
                {
                    pszItemName[0] = 0;
                }

                *ppenum = _GetItems(iCurSel);
                if (*ppenum)
                {
                    if (lstrcmp(szText, pszItemName))
                        *ppenum = NULL;            // combo edit/combo dropdown mismatch!
                }
                LocalFree(pszItemName);
            }
        }
    }
    return *ppenum ? S_OK : E_FAIL;
}

void CFindFilesDlg::Clear()
{
    CSearchCmdDlg::Clear();
    
    //  Clear edit fields
    SetDlgItemText(IDC_FILESPEC, NULL);
    SetDlgItemText(IDC_GREPTEXT, NULL);

    _dlgOptions.Clear();
    _pfsb->UpdateLayout(BLF_ALL);
}

void CFindFilesDlg::LoadSaveUIState(UINT nIDCtl, BOOL bSave) 
{
    if (0 == nIDCtl)   // load/save all.
    {
        LoadSaveUIState(IDC_SEARCHLINK_OPTIONS, bSave);
        LoadSaveUIState(LSUIS_WARNING, bSave);
    }
    
    HKEY hkey = _pfsb->GetBandRegKey(bSave);
    if (hkey)
    {
        DWORD   dwData;
        DWORD   cbData;
        DWORD   dwType = REG_DWORD;
        LPCTSTR pszVal = NULL; 

        switch (nIDCtl)
        {
        case IDC_SEARCHLINK_OPTIONS:
            pszVal = TEXT("UseSearchOptions");
            dwData = _fDisplayOptions;
            cbData = sizeof(dwData);
            break;
        
        case LSUIS_WARNING:
            pszVal = TEXT("Warnings");
            dwData = _dwWarningFlags;
            cbData = sizeof(_dwWarningFlags);
            break;
        }

        if (bSave)
        {
            RegSetValueEx(hkey, pszVal, 0, dwType, (LPBYTE)&dwData, cbData);
        }
        else if (pszVal != NULL)
        {
            DWORD dwTypeActual;

            if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszVal, 0, &dwTypeActual,
                                                  (LPBYTE)&dwData, &cbData)
                && dwType == dwTypeActual)
            {
                switch (nIDCtl)
                {
                case IDC_SEARCHLINK_OPTIONS:
                    _fDisplayOptions = BOOLIFY(dwData);
                    break;
                case LSUIS_WARNING:
                    _dwWarningFlags = dwData;
                    break;
                }
            }
        }
        
        RegCloseKey(hkey);
    }
}

HWND CFindFilesDlg::GetFirstTabItem() const
{
    return GetDlgItem(FSEARCHMAIN_TABFIRST);
}

HWND CFindFilesDlg::GetLastTabItem() const
{
    return GetDlgItem(FSEARCHMAIN_TABLAST);
}

BOOL CFindFilesDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2)
{
    *ppac2 = NULL;

    if (hwnd == GetDlgItem(IDC_FILESPEC))
        *ppac2 = _pacFileSpec;
    else if (hwnd == GetDlgItem(IDC_GREPTEXT))
        *ppac2 = _pacGrepText;

    if (*ppac2)
    {
        (*ppac2)->AddRef();
        return TRUE;
    }
    return CBandDlg::GetAutoCompleteObjectForWindow(hwnd, ppac2);
}


void CFindFilesDlg::_ShowNamespaceEditImage(BOOL bShow)
{
    SendDlgItemMessage(IDC_NAMESPACE, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, bShow ? 0 : CBES_EX_NOEDITIMAGE);
}



STDMETHODIMP CFindFilesDlg::TranslateAccelerator(MSG *pmsg)
{
    //  Check for Ctrl+Nav Key:
    if (S_OK == CSearchCmdDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Check for VK_RETURN key.
    if (WM_KEYDOWN == pmsg->message)
    {
        HWND hwndFocus = ::GetFocus();
        if (hwndFocus == GetDlgItem(IDC_NAMESPACE) || ::IsChild(GetDlgItem(IDC_NAMESPACE), hwndFocus))
        {
            if (VK_RETURN == pmsg->wParam || VK_TAB == pmsg->wParam || VK_F6 == pmsg->wParam)
            {
                _UIReconcileNamespace();
            }
            else 
            {
                //  Hide edit image if this virtkey maps to a character,
                if (MapVirtualKey((UINT)pmsg->wParam, 2) != 0 /* it's a char */)
                    _fNamespace = TRUE;
                _ShowNamespaceEditImage(!_fNamespace);
            }
        }
    }

    if (_dlgOptions.IsChild(pmsg->hwnd) &&
        S_OK == _dlgOptions.TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}


BOOL CFindFilesDlg::GetMinSize(HWND hwndOC, SIZE *psize) const
{
    CMetrics& metrics = _pfsb->GetMetrics();
    RECT rc;

    //  Calculate minimum tracking width.
    ASSERT(psize);
    psize->cx = psize->cy = 0;

    if (!::IsWindow(m_hWnd))
        return FALSE;

        // determine mininum width
    HWND hwndLimit = GetDlgItem(FSEARCHMAIN_RIGHTMOST);
    if (!::GetWindowRect(hwndLimit, &rc))
    {
        ASSERT(hwndLimit != NULL);
        return FALSE;
    }
    ::MapWindowRect(NULL, m_hWnd, &rc);
    psize->cx = rc.right + metrics.CtlMarginX();

    // determine mininum height
    hwndLimit = GetDlgItem(FSEARCHMAIN_BOTTOMMOST);

    if (!(::IsWindow(hwndLimit) && ::GetWindowRect(hwndLimit, &rc)))
        return FALSE;

    ::MapWindowRect(NULL, m_hWnd, &rc);
    psize->cy = rc.bottom + metrics.TightMarginY();

    return TRUE;
}


int CFindFilesDlg::GetIdealDeskbandWidth() const
{
    LONG cx0 = _GetResourceMetric(m_hWnd, IDS_FSEARCH_BANDWIDTH, TRUE);
    ASSERT(cx0 >= 0);

    return cx0 + (_pfsb->GetMetrics().CtlMarginX() * 2);
}


void CFindFilesDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rcClient;
        GetClientRect(&rcClient);
        cx = RECTWIDTH(rcClient);
        cy = RECTHEIGHT(rcClient);
    }
    CBandDlg::LayoutControls(cx, cy);

    CMetrics& metrics = _pfsb->GetMetrics();
    POINT ptOrigin = metrics.ExpandOrigin();
    HDWP  hdwp = BeginDeferWindowPos(6);

    if (hdwp)
    {
        //  Resize edit, combo immediate children
        int i;
        enum {  ircFILESPEC,
                ircGREPTEXT,
                ircNAMESPACE,
                ircSEARCHSTART,
                ircOPTIONGRP,
                ircOPTIONSDLG,
                ircLINKCAPTION,
                ircDIV2,
                irc_count };
        RECT rcCtls[irc_count];

        ::GetWindowRect(GetDlgItem(IDC_FILESPEC),            &rcCtls[ircFILESPEC]);
        ::GetWindowRect(GetDlgItem(IDC_GREPTEXT),            &rcCtls[ircGREPTEXT]);
        ::GetWindowRect(GetDlgItem(IDC_NAMESPACE),           &rcCtls[ircNAMESPACE]);
        ::GetWindowRect(GetDlgItem(IDC_SEARCH_START),        &rcCtls[ircSEARCHSTART]);
        ::GetWindowRect(GetDlgItem(IDC_GROUPBTN_OPTIONS),    &rcCtls[ircOPTIONGRP]);
        ::GetWindowRect(GetDlgItem(IDC_SEARCHLINK_CAPTION),  &rcCtls[ircLINKCAPTION]);
        ::GetWindowRect(GetDlgItem(IDC_FSEARCH_DIV2),        &rcCtls[ircDIV2]);

        SIZE sizeOptions;
        _dlgOptions.GetWindowRect(&rcCtls[ircOPTIONSDLG]);
        _dlgOptions.GetMinSize(&sizeOptions);
        rcCtls[ircOPTIONSDLG].bottom = rcCtls[ircOPTIONSDLG].top + sizeOptions.cy;
        for (i = 0; i < ARRAYSIZE(rcCtls); i++)
        {
            // MapWindowPoints is mirroring aware only if you pass two points        
            ::MapWindowRect(NULL, m_hWnd, &rcCtls[i]);
        }    

        //  Position caption elements
        _LayoutCaption(IDC_FSEARCH_CAPTION, IDC_FSEARCH_ICON, IDC_FSEARCH_DIV1, cx);

        //  Resize ctl widths
        for (i = 0; i < irc_count; i++)
            rcCtls[i].right = cx - metrics.CtlMarginX();

        //  Stretch the 'Named' combo:
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_FILESPEC), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircFILESPEC)), RECTHEIGHT(*(rcCtls + ircFILESPEC)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

        //  Stretch the 'Containing Text' combo:
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_GREPTEXT), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircGREPTEXT)), RECTHEIGHT(*(rcCtls + ircGREPTEXT)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

        //  Stretch the 'Look In' combo
        ::DeferWindowPos(hdwp, GetDlgItem(IDC_NAMESPACE), NULL, 0, 0,
                        RECTWIDTH(*(rcCtls + ircNAMESPACE)), RECTHEIGHT(*(rcCtls + ircNAMESPACE)),
                        SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        
        //  Arrange dynamically positioned controls.
        ptOrigin.y = rcCtls[ircSEARCHSTART].bottom + metrics.LooseMarginY();
        if (_fDisplayOptions)
        {
            OffsetRect(&rcCtls[ircOPTIONGRP], metrics.CtlMarginX() - rcCtls[ircOPTIONGRP].left, 
                                                ptOrigin.y - rcCtls[ircOPTIONGRP].top);
            rcCtls[ircOPTIONSDLG].right = cx - metrics.CtlMarginX();

            ::SetWindowPos(GetDlgItem(IDC_GROUPBTN_OPTIONS), NULL, 
                            rcCtls[ircOPTIONGRP].left, rcCtls[ircOPTIONGRP].top,
                            RECTWIDTH(rcCtls[ircOPTIONGRP]), RECTHEIGHT(rcCtls[ircOPTIONGRP]),
                            SWP_NOZORDER|SWP_NOACTIVATE);
            
            ::GetWindowRect(GetDlgItem(IDC_GROUPBTN_OPTIONS),    &rcCtls[ircOPTIONGRP]);
            ::MapWindowRect(NULL, m_hWnd, &rcCtls[ircOPTIONGRP]);
            
            ptOrigin.y = rcCtls[ircOPTIONGRP].bottom + metrics.TightMarginY();
        }
        else
        {
            //  Position the 'Options' link
            _LayoutLinkWindow(m_hWnd, metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                                ptOrigin.y, IDC_SEARCHLINK_OPTIONS);
        }

        ptOrigin.y += metrics.TightMarginY();

        //  Position the 'Search for Other Items' caption, divider and link windows
        const int rgLinkIDs[] = { 
            IDC_SEARCHLINK_FILES,
            IDC_SEARCHLINK_COMPUTERS,
            IDC_SEARCHLINK_PRINTERS,
            IDC_SEARCHLINK_PEOPLE,
            -IDC_FSEARCH_DIV3,
            IDC_SEARCHLINK_INTERNET, 
        };

        _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, !_fDisplayOptions,
                            metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                            ptOrigin.y, rgLinkIDs, ARRAYSIZE(rgLinkIDs));

        EndDeferWindowPos(hdwp);
    }

}


LRESULT CFindFilesDlg::OnUpdateLayout(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    LayoutControls();
    _pfsb->UpdateLayout((ULONG)wParam);
    return 0;
}


LRESULT CFindFilesDlg::OnTimer(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    if (UISTATETIMER == wParam && IsWindowVisible())
        UpdateSearchCmdStateUI();
    
    return 0;
}


LRESULT CFindFilesDlg::OnOptions(int idCtl, NMHDR *pnmh, BOOL&)
{
    _ShowOptions(!_fDisplayOptions);
    LoadSaveUIState(IDC_SEARCHLINK_OPTIONS, TRUE);

    if (_fDisplayOptions)
        _dlgOptions.TakeFocus();
    else
        ::SetFocus(GetDlgItem(IDC_SEARCHLINK_OPTIONS));

    return 0;
}


void CFindFilesDlg::_ShowOptions(BOOL bShow)
{
    _fDisplayOptions = bShow;

    //  don't need to scroll if we've expanded a subdialog,
    //  but we do if we've contracted one.
    ULONG dwLayoutFlags = BLF_ALL;
    if (_fDisplayOptions)
        dwLayoutFlags &= ~BLF_SCROLLWINDOW;    

    LayoutControls();
    _pfsb->UpdateLayout(dwLayoutFlags);

    ::ShowWindow(GetDlgItem(IDC_GROUPBTN_OPTIONS), _fDisplayOptions ? SW_SHOW : SW_HIDE);
    ::ShowWindow(GetDlgItem(IDC_SEARCHLINK_OPTIONS), !_fDisplayOptions ? SW_SHOW : SW_HIDE);

}


LRESULT CFindFilesDlg::OnQueryOptionsHeight(int idCtl, NMHDR *pnmh, BOOL&)
{
    GBNQUERYBUDDYSIZE* pqbs = (GBNQUERYBUDDYSIZE*)pnmh;
    pqbs->cy = _dlgOptions.QueryHeight(pqbs->cx, pqbs->cy);
    return TRUE;
}


void CFindFilesDlg::UpdateSearchCmdStateUI(DISPID eventID)
{
    if (_fOnDestroy)
        return;

    if (DISPID_SEARCHCOMMAND_COMPLETE == eventID 
    ||   DISPID_SEARCHCOMMAND_ABORT == eventID)
        _dwRunOnceWarningFlags = DFW_DEFAULT;

    CSearchCmdDlg::UpdateSearchCmdStateUI(eventID);
    _dlgOptions.UpdateSearchCmdStateUI(eventID);
}


BOOL CFindFilesDlg::OnSearchCmdError(HRESULT hr, LPCTSTR pszError)
{
    if (SCEE_SCOPEMISMATCH == HRESULT_CODE(hr) 
    ||  SCEE_INDEXNOTCOMPLETE == HRESULT_CODE(hr))
    {
        //  Set up checkbox
        BOOL fFlag = SCEE_SCOPEMISMATCH == HRESULT_CODE(hr)? DFW_IGNORE_CISCOPEMISMATCH :
                                                             DFW_IGNORE_INDEXNOTCOMPLETE ,
             fNoWarn = (_dwWarningFlags & fFlag) != 0,
             fNoWarnPrev = fNoWarn;
        USHORT uDlgT = SCEE_SCOPEMISMATCH == HRESULT_CODE(hr)? DLG_FSEARCH_SCOPEMISMATCH :
                                                               DLG_FSEARCH_INDEXNOTCOMPLETE ;
        int  nRet = CSearchWarningDlg_DoModal(m_hWnd, uDlgT, &fNoWarn);

        if (fNoWarn)
            _dwWarningFlags |= fFlag;
        else
            _dwWarningFlags &= ~fFlag;        
        
        if (fNoWarnPrev != fNoWarn)
            LoadSaveUIState(LSUIS_WARNING, TRUE);

        if (IDOK == nRet)
        {
            _dwRunOnceWarningFlags |= _dwWarningFlags | fFlag ; // preserve the old run once flags...
            //  hack one, hack two...  let's be USER!!! [scotthan]
            PostMessage(WM_COMMAND, MAKEWPARAM(IDC_SEARCH_START, BN_CLICKED),
                         (LPARAM)GetDlgItem(IDC_SEARCH_START));
        }
        else
            ::SetFocus(GetDlgItem(IDC_NAMESPACE));

        return TRUE;
    }
    return CSearchCmdDlg::OnSearchCmdError(hr, pszError);
}

LRESULT CFindFilesDlg::OnBtnClick(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    switch (nID)
    {
    case IDC_SEARCH_START:
        if (_ShouldReconcileNamespace())
            _UIReconcileNamespace(TRUE);
        
        if (SUCCEEDED(StartSearch()))
        {
            EnableStartStopButton(hwndCtl, FALSE);
            StartStopAnimation(TRUE);
        }
        break;

    case IDC_SEARCH_STOP:
        StopSearch();
        break;
    }
    return 0;
}

void CFindFilesDlg::NavigateToResults(IWebBrowser2* pwb2)
{
    BSTR bstrUrl = SysAllocString(L"::{e17d4fc0-5564-11d1-83f2-00a0c90dc849}");// CLSID_DocFindFolder
    if (bstrUrl)
    {
        VARIANT varNil = {0};
        pwb2->Navigate(bstrUrl, &varNil, &varNil, &varNil, &varNil);
        SysFreeString(bstrUrl);
    }
}

LRESULT CFindFilesDlg::OnStateChange(UINT, WPARAM, LPARAM, BOOL&)
{
    UpdateSearchCmdStateUI();
    return 0;
}

LRESULT CFindFilesDlg::OnNamespaceSelEndOk(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    LRESULT iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if (iSel != CB_ERR)
    {
        IEnumIDList *penum = _GetItems(iSel);
        if (NULL == penum)
            _BrowseAndAssignNamespace();    // Was this the "Browse..." item 
        else
            _iCurNamespace = iSel;
    }

    _pfsb->SetDirty();
    return 0;
}

LRESULT CFindFilesDlg::OnNamespaceEditChange(WORD wID, WORD wCode, HWND hwndCtl, BOOL& bHandled)
{
    return OnEditChange(wID, wCode, hwndCtl, bHandled);
}

//  Handler for CBN_SELENDCANCEL, CBN_DROPDOWN, CBN_KILLFOCUS
LRESULT CFindFilesDlg::OnNamespaceReconcileCmd(WORD wID, WORD wCode, HWND hwndCtl, BOOL&)
{
    if (_ShouldReconcileNamespace())
        _UIReconcileNamespace(wCode != CBN_DROPDOWN);
    return 0;
}

//  Handler for WM_NOTIFY::CBEN_ENDEDIT
LRESULT CFindFilesDlg::OnNamespaceReconcileNotify(int idCtl, NMHDR *pnmh, BOOL& bHandled)
{
    if (_ShouldReconcileNamespace())
    {
        //  Post ourselves a message to reconcile the ad hoc namespace.
        //  Note: We need to do this because ComboBoxEx won't update his window text if he
        //  is waiting for his CBEN_ENDEDIT notification message to return.
        PostMessage(WMU_NAMESPACERECONCILE, 0, 0);
    }
    bHandled = FALSE; // let base class have a crack as well.
    return 0;
}


//  WMU_NAMESPACERECONCILE handler
LRESULT CFindFilesDlg::OnNamespaceReconcileMsg(UINT, WPARAM, LPARAM, BOOL&)
{
    if (_ShouldReconcileNamespace())
        _UIReconcileNamespace(FALSE);
    return 0;
}

//  WMU_BANDFINISHEDDISPLAYING handler
//  Note that we do not care about returning results from this, as it will
//  be started asynchronously.
LRESULT CFindFilesDlg::OnBandFinishedDisplaying(UINT, WPARAM, LPARAM, BOOL&)
{
    //  Now that the search band has finished displaying, we will do the
    //  delayed initialization.  Make sure we don't do it twice.
    if (!_fBandFinishedDisplaying)
    {
        _fBandFinishedDisplaying = TRUE;
        _dlgOptions.DoDelayedInit();
    }
    return 0;
}


BOOL CFindFilesDlg::_ShouldReconcileNamespace()
{
    return _fNamespace || SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0) == CB_ERR;
}


//  Invokes lower Namespace reconciliation helper, updates some UI and 
//  instance state data. 
//  this was added as a late RC 'safe' delta, and should have actually
//  become part of _ReconcileNamespace() impl.
void CFindFilesDlg::_UIReconcileNamespace(BOOL bAsync)
{
    LRESULT iSel = _ReconcileNamespace(bAsync);
    if (iSel != CB_ERR)
        _iCurNamespace = iSel;

    _ShowNamespaceEditImage(TRUE);
    _fNamespace = FALSE; // clear the ad hoc flag.    
}

//  Scans namespace combo for a matching namespace; if found, selects
//  the namespace item, otherwise adds an adhoc item and selects it.
//  
//  Important: don't call this directly, call _UIReconcileNamespace()
//  instead to ensure that instance state data is updated.
INT_PTR CFindFilesDlg::_ReconcileNamespace(OPTIONAL BOOL bAsync)
{
    INT_PTR iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
    if ((CB_ERR != iSel) && (NULL == _GetItems(iSel)))
    {
        // The user has selected the special Browse... item. 
        // Irreconcilable.  Return CB_ERR
        return CB_ERR;
    }

    //  Don't know the namespace?  Use current window text.
    TCHAR szNamespace[MAX_URL_STRING];
    if (0 == GetDlgItemText(IDC_NAMESPACE, szNamespace, ARRAYSIZE(szNamespace)))
        return CB_ERR;

    INT_PTR iFind = _FindNamespace(szNamespace, NULL);

    // search display names
    if (CB_ERR == iFind)
    {
        // search paths
        TCHAR szTemp[MAX_URL_STRING];

        StringCchCopy(szTemp, ARRAYSIZE(szTemp), szNamespace); // ok to truncate
        _PathFixup(szNamespace, ARRAYSIZE(szNamespace), szTemp); // don't care if this fails, the path might be a path list

        iFind = _FindNamespace(szNamespace, NULL);
    }

    //  Not found in CB list? Add it if it's a valid path
    if (CB_ERR == iFind)
    {
        iSel = _AddNamespace(szNamespace, NULL, szNamespace, TRUE);
    }
    else
    {    
        // found in CB list? Select it.
        if (bAsync)
        {
            // this was needed in cases of reconcile following kill focus
            ::PostMessage(GetDlgItem(IDC_NAMESPACE), CB_SETCURSEL, iFind, 0); 
        }
        else
        {
            iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iFind, 0);
        }
    }

    return iSel;
}

BOOL CFindFilesDlg::_PathFixup(LPTSTR pszDst, UINT cchDst, LPCTSTR pszSrc)
{
    ASSERT(pszDst);
    ASSERT(pszSrc);
    TCHAR szSrc[MAX_PATH];
    TCHAR szFull[MAX_PATH];

    if (SHExpandEnvironmentStrings(pszSrc, szSrc, ARRAYSIZE(szSrc)) && *szSrc)
        pszSrc = szSrc;

    if (_IsPathList(pszSrc))
    {
        StringCchCopy(pszDst, cchDst, pszSrc); // ok to truncate
        return TRUE;
    }

    szFull[0] = 0;
    BOOL bRelative     = PathIsRelative(pszSrc);
    BOOL bMissingDrive = bRelative ? FALSE : _IsFullPathMinusDriveLetter(pszSrc);
    // bMissingDrive =,e.g. "\foo", "\foo\bar", etc.  PathIsRelative() reports FALSE in this case.

    if (bRelative || bMissingDrive)
    {
        ASSERT(_pfsb && _pfsb->BandSite());

        LPITEMIDLIST pidl;
        HRESULT hr = _GetCurrentFolderIDList(_pfsb->BandSite(), &pidl);
        if (S_OK == hr) 
        {
            TCHAR szCurDir[MAX_PATH];   
            // file system path only here!
            if (SHGetPathFromIDList(pidl, szCurDir) && 
                StrCmpI(szCurDir, _szCurrentPath))
            {
                StringCchCopy(_szCurrentPath, ARRAYSIZE(_szCurrentPath), szCurDir);    // ok to truncate
            }

            if (*_szCurrentPath)
            {
                if (bRelative)
                {
                    if (PathCombine(szFull, _szCurrentPath, pszSrc))
                        pszSrc = szFull;
                }
                else if (bMissingDrive)
                {
                    int iDrive = PathGetDriveNumber(_szCurrentPath);
                    if (-1 != iDrive)
                    {
                        TCHAR szRoot[MAX_PATH];
                        if (PathCombine(szFull, PathBuildRoot(szRoot, iDrive), pszSrc))
                            pszSrc = szFull;
                    }
                }
            }
            ILFree(pidl);
        }
    }
    return PathCanonicalize(pszDst, pszSrc);
}

LRESULT CFindFilesDlg::OnNamespaceDeleteItem(int idCtrl, NMHDR *pnmh, BOOL& bHandled)
{
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnmh;
    if (pnmce->ceItem.lParam)
    {
        IEnumIDList *penum = (IEnumIDList *)pnmce->ceItem.lParam;
        penum->Release();
    }
    return 1;
}

DWORD CFindFilesDlg::NamespaceThreadProc(void* pv)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)pv;
    CFindFilesDlg* pThis = (CFindFilesDlg*)pState->pvParam;

    if (PopulateNamespaceCombo(pState->hwndCtl, AddNamespaceItemNotify, (LPARAM)pv) != E_ABORT)
    {
        ::PostMessage(::GetParent(pState->hwndCtl), WMU_COMBOPOPULATIONCOMPLETE, (WPARAM)pState->hwndCtl, 0);
    }

    pState->fComplete = TRUE;
    ATOMICRELEASE(pState->punkBand);
    return 0;
}

#define CBX_CSIDL_LOCALDRIVES          0x04FF   // arbitrarily out of range of other CSIDL_xxx values.

HRESULT CFindFilesDlg::AddNamespaceItemNotify(ULONG fAction, PCBXITEM pItem, LPARAM lParam)
{
    FSEARCHTHREADSTATE *pState = (FSEARCHTHREADSTATE *)lParam;
    
    if (fAction & CBXCB_ADDING && pState->fCancel)
        return E_ABORT;

    //
    //  Sets the string in the CFindFilesDlg as the display name.
    //  This string is then used to set the default item in the 
    //  combo box.
    //
    if (fAction & CBXCB_ADDED && CBX_CSIDL_LOCALDRIVES == pItem->iID)
    {
        CFindFilesDlg* pffd = (CFindFilesDlg*)pState->pvParam;

        StringCchCopy(pffd->_szLocalDrives, ARRAYSIZE(pffd->_szLocalDrives), pItem->szText); // ok to truncate
    }

    return S_OK;
}

LRESULT CFindFilesDlg::OnComboPopulationComplete(UINT, WPARAM wParam, LPARAM, BOOL&)
{
    _bScoped = SetDefaultScope();
    return 0;
}

// bPassive TRUE -> assign only if no current selection

BOOL CFindFilesDlg::AssignNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bPassive)
{
    INT_PTR iSel = CB_ERR;
    
    //  If we don't yet have a current selection, establish it now.
    if (!bPassive || CB_ERR == (iSel = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0)))
    {
        iSel = _FindNamespace(pszPath, pidl);

        // scan items by display name if we don't have pidl
        // otherwise choosing x:\my pictures (in browse) would end up selecting
        // my pictures folder and searching the wrong place
        if (CB_ERR == iSel && !pidl && !pszPath && pszName && *pszName)
            iSel = _FindNamespace(pszName, NULL);

        //  Is this a folder we already know about?
        if (CB_ERR == iSel)
        {
            if (pidl || pszPath)
                iSel = _AddNamespace(pszPath, pidl, pszName, TRUE);

            if (iSel != CB_ERR)
                _iCurNamespace = iSel;
        }
        else
        {
            // yes: select it
            SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iSel, 0);
            _iCurNamespace = iSel;
        }
    }

    return CB_ERR != SendDlgItemMessage(IDC_NAMESPACE, CB_GETCURSEL, 0, 0);
}

HWND CFindFilesDlg::ShowHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("find.chm"), HH_DISPLAY_TOPIC, 0);
}

// inserts something into the name space combo
INT_PTR CFindFilesDlg::_AddNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl, LPCTSTR pszName, BOOL bSelectItem)
{
    IEnumIDList *penum = NULL;

    if (pszPath)
    {
        CreateIEnumIDListPaths(pszPath, &penum);
    }
    else if (pidl)
    {
        CreateIEnumIDListOnIDLists(&pidl, 1, &penum);
    }

    CBXITEM item;
    item.iItem = CB_ERR;    // failure result here
    if (penum)
    {
        LPITEMIDLIST pidlIcon;
        if (S_OK == FirstIDList(penum, &pidlIcon))
        {
            if (NULL == pszName)
                pszName = pszPath;

            MakeCbxItem(&item, pszName, penum, pidlIcon, LISTINSERT_LAST, 1);

            INT_PTR iSel = item.iItem;
            if (SUCCEEDED(AddCbxItemToComboBox(GetDlgItem(IDC_NAMESPACE), &item, &iSel)))
            {
                penum = NULL;   // don't release below

                item.iItem = iSel;
                if (bSelectItem)
                    SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, iSel, 0);
            }
            else
            {
                item.iItem = CB_ERR;
            }
            ILFree(pidlIcon);
        }

        if (penum)
            penum->Release();   // not inserted, free this
    }

    return item.iItem;
}

LPARAM CFindFilesDlg::_GetComboData(UINT id, INT_PTR idx)
{
    if (CB_ERR == idx)
        idx = SendDlgItemMessage(id, CB_GETCURSEL, 0, 0);
    if (CB_ERR == idx)
        return idx;

    return (LPARAM)SendDlgItemMessage(id, CB_GETITEMDATA, idx, 0);
}

IEnumIDList *CFindFilesDlg::_GetItems(INT_PTR i)
{
    IEnumIDList *penum = (IEnumIDList *)_GetComboData(IDC_NAMESPACE, i);
    return (INVALID_HANDLE_VALUE != penum) ? penum : NULL;
}

BOOL MatchItem(IEnumIDList *penum, LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    BOOL bMatch = FALSE;

    // this is somewhat imprecise as we will match on the first IDList in the
    // enumerator. but generally that is the desired behavior for the special
    // items that include multiple implied items
    LPITEMIDLIST pidlFirst;
    if (S_OK == FirstIDList(penum, &pidlFirst))
    {
        bMatch = pidl && ILIsEqual(pidl, pidlFirst);

        if (!bMatch && pszPath)
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidlFirst, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
            {
                bMatch = (0 == StrCmpI(pszPath, szPath));
            }
        }
        ILFree(pidlFirst);
    }

    return bMatch;
}

// searches namespace comboboxex for the indicated item
// returns:
//      index of item, CB_ERR (-1) if not found

INT_PTR CFindFilesDlg::_FindNamespace(LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    for (INT_PTR i = 0, cnt = SendDlgItemMessage(IDC_NAMESPACE, CB_GETCOUNT, 0, 0); i < cnt; i++)
    {
        IEnumIDList *penum = _GetItems(i);
        if (penum)
        {
            if (MatchItem(penum, pszPath, pidl))
                return i;
        }
    }
    // fall back to finding by display name in the combo
    if (pszPath)
        return SendDlgItemMessage(IDC_NAMESPACE, CB_FINDSTRINGEXACT, -1, (LPARAM)pszPath);
    return CB_ERR;
}

//  Invokes UI to select a namespace.
//
//  Returns:
//  S_OK if the user has selected a valid item and the pszNamespace contains
//  a valid shell folder display name.
//  E_ABORT if the user canceled his search
//  E_FAIL if an error occurred

HRESULT CFindFilesDlg::_BrowseForNamespace(LPTSTR pszName, UINT cchName, LPITEMIDLIST *ppidlRet)
{
    *pszName = 0;

    TCHAR szTitle[128];
    LoadString(HINST_THISDLL, IDS_SNS_BROWSERFORDIR_TITLE, szTitle, ARRAYSIZE(szTitle));

    BROWSEINFO bi = {0};

    bi.hwndOwner = m_hWnd;
    bi.lpszTitle = szTitle;
    bi.ulFlags   = BIF_USENEWUI | BIF_EDITBOX; // | BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
    bi.lpfn      = _BrowseCallback;
    bi.lParam    = (LPARAM)this;

    HRESULT hr;
    *ppidlRet = SHBrowseForFolder(&bi);
    if (*ppidlRet)
    {
        SHGetNameAndFlags(*ppidlRet, SHGDN_NORMAL, pszName, cchName, NULL);
        hr = S_OK;
    }
    else
    {
        hr = E_ABORT;
    }
    return hr;
}

//  Invokes SHBrowserForFolder UI and assigns results.
void CFindFilesDlg::_BrowseAndAssignNamespace()
{
    TCHAR szName[MAX_PATH];
    LPITEMIDLIST pidl;
    if (SUCCEEDED(_BrowseForNamespace(szName, ARRAYSIZE(szName), &pidl)))
    {
        AssignNamespace(NULL, pidl, szName, FALSE);
        ILFree(pidl);
    }
    else
    {
        SendDlgItemMessage(IDC_NAMESPACE, CB_SETCURSEL, _iCurNamespace, 0);
    }
}

BOOL CFindFilesDlg::_IsSearchableFolder(LPCITEMIDLIST pidlFolder)
{
    return TRUE;
}

int CFindFilesDlg::_BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    CFindFilesDlg *pThis = (CFindFilesDlg *)lpData;
    switch (msg)
    {
    case BFFM_INITIALIZED:  // initializing: set default selection to drives if we can
        {
            LPITEMIDLIST pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_DRIVES, TRUE);
            if (pidlDefault)
            {
                if (!::SendMessage(hwnd, BFFM_SETSELECTION, FALSE, (LPARAM)pidlDefault)) // if we fail to default to drives, default to desktop
                {
                    ILFree(pidlDefault);
                    pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, TRUE);
                    ::SendMessage(hwnd, BFFM_SETSELECTION, FALSE, (LPARAM)pidlDefault);
                }
                ILFree(pidlDefault);
                
            }
        }
        break;

    case BFFM_SELCHANGED:   // prevent non-searchable folder pidls from being selected.
        {
            BOOL bAllow = pThis->_IsSearchableFolder((LPCITEMIDLIST)lParam);
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bAllow);
        }
        break;
    }

    return 0;
}


class CSearchWarningDlg
{
private:    
    CSearchWarningDlg() : _hwnd(NULL), _bNoWarn(FALSE) {}
    static BOOL_PTR WINAPI DlgProc(HWND, UINT, WPARAM, LPARAM);

    HWND    _hwnd;
    BOOL    _bNoWarn;

    friend int CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgT, BOOL* pbNoWarn);
};


int CSearchWarningDlg_DoModal(HWND hwndParent, USHORT uDlgTemplate, BOOL* pbNoWarn)
{
    ASSERT(pbNoWarn);

    CSearchWarningDlg dlg;
    dlg._bNoWarn = *pbNoWarn;
    int nRet = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(uDlgTemplate),
                                    hwndParent, CSearchWarningDlg::DlgProc, (LPARAM)&dlg);    
    *pbNoWarn = dlg._bNoWarn;
    return nRet;
}

BOOL_PTR WINAPI CSearchWarningDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSearchWarningDlg* pdlg = (CSearchWarningDlg*)GetWindowPtr(hwnd, GWLP_USERDATA);

    if (WM_INITDIALOG == uMsg)
    {
        pdlg = (CSearchWarningDlg*)lParam;
        pdlg->_hwnd = hwnd;
        SetWindowPtr(hwnd, GWLP_USERDATA, pdlg);

        CheckDlgButton(hwnd, IDC_NOSCOPEWARNING, pdlg->_bNoWarn);
        MessageBeep(MB_ICONASTERISK);
        return TRUE;
    }

    if (pdlg)
    {
        switch (uMsg)
        {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDOK:
            case IDCANCEL:
                pdlg->_bNoWarn = IsDlgButtonChecked(hwnd, IDC_NOSCOPEWARNING);
                EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                break;
            }
            return TRUE;
        }
    }
    return FALSE;
}


class CCISettingsDlg
{
public:
    CCISettingsDlg() : _hwnd(NULL), _fCiIndexed(FALSE), _fCiRunning(FALSE), _fCiPermission(FALSE), _hProcessMMC(INVALID_HANDLE_VALUE)
    {
    }

    ~CCISettingsDlg()   
    {
        if (_hProcessMMC != INVALID_HANDLE_VALUE)
            CloseHandle(_hProcessMMC);
    }

    static int  DoModal(HWND hwndParent);
    static HWND CreateModeless(HWND hwndParent);


protected:
    BOOL OnInitDialog();
    BOOL OnOK();

private:    
    static BOOL_PTR WINAPI DlgProc(HWND, UINT, WPARAM, LPARAM);

    void ShowAdvanced();

    HWND    _hwnd;
    BOOL    _fCiIndexed,
            _fCiRunning,
            _fCiPermission;
    HANDLE  _hProcessMMC;

    friend int  CCISettingsDlg_DoModal(HWND hwndParent);
};


int CCISettingsDlg_DoModal(HWND hwndParent)
{
    CCISettingsDlg dlg;
    return (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_INDEXSERVER),
                           hwndParent, CCISettingsDlg::DlgProc, (LPARAM)&dlg);    
}

BOOL_PTR WINAPI CCISettingsDlg::DlgProc(HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CCISettingsDlg* pdlg = (CCISettingsDlg*)GetWindowPtr(hDlg, GWLP_USERDATA);

    if (WM_INITDIALOG == nMsg)
    {
        pdlg = (CCISettingsDlg*)lParam;
        pdlg->_hwnd = hDlg;
        SetWindowPtr(hDlg, GWLP_USERDATA, pdlg);
        return pdlg->OnInitDialog();
    }

    if (pdlg)
    {
        switch (nMsg)
        {
        case WM_NCDESTROY:
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_CI_ADVANCED:
                pdlg->ShowAdvanced();
                break;

            case IDOK:
                if (pdlg->OnOK())
                    EndDialog(hDlg, IDOK);
                break;

            case IDCANCEL:
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                break;

            case IDC_CI_HELP:
                _IndexServiceHelp(hDlg);
                break;
            }
            return TRUE;
        }
    }
    return FALSE;
}

void CCISettingsDlg::ShowAdvanced()
{
    //  have we already spawned MMC?
    if (_hProcessMMC != INVALID_HANDLE_VALUE)
    {
        if (WaitForSingleObject(_hProcessMMC, 0) != WAIT_OBJECT_0)
        {
            //  MMC is still running, let user ATL+TAB or something but don't launch a second copy
            return;     
        }
        _hProcessMMC = INVALID_HANDLE_VALUE;
    }

    TCHAR szProgram[MAX_PATH];
    DWORD dwRet = GetSystemDirectory(szProgram, ARRAYSIZE(szProgram));
    HRESULT hr = E_FAIL;

    if (dwRet == 0 || dwRet >= ARRAYSIZE(szProgram))
    {
        hr = StringCchCopy(szProgram, ARRAYSIZE(szProgram), TEXT("ciadv.msc"));
    }
    else
    {
        if (PathAppend(szProgram, TEXT("ciadv.msc")))
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        SHELLEXECUTEINFO sei = { sizeof(sei) };

        sei.fMask = SEE_MASK_NOCLOSEPROCESS;
        sei.nShow = SW_SHOWNORMAL;
        sei.lpFile = szProgram;
        sei.lpParameters = TEXT("computername=localmachine");

        if (ShellExecuteEx(&sei))
        {
            _hProcessMMC = sei.hProcess;
        }
    }
}

BOOL CCISettingsDlg::OnInitDialog() 
{ 
    TCHAR szStatusFmt[128], szStatusText[MAX_PATH];
    UINT nStatusText = IDS_FSEARCH_CI_DISABLED;

    GetCIStatus(&_fCiRunning, &_fCiIndexed, &_fCiPermission);
    
    if (_fCiRunning)
    {
        if (_fCiPermission)
            //  permission to distinguish between ready, busy.
            nStatusText = _fCiIndexed ? IDS_FSEARCH_CI_READY : IDS_FSEARCH_CI_BUSY;
        else
            //  no permission to distinguish between ready, busy; just say it's enabled.
            nStatusText = IDS_FSEARCH_CI_ENABLED;
    }

    if (LoadString(HINST_THISDLL, IDS_FSEARCH_CI_STATUSFMT, szStatusFmt, ARRAYSIZE(szStatusFmt)))
    {
        if (LoadString(HINST_THISDLL, nStatusText, szStatusText, ARRAYSIZE(szStatusText)))
        {
            TCHAR szStatus[MAX_PATH];

            StringCchPrintf(szStatus, ARRAYSIZE(szStatus), szStatusFmt, szStatusText);  // ok to truncate - for display only
            SetDlgItemText(_hwnd, IDC_CI_STATUS, szStatus);
        }
    }

    CheckDlgButton(_hwnd, IDC_ENABLE_CI,   _fCiRunning);
    CheckDlgButton(_hwnd, IDC_BLOWOFF_CI, !_fCiRunning);

    EnableWindow(GetDlgItem(_hwnd, IDC_CI_PROMPT),  _fCiPermission);
    EnableWindow(GetDlgItem(_hwnd, IDC_ENABLE_CI),   _fCiPermission);
    EnableWindow(GetDlgItem(_hwnd, IDC_BLOWOFF_CI),  _fCiPermission);

    return TRUE; 
}

BOOL CCISettingsDlg::OnOK()
{
    StartStopCI(IsDlgButtonChecked(_hwnd, IDC_ENABLE_CI) ? TRUE : FALSE);
    return TRUE;
}

#ifdef __PSEARCH_BANDDLG__

//  CFindPrintersDlg impl

#define PSEARCHDLG_TABFIRST   IDC_PSEARCH_NAME
#define PSEARCHDLG_TABLAST    IDC_SEARCHLINK_INTERNET
#define PSEARCHDLG_RIGHTMOST   IDC_SEARCH_START
#define PSEARCHDLG_BOTTOMMOST  IDC_SEARCHLINK_INTERNET


CFindPrintersDlg::CFindPrintersDlg(CFileSearchBand* pfsb)
    :   CBandDlg(pfsb)
{
}

CFindPrintersDlg::~CFindPrintersDlg()
{

}

LRESULT CFindPrintersDlg::OnInitDialog(UINT, WPARAM, LPARAM, BOOL&)
{
    _Attach(m_hWnd);
    ASSERT(Hwnd());

    CMetrics&   metrics = _pfsb->GetMetrics();
    _pfsb->GetMetrics().Init(m_hWnd);

    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_PRINTERS);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_PSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    OnWinIniChange();
    LayoutControls(-1, -1);

    return TRUE;
}

void CFindPrintersDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }

    CBandDlg::LayoutControls(cx, cy);
    CMetrics& metrics = _pfsb->GetMetrics();

    const UINT nIDCtl[] = {
        IDC_PSEARCH_NAME,
        IDC_PSEARCH_LOCATION,
        IDC_PSEARCH_MODEL,
    };
    RECT rcCtl[ARRAYSIZE(nIDCtl)];
    
    //  Stretch edit boxes to fit horz
    for (int i = 0; i< ARRAYSIZE(nIDCtl); i++)
    {
        HWND hwndCtl = GetDlgItem(nIDCtl[i]);
        if (hwndCtl && ::GetWindowRect(hwndCtl, &rcCtl[i]))
        {
            ::MapWindowRect(NULL, Hwnd(), &rcCtl[i]);
            rcCtl[i].right = cx - metrics.CtlMarginX();
            ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                          RECTWIDTH(*(rcCtl+i)), RECTHEIGHT(*(rcCtl+i)),
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
        else
            SetRectEmpty(rcCtl + i);    
    }

    //  Position the 'Search for Other Items' caption, divider and link windows
    const int rgLinks[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        -IDC_FSEARCH_DIV3,
        IDC_SEARCHLINK_INTERNET,
    };

    RECT rc;
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.bottom += metrics.LooseMarginY();

    _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, TRUE,
                        metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                        rc.bottom, rgLinks, ARRAYSIZE(rgLinks));
}


BOOL CFindPrintersDlg::Validate()
{
    return TRUE;
}


void CFindPrintersDlg::Clear()
{
    SetDlgItemText(IDC_PSEARCH_NAME, NULL);
    SetDlgItemText(IDC_PSEARCH_LOCATION, NULL);
    SetDlgItemText(IDC_PSEARCH_MODEL, NULL);
}


BOOL CFindPrintersDlg::GetMinSize(HWND hwndOC, SIZE *pSize) const
{
    RECT rcRightmost, rcBottommost;
    HWND hwndRightmost = GetDlgItem(PSEARCHDLG_RIGHTMOST), 
         hwndBottommost= GetDlgItem(PSEARCHDLG_BOTTOMMOST);
    
    ASSERT(::IsWindow(hwndRightmost));
    ASSERT(::IsWindow(hwndBottommost));

    ::GetWindowRect(hwndRightmost, &rcRightmost);
    ::MapWindowRect(NULL, m_hWnd, &rcRightmost);

    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, m_hWnd, &rcBottommost);

    pSize->cx = rcRightmost.right;
    pSize->cy = rcBottommost.bottom + _pfsb->GetMetrics().TightMarginY();

    return TRUE;
}

HWND CFindPrintersDlg::GetFirstTabItem() const
{
    return GetDlgItem(PSEARCHDLG_TABFIRST);
}

HWND CFindPrintersDlg::GetLastTabItem() const
{
    return GetDlgItem(PSEARCHDLG_TABLAST);
}

STDMETHODIMP CFindPrintersDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CBandDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}

void CFindPrintersDlg::OnWinIniChange()
{
    _BeautifyCaption(IDC_PSEARCH_CAPTION, IDC_PSEARCH_ICON, IDI_PSEARCH);
}

LRESULT CFindPrintersDlg::OnSearchStartBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    WCHAR wszName[MAX_PATH],
          wszLocation[MAX_PATH],
          wszModel[MAX_PATH];

    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_NAME, wszName, ARRAYSIZE(wszName));
    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_LOCATION, wszLocation, ARRAYSIZE(wszLocation));
    ::GetDlgItemTextW(m_hWnd, IDC_PSEARCH_MODEL, wszModel, ARRAYSIZE(wszModel));

    ASSERT(_pfsb);
    ASSERT(_pfsb->BandSite());

    IShellDispatch2* psd2;
    if (SUCCEEDED(CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                     IID_PPV_ARG(IShellDispatch2, &psd2))))
    {
        BSTR bstrName     = *wszName ? SysAllocString(wszName) : NULL,
             bstrLocation = *wszLocation ? SysAllocString(wszLocation) : NULL, 
             bstrModel    = *wszModel ? SysAllocString(wszModel) : NULL;

        if (FAILED(psd2->FindPrinter(bstrName, bstrLocation, bstrModel)))
        {
            SysFreeString(bstrName);
            SysFreeString(bstrLocation);
            SysFreeString(bstrModel);
        }
        
        psd2->Release();
    }
    
    return 0;
}
#endif __PSEARCH_BANDDLG__



//  CFindComputersDlg impl

#define CSEARCHDLG_TABFIRST   IDC_CSEARCH_NAME
#define CSEARCHDLG_TABLAST    IDC_SEARCHLINK_INTERNET
#define CSEARCHDLG_RIGHTMOST   IDC_SEARCH_STOP
#define CSEARCHDLG_BOTTOMMOST  IDC_SEARCHLINK_INTERNET


CFindComputersDlg::CFindComputersDlg(CFileSearchBand* pfsb)
    :   CSearchCmdDlg(pfsb),
        _pacComputerName(NULL),
        _pmruComputerName(NULL)
{

}


CFindComputersDlg::~CFindComputersDlg()
{
    ATOMICRELEASE(_pacComputerName);
    ATOMICRELEASE(_pmruComputerName);
}


LRESULT CFindComputersDlg::OnInitDialog(UINT, WPARAM, LPARAM, BOOL&)
{
    _Attach(m_hWnd);
    ASSERT(Hwnd());

    CMetrics&   metrics = _pfsb->GetMetrics();
    _pfsb->GetMetrics().Init(m_hWnd);

    //  Register specialty window classes.
    DivWindow_RegisterClass();

    POINT pt;
    pt.x = metrics.CtlMarginX();
    pt.y = 0;
    _CreateSearchLinks(m_hWnd, pt, IDC_SEARCHLINK_COMPUTERS);
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV1, pt, 2, GetDlgItem(IDC_CSEARCH_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV2, pt, 1, GetDlgItem(IDC_SEARCHLINK_CAPTION));
    _CreateDivider(m_hWnd, IDC_FSEARCH_DIV3, pt, 1, GetDlgItem(IDC_SEARCHLINK_PEOPLE));

    _InitializeMru(GetDlgItem(IDC_CSEARCH_NAME), &_pacComputerName, 
                    TEXT("ComputerNameMRU"), &_pmruComputerName);
    SendDlgItemMessage(IDC_CSEARCH_NAME, EM_LIMITTEXT, MAX_PATH, 0);

    OnWinIniChange();
    LayoutControls(-1, -1);

    return TRUE;
}

LRESULT CFindComputersDlg::OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
{
    StopSearch();
    if (_pSrchCmd)
    {
        DisconnectEvents();
        IUnknown_SetSite(_pSrchCmd, NULL);
    }
    bHandled = FALSE;
    _fOnDestroy = TRUE;
    return 0;
}



void CFindComputersDlg::LayoutControls(int cx, int cy)
{
    if (cx < 0 || cy < 0)
    {
        RECT rc;
        GetClientRect(&rc);
        cx = RECTWIDTH(rc);
        cy = RECTHEIGHT(rc);
    }
    CBandDlg::LayoutControls(cx, cy);

    const UINT nIDCtl[] = {
        IDC_CSEARCH_NAME,
    };
    RECT rcCtl[ARRAYSIZE(nIDCtl)];

    CMetrics& metrics = _pfsb->GetMetrics();
    for (int i = 0; i< ARRAYSIZE(nIDCtl); i++)
    {
        HWND hwndCtl = GetDlgItem(nIDCtl[i]);
        if (hwndCtl && ::GetWindowRect(hwndCtl, &rcCtl[i]))
        {
            ::MapWindowRect(NULL, m_hWnd, &rcCtl[i]);
            rcCtl[i].right = cx - metrics.CtlMarginX();
            ::SetWindowPos(hwndCtl, NULL, 0, 0, 
                          RECTWIDTH(*(rcCtl+i)), RECTHEIGHT(*(rcCtl+i)),
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
        else
            SetRectEmpty(rcCtl + i);    
    }

    //  Position the 'Search for Other Items' caption, divider and link windows

    const int rgLinks[] = {
        IDC_SEARCHLINK_FILES,
        IDC_SEARCHLINK_COMPUTERS,
        IDC_SEARCHLINK_PRINTERS,
        IDC_SEARCHLINK_PEOPLE,
        -IDC_FSEARCH_DIV3,
        IDC_SEARCHLINK_INTERNET,
    };

    RECT rc;
    ::GetWindowRect(GetDlgItem(IDC_SEARCH_START), &rc);
    ::MapWindowRect(NULL, m_hWnd, &rc);
    rc.bottom += metrics.LooseMarginY();

    _LayoutSearchLinks(IDC_SEARCHLINK_CAPTION, IDC_FSEARCH_DIV2, TRUE,
                        metrics.CtlMarginX(), cx - metrics.CtlMarginX(), metrics.TightMarginY(),
                        rc.bottom, rgLinks, ARRAYSIZE(rgLinks));
}

BOOL CFindComputersDlg::Validate()
{
    return TRUE;
}

STDMETHODIMP CFindComputersDlg::AddConstraints(ISearchCommandExt* pSrchCmd)
{
    HRESULT hr = E_FAIL;
    TCHAR   szName[MAX_PATH];
    if (::GetDlgItemText(m_hWnd, IDC_CSEARCH_NAME, szName, ARRAYSIZE(szName)) <= 0)
    {
        StringCchCopy(szName, ARRAYSIZE(szName), TEXT("*"));    // should always fit
    }

    VARIANT var;
    hr = InitVariantFromStr(&var, szName);
    if (SUCCEEDED(hr))
    {
        hr = _AddConstraint(pSrchCmd, L"SearchFor", &var);
        if (SUCCEEDED(hr))
            _AddMruStringFromWindow(_pmruComputerName, GetDlgItem(IDC_CSEARCH_NAME));
        VariantClear(&var);
    }

    return hr;
}


void CFindComputersDlg::UpdateStatusText()
{
    CSearchCmdDlg::UpdateStatusText();
}


void CFindComputersDlg::RestoreSearch()
{
    CSearchCmdDlg::RestoreSearch();
}


void CFindComputersDlg::Clear()
{
    CSearchCmdDlg::Clear();
    SetDlgItemText(IDC_CSEARCH_NAME, NULL);
}


BOOL CFindComputersDlg::GetMinSize(HWND hwndOC, SIZE *pSize) const
{
    RECT rcRightmost, rcBottommost;
    HWND hwndRightmost = GetDlgItem(CSEARCHDLG_RIGHTMOST), 
         hwndBottommost= GetDlgItem(CSEARCHDLG_BOTTOMMOST);
    
    ASSERT(::IsWindow(hwndRightmost));
    ASSERT(::IsWindow(hwndBottommost));

    ::GetWindowRect(hwndRightmost, &rcRightmost);
    ::MapWindowRect(NULL, m_hWnd, &rcRightmost);

    ::GetWindowRect(hwndBottommost, &rcBottommost);
    ::MapWindowRect(NULL, m_hWnd, &rcBottommost);

    pSize->cx = rcRightmost.right;
    pSize->cy = rcBottommost.bottom + _pfsb->GetMetrics().TightMarginY();

    return TRUE;
}

void CFindComputersDlg::NavigateToResults(IWebBrowser2* pwb2)
{
    BSTR bstrUrl = SysAllocString(L"::{1f4de370-d627-11d1-ba4f-00a0c91eedba}");// CLSID_ComputerFindFolder
    if (bstrUrl)
    {
        VARIANT varNil = {0};
        pwb2->Navigate(bstrUrl, &varNil, &varNil, &varNil, &varNil);
        SysFreeString(bstrUrl);
    }
}

HWND CFindComputersDlg::GetFirstTabItem() const
{
    return GetDlgItem(CSEARCHDLG_TABFIRST);
}

HWND CFindComputersDlg::GetLastTabItem() const
{
    return GetDlgItem(CSEARCHDLG_TABLAST);
}

BOOL CFindComputersDlg::GetAutoCompleteObjectForWindow(HWND hwnd, IAutoComplete2** ppac2)
{
    if (hwnd == GetDlgItem(IDC_CSEARCH_NAME))
    {
        *ppac2 = _pacComputerName;
        (*ppac2)->AddRef();
        return TRUE;
    }
    return CBandDlg::GetAutoCompleteObjectForWindow(hwnd, ppac2);
}

STDMETHODIMP CFindComputersDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CSearchCmdDlg::TranslateAccelerator(pmsg))
        return S_OK;

    //  Handle it ourselves...
    return _pfsb->IsDlgMessage(m_hWnd, pmsg);
}


void CFindComputersDlg::OnWinIniChange()
{
    //  redisplay animated icon
    HWND hwndIcon = GetDlgItem(IDC_CSEARCH_ICON);
    Animate_Close(hwndIcon);
    Animate_OpenEx(hwndIcon, HINST_THISDLL, MAKEINTRESOURCE(IDA_FINDCOMP));

    _BeautifyCaption(IDC_CSEARCH_CAPTION);
}


LRESULT CFindComputersDlg::OnSearchStartBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    if (SUCCEEDED(StartSearch()))
    {
        EnableStartStopButton(hwndCtl, FALSE);
        StartStopAnimation(TRUE);
    }
    return 0;
}


LRESULT CFindComputersDlg::OnSearchStopBtn(WORD nCode, WORD nID, HWND hwndCtl, BOOL&)
{
    StopSearch();
    return 0;
}

HWND CFindComputersDlg::ShowHelp(HWND hwnd)
{
    return ::HtmlHelp(hwnd, TEXT("find.chm"), HH_DISPLAY_TOPIC, 0);
}

//  CSearchCmdDlg object wrap and event sink

CSearchCmdDlg::CSearchCmdDlg(CFileSearchBand* pfsb)
    :   CBandDlg(pfsb),
        _pSrchCmd(NULL), 
        _pcp(NULL), 
        _dwConnection(0)
{
    ASSERT(pfsb);
}

CSearchCmdDlg::~CSearchCmdDlg()
{ 
    DisconnectEvents(); 
    if (_pSrchCmd)
    {
        _pSrchCmd->Release();
        _pSrchCmd = NULL;
    }
}


ISearchCommandExt* CSearchCmdDlg::GetSearchCmd()
{
    if (_fOnDestroy)
        return NULL;
        
    ASSERT(_pfsb->BandSite() != NULL);

    //  Instantiate docfind command object
    if (NULL == _pSrchCmd)
    {
        ASSERT(0 == _dwConnection);

        if (SUCCEEDED(CoCreateInstance(CLSID_DocFindCommand, NULL, CLSCTX_INPROC_SERVER,
                                      IID_PPV_ARG(ISearchCommandExt, &_pSrchCmd))))
        {
            // Assign search type.
            _pSrchCmd->SearchFor(GetSearchType());

            // cmd object needs site to get to browser
            IUnknown_SetSite(_pSrchCmd, _pfsb->BandSite());

            // Connect events.
            ConnectToConnectionPoint(SAFECAST(this, DSearchCommandEvents*), DIID_DSearchCommandEvents,
                                      TRUE, _pSrchCmd, &_dwConnection, &_pcp);
        }
    }
    return _pSrchCmd;
}

HRESULT CSearchCmdDlg::DisconnectEvents()
{
    HRESULT hr = S_FALSE;
    if (_pcp)
    {
        _pcp->Unadvise(_dwConnection);
        _pcp->Release();
        _pcp = NULL;
        _dwConnection = 0;
        hr = S_OK;
    }
    return hr;
}

HRESULT CSearchCmdDlg::StartSearch()
{
    HRESULT hr = E_INVALIDARG;
    if (Validate())     //  Validate input
    {
        ISearchCommandExt* pSrchCmd = GetSearchCmd();
        if (pSrchCmd)
        {
            pSrchCmd->ClearResults();   //  Clear off current results
            hr = AddConstraints(pSrchCmd);
            if (SUCCEEDED(hr))
                hr = Execute(TRUE);
        }
    }
    return hr;
}

void CSearchCmdDlg::StartStopAnimation(BOOL bStart)
{
    HWND hwndAnimate = GetAnimation();
    if (IsWindow(hwndAnimate))
    {
        if (bStart)
            Animate_Play(hwndAnimate, 0, -1, -1);
        else
            Animate_Stop(hwndAnimate);
    }
}


//  WMU_RESTORESEARCH handler
LRESULT CSearchCmdDlg::OnRestoreSearch(UINT, WPARAM, LPARAM, BOOL&)
{
    //  We've posted ourselves this message in response to the event 
    //  dispatch because we want to do our restoration on the
    //  band's primary thread rather than the OLE dispatch thread.   
    //  To do the work on the dispatch thread results in a premature 
    //  abort of the search restoration processing as the dispatch
    //  thread terminates.
    RestoreSearch();
    return 0;
}


void CSearchCmdDlg::Clear()
{
    StopSearch();
    
    ISearchCommandExt *pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
        pSrchCmd->ClearResults();
}


HRESULT CSearchCmdDlg::Execute(BOOL bStart)
{
    ASSERT(_pSrchCmd);
    
    VARIANT varRecordsAffected = {0}, varParams = {0};
    return _pSrchCmd->Execute(&varRecordsAffected, &varParams, bStart ? 1 : 0);
}


void CSearchCmdDlg::StopSearch()
{
    if (SearchInProgress())
        Execute(FALSE);
}


HRESULT CSearchCmdDlg::SetQueryFile(IN VARIANT* pvarFile)
{
    HRESULT hr = CBandDlg::SetQueryFile(pvarFile);
    if (S_OK == hr)
    {
        ISearchCommandExt* pSrchCmd = GetSearchCmd();
        if (pSrchCmd)
            hr = pSrchCmd->RestoreSavedSearch(pvarFile);
        else
            hr = E_FAIL;
    }
    return hr;
}


void CSearchCmdDlg::UpdateSearchCmdStateUI(DISPID eventID)
{
    if (_fOnDestroy)
        return;
        
    BOOL bStopEvent = (DISPID_SEARCHCOMMAND_COMPLETE == eventID || 
                       DISPID_SEARCHCOMMAND_ERROR == eventID ||
                       DISPID_SEARCHCOMMAND_ABORT == eventID),
         bStartEvent = DISPID_SEARCHCOMMAND_START == eventID;
    
    HWND hwndStart = GetDlgItem(Hwnd(), IDC_SEARCH_START),
         hwndStop  = GetDlgItem(Hwnd(), IDC_SEARCH_STOP);

    if (IsWindow(hwndStart))
    {
        EnableStartStopButton(hwndStart, !SearchInProgress());
        if (bStopEvent && IsChild(Hwnd(), GetFocus()))
        {
            _pfsb->AutoActivate();
            SetFocus(hwndStart);
        }
    }

    if (IsWindow(hwndStop))
    {
        EnableStartStopButton(hwndStop, SearchInProgress());
        if (bStartEvent)
        {
            _pfsb->AutoActivate();
            SetFocus(hwndStop);
        }
    }

    if (bStopEvent || !SearchInProgress())
        StartStopAnimation(FALSE);
}


void CSearchCmdDlg::EnableStartStopButton(HWND hwndBtn, BOOL bEnable)
{
    if (IsWindow(hwndBtn))
    {
        if (bEnable)
            _ModifyWindowStyle(hwndBtn, BS_DEFPUSHBUTTON, 0);
        else
            _ModifyWindowStyle(hwndBtn, 0, BS_DEFPUSHBUTTON);

        ::EnableWindow(hwndBtn, bEnable);
    }
}


//  Extracts error information from ISearchCommandExt and 
//  propagate 
BOOL CSearchCmdDlg::ProcessCmdError()
{
    BOOL bRet = FALSE;
    
    ISearchCommandExt* pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
    {
        HRESULT hr = S_OK;
        BSTR bstrError = NULL;

        //  request error information through ISearchCommandExt
        if (SUCCEEDED(pSrchCmd->GetErrorInfo(&bstrError,  (int *)&hr)))
            //  allow derivatives classes a crack at handling the error
            bRet = OnSearchCmdError(hr, bstrError ? bstrError : NULL);
    }
    return bRet;
}


BOOL CSearchCmdDlg::OnSearchCmdError(HRESULT hr, LPCTSTR pszError)
{
    if (pszError)
    {
        ShellMessageBox(HINST_THISDLL, _pfsb->m_hWnd, pszError, NULL,
                         MB_OK | MB_ICONASTERISK);
        return TRUE;
    }
    return FALSE;
}


void CSearchCmdDlg::UpdateStatusText()
{
    if (_fOnDestroy)
        return;
        
    ASSERT(_pfsb && _pfsb->BandSite());

    ISearchCommandExt* pSrchCmd = GetSearchCmd();
    if (pSrchCmd)
    {
        BSTR bstrStatus;
        if (SUCCEEDED(pSrchCmd->get_ProgressText(&bstrStatus)))
        {
            IWebBrowserApp* pwba;
            if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(_pfsb->BandSite(), IID_PPV_ARG(IWebBrowserApp, &pwba))))
            {
                pwba->put_StatusText(bstrStatus);
                pwba->Release();
            }
            if (bstrStatus)
                SysFreeString(bstrStatus);
        }
    }
}


void CSearchCmdDlg::OnBandShow(BOOL bShow) 
{ 
    if (!bShow) 
        StopSearch() ;
}


STDMETHODIMP CSearchCmdDlg::TranslateAccelerator(MSG *pmsg)
{
    if (S_OK == CBandDlg::TranslateAccelerator(pmsg))
        return S_OK;

    if (WM_KEYDOWN == pmsg->message &&
        VK_ESCAPE == pmsg->wParam && 
        SearchInProgress() &&
        0 == (GetKeyState(VK_CONTROL) & 0x8000))
    {
        StopSearch();
    }
    return S_FALSE;
}

STDMETHODIMP CSearchCmdDlg::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CSearchCmdDlg, IDispatch, DSearchCommandEvents),
        QITABENTMULTI2(CSearchCmdDlg, DIID_DSearchCommandEvents, DSearchCommandEvents),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearchCmdDlg::AddRef()
{
    return ((IFileSearchBand*)_pfsb)->AddRef(); 
}

STDMETHODIMP_(ULONG) CSearchCmdDlg::Release()
{
    return ((IFileSearchBand*)_pfsb)->Release(); 
}

// IDispatch
STDMETHODIMP CSearchCmdDlg::Invoke(DISPID dispid, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
{
    switch (dispid)
    {
    case DISPID_SEARCHCOMMAND_COMPLETE:
    case DISPID_SEARCHCOMMAND_ABORT:
    case DISPID_SEARCHCOMMAND_ERROR:
    case DISPID_SEARCHCOMMAND_START:
        _fSearchInProgress = (DISPID_SEARCHCOMMAND_START == dispid);
        _fSearchAborted =    (DISPID_SEARCHCOMMAND_ABORT == dispid);
        UpdateSearchCmdStateUI(dispid);
        if (DISPID_SEARCHCOMMAND_ERROR == dispid)
            ProcessCmdError();    
        break;

    case DISPID_SEARCHCOMMAND_PROGRESSTEXT:
        UpdateStatusText();
        break;

    case DISPID_SEARCHCOMMAND_RESTORE:
        PostMessage(Hwnd(), WMU_RESTORESEARCH, 0, 0); 
        //  See comments in the CSearchCmdDlg::OnRestoreSearch message handler.
        break;
    }
    return S_OK;
}

class CDivWindow
{
    //  All private members:
    CDivWindow();
    ~CDivWindow();
    
    static LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT     EraseBkgnd(HDC hdc);
    LRESULT     WindowPosChanging(WINDOWPOS* pwp);
    LRESULT     SetHeight(LONG cy);
    LRESULT     SetBkColor(COLORREF rgb);


    static ATOM _atom;     // window class atom
    HWND        _hwnd;
    LONG        _cy;       // enforced height.
    COLORREF    _rgbBkgnd; // background color
    HBRUSH      _hbrBkgnd; // background brush

    friend void WINAPI DivWindow_RegisterClass();
};

void DivWindow_RegisterClass()
{
    WNDCLASSEX wc = {0};
    
    wc.cbSize         = sizeof(wc);
    wc.style          = CS_GLOBALCLASS;
    wc.lpfnWndProc    = CDivWindow::WndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName  = DIVWINDOW_CLASS;

    RegisterClassEx(&wc);
}

inline CDivWindow::CDivWindow() : _hwnd(NULL), _cy(1), _hbrBkgnd(NULL), _rgbBkgnd(COLOR_BTNFACE)
{
}
        

inline CDivWindow::~CDivWindow()
{
    if (_hbrBkgnd)
        DeleteObject(_hbrBkgnd);
}


LRESULT CDivWindow::EraseBkgnd(HDC hdc)
{
    if (!_hbrBkgnd)
        return DefWindowProc(_hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);

    RECT rc;
    GetClientRect(_hwnd, &rc);
    FillRect(hdc, &rc, _hbrBkgnd);
    return TRUE;
}


LRESULT CDivWindow::WindowPosChanging(WINDOWPOS* pwp)
{
    //  enforce height
    if (0 == (pwp->flags & SWP_NOSIZE))
        pwp->cy = _cy;
    return 0;
}


LRESULT CDivWindow::SetHeight(LONG cy)
{
    _cy = cy;
    return TRUE;
}


LRESULT CDivWindow::SetBkColor(COLORREF rgb)
{
    if (rgb != _rgbBkgnd)
    {
        _rgbBkgnd = rgb;
        if (_hbrBkgnd)
            DeleteObject(_hbrBkgnd);
        _hbrBkgnd = CreateSolidBrush(_rgbBkgnd);
        InvalidateRect(_hwnd, NULL, TRUE);
    }
    return TRUE;
}


LRESULT WINAPI CDivWindow::WndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CDivWindow* pThis = (CDivWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (nMsg)
    {
        case WM_ERASEBKGND:
            return pThis->EraseBkgnd((HDC)wParam);

        case WM_WINDOWPOSCHANGING:
            return pThis->WindowPosChanging((WINDOWPOS*)lParam);

        case WM_GETDLGCODE:
            return DLGC_STATIC;

        case DWM_SETHEIGHT:
            return pThis->SetHeight((LONG)wParam);

        case DWM_SETBKCOLOR:
            return pThis->SetBkColor((COLORREF)wParam);

        case WM_NCCREATE:
            if (NULL == (pThis = new CDivWindow))
                return FALSE;
            pThis->_hwnd = hwnd;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            break;

        case WM_NCDESTROY:
        {
            LRESULT lRet = DefWindowProc(hwnd, nMsg, wParam, lParam);
            SetWindowPtr(hwnd, GWLP_USERDATA, 0);
            pThis->_hwnd = NULL;
            delete pThis;
            return lRet;
        }
    }
    return DefWindowProc(hwnd, nMsg, wParam, lParam);
}


// {C8F945CB-327A-4330-BB2F-C04122959488}
static const IID IID_IStringMru = 
    { 0xc8f945cb, 0x327a, 0x4330, { 0xbb, 0x2f, 0xc0, 0x41, 0x22, 0x95, 0x94, 0x88 } };


//  Creates and initializes a CStringMru instance
HRESULT CStringMru::CreateInstance(HKEY hKey, LPCTSTR szSubKey, LONG cMaxStrings, BOOL  bCaseSensitive, REFIID riid, void ** ppv)
{
    HRESULT hr;
    CStringMru* pmru = new CStringMru;
    if (NULL == pmru)
        return E_OUTOFMEMORY;

    pmru->_hKeyRoot = hKey;

    hr = StringCchCopy(pmru->_szSubKey, ARRAYSIZE(pmru->_szSubKey), szSubKey);
    if (SUCCEEDED(hr))
    {
        if (cMaxStrings > 0)
            pmru->_cMax = cMaxStrings;
        pmru->_bCaseSensitive = bCaseSensitive;

        hr = pmru->QueryInterface(riid, ppv);
    }
    pmru->Release();

    return hr;
}

CStringMru::CStringMru() : _cRef(1), _hKeyRoot(NULL), _hKey(NULL), 
        _hdpaStrings(NULL), _cMax(25), _bCaseSensitive(TRUE), _iString(-1)
{
    *_szSubKey = 0;
}

CStringMru::~CStringMru()
{
    _Close();
    _Clear();
}

//  Opens string MRU store
HRESULT CStringMru::_Open()
{
    if (_hKey)
        return S_OK;

    DWORD dwDisposition;
    DWORD dwErr = RegCreateKeyEx(_hKeyRoot, _szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE,
                                  NULL, &_hKey, &dwDisposition);
    return HRESULT_FROM_WIN32(dwErr);
}


//  Deletes string MRU store
void CStringMru::_Delete()
{
    if (_hKey)
        _Close();

    SHDeleteKey(_hKeyRoot, _szSubKey);
}

//  Reads string MRU store into memory
HRESULT CStringMru::_Read(OUT OPTIONAL LONG* pcRead)
{
    HRESULT hr = E_FAIL;
    if (pcRead)
        *pcRead = 0;

    if (SUCCEEDED((hr = _Open())))
    {
        _Clear();     // throw away existing cached strings
        _hdpaStrings = DPA_Create(4);  // allocate dynarray
        if (NULL == _hdpaStrings)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //  step through string values in registry.
            for (int iString = 0; iString < _cMax; iString++)
            {
                TCHAR szVal[16];
                TCHAR szString[MAX_URL_STRING];

                StringCchPrintf(szVal, ARRAYSIZE(szVal), TEXT("%03d"), iString);   // ok to truncate
                DWORD dwErr = SHRegGetString(_hKey, szVal, 0, szString, ARRAYSIZE(szString));
                if (dwErr == ERROR_SUCCESS && *szString)
                {
                    LPOLESTR pwszAdd;
                    if (SUCCEEDED(SHStrDup(szString, &pwszAdd)))
                    {
                        if (DPA_AppendPtr(_hdpaStrings, pwszAdd) == -1)
                        {
                            CoTaskMemFree(pwszAdd);
                        }
                    }
                }
            }
        }

        _Close();
        
        if (pcRead && _hdpaStrings)
            *pcRead = DPA_GetPtrCount(_hdpaStrings);
    }

    return hr;
}


//  Writes string MRU store from memory
HRESULT CStringMru::_Write(OUT OPTIONAL LONG* pcWritten)
{
    HRESULT hr = E_FAIL;
    LONG   cWritten = 0;
    
    if (pcWritten)
        *pcWritten = cWritten;

    //  Delete store and re-create.
    _Delete();
    if (NULL == _hdpaStrings)
        return S_FALSE;
    if (FAILED((hr = _Open())))
        return hr;

    ASSERT(DPA_GetPtrCount(_hdpaStrings) <= _cMax);

    //  step through string values in registry.
    for (int iString = 0, cnt = DPA_GetPtrCount(_hdpaStrings); 
         iString < cnt; iString++)
    {
        TCHAR szVal[16];
        TCHAR szString[MAX_URL_STRING];

        StringCchPrintf(szVal, ARRAYSIZE(szVal), TEXT("%03d"), iString);   // ok to truncate

        LPOLESTR pwszWrite = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, iString);
        SHUnicodeToTChar(pwszWrite, szString, ARRAYSIZE(szString));

        DWORD dwErr = RegSetValueEx(_hKey, szVal, 0, REG_SZ, 
                                     (LPBYTE)szString, sizeof(szString));

        if (ERROR_SUCCESS == dwErr)
            cWritten++;
    }

    _Close();

    if (pcWritten)
        *pcWritten = cWritten;

    return S_OK;
}


//  Closes string MRU store
void  CStringMru::_Close()
{
    if (_hKey)
    {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }
}

//  Adds a string to the store
STDMETHODIMP CStringMru::Add(LPCOLESTR pwszAdd)
{
    if (!(pwszAdd && *pwszAdd))
        return E_INVALIDARG;
    
    if (NULL == _hdpaStrings)
    {
        _hdpaStrings = DPA_Create(4);
        if (NULL == _hdpaStrings)
            return E_OUTOFMEMORY;
    }
        
    HRESULT hr = E_FAIL;
    LONG    iMatch = -1;

    for (LONG i = 0, cnt = DPA_GetPtrCount(_hdpaStrings); i < cnt; i++)
    {
        LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, i);
        if (pwsz)
        {
            int nCompare = _bCaseSensitive ? 
                    StrCmpW(pwszAdd, pwsz) : StrCmpIW(pwszAdd, pwsz);

            if (0 == nCompare)
            {
                iMatch = i;
                break;
            }       
        }
    }

    if (-1 == iMatch)
    {
        //  Create a copy and add it to the list.
        LPOLESTR pwszCopy;
        hr = SHStrDup(pwszAdd, &pwszCopy);
        if (SUCCEEDED(hr))
        {
            int iNew = DPA_InsertPtr(_hdpaStrings, 0, pwszCopy);
            if (iNew < 0)
            {
                CoTaskMemFree(pwszCopy);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = _Promote(iMatch);
    }

    if (S_OK == hr)
    {
        //  If we've grown too large, delete LRU string
        int cStrings = DPA_GetPtrCount(_hdpaStrings);
        while (cStrings > _cMax)
        {
            LPOLESTR pwsz = (LPOLESTR)DPA_DeletePtr(_hdpaStrings, cStrings - 1);
            CoTaskMemFree(pwsz);
            cStrings--;
        }
        hr = _Write();
    }

    return hr;
}


//  Promotes a string to MRU
HRESULT CStringMru::_Promote(LONG iString)
{
    if (0 == iString)
        return S_OK;

    LONG cnt = _hdpaStrings ? DPA_GetPtrCount(_hdpaStrings) : 0 ;
    
    if (iString >= cnt)
        return E_INVALIDARG;

    LPOLESTR pwsz = (LPOLESTR)DPA_DeletePtr(_hdpaStrings, iString);
    if (pwsz)
    {
        int iMru = DPA_InsertPtr(_hdpaStrings, 0, pwsz);

        if (iMru < 0)
        {
            CoTaskMemFree(pwsz);
            return E_OUTOFMEMORY;
        }
        else
        {
            ASSERT(0 == iMru);
            return S_OK;
        }
    }
    return E_FAIL;
}


//  Clears string MRU memory cache
void CStringMru::_Clear()
{
    if (_hdpaStrings)
    {
        for (int i = 0, cnt = DPA_GetPtrCount(_hdpaStrings); i < cnt; i++)
        {
            LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, i);
            CoTaskMemFree(pwsz);
        }
        DPA_Destroy(_hdpaStrings);
        _hdpaStrings = NULL;
    }
}

STDMETHODIMP_(ULONG) CStringMru::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CStringMru::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CStringMru::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CStringMru, IEnumString),
        QITABENT(CStringMru, IStringMru),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// *** IEnumString ***
STDMETHODIMP CStringMru::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    ULONG cFetched = 0;

    if (pceltFetched)
        *pceltFetched = cFetched;

    if (NULL == _hdpaStrings)
    {
        HRESULT hr = _Read();
        if (FAILED(hr))
            return hr;
    }

    for (int cnt =  _hdpaStrings ? DPA_GetPtrCount(_hdpaStrings) : 0; 
         cFetched < celt && (_iString + 1) < cnt;)
    {
        _iString++;
        LPOLESTR pwsz = (LPOLESTR)DPA_FastGetPtr(_hdpaStrings, _iString);
        if (pwsz)
        {
            if (SUCCEEDED(SHStrDup(pwsz, &rgelt[cFetched])))
            {
                cFetched++;
            }
        }
    }

    if (pceltFetched)
        *pceltFetched = cFetched;

    return cFetched == celt ? S_OK : S_FALSE ;
}

STDMETHODIMP CStringMru::Skip(ULONG celt)
{
    _iString += celt;
    if (_iString >= _cMax)
        _iString = _cMax - 1;
    return S_OK;
}

STDMETHODIMP CStringMru::Reset(void)
{
    _iString = -1;
    return S_OK;
}

//  Namespace selector combo methods

HRESULT _MakeCSIDLCbxItem(UINT csidl, UINT csidl2, HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    LPCTSTR rgcsidl[2] = {MAKEINTRESOURCE(csidl), MAKEINTRESOURCE(csidl2)};

    // note, CreateIEnumIDListOnCSIDLs checks SFGAO_NONENUMERATED so it filters
    // out things we should not display

    IEnumIDList *penum;
    HRESULT hr = CreateIEnumIDListOnCSIDLs(NULL, rgcsidl, (-1 == csidl2 ? 1 : 2), &penum);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        if (S_OK == FirstIDList(penum, &pidl))
        {
            TCHAR szName[MAX_PATH];
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), NULL);
        
            CBXITEM item;
            item.iID = csidl;

            MakeCbxItem(&item, szName, penum, pidl, LISTINSERT_LAST, NO_ITEM_INDENT);

            hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
            if (SUCCEEDED(hr))
            {
                penum = NULL;
            }

            ILFree(pidl);
        }
        if (penum)
            penum->Release();
    }
    return hr;
}

BOOL AppendItemToItemsArray(LPITEMIDLIST pidl, LPITEMIDLIST rgItems[], UINT sizeItems, UINT *pcItems)
{
    BOOL bAdded = FALSE;
    if (*pcItems < sizeItems)
    {
        DWORD dwFlags = SFGAO_NONENUMERATED;
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_NORMAL, NULL, 0, &dwFlags)) &&
            !(dwFlags & SFGAO_NONENUMERATED))
        {
            rgItems[(*pcItems)++] = pidl;
            bAdded = TRUE;
            pidl = NULL;    // don't free below
        }
    }
    ILFree(pidl);   // will be NULL if added to array, ownership transfered
    return bAdded;
}

BOOL AppendToItemsArray(LPCTSTR psz, LPITEMIDLIST rgItems[], UINT sizeItems, UINT *pcItems)
{
    LPITEMIDLIST pidl;
    if (IS_INTRESOURCE(psz))
    {
        SHGetFolderLocation(NULL, LOWORD((UINT_PTR)psz), NULL, 0, &pidl);
    }
    else
    {
        SHParseDisplayName(psz, NULL, &pidl, 0, NULL);
    }

    BOOL bAdded = FALSE;
    if (pidl)
    {
        bAdded = AppendItemToItemsArray(pidl, rgItems, sizeItems, pcItems);
    }
    return bAdded;
}

//  Create an item to put into the "look in" combo box for 
//  Local Hard Drives.  Will search the following directories:
//    1. My Documents
//    2. The Desktop folder (not the root of all PIDLS)
//    3. My Pictures
//    4. My Music
//    5. Documents and Settings
//    6. The current directory
//    7. The recycle bin
//    8. All local drives.

#define MIR(x) MAKEINTRESOURCE(x)

HRESULT _MakeLocalHardDrivesCbxItem(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    LPITEMIDLIST rgItems[32] = {0};
    UINT cItems = 0;
    HRESULT hr = S_OK;

    AppendToItemsArray(MIR(CSIDL_PERSONAL), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_COMMON_DOCUMENTS | CSIDL_FLAG_NO_ALIAS), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_COMMON_DESKTOPDIRECTORY), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYPICTURES), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYMUSIC), rgItems, ARRAYSIZE(rgItems), &cItems);
    AppendToItemsArray(MIR(CSIDL_MYVIDEO), rgItems, ARRAYSIZE(rgItems), &cItems);

    TCHAR szPath[MAX_PATH];
    DWORD cchPath = ARRAYSIZE(szPath);
    if (GetProfilesDirectory(szPath, &cchPath))
    {
        AppendToItemsArray(szPath, rgItems, ARRAYSIZE(rgItems), &cItems);
    }
    
    AppendToItemsArray(MIR(CSIDL_BITBUCKET), rgItems, ARRAYSIZE(rgItems), &cItems);

    TCHAR szDrives[128];
    szDrives[0] = 0;
    LPITEMIDLIST pidlIcon = NULL;
    for (int i = 0; i < 26; i++)
    {
        TCHAR szDrive[4];
        if (DRIVE_FIXED == GetDriveType(PathBuildRoot(szDrive, i)))
        {
            if (AppendToItemsArray(szDrive, rgItems, ARRAYSIZE(rgItems), &cItems))
            {
                // grab the pidl of the first time to use for the icon
                if (pidlIcon == NULL)
                    SHParseDisplayName(szDrive, NULL, &pidlIcon, 0, NULL);

                if (szDrives[0])
                {
                    hr = StringCchCat(szDrives, ARRAYSIZE(szDrives), TEXT(";"));
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                szDrive[2] = 0; // remove the back slash
                hr = StringCchCat(szDrives, ARRAYSIZE(szDrives), szDrive);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;
        hr = CreateIEnumIDListOnIDLists(rgItems, cItems, &penum);
        if (SUCCEEDED(hr))
        {
            TCHAR szFmt[64];
            LoadString(HINST_THISDLL, IDS_SNS_LOCALHARDDRIVES, szFmt, ARRAYSIZE(szFmt));

            hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), szFmt, szDrives);
            if (SUCCEEDED(hr))
            {
                CBXITEM item;
                MakeCbxItem(&item, szPath, penum, pidlIcon, LISTINSERT_LAST, ITEM_INDENT);

                item.iID = CBX_CSIDL_LOCALDRIVES;
                hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
            }

            if (FAILED(hr))
                penum->Release();
        }
    }

    ILFree(pidlIcon);
    return hr;
}

typedef struct
{
    HWND                hwndComboBox;
    ADDCBXITEMCALLBACK  pfn; 
    LPARAM              lParam;
} ENUMITEMPARAM;

HRESULT _PopulateDrivesCB(LPCITEMIDLIST pidl, void *pv) 
{ 
    ENUMITEMPARAM* peip = (ENUMITEMPARAM*)pv;

    ULONG ulAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED;
    TCHAR szName[MAX_PATH];       
    HRESULT hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName), &ulAttrs);
    if (SUCCEEDED(hr))
    {
        if ((SFGAO_FOLDER | SFGAO_FILESYSTEM) == (ulAttrs & (SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_NONENUMERATED)))
        {
            IEnumIDList *penum;
            hr = CreateIEnumIDListOnIDLists(&pidl, 1, &penum);
            if (SUCCEEDED(hr))
            {
                CBXITEM item;
                MakeCbxItem(&item, szName, penum, pidl, LISTINSERT_LAST, ITEM_INDENT);

                item.iID = CSIDL_DRIVES;
                hr = AddCbxItemToComboBoxCallback(peip->hwndComboBox, &item, peip->pfn, peip->lParam);
                if (SUCCEEDED(hr))
                {
                    penum = NULL;
                }
                else
                {
                    penum->Release();
                }
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;    
}

STDAPI PopulateNamespaceCombo(HWND hwndComboBoxEx, ADDCBXITEMCALLBACK pfn, LPARAM lParam)
{
    ::SendMessage(hwndComboBoxEx, CB_RESETCONTENT, 0, 0);

    // CSIDL_DESKTOP - use just the file system locations, not the root of the whole
    // name space here to avoid searching everything
    HRESULT hr = _MakeCSIDLCbxItem(CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS, 
                                   CSIDL_COMMON_DESKTOPDIRECTORY | CSIDL_FLAG_NO_ALIAS, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_PERSONAL, -1, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_MYPICTURES, -1, hwndComboBoxEx, pfn, lParam);
    
    if (SUCCEEDED(hr))
        hr = _MakeCSIDLCbxItem(CSIDL_MYMUSIC, -1, hwndComboBoxEx, pfn, lParam);

    if (SUCCEEDED(hr))
    {
        //  My Computer and children

        //  If My Docs has been redirected to a remote share, we'll want to prepend its path
        //  to our My Computer path list; otherwise it'll be missed.
        UINT csidl2 = -1;
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, szPath)) &&
            PathIsNetworkPath(szPath))
        {
            csidl2 = CSIDL_PERSONAL;
        }

        hr = _MakeCSIDLCbxItem(CSIDL_DRIVES, csidl2, hwndComboBoxEx, pfn, lParam);
        if (SUCCEEDED(hr))
        {
            //  Local hard drives (Which has heuristics to search best places first...)
            hr = _MakeLocalHardDrivesCbxItem(hwndComboBoxEx, pfn, lParam);
            if (SUCCEEDED(hr))
            {
                ENUMITEMPARAM eip = {0};
                eip.hwndComboBox = hwndComboBoxEx;
                eip.pfn          = pfn;
                eip.lParam       = lParam;

                hr = EnumSpecialItemIDs(CSIDL_DRIVES, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, _PopulateDrivesCB, &eip);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // Browse...
        CBXITEM item;
        item.iID = -1;
        TCHAR szDisplayName[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_SNS_BROWSER_FOR_DIR, szDisplayName, ARRAYSIZE(szDisplayName));
        MakeCbxItem(&item, szDisplayName, NULL, NULL, LISTINSERT_LAST, NO_ITEM_NOICON_INDENT);

        hr = AddCbxItemToComboBoxCallback(hwndComboBoxEx, &item, pfn, lParam);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findfilter.h ===
#ifndef _INC_DOCFIND
#define _INC_DOCFIND

// for the OLEDB query stuff
#define OLEDBVER 0x0250 // enable ICommandTree interface
#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledbdep.h>
#include <query.h>
#include <stgprop.h>
#include <ntquery.h>

#include <idhidden.h>

// reg location where we store bad paths that ci should not have indexed
#define CI_SPECIAL_FOLDERS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\SpecialFolders")

// Define some options that are used between filter and search code
#define DFOO_INCLUDESUBDIRS     0x0001      // Include sub directories.
#define DFOO_SHOWALLOBJECTS     0x1000      // Show all files
#define DFOO_CASESEN            0x0008      // Do case sensitive search         
#define DFOO_SEARCHSYSTEMDIRS   0x0010      // Search into system directories

// Some error happended on the get next file...
#define GNF_ERROR       -1
#define GNF_DONE        0
#define GNF_MATCH       1
#define GNF_NOMATCH     2
#define GNF_ASYNC       3

// Define a FACILITY That we can check errors for...
#define FACILITY_SEARCHCOMMAND      99

#undef  INTERFACE
#define INTERFACE       IFindEnum

DECLARE_INTERFACE_(IFindEnum, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindEnum
    STDMETHOD(Next)(THIS_ LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState) PURE;
    STDMETHOD (Skip)(THIS_ int celt) PURE;
    STDMETHOD (Reset)(THIS) PURE;
    STDMETHOD (StopSearch)(THIS) PURE;
    STDMETHOD_(BOOL,FQueryIsAsync)(THIS) PURE;
    STDMETHOD (GetAsyncCount)(THIS_ DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone) PURE;
    STDMETHOD (GetItemIDList)(THIS_ UINT iItem, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (GetItemID)(THIS_ UINT iItem, DWORD *puWorkID) PURE;
    STDMETHOD (SortOnColumn)(THIS_ UINT iCol, BOOL fAscending) PURE;
};

// We overloaded Async case when we are in mixed (some async some sync mode)
#define DF_QUERYISMIXED     ((BOOL)42)

typedef interface IFindFolder IFindFolder;

#undef  INTERFACE
#define INTERFACE       IFindFilter
DECLARE_INTERFACE_(IFindFilter, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindFilter
    STDMETHOD(GetStatusMessageIndex)(THIS_ UINT uContext, UINT *puMsgIndex) PURE;
    STDMETHOD(GetFolderMergeMenuIndex)(THIS_ UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu) PURE;
    STDMETHOD(FFilterChanged)(THIS) PURE;
    STDMETHOD(GenerateTitle)(THIS_ LPTSTR *ppszTile, BOOL fFileName) PURE;
    STDMETHOD(PrepareToEnumObjects)(THIS_ HWND hwnd, DWORD *pdwFlags) PURE;
    STDMETHOD(ClearSearchCriteria)(THIS) PURE;
    STDMETHOD(EnumObjects)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidlStart,
            DWORD grfFlags, int iColSort, LPTSTR pszProgressText, IRowsetWatchNotify *prwn, 
            IFindEnum **ppdfenum) PURE;
    STDMETHOD(GetColumnsFolder)(THIS_ IShellFolder2 **ppsf) PURE;
    STDMETHOD_(BOOL,MatchFilter)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SaveCriteria)(THIS_ IStream * pstm, WORD fCharType) PURE;   
    STDMETHOD(RestoreCriteria)(THIS_ IStream * pstm, int cCriteria, WORD fCharType) PURE;
    STDMETHOD(DeclareFSNotifyInterest)(THIS_ HWND hwndDlg, UINT uMsg) PURE;
    STDMETHOD(GetColSaveStream)(THIS_ WPARAM wParam, IStream **ppstm) PURE;
    STDMETHOD(GenerateQueryRestrictions)(THIS_ LPWSTR *ppwszQuery, DWORD *pdwGQRFlags) PURE;
    STDMETHOD(ReleaseQuery)(THIS) PURE;
    STDMETHOD(UpdateField)(THIS_ LPCWSTR pszField, VARIANT vValue) PURE;
    STDMETHOD(ResetFieldsToDefaults)(THIS) PURE;
    STDMETHOD(GetItemContextMenu)(THIS_ HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu** ppcm) PURE;
    STDMETHOD(GetDefaultSearchGUID)(THIS_ IShellFolder2 *psf2, LPGUID lpGuid) PURE;
    STDMETHOD(EnumSearches)(THIS_ IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum) PURE;
    STDMETHOD(GetSearchFolderClassId)(THIS_ LPGUID lpGuid) PURE;
    STDMETHOD(GetNextConstraint)(THIS_ VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound) PURE;
    STDMETHOD(GetQueryLanguageDialect)(THIS_ ULONG * pulDialect);
    STDMETHOD(GetWarningFlags)(THIS_ DWORD *pdwWarningFlags);
};


// Define the flags that GenerateQueryRestrictions may return
typedef enum {
    GQR_MAKES_USE_OF_CI =   0x0001, // some constraint makes resonable use of Content index
    GQR_REQUIRES_CI     =   0x0002, // The query requires the CI to work
    GQR_BYBASS_CI       =   0x0004, // The query should bybass CI.
} GQR_FLAGS;

//  Docfind UI warning bits.
#define DFW_DEFAULT                0x00000000  
#define DFW_IGNORE_CISCOPEMISMATCH 0x00000001 // CI query requested search scopes beyond indexed scopes
#define DFW_IGNORE_INDEXNOTCOMPLETE 0x00000002 // ci not done indexing

#define ESFITEM_ICONOVERLAYSET    0x00000001
typedef struct
{
    DWORD       dwMask;
    DWORD       dwState;    // State of the item;
    int         iIcon;
    ITEMIDLIST  idl;        // find pidl bits (with hidden stuff embedded), variable length
} FIND_ITEM;

// Currently the state above is LVIS_SELECTED and LVIS_FOCUSED (low two bits)
// Add a bit to use in the processing of updatedir
#define CDFITEM_STATE_MAYBEDELETE    0x80000000L
#define CDFITEM_STATE_MASK           (LVIS_SELECTED)    // Which states we will hav LV have us track

// Definition of the data items that we cache per directory.
typedef struct
{
    IShellFolder *      psf;        // Cache of MRU items
    BOOL                fUpdateDir:1; // Was this node touched by an updatedir...
    BOOL                fDeleteDir:1; // Was this directory removed from the list?
    // Allocate the pidl at end as variable length
    ITEMIDLIST idl;      // the pidl
} FIND_FOLDER_ITEM;


#pragma pack(1)
typedef struct
{
    HIDDENITEMID hid;
    WORD    iFolder;        // index to the folder DPA
    WORD    wFlags;
    UINT    uRow;           // Which row in the CI;
    DWORD   dwItemID;       // Only used for Async support...
    ULONG   ulRank;         // The rank returned by CI...
    ITEMIDLIST idlParent;   // the pidl of the folder this thing came from (fully qualified!)
} HIDDENDOCFINDDATA;
#pragma pack()

#define DFDF_NONE               0x0000
#define DFDF_EXTRADATA          0x0001

typedef UNALIGNED HIDDENDOCFINDDATA * PHIDDENDOCFINDDATA;
typedef const UNALIGNED HIDDENDOCFINDDATA * PCHIDDENDOCFINDDATA;

//
// Define structure that will be saved out to disk.
//
#define DOCFIND_SIG     (TEXT('D') | (TEXT('F') << 8))
typedef struct
{
    WORD    wSig;       // Signature
    WORD    wVer;       // Version
    DWORD   dwFlags;    // Flags that controls the sort
    WORD    wSortOrder; // Current sort order
    WORD    wcbItem;    // Size of the fixed portion of each item.
    DWORD   oCriteria;  // Offset to criterias in list
    long    cCriteria;  // Count of Criteria
    DWORD   oResults;   // Starting location of results in file
    long    cResults;   // Count of items that have been saved to file
    UINT    ViewMode;   // The view mode of the file...
} DFHEADER_WIN95;

typedef struct
{
    WORD    wSig;       // Signature
    WORD    wVer;       // Version
    DWORD   dwFlags;    // Flags that controls the sort
    WORD    wSortOrder; // Current sort order
    WORD    wcbItem;    // Size of the fixed portion of each item.
    DWORD   oCriteria;  // Offset to criterias in list
    long    cCriteria;  // Count of Criteria
    DWORD   oResults;   // Starting location of results in file
    long    cResults;   // Count of items that have been saved to file
    UINT    ViewMode;   // The view mode of the file...
    DWORD   oHistory;   // IPersistHistory::Save offset
} DFHEADER;

// The check in Win95/NT4 would fail to read the DFHEADER structure if
// the wVer field was > 3, which is unfortunate since the DFHEADER struct is
// backwards compiatible (that's why it uses offsets).  So we either
// go through the pain of revving the stream format in a backwards
// compatible way (not impossible, just a pain in the brain), or simply
// rev the version and add our new fields and call the Win95/NT4 problem
// a bug and punt.  I'm leaning towards "bug" as this is a rarely used feature.
#define DF_CURFILEVER_WIN95  3
#define DF_CURFILEVER        4

// define the format of the column information.
typedef struct
{
    WORD    wNum;       // Criteria number (cooresponds to dlg item id)
    WORD    cbText;     // size of text including null char (DavePl: code using this now assumes byte count)
} DFCRITERIA;

// Formats for saving find criteria.
#define DFC_FMT_UNICODE   1
#define DFC_FMT_ANSI      2

// This is a subset of fileinfo structure
typedef struct
{
    WORD    flags;          // FIF_ bits
    WORD    timeLastWrite;
    WORD    dateLastWrite;
    WORD    dummy;              // 16/32 bit compat.
                                //the compiler adds this padding
                                // remove and use if needed
    DWORD   dwSize;     // size of the file
    WORD    cbPath;     // size of the text (0 implies use previous files)
    WORD    cbName;     // Size of name including NULL.
} DFITEM;

STDAPI CreateNameSpaceFindFilter(IFindFilter **ppff);
STDAPI_(BOOL) SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR * pszSpecOut);

STDAPI CreateDefaultComputerFindFilter(IFindFilter **ppff);

STDAPI CreateOleDBEnum(
    IFindFilter * pdfff,
    IShellFolder *psf,
    LPWSTR *apwszPaths,
    UINT    *pcPaths,
    DWORD grfFlags,
    int iColSort,
    LPTSTR pszProgressText,
    IRowsetWatchNotify *prwn,
    IFindEnum **ppdfenum);


#undef  INTERFACE
#define INTERFACE       IFindControllerNotify

// This interface is used to let the callback class talk to the class that is actually controlling
// the queries and the like.
DECLARE_INTERFACE_(IFindControllerNotify, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IFindControllerNotify methods ***
    STDMETHOD(DoSortOnColumn)(THIS_ UINT iCol, BOOL fSameCol) PURE;
    STDMETHOD(SaveSearch)(THIS) PURE;
    STDMETHOD(RestoreSearch)(THIS) PURE;
    STDMETHOD(StopSearch)(THIS) PURE;
    STDMETHOD(GetItemCount)(THIS_ UINT *pcItems) PURE;
    STDMETHOD(SetItemCount)(THIS_ UINT cItems) PURE;
    STDMETHOD(ViewDestroyed)(THIS) PURE;
};


typedef struct {
    LPITEMIDLIST pidlSaveFile;  // [in, out] most recent pidl saved to
    DWORD dwFlags;              // [in, out] current flag state
    int SortMode;               // [in]      current sort mode
} DFBSAVEINFO;


#undef  INTERFACE
#define INTERFACE       IFindFolder

DECLARE_INTERFACE_(IFindFolder, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // IFindFolder
    STDMETHOD(GetFindFilter)(THIS_ IFindFilter  **pdfff) PURE;
    STDMETHOD(AddPidl)(THIS_ int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppItem) PURE;
    STDMETHOD(GetItem)(THIS_ int iItem, FIND_ITEM **ppItem) PURE;
    STDMETHOD(DeleteItem)(THIS_ int iItem) PURE;
    STDMETHOD(GetItemCount)(THIS_ INT *pcItems) PURE;
    STDMETHOD(ValidateItems)(THIS_ IUnknown *punk, int iItemFirst, int cItems, BOOL bSearchComplete) PURE;
    STDMETHOD(GetFolderListItemCount)(THIS_ INT *pcCount) PURE;
    STDMETHOD(GetFolderListItem)(THIS_ int iItem, FIND_FOLDER_ITEM **ppItem) PURE;
    STDMETHOD(GetFolder)(THIS_ int iFolder, REFIID riid, void **ppv) PURE;
    STDMETHOD_(UINT,GetFolderIndex)(THIS_ LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SetItemsChangedSinceSort)(THIS) PURE;
    STDMETHOD(ClearItemList)(THIS) PURE;
    STDMETHOD(ClearFolderList)(THIS) PURE;
    STDMETHOD(AddFolder)(THIS_ LPITEMIDLIST pidl, BOOL fCheckForDup, int *piFolder) PURE;
    STDMETHOD(SetAsyncEnum)(THIS_ IFindEnum *pdfEnumAsync) PURE;
    STDMETHOD(GetAsyncEnum)(THIS_ IFindEnum **ppdfEnumAsync) PURE;
    STDMETHOD(SetAsyncCount)(THIS_ DBCOUNTITEM cCount) PURE;
    STDMETHOD(CacheAllAsyncItems)(THIS) PURE;
    STDMETHOD_(BOOL,AllAsyncItemsCached)(THIS) PURE;
    STDMETHOD(ClearSaveStateList)(THIS) PURE;
    STDMETHOD(GetStateFromSaveStateList)(THIS_ DWORD dwItemID, DWORD *pdwState) PURE;
    STDMETHOD(MapToSearchIDList)(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD(GetParentsPIDL)(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent) PURE;
    STDMETHOD(RememberSelectedItems)(THIS) PURE;
    STDMETHOD(SetControllerNotifyObject)(IFindControllerNotify *pdfcn) PURE;
    STDMETHOD(GetControllerNotifyObject)(IFindControllerNotify **ppdfcn) PURE;
    STDMETHOD(SaveFolderList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(RestoreFolderList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(SaveItemList)(THIS_ IStream *pstm) PURE;
    STDMETHOD(RestoreItemList)(THIS_ IStream *pstm, int *pcItems) PURE;
    STDMETHOD(RestoreSearchFromSaveFile)(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv) PURE;

    STDMETHOD_(BOOL,HandleUpdateDir)(LPCITEMIDLIST pidl, BOOL fCheckSubDirs) PURE;
    STDMETHOD_(void,HandleRMDir)(IShellFolderView *psfv, LPCITEMIDLIST pidl) PURE;
    STDMETHOD_(void,UpdateOrMaybeAddPidl)(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld) PURE;
    STDMETHOD_(void,Save)(IFindFilter* pdfff, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown * pObject) PURE;
    STDMETHOD(OpenContainingFolder)(IUnknown *punkSite) PURE;

    STDMETHOD(AddDataToIDList)(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl) PURE;
};

STDAPI CFindItem_Create(HWND hwnd, IFindFolder *pdfFolder, IContextMenu **ppcm);

EXTERN_C const GUID IID_IFindFolder;
EXTERN_C const GUID IID_IFindFilter;
EXTERN_C const GUID IID_IFindControllerNotify;

#endif   // !_INC_DOCFIND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fldrcust.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "util.h"
#include "datautil.h"
#include "foldertypes.h"
#include "basefvcb.h"

#define PROPSTR_LOGO L"Logo"

typedef struct
{
    UINT    uIDFriendly;
    LPCTSTR pszFolderType;
    DWORD   dwFlags;
} WEBVIEWTEMPLATEINFO;

#define WVTI_SHOWIFOLDTEMPLATE 0x00000001

// documents must be first.
const WEBVIEWTEMPLATEINFO c_wvtiList[] =
{
    { IDS_CUSTOMIZE_USELEGACYHTT, STR_TYPE_USELEGACYHTT, WVTI_SHOWIFOLDTEMPLATE },
    { IDS_CUSTOMIZE_DOCUMENTS,    STR_TYPE_DOCUMENTS,    0 },
    { IDS_CUSTOMIZE_PICTURES,     STR_TYPE_PICTURES,     0 },
    { IDS_CUSTOMIZE_PHOTOALBUM,   STR_TYPE_PHOTOALBUM,   0 },
    { IDS_CUSTOMIZE_MUSIC,        STR_TYPE_MUSIC,        0 },
    { IDS_CUSTOMIZE_MUSICARTIST,  STR_TYPE_MUSICARTIST,  0 },
    { IDS_CUSTOMIZE_MUSICALBUM,   STR_TYPE_MUSICALBUM,   0 },
    { IDS_CUSTOMIZE_VIDEOS,       STR_TYPE_VIDEOS,       0 },
// note: are these gonna happen?
//    { IDS_CUSTOMIZE_VIDEOALBUM,   STR_TYPE_VIDEOALBUM,   0 },
//    { IDS_CUSTOMIZE_BOOKS,        STR_TYPE_BOOKS,        0 }
};

typedef enum
{
    FOLDERCUST_MODE_GENERATING,
    FOLDERCUST_MODE_ICON,
    FOLDERCUST_MODE_BITMAP
} FOLDERCUSTMODE;

class CFolderCustomize : public IShellExtInit,
                         public IShellPropSheetExt
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
        { return S_OK; };

    CFolderCustomize();

private:
    ~CFolderCustomize();
    static UINT CALLBACK _PrshtCallback(HWND hwnd, UINT uMsg, PROPSHEETPAGE *ppsp);
    void _SetRecurseBox(HWND hwnd);
    void _HideIconSection(HWND hwnd);
    void _InitDialog(HWND hwnd);
    BOOL _HandleWMCommand(HWND hwndDlg, WORD wNotify, WORD wID, HWND hwndCtrl);
    void _EnableApply(HWND hwnd);

    static DWORD WINAPI _ExtractThreadProc(void *pv);
    HRESULT _ExtractOnSeparateThread(IPropertyBag *ppb, HWND hwndDlg);
    HRESULT _CreateThumbnailBitmap(HWND hwndDlg);
    HRESULT _CreateFolderIcon(HWND hwndDlg);
    void _SetThumbnail(HWND hwnd);
    void _FreeDlgItems(HWND hwndDlg);
    void _SetPreviewToNewState(HWND hwndDlg, FOLDERCUSTMODE fcMode, HBITMAP hbitmap, HICON hicon);

    BOOL _ShouldEnableChangeOfIcon();
    void _ChangeFolderIcon(HWND hwndDlg);
    HRESULT _ProcessIconChange(LPCTSTR pszPickIconDialogCaption, HWND hwndDlg);

    void _DirTouch(LPITEMIDLIST pidl);
    void _DeleteCustomizationInBag(IPropertyBag *ppb);
    BOOL _NotifyAboutWebView(HWND hwnd);
    static BOOL CALLBACK _RefreshView(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
    void _RefreshWindows(BOOL fTurnOnWebView, BOOL fApplyToChildren);
    HRESULT _ApplyChangesToBag(HWND hwndDlg, IPropertyBag *ppb);
    HRESULT _ApplyChanges(HWND hwndDlg);

    void _UpdateViewState(HWND hwndDlg, IPropertyBag *ppb, int iIndex);
    void _FillTemplateComboBox(HWND hwndTemplates);
    int _GetTemplateIndexFromType(LPCTSTR pszType);

    static BOOL_PTR CALLBACK _DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG _cRef;

    LPITEMIDLIST   _pidl;
    IPropertyBag  *_ppb;

    // used for background thread extraction
    HWND           _hwnd;
    IPropertyBag  *_ppbBackground;

    // cached info
    HBITMAP        _hbmDefault;
    HBITMAP        _hbmLogo;
    TCHAR          _szCachedLogoFile[MAX_PATH];

    BOOL           _fUsingThumb;

    ICustomIconManager *_pIconManager;
    TCHAR _szLogoFile[MAX_PATH];
    TCHAR _szIconPath[MAX_PATH];
    int _iIconIndex;
    HRESULT _hrFromIconChange;

};

CFolderCustomize::CFolderCustomize() : _cRef(1), _hrFromIconChange(E_FAIL)
{
}

CFolderCustomize::~CFolderCustomize() 
{
    ILFree(_pidl);
    if (_ppb)
        _ppb->Release();
    if (_pIconManager)
        _pIconManager->Release();
    if (_ppbBackground)
        _ppbBackground->Release();
    if (_hbmDefault)
        DeleteObject(_hbmDefault);
    if (_hbmLogo)
        DeleteObject(_hbmLogo);
}
    
STDAPI CFolderCustomize_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory
    
    HRESULT hr = E_OUTOFMEMORY;
    CFolderCustomize* pfc = new CFolderCustomize();
    if (pfc)
    {
        hr = pfc->QueryInterface(riid, ppvOut);
        pfc->Release();
    }
    
    return hr;
}

HRESULT CFolderCustomize::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderCustomize, IShellExtInit),
        QITABENT(CFolderCustomize, IShellPropSheetExt),
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderCustomize::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderCustomize::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFolderCustomize::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hr;
    if (!pidlFolder)
    {
        hr = PidlFromDataObject(pdtobj, &_pidl);
    }
    else
    {
        hr = Pidl_Set(&_pidl, pidlFolder) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &_ppb));
    }
    return hr;
}

// from defview.cpp
BOOL IsCustomizable(LPCITEMIDLIST pidlFolder);

UINT CALLBACK CFolderCustomize::_PrshtCallback(HWND hwnd, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        ((CFolderCustomize *)ppsp->lParam)->Release();
    }
    return 1;
}

STDMETHODIMP CFolderCustomize::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    if (IsCustomizable(_pidl))
    {
        PROPSHEETPAGE psp = {0};
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_USECALLBACK;
        psp.hInstance   = HINST_THISDLL;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_FOLDER_CUSTOMIZE);
        psp.pfnDlgProc  = _DlgProc;
        psp.pfnCallback = _PrshtCallback;
        psp.lParam      = (LPARAM)this;

        HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            AddRef();   // HPROPSHEETPAGE holds ref, released on _PrshtCallback
            if (!pfnAddPage(hpsp, lParam))
            {
                DestroyPropertySheetPage(hpsp);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

#define IDH_FOLDER_TEMPLATES  10005
#define IDH_FOLDER_RECURSE    10006
#define IDH_FOLDER_PICKBROWSE 10007
#define IDH_FOLDER_DEFAULT    10008
#define IDH_FOLDER_CHANGEICON 10009

const static DWORD aPrshtHelpIDs[] = 
{
    IDC_FOLDER_TEMPLATES,       IDH_FOLDER_TEMPLATES,
    IDC_FOLDER_RECURSE,         IDH_FOLDER_RECURSE,
    IDC_FOLDER_PICKBROWSE,      IDH_FOLDER_PICKBROWSE,
    IDC_FOLDER_DEFAULT,         IDH_FOLDER_DEFAULT,
    IDC_FOLDER_CHANGEICON,      IDH_FOLDER_CHANGEICON,
    IDC_FOLDER_PREVIEW_ICON,    NO_HELP,
    IDC_FOLDER_PREVIEW_BITMAP,  NO_HELP,
    IDC_FOLDER_ICON,            NO_HELP,
    IDC_FOLDER_CHANGEICONTEXT,  NO_HELP,
    IDC_FOLDER_CHANGEICONGROUP, NO_HELP,
    IDC_NO_HELP_1,              NO_HELP,
    IDC_NO_HELP_2,              NO_HELP,
    0, 0
};

BOOL_PTR CALLBACK CFolderCustomize::_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    CFolderCustomize *pfc = (CFolderCustomize*)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pfc = (CFolderCustomize*)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pfc);
        pfc->_InitDialog(hwnd);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, L"filefold.hlp", HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPrshtHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, L"filefold.hlp", HELP_CONTEXTMENU, (ULONG_PTR)(void *)aPrshtHelpIDs);
        break;

    case WM_COMMAND:
        fRet = pfc->_HandleWMCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        break;

    case WM_NOTIFY:
        if (((LPNMHDR)lParam)->code == PSN_APPLY)
        {
            pfc->_ApplyChanges(hwnd);
        }
        fRet = TRUE;
        break;

    case WM_DESTROY:
        pfc->_FreeDlgItems(hwnd);
        break;
    }
    return fRet;
}

void CFolderCustomize::_FreeDlgItems(HWND hwndDlg)
{
    HICON hicon = (HICON)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETICON, NULL, NULL);
    if (hicon)
        DestroyIcon(hicon);
    HBITMAP hbitmap = (HBITMAP)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, NULL);
    if (hbitmap)
        DeleteObject(hbitmap);
    ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, NULL);
}

void CFolderCustomize::_SetPreviewToNewState(HWND hwndDlg, FOLDERCUSTMODE fcMode, HBITMAP hbitmap, HICON hicon)
{
    // if fcMode == FOLDERCUST_MODE_ICON, we need hicon and not hbitmap
    // if fcMode == FOLDERCUST_MODE_BITMAP, we need hbitmap and not hicon.
    // otherwise we dont want either.
    ASSERT((fcMode != FOLDERCUST_MODE_ICON) || (hicon && !hbitmap));
    ASSERT((fcMode != FOLDERCUST_MODE_BITMAP) || (!hicon && hbitmap));
    ASSERT((fcMode != FOLDERCUST_MODE_GENERATING) || (!hicon && !hbitmap));

    switch (fcMode)
    {
    case FOLDERCUST_MODE_GENERATING:
        {
            TCHAR szText[100];
            LoadString(HINST_THISDLL, IDS_CUSTOMIZE_GENERATING, szText, ARRAYSIZE(szText));
            SetWindowText(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), szText);

            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_HIDE);
        }
        break;

    case FOLDERCUST_MODE_ICON:
        {
            HICON hiconOld = (HICON)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETICON, NULL, NULL);
            if (hiconOld)
                DestroyIcon(hiconOld);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_SHOW);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_HIDE);

            SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hicon);
        }
        break;
        
    case FOLDERCUST_MODE_BITMAP:
        {
            HBITMAP hbitmapOld = (HBITMAP)SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, NULL);
            if (hbitmapOld)
                DeleteObject(hbitmapOld);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP), SW_SHOW);

            SendDlgItemMessage(hwndDlg, IDC_FOLDER_PREVIEW_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbitmap);
        }
        break;
    }
}

HRESULT CFolderCustomize::_CreateFolderIcon(HWND hwndDlg)
{
    IExtractIcon *peic;
    HRESULT hr = SHGetUIObjectFromFullPIDL(_pidl, NULL, IID_PPV_ARG(IExtractIcon, &peic));
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        INT iIndex;
        UINT wFlags;
        hr = peic->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
        if (SUCCEEDED(hr))
        {
            UINT nIconSize = MAKELONG(32, 32); // 32 for both large and small
            HICON hiconLarge;
            hr = peic->Extract(szPath, iIndex, NULL, &hiconLarge, nIconSize);
            if (SUCCEEDED(hr))
            {
                ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hiconLarge);
            }
        }
        peic->Release();
    }
    return hr;
}

DWORD WINAPI CFolderCustomize::_ExtractThreadProc(void *pv)
{
    CFolderCustomize *pfc = (CFolderCustomize*)pv;

    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_GENERATING, NULL, NULL);

    IExtractImage *pei;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pfc->_pidl, NULL, IID_PPV_ARG(IExtractImage, &pei));
    if (SUCCEEDED(hr))
    {
        hr = SHLoadFromPropertyBag(pei, pfc->_ppbBackground);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            SIZE sz = {96, 96};
            DWORD dwFlags = IEIFLAG_QUALITY;
            hr = pei->GetLocation(szPath, ARRAYSIZE(szPath), NULL, &sz, 24, &dwFlags);
            if (SUCCEEDED(hr))
            {
                HBITMAP hbitmap;
                hr = pei->Extract(&hbitmap);
                if (SUCCEEDED(hr))
                {
                    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_BITMAP, hbitmap, NULL);

                    TCHAR szLogo[MAX_PATH];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(pfc->_ppbBackground, PROPSTR_LOGO, szLogo, ARRAYSIZE(szLogo))))
                    {
                        HBITMAP *phbm = szLogo[0] ? &pfc->_hbmLogo : &pfc->_hbmDefault;
                        if (*phbm)
                            DeleteObject(*phbm);
                        *phbm = (HBITMAP)CopyImage(hbitmap, IMAGE_BITMAP, 0, 0, 0);

                        if (szLogo[0])
                        {
                            if (FAILED(StringCchCopy(pfc->_szCachedLogoFile, ARRAYSIZE(pfc->_szCachedLogoFile), szLogo)))
                            {
                                pfc->_szCachedLogoFile[0] = TEXT('\0');
                            }
                        }
                    }
                }
            }
        }
        pei->Release();
    }

    if (FAILED(hr))
    {
        // IExtractImage on a folder without any jpegs inside will fail.
        // in that case we need IExtractIcon.
        IExtractIcon *peic;
        hr = SHGetUIObjectFromFullPIDL(pfc->_pidl, NULL, IID_PPV_ARG(IExtractIcon, &peic));
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            INT iIndex;
            UINT wFlags;
            hr = peic->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &iIndex, &wFlags);
            if (SUCCEEDED(hr))
            {
                UINT nIconSize = MAKELONG(96, 96); // 96 for both large and small
                HICON hiconLarge;
                hr = peic->Extract(szPath, iIndex, NULL, &hiconLarge, nIconSize);
                if (SUCCEEDED(hr))
                {
                    pfc->_SetPreviewToNewState(pfc->_hwnd, FOLDERCUST_MODE_ICON, NULL, hiconLarge);
                }
            }
            peic->Release();
        }
    }

    pfc->Release(); // this thread holds a ref
    return 0;
}

HRESULT CFolderCustomize::_ExtractOnSeparateThread(IPropertyBag *ppb, HWND hwndDlg)
{
    HRESULT hr = E_OUTOFMEMORY;

    IUnknown_Set((IUnknown**)&_ppbBackground, ppb);
    _hwnd = hwndDlg;

    AddRef();
    if (SHCreateThread(_ExtractThreadProc, this, CTF_COINIT, NULL))
    {
        hr = S_OK;
    }
    else
    {
        Release();  // thread failed to take ref
    }

    return hr;
}

HRESULT CFolderCustomize::_CreateThumbnailBitmap(HWND hwndDlg)
{
    HRESULT hr = S_OK;
    // see if the bitmap is one we've already extracted.
    // can't use the thumbs.db cache for this kind of stuff, since the changes
    // havent been committed yet we really shouldnt be poking around in data.
    if (!_fUsingThumb && _hbmDefault)
    {
        _SetPreviewToNewState(hwndDlg, FOLDERCUST_MODE_BITMAP, (HBITMAP)CopyImage(_hbmDefault, IMAGE_BITMAP, 0, 0, 0), NULL);
    }
    else if (_fUsingThumb && _hbmLogo && (lstrcmpi(_szLogoFile, _szCachedLogoFile) == 0))
    {
        _SetPreviewToNewState(hwndDlg, FOLDERCUST_MODE_BITMAP, (HBITMAP)CopyImage(_hbmLogo, IMAGE_BITMAP, 0, 0, 0), NULL);
    }
    else
    {
        // cache miss, figure it out again.
        IPropertyBag *ppb;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteStr(ppb, PROPSTR_LOGO, _fUsingThumb ? _szLogoFile : TEXT(""));
            if (SUCCEEDED(hr))
            {
                hr = _ExtractOnSeparateThread(ppb, hwndDlg);
            }
            ppb->Release();
        }
    }
    return hr;
}

// dont want OFN_NODEREFERENCELINKS so use the rundlg.cpp helper directly
STDAPI_(BOOL) _GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cbFilePath, LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle, DWORD dwFlags);
BOOL CFolderCustomize::_HandleWMCommand(HWND hwndDlg, WORD wNotify, WORD wID, HWND hwndCtrl)
{
    switch(wID)
    {
    case IDC_FOLDER_TEMPLATES:
        if (wNotify == LBN_SELCHANGE)
        {
            _EnableApply(hwndDlg);
        }
        break;

    case IDC_FOLDER_DEFAULT:
        _EnableApply(hwndDlg);
        _fUsingThumb = FALSE;
        _CreateThumbnailBitmap(hwndDlg);
        break;

    case IDC_FOLDER_CHANGEICON:
        _ChangeFolderIcon(hwndDlg);
        break;

    case IDC_FOLDER_PICKBROWSE:
        TCHAR szFilePath[MAX_PATH] = {0};
        TCHAR szInitialDir[MAX_PATH] = {0};

        // initial directory is current folder
        // todo: load supported file types at runtime
        if (SHGetPathFromIDList(_pidl, szInitialDir) &&
            _GetFileNameFromBrowse(hwndDlg, szFilePath, ARRAYSIZE(szFilePath), szInitialDir,
                                   MAKEINTRESOURCE(IDS_IMAGES), MAKEINTRESOURCE(IDS_IMAGESFILTER), MAKEINTRESOURCE(IDS_BROWSE),
                                   OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR))
        {
            if (SUCCEEDED(StringCchCopy(_szLogoFile, ARRAYSIZE(_szLogoFile), szFilePath)))
            {
                _EnableApply(hwndDlg);
                _fUsingThumb = TRUE;
                _CreateThumbnailBitmap(hwndDlg);
            }
            else
            {
                _szLogoFile[0] = TEXT('\0');    // don't use truncated name
            }
        }
        break;
    }

    return FALSE;
}

BOOL CFolderCustomize::_NotifyAboutWebView(HWND hwnd)
{
    BOOL fRet = FALSE;

    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
    if (!ss.fWebView &&
        (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CUSTOMIZE_TURNONWEBVIEW),
                                  MAKEINTRESOURCE(IDS_CUSTOMIZE), MB_YESNO | MB_ICONQUESTION)))
    {
        ss.fWebView = TRUE;
        SHGetSetSettings(&ss, SSF_WEBVIEW, TRUE);
        fRet = TRUE;
    }
    return fRet;
}

typedef struct
{
    LPCITEMIDLIST pidlChanged;
    BOOL fTurnOnWebView;
    BOOL fApplyToChildren;
} CUSTENUMSTRUCT;

BOOL CALLBACK CFolderCustomize::_RefreshView(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam)
{
    CUSTENUMSTRUCT *pes = (CUSTENUMSTRUCT *)lParam;

    if (pes->fTurnOnWebView)
    {
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_SETWEBVIEW, TRUE);
    }
    if (ILIsEqual(pes->pidlChanged, pidl) || (pes->fApplyToChildren && ILIsParent(pes->pidlChanged, pidl, FALSE)))
    {
        PostMessage(hwnd, WM_COMMAND, SFVIDM_MISC_HARDREFRESH, 0L);
    }
    return TRUE;
}

void CFolderCustomize::_RefreshWindows(BOOL fTurnOnWebView, BOOL fApplyToChildren)
{
    CUSTENUMSTRUCT es = { _pidl, fTurnOnWebView, fApplyToChildren };
    EnumShellWindows(_RefreshView, (LPARAM)&es);
}

void CFolderCustomize::_UpdateViewState(HWND hwndDlg, IPropertyBag *ppb, int iIndex)
{
    TCHAR szOriginalType[25];
    szOriginalType[0] = 0;
    SHPropertyBag_ReadStr(ppb, PROPSTR_FOLDERTYPE, szOriginalType, ARRAYSIZE(szOriginalType));
    // only apply view state change if the folder type is changing.
    // also special case so that we dont apply a view state change if the folder has no
    // current folder type and the user didnt change the selection from "documents"
    // (i.e. they changed folder thumbnail but nothing else).
    if ((lstrcmpi(c_wvtiList[iIndex].pszFolderType, szOriginalType) != 0) &&
        (szOriginalType[0] || iIndex))
    {
        // knock out existing state, they don't want it any more.
        SHPropertyBag_Delete(ppb, VS_PROPSTR_MODE);
        SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);

        SHPropertyBag_WriteStr(ppb, PROPSTR_FOLDERTYPE, c_wvtiList[iIndex].pszFolderType);

        _RefreshWindows(_NotifyAboutWebView(hwndDlg), Button_GetCheck(GetDlgItem(hwndDlg, IDC_FOLDER_RECURSE)) == BST_CHECKED);
    }
}

void CFolderCustomize::_DirTouch(LPITEMIDLIST pidl)
{
    FILETIME ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent);

    TCHAR szPath[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // woohoo yay for private flags
        // 0x100 lets us open a directory in write access
        HANDLE h = CreateFile(szPath, GENERIC_READ | 0x100,
                              FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                              OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
        if (h != INVALID_HANDLE_VALUE)
        {
            SetFileTime(h, NULL, NULL, &ftCurrent);
            CloseHandle(h);
        }
    }
}

void CFolderCustomize::_DeleteCustomizationInBag(IPropertyBag *ppb)
{
    // this is only called when the inherit bag is getting written out.
    // so we need to scorch the existing non-inherit bag so it doesn't
    // override the inherit bag.
    SHPropertyBag_Delete(ppb, PROPSTR_FOLDERTYPE);
    SHPropertyBag_Delete(ppb, PROPSTR_LOGO);
    SHPropertyBag_Delete(ppb, VS_PROPSTR_MODE);
    SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);
}

HRESULT CFolderCustomize::_ApplyChangesToBag(HWND hwndDlg, IPropertyBag *ppb)
{
    // handle webview template
    HWND hwndTemplates = GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES);
    if (hwndTemplates)
    {
        int iIndex = ComboBox_GetCurSel(hwndTemplates);
        if (iIndex != CB_ERR)
        {
            int iViewIndex = (int)ComboBox_GetItemData(hwndTemplates, iIndex);
            _UpdateViewState(hwndDlg, ppb, iViewIndex);
        }
    }

    TCHAR szThumb[MAX_PATH];
    szThumb[0] = 0;
    if (_fUsingThumb)
    {
        if (FAILED(StringCchCopy(szThumb, ARRAYSIZE(szThumb), _szLogoFile)))
        {
            szThumb[0] = TEXT('\0');
        }
    }

    TCHAR szOriginalLogo[MAX_PATH];
    szOriginalLogo[0] = 0;
    SHPropertyBag_ReadStr(ppb, PROPSTR_LOGO, szOriginalLogo, ARRAYSIZE(szOriginalLogo));
    if (lstrcmpi(szThumb, szOriginalLogo) != 0)
    {
        SHPropertyBag_WriteStr(ppb, PROPSTR_LOGO, szThumb);
        _DirTouch(_pidl);
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, _pidl, NULL);
    }

    return S_OK;
}

HRESULT CFolderCustomize::_ApplyChanges(HWND hwndDlg)
{
    // handle icon change
    switch (_hrFromIconChange)
    {
        case S_OK:
            _pIconManager->SetIcon(_szIconPath, _iIconIndex);
            break;

        case S_FALSE:
            _pIconManager->SetDefaultIcon();
            break;
    }

    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_FOLDER_RECURSE)) == BST_CHECKED)
    {
        IPropertyBag *ppbInherit;
        if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_INHERIT, IID_PPV_ARG(IPropertyBag, &ppbInherit))))
        {
            _DeleteCustomizationInBag(_ppb);
            _ApplyChangesToBag(hwndDlg, ppbInherit);
            ppbInherit->Release();
        }
    }
    else
    {
        _ApplyChangesToBag(hwndDlg, _ppb);
    }

    return S_OK;
}

int CFolderCustomize::_GetTemplateIndexFromType(LPCTSTR pszType)
{
    // default to "documents"
    int iIndexFound = 0;
    for (int iIndex = 0; iIndex < ARRAYSIZE(c_wvtiList); iIndex++)
    {
        if (lstrcmpi(c_wvtiList[iIndex].pszFolderType, pszType) == 0)
        {
            iIndexFound = iIndex;
            break;
        }
    }
    return iIndexFound;
}

// Fill the combobox with templates' friendly names.
void CFolderCustomize::_FillTemplateComboBox(HWND hwndTemplates)
{
    // Disable redraws while we mess repeatedly with the contents.
    SendMessage(hwndTemplates, WM_SETREDRAW, FALSE, 0);

    TCHAR szType[25];
    szType[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_FOLDERTYPE, szType, ARRAYSIZE(szType));

    int nFolderTypeIndex = _GetTemplateIndexFromType(szType); // store index into c_wvtiList
    int iIndex = 0; // index into combobox
    // Add each template to the listview.
    for (int nTemplate = 0; nTemplate < ARRAYSIZE(c_wvtiList); nTemplate++)
    {
        TCHAR szPath[MAX_PATH];
        SFVM_WEBVIEW_TEMPLATE_DATA wvData;
        if (!(c_wvtiList[nTemplate].dwFlags & WVTI_SHOWIFOLDTEMPLATE) ||
            (SHGetPathFromIDList(_pidl, szPath) && SUCCEEDED(DefaultGetWebViewTemplateFromPath(szPath, &wvData))))
        {
            TCHAR szFriendlyName[100];
            LoadString(HINST_THISDLL, c_wvtiList[nTemplate].uIDFriendly, szFriendlyName, ARRAYSIZE(szFriendlyName));

            int iIndexAdd = ComboBox_AddString(hwndTemplates, szFriendlyName);
            if (iIndexAdd != -1)
            {
                if (nTemplate == nFolderTypeIndex)
                {
                    iIndex = iIndexAdd;
                }
                ComboBox_SetItemData(hwndTemplates, iIndexAdd, nTemplate);
            }
        }
    }

    // pick default
    ComboBox_SetCurSel(hwndTemplates, iIndex);

    // Reenable redraws.
    SendMessage(hwndTemplates, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndTemplates, NULL, TRUE);
}

void CFolderCustomize::_SetThumbnail(HWND hwnd)
{
    _szLogoFile[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_LOGO, _szLogoFile, ARRAYSIZE(_szLogoFile));

    _fUsingThumb = _szLogoFile[0];

    _CreateThumbnailBitmap(hwnd);
}

void CFolderCustomize::_SetRecurseBox(HWND hwnd)
{
    IPropertyBag *ppbInherit;
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_INHERIT, IID_PPV_ARG(IPropertyBag, &ppbInherit))))
    {
        TCHAR szTypeInherit[MAX_PATH];
        if (SUCCEEDED(SHPropertyBag_ReadStr(ppbInherit, PROPSTR_FOLDERTYPE, szTypeInherit, ARRAYSIZE(szTypeInherit))) && szTypeInherit[0])
        {
            TCHAR szType[MAX_PATH];
            if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_FOLDERTYPE, szType, ARRAYSIZE(szType))) && 
                (lstrcmpi(szTypeInherit, szType) == 0))
            {
                Button_SetCheck(GetDlgItem(hwnd, IDC_FOLDER_RECURSE), TRUE);
            }
        }
        ppbInherit->Release();
    }
}

// since changing the icon isn't in the peruser property bag (yet [it was punted from whistler])
// we need to disable this section if we know it can't be modified.
void CFolderCustomize::_HideIconSection(HWND hwndDlg)
{
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICONGROUP), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICON), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_CHANGEICONTEXT), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, IDC_FOLDER_ICON), SW_HIDE);
}

void CFolderCustomize::_InitDialog(HWND hwndDlg)
{
    HWND hwndTemplates = GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES);
    if (hwndTemplates)
    {
        _FillTemplateComboBox(GetDlgItem(hwndDlg, IDC_FOLDER_TEMPLATES));
        EnableWindow(hwndTemplates, TRUE);

        _SetThumbnail(hwndDlg);

        // Disable the Icon Change button if we the IShellFolder doesn't support ICustomIconManager interface.
        if (_ShouldEnableChangeOfIcon())
        {
            _CreateFolderIcon(hwndDlg);
        }
        else
        {
            _HideIconSection(hwndDlg);
        }

        _SetRecurseBox(hwndDlg);
    }
}

// helpers moved from mulprsht

// How do we selectively disable for .exe
BOOL CFolderCustomize::_ShouldEnableChangeOfIcon()
{
    if (!_pIconManager)
    {   
        SHGetUIObjectFromFullPIDL(_pidl, NULL, IID_PPV_ARG(ICustomIconManager, &_pIconManager));
    }
    
    return BOOLIFY(_pIconManager);
}

void CFolderCustomize::_EnableApply(HWND hwnd)
{
    PropSheet_Changed(GetParent(hwnd), hwnd);
}

void CFolderCustomize::_ChangeFolderIcon(HWND hwndDlg)
{
    ASSERT(_pIconManager);

    TCHAR szDialogCaptionFmt[MAX_PATH];
    LoadString(HINST_THISDLL, IDS_FOLDER_PICKICONDLG_CAPTION, szDialogCaptionFmt, ARRAYSIZE(szDialogCaptionFmt));

    TCHAR szFileName[MAX_PATH], szDialogCaption[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(_pidl, SHGDN_NORMAL, szFileName, ARRAYSIZE(szFileName), NULL)))
    {
        StringCchPrintf(szDialogCaption, ARRAYSIZE(szDialogCaption), szDialogCaptionFmt, PathFindFileName(szFileName)); // ok to truncate - display only
    }

    if (SUCCEEDED(_ProcessIconChange(szDialogCaption, hwndDlg)))
    {
        _EnableApply(hwndDlg);
    }
}

HRESULT CFolderCustomize::_ProcessIconChange(LPCTSTR pszPickIconDialogCaption, HWND hwndDlg)
{
    int nIconIndex = -1;

    TCHAR szIconPath[MAX_PATH];
    szIconPath[0] = 0;
       
    HRESULT hr = PickIconDlgWithTitle(hwndDlg, pszPickIconDialogCaption, TRUE, szIconPath, ARRAYSIZE(szIconPath), &nIconIndex);
    _hrFromIconChange = hr;
    switch (hr)
    {
        case S_OK:
        {
            HICON hIcon = ExtractIcon(HINST_THISDLL, szIconPath, nIconIndex);
            if (hIcon != NULL)
            {
                if (SUCCEEDED(StringCchCopy(_szIconPath, ARRAYSIZE(_szIconPath), szIconPath)))
                {
                    _iIconIndex = nIconIndex;
                    ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hIcon);
                }
                else
                {
                    DestroyIcon(hIcon);
                    _hrFromIconChange = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
            }
            else
            {
                _hrFromIconChange = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            break;
        }

        case S_FALSE:
        {
            HICON hIcon;
            if (SUCCEEDED(_pIconManager->GetDefaultIconHandle(&hIcon)))
            {
                ReplaceDlgIcon(hwndDlg, IDC_FOLDER_ICON, hIcon);
            }
            else
            {
                _hrFromIconChange = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            break;
        }

        case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        {
            break;
        }  
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findfilter.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "findhlp.h"
#include "fstreex.h"
#include "findfilter.h"
#include "prop.h"
#include "filtgrep.h"
#include "shstr.h"
#include "mtpt.h"
#include "idltree.h"
#include "enumidlist.h"

// Can't put this in varutil.cpp since a delay-load thunk for VariantTimeToDosDateTime
// pulls in the floating point init code, which pulls in _wWinMainCRTStartup which
// requires a _wWinMain which shlwapi does not have
//
STDAPI VariantToDosDateTime(VARIANT varIn, WORD *pwDate, WORD *pwTime)
{
    VARIANT varResult = {0};
    HRESULT hr = VariantChangeType(&varResult, &varIn, 0, VT_DATE);
    if (SUCCEEDED(hr))
    {
        VariantTimeToDosDateTime(varResult.date, pwDate, pwTime); 
    }
    return hr;
}

STDAPI InitVariantFromDosDateTime(VARIANT *pvar, WORD wDate, WORD wTime)
{
    pvar->vt = VT_DATE;
    return DosDateTimeToVariantTime(wDate, wTime, &pvar->date) ? S_OK : S_FALSE;
}

// {DBEC1000-6AB8-11d1-B758-00A0C90564FE}
const IID IID_IFindFilter = {0xdbec1000, 0x6ab8, 0x11d1, {0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe}};

// constants to define types of date we are searching on
#define DFF_DATE_ALL        (IDD_MDATE_ALL-IDD_MDATE_ALL)
#define DFF_DATE_DAYS       (IDD_MDATE_DAYS-IDD_MDATE_ALL)
#define DFF_DATE_MONTHS     (IDD_MDATE_MONTHS-IDD_MDATE_ALL)
#define DFF_DATE_BETWEEN    (IDD_MDATE_BETWEEN-IDD_MDATE_ALL)
#define DFF_DATE_RANGEMASK  0x00ff

// Define new criteria to be saved in file...
#define DFSC_SEARCHFOR      0x5000

#define DFSLI_VER                   0
#define DFSLI_TYPE_PIDL             0   // Pidl is streamed after this
#define DFSLI_TYPE_STRING           1   // cb follows this for length then string...
// Document folders and children - Warning we assume the order of items after Document Folders
#define DFSLI_TYPE_DOCUMENTFOLDERS  0x10
#define DFSLI_TYPE_DESKTOP          0x11
#define DFSLI_TYPE_PERSONAL         0x12
// My computer and children...
#define DFSLI_TYPE_MYCOMPUTER       0x20
#define DFSLI_TYPE_LOCALDRIVES      0x21

#define DFPAGE_INIT     0x0001          /* This page has been initialized */
#define DFPAGE_CHANGE   0x0002          /*  The user has modified the page */

#define SFGAO_FS_SEARCH (SFGAO_FILESYSANCESTOR | SFGAO_FOLDER)

// Use same enum and string table between updatefield and getting the constraints
// back out...
typedef enum
{
    CDFFUFE_IndexedSearch = 0,
    CDFFUFE_LookIn,
    CDFFUFE_IncludeSubFolders,
    CDFFUFE_Named,
    CDFFUFE_ContainingText,
    CDFFUFE_FileType,
    CDFFUFE_WhichDate,
    CDFFUFE_DateLE,
    CDFFUFE_DateGE,
    CDFFUFE_DateNDays,
    CDFFUFE_DateNMonths,
    CDFFUFE_SizeLE,
    CDFFUFE_SizeGE,
    CDFFUFE_TextCaseSen,
    CDFFUFE_TextReg,
    CDFFUFE_SearchSlowFiles,
    CDFFUFE_QueryDialect,
    CDFFUFE_WarningFlags,
    CDFFUFE_StartItem,
    CDFFUFE_SearchSystemDirs,
    CDFFUFE_SearchHidden,
} CDFFUFE;

static const struct
{
    LPCWSTR     pwszField;
    int         cdffufe;
}
s_cdffuf[] = // Warning: index of fields is used below in case...
{
    {L"IndexedSearch",       CDFFUFE_IndexedSearch},
    {L"LookIn",              CDFFUFE_LookIn},           // VARIANT: pidl, string or IEnumIDList object
    {L"IncludeSubFolders",   CDFFUFE_IncludeSubFolders},
    {L"Named",               CDFFUFE_Named},
    {L"ContainingText",      CDFFUFE_ContainingText},
    {L"FileType",            CDFFUFE_FileType},
    {L"WhichDate",           CDFFUFE_WhichDate},
    {L"DateLE",              CDFFUFE_DateLE},
    {L"DateGE",              CDFFUFE_DateGE},
    {L"DateNDays",           CDFFUFE_DateNDays},
    {L"DateNMonths",         CDFFUFE_DateNMonths},
    {L"SizeLE",              CDFFUFE_SizeLE},
    {L"SizeGE",              CDFFUFE_SizeGE},
    {L"CaseSensitive",       CDFFUFE_TextCaseSen},
    {L"RegularExpressions",  CDFFUFE_TextReg},
    {L"SearchSlowFiles",     CDFFUFE_SearchSlowFiles},
    {L"QueryDialect",        CDFFUFE_QueryDialect},
    {L"WarningFlags",        CDFFUFE_WarningFlags}, /*DFW_xxx bits*/
    {L"StartItem",           CDFFUFE_LookIn},           // VARIANT: pidl, string or IEnumIDList object
    {L"SearchSystemDirs",    CDFFUFE_SearchSystemDirs},
    {L"SearchHidden",        CDFFUFE_SearchHidden},
};

// internal support functions
STDAPI_(BOOL) SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR *ppszSpecOut);

// data filter object
class CFindFilter : public IFindFilter
{
public:
    CFindFilter();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindFilter
    STDMETHODIMP GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex);
    STDMETHODIMP GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu);
    STDMETHODIMP FFilterChanged();
    STDMETHODIMP GenerateTitle(LPTSTR *ppszTile, BOOL fFileName);
    STDMETHODIMP PrepareToEnumObjects(HWND hwnd, DWORD * pdwFlags);
    STDMETHODIMP ClearSearchCriteria();
    STDMETHODIMP EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, DWORD grfFlags, int iColSort, 
                             LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppdfenum);
    STDMETHODIMP GetColumnsFolder(IShellFolder2 **ppsf);
    STDMETHODIMP_(BOOL) MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP SaveCriteria(IStream * pstm, WORD fCharType);   
    STDMETHODIMP RestoreCriteria(IStream * pstm, int cCriteria, WORD fCharType);
    STDMETHODIMP DeclareFSNotifyInterest(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetColSaveStream(WPARAM wParam, LPSTREAM *ppstm);
    STDMETHODIMP GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwGQRFlags);
    STDMETHODIMP ReleaseQuery();
    STDMETHODIMP UpdateField(LPCWSTR pszField, VARIANT vValue);
    STDMETHODIMP ResetFieldsToDefaults();
    STDMETHODIMP GetItemContextMenu(HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu** ppcm);
    STDMETHODIMP GetDefaultSearchGUID(IShellFolder2 *psf2, LPGUID lpGuid);
    STDMETHODIMP EnumSearches(IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetSearchFolderClassId(LPGUID lpGuid);
    STDMETHODIMP GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound);
    STDMETHODIMP GetQueryLanguageDialect(ULONG * pulDialect);
    STDMETHODIMP GetWarningFlags(DWORD *pdwWarningFlags);

    STDMETHODIMP InitSelf(void);
    STDMETHODIMP_(BOOL) TopLevelOnly() const   { return _fTopLevelOnly; }

private:
    ~CFindFilter();
    HRESULT _GetDetailsFolder();
    void _GenerateQuery(LPWSTR pwszQuery, DWORD *pcchQuery);
    void _UpdateTypeField(const VARIANT *pvar);
    static int _SaveCriteriaItem(IStream * pstm, WORD wNum, LPCTSTR psz, WORD fCharType);
    DWORD _QueryDosDate(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, WORD wDate, BOOL bBefore);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);
    DWORD _CIQuerySize(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, ULONGLONG ullSize, int iSizeType);
    DWORD _CIQueryFilePatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPCWSTR pszFilePatterns);
    DWORD _CIQueryTextPatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText, BOOL bTextReg);
    DWORD _CIQueryShellSettings(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent);
    DWORD _CIQueryIndex(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText);
    DWORD _AddToQuery(LPWSTR *ppszBuf, DWORD *pcchBuf, LPWSTR pszAdd);
    WORD _GetTodaysDosDateMinusNMonths(int nMonths);
    WORD _GetTodaysDosDateMinusNDays(int nDays);
    HRESULT _ScopeEnumerator(IEnumIDList **ppenum);
    void _ResetRoots();

    LONG                _cRef;
    IFindEnum           *_penumAsync; // Added support for Query results to be async...

    // Data associated with the file name.
    LPTSTR              _pszFileSpec;        // $$ the one we do compares with
    LPTSTR              _pszSpecs;           // same as pszFileSpec but with '\0's for ';'s
    LPTSTR *            _apszFileSpecs;      // pointers into pszSpecs for each token
    int                 _cFileSpecs;         // count of specs

    TCHAR               _szPath[MAX_URL_STRING];   // Location of where to start search from
    TCHAR               _szUserInputFileSpec[MAX_PATH];  // File pattern.
    TCHAR               _szText[128];        // Limit text to max editable size

    BOOL                _fTopLevelOnly;      // Search on top level only?
    BOOL                _fSearchHidden;      // $$ Should we show all files?
    BOOL                _fFilterChanged;     // Something in the filter changed.
    BOOL                _fWeRestoredSomeCriteria; // We need to initilize the pages...
    BOOL                _fANDSearch;         // Perform search using AND vs OR?

    // Fields associated with the file type
    BOOL                _fTypeChanged;       // Type changed;
    int                 _iType;              // Index of the type.
    TCHAR               _szTypeName[80];     // The display name for type
    SHSTR               _strTypeFilePatterns;// $$ The file patterns associated with type
    LPTSTR              _pszIndexedSearch;   // what to search for... (Maybe larger than MAX_PATH because it's a list of paths.
    ULONG               _ulQueryDialect;     // ISQLANG_V1 or ISQLANG_V2
    DWORD               _dwWarningFlags;     // Warning bits (DFW_xxx).

    CFilterGrep         _filtgrep;

    int                 _iSizeType;          // $$ What type of size 0 - none, 1 > 2 <
    ULONGLONG           _ullSize;            // $$ Size comparison
    WORD                _wDateType;          // $$ 0 - none, 1 days before, 2 months before...
    WORD                _wDateValue;         //  (Num of months or days)
    WORD                _dateModifiedBefore; // $$
    WORD                _dateModifiedAfter;  // $$
    BOOL                _fFoldersOnly;       // $$ Are we searching for folders?
    BOOL                _fTextCaseSen;       // $$ Case sensitive searching...
    BOOL                _fTextReg;           // $$ regular expressions.
    BOOL                _fSearchSlowFiles;   // && probably missleading as file over a 300baud modem is also slow
    BOOL                _fSearchSystemDirs;  //    Search system directories?
    int                 _iNextConstraint;    // which constraint to look at next...
    HWND                _hwnd;               // for enum UI
    SHCOLUMNID          _scidDate;           // which date property to operate on
    SHCOLUMNID          _scidSize;           // which numeric property to operate on
    IEnumIDList         *_penumRoots;        // idlist enumerator for search roots
    IPropertyUI         *_ppui;
};

//  Target folder queue.
class CFolderQueue
{
public:
    CFolderQueue() : _hdpa(NULL) {}
    ~CFolderQueue();

    HRESULT Add(IShellFolder *psf, LPCITEMIDLIST pidl);

    IShellFolder *Remove();

private:
    HRESULT _AddFolder(IShellFolder *psf);
    HDPA    _hdpa;
};

class CNamespaceEnum : public IFindEnum
{
public:
    CNamespaceEnum(IFindFilter *pfilter, IShellFolder *psf, IFindEnum *pdfEnumAsync,
                   IEnumIDList *penumScopes, HWND hwnd, DWORD grfFlags, LPTSTR pszProgressText);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP StopSearch();
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCol, BOOL fAscending);

private:
    ~CNamespaceEnum();
    BOOL _ShouldPushItem(LPCITEMIDLIST pidl);
    BOOL _IsSystemFolderByCLSID(LPCITEMIDLIST pidlFull);
    IShellFolder *_NextRootScope();

    LONG            _cRef;
    IFindFilter     *_pfilter;          // parent filter object

    IFindFolder     *_pff;              // docfind folder interface over results
    HWND             _hwnd;             // for enum UI
    DWORD            _grfFlags;         // docfind enumeration flags (DFOO_xxx).

    // Recursion state...
    IShellFolder*    _psf;              // current shell folder
    LPITEMIDLIST     _pidlFolder;       // current shell folder, as pidl
    LPITEMIDLIST     _pidlCurrentRootScope; // the last scope pulled out of _penumScopes
    IEnumIDList      *_penum;           // current enumerator.
    int              _iFolder;          // index of current folder in docfind results' folder list.

    // filter info...
    LPTSTR           _pszProgressText;  // path buffer pointer; caller-owned (evil!)

    // enumeration state
    IEnumIDList      *_penumScopes;     // Queue of target folders passed as arguments.
    CFolderQueue      _queSubFolders;   // Queue of subfolders to search in next recursive pass.

    // tree to store the exclude items (i.e. already seached)
    CIDLTree         _treeExcludeFolders;

    // We may have an Async Enum that does some of the scopes...
    IFindEnum         *_penumAsync;
};

// Constants used to keep track of how/why an item was added to the
// exclude tree.
enum 
{
    EXCLUDE_SEARCHED  = 1,
    EXCLUDE_SYSTEMDIR = 2,
};
    

// Create the default filter for our find code...  They should be completly
// self contained...

STDAPI CreateNameSpaceFindFilter(IFindFilter **ppff)
{
    CFindFilter *pff;
    HRESULT hr = E_OUTOFMEMORY;

    pff = new CFindFilter();
    if (pff)
    {
        hr = pff->InitSelf();
        if (SUCCEEDED(hr))
        {
            *ppff = pff;
        }
        else
        {
            pff->Release();
        }
    }

    return hr;
}

HRESULT CFolderQueue::Add(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IShellFolder *psfNew;
    HRESULT hr = SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfNew));
    if (SUCCEEDED(hr))
    {
        hr = _AddFolder(psfNew);
        psfNew->Release();
    }
    return hr;
}

HRESULT CFolderQueue::_AddFolder(IShellFolder *psf)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(4);
    }

    if (_hdpa)
    {
        if (DPA_AppendPtr(_hdpa, psf) >= 0)
        {
            psf->AddRef();
            hr = S_OK;
        }
    }
    return hr;
}

// remove the folder from the queue
// give the caller the ownership of this folder
IShellFolder *CFolderQueue::Remove()
{
    IShellFolder *psf = NULL;
    if (_hdpa && DPA_GetPtrCount(_hdpa))
        psf = (IShellFolder *)DPA_DeletePtr(_hdpa, 0);
    return psf;
}

CFolderQueue::~CFolderQueue()
{ 
    if (_hdpa) 
    { 
        while (TRUE)
        {
            IShellFolder *psf = Remove();
            if (psf)
            {
                psf->Release();
            }
            else
            {
                break;
            }
        }
        DPA_Destroy(_hdpa); 
    } 
}

CFindFilter::CFindFilter() : _cRef(1), _wDateType(DFF_DATE_ALL), _ulQueryDialect(ISQLANG_V2)
{
}

CFindFilter::~CFindFilter()
{
    Str_SetPtr(&_pszFileSpec, NULL);
    Str_SetPtr(&_pszSpecs, NULL);
    LocalFree(_apszFileSpecs); // elements point to pszSpecs so no free for them
    
    Str_SetPtr(&_pszIndexedSearch, NULL);

    if (_ppui)
        _ppui->Release();

    if (_penumRoots)
        _penumRoots->Release();
}

STDMETHODIMP CFindFilter::InitSelf(void)
{
    return _filtgrep.InitSelf();
}


STDMETHODIMP CFindFilter::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindFilter, IFindFilter),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFindFilter::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindFilter::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// Retrieves the string resource index number that is proper for the
// current type of search.
STDMETHODIMP CFindFilter::GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex)
{
    // Currently context is not used
    *puMsgIndex = IDS_FILESFOUND;
    return S_OK;
}

// Retrieves which menu to load to merge for the folder
STDMETHODIMP CFindFilter::GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu)
{
    *puBGMainMergeMenu = POPUP_DOCFIND_MERGE;
    *puBGPopupMergeMenu = 0;
    return S_OK;
}

STDMETHODIMP CFindFilter::GetItemContextMenu(HWND hwndOwner, IFindFolder* pdfFolder, IContextMenu **ppcm)
{
    return CFindItem_Create(hwndOwner, pdfFolder, ppcm);
}

STDMETHODIMP CFindFilter::GetDefaultSearchGUID(IShellFolder2 *psf2, GUID *pGuid)
{
    return DefaultSearchGUID(pGuid);
}

STDMETHODIMP CFindFilter::EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return  E_NOTIMPL;
}

STDMETHODIMP CFindFilter::GetSearchFolderClassId(GUID *pGuid)
{
    *pGuid = CLSID_DocFindFolder;
    return S_OK;
}

// (returns S_OK if nothing changed.)
STDMETHODIMP CFindFilter::FFilterChanged()
{
    BOOL fFilterChanged = _fFilterChanged;
    this->_fFilterChanged = FALSE;
    return fFilterChanged ? S_FALSE : S_OK;
}

// Generates the title given the current search criteria.
STDMETHODIMP CFindFilter::GenerateTitle(LPTSTR *ppszTitle, BOOL fFileName)
{
    BOOL   fFilePattern;
    int    iRes;
    TCHAR  szFindName[80];    // German should not exceed this find: ->???
    LPTSTR pszFileSpec = _szUserInputFileSpec;
    LPTSTR pszText     = _szText;

    //
    // Lets generate a title for the search.  The title will depend on
    // the file patern(s), the type field and the containing text field
    // Complicate this a bit with the search for field...
    //

    fFilePattern = (pszFileSpec[0] != 0) &&
                (lstrcmp(pszFileSpec, c_szStarDotStar) != 0);

    if (!fFilePattern && (_penumAsync == NULL) && _pszIndexedSearch)
    {
        pszFileSpec = _pszIndexedSearch;
        fFilePattern = (pszFileSpec[0] != 0) &&
                    (lstrcmp(pszFileSpec, c_szStarDotStar) != 0);
    }

    if ((pszText[0] == 0) && (_penumAsync != NULL) && _pszIndexedSearch)
        pszText = _pszIndexedSearch;

    // First see if there is a type field
    if (_iType > 0)
    {
        // We have a type field no check for content...
        if (pszText[0] != 0)
        {
            // There is text!
            // Should now use type but...
            // else see if the name field is not NULL and not *.*
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_TYPE_NAME_TEXT;
            else
                iRes = IDS_FIND_TITLE_TYPE_TEXT;
        }
        else
        {
            // No type or text, see if file pattern
            // Containing not found, first search for type then named
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_TYPE_NAME;
            else
                iRes = IDS_FIND_TITLE_TYPE;
        }
    }
    else
    {
        // No Type field ...
        // first see if there is text to be searched for!
        if (pszText[0] != 0)
        {
            // There is text!
            // Should now use type but...
            // else see if the name field is not NULL and not *.*
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_NAME_TEXT;
            else
                iRes = IDS_FIND_TITLE_TEXT;
        }
        else
        {
            // No type or text, see if file pattern
            // Containing not found, first search for type then named
            if (fFilePattern)
                iRes = IDS_FIND_TITLE_NAME;
            else
                iRes = IDS_FIND_TITLE_ALL;
        }
    }


    // We put : in for first spot for title bar.  For name creation
    // we remove it which will put the number at the end...
    if (!fFileName)
        LoadString(HINST_THISDLL, IDS_FIND_TITLE_FIND,
                szFindName, ARRAYSIZE(szFindName));
    *ppszTitle = ShellConstructMessageString(HINST_THISDLL,
            MAKEINTRESOURCE(iRes),
            fFileName? szNULL : szFindName,
            _szTypeName, pszFileSpec, pszText);

    return *ppszTitle ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindFilter::ClearSearchCriteria()
{
    // Also clear out a few other fields...
    _szUserInputFileSpec[0] = 0;
    _iType = 0;
    _szText[0] = 0;

    return S_OK;
}

STDMETHODIMP CFindFilter::PrepareToEnumObjects(HWND hwnd, DWORD *pdwFlags)
{
    *pdwFlags = 0;  // start out empty

    _hwnd = hwnd;   // used for the first enum so that can do UI (auth/insert media)

    // Update the flags and buffer strings
    if (!_fTopLevelOnly)
        *pdwFlags |= DFOO_INCLUDESUBDIRS;

    if (_fTextCaseSen)
        *pdwFlags |= DFOO_CASESEN;
        
    if (_fSearchSystemDirs)
        *pdwFlags |= DFOO_SEARCHSYSTEMDIRS;

    // Also get the shell state variables to see if we should show extensions and the like
    if (_fSearchHidden)
        *pdwFlags |= DFOO_SHOWALLOBJECTS;

    // Now lets generate the file patern we will ask the system to look for
    
    // Here is where we try to put some smarts into the file patterns stuff
    // It will go something like:
    // look between each; or , and see if there are any wild cards.  If not
    // do something like *patern*.
    // Also if there is no search pattern or if it is * or *.*, set the
    // filter to NULL as to speed it up.
    //

    _fANDSearch = SetupWildCardingOnFileSpec(_szUserInputFileSpec, &_pszFileSpec);

    _cFileSpecs = 0;
    if (_pszFileSpec && _pszFileSpec[0])
    {
        Str_SetPtr(&_pszSpecs, _pszFileSpec);

        if (_pszSpecs)
        {
            int cTokens = 0;
            LPTSTR pszToken = _pszSpecs;
            // Count number of file spces
            while (pszToken)
            {
                // let's walk pszFileSpec to see how many specs we have...
                pszToken = StrChr(pszToken, TEXT(';'));

                // If delimiter, then advance past for next iteration
                if (pszToken)
                    pszToken++;
                cTokens++;
            }

            if (cTokens)
            {
                // cleanup the previous search
                if (_apszFileSpecs)
                    LocalFree(_apszFileSpecs);
                _apszFileSpecs = (LPTSTR *)LocalAlloc(LPTR, cTokens * sizeof(LPTSTR *));
                if (_apszFileSpecs)
                {
                    _cFileSpecs = cTokens;
                    pszToken = _pszSpecs;
                    for (int i = 0; i < cTokens; i++)
                    {
                        _apszFileSpecs[i] = pszToken;
                        pszToken = StrChr(pszToken, TEXT(';'));
                        if (pszToken)
                            *pszToken++ = 0;
                    }
                }
            }
        }
    }

    _filtgrep.Reset();
    
    HRESULT hr = S_OK;
    if (_szText[0])
    {
        DWORD dwGrepFlags = FGIF_BLANKETGREP | FGIF_GREPFILENAME;
        if (*pdwFlags & DFOO_CASESEN)
            dwGrepFlags |= FGIF_CASESENSITIVE;

        hr = _filtgrep.Initialize(GetACP(), _szText, NULL, dwGrepFlags);
    }
    return hr;
}

STDMETHODIMP CFindFilter::GetColumnsFolder(IShellFolder2 **ppsf)
{
    *ppsf = NULL;
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidl, ppsf));
        ILFree(pidl);
    }
    return hr;
}

void FreePathArray(LPTSTR rgpszPaths[], UINT cPaths)
{
    for (UINT i = 0; i < cPaths; i++)
    {
        LocalFree((HLOCAL)rgpszPaths[i]);
        rgpszPaths[i] = NULL;
    }
}

HRESULT NamesFromEnumIDList(IEnumIDList *penum, LPTSTR rgpszPaths[], UINT sizePaths, UINT *pcPaths)
{
    *pcPaths = 0;
    ZeroMemory(rgpszPaths, sizeof(rgpszPaths[0]) * sizePaths);

    penum->Reset();

    LPITEMIDLIST pidl;
    while (S_OK == penum->Next(1, &pidl, NULL))
    {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            if ((*pcPaths) < sizePaths)
            {
                rgpszPaths[*pcPaths] = StrDup(szPath);
                if (rgpszPaths[*pcPaths])
                    (*pcPaths)++;
            }
        }
        ILFree(pidl);
    }
    return S_OK;
}

void ClearIDArray(LPITEMIDLIST rgItems[], UINT cItems)
{
    for (UINT i = 0; i < cItems; i++)
    {
        ILFree(rgItems[i]);
        rgItems[i] = NULL;
    }
}

#define MAX_ROOTS   32

HRESULT FilterEnumeratorByNames(const LPCTSTR rgpszNames[], UINT cNames, IEnumIDList **ppenum)
{
    LPITEMIDLIST rgItems[MAX_ROOTS] = {0};
    int cItems = 0;

    (*ppenum)->Reset();
    // capture all of the other pidls in the current enumerator
    LPITEMIDLIST pidl;
    while (S_OK == (*ppenum)->Next(1, &pidl, NULL))
    {
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            for (UINT i = 0; i < cNames; i++)
            {
                if (rgpszNames[i] &&
                    (cItems < ARRAYSIZE(rgItems)) &&
                    (0 == StrCmpIC(szPath, rgpszNames[i])))
                {
                    rgItems[cItems++] = pidl;
                    pidl = NULL;    // don't free below
                    break;
                }
            }
        }
        ILFree(pidl);   // may be NULL
    }

    IEnumIDList *penum;
    if (SUCCEEDED(CreateIEnumIDListOnIDLists(rgItems, cItems, &penum)))
    {
        (*ppenum)->Release();
        *ppenum = penum;
    }

    ClearIDArray(rgItems, cItems);

    return S_OK;
}

HRESULT CFindFilter::_ScopeEnumerator(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    HRESULT hr = E_FAIL;
    if (_penumRoots)
    {
        hr = _penumRoots->Clone(ppenum);
        if (SUCCEEDED(hr))
            (*ppenum)->Reset(); // clone above will clone the index as well
    }
    return hr;
}

//==========================================================================
//add helper funtion to check if the Path is restricted (WinseBUG 20189)
//==========================================================================
BOOL PathIsRestricted(TCHAR * szPath, RESTRICTIONS iFlag)
{
      UINT driveNum, dwRest;

      if((driveNum = PathGetDriveNumber(szPath)) != -1){
        dwRest = SHRestricted(iFlag);
        if (dwRest & (1 << driveNum))
        {
            return TRUE;
        }
      }
      return FALSE;
}

void FilterNoViewDrives(LPTSTR rgpszNames[], UINT *pcNames)
{
    UINT cNames = *pcNames;
    UINT cNamesResult = 0;

    for (UINT iName = 0; iName < cNames; iName++)
    {
        if (PathIsRestricted(rgpszNames[iName], REST_NOVIEWONDRIVE))
        {
            LocalFree((HLOCAL)rgpszNames[iName]);
            rgpszNames[iName] = NULL;
        }
        else
        {
            rgpszNames[cNamesResult++] = rgpszNames[iName];
        }
    }
    *pcNames = cNamesResult;
}

// produce the find enumerator

STDMETHODIMP CFindFilter::EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart,
                                      DWORD grfFlags, int iColSort, LPTSTR pszProgressText,  
                                      IRowsetWatchNotify *prwn, IFindEnum **ppdfenum)
{
    *ppdfenum = NULL;

    HRESULT hr;
    IEnumIDList *penum;
    if (pidlStart)
    {
        hr = CreateIEnumIDListOnIDLists(&pidlStart, 1, &penum);
    }
    else
    {
        hr = _ScopeEnumerator(&penum);
    }
    if (SUCCEEDED(hr))
    {
        UINT cPaths;
        LPTSTR rgpszPaths[MAX_ROOTS];
        hr = NamesFromEnumIDList(penum, rgpszPaths, ARRAYSIZE(rgpszPaths), &cPaths);
        if (SUCCEEDED(hr)) 
        {
            FilterNoViewDrives(rgpszPaths, &cPaths);

            *ppdfenum = NULL;

            if (cPaths > 0)
            {
                hr = CreateOleDBEnum(this, psf, rgpszPaths, &cPaths, grfFlags, iColSort, pszProgressText, prwn, ppdfenum);
                if (S_OK == hr && *ppdfenum != NULL)
                {
                    _penumAsync = *ppdfenum;
                    _penumAsync->AddRef();
                }
                else
                {
                    _penumAsync = NULL;
                }

                // are their more paths to process?
                if (cPaths)
                {
                    // did user specified CI query that we can't grep for?
                    DWORD dwFlags;
                    if (FAILED(GenerateQueryRestrictions(NULL, &dwFlags)) ||
                        !(dwFlags & GQR_REQUIRES_CI))
                    {
                        FilterEnumeratorByNames(rgpszPaths, ARRAYSIZE(rgpszPaths), &penum);

                        IFindEnum *pdfenum = new CNamespaceEnum(
                            SAFECAST(this, IFindFilter *), psf, *ppdfenum,
                            penum, _hwnd, grfFlags, pszProgressText);
                        if (pdfenum)
                        {
                            // The rest of the fields should be zero/NULL
                            *ppdfenum = pdfenum;
                            hr = S_OK;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
            FreePathArray(rgpszPaths, cPaths);
        }
        penum->Release();
    }
    return hr;
}

// IFindFilter::MatchFilter

STDMETHODIMP_(BOOL) CFindFilter::MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bMatch = TRUE;
    TCHAR szName[MAX_PATH], szDisplayName[MAX_PATH];
    DWORD dwAttrib = SHGetAttributes(psf, pidl, SFGAO_HIDDEN | SFGAO_FOLDER | SFGAO_ISSLOW);
    
    if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))) &&
        SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_NORMAL, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        IShellFolder2 *psf2;
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2)); // optional, may be NULL
        
        // First things we dont show hidden files
        // If show all is set then we should include hidden files also...
        
        if (!_fSearchHidden && (SFGAO_HIDDEN & dwAttrib))
            bMatch = FALSE;     // does not match
        
        if (bMatch && _fFoldersOnly && !(SFGAO_FOLDER & dwAttrib))
            bMatch = FALSE;     // does not match
        
        if (bMatch && _iSizeType)
        {
            ULONGLONG ullSize;
            if (psf2 && SUCCEEDED(GetLongProperty(psf2, pidl, &_scidSize, &ullSize)))
            {
                if (1 == _iSizeType)        // >
                {
                    if (!(ullSize > _ullSize))
                        bMatch = FALSE;     // does not match
                }
                else if (2 == _iSizeType)   // <
                {
                    if (!(ullSize < _ullSize))
                        bMatch = FALSE;     // does not match
                }
            }
            else
            {
                bMatch = FALSE;
            }
        }
        
        if (bMatch && (_scidDate.fmtid != CLSID_NULL))
        {
            FILETIME ft;
            if (psf2 && SUCCEEDED(GetDateProperty(psf2, pidl, &_scidDate, &ft)))
            {
                FILETIME ftLocal;
                FileTimeToLocalFileTime(&ft, &ftLocal);

                WORD wFileDate = 0, wFileTime = 0;
                FileTimeToDosDateTime(&ftLocal, &wFileDate, &wFileTime);
            
                if (_dateModifiedBefore && !(wFileDate <= _dateModifiedBefore))
                    bMatch = FALSE;     // does not match
            
                if (_dateModifiedAfter && !(wFileDate >= _dateModifiedAfter))
                    bMatch = FALSE;     // does not match
            }
            else
            {
                bMatch = FALSE;
            }
        }
        
        // Match file specificaitions.
        if (bMatch && _pszFileSpec && _pszFileSpec[0])
        {
            // if we have split up version of the specs we'll use it because PathMatchSpec
            // can take up to 5-6 hours for more than 10 wildcard specs
            if (_cFileSpecs)
            {
                // Only search the actual file system file name if the user specified 
                // an extention
                BOOL bHasExtension = (0 != *PathFindExtension(_pszFileSpec));
                if (bHasExtension)
                {
                    for (int i = 0; i < _cFileSpecs; i++)
                    {
                        bMatch = PathMatchSpec(szName, _apszFileSpecs[i]);
                        if (_fANDSearch)
                        {
                            // AND we quit on the first one that doesn't match
                            if (!bMatch)
                                break;
                        }
                        else
                        {
                            // OR we quit on the first one that does match
                            if (bMatch)
                                break;
                        }
                    }
                }
                
                // Compare the displayable name to the filter.
                // This is needed for searching the recylcle bin becuase the actual file names
                // are similar to "DC0.LNK" instead of "New Text Document.txt"
                if (!bMatch || !bHasExtension)
                {
                    for (int i = 0; i < _cFileSpecs; i++)
                    {
                        bMatch = PathMatchSpec(szDisplayName, _apszFileSpecs[i]);
                        if (_fANDSearch)
                        {
                            // AND we quit on the first one that doesn't match
                            if (!bMatch)
                                break;
                        }
                        else
                        {
                            // OR we quit on the first one that does match
                            if (bMatch)
                                break;
                        }
                    }
                }
            }
            else if (!PathMatchSpec(szName, _pszFileSpec) 
                && !PathMatchSpec(szDisplayName, _pszFileSpec))
            {
                bMatch = FALSE;     // does not match
            }
        }
        
        if (bMatch && _strTypeFilePatterns[0])
        {
            // if looking for folders only and file pattern is all folders then no need to check
            // if folder name matches the pattern -- we know it is the folder, otherwise we
            // would have bailed out earlier in the function
            if (!(_fFoldersOnly && lstrcmp(_strTypeFilePatterns, TEXT(".")) == 0))
            {
                if (!PathMatchSpec(szName, _strTypeFilePatterns))
                    bMatch = FALSE;     // does not match
            }
        }
        
        // See if we need to do a grep of the file
        if (bMatch && (SFGAO_ISSLOW & dwAttrib) && !_fSearchSlowFiles)
            bMatch = FALSE;     // does not match
        
        if (bMatch && 
            (S_OK == _filtgrep.GetMatchTokens(NULL, 0) || 
             S_OK == _filtgrep.GetExcludeTokens(NULL, 0)))
        {
            bMatch = (S_OK == _filtgrep.Grep(psf, pidl, szName));
        }
        
        if (psf2)
            psf2->Release();
    }
    else
        bMatch = FALSE;
    return bMatch;    // return TRUE -> yes, a match!
}

// date ordinal mapper helpers to deal with old way to refer to dates

BOOL MapValueToDateSCID(UINT i, SHCOLUMNID *pscid)
{
    ZeroMemory(pscid, sizeof(*pscid));

    switch (i)
    {
    case 1:
        *pscid = SCID_WRITETIME;
        break;
    case 2:
        *pscid = SCID_CREATETIME;
        break;
    case 3:
        *pscid = SCID_ACCESSTIME;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

// returns 0 as invalid ordinal

int MapDateSCIDToValue(const SHCOLUMNID *pscid)
{
    int i = 0;  // 0 invalid scid

    if (IsEqualSCID(*pscid, SCID_WRITETIME))
    {
        i = 1;
    }
    else if (IsEqualSCID(*pscid, SCID_CREATETIME))
    {
        i = 2;
    }
    else if (IsEqualSCID(*pscid, SCID_ACCESSTIME))
    {
        i = 3;
    }
    return i;
}


// IFindFilter::SaveCriteria

// util.cpp
STDAPI_(int) Int64ToString(LONGLONG n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                           NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
#define MAX_ULONGLONG_LEN 20+1 // "18446744073709551616"

STDMETHODIMP CFindFilter::SaveCriteria(IStream * pstm, WORD fCharType)
{
    TCHAR szTemp[40];    // some random size

    // The caller should have already validated the stuff and updated
    // everything for the current filter information.

    // we need to walk through and check each of the items to see if we
    // have a criteria to save away. this includes:
    //      (Name, Path, Type, Contents, size, modification dates)
    int cCriteria = _SaveCriteriaItem(pstm, IDD_FILESPEC, _szUserInputFileSpec, fCharType);

    cCriteria += _SaveCriteriaItem(pstm, IDD_PATH, _szPath, fCharType);

    cCriteria += _SaveCriteriaItem(pstm, DFSC_SEARCHFOR, _pszIndexedSearch, fCharType);
    cCriteria += _SaveCriteriaItem(pstm, IDD_TYPECOMBO, _strTypeFilePatterns, fCharType);
    cCriteria += _SaveCriteriaItem(pstm, IDD_CONTAINS, _szText, fCharType);
    
    // Also save away the state of the top level only
    wsprintf(szTemp, TEXT("%d"), _fTopLevelOnly);
    cCriteria += _SaveCriteriaItem(pstm, IDD_TOPLEVELONLY, szTemp, fCharType);

    // The Size field is little more fun!
    if (_iSizeType != 0)
    {
        WCHAR szNum[MAX_ULONGLONG_LEN];
        Int64ToString(_ullSize, szNum, ARRAYSIZE(szNum), FALSE, NULL, 0);
        wsprintf(szTemp, TEXT("%d %ws"), _iSizeType, szNum);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SIZECOMP, szTemp, fCharType);
    }

    // Likewise for the dates, should be fun as we need to save it depending on
    // how the date was specified
    switch (_wDateType & DFF_DATE_RANGEMASK)
    {
    case DFF_DATE_ALL:
        // nothing to store
        break;
    case DFF_DATE_DAYS:
        wsprintf(szTemp, TEXT("%d"), _wDateValue);
        cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_NUMDAYS, szTemp, fCharType);
        break;
    case DFF_DATE_MONTHS:
        wsprintf(szTemp, TEXT("%d"), _wDateValue);
        cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_NUMMONTHS, szTemp, fCharType);
        break;
    case DFF_DATE_BETWEEN:
        if (_dateModifiedAfter)
        {
            wsprintf(szTemp, TEXT("%d"), _dateModifiedAfter);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_FROM, szTemp, fCharType);
        }

        if (_dateModifiedBefore)
        {
            wsprintf(szTemp, TEXT("%d"), _dateModifiedBefore);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_TO, szTemp, fCharType);
        }
        break;
    }

    if ((_wDateType & DFF_DATE_RANGEMASK) != DFF_DATE_ALL)
    {
        int i = MapDateSCIDToValue(&_scidDate);
        if (i)
        {
            // strangly we write a 0 based version of this ordinal out
            wsprintf(szTemp, TEXT("%d"), i - 1);
            cCriteria += _SaveCriteriaItem(pstm, IDD_MDATE_TYPE, szTemp, fCharType);
        }
    }

    if (_fTextCaseSen)
    {
        wsprintf(szTemp, TEXT("%d"), _fTextCaseSen);
        cCriteria += _SaveCriteriaItem(pstm, IDD_TEXTCASESEN, szTemp, fCharType);
    }

    if (_fTextReg)
    {
        wsprintf(szTemp, TEXT("%d"), _fTextReg);
        cCriteria += _SaveCriteriaItem(pstm, IDD_TEXTREG, szTemp, fCharType);
    }

    if (_fSearchSlowFiles)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchSlowFiles);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHSLOWFILES, szTemp, fCharType);
    }

    //  Save value for searching system directories.
    if (_fSearchSystemDirs)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchSystemDirs);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHSYSTEMDIRS, szTemp, fCharType);
    }

    if (_fSearchHidden)
    {
        wsprintf(szTemp, TEXT("%d"), _fSearchHidden);
        cCriteria += _SaveCriteriaItem(pstm, IDD_SEARCHHIDDEN, szTemp, fCharType);
    }

    return MAKE_SCODE(0, 0, cCriteria);
}


// Helper function for save criteria that will output the string and
// and id to the specified file.  it will also test for NULL and the like

int CFindFilter::_SaveCriteriaItem(IStream *pstm, WORD wNum, LPCTSTR psz, WORD fCharType)
{
    if ((psz == NULL) || (*psz == 0))
        return 0;
    else
    {
        const void *pszText = (const void *)psz; // Ptr to output text. Defaults to source.
        // These are required to support ANSI-unicode conversions.
        LPSTR pszAnsi  = NULL; // For unicode-to-ansi conversion.
        LPWSTR pszWide = NULL; // For ansi-to-unicode conversion.
        DFCRITERIA dfc;
        dfc.wNum = wNum;
        
        // Note: Problem if string is longer than 64K
        dfc.cbText = (WORD) ((lstrlen(psz) + 1) * sizeof(TCHAR));
        
        // Source string is Unicode but caller wants to save as ANSI.
        //
        if (DFC_FMT_ANSI == fCharType)
        {
            // Convert to ansi and write ansi.
            dfc.cbText = (WORD) WideCharToMultiByte(CP_ACP, 0L, psz, -1, pszAnsi, 0, NULL, NULL);
            
            pszAnsi = (LPSTR)LocalAlloc(LMEM_FIXED, dfc.cbText);
            if (pszAnsi)
            {
                WideCharToMultiByte(CP_ACP, 0L, psz, -1, pszAnsi, dfc.cbText / sizeof(pszAnsi[0]), NULL, NULL);
                pszText = (void *)pszAnsi;
            }
        }
        
        pstm->Write(&dfc, sizeof(dfc), NULL);       // Output index
        pstm->Write(pszText, dfc.cbText, NULL);     // output string + NULL
        
        // Free up conversion buffers if any were created.
        if (pszAnsi)
            LocalFree(pszAnsi);
        if (pszWide)
            LocalFree(pszWide);
    }
    
    return 1;
}

// IFindFilter::RestoreCriteria
STDMETHODIMP CFindFilter::RestoreCriteria(IStream *pstm, int cCriteria, WORD fCharType)
{
    SHSTR strTemp;
    SHSTRA strTempA;

    if (cCriteria > 0)
        _fWeRestoredSomeCriteria = TRUE;

    while (cCriteria--)
    {
        DFCRITERIA dfc;
        DWORD cb;

        if (FAILED(pstm->Read(&dfc, sizeof(dfc), &cb)) || cb != sizeof(dfc))
            break;

        if (DFC_FMT_UNICODE == fCharType)
        {
           // Destination is Unicode and we're reading Unicode data from stream.
           // No conversion required.
           if (FAILED(strTemp.SetSize(dfc.cbText / sizeof(TCHAR))) ||
               FAILED(pstm->Read(strTemp.GetInplaceStr(), dfc.cbText, &cb))
                   || (cb != dfc.cbText))
               break;
        }
        else
        {
           // Destination is Unicode but we're reading ANSI data from stream.
           // Read ansi.  Convert to unicode.
           if (FAILED(strTempA.SetSize(dfc.cbText / sizeof(CHAR))) ||
               FAILED(pstm->Read(strTempA.GetInplaceStr(), dfc.cbText, &cb))
                   || (cb != dfc.cbText))
               break;

           strTemp.SetStr(strTempA);
        }

        switch (dfc.wNum)
        {
        case IDD_FILESPEC:
            lstrcpyn(_szUserInputFileSpec, strTemp, ARRAYSIZE(_szUserInputFileSpec));
            break;

        case DFSC_SEARCHFOR:
            Str_SetPtr(&_pszIndexedSearch, strTemp);
            break;

        case IDD_PATH:
            _ResetRoots();
            lstrcpyn(_szPath, strTemp, ARRAYSIZE(_szPath));
            CreateIEnumIDListPaths(_szPath, &_penumRoots);
            break;

        case IDD_TOPLEVELONLY:
            _fTopLevelOnly = StrToInt(strTemp);
            break;

        case IDD_TYPECOMBO:
            _strTypeFilePatterns.SetStr(strTemp);
            break;

        case IDD_CONTAINS:
            lstrcpyn(_szText, strTemp, ARRAYSIZE(_szText));
            break;

        case IDD_SIZECOMP:
            // we need to extract off the two parts, the type and
            // the value

            _iSizeType = strTemp[0] - TEXT('0');
            StrToInt64Ex(&(strTemp.GetStr())[2], STIF_DEFAULT, (LONGLONG*)&_ullSize);
            break;

        case IDD_MDATE_NUMDAYS:
            _wDateType = DFF_DATE_DAYS;
            _wDateValue = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_NUMMONTHS:
            _wDateType = DFF_DATE_MONTHS;
            _wDateValue = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_FROM:
            _wDateType = DFF_DATE_BETWEEN;
            _dateModifiedAfter = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_TO:
            _wDateType = DFF_DATE_BETWEEN;
            _dateModifiedBefore = (WORD) StrToInt(strTemp);
            break;

        case IDD_MDATE_TYPE:
            // persisted value is zero based, adjust that by adding 1
            MapValueToDateSCID(StrToInt(strTemp) + 1, &_scidDate);
            break;

        case IDD_TEXTCASESEN:
            _fTextCaseSen = StrToInt(strTemp);
            break;

        case IDD_TEXTREG:
            _fTextReg = StrToInt(strTemp);
            break;

        case IDD_SEARCHSLOWFILES:
            _fSearchSlowFiles = StrToInt(strTemp);
            break;
            
        case IDD_SEARCHSYSTEMDIRS:
            _fSearchSystemDirs = StrToInt(strTemp);
            break;
        }
    }
    return S_OK;
}

// IFindFilter::GetColSaveStream

STDMETHODIMP CFindFilter::GetColSaveStream(WPARAM wParam, IStream **ppstm)
{
    *ppstm = OpenRegStream(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, TEXT("DocFindColsX"), (DWORD) wParam);
    return *ppstm ? S_OK : E_FAIL;
}

void CFindFilter::_GenerateQuery(LPWSTR pwszQuery, DWORD *pcchQuery)
{
    DWORD cchNeeded = 0, cchLeft = *pcchQuery;
    LPWSTR pszCurrent = pwszQuery;
    BOOL bFirst = TRUE; // first property

    if (_pszFileSpec && _pszFileSpec[0])
    {
        cchNeeded += _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, _pszFileSpec);
    }

    // fFoldersOnly = TRUE implies szTypeFilePatterns = "."
    // we cannot pass "." to CI because they won't understand it as give me the folder types
    // we could check for @attrib ^a FILE_ATTRIBUTE_DIRECTORY (0x10) but ci doesn't index the 
    // folder names by default so we normally won't get any results...

    if (!_fFoldersOnly && _strTypeFilePatterns[0])
    {
        cchNeeded += _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, _strTypeFilePatterns);
    }
    
    // Date:
    if (_dateModifiedBefore)
    {           
        cchNeeded += _QueryDosDate(&bFirst, &cchLeft, &pszCurrent, _dateModifiedBefore, TRUE);
    }
    
    if (_dateModifiedAfter)
    {
        cchNeeded += _QueryDosDate(&bFirst, &cchLeft, &pszCurrent, _dateModifiedAfter, FALSE);
    }

    if (_iSizeType)
    {
        cchNeeded += _CIQuerySize(&bFirst, &cchLeft, &pszCurrent, _ullSize, _iSizeType);
    }

    // Indexed Search: raw query
    if (_pszIndexedSearch && _pszIndexedSearch[0])
    {
        // HACK Alert if first Char is ! then we assume Raw and pass it through directly to CI...
        // Likewise if it starts with @ or # pass through, but remember the @...
        cchNeeded += _CIQueryIndex(&bFirst, &cchLeft, &pszCurrent, _pszIndexedSearch);
    }

    // Containing Text:
    if (_szText[0])
    {
        // Try not to quote the strings unless we need to.  This allows more flexability to do the
        // searching for example: "cat near dog" is different than: cat near dog
        cchNeeded += _CIQueryTextPatterns(&bFirst, &cchLeft, &pszCurrent, _szText, _fTextReg);
    }

    cchNeeded += _CIQueryShellSettings(&bFirst, &cchLeft, &pszCurrent);

    IEnumIDList *penum;
    if (SUCCEEDED(_ScopeEnumerator(&penum)))
    {
        TCHAR szPath[MAX_PATH];

        LPITEMIDLIST pidl;
        while (S_OK == penum->Next(1, &pidl, NULL))
        {
            if (SHGetPathFromIDList(pidl, szPath) && PathStripToRoot(szPath))
            {
                // don't search recycle bin folder. we add both nt4's recycled 
                // and nt5's recycler for every drive we search.
                static const LPCTSTR s_rgszRecycleBins[] = 
                { 
                    TEXT("Recycled\\*"), 
                    TEXT("Recycler\\*"), 
                };

                for (int iBin = 0; iBin < ARRAYSIZE(s_rgszRecycleBins); iBin++)
                {
                    TCHAR szExclude[MAX_PATH];
                    if (PathCombine(szExclude, szPath, s_rgszRecycleBins[iBin]))
                    {
                        DWORD cchSize = lstrlen(szExclude) + ARRAYSIZE(TEXT(" & !#PATH "));

                        // don't bail out early if we are asked for size of query
                        if (pwszQuery && cchSize > cchLeft)
                            break;

                        cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, TEXT(" & !#PATH "));
                        cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, szExclude);
                    }
                }
            }
            ILFree(pidl);
        }
        penum->Release();
    }

    // we must exclude the special folders from the results or ci will find items that 
    // we cannot get pidls for.
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, CI_SPECIAL_FOLDERS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD cValues = 0; // init to zero in case query info bellow fails
    
        RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, NULL, NULL, NULL, NULL);
        for (DWORD i = 0; i < cValues; i++)
        {
            TCHAR szExcludePath[MAX_PATH];
            DWORD cb = sizeof(szExcludePath);

            TCHAR szName[10];
            wsprintf(szName, TEXT("%d"), i);
            if (RegQueryValueEx(hkey, szName, NULL, NULL, (BYTE *)szExcludePath, &cb) == ERROR_SUCCESS)
            {
                // this is in the query (or a drive letter of the query)

                DWORD cchSize = lstrlen(szExcludePath) + ARRAYSIZE(TEXT(" & !#PATH "));

                // don't bail out early if we are asked for size of query
                if (pwszQuery && cchSize > cchLeft)
                    break;

                cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, TEXT(" & !#PATH "));
                cchNeeded += _AddToQuery(&pszCurrent, &cchLeft, szExcludePath);
            }
        }
        RegCloseKey(hkey);
    }

    // we need at least some constraints so give a query of "all files"

    if (pwszQuery && pszCurrent == pwszQuery)
        _CIQueryFilePatterns(&bFirst, &cchLeft, &pszCurrent, L"*.*");

    if (pszCurrent)
    {
        // Make sure we terminate the string at the end...
        *pszCurrent = 0;
    }

    if (!pwszQuery)
    {
        *pcchQuery = cchNeeded;
    }
    else
    {
        ASSERT(*pcchQuery > cchNeeded);
    }
}

// Create a query command string out of the search criteria

STDMETHODIMP CFindFilter::GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwQueryRestrictions)
{
    // we should be able to make use of ci no matter what (exceptions at the end of the function)
    DWORD dwQueryRestrictions = GQR_MAKES_USE_OF_CI; 
    HRESULT hr = S_OK;

#ifdef DEBUG
    if (GetKeyState(VK_SHIFT) < 0)
    {
        dwQueryRestrictions |= GQR_REQUIRES_CI;
    }
#endif

    if (ppwszQuery)
    {
        DWORD cchNeeded = 0;
        _GenerateQuery(NULL, &cchNeeded);
        cchNeeded++;  // for \0
        
        *ppwszQuery = (LPWSTR)LocalAlloc(LPTR, cchNeeded * sizeof(**ppwszQuery));
        if (*ppwszQuery)
        {
            _GenerateQuery(*ppwszQuery, &cchNeeded);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (_pszIndexedSearch && _pszIndexedSearch[0])
            dwQueryRestrictions |= GQR_REQUIRES_CI;

        // ci is not case sensitive, so if user wanted case sensitive search we cannot use ci
        // also ci doesn't index folder names by default so to be safe we just default to our
        // disk traversal algorithm...
        if (_fTextCaseSen || _fFoldersOnly)
        {    
            if ((dwQueryRestrictions & GQR_REQUIRES_CI) && _fTextCaseSen)
                hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_CASESENINDEX);
            else if (dwQueryRestrictions & GQR_MAKES_USE_OF_CI)
                dwQueryRestrictions &= ~GQR_MAKES_USE_OF_CI;
        }
    }
    *pdwQueryRestrictions = dwQueryRestrictions;  // return calculated Flags...
    return hr;
}

STDMETHODIMP CFindFilter::ReleaseQuery()
{
    ATOMICRELEASE(_penumAsync);
    return S_OK;
}

STDMETHODIMP CFindFilter::GetQueryLanguageDialect(ULONG* pulDialect)
{
    *pulDialect = _ulQueryDialect;
    return S_OK;
}

STDMETHODIMP CFindFilter::GetWarningFlags(DWORD* pdwWarningFlags)
{
    *pdwWarningFlags = _dwWarningFlags;
    return S_OK;
}

// Registering our interest in FS change notifications.
//
// In:
//   hwnd = window handle of the find dialog
//   uMsg = message to be sent to window when informing of notify

STDMETHODIMP CFindFilter::DeclareFSNotifyInterest(HWND hwnd, UINT uMsg)
{
    HDPA hdpa = DPA_Create(10);     // Used to manage list of pidls to add
    if (hdpa)
    {
        IEnumIDList *penum;
        if (SUCCEEDED(_ScopeEnumerator(&penum)))
        {
            LPITEMIDLIST pidl;
            while (S_OK == penum->Next(1, &pidl, NULL))
            {
                if (-1 == DPA_AppendPtr(hdpa, pidl))
                {
                    // Failed to add it, so free it.
                    ILFree(pidl);
                }
            }
            penum->Release();
        }
        // Eliminate any pidls in the hdpa that are children of other pidls.  
        // this is needed to prevent receiving the multiple updates for one change.
        // For example, if searching My Documents and C:\, then we will get 2 updates
        // for a change in My Documents if My Documents is on the C:\.            
        int cItems = DPA_GetPtrCount(hdpa);
        for (int iOuterLoop = 0; iOuterLoop < cItems - 1; iOuterLoop++)
        {
            LPITEMIDLIST pidlOuter = (LPITEMIDLIST) DPA_GetPtr(hdpa, iOuterLoop);
            for (int iInnerLoop = iOuterLoop + 1; 
                 pidlOuter && iInnerLoop < cItems; 
                 iInnerLoop++)
            {
                LPITEMIDLIST pidlInner = (LPITEMIDLIST) DPA_GetPtr(hdpa, iInnerLoop);
                if (pidlInner)
                {
                    if (ILIsParent(pidlInner, pidlOuter, FALSE))
                    {
                        // Since pidlInner is pidlOuter's parent, free pidlOuter and 
                        // don't register for events on it.
                        ILFree(pidlOuter);
                        pidlOuter = NULL;
                        DPA_SetPtr(hdpa, iOuterLoop, NULL);
                    } 
                    else if (ILIsParent(pidlOuter, pidlInner, FALSE))
                    {
                        // Since pidlOuter is pidlInner's parent, free pidlInner and 
                        // don't register for events on it.
                        ILFree(pidlInner);
                        pidlInner = NULL;
                        DPA_SetPtr(hdpa, iInnerLoop, NULL);
                    }
                }
            }
        }
        // Declare that we are interested in events on remaining pidls
        for (int iRegIndex = 0; iRegIndex < cItems; iRegIndex++)
        {
            SHChangeNotifyEntry fsne = {0};
            fsne.fRecursive = TRUE;

            fsne.pidl = (LPITEMIDLIST)DPA_GetPtr(hdpa, iRegIndex);
            if (fsne.pidl)
            {
                SHChangeNotifyRegister(hwnd, 
                                       SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                       SHCNE_DISKEVENTS, uMsg, 1, &fsne);
                ILFree((LPITEMIDLIST)fsne.pidl);
            }
        }

        DPA_Destroy(hdpa);
    }
    return S_OK;
}

void CFindFilter::_UpdateTypeField(const VARIANT *pvar)
{
    LPCWSTR pszValue = VariantToStrCast(pvar);  // input needs to be a BSTR
    if (pszValue)
    {
        if (StrStr(pszValue, TEXT(".Folder;.")))
        {
            // Special searching for folders...
            _fFoldersOnly = TRUE;
            _strTypeFilePatterns.SetStr(TEXT("."));
        }
        else
        {
            // Assume if the first one is wildcarded than all are,...
            if (*pszValue == TEXT('*'))
                _strTypeFilePatterns.SetStr(pszValue);
            else
            {
                TCHAR szNextPattern[MAX_PATH];  // overkill in size
                BOOL fFirst = TRUE;
                LPCTSTR pszNextPattern = pszValue;
                while ((pszNextPattern = NextPath(pszNextPattern, szNextPattern, ARRAYSIZE(szNextPattern))) != NULL)
                {
                    if (!fFirst)
                        _strTypeFilePatterns.Append(TEXT(";"));
                    fFirst = FALSE;

                    if (szNextPattern[0] != TEXT('*'))
                        _strTypeFilePatterns.Append(TEXT("*"));
                    _strTypeFilePatterns.Append(szNextPattern);
                }
            }
        }
    }
}

int _MapConstraint(LPCWSTR pszField)
{
    for (int i = 0; i < ARRAYSIZE(s_cdffuf); i++)
    {
        if (StrCmpIW(pszField, s_cdffuf[i].pwszField) == 0)
        {
            return i;
        }
    }
    return -1;
}

HRESULT CFindFilter::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

HRESULT CFindFilter::UpdateField(LPCWSTR pszField, VARIANT vValue)
{
    _fFilterChanged = TRUE;    // force rebuilding name of files...

    USHORT uDosTime;

    switch (_MapConstraint(pszField))
    {
    case CDFFUFE_IndexedSearch:
        Str_SetPtr(&_pszIndexedSearch, NULL);   // zero this out
        _pszIndexedSearch = VariantToStr(&vValue, NULL, 0);
        break;

    case CDFFUFE_LookIn:
        _ResetRoots();

        if (FAILED(QueryInterfaceVariant(vValue, IID_PPV_ARG(IEnumIDList, &_penumRoots))))
        {
            if (vValue.vt == VT_BSTR)
            {
                VariantToStr(&vValue, _szPath, ARRAYSIZE(_szPath));
                CreateIEnumIDListPaths(_szPath, &_penumRoots);
            }
            else
            {
                LPITEMIDLIST pidl = VariantToIDList(&vValue);
                if (pidl)
                {
                    CreateIEnumIDListOnIDLists(&pidl, 1, &_penumRoots);
                    ILFree(pidl);
                }
            }
        }
        break;

    case CDFFUFE_IncludeSubFolders:
        _fTopLevelOnly = !VariantToBOOL(vValue);   // invert sense
        break;

    case CDFFUFE_Named:
        VariantToStr(&vValue, _szUserInputFileSpec, ARRAYSIZE(_szUserInputFileSpec));
        break;

    case CDFFUFE_ContainingText:
        ZeroMemory(_szText, sizeof(_szText));   // special zero init whole buffer
        VariantToStr(&vValue, _szText, ARRAYSIZE(_szText));
        break;

    case CDFFUFE_FileType:
        _UpdateTypeField(&vValue);
        break;

    case CDFFUFE_WhichDate:
        if (vValue.vt == VT_BSTR)
        {
            IPropertyUI *ppui;
            if (SUCCEEDED(_GetPropertyUI(&ppui)))
            {
                ULONG cch = 0;  // in/out
                ppui->ParsePropertyName(vValue.bstrVal, &_scidDate.fmtid, &_scidDate.pid, &cch);
                ppui->Release();
            }
        }
        else
        {
            MapValueToDateSCID(VariantToInt(vValue), &_scidDate);
        }
        break;

    case CDFFUFE_DateLE:
        _wDateType |= DFF_DATE_BETWEEN;
        VariantToDosDateTime(vValue, &_dateModifiedBefore, &uDosTime); 
        if (_dateModifiedAfter && _dateModifiedBefore)
        {
            if (_dateModifiedAfter > _dateModifiedBefore)
            {
                WORD wTemp = _dateModifiedAfter;
                _dateModifiedAfter = _dateModifiedBefore;
                _dateModifiedBefore = wTemp;
            }
        }
        break;

    case CDFFUFE_DateGE:
        _wDateType |= DFF_DATE_BETWEEN;
        VariantToDosDateTime(vValue, &_dateModifiedAfter, &uDosTime); 
        if (_dateModifiedAfter && _dateModifiedBefore)
        {
            if (_dateModifiedAfter > _dateModifiedBefore)
            {
                WORD wTemp = _dateModifiedAfter;
                _dateModifiedAfter = _dateModifiedBefore;
                _dateModifiedBefore = wTemp;
            }
        }
        break;

    case CDFFUFE_DateNDays:
        _wDateType |= DFF_DATE_DAYS;
        _wDateValue = (WORD)VariantToInt(vValue);
        _dateModifiedAfter = _GetTodaysDosDateMinusNDays(_wDateValue);
        break;

    case CDFFUFE_DateNMonths:
        _wDateType |= DFF_DATE_MONTHS;
        _wDateValue = (WORD)VariantToInt(vValue);
        _dateModifiedAfter = _GetTodaysDosDateMinusNMonths(_wDateValue);
        break;

    case CDFFUFE_SizeLE:
        _iSizeType = 2;
        _ullSize = VariantToULONGLONG(vValue);
        break;

    case CDFFUFE_SizeGE:
        _iSizeType = 1;
        _ullSize = VariantToULONGLONG(vValue);
        break;

    case CDFFUFE_TextCaseSen:
        _fTextCaseSen = VariantToBOOL(vValue);
        break;

    case CDFFUFE_TextReg:
        _fTextReg = VariantToBOOL(vValue);
        break;

    case CDFFUFE_SearchSlowFiles:
        _fSearchSlowFiles = VariantToBOOL(vValue);
        break;

    case CDFFUFE_QueryDialect:
        _ulQueryDialect = VariantToUINT(vValue);
        break;

    case CDFFUFE_WarningFlags:
        _dwWarningFlags = VariantToUINT(vValue);
        break;

    case CDFFUFE_SearchSystemDirs:
        _fSearchSystemDirs = VariantToBOOL(vValue);
        break;

    case CDFFUFE_SearchHidden:
        _fSearchHidden = VariantToBOOL(vValue);
        break;
    }
    return S_OK;
}

void CFindFilter::_ResetRoots()
{
    _szPath[0] = 0;
    ATOMICRELEASE(_penumRoots);
}

HRESULT CFindFilter::ResetFieldsToDefaults()
{
    // Try to reset everything that our UpdateFields may touch to make sure next search gets all

    _ResetRoots();

    _fTopLevelOnly = FALSE;
    _szUserInputFileSpec[0] = 0;
    _szText[0] = 0;
    if (_pszIndexedSearch)
        *_pszIndexedSearch = 0;
    _strTypeFilePatterns.Reset();

    ZeroMemory(&_scidDate, sizeof(_scidDate));
    _scidSize = SCID_SIZE;

    _fFoldersOnly = FALSE;
    _wDateType = 0;
    _dateModifiedBefore = 0;
    _dateModifiedAfter = 0;
    _iSizeType = 0;
    _ullSize = 0;
    _fTextCaseSen = FALSE;
    _fTextReg = FALSE;
    _fSearchSlowFiles = FALSE;
    _ulQueryDialect = ISQLANG_V2;
    _dwWarningFlags = DFW_DEFAULT;
    _fSearchSystemDirs = FALSE;

    // the search UI will usually override this, but if that us has not been updated
    // we need to set out state the same was as before here
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    _fSearchHidden = ss.fShowAllObjects;
    return S_OK;
}

HRESULT CFindFilter::GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound)
{
    *pName = NULL;
    VariantClear(pValue);                            
    *pfFound = FALSE;

    if (fReset)
        _iNextConstraint = 0;

    HRESULT hr = S_FALSE;    // not found

    // we don't go to array size as the last entry is an empty item...
    while (_iNextConstraint < ARRAYSIZE(s_cdffuf))
    {
        switch (s_cdffuf[_iNextConstraint].cdffufe)
        {
        case CDFFUFE_IndexedSearch:
            hr = InitVariantFromStr(pValue, _pszIndexedSearch);
            break;
    
        case CDFFUFE_LookIn:
            hr = InitVariantFromStr(pValue, _szPath);
            break;
    
        case CDFFUFE_IncludeSubFolders:
            hr = InitVariantFromInt(pValue, _fTopLevelOnly ? 0 : 1);
            break;
    
        case CDFFUFE_Named:
            hr = InitVariantFromStr(pValue, _szUserInputFileSpec);
            break;
    
        case CDFFUFE_ContainingText:
            hr = InitVariantFromStr(pValue, _szText);
            break;
    
        case CDFFUFE_FileType:
            hr = InitVariantFromStr(pValue, _strTypeFilePatterns);
            break;

        case CDFFUFE_WhichDate:
            pValue->lVal = MapDateSCIDToValue(&_scidDate);
            if (pValue->lVal)
                hr = InitVariantFromInt(pValue, pValue->lVal);
            break;

        case CDFFUFE_DateLE:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_BETWEEN)
                hr = InitVariantFromDosDateTime(pValue, _dateModifiedBefore, 0);
            break;

        case CDFFUFE_DateGE:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_BETWEEN)
                hr = InitVariantFromDosDateTime(pValue, _dateModifiedAfter, 0); 
            break;

        case CDFFUFE_DateNDays:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_DAYS)
                hr = InitVariantFromInt(pValue, _wDateValue);
            break;

        case CDFFUFE_DateNMonths:
            if ((_wDateType & DFF_DATE_RANGEMASK) == DFF_DATE_MONTHS)
                hr = InitVariantFromInt(pValue, _wDateValue);
            break;

        case CDFFUFE_SizeLE:
            if (_iSizeType == 2)
                hr = InitVariantFromULONGLONG(pValue, _ullSize);
            break;

        case CDFFUFE_SizeGE:
            if (_iSizeType == 1)
                hr = InitVariantFromULONGLONG(pValue, _ullSize);
            break;

        case CDFFUFE_TextCaseSen:
            hr = InitVariantFromInt(pValue, _fTextCaseSen ? 1 : 0);
            break;

        case CDFFUFE_TextReg:
            hr = InitVariantFromInt(pValue, _fTextReg ? 1 : 0);
            break;

        case CDFFUFE_SearchSlowFiles:
            hr = InitVariantFromInt(pValue, _fSearchSlowFiles ? 1 : 0);
            break;

        case CDFFUFE_QueryDialect:
            hr = InitVariantFromUINT(pValue, _ulQueryDialect);
            break;

        case CDFFUFE_WarningFlags:
            hr = InitVariantFromUINT(pValue, _dwWarningFlags);
            break;

        case CDFFUFE_SearchSystemDirs:
            hr = InitVariantFromUINT(pValue, _fSearchSystemDirs ? 1 : 0);
            break;

        case CDFFUFE_SearchHidden:
            hr = InitVariantFromUINT(pValue, _fSearchHidden ? 1 : 0);
            break;
        }

        if (S_OK == hr)
            break;

        if (SUCCEEDED(hr))
            VariantClear(pValue);

        _iNextConstraint += 1;
    }

    if (S_OK == hr)
    {
        *pName = SysAllocString(s_cdffuf[_iNextConstraint].pwszField);
        if (NULL == *pName)
        {
            VariantClear(pValue);                            
            hr = E_OUTOFMEMORY;
        }
        else
            *pfFound = TRUE;

        _iNextConstraint += 1; // for the next call here
    }
    return hr;    // no error let script use the found field...
}


DWORD CFindFilter::_AddToQuery(LPWSTR *ppszBuf, DWORD *pcchBuf, LPWSTR pszAdd)
{
    DWORD cchAdd = lstrlenW(pszAdd);

    if (*ppszBuf && *pcchBuf > cchAdd)
    {
        StrCpyNW(*ppszBuf, pszAdd, *pcchBuf);
        *pcchBuf -= cchAdd;
        *ppszBuf += cchAdd;
    }
    return cchAdd;
}


DWORD AddQuerySep(DWORD *pcchBuf, LPWSTR *ppszCurrent, WCHAR  bSep)
{
    LPWSTR pszCurrent = *ppszCurrent;
    // make sure we have room for us plus terminator...
    if (*ppszCurrent && *pcchBuf >= 4)
    {
        *pszCurrent++ = L' ';
        *pszCurrent++ = bSep;
        *pszCurrent++ = L' ';

        *ppszCurrent = pszCurrent;
        *pcchBuf -= 3;
    }
    return 3; // size necessary
}


DWORD PrepareQueryParam(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent)
{
    if (*pbFirst)
    {
        *pbFirst = FALSE;
        return 0;  // no size necessary
    }
        
    // we're not the first property
    return AddQuerySep(pcchBuf, ppszCurrent, L'&');
}

// pick the longest date query so we can avoid checking the buffer size each time we
// add something to the string
#define LONGEST_DATE  50 //lstrlen(TEXT("{prop name=access} <= 2000/12/31 23:59:59{/prop}"))+2

DWORD CFindFilter::_QueryDosDate(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, WORD wDate, BOOL bBefore)
{
    LPWSTR pszCurrent = *ppszCurrent;
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, &pszCurrent);
    
    if (pszCurrent && *pcchBuf > LONGEST_DATE)
    {
        FILETIME ftLocal;
        DosDateTimeToFileTime(wDate, 0, &ftLocal);
        FILETIME ftGMT;
        LocalFileTimeToFileTime(&ftLocal, &ftGMT);
        SYSTEMTIME st;
        FileTimeToSystemTime(&ftGMT, &st);

        IPropertyUI *ppui;
        if (SUCCEEDED(_GetPropertyUI(&ppui)))
        {
            WCHAR szName[128];
            if (SUCCEEDED(ppui->GetCannonicalName(_scidDate.fmtid, _scidDate.pid, szName, ARRAYSIZE(szName))))
            {
                 wnsprintfW(pszCurrent, *pcchBuf, L"{prop name=%s} ", szName);
                 // the date syntax we use is V2, so force this dialect
                _ulQueryDialect = ISQLANG_V2;
            }
            ppui->Release();
        }

        pszCurrent += lstrlenW(pszCurrent);
        if (bBefore)
        {
            *pszCurrent++ = L'<';
            // if you ask for a range like: 2/20/98 - 2/20/98 then we get no time at all
            // So for before, convert H:m:ss to 23:59:59...
            st.wHour = 23;
            st.wMinute = 59; 
            st.wSecond = 59;
        }
        else
        {
            *pszCurrent++ = L'>';
        }
        
        *pszCurrent++ = L'=';

        wnsprintfW(pszCurrent, *pcchBuf, L" %d/%d/%d %d:%d:%d{/prop}", st.wYear, st.wMonth, st.wDay,
            st.wHour, st.wMinute, st.wSecond);
        pszCurrent += lstrlenW(pszCurrent);
        
        *ppszCurrent = pszCurrent;
        *pcchBuf -= LONGEST_DATE;
    }
    return cchNeeded + LONGEST_DATE;
}

DWORD CFindFilter::_CIQueryFilePatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPCWSTR pszFilePatterns)
{
    WCHAR szNextPattern[MAX_PATH];  // overkill in size
    BOOL fFirst = TRUE;
    LPCWSTR pszNextPattern = pszFilePatterns;
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    // Currently will have to long hand the query, may try to find shorter format once bugs
    // are fixed...
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"(");
    while ((pszNextPattern = NextPathW(pszNextPattern, szNextPattern, ARRAYSIZE(szNextPattern))) != NULL)
    {
        if (!fFirst)
        {
            cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L" | ");
        }
        fFirst = FALSE;
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"#filename ");
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, szNextPattern);
    }
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L")");
    return cchNeeded;
}


DWORD CFindFilter::_CIQueryTextPatterns(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText, BOOL bTextReg)
{
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"{prop name=all}");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, bTextReg? L"{regex}" : L"{phrase}");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, pszText);
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, bTextReg? L"{/regex}{/prop}" : L"{/phrase}{/prop}");

    return cchNeeded;
}

DWORD CFindFilter::_CIQuerySize(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, ULONGLONG ullSize, int iSizeType)
{
    WCHAR szSize[MAX_ULONGLONG_LEN+8]; // +8 for " {/prop}"
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"{prop name=size} ");
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, iSizeType == 1? L">" : L"<");
            
    WCHAR szNum[MAX_ULONGLONG_LEN];
    Int64ToString(ullSize, szNum, ARRAYSIZE(szNum), FALSE, NULL, 0);
    wnsprintfW(szSize, *pcchBuf, L" %ws{/prop}", szNum);
    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, szSize);

    return cchNeeded;
}

DWORD CFindFilter::_CIQueryIndex(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent, LPWSTR pszText)
{
    DWORD cchNeeded = PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);

    cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, pszText);
    return cchNeeded;
}

DWORD CFindFilter::_CIQueryShellSettings(BOOL *pbFirst, DWORD *pcchBuf, LPWSTR *ppszCurrent)
{
    DWORD cchNeeded = 0;
    
    if (!ShowSuperHidden())
    {
        cchNeeded += PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"NOT @attrib ^a 0x6 ");// don't show files w/ hidden and system bit on
    }

    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    if (!ss.fShowAllObjects)
    {
        cchNeeded += PrepareQueryParam(pbFirst, pcchBuf, ppszCurrent);
        cchNeeded += _AddToQuery(ppszCurrent, pcchBuf, L"NOT @attrib ^a 0x2 "); // don't show files w/ hidden bit on
    }
    return cchNeeded;
}


//  Helper function to add the PIDL from theCsidl to the exclude tree.
void _AddSystemDirCSIDLToPidlTree(int csidl, CIDLTree *ppidlTree)
{
    LPITEMIDLIST pidl = SHCloneSpecialIDList(NULL, csidl, TRUE);
    if (pidl)
    {
        ppidlTree->AddData(IDLDATAF_MATCH_RECURSIVE, pidl, EXCLUDE_SYSTEMDIR);
        ILFree(pidl);
    }
}


CNamespaceEnum::CNamespaceEnum(IFindFilter *pfilter, IShellFolder* psf, 
                               IFindEnum *penumAsync, IEnumIDList *penumScopes, 
                               HWND hwnd, DWORD grfFlags, LPTSTR pszProgressText) :   
    _cRef(1), _pfilter(pfilter), _iFolder(-1), _hwnd(hwnd), _grfFlags(grfFlags), 
    _pszProgressText(pszProgressText), _penumAsync(penumAsync)
{
    ASSERT(NULL == _psf);
    ASSERT(NULL == _pidlFolder);
    ASSERT(NULL == _pidlCurrentRootScope);
    ASSERT(NULL == _penum);

    if (penumScopes)
        penumScopes->Clone(&_penumScopes);

    _pfilter->AddRef();
    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
    ASSERT(_pff);

    if (_penumAsync) 
        _penumAsync->AddRef();

    // Setup the exclude system directories:
    if (!(_grfFlags & DFOO_SEARCHSYSTEMDIRS))
    {
        // IE History and cache are excluded based on the CLSID.
        _AddSystemDirCSIDLToPidlTree(CSIDL_WINDOWS, &_treeExcludeFolders);
        _AddSystemDirCSIDLToPidlTree(CSIDL_PROGRAM_FILES, &_treeExcludeFolders);

        //  Exclude Temp folder
        TCHAR szPath[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(szPath), szPath))
        {
            LPITEMIDLIST pidl = ILCreateFromPath(szPath);
            if (pidl)
            {   
                _treeExcludeFolders.AddData(IDLDATAF_MATCH_RECURSIVE, pidl, EXCLUDE_SYSTEMDIR);
                ILFree(pidl);
            }
        }
    }
}

CNamespaceEnum::~CNamespaceEnum()
{
    ATOMICRELEASE(_penumScopes);

    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_penumAsync);
    ATOMICRELEASE(_pff);

    ILFree(_pidlFolder);    // accepts NULL
    ILFree(_pidlCurrentRootScope);
}

STDMETHODIMP CNamespaceEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
//        QITABENT(CNamespaceEnum, IFindEnum),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNamespaceEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNamespaceEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// Check if the relative pidl passed is to a folder that we are going 
// skip based on its CLSID:
// This will be used to skip IE History and IE Cache.
BOOL CNamespaceEnum::_IsSystemFolderByCLSID(LPCITEMIDLIST pidl)
{
    BOOL bRetVal = FALSE;
    IShellFolder2 *psf2;
    if (_psf && SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        CLSID clsid;
        if (SUCCEEDED(GetItemCLSID(psf2, pidl, &clsid)))
        {
            if (IsEqualCLSID(clsid, CLSID_CacheFolder) ||
                IsEqualCLSID(clsid, CLSID_CacheFolder2) ||
                IsEqualCLSID(clsid, CLSID_HistFolder))
            {
                bRetVal = TRUE;
            }
        }  
        psf2->Release();
    }
    return bRetVal;
}

// given the fact that a file is a directory, is this one we should search???

BOOL CNamespaceEnum::_ShouldPushItem(LPCITEMIDLIST pidl)
{
    BOOL bShouldPush = FALSE;
    TCHAR szName[MAX_PATH];

    // folders only, not folder shortcuts (note, this includes SFGAO_STREAM objects, .zip/.cab files)
    // skip all folders that start with '?'. these are folders that the names got trashed in some
    // ansi/unicode round trip. this avoids problems in the web folders name space

    if (SFGAO_FOLDER == SHGetAttributes(_psf, pidl, SFGAO_FOLDER | SFGAO_LINK) &&
        SUCCEEDED(DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))) &&
        (TEXT('?') != szName[0]))
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidlFolder, pidl);
        if (pidlFull)
        {
            INT_PTR i = 0;
            
            // Check if the folder is in the exclude list because it has been searched
            HRESULT hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, pidlFull, &i, NULL);

            if (FAILED(hr))
            {
                // see if an alias version of this pidl is exists
                LPITEMIDLIST pidlAlias = SHLogILFromFSIL(pidlFull);
                if (pidlAlias)
                {
                    hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, pidlAlias, &i, NULL);
                    ILFree(pidlAlias);
                }
            }

            if (FAILED(hr))
            {
                // If we still think it should be added, check if we can reject it based
                // on its CSILD.  We will only exclude system folders this way.
                bShouldPush = (_grfFlags & DFOO_SEARCHSYSTEMDIRS) || 
                              (!_IsSystemFolderByCLSID(pidl));
            }
            else if (i == EXCLUDE_SYSTEMDIR)
            {
                //  If it is under a system directory exclude, check to see if it is the 
                //  directory or a sub directory.  We want to exclude the exact directory
                //  so that we don't add a system directory to the list of things to search.
                //  Since we may have specified the directory in the list of places to search
                //  and therefore want to search it, we don't want to exclude sub directories 
                //  that way.
                hr = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_EXACT, pidlFull, &i, NULL);
                if (FAILED(hr))
                {
                    //  If we get here, it means that pidlFull is a sub directory of a 
                    //  system directory which was searched because it was explicitly
                    //  specified in the list of scopes to search.  Therefore we want
                    //  to continue to search the sub directories.
                    bShouldPush = TRUE;
                }
            } 
            else
            {
                // It matched an item in the tree and was not EXCLUDE_SYSTEMDIR:
                ASSERT(i == EXCLUDE_SEARCHED);
            }
            
            ILFree(pidlFull);
        }
    }

    return bShouldPush;
}

IShellFolder *CNamespaceEnum::_NextRootScope()
{
    IShellFolder *psf = NULL;

    if (_penumScopes)
    {
        LPITEMIDLIST pidl;
        if (S_OK == _penumScopes->Next(1, &pidl, NULL))
        {
            SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf));
            ILFree(pidl);
        }
    }
    return psf;
}

STDMETHODIMP CNamespaceEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, 
                                  int *pcFoldersSearched, BOOL *pfContinue, int *piState)
{
    *ppidl = NULL;
    *piState = GNF_NOMATCH;
    HRESULT hrRet = S_FALSE;
    
    while (S_OK != hrRet && *pfContinue)
    {
        // Retrieve an enumerator if we don't already have one.
        while (NULL == _penum)
        {
            // Indicates that we have taken scope from _penumScopes
            BOOL fUseRootScope = FALSE;

            ASSERT(NULL == _psf);

            // first try popping subdirs off folder stack

            _psf = _queSubFolders.Remove();

            // If there are no folders pushed, then try to get on from the caller.. (root scopes)
            if (NULL == _psf) 
            {
                // Since we are getting a new root scope, add old one to exclude list
                if (_pidlCurrentRootScope)
                {                
                    // Add to exclude List.
                    if (_grfFlags & DFOO_INCLUDESUBDIRS)
                    {
                        // Since all sub directories will be search, don't search again.
                        _treeExcludeFolders.AddData(IDLDATAF_MATCH_RECURSIVE, _pidlCurrentRootScope, EXCLUDE_SEARCHED);
                    }
                    else
                    {
                        // Since sub directories have not been search, allow them to be searched.
                        _treeExcludeFolders.AddData(IDLDATAF_MATCH_EXACT, _pidlCurrentRootScope, EXCLUDE_SEARCHED);
                    }

                    ILFree(_pidlCurrentRootScope);
                    _pidlCurrentRootScope = NULL;
                }
            
                // Get scope from list passed in from caller (root scopes)
                _psf = _NextRootScope();

                fUseRootScope = TRUE;
            }
            
            if (_psf)
            {
                HRESULT hrT = SHGetIDListFromUnk(_psf, &_pidlFolder);

                if (SUCCEEDED(hrT) && fUseRootScope)
                {
                    // Check if the pidl is in the tree
                    INT_PTR i = 0;
                    HRESULT hrMatch = _treeExcludeFolders.MatchOne(IDLDATAF_MATCH_RECURSIVE, _pidlFolder, &i, NULL);
  
                    // If we have a new root scope, set that up as current root scope pidl:
                    // We only want to skip pidls from the queue of "root" search scopes
                    // if they have already been searched.  We do not want to exclude a directory
                    // (from exclude system directories) if it is an explicit search scope.
                    if (FAILED(hrMatch) || i == EXCLUDE_SYSTEMDIR)
                    {
                        ASSERT(_pidlCurrentRootScope == NULL);
                        _pidlCurrentRootScope = ILClone(_pidlFolder);
                    }
                    else
                    {
                        // Since the PIDL is in the exclude tree, we do not want to search it.
                        hrT = E_FAIL;
                    }
                }

                if (SUCCEEDED(hrT))
                {
                    //  Check that we have a pidl, that it is not to be excluded, and that it can
                    //  be enumerated.

                    SHCONTF contf = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
                    if (_grfFlags & DFOO_SHOWALLOBJECTS) 
                        contf |= SHCONTF_INCLUDEHIDDEN;
                    hrT = _psf->EnumObjects(_hwnd, contf, &_penum);

                    // only do UI on the first enum, all others are silent
                    // this makes doing search on A:\ produce the insert media
                    // prompt, but searching MyComputer does not prompt for all
                    // empty media
                    _hwnd = NULL;   

                    if (S_OK == hrT)
                    {
                        SHGetNameAndFlags(_pidlFolder, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, _pszProgressText, MAX_PATH, NULL);
                        (*pcFoldersSearched)++;
                    }
                }

                // Check for cleaning up...
                if (hrT != S_OK)
                {
                    ASSERT(NULL == _penum);
                    ATOMICRELEASE(_psf);    // and continue...
                    ILFree(_pidlFolder);
                    _pidlFolder = NULL;
                }
            }
            else // no scope
            {
                *piState = GNF_DONE;
                return hrRet;
            }
        }

        // Retrieve item
        LPITEMIDLIST pidl;
        HRESULT hrEnum = S_FALSE;

        while ((S_OK != hrRet) && *pfContinue && (S_OK == (hrEnum = _penum->Next(1, &pidl, NULL))))
        {
            (*pcObjectSearched)++;

            //  Determine if this is a subfolder that should be recursively searched.
            if (_grfFlags & DFOO_INCLUDESUBDIRS)
            {
                if (_ShouldPushItem(pidl))
                {
                    // queue folder to stack of subfolders to be searched in the next round.
                    _queSubFolders.Add(_psf, pidl);
                }
            }

            //  Test item against search criteria:
            if (_pfilter->MatchFilter(_psf, pidl))
            {
                // folder has not been registered with docfind folder?
                if (_iFolder < 0)
                {
                    // add folder to folder list.
                    _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
                    ASSERT(_iFolder >= 0);
                }
                
                // add docfind goo to pidl
                hrRet = _pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl);
                if (SUCCEEDED(hrRet))
                    *piState = GNF_MATCH;
            }
            else
            {
                ASSERT(GNF_NOMATCH == *piState);
                hrRet = S_OK;   // exit loop, without a match
            }
            ILFree(pidl);
        }


        if (!*pfContinue)
        {
            *piState = GNF_DONE;
            hrEnum = S_FALSE;
        }
        
        if (S_OK != hrEnum)
        {
            // Done enumerating this folder - clean up for next iteration; or..
            // Failed miserably - clean up prior to bail.
            ATOMICRELEASE(_penum);
            ATOMICRELEASE(_psf);
            ILFree(_pidlFolder);
            _pidlFolder = NULL;
            _iFolder = -1;
        }
    }
    return hrRet;
}

STDMETHODIMP CNamespaceEnum::StopSearch()
{
    if (_penumAsync)
        return _penumAsync->StopSearch();
    return E_NOTIMPL;
}

STDMETHODIMP_(BOOL) CNamespaceEnum::FQueryIsAsync()
{
    if (_penumAsync)
        return DF_QUERYISMIXED;    // non-zero special number to say both...
    return FALSE;
}

STDMETHODIMP CNamespaceEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    if (_penumAsync)
        return _penumAsync->GetAsyncCount(pdwTotalAsync, pnPercentComplete, pfQueryDone);

    *pdwTotalAsync = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    if (_penumAsync)
        return _penumAsync->GetItemIDList(iItem, ppidl);

    *ppidl = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::GetItemID(UINT iItem, DWORD *puWorkID)
{
    if (_penumAsync)
        return _penumAsync->GetItemID(iItem, puWorkID);

    *puWorkID = (UINT)-1;
    return E_NOTIMPL;
}

STDMETHODIMP CNamespaceEnum::SortOnColumn(UINT iCol, BOOL fAscending)
{
    if (_penumAsync)
        return _penumAsync->SortOnColumn(iCol, fAscending);

    return E_NOTIMPL;
}


// Masks used to indicate which search operation we are doing.
#define AND_MASK            0x01
#define OR_MASK             0x02
#define SEMICOLON_MASK      0x04
#define COMMA_MASK          0x08
#define EXTENSION_MASK      0x10

// Both "*" and "?" are treated as wildcards.

BOOL SetupWildCardingOnFileSpec(LPTSTR pszSpecIn, LPTSTR *ppszSpecOut)
{
    LPTSTR pszIn = pszSpecIn;
    BOOL fQuote;
    TCHAR szSpecOut[3*MAX_PATH];   // Rather large...

    // Read in localized versions of AND/OR used for searching
    TCHAR szAND[20];
    LoadString(HINST_THISDLL, IDS_FIND_AND, szAND, ARRAYSIZE(szAND));
    TCHAR szOR[20];
    LoadString(HINST_THISDLL, IDS_FIND_OR, szOR, ARRAYSIZE(szOR));

    // Masks and variable to indicate what operation we are going to perform.
    UINT iOperation  = 0;      // Bitmask to store which operation we have selected.

    // allocate a buffer that should be able to hold the resultant
    // string.  When all is said and done we'll re-allocate to the
    // correct size.

    LPTSTR pszOut = szSpecOut;
    while (*pszIn != 0)
    {
        TCHAR  c;                       // The delimiter.
        LPTSTR pszT;
        int    ich;

        // Strip in leading spaces out of there
        while (*pszIn == TEXT(' '))
            pszIn++;

        if (*pszIn == 0)
            break;

        // If we are beyond the first item, add a seperator between the tokens
        if (pszOut != szSpecOut)
            *pszOut++ = TEXT(';');
        
        fQuote = (*pszIn == TEXT('"'));
        if (fQuote)
        {
            // The user asked for something litteral.
           pszT = pszIn = CharNext(pszIn);
           while (*pszT && (*pszT != TEXT('"')))
               pszT = CharNext(pszT);
        }
        else
        {
            pszT = pszIn + (ich = StrCSpn(pszIn, TEXT(",; \""))); // Find end of token
        }

        c = *pszT;       // Save away the seperator character that was found
        *pszT = 0;       // Add null so string functions will work and only extract the token

        // Put in a couple of tests for * and *.*
        if ((lstrcmp(pszIn, c_szStar) == 0) ||
            (lstrcmp(pszIn, c_szStarDotStar) == 0))
        {
            // Complete wild card so set a null criteria
            *pszT = c;              // Restore char;
            pszOut = szSpecOut;     // Set to start of string
            break;
        }
        
        if (fQuote)
        {
            lstrcpy(pszOut, pszIn);
            pszOut += lstrlen(pszIn);
        }
        else if (lstrcmpi(pszIn, szAND) == 0)
        {
            iOperation |= AND_MASK;
            // If we don't move back one character, then "New and folder" will give:
            // "*New*;;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;
        }
        else if (lstrcmpi(pszIn, szOR) == 0)
        {
            iOperation |= OR_MASK;
            // If we don't move back one character, then "New or folder" will give:
            // "*New*;;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;
        }
        else if (*pszIn == 0)
        {
            // If we don't move back one character, then "New ; folder" will give:
            // "*New*;**;*folder*"
            if (pszOut != szSpecOut)
                --pszOut;

            // Check what the seperator is.  This handles instances like
            // ("abba" ; "abba2") where we want an OR search.
            if (c == TEXT(','))
            {
                iOperation |= COMMA_MASK;
            }
            else if (c == TEXT(';'))
            {
                iOperation |= SEMICOLON_MASK;
            }
        }
        else
        {
            // Check what the seperator is:
            if (c == TEXT(','))
            {
                iOperation |= COMMA_MASK;
            }
            else if (c == TEXT(';'))
            {
                iOperation |= SEMICOLON_MASK;
            }
        
            // both "*" and "?" are wildcards.  When checking for wildcards check
            // for both before we conclude there are no wildcards.  If a search
            // string contains both "*" and "?" then we need for pszStar to point
            // to the last occorance of either one (this is assumed in the code
            // below which will add a ".*" when pszStar is the last character).
            // NOTE: I wish there was a StrRPBrk function to do this for me.
            LPTSTR pszStar = StrRChr(pszIn, NULL, TEXT('*'));
            LPTSTR pszAnyC = StrRChr(pszIn, NULL, TEXT('?'));
            if (pszAnyC > pszStar)
                pszStar = pszAnyC;
            if (pszStar == NULL)
            {
                // No wildcards were used:
                *pszOut++ = TEXT('*');
                lstrcpy(pszOut, pszIn);
                pszOut += ich;
                *pszOut++ = TEXT('*');
            }
            else
            {
                // Includes wild cards
                lstrcpy(pszOut, pszIn);
                pszOut += ich;

                pszAnyC = StrRChr(pszIn, NULL, TEXT('.'));
                if (pszAnyC)
                {
                    // extension present, that implies OR search
                    iOperation |= EXTENSION_MASK;
                }
                else
                {
                    // No extension is given
                    if ((*(pszStar+1) == 0) && (*pszStar == TEXT('*')))
                    {
                        // The last character is an "*" so this single string will
                        // match everything you would expect.
                    }
                    else
                    {
                        // Before, given "a*a" we searched for "a*a" as well
                        // as "a*a.*".  We can no longer do that because if we are
                        // doing an AND search, it will exclude any item that does not
                        // match both of the criterial.  For example, "abba" mattches
                        // "a*a" but not "a*a.*" and "abba.txt" matches "a*a.*" but
                        // not "a*a".  Therefore, we append an * to get "a*a*".  This 
                        // will match files like "abba2.wav" which wouldn't previously
                        // have been matched, but it is a small price to pay.
                        *pszOut++ = TEXT('*');  
                    }
                }
            }
        }

        *pszT = c;  // Restore char;
        if (c == 0)
            break;

        // Skip the seperator except if we weren't quoting and the seperator is 
        // a '"' then we found something like (blah"next tag")
        if (*pszT != 0 && !(*pszT == TEXT('"') && !fQuote))
            pszT++;
            
        pszIn = pszT;   // setup for the next item
    }
    
    // Ensure the string is terminated
    *pszOut++ = 0;

    // re-alloc the buffer down to the actual size of the string...
    Str_SetPtr(ppszSpecOut, szSpecOut);
    
    //  Precidence rules to be applied in order:
    //  1. ;        -> OR search
    //  2. AND      -> AND search 
    //  3. , or OR  -> OR search
    //  4. none & explict file extensions -> OR search (files can only have one extension)
    //  5. none     -> AND search
    //  
    //
    // AND   OR  ;   ,   | AND Search
    //  X    X   1   X   |     0
    //  1    X   0   X   |     1
    //  0    \   0   \   |     0    Where one if the '\'s is 1
    //  0    0   0   0   |     1
    return (!(iOperation & SEMICOLON_MASK) && (iOperation & AND_MASK)) || iOperation == 0;
}

WORD CFindFilter::_GetTodaysDosDateMinusNDays(int nDays)
{
    SYSTEMTIME st;
    union
    {
        FILETIME ft;
        LARGE_INTEGER li;
    }ftli;

    WORD FatTime = 0, FatDate = 0;

    // Now we need to
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftli.ft);
    FileTimeToLocalFileTime(&ftli.ft, &ftli.ft);

    // Now decrement the file time by the count of days * the number of
    // 100NS time units per day.  Assume that nDays is positive.
    if (nDays > 0)
    {
        #define NANO_SECONDS_PER_DAY 864000000000
        ftli.li.QuadPart = ftli.li.QuadPart - ((__int64)nDays * NANO_SECONDS_PER_DAY);
    }

    FileTimeToDosDateTime(&ftli.ft, &FatDate, &FatTime);
    DebugMsg(DM_TRACE, TEXT("DocFind %d days = %x"), nDays, FatDate);
    return FatDate;
}

WORD CFindFilter::_GetTodaysDosDateMinusNMonths(int nMonths)
{
    SYSTEMTIME st;
    FILETIME ft;
    WORD FatTime, FatDate;

    GetSystemTime(&st);
    st.wYear -= (WORD) nMonths / 12;
    nMonths = nMonths % 12;
    if (nMonths < st.wMonth)
        st.wMonth -= (WORD) nMonths;
    else
    {
        st.wYear--;
        st.wMonth = (WORD)(12 - (nMonths - st.wMonth));
    }

    // Now normalize back to a valid date.
    while (!SystemTimeToFileTime(&st, &ft))
    {
        st.wDay--;  // must not be valid date for month...
    }

    if (!FileTimeToLocalFileTime(&ft, &ft) || !FileTimeToDosDateTime(&ft, &FatDate,&FatTime))
        FatDate = 0; //search for all the files from beginning of time (better to find more than less)
        
    DebugMsg(DM_TRACE, TEXT("DocFind %d months = %x"), nMonths, FatDate);
    return FatDate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fldsets.c ===
#include "shellprv.h"
#pragma  hdrstop

#define GUIDSIZE  (GUIDSTR_MAX+1)

//
// This function uses SHGetIniStringUTF7 to access the string, so it is valid
// to use SZ_CANBEUNICODE on the key name.
//
HRESULT SHGetSetFolderSetting(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
                              LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize)
{
    HRESULT hr = S_OK;
    //They just want to read.
    if (dwReadWrite == FCS_READ)
    {
        if (pszValue)
        {
            if (!SHGetIniStringUTF7(pszSection,pszKey, pszValue, cchValueSize, pszIniFile))
                hr = E_FAIL;
        }

    }        
    //They want to write the value regardless whether the value is already there or not.
    if (dwReadWrite == FCS_FORCEWRITE)
    {
        SHSetIniStringUTF7(pszSection, pszKey, pszValue, pszIniFile);
    }

    //Write only if the value is not already present.
    if (dwReadWrite == FCS_WRITE)
    {
        TCHAR szBuf[MAX_PATH];
        BOOL fWrite = TRUE;

        szBuf[0] = 0;
        //See if the value already exists ?
        SHGetIniStringUTF7(pszSection,pszKey, szBuf, ARRAYSIZE(szBuf), pszIniFile);

        if (!szBuf[0])
        {            
            //Write only if the value is not already in the file
            SHSetIniStringUTF7(pszSection, pszKey, pszValue, pszIniFile);
        }
    }

    return hr;
}

// SHGetSetFolderSetting for path values
HRESULT SHGetSetFolderSettingPath(LPCTSTR pszIniFile, DWORD dwReadWrite, LPCTSTR pszSection,
                                  LPCTSTR pszKey, LPTSTR pszValue, DWORD cchValueSize)
{
    HRESULT hr;
    TCHAR szTemp[MAX_PATH], szTemp2[MAX_PATH];
    if ((dwReadWrite == FCS_FORCEWRITE) || (dwReadWrite == FCS_WRITE))  // We write
    {
        if (pszValue)
        {
            lstrcpyn(szTemp, pszValue, ARRAYSIZE(szTemp));
            hr = SubstituteWebDir(szTemp, ARRAYSIZE(szTemp));
            if (SUCCEEDED(hr))
            {
                if (PathUnExpandEnvStrings(szTemp, szTemp2, ARRAYSIZE(szTemp2)))
                {
                    pszValue = szTemp2;
                }
                else
                {
                    pszValue = szTemp;
                }
            }
            else
            {
                // some problem substituting due to not enough buffer space,
                // lets not un-expand that value - use the original value.
            }
        }
        hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, pszSection, pszKey, pszValue, 0);
    }
    else
    {
        hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, pszSection, pszKey, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))    // We've read a path
        {
            SHExpandEnvironmentStrings(szTemp, pszValue, cchValueSize);   // This is a path, so expand the env vars in it

            hr = ExpandOtherVariables(pszValue, cchValueSize);  // expand and make sure they fit
        }
    }
    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetLogo(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_LOGO)
    {
        hr =  SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("Logo"),
                                     pfcs->pszLogo, pfcs->cchLogo);
    }
    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetInfoTip(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_INFOTIP)
    {
        hr =  SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("InfoTip"),
                                pfcs->pszInfoTip, pfcs->cchInfoTip);
    }

    return hr;
}

// Read/write desktop.ini settings
HRESULT SHGetSetIconFile(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_ICONFILE)
    {
        hr =  SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), SZ_CANBEUNICODE TEXT("IconFile"),
                                      pfcs->pszIconFile, pfcs->cchIconFile);
    }
    return hr;
}

  
// Read/write desktop.ini settings
HRESULT SHGetSetVID(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szVID[GUIDSIZE];

    if (pfcs->dwMask & FCSM_VIEWID)
    {
        if (dwReadWrite == FCS_READ)
        {
            if (pfcs->pvid)
            {
                hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), TEXT("Default"),
                                             szVID, ARRAYSIZE(szVID));
                if (hr == S_OK)
                    SHCLSIDFromString(szVID, pfcs->pvid);
            }
        }
        else if (pfcs->pvid)
        {
            SHStringFromGUID(pfcs->pvid, szVID, ARRAYSIZE(szVID));
            SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), TEXT("Default"),
                                              szVID, ARRAYSIZE(szVID));        
            hr =  SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), szVID,
                                              szVID, ARRAYSIZE(szVID));        
        }
        else
        {
            // if we get here we assume that they want to nuke the whole section
            if(0 != WritePrivateProfileString(TEXT("ExtShellFolderViews"), NULL, NULL, pszIniFile))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetCLSID(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szCLSID[GUIDSIZE];

    if (pfcs->dwMask & FCSM_CLSID)
    {
        if (dwReadWrite == FCS_READ)
        {
            if (pfcs->pclsid)
            {
                SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  szCLSID, ARRAYSIZE(szCLSID));        
                hr = SHCLSIDFromString(szCLSID, pfcs->pclsid);
            }
        }
        else if (pfcs->pclsid)
        {
            SHStringFromGUID(pfcs->pclsid, szCLSID, ARRAYSIZE(szCLSID));
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  szCLSID, ARRAYSIZE(szCLSID));        
        }
        else
        {
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("CLSID2"),
                                                  NULL, 0);        
        }

    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetFlags(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    HRESULT hr = S_FALSE;
    TCHAR szFlags[20];

    if (pfcs->dwMask & FCSM_FLAGS)
    {
        if (dwReadWrite == FCS_READ)
        {
           hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("Flags"),
                                           szFlags, ARRAYSIZE(szFlags));        
           pfcs->dwFlags = StrToInt(szFlags);
        }
        else
        {
            wnsprintf(szFlags, ARRAYSIZE(szFlags), TEXT("%d"), (int)pfcs->dwFlags);
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("Flags"),
                                                szFlags, ARRAYSIZE(szFlags));        
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetIconIndex(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    TCHAR szIconIndex[20];
    HRESULT hr = S_FALSE;

    if (pfcs->dwMask & FCSM_ICONFILE)
    {
        if (dwReadWrite == FCS_READ)
        {
           hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                           szIconIndex, ARRAYSIZE(szIconIndex));        
           pfcs->iIconIndex = StrToInt(szIconIndex);
        }
        else if (pfcs->pszIconFile)
        {
            wnsprintf(szIconIndex, ARRAYSIZE(szIconIndex), TEXT("%d"), (int)pfcs->iIconIndex);
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                                szIconIndex, ARRAYSIZE(szIconIndex));        
        }
        else
        {
            hr = SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT(".ShellClassInfo"), TEXT("IconIndex"),
                                                NULL, 0);        
        }
    }
    return hr;
}


const LPCTSTR c_szWebViewTemplateVersions[] =
{
    SZ_CANBEUNICODE TEXT("WebViewTemplate.NT5"),
    SZ_CANBEUNICODE TEXT("PersistMoniker")
};

// Read/write desktop.ini settings
HRESULT SHGetSetWebViewTemplate(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszIniFile, DWORD dwReadWrite)
{
    int i;
    TCHAR szVID[GUIDSIZE], szTemp[MAX_PATH];
    HRESULT hr = S_FALSE;
    if (pfcs->dwMask & FCSM_WEBVIEWTEMPLATE)
    {
        if (!SHStringFromGUID(&VID_WebView, szVID, ARRAYSIZE(szVID)))
        {
            hr = E_FAIL;
        }

        if ((!pfcs->pszWebViewTemplate || !pfcs->pszWebViewTemplate[0]) && (dwReadWrite == FCS_FORCEWRITE)) // We have to remove webview
        {
            WritePrivateProfileString(szVID, NULL, NULL, pszIniFile);
            WritePrivateProfileString(TEXT("ExtShellFolderViews"), szVID, NULL, pszIniFile);
            if (SHGetSetFolderSetting(pszIniFile, FCS_READ, TEXT("ExtShellFolderViews"), TEXT("Default"), szTemp, ARRAYSIZE(szTemp)) == S_OK
                    && StrCmpI(szTemp, szVID) == 0)
            {
                WritePrivateProfileString(TEXT("ExtShellFolderViews"), TEXT("Default"), NULL, pszIniFile);
            }
        }
        else
        {
            TCHAR szKey[MAX_PATH];
            if (!pfcs->pszWebViewTemplateVersion || !pfcs->pszWebViewTemplateVersion[0]
                    || (lstrcmpi(pfcs->pszWebViewTemplateVersion, TEXT("IE4")) == 0))
            {   // They don't know which version template they want. Let's try from the latest version down.
                if (dwReadWrite & FCS_READ)
                {
                    for (i = 0; i < ARRAYSIZE(c_szWebViewTemplateVersions); i++)
                    {
                        lstrcpyn(szKey, c_szWebViewTemplateVersions[i], ARRAYSIZE(szKey));
                        if (SHGetSetFolderSetting(pszIniFile, FCS_READ, szVID, szKey, szTemp, ARRAYSIZE(szTemp)) == S_OK)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    lstrcpyn(szKey, c_szWebViewTemplateVersions[ARRAYSIZE(c_szWebViewTemplateVersions) - 1], ARRAYSIZE(szKey));
                }
            }
            else
            {
                lstrcpyn(szKey, SZ_CANBEUNICODE TEXT("WebViewTemplate."), ARRAYSIZE(szKey));
                StrCatBuff(szKey, pfcs->pszWebViewTemplateVersion, ARRAYSIZE(szKey));
            }
            
            if (dwReadWrite == FCS_FORCEWRITE)
            {
                // Remove all old templates
                for (i = 0; i < ARRAYSIZE(c_szWebViewTemplateVersions); i++)
                {
                    SHGetSetFolderSetting(pszIniFile, FCS_FORCEWRITE, szVID, c_szWebViewTemplateVersions[i], NULL, 0);
                }
            }
            
            hr = SHGetSetFolderSettingPath(pszIniFile, dwReadWrite, szVID, szKey,
                                    pfcs->pszWebViewTemplate, pfcs->cchWebViewTemplate);
            if (SUCCEEDED(hr))
            {
                if ((dwReadWrite == FCS_FORCEWRITE) || (dwReadWrite == FCS_WRITE))
                {
                    // If we have set the template, make sure that the VID_Webview = VID_WebView line under "ExtShellFolderViews" is present
                    if (pfcs->pszWebViewTemplate)
                    {
                        SHGetSetFolderSetting(pszIniFile, dwReadWrite, TEXT("ExtShellFolderViews"), szVID, 
                                        szVID, ARRAYSIZE(szVID));
                    }
                }
            }
        }
    }
    return hr;
}


// Read/write desktop.ini settings
HRESULT SHGetSetFCS(LPSHFOLDERCUSTOMSETTINGS pfcs, LPCTSTR pszPath, DWORD dwReadWrite)
{
    HRESULT hret = S_OK, hr;
    TCHAR szIniFile[MAX_PATH];
    DWORD dwValueReturned = 0;

    // Get the pathname for desktop.ini
    PathCombine(szIniFile, pszPath, TEXT("Desktop.ini"));

    hr = SHGetSetVID(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_VIEWID;
    }

    hr = SHGetSetWebViewTemplate(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_WEBVIEWTEMPLATE;
    }

    hr = SHGetSetInfoTip(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_INFOTIP;
    }

    hr = SHGetSetCLSID(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_CLSID;
    }
    
    hr = SHGetSetFlags(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_FLAGS;
    }

    hr = SHGetSetIconFile(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_ICONFILE;
    }

    hr = SHGetSetIconIndex(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_ICONFILE;
    }
    
    hr = SHGetSetLogo(pfcs, szIniFile, dwReadWrite);
    if (S_OK == hr)
    {
        dwValueReturned |= FCSM_LOGO;
    }
    
    if (SUCCEEDED(hret) && (dwReadWrite & FCS_FORCEWRITE))
    {
        // Make desktop.ini hidden
        SetFileAttributes(szIniFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        // Make this a system folder, so that we look for desktop.ini when we navigate to this folder.
        PathMakeSystemFolder(pszPath);
    }

    if (dwReadWrite & FCS_READ)
    {
        // If we were asked to get something and we are not returning anything, return error.
        if (pfcs->dwMask && !dwValueReturned)
        {
            hret = E_FAIL;
        }
        pfcs->dwMask = dwValueReturned;
    }
    return hret;
}

HRESULT SHAllocAndThunkUnicodeToTChar(LPWSTR pwsz, LPTSTR* ppsz, int cchReturnBuffer)
{
    HRESULT hr = S_OK;

    if (!ppsz || !pwsz)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int cch;

        if (cchReturnBuffer > 0)
        {      
            // if the user specified the size of the return buffer, alloc that ammount
            cch = cchReturnBuffer;
        }
        else
        {
            // since the user did not specify the size, alloc just enough to hold the string
            cch = lstrlenW(pwsz) + 1;
        }

        *ppsz = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (!*ppsz)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            SHUnicodeToTChar(pwsz, *ppsz, cch);
        }
    }
    return hr;
}

HRESULT SHAllocAndThunkAnsiToTChar(LPSTR psz, LPTSTR* ppsz, int cchReturnBuffer)
{
    HRESULT hr = S_OK;

    if (!ppsz || !psz)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int cch;
        
        if (cchReturnBuffer > 0)
        {      
            // if the user specified the size of the return buffer, alloc that ammount
            cch = cchReturnBuffer;
        }
        else
        {
            // since the user did not specify the size, alloc just enough to hold the string
            cch = lstrlenA(psz) + 1;
        }

        *ppsz = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (!*ppsz)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            SHAnsiToTChar(psz, *ppsz, cch);
        }
    }
    return hr;
}

// Read/write desktop.ini settings - Unicode (thunking function)
HRESULT SHGetSetFolderCustomSettingsW(LPSHFOLDERCUSTOMSETTINGSW pfcsW, LPCWSTR pwszPath, DWORD dwReadWrite)
{
    HRESULT hr = S_OK;

    if (pfcsW->dwSize >= sizeof(SHFOLDERCUSTOMSETTINGSW)  && pwszPath)
    {
        TCHAR szPath[MAX_PATH], *pszWebViewTemplate = NULL, *pszWebViewTemplateVersion = NULL;
        TCHAR *pszInfoTip = NULL, *pszIconFile = NULL, *pszLogo = NULL;

        SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath));
        if (dwReadWrite == FCS_WRITE || dwReadWrite == FCS_FORCEWRITE)
        {
            if (pfcsW->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsW->pszWebViewTemplate)
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplate, &pszWebViewTemplate, pfcsW->cchWebViewTemplate);
                if (SUCCEEDED(hr) && pfcsW->pszWebViewTemplateVersion)
                {
                    hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                }
            }
            if (pfcsW->dwMask & FCSM_INFOTIP && pfcsW->pszInfoTip && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszInfoTip, &pszInfoTip, pfcsW->cchInfoTip);
            }
            if (pfcsW->dwMask & FCSM_ICONFILE && pfcsW->pszIconFile && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszIconFile, &pszIconFile, pfcsW->cchIconFile);
            }
            if (pfcsW->dwMask & FCSM_LOGO && pfcsW->pszLogo && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszLogo, &pszLogo, pfcsW->cchLogo);
            }
        }
        else if (dwReadWrite == FCS_READ)
        {
            if (pfcsW->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsW->pszWebViewTemplate && pfcsW->cchWebViewTemplate > 0)
            {
                pszWebViewTemplate = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchWebViewTemplate * sizeof(TCHAR));
                if (!pszWebViewTemplate)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszWebViewTemplate[0] = 0;
                    if (pfcsW->pszWebViewTemplateVersion)
                    {
                        hr = SHAllocAndThunkUnicodeToTChar(pfcsW->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                    }
                }
            }

            if (pfcsW->dwMask & FCSM_INFOTIP && pfcsW->pszInfoTip && pfcsW->cchInfoTip > 0 && SUCCEEDED(hr))
            {
                pszInfoTip = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchInfoTip * sizeof(TCHAR));
                if (!pszInfoTip)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszInfoTip[0] = 0;
                }
            }

            if (pfcsW->dwMask & FCSM_ICONFILE && pfcsW->pszIconFile && pfcsW->cchIconFile > 0 && SUCCEEDED(hr))
            {
                pszIconFile = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchIconFile * sizeof(TCHAR));
                if (!pszIconFile)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszIconFile[0] = 0;
                }
            }

            if (pfcsW->dwMask & FCSM_LOGO && pfcsW->pszLogo && pfcsW->cchLogo > 0 && SUCCEEDED(hr))
            {
                pszLogo = (LPTSTR)LocalAlloc(LPTR, pfcsW->cchLogo * sizeof(TCHAR));
                if (!pszLogo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszLogo[0] = 0;
                }
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }
        
        if (SUCCEEDED(hr))
        {
            SHFOLDERCUSTOMSETTINGS fcs;
            fcs.dwSize = sizeof(LPSHFOLDERCUSTOMSETTINGS);
            fcs.dwMask = pfcsW->dwMask;
            fcs.pvid = pfcsW->pvid;
            fcs.pszWebViewTemplate = pszWebViewTemplate;
            fcs.cchWebViewTemplate = pfcsW->cchWebViewTemplate;
            fcs.pszWebViewTemplateVersion = pszWebViewTemplateVersion;
            fcs.pszInfoTip = pszInfoTip;
            fcs.cchInfoTip = pfcsW->cchInfoTip;
            fcs.pclsid = pfcsW->pclsid;
            fcs.dwFlags = pfcsW->dwFlags;
            fcs.pszIconFile = pszIconFile;
            fcs.cchIconFile = pfcsW->cchIconFile;
            fcs.iIconIndex  = pfcsW->iIconIndex;
            fcs.pszLogo = pszLogo;
            fcs.cchLogo = pfcsW->cchLogo;

            hr = SHGetSetFCS(&fcs, szPath, dwReadWrite);
            if (SUCCEEDED(hr))
            {
                if (dwReadWrite == FCS_READ)
                {
                    if (fcs.dwMask & FCSM_WEBVIEWTEMPLATE && fcs.pszWebViewTemplate)
                    {
                        SHTCharToUnicode(fcs.pszWebViewTemplate, pfcsW->pszWebViewTemplate, pfcsW->cchWebViewTemplate);
                    }
                    if (fcs.dwMask & FCSM_INFOTIP && fcs.pszInfoTip)
                    {
                        SHTCharToUnicode(fcs.pszInfoTip, pfcsW->pszInfoTip, pfcsW->cchInfoTip);
                    }
                    if (fcs.dwMask & FCSM_ICONFILE && fcs.pszIconFile)
                    {
                        SHTCharToUnicode(fcs.pszIconFile, pfcsW->pszIconFile, pfcsW->cchIconFile);
                    }
                    if (fcs.dwMask & FCSM_LOGO && fcs.pszLogo)
                    {
                        SHTCharToUnicode(fcs.pszLogo, pfcsW->pszLogo, pfcsW->cchLogo);
                    }
                    pfcsW->dwFlags = fcs.dwFlags;
                    pfcsW->iIconIndex = fcs.iIconIndex;
                    pfcsW->dwMask = fcs.dwMask;
                }
            }
        }

        // Free allocated memory
        if (pszWebViewTemplate)
        {
            LocalFree(pszWebViewTemplate);
        }
        if (pszWebViewTemplateVersion)
        {
            LocalFree(pszWebViewTemplateVersion);
        }
        if (pszInfoTip)
        {
            LocalFree(pszInfoTip);
        }
        if (pszIconFile)
        {
            LocalFree(pszIconFile);
        }
        if (pszLogo)
        {
            LocalFree(pszLogo);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


// Read/write desktop.ini settings - ANSI (thunking function)
HRESULT SHGetSetFolderCustomSettingsA(LPSHFOLDERCUSTOMSETTINGSA pfcsA, LPCSTR pszPath, DWORD dwReadWrite)
{
    HRESULT hr = S_OK;
    if (pfcsA->dwSize >= sizeof(SHFOLDERCUSTOMSETTINGSA) && pszPath)
    {
        TCHAR szPath[MAX_PATH], *pszWebViewTemplate = NULL, *pszWebViewTemplateVersion = NULL;
        TCHAR *pszInfoTip = NULL, *pszIconFile =NULL, *pszLogo = NULL;

        SHAnsiToTChar(pszPath, szPath, ARRAYSIZE(szPath));
        if (dwReadWrite == FCS_WRITE || dwReadWrite == FCS_FORCEWRITE)
        {
            if (pfcsA->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsA->pszWebViewTemplate)
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplate, &pszWebViewTemplate, pfcsA->cchWebViewTemplate);
                if (SUCCEEDED(hr) && pfcsA->pszWebViewTemplateVersion)
                {
                    hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                }
            }

            if (pfcsA->dwMask & FCSM_INFOTIP && pfcsA->pszInfoTip && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszInfoTip, &pszInfoTip, pfcsA->cchInfoTip);
            }

            if (pfcsA->dwMask & FCSM_ICONFILE && pfcsA->pszIconFile && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszIconFile, &pszIconFile, pfcsA->cchIconFile);
            }

            if (pfcsA->dwMask & FCSM_LOGO && pfcsA->pszLogo && SUCCEEDED(hr))
            {
                hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszLogo, &pszLogo, pfcsA->cchLogo);
            }
        }
        else if (dwReadWrite == FCS_READ)
        {
            if (pfcsA->dwMask & FCSM_WEBVIEWTEMPLATE && pfcsA->pszWebViewTemplate && pfcsA->cchWebViewTemplate > 0)
            {
                pszWebViewTemplate = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchWebViewTemplate * sizeof(TCHAR));
                if (!pszWebViewTemplate)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszWebViewTemplate[0] = 0;
                    if (pfcsA->pszWebViewTemplateVersion)
                    {
                        hr = SHAllocAndThunkAnsiToTChar(pfcsA->pszWebViewTemplateVersion, &pszWebViewTemplateVersion, 0);
                    }
                }
            }
            if (pfcsA->dwMask & FCSM_INFOTIP && pfcsA->pszInfoTip && pfcsA->cchInfoTip > 0 && SUCCEEDED(hr))
            {
                pszInfoTip = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchInfoTip * sizeof(TCHAR));
                if (!pszInfoTip)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszInfoTip[0] = 0;
                }
            }
            if (pfcsA->dwMask & FCSM_ICONFILE && pfcsA->pszIconFile && pfcsA->cchIconFile > 0 && SUCCEEDED(hr))
            {
                pszIconFile = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchIconFile * sizeof(TCHAR));
                if (!pszIconFile)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszIconFile[0] = 0;
                }
            }
            if (pfcsA->dwMask & FCSM_LOGO && pfcsA->pszLogo && pfcsA->cchLogo > 0 && SUCCEEDED(hr))
            {
                pszLogo = (LPTSTR)LocalAlloc(LPTR, pfcsA->cchLogo * sizeof(TCHAR));
                if (!pszLogo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pszLogo[0] = 0;
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        
        if (SUCCEEDED(hr))
        {
            SHFOLDERCUSTOMSETTINGS fcs;
            fcs.dwSize = sizeof(LPSHFOLDERCUSTOMSETTINGS);
            fcs.dwMask = pfcsA->dwMask;
            fcs.pvid = pfcsA->pvid;
            fcs.pszWebViewTemplate = pszWebViewTemplate;
            fcs.cchWebViewTemplate = pfcsA->cchWebViewTemplate;
            fcs.pszWebViewTemplateVersion = pszWebViewTemplateVersion;
            fcs.pszInfoTip = pszInfoTip;
            fcs.cchInfoTip = pfcsA->cchInfoTip;
            fcs.pclsid = pfcsA->pclsid;
            fcs.dwFlags = pfcsA->dwFlags;
            fcs.pszIconFile = pszIconFile;
            fcs.cchIconFile = pfcsA->cchIconFile;
            fcs.iIconIndex = pfcsA->iIconIndex;
            fcs.pszLogo = pszLogo;
            fcs.cchLogo = pfcsA->cchLogo;

            hr = SHGetSetFCS(&fcs, szPath, dwReadWrite);
            if (SUCCEEDED(hr))
            {
                if (dwReadWrite == FCS_READ)
                {
                    if (fcs.dwMask & FCSM_WEBVIEWTEMPLATE && fcs.pszWebViewTemplate)
                    {
                        SHTCharToAnsi(fcs.pszWebViewTemplate, pfcsA->pszWebViewTemplate, pfcsA->cchWebViewTemplate);
                    }
                    if (fcs.dwMask & FCSM_INFOTIP && fcs.pszInfoTip)
                    {
                        SHTCharToAnsi(fcs.pszInfoTip, pfcsA->pszInfoTip, pfcsA->cchInfoTip);
                    }
                    if (fcs.dwMask & FCSM_ICONFILE && fcs.pszIconFile)
                    {
                        SHTCharToAnsi(fcs.pszIconFile, pfcsA->pszIconFile, pfcsA->cchIconFile);
                    }
                    if (fcs.dwMask & FCSM_LOGO && fcs.pszLogo)
                    {
                        SHTCharToAnsi(fcs.pszLogo, pfcsA->pszLogo, pfcsA->cchLogo);
                    }
                    pfcsA->dwFlags = fcs.dwFlags;
                    pfcsA->iIconIndex = fcs.iIconIndex;
                    pfcsA->dwMask = fcs.dwMask;
                }
            }
        }

        // Free allocated memory
        if (pszWebViewTemplate)
        {
            LocalFree(pszWebViewTemplate);
        }
        if (pszWebViewTemplateVersion)
        {
            LocalFree(pszWebViewTemplateVersion);
        }
        if (pszInfoTip)
        {
            LocalFree(pszInfoTip);
        }

        if (pszIconFile)
        {
            LocalFree(pszIconFile);
        }

        if (pszLogo)
        {
            LocalFree(pszLogo);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include <regstr.h>
#include <varutil.h>
#include "ids.h"        
#include "findhlp.h"    
#include "pidl.h"       
#include "shitemid.h"   
#include "defview.h"    
#include "fstreex.h"
#include "views.h"
#include "cowsite.h"
#include "exdisp.h"
#include "shguidp.h"
#include "prop.h"           // COLUMN_INFO
#include <limits.h>
#include "stgutil.h"
#include "netview.h"
#include "basefvcb.h"
#include "findfilter.h"
#include "defvphst.h"
#include "perhist.h"
#include "adoint.h"
#include "dspsprt.h"
#include "defcm.h"
#include "enumidlist.h"
#include "contextmenu.h"

// findband.cpp
STDAPI GetCIStatus(BOOL *pbRunning, BOOL *pbIndexed, BOOL *pbPermission);
STDAPI CatalogUptodate(LPCWSTR pszCatalog, LPCWSTR pszMachine);

class CFindFolder;

class CFindLVRange : public ILVRange
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ILVRange
    STDMETHODIMP IncludeRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP ExcludeRange(LONG iBegin, LONG iEnd);    
    STDMETHODIMP InvertRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP InsertItem(LONG iItem);
    STDMETHODIMP RemoveItem(LONG iItem);

    STDMETHODIMP Clear();
    STDMETHODIMP IsSelected(LONG iItem);
    STDMETHODIMP IsEmpty();
    STDMETHODIMP NextSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP NextUnSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP CountIncluded(LONG *pcIncluded);

    // Helperfunctions...
    void SetOwner(CFindFolder *pff, DWORD dwMask)
    {
        // don't AddRef -- we're a member variable of the object punk points to
        _pff = pff;
        _dwMask = dwMask;
        _cIncluded = 0;
    }
    void IncrementIncludedCount() {_cIncluded++;}
    void DecrementIncludedCount() {_cIncluded--;}
protected:
    CFindFolder *_pff;
    DWORD _dwMask;  // The mask we use to know which "selection" bit we are tracking...
    LONG _cIncluded;  // count included... (selected)
};

class CFindFolder : public IFindFolder,
                    public IShellFolder2,
                    public IShellIcon,
                    public IShellIconOverlay,
                    public IPersistFolder2
{
public:
    CFindFolder(IFindFilter *pff);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
        
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(THIS_ HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        { return BindToObject(pidl, pbc, riid, ppv); }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid);

    // IFindFolder
    STDMETHODIMP GetFindFilter(IFindFilter **pfilter);
    STDMETHODIMP AddPidl(int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppItem);
    STDMETHODIMP GetItem(int iItem, FIND_ITEM **ppItem);
    STDMETHODIMP DeleteItem(int iItem);
    STDMETHODIMP GetItemCount(INT *pcItems);
    STDMETHODIMP ValidateItems(IUnknown *punkView, int iItemFirst, int cItems, BOOL bSearchComplete);
    STDMETHODIMP GetFolderListItemCount(INT *pcCount);
    STDMETHODIMP GetFolderListItem(int iItem, FIND_FOLDER_ITEM **ppItem);
    STDMETHODIMP GetFolder(int iFolder, REFIID riid, void **ppv);
    STDMETHODIMP_(UINT) GetFolderIndex(LPCITEMIDLIST pidl);
    STDMETHODIMP SetItemsChangedSinceSort();
    STDMETHODIMP ClearItemList();
    STDMETHODIMP ClearFolderList();
    STDMETHODIMP AddFolder(LPITEMIDLIST pidl, BOOL fCheckForDup, int * piFolder);
    STDMETHODIMP SetAsyncEnum(IFindEnum *pfenum);
    STDMETHODIMP GetAsyncEnum(IFindEnum **ppfenum);
    STDMETHODIMP CacheAllAsyncItems();
    STDMETHODIMP_(BOOL) AllAsyncItemsCached();
    STDMETHODIMP SetAsyncCount(DBCOUNTITEM cCount);
    STDMETHODIMP ClearSaveStateList();
    STDMETHODIMP GetStateFromSaveStateList(DWORD dwItemID, DWORD *pdwState);
    STDMETHODIMP MapToSearchIDList(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetParentsPIDL(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent);
    STDMETHODIMP SetControllerNotifyObject(IFindControllerNotify *pfcn);
    STDMETHODIMP GetControllerNotifyObject(IFindControllerNotify **ppfcn);
    STDMETHODIMP RememberSelectedItems();
    STDMETHODIMP SaveFolderList(IStream *pstm);
    STDMETHODIMP RestoreFolderList(IStream *pstm);
    STDMETHODIMP SaveItemList(IStream *pstm);
    STDMETHODIMP RestoreItemList(IStream *pstm, int *pcItems);
    STDMETHODIMP RestoreSearchFromSaveFile(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv);

    STDMETHODIMP_(BOOL) HandleUpdateDir(LPCITEMIDLIST pidl, BOOL fCheckSubDirs);
    STDMETHODIMP_(void) HandleRMDir(IShellFolderView *psfv, LPCITEMIDLIST pidl);
    STDMETHODIMP_(void) UpdateOrMaybeAddPidl(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld);
    STDMETHODIMP_(void) Save(IFindFilter* pfilter, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown * pObject);
    STDMETHODIMP OpenContainingFolder(IUnknown *punkSite);
    STDMETHODIMP AddDataToIDList(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl);

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);
  
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    friend class CFindFolderViewCB;
    friend class CFindLVRange;

    HRESULT Init();

private:
    ~CFindFolder();
    HRESULT _CompareFolderIndexes(int iFolder1, int iFolder2);
    void _AddFIND_ITEMToSaveStateList(FIND_ITEM *pesfi);
    LPITEMIDLIST _GetFullPidlForItem(LPCITEMIDLIST pidl);
    HRESULT _UpdateItemList();

    static int CALLBACK _SortForDataObj(void *p1, void *p2, LPARAM lparam);
    static ULONG _Rank(LPCITEMIDLIST pidl);
    static DWORD _ItemID(LPCITEMIDLIST pidl);
    static PCHIDDENDOCFINDDATA _HiddenData(LPCITEMIDLIST pidl);
    FIND_FOLDER_ITEM *_FolderListItem(int iFolder);
    FIND_FOLDER_ITEM *_FolderListItem(LPCITEMIDLIST pidl);
    static BOOL _MapColIndex(UINT *piColumn);
    HRESULT _PrepareHIDA(UINT cidl, LPCITEMIDLIST *apidl, HDPA *phdpa);

    HRESULT _GetDetailsFolder();
    HRESULT _QueryItemShellFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf);
    HRESULT _QueryItemInterface(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _Folder(FIND_FOLDER_ITEM *pffli, REFIID riid, void **ppv);
    HRESULT _FolderFromItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv);

    HRESULT _GetFolderName(LPCITEMIDLIST pidl, DWORD gdnFlags, LPTSTR psz, UINT cch);
    int _CompareByCachedSCID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareNames(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwFlags);
    HRESULT _GetItemDisplayName(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR wzName, UINT cch);
    HRESULT _GetFolderIDList(int iFolder, LPITEMIDLIST *ppidlParent);

    LONG _cRef;

    CFindLVRange _dflvrSel; // manage selection and cut range information...
    CFindLVRange _dflvrCut;

    HDPA                _hdpaItems;             // all of the items in the results
    HDPA                _hdpaPidf;              // folders that the items came from
    IFindFilter         *_pfilter;
    BOOL                _fItemsChangedSinceSort;// Has the list changed since the last sort?
    BOOL                _fAllAsyncItemsCached;  // Have we already cached all of the items?
    BOOL                _fSearchComplete; 
    BOOL                _fInRefresh;            // true if received prerefresh callback but postrefresh

    LPITEMIDLIST        _pidl;
    IFindEnum           *_pDFEnumAsync;         // we have an async one, will need to call back for PIDLS and the like
    DBCOUNTITEM         _cAsyncItems;           // Count of async items
    int                 _iGetIDList;            // index of the last IDlist we retrieved in callback.
    HDSA                _hdsaSaveStateForIDs;   // Async - Remember which items are selected when we sort
    int                 _cSaveStateSelected;    // Number of items in selection list which are selected
    IFindControllerNotify *_pfcn;           // Sometimes need to let the "Controller" object know about things
    CRITICAL_SECTION    _csSearch;          
    BOOL                _fcsSearch;
    int                 _iCompareFolderCache1, _iCompareFolderCache2, _iCompareFolderCacheResult;
    IShellFolder2       *_psfDetails;

    SHCOLUMNID          _scidCached;            // Cached SCID for sorting the columns
    UINT                _uiColumnCached;         // The index to the cached column for _scidCached

#if DEBUG
    DWORD               _GUIThreadID;           // Items can only be added to _hdpaItems on the UI thread.
#endif
};

class CFindFolderViewCB : public CBaseShellFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT SetShellView(IShellView *psv);

    CFindFolderViewCB(CFindFolder* pff);

    //  IServiceProvider override
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // Web View Tasks
    static HRESULT _OnOpenContainingFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

private:
    ~CFindFolderViewCB();

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP);    
    HRESULT OnReArrange(DWORD pv, LPARAM lp);
    HRESULT OnGETWORKINGDIR(DWORD pv, UINT wP, LPTSTR lP);
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream**lP);
    HRESULT OnGETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST *ppidl);
    HRESULT OnGetItemIconIndex(DWORD pv, WPARAM iItem, int *piIcon);
    HRESULT OnSetItemIconOverlay(DWORD pv, WPARAM iItem, int dwOverlayState);
    HRESULT OnGetItemIconOverlay(DWORD pv, WPARAM iItem, int * pdwOverlayState);
    HRESULT OnSETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST pidl);
    HRESULT OnGetIndexForItemIDList(DWORD pv, int * piItem, LPITEMIDLIST pidl);
    HRESULT OnDeleteItem(DWORD pv, LPCITEMIDLIST pidl);
    HRESULT OnODFindItem(DWORD pv, int * piItem, NM_FINDITEM* pnmfi);
    HRESULT OnODCacheHint(DWORD pv, NMLVCACHEHINT* pnmlvc);
    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnGetEmptyText(DWORD pv, UINT cchTextMax, LPTSTR pszText);
    HRESULT OnSetEmptyText(DWORD pv, UINT res, LPCTSTR pszText);
    HRESULT OnHwndMain(DWORD pv, HWND hwndMain);
    HRESULT OnIsOwnerData(DWORD pv, DWORD *pdwFlags);
    HRESULT OnSetISFV(DWORD pv, IShellFolderView* pisfv);
    HRESULT OnWindowCreated(DWORD pv, HWND hwnd);
    HRESULT OnWindowDestroy(DWORD pv, HWND wP);
    HRESULT OnGetODRangeObject(DWORD pv, WPARAM wWhich, ILVRange **pplvr);
    HRESULT OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP);
    HRESULT OnGetIPersistHistory(DWORD pv, IPersistHistory **ppph);
    HRESULT OnRefresh(DWORD pv, BOOL fPreRefresh);
    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *shtd);
    HRESULT OnSortListData(DWORD pv, PFNLVCOMPARE pfnCompare, LPARAM lParamSort);
    HRESULT _ProfferService(BOOL bProffer);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme);

    CFindFolder*  _pff;
    UINT        _iColSort;         // Which column are we sorting by
    BOOL        _fIgnoreSelChange;      // Sort in process
    UINT        _iFocused;         // Which item has the focus?
    UINT        _cSelected;        // Count of items selected

    IProfferService* _pps;          // ProfferService site.
    DWORD _dwServiceCookie;         // ProfferService cookie.

    TCHAR _szEmptyText[128];        // empty results list text.

    friend class CFindLVRange;
};

// Class to save and restore find state on the travel log 
class CFindPersistHistory : public CDefViewPersistHistory
{
public:
    CFindPersistHistory();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistHistory
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc);
    STDMETHODIMP SaveHistory(IStream *pStream);

protected:
    IFindFolder* _GetDocFindFolder();
};


// {a5df1ea0-5702-11d1-83fa-00a0c90dc849}
const IID IID_IFindFolder = {0xa5df1ea0, 0x5702, 0x11d1, {0x83, 0xfa, 0x00, 0xa0, 0xc9, 0x0d, 0xc8, 0x49}};

// {5B8DCBF0-B096-11d1-9217-00403393B8F0}
const IID IID_IFindControllerNotify = {0x5b8dcbf0, 0xb096, 0x11d1, {0x92, 0x17, 0x0, 0x40, 0x33, 0x93, 0xb8, 0xf0}};

// Listview doesn't support more than 100000000 items, so if our
// client returns more than that, just stop after that point.
//
// Instead of 100000000, we use the next lower 64K boundary.  This keeps
// us away from strange boundary cases (where a +1 might push us over the
// top), and it keeps the Alpha happy.
//
#define MAX_LISTVIEWITEMS  (100000000 & ~0xFFFF)
#define SANE_ITEMCOUNT(c)  ((int)min(c, MAX_LISTVIEWITEMS))

// Unicode descriptor:
//
// Structure written at the end of NT-generated find stream serves dual purpose.
// 1. Contains an NT-specific signature to identify stream as NT-generated.
//    Appears as "NTFF" (NT Find File) in ASCII dump of file.
// 2. Contains an offset to the unicode-formatted criteria section.
//
// The following diagram shows the find criteria/results stream format including
// the NT-specific unicode criteria and descriptor.
//
//          +-----------------------------------------+ --------------
//          |         DFHEADER structure              |   .        .
//          +-----------------------------------------+   .        .
//          |      DF Criteria records (ANSI)         | Win95      .
//          +-----------------------------------------+   .        .
//          |      DF Results (PIDL) [optional]       |   .        NT
//          +-----------------------------------------+ -------    .
//   +----->| DF Criteria records (Unicode) [NT only] |            .
//   |      +-----------------------------------------+            .
//   |      | Unicode Descriptor |                                 .
//   |      +--------------------+  ----------------------------------
//   |     /                      \
//   |    /                         \
//   |   +-----------------+---------+
//   +---| Offset (64-bit) |  "NTFF" |
//       +-----------------+---------+
//
//

const DWORD c_NTsignature = 0x4646544E; // "NTFF" in ASCII file dump.

typedef struct
{
   ULARGE_INTEGER oUnicodeCriteria;  // Offset of unicode find criteria.
   DWORD NTsignature;               // Signature of NT-generated find file.
} DFC_UNICODE_DESC;


enum
{
    IDFCOL_NAME = 0,    // default col from guy we are delegating to
    IDFCOL_PATH,
    IDFCOL_RANK,
};

const COLUMN_INFO c_find_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,            30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_DIRECTORY,       30, IDS_PATH_COL),
    DEFINE_COL_STR_MENU_ENTRY(SCID_RANK,       10, IDS_RANK_COL),
};

class CFindMenuBase : public IContextMenuCB , public CObjectWithSite
{
public:
    CFindMenuBase();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

protected:
    virtual ~CFindMenuBase();

private:
    LONG _cRef;
};

CFindMenuBase::CFindMenuBase() : _cRef(1)
{
}

CFindMenuBase::~CFindMenuBase()
{
}

STDMETHODIMP CFindMenuBase::QueryInterface(REFIID riid, void **ppv) 
{        
    static const QITAB qit[] = {
        QITABENT(CFindMenuBase, IContextMenuCB),           // IID_IContextMenuCB
        QITABENT(CFindMenuBase, IObjectWithSite),          // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFindMenuBase::AddRef() 
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFindMenuBase::Release() 
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


class CFindMenuCB : public CFindMenuBase
{
public:
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

STDMETHODIMP CFindMenuCB::CallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            if (!pdtobj)
            {
                UINT idStart = pqcm->idCmdFirst;
                UINT idBGMain = 0, idBGPopup = 0;
                IFindFolder *pff;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff)))) 
                {
                    IFindFilter *pfilter;
                    if (SUCCEEDED(pff->GetFindFilter(&pfilter))) 
                    {
                        pfilter->GetFolderMergeMenuIndex(&idBGMain, &idBGPopup);
                        CDefFolderMenu_MergeMenu(HINST_THISDLL, idBGMain, idBGPopup, pqcm);

                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_EDIT_PASTE, MF_BYCOMMAND);
                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_EDIT_PASTELINK, MF_BYCOMMAND);
                        DeleteMenu(pqcm->hmenu, idStart+SFVIDM_MISC_REFRESH, MF_BYCOMMAND);

                        IFindControllerNotify *pdcn;
                        if (S_OK == pff->GetControllerNotifyObject(&pdcn))
                        {
                            pdcn->Release();
                        }
                        else
                        {
                            DeleteMenu(pqcm->hmenu, idStart+FSIDM_SAVESEARCH, MF_BYCOMMAND);
                        }
                        
                        pfilter->Release();
                    }
                    pff->Release();
                }
            }
        }
        break;

    case DFM_INVOKECOMMAND:
        {    
            // Check if this is from item context menu
            if (pdtobj)
            {
                switch(wParam)
                {
                case DFM_CMD_LINK:
                    hr = SHCreateLinks(hwnd, NULL, pdtobj, SHCL_USETEMPLATE | SHCL_USEDESKTOP | SHCL_CONFIRM, NULL);
                    break;
    
                case DFM_CMD_DELETE:
                    // convert to DFM_INVOKCOMMANDEX to get flags bits
                    hr = DeleteFilesInDataObject(hwnd, 0, pdtobj, 0);
                    break;

                case DFM_CMD_PROPERTIES:
                    // We need to pass an empty IDlist to combine with.
                    hr = SHLaunchPropSheet(CFSFolder_PropertiesThread, pdtobj,
                                      (LPCTSTR)lParam, NULL,  (void *)&c_idlDesktop);
                    break;

                default:
                    // Note: Fixing the working of Translator Key is not worth fixing. Hence Punted.
                    // if GetAttributesOf did not specify the SFGAO_ bit
                    // that corresponds to this default DFM_CMD, then we should
                    // fail it here instead of returning S_FALSE. Otherwise,
                    // accelerator keys (cut/copy/paste/etc) will get here, and
                    // defcm tries to do the command with mixed results.
                    // if GetAttributesOf did not specify SFGAO_CANLINK
                    // or SFGAO_CANDELETE or SFGAO_HASPROPERTIES, then the above
                    // implementations of these DFM_CMD commands are wrong...
                    // Let the defaults happen for this object
                    hr = S_FALSE;
                    break;
                }
            }
            else
            {
                switch (wParam)
                {
                case FSIDM_SAVESEARCH:
                    {
                        IFindFolder *pff;
                        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff))))
                        {
                            IFindControllerNotify *pdcn;
                            if (S_OK == pff->GetControllerNotifyObject(&pdcn))
                            {
                                pdcn->SaveSearch();
                                pdcn->Release();
                            }
                            pff->Release();
                        }
                    }
                    break;

                default:
                    hr = S_FALSE; // one of view menu items, use the default code.
                    break;
                }
            }
        }
        break;

    case DFM_GETHELPTEXT:  // ansi version
    case DFM_GETHELPTEXTW:
        {
            UINT id = LOWORD(wParam) + IDS_MH_FSIDM_FIRST;

            if (uMsg == DFM_GETHELPTEXTW)
                LoadStringW(HINST_THISDLL, id, (LPWSTR)lParam, HIWORD(wParam));
            else
                LoadStringA(HINST_THISDLL, id, (LPSTR)lParam, HIWORD(wParam));
        }
        break;
        
    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}


class CFindFolderContextMenuItemCB : public CFindMenuBase
{
public:
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    CFindFolderContextMenuItemCB(IFindFolder* pff);
    ~CFindFolderContextMenuItemCB();
    friend HRESULT CFindItem_Create(HWND hwnd, IFindFolder *pff, IContextMenu **ppcm);

    STDMETHODIMP _GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode);

    IFindFolder *_pff;
};

CFindFolderContextMenuItemCB::CFindFolderContextMenuItemCB(IFindFolder* pff) : _pff(pff)
{
    _pff->AddRef();
}

CFindFolderContextMenuItemCB::~CFindFolderContextMenuItemCB()
{
    _pff->Release();
}

STDMETHODIMP CFindFolderContextMenuItemCB::_GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    HRESULT hr;
    if (idCmd == FSIDM_OPENCONTAININGFOLDER)
    {
        if (bUnicode)
            hr = StringCchCopyW((LPWSTR)pszName, cchMax, L"OpenContainingFolder");
        else
            hr = StringCchCopyA((LPSTR)pszName, cchMax, "OpenContainingFolder");
    }
    else
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

STDMETHODIMP CFindFolderContextMenuItemCB::CallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DOCFIND_ITEM_MERGE, 0, pqcm);
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_OPENCONTAININGFOLDER:
            _pff->OpenContainingFolder(_punkSite);
            break;
        default:
            hr = E_FAIL; // not our command
            break;
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        // probably need to implement these...
        
    case DFM_GETVERBA:
    case DFM_GETVERBW:
        hr = _GetVerb((UINT_PTR)(LOWORD(wParam)), (LPSTR)lParam, (UINT)(HIWORD(wParam)), uMsg == DFM_GETVERBW);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    
    return hr;
}

STDAPI CFindItem_Create(HWND hwnd, IFindFolder* pff, IContextMenu **ppcm)
{
    *ppcm = NULL;

    HRESULT hr;
    // We want a quick IContextMenu implementation -- an empty defcm looks easiest
    IContextMenuCB* pcmcb = new CFindFolderContextMenuItemCB(pff);
    if (pcmcb)
    {
        hr = CDefFolderMenu_CreateEx(NULL, hwnd, 0, NULL, NULL, pcmcb, NULL, NULL, ppcm);
        pcmcb->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CFindFolder::AddFolder(LPITEMIDLIST pidl, BOOL fCheckForDup, int *piFolder)
{
    *piFolder = -1;

    if (fCheckForDup)
    {
        EnterCriticalSection(&_csSearch);
        for (int i = DPA_GetPtrCount(_hdpaPidf) - 1; i >= 0; i--)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli && ILIsEqual(&pffli->idl, pidl))
            {
                LeaveCriticalSection(&_csSearch);
                *piFolder = i;
                return S_OK;
            }
        }
        LeaveCriticalSection(&_csSearch);
    }

    int cb = ILGetSize(pidl);
    FIND_FOLDER_ITEM *pffli;;
    HRESULT hr = SHLocalAlloc(sizeof(*pffli) - sizeof(pffli->idl) + cb, &pffli);
    if (SUCCEEDED(hr))
    {
        // pddfli->psf = NULL;
        // pffli->fUpdateDir = FALSE;
        memcpy(&pffli->idl, pidl, cb);

        EnterCriticalSection(&_csSearch);
        // Now add this item to our DPA...
        *piFolder = DPA_AppendPtr(_hdpaPidf, pffli);
        LeaveCriticalSection(&_csSearch);
    
        if (-1 != *piFolder)
        {
            // If this is a network ID list then register a path -> pidl mapping, therefore
            // avoiding having to create simple ID lists, which don't work correctly when
            // being compared against real ID lists.

            if (IsIDListInNameSpace(pidl, &CLSID_NetworkPlaces))
            {
                TCHAR szPath[ MAX_PATH ];
                SHGetPathFromIDList(pidl, szPath);
                NPTRegisterNameToPidlTranslation(szPath, _ILNext(pidl));  // skip the My Net Places entry
            }
        }
        else
        {
            LocalFree((HLOCAL)pffli);
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

typedef struct
{
    DWORD       dwState;    // State of the item;
    DWORD       dwItemID;   // Only used for Async support...
} FIND_ITEM_SAVE_STATE;


void CFindFolder::_AddFIND_ITEMToSaveStateList(FIND_ITEM *pesfi)
{
    FIND_ITEM_SAVE_STATE essi;
    essi.dwState = pesfi->dwState & CDFITEM_STATE_MASK;
    essi.dwItemID = _ItemID(&pesfi->idl);

    DSA_AppendItem(_hdsaSaveStateForIDs, (void *)&essi);
    if (essi.dwState & LVIS_SELECTED)
        _cSaveStateSelected++;
}


HRESULT CFindFolder::RememberSelectedItems()
{
    EnterCriticalSection(&_csSearch);
    // Currently has list of pidls...
    for (int i = DPA_GetPtrCount(_hdpaItems); i-- > 0;)
    {
        // Pidl at start of structure...
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_hdpaItems, i);
        if (pesfi)
        {
            if (pesfi->dwState & (LVIS_SELECTED|LVIS_FOCUSED))
                _AddFIND_ITEMToSaveStateList(pesfi);
        }
    }
    LeaveCriticalSection(&_csSearch);
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearItemList()
{
    // Clear out any async enumerators we may have
    SetAsyncEnum(NULL);
    _cAsyncItems = 0;       // clear out our count of items...
    _pfilter->ReleaseQuery();

    // Also tell the filter to release everything...
    EnterCriticalSection(&_csSearch);
    if (_hdpaItems)
    {
        // Currently has list of pidls...
        for (int i = DPA_GetPtrCount(_hdpaItems) - 1; i >= 0; i--)
        {
            // Pidl at start of structure...
            FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_hdpaItems, i);
            if (pesfi)
                LocalFree((HLOCAL)pesfi);
        }

        _fSearchComplete = FALSE;
        DPA_DeleteAllPtrs(_hdpaItems);
    }
    LeaveCriticalSection(&_csSearch);
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearFolderList()
{
    EnterCriticalSection(&_csSearch);
    if (_hdpaPidf)
    {
        for (int i = DPA_GetPtrCount(_hdpaPidf) - 1; i >= 0; i--)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli)
            {
                // Release the IShellFolder if we have one
                if (pffli->psf)
                    pffli->psf->Release();

                // And delete the item
                LocalFree((HLOCAL)pffli);
            }
        }
        DPA_DeleteAllPtrs(_hdpaPidf);
    }
    LeaveCriticalSection(&_csSearch);
    
    return S_OK;
}

CFindFolder::CFindFolder(IFindFilter *pff) : _cRef(1), _iGetIDList(-1), _pfilter(pff), _iCompareFolderCache1(-1), _uiColumnCached(-1)
{
    ASSERT(_pidl == NULL);

    _pfilter->AddRef();

    // initialize our LV selection objects...
    _dflvrSel.SetOwner(this, LVIS_SELECTED);
    _dflvrCut.SetOwner(this, LVIS_CUT);

#if DEBUG
    _GUIThreadID = GetCurrentThreadId();
#endif
}

CFindFolder::~CFindFolder()
{
    ASSERT(_cRef==0);
    
    // We will need to call our function to Free our items in our
    // Folder list.  We will use the same function that we use to
    // clear it when we do a new search

    ClearItemList();
    ClearFolderList();
    ClearSaveStateList();

    EnterCriticalSection(&_csSearch);
    DPA_Destroy(_hdpaPidf);
    DPA_Destroy(_hdpaItems);
    _hdpaPidf = NULL;
    _hdpaItems = NULL;
    LeaveCriticalSection(&_csSearch);
    DSA_Destroy(_hdsaSaveStateForIDs);

    _pfilter->Release();

    if (_psfDetails)
        _psfDetails->Release();

    if (_fcsSearch)
    {
        DeleteCriticalSection(&_csSearch);
    }
}

HRESULT CFindFolder::Init()
{
    if (InitializeCriticalSectionAndSpinCount(&_csSearch, 0))
    {
        _fcsSearch = TRUE;
    }

    // Create the heap for the folder lists.
    _hdpaPidf = DPA_CreateEx(64, GetProcessHeap());

    // Create the DPA and DSA for the item list.
    _hdpaItems = DPA_CreateEx(64, GetProcessHeap());
    _hdsaSaveStateForIDs = DSA_Create(sizeof(FIND_ITEM_SAVE_STATE), 16);

    return _fcsSearch && _hdsaSaveStateForIDs && _hdpaItems && _hdpaPidf ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CFindFolder::AddDataToIDList(LPCITEMIDLIST pidl, int iFolder, LPCITEMIDLIST pidlFolder, UINT uFlags, UINT uRow, DWORD dwItemID, ULONG ulRank, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    LPITEMIDLIST pidlToFree;
    if (pidlFolder)
    {
        pidlToFree = NULL;
        hr = S_OK;
    }
    else
    {
         hr = _GetFolderIDList(iFolder, &pidlToFree);
         pidlFolder = pidlToFree;
    }

    if (SUCCEEDED(hr))
    {
        HIDDENDOCFINDDATA *phfd;
        int cb = ILGetSize(pidlFolder);
        int cbTotal = sizeof(*phfd) - sizeof(phfd->idlParent) + cb;
        hr = SHLocalAlloc(cbTotal, &phfd);
        if (SUCCEEDED(hr))
        {
            phfd->hid.cb = (WORD)cbTotal;
            phfd->hid.wVersion = 0;
            phfd->hid.id = IDLHID_DOCFINDDATA;
            phfd->iFolder = (WORD)iFolder;      // index to the folder DPA
            phfd->wFlags  = (WORD)uFlags;
            phfd->uRow = uRow;                  // Which row in the CI;
            phfd->dwItemID = dwItemID;          // Only used for Async support...
            phfd->ulRank = ulRank;              // The rank returned by CI...
            memcpy(&phfd->idlParent, pidlFolder, cb);
    
            hr = ILCloneWithHiddenID(pidl, &phfd->hid, ppidl);
            LocalFree(phfd);
        }
        ILFree(pidlToFree);
    }
    return hr;
}

HRESULT CreateFindWithFilter(IFindFilter *pff, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_OUTOFMEMORY;

    CFindFolder *pfindfldr = new CFindFolder(pff);
    if (pfindfldr)
    {
        hr = pfindfldr->Init();
        if (SUCCEEDED(hr))
            hr = pfindfldr->QueryInterface(riid, ppv);
        pfindfldr->Release();
    }

    return hr;
}

STDAPI CDocFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IFindFilter *pff;
    HRESULT hr = CreateNameSpaceFindFilter(&pff);
    if (SUCCEEDED(hr))
    {
        hr = CreateFindWithFilter(pff, riid, ppv);
        pff->Release();
    }

    return hr;    
}

STDAPI CComputerFindFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IFindFilter *pff;
    HRESULT hr = CreateDefaultComputerFindFilter(&pff);
    if (pff)
    {
        hr = CreateFindWithFilter(pff, riid, ppv);
        pff->Release();
    }
    return hr;    
}

HRESULT CFindFolder::MapToSearchIDList(LPCITEMIDLIST pidl, BOOL fMapToReal, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    
    LPITEMIDLIST pidlParent;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SplitIDList(pidl, &pidlParent, &pidlChild)))
    {
        EnterCriticalSection(&_csSearch);

        // loop through our DPA list and see if we can find a matach
        for (int i = 0; i < DPA_GetPtrCount(_hdpaPidf); i++)
        {
            FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
            if (pffli && ILIsEqual(pidlParent, &pffli->idl))
            {
                // We found the right one
                // so no lets transform the ID into one of our own
                // to return.  Note: we must catch the case where the
                // original one passed in was a simple pidl and do
                // the appropriate thing.
                //
                LPITEMIDLIST pidlToFree = NULL; // might need to cleanup in one case

                // If this is not a FS folder, just clone it.
                IShellFolder *psf;
                if (fMapToReal && SUCCEEDED(_Folder(pffli, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    if (SUCCEEDED(SHGetRealIDL(psf, pidlChild, &pidlToFree)))
                    {
                        pidlChild = pidlToFree; // use this below... 
                    }
                    psf->Release();
                }

                // create the doc find version of the pidl witht the
                // extra hidden items embedded
                AddDataToIDList(pidlChild, i, pidlParent, DFDF_NONE, 0, 0, 0, ppidl);
                ILFree(pidlToFree); // may be NULL

                break;  // done with this loop
            }
        }
        LeaveCriticalSection(&_csSearch);

        ILFree(pidlParent);
    }
    
    return *ppidl ? S_OK : S_FALSE;
}


// Called before saving folder list.  Needed especially in Asynch search, 
// (CI).  We lazily pull item data from RowSet only when list view asks 
// for it.  When we are leaving the search folder, we pull all items
// creating all necessary folder lists.  This ensure when saving  folder
// list, all are included.   
// remark : Fix bug#338714.

HRESULT CFindFolder::_UpdateItemList()
{
    USHORT cb = 0;
    int cItems;
    if (SUCCEEDED(GetItemCount(&cItems))) 
    {
        for (int i = 0; i < cItems; i++) 
        {
            FIND_ITEM *pesfi;
            if (DB_S_ENDOFROWSET == GetItem(i, &pesfi))
                break;
        }
    }
    return S_OK;
}

// IFindFolder
HRESULT CFindFolder::SaveFolderList(IStream *pstm)
{
    // We First pull all the items from RowSet (in Asynch case)
    _UpdateItemList();

    EnterCriticalSection(&_csSearch);

    // Now loop through our DPA list and see if we can find a matach
    for (int i = 0; i < DPA_GetPtrCount(_hdpaPidf); i++)
    {
        FIND_FOLDER_ITEM *pffli = _FolderListItem(i);
        if (EVAL(pffli))
            ILSaveToStream(pstm, &pffli->idl);
        else
            break;
    }
    LeaveCriticalSection(&_csSearch);

    // Now out a zero size item..
    USHORT cb = 0;
    pstm->Write(&cb, sizeof(cb), NULL);

    return TRUE;
}

// IFindFolder, Restore results out to file.
HRESULT CFindFolder::RestoreFolderList(IStream *pstm)
{
    // loop through and all all of the folders to our list...
    LPITEMIDLIST pidl = NULL;
    HRESULT hr;

    for (;;)
    {
        hr = ILLoadFromStream(pstm, &pidl); // frees [in,out] pidl for us
        
        if (pidl == NULL)
            break;   // end of the list
        else
        {
            int i;
            AddFolder(pidl, FALSE, &i);
        }
    }
    
    ILFree(pidl); // don't forget to free last pidl

    return hr;
}

HRESULT CFindFolder::SaveItemList(IStream *pstm)
{
    // We First serialize all of our PIDLS for each item in our list
    int cItems;
    if (SUCCEEDED(GetItemCount(&cItems))) 
    {
        // And Save the items that are in the list
        for (int i = 0; i < cItems; i++) 
        {
            FIND_ITEM *pesfi;
            HRESULT hr = GetItem(i, &pesfi);
            
            if (hr == DB_S_ENDOFROWSET)
                break;
            if (SUCCEEDED(hr) && pesfi)
                ILSaveToStream(pstm, &pesfi->idl);
        }
    }
    
    USHORT cb = 0;
    pstm->Write(&cb, sizeof(cb), NULL); // a Trailing NULL size to say end of pidl list...
    
    return S_OK;
}

HRESULT CFindFolder::RestoreItemList(IStream *pstm, int *pcItems)
{
    // And the pidls that are associated with the object
    int cItems = 0;
    LPITEMIDLIST pidl = NULL;    // don't free previous one
    FIND_ITEM *pesfi;
    for (;;)
    {
        if (FAILED(ILLoadFromStream(pstm, &pidl)) || (pidl == NULL))
            break;
        
        if (FAILED(AddPidl(cItems, pidl, (UINT)-1, &pesfi)) || !pesfi)
            break;
        cItems++;
    }

    ILFree(pidl);       // Free the last one read in

    *pcItems = cItems;
    return S_OK;
}

HRESULT CFindFolder::_GetFolderIDList(int iFolder, LPITEMIDLIST *ppidlParent)
{
    *ppidlParent = NULL;

    HRESULT hr = E_FAIL;
    EnterCriticalSection(&_csSearch);
    FIND_FOLDER_ITEM *pffli = _FolderListItem(iFolder);
    if (pffli)
        hr = SHILClone(&pffli->idl, ppidlParent);
    LeaveCriticalSection(&_csSearch);

    return hr;
}

HRESULT CFindFolder::GetParentsPIDL(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlParent)
{
    return _GetFolderIDList(GetFolderIndex(pidl), ppidlParent);
}

HRESULT CFindFolder::SetControllerNotifyObject(IFindControllerNotify *pfcn)
{
    IUnknown_Set((IUnknown **)&_pfcn, pfcn);
    return S_OK;
}

HRESULT CFindFolder::GetControllerNotifyObject(IFindControllerNotify **ppfcn)
{
    *ppfcn = _pfcn;
    if (_pfcn)
        _pfcn->AddRef();
    return _pfcn ? S_OK : S_FALSE;
}

STDMETHODIMP_(ULONG) CFindFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFindFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG  cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP CFindFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName,
    ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFindFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    // We do not want the def view to enumerate us, instead we
    // will tell defview to call us...
    *ppenum = NULL;     // No enumerator
    return S_FALSE;     // no enumerator (not error)
}

STDMETHODIMP CFindFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        hr = psf->BindToObject(pidl, pbc, riid, ppv);
        psf->Release();
    }
    return hr;
}


// Little helper function for bellow
HRESULT CFindFolder::_CompareFolderIndexes(int iFolder1, int iFolder2)
{
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&_csSearch);
    
    FIND_FOLDER_ITEM *pffli1 = _FolderListItem(iFolder1);
    FIND_FOLDER_ITEM *pffli2 = _FolderListItem(iFolder2);

    if (pffli1 && pffli2)
    {
        // Check our 1-level deep cache.  Since its is common for there to be multiple
        //  items in the same folder, during a sort operation, we often compare the
        //  same two folders repeatedly.
        if ((_iCompareFolderCache1 != iFolder1) || (_iCompareFolderCache2 != iFolder2))
        {
            TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];

            SHGetPathFromIDList(&pffli1->idl, szPath1);
            SHGetPathFromIDList(&pffli2->idl, szPath2);
            _iCompareFolderCacheResult = lstrcmpi(szPath1, szPath2);
            _iCompareFolderCache1 = iFolder1;
            _iCompareFolderCache2 = iFolder2;
        }
        hr = ResultFromShort(_iCompareFolderCacheResult);
    }

    LeaveCriticalSection(&_csSearch);
    return hr;
}

PCHIDDENDOCFINDDATA CFindFolder::_HiddenData(LPCITEMIDLIST pidl)
{
    return (PCHIDDENDOCFINDDATA)ILFindHiddenID(pidl, IDLHID_DOCFINDDATA);
}


UINT CFindFolder::GetFolderIndex(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = (PCHIDDENDOCFINDDATA)ILFindHiddenID(pidl, IDLHID_DOCFINDDATA);
    return phdfd ? phdfd->iFolder : -1;
}

FIND_FOLDER_ITEM *CFindFolder::_FolderListItem(int iFolder)
{
    return (FIND_FOLDER_ITEM *)DPA_GetPtr(_hdpaPidf, iFolder);
}

FIND_FOLDER_ITEM *CFindFolder::_FolderListItem(LPCITEMIDLIST pidl)
{
    return _FolderListItem(GetFolderIndex(pidl));
}

ULONG CFindFolder::_Rank(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    // Could be mixed if so put ones without rank at the end...
    return phdfd && (phdfd->wFlags & DFDF_EXTRADATA) ? phdfd->ulRank : 0;
}

DWORD CFindFolder::_ItemID(LPCITEMIDLIST pidl)
{
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    return phdfd && (phdfd->wFlags & DFDF_EXTRADATA) ? phdfd->dwItemID : -1;
}

HRESULT CFindFolder::_GetItemDisplayName(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR wzName, UINT cch)
{
    // Get the IShellFolder:
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        // Get the display name:
        hr = DisplayNameOf(psf, pidl, dwFlags, wzName, cch);
        psf->Release();
    }
    return hr;
}


// Given the 2 pidls, we extract the display name using DisplayNameOf and then
// if all goes well, we compare the two.
int CFindFolder::_CompareNames(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwFlags)
{
    int iRetVal = 0;
    WCHAR szName1[MAX_PATH], szName2[MAX_PATH];

    // Get the name for 1
    HRESULT hr = _GetItemDisplayName(pidl1, dwFlags, szName1, ARRAYSIZE(szName1));
    if (SUCCEEDED(hr))
    {
        // Get the name for 2
        hr = _GetItemDisplayName(pidl2, dwFlags, szName2, ARRAYSIZE(szName2));
        if (SUCCEEDED(hr))
        {
            // Compare and set value
            iRetVal = StrCmpLogicalW(szName1, szName2);
        }
    }

    return iRetVal;
}

int CFindFolder::_CompareByCachedSCID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRetVal = 0;
    
    // If sort on name, we will skip this and use the code below.
    if (!IsEqualSCID(_scidCached, SCID_NAME))
    {
        iRetVal = CompareBySCID(this, &_scidCached, pidl1, pidl2);
    }
    
    // If they are still the same, sort them alphabetically by the name:
    // When we want to sort by name (either becuase we are sorting the
    // name column, or because 2 items are identical in other regards) we 
    // want to display name vs the GetDetailsOf name for 2 reasons:
    //   1. Some folders like IE's History don't support GetDetailsEx.
    //   2. Recycle bin returns the file name, not the displayable name;
    //      so we would end up with "DC###..." instead of "New Folder".
    if (iRetVal == 0)
    {
        iRetVal = _CompareNames(pidl1, pidl2, SHGDN_INFOLDER | SHGDN_NORMAL);
        if (iRetVal == 0)  // the display names are the same, could they be in different folders?
        {
            iRetVal = _CompareNames(pidl1, pidl2, SHGDN_FORPARSING);
        }
    }

    return iRetVal;
}

STDMETHODIMP CFindFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pidl1 == ILFindLastID(pidl1));

    UINT iInputColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);
    UINT iMappedColumn = iInputColumn;

    if (_MapColIndex(&iMappedColumn))
    {
        if (IDFCOL_PATH == iMappedColumn)
        {
            UINT iFolder1 = GetFolderIndex(pidl1);
            UINT iFolder2 = GetFolderIndex(pidl2);

            if (iFolder1 != iFolder2)
                return _CompareFolderIndexes(iFolder1, iFolder2);
        }
        else
        {
            ASSERT(iMappedColumn == IDFCOL_RANK);

            ULONG ulRank1 = _Rank(pidl1);
            ULONG ulRank2 = _Rank(pidl2);
            if (ulRank1 < ulRank2)
                return ResultFromShort(-1);
            if (ulRank1 > ulRank2)
                return ResultFromShort(1);
        }
    }

    // Check the SCID cache and update it if necessary.
    if (_uiColumnCached != iInputColumn)
    {
        hr = MapColumnToSCID(iInputColumn, &_scidCached);
        if (SUCCEEDED(hr))
        {
            _uiColumnCached = iInputColumn;
        }
    }

    // Check if one is a folder and not the other. put folders before files.
    int iRes = CompareFolderness(this, pidl1, pidl2);
    if (iRes == 0)
    {
        iRes = _CompareByCachedSCID(pidl1, pidl2);
    }

    return ResultFromShort(iRes);
}

STDMETHODIMP CFindFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb = new CFindFolderViewCB(this);
        if (psfvcb)
        {
            SFV_CREATE sSFV = {0};
            sSFV.cbSize   = sizeof(sSFV);
            sSFV.pshf     = this;
            sSFV.psfvcb   = psfvcb;

            hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

            psfvcb->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenuCB *pcmcb = new CFindMenuCB();
        if (pcmcb)
        {
            hr = CDefFolderMenu_CreateEx(NULL, hwnd,
                    0, NULL, this, pcmcb, NULL, NULL, (IContextMenu * *)ppv);
            pcmcb->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    HRESULT hr;
    if (cidl == 0)
    {
        // defview asks to see if any items can be renamed this way, lame
        *prgfInOut = SFGAO_CANRENAME;
        hr = S_OK;
    }
    else
    {
        ASSERT(*apidl == ILFindLastID(*apidl))
        IShellFolder *psf;
        hr = _QueryItemShellFolder(apidl[0], &psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(cidl, apidl, prgfInOut);
            psf->Release();
        }
    }
    return hr;
}

//
// To be called back from within CDefFolderMenuE - Currently only used
//

// Some helper functions                
STDMETHODIMP CFindFolder::SetItemsChangedSinceSort()
{ 
    _fItemsChangedSinceSort = TRUE;
    _iCompareFolderCache1 = -1;     // an invalid folder index value
    return S_OK;
}

STDMETHODIMP CFindFolder::GetItemCount(INT *pcItems)
{ 
    ASSERT(pcItems);
    DBCOUNTITEM cItems = 0;

    EnterCriticalSection(&_csSearch);
    if (_hdpaItems)
        cItems = DPA_GetPtrCount(_hdpaItems);
    LeaveCriticalSection(&_csSearch);

    // If async, then we may not have grown our dpa yet... but in mixed case we have so take
    // max of the two...
    if (_pDFEnumAsync)
    {
        if (_cAsyncItems > cItems)
            cItems = _cAsyncItems;
    }

    *pcItems = SANE_ITEMCOUNT(cItems);
    return S_OK;
};


STDMETHODIMP CFindFolder::GetItem(int iItem, FIND_ITEM **ppItem)
{
    HRESULT  hr = E_FAIL; // just to init, use anything
    FIND_ITEM *pesfi;
    IFindEnum *pidfenum;

    GetAsyncEnum(&pidfenum);

    DWORD dwItemID = (UINT)-1;

    EnterCriticalSection(&_csSearch);
    int i = DPA_GetPtrCount(_hdpaItems);
    pesfi = (FIND_ITEM *) DPA_GetPtr(_hdpaItems, iItem);
    LeaveCriticalSection(&_csSearch);

    // Mondo hack to better handle Async searching (ROWSET), we are not sure if we
    // can trust the PIDL of the row as new rows may have been inserted...
    // Only do this if we are not looking at the previous item..

    if (pesfi && pidfenum && !_fSearchComplete && (iItem != _iGetIDList))
    {
        PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

        // As we can now have mixed results only blow away if this is an async guy...
        if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
        {
            pidfenum->GetItemID(iItem, &dwItemID);
            if (dwItemID != phdfd->dwItemID)
            {
                // Overload, pass NULL to ADDPIDL to tell system to free that item
                if (pesfi->dwState & (LVIS_SELECTED|LVIS_FOCUSED))
                    _AddFIND_ITEMToSaveStateList(pesfi);

                AddPidl(iItem, 0, NULL, NULL);
                pesfi = NULL;
            }
        }
    }
                                                                                   
    _iGetIDList = iItem;   // remember the last one we retrieved...

    if (!pesfi && (iItem >= 0))
    {
        // See if this is the async case
        if (pidfenum)
        {
            LPITEMIDLIST pidlT;

            hr = pidfenum->GetItemIDList(SANE_ITEMCOUNT(iItem), &pidlT);            
            if (SUCCEEDED(hr) && hr != DB_S_ENDOFROWSET)
            {
                AddPidl(iItem, pidlT, dwItemID, &pesfi);
                // See if this item should show up as selected...
                if (dwItemID == (UINT)-1)
                    pidfenum->GetItemID(iItem, &dwItemID);
                GetStateFromSaveStateList(dwItemID, &pesfi->dwState);
            }
        }
    }

    *ppItem = pesfi;

    if (hr != DB_S_ENDOFROWSET)
        hr = pesfi ? S_OK : E_FAIL;

    return hr;
}

STDMETHODIMP CFindFolder::DeleteItem(int iItem)
{
    HRESULT hr = E_FAIL;
    
    if (!_fInRefresh)
    {
        FIND_ITEM *pesfi;

        hr = E_INVALIDARG;
        // make sure the item is in dpa (if using cI)
        if (SUCCEEDED(GetItem(iItem, &pesfi)) && pesfi)
        {
            EnterCriticalSection(&_csSearch);
            DPA_DeletePtr(_hdpaItems, iItem);
            LeaveCriticalSection(&_csSearch);
            
            PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

            if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
            {
                //we are deleting async item...
                _cAsyncItems--;
            }
            
            if (pesfi->dwState &= LVIS_SELECTED)
            {
                // Need to update the count of items selected...
                _dflvrSel.DecrementIncludedCount();
            }
            LocalFree((HLOCAL)pesfi);

            hr = S_OK;
        }
    }
    return hr;
}

// evil window crawling code to get the listview from defview

HWND ListviewFromView(HWND hwnd)
{
    HWND hwndLV;

    do
    {
        hwndLV = FindWindowEx(hwnd, NULL, WC_LISTVIEW, NULL);
    }
    while ((hwndLV == NULL) && (hwnd = GetWindow(hwnd, GW_CHILD)));

    return hwndLV;
}

HWND ListviewFromViewUnk(IUnknown *punkView)
{
    HWND hwnd;
    if (SUCCEEDED(IUnknown_GetWindow(punkView, &hwnd)))
    {
        hwnd = ListviewFromView(hwnd);
    }
    return hwnd;
}

STDMETHODIMP CFindFolder::ValidateItems(IUnknown *punkView, int iItem, int cItems, BOOL bSearchComplete)
{
    IFindEnum *pidfenum;
    if (S_OK != GetAsyncEnum(&pidfenum) || _fAllAsyncItemsCached)
        return S_OK;    // nothing to validate.

    DWORD dwItemID = (UINT)-1;

    int cItemsInList;
    GetItemCount(&cItemsInList);

    // force reload of rows
    pidfenum->Reset();

    HWND hwndLV = ListviewFromViewUnk(punkView);

    int iLVFirst = ListView_GetTopIndex(hwndLV);
    int cLVItems = ListView_GetCountPerPage(hwndLV);

    if (iItem == -1)
    {
        iItem = iLVFirst;
        cItems = cLVItems;
    }

    // to avoid failing to update an item...
    if (bSearchComplete)
        _iGetIDList = -1;
        
    while ((iItem < cItemsInList) && cItems)
    {
        EnterCriticalSection(&_csSearch);
        FIND_ITEM *pesfi = (FIND_ITEM *) DPA_GetPtr(_hdpaItems, iItem);
        LeaveCriticalSection(&_csSearch);
        if (!pesfi)     // Assume that if we have not gotten this one we are in the clear...
            break;

        PCHIDDENDOCFINDDATA phdfd = _HiddenData(&pesfi->idl);

        if (phdfd && (phdfd->wFlags & DFDF_EXTRADATA))
        {
            pidfenum->GetItemID(iItem, &dwItemID);
            
            if (dwItemID != _ItemID(&pesfi->idl))
            {
                FIND_ITEM *pItem; // dummy to make GetItem happy
                // Oops don't match,
                if (InRange(iItem, iLVFirst, iLVFirst+cLVItems))
                {
                    if (SUCCEEDED(GetItem(iItem, &pItem)))
                    {
                        ListView_RedrawItems(hwndLV, iItem, iItem);
                    }
                }
                else
                {
                    AddPidl(iItem, NULL, 0, NULL);
                }
            }
        }
        else
        {
            break;  // stop after we reach first non ci item
        }
        iItem++;
        cItems--;
    }

    _fSearchComplete = bSearchComplete;

    return S_OK;
}

STDMETHODIMP CFindFolder::AddPidl(int i, LPCITEMIDLIST pidl, DWORD dwItemID, FIND_ITEM **ppcdfi)
{
    HRESULT hr = S_OK;

    ASSERT(GetCurrentThreadId() == _GUIThreadID);

    if (NULL == pidl)
    {
        EnterCriticalSection(&_csSearch);
        FIND_ITEM* pesfi = (FIND_ITEM*)DPA_GetPtr(_hdpaItems, i);
        if (pesfi)
        {
            LocalFree((HLOCAL)pesfi);
            DPA_SetPtr(_hdpaItems, i, NULL);
        }
        LeaveCriticalSection(&_csSearch);
        if (ppcdfi)
            *ppcdfi = NULL;
    }
    else
    {
        int cb = ILGetSize(pidl);
        FIND_ITEM *pesfi;
        hr = SHLocalAlloc(sizeof(*pesfi) - sizeof(pesfi->idl) + cb, &pesfi);
        if (SUCCEEDED(hr))
        {
            // pesfi->dwMask = 0;
            // pesfi->dwState = 0;
            pesfi->iIcon = -1;
            memcpy(&pesfi->idl, pidl, cb);

            EnterCriticalSection(&_csSearch);
            BOOL bRet = DPA_SetPtr(_hdpaItems, i, (void *)pesfi);
            LeaveCriticalSection(&_csSearch);

            if (bRet)
            {
                if (ppcdfi)
                    *ppcdfi = pesfi;
            }
            else
            {
                LocalFree((HLOCAL)pesfi);
                pesfi = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CFindFolder::SetAsyncEnum(IFindEnum *pdfEnumAsync)
{
    if (_pDFEnumAsync)
        _pDFEnumAsync->Release();

    _pDFEnumAsync = pdfEnumAsync;
    if (pdfEnumAsync)
        pdfEnumAsync->AddRef();
    return S_OK;
}

STDMETHODIMP CFindFolder::CacheAllAsyncItems()
{
    if (_fAllAsyncItemsCached)
        return S_OK;      // Allready done it...  

    IFindEnum *pidfenum;
    if (S_OK != GetAsyncEnum(&pidfenum))
        return S_FALSE; // nothing to do...

    // Probably the easiest thing to do is to simply walk through all of the items...
    int maxItems = SANE_ITEMCOUNT(_cAsyncItems);
    for (int i = 0; i < maxItems; i++)
    {
        FIND_ITEM *pesfi;
        GetItem(i, &pesfi);
    }

    _fAllAsyncItemsCached = TRUE;
    return S_OK;
}

BOOL CFindFolder::AllAsyncItemsCached()
{
    return _fAllAsyncItemsCached;
}

STDMETHODIMP CFindFolder::GetAsyncEnum(IFindEnum **ppdfEnumAsync)
{
    *ppdfEnumAsync = _pDFEnumAsync; // unreferecned!
    return *ppdfEnumAsync ? S_OK : S_FALSE;
}

STDMETHODIMP CFindFolder::SetAsyncCount(DBCOUNTITEM cCount)
{
    _cAsyncItems = cCount;
    _fAllAsyncItemsCached = FALSE;
    return S_OK;
}

STDMETHODIMP CFindFolder::ClearSaveStateList()
{
    DSA_DeleteAllItems(_hdsaSaveStateForIDs);
    _cSaveStateSelected = 0;
    return S_OK;
}

STDMETHODIMP CFindFolder::GetStateFromSaveStateList(DWORD dwItemID, DWORD *pdwState)
{
    for (int i = DSA_GetItemCount(_hdsaSaveStateForIDs); i-- > 0;)
    {
        // Pidl at start of structure...
        FIND_ITEM_SAVE_STATE *pessi = (FIND_ITEM_SAVE_STATE*)DSA_GetItemPtr(_hdsaSaveStateForIDs, i);
        if  (pessi->dwItemID == dwItemID)
        {    
            *pdwState = pessi->dwState;
            if (pessi->dwState & LVIS_SELECTED)
            {
                // Remember the counts of items that we have touched...
                _dflvrSel.IncrementIncludedCount();
                _cSaveStateSelected--;
            }

            // Any items we retrieve we can get rid of...
            DSA_DeleteItem(_hdsaSaveStateForIDs, i);
            return S_OK;
        }
    }
    return S_FALSE;
}

STDMETHODIMP CFindFolder::GetFolderListItemCount(INT *pcItemCount)
{ 
    *pcItemCount = 0;

    EnterCriticalSection(&_csSearch);
    if (_hdpaPidf)
        *pcItemCount = DPA_GetPtrCount(_hdpaPidf);
    LeaveCriticalSection(&_csSearch);
     
    return S_OK;
}

STDMETHODIMP CFindFolder::GetFolderListItem(int iItem, FIND_FOLDER_ITEM **ppdffi)
{ 
    EnterCriticalSection(&_csSearch);
    *ppdffi = (FIND_FOLDER_ITEM *)DPA_GetPtr(_hdpaPidf, iItem);
    LeaveCriticalSection(&_csSearch);
    return *ppdffi ? S_OK : E_FAIL;
}

class CFindMenuWrap : public CContextMenuForwarder
{
public:
    // IContextMenu overrides
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

protected:
    CFindMenuWrap(IDataObject* pdo, IContextMenu* pcmArray);
    ~CFindMenuWrap();
    friend HRESULT DFWrapIContextMenus(IDataObject* pdo, IContextMenu* pcm1, IContextMenu* pcm2, REFIID riid, void** ppv);

private:
    IDataObject *       _pdtobj;
};

CFindMenuWrap::CFindMenuWrap(IDataObject* pdo, IContextMenu* pcmArray) : CContextMenuForwarder(pcmArray)
{
    _pdtobj = pdo;
    _pdtobj->AddRef();
}

CFindMenuWrap::~CFindMenuWrap()
{
    _pdtobj->Release();
}

STDMETHODIMP CFindMenuWrap::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fIsLink = FALSE;

    // "link" has to create a link on the desktop, not in the folder (since we're not a real folder...)
    if (IS_INTRESOURCE(lpici->lpVerb))
    {
        WCHAR szCommandString[64];
        if (SUCCEEDED(ContextMenu_GetCommandStringVerb(_pcm, LOWORD((UINT_PTR)lpici->lpVerb), szCommandString, ARRAYSIZE(szCommandString))))
        {
            fIsLink = !StrCmpIW(szCommandString, L"link");
        }
    }
    else
    {
        fIsLink = !StrCmpIA(lpici->lpVerb, "link");
    }

    if (fIsLink)
    {
        // Note: old code used to check pdtobj, but we don't create this
        //       object unless we get one of them, so why check?
        ASSERT(_pdtobj);
        return SHCreateLinks(lpici->hwnd, NULL, _pdtobj,
                SHCL_USETEMPLATE | SHCL_USEDESKTOP | SHCL_CONFIRM, NULL);
    }

    return CContextMenuForwarder::InvokeCommand(lpici);
}

HRESULT DFWrapIContextMenu(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl,
                           IContextMenu* pcmExtra, void **ppvInOut)
{
    IContextMenu *pcmWrap = NULL;
    IContextMenu *pcmFree = (IContextMenu*)*ppvInOut;

    IDataObject* pdo;
    HRESULT hr = psf->GetUIObjectOf(hwnd, 1, &pidl, IID_X_PPV_ARG(IDataObject, NULL, &pdo));
    if (SUCCEEDED(hr))
    {
        hr = DFWrapIContextMenus(pdo, pcmFree, pcmExtra, IID_PPV_ARG(IContextMenu, &pcmWrap));
        pdo->Release();
    }

    pcmFree->Release();
    *ppvInOut = pcmWrap;
    
    return hr;
}

HRESULT DFWrapIContextMenus(IDataObject* pdo, IContextMenu* pcm1, IContextMenu* pcm2, REFIID riid, void** ppv)
{
    *ppv = NULL;

    IContextMenu * pcmArray;
    IContextMenu* rgpcm[2] = {pcm2, pcm1};
    HRESULT hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), IID_PPV_ARG(IContextMenu, &pcmArray));
    if (SUCCEEDED(hr))
    {
        CFindMenuWrap * p = new CFindMenuWrap(pdo, pcmArray);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        pcmArray->Release();
    }

    return hr;
}


STDMETHODIMP CFindFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindFolder, IShellFolder2),          //IID_ISHELLFolder2
        QITABENTMULTI(CFindFolder, IShellFolder, IShellFolder2),   // IID_IShellFolder
        QITABENT(CFindFolder, IFindFolder),        //IID_IFindFolder
        QITABENT(CFindFolder, IShellIcon),            //IID_IShellIcon
        QITABENT(CFindFolder, IPersistFolder2),       //IID_IPersistFolder2
        QITABENTMULTI(CFindFolder, IPersistFolder, IPersistFolder2), //IID_IPersistFolder
        QITABENTMULTI(CFindFolder, IPersist, IPersistFolder2),      //IID_IPersist
        QITABENT(CFindFolder, IShellIconOverlay),     //IID_IShellIconOverlay
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
    
// IPersistFolder2 implementation
STDMETHODIMP CFindFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DocFindFolder;
    return S_OK;
}

STDMETHODIMP CFindFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (_pidl)
        ILFree(_pidl);

    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CFindFolder::GetCurFolder(LPITEMIDLIST *ppidl) 
{    
    return GetCurFolderImpl(_pidl, ppidl);
}

// helper function to sort the selected ID list by something that
// makes file operations work reasonably OK, when both an object and it's
// parent is in the list...
//
int CALLBACK CFindFolder::_SortForDataObj(void *p1, void *p2, LPARAM lparam)
{
    // Since I do recursion, If I get the Folder index number from the
    // last element of each and sort by them such that the higher numbers
    // come first, should solve the problem fine...
    LPITEMIDLIST pidl1 = (LPITEMIDLIST)ILFindLastID((LPITEMIDLIST)p1);
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)ILFindLastID((LPITEMIDLIST)p2);
    CFindFolder *pff = (CFindFolder *)lparam;

    return pff->GetFolderIndex(pidl2) - pff->GetFolderIndex(pidl1);
}

LPITEMIDLIST CFindFolder::_GetFullPidlForItem(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlParent;
    if (S_OK == GetParentsPIDL(pidl, &pidlParent))
    {
        pidlRet = ILCombine(pidlParent, pidl);
        ILFree(pidlParent);
    }
    return pidlRet;
}

// we generate a non flat HIDA. this is so clients that
// use this HIDA will bind to the folder that the results came
// from instead of this folder that has runtime state that won't
// be present if we rebind

HRESULT CFindFolder::_PrepareHIDA(UINT cidl, LPCITEMIDLIST * apidl, HDPA *phdpa)
{
    HRESULT hr = E_OUTOFMEMORY;
    *phdpa = DPA_Create(0);
    if (*phdpa)
    {
        if (DPA_Grow(*phdpa, cidl))
        {
            for (UINT i = 0; i < cidl; i++)
            {
                LPITEMIDLIST pidl = _GetFullPidlForItem(apidl[i]);
                if (pidl)
                    DPA_InsertPtr(*phdpa, i, pidl);
            }

            // In order to make file manipulation functions work properly we
            // need to sort the elements to make sure if an element and one
            // of it's parents are in the list, that the element comes
            // before it's parents...
            DPA_Sort(*phdpa, _SortForDataObj, (LPARAM)this);
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    *ppv = NULL;

    // if just one item we can deletate to real folder
    if (cidl == 1)
    {
        // Note we may have been passed in a complex item so find the last
        ASSERT(ILIsEmpty(_ILNext(*apidl)));  // should be a single level PIDL!

        IShellFolder *psf;
        hr = _QueryItemShellFolder(apidl[0], &psf);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);

            // if we are doing context menu, then we will wrap this
            // interface in a wrapper object, that we can then pick
            // off commands like link to process specially
            if (SUCCEEDED(hr))
            {
                if (IsEqualIID(riid, IID_IContextMenu))
                {
                    // we also let the net/file guy add in a context menu if they want to
                    IContextMenu* pcmExtra = NULL;
                    _pfilter->GetItemContextMenu(hwnd, SAFECAST(this, IFindFolder*), &pcmExtra);
                
                    hr = DFWrapIContextMenu(hwnd, psf, apidl[0], pcmExtra, ppv);

                    ATOMICRELEASE(pcmExtra);
                }
                else if (IsEqualIID(riid, IID_IQueryInfo)) // && SHGetAttributes(psf, apidl[0], SFGAO_FILESYSTEM))
                {
                    WrapInfotip(SAFECAST(this, IShellFolder2 *), apidl[0], &SCID_DIRECTORY, (IUnknown *)*ppv);
                }
            }
            psf->Release();
        }
    }
    else if (cidl > 1)
    {
        if (IsEqualIID(riid, IID_IContextMenu))
        {
            // Try to create a menu object that we process ourself
            // Yes, do context menu.
            HKEY ahkeys[MAX_ASSOC_KEYS] = {0};
            DWORD ckeys = 0;

            LPITEMIDLIST pidlFull = _GetFullPidlForItem(apidl[0]);
            if (pidlFull)
            {
                // Get the hkeyProgID and hkeyBaseProgID from the first item.
                ckeys = SHGetAssocKeysForIDList(pidlFull, ahkeys, ARRAYSIZE(ahkeys));
                ILFree(pidlFull);
            }

            IContextMenuCB *pcmcb = new CFindMenuCB();
            if (pcmcb)
            {
                hr = CDefFolderMenu_Create2Ex(NULL, hwnd,
                                cidl, apidl, this, pcmcb,
                                ckeys, ahkeys,
                                (IContextMenu **)ppv);
                pcmcb->Release();
            }

            SHRegCloseKeys(ahkeys, ckeys);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            HDPA hdpa;
            hr = _PrepareHIDA(cidl, apidl, &hdpa);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateFileDataObject(&c_idlDesktop, cidl, (LPCITEMIDLIST*)DPA_GetPtrPtr(hdpa),
                                            NULL, (IDataObject **)ppv);
                DPA_FreeIDArray(hdpa);
            }
        }
    }

    return hr;
}

STDMETHODIMP CFindFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwRes, LPSTRRET pStrRet)
{
    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        if ((dwRes & SHGDN_INFOLDER) && (dwRes & SHGDN_FORPARSING) && !(dwRes & SHGDN_FORADDRESSBAR))
        {
            // The thumbnail cache uses this as a hit test... in search view we can have files with the same name.
            dwRes &= ~SHGDN_INFOLDER;
        }
        hr = psf->GetDisplayNameOf(pidl, dwRes, pStrRet);
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                                    DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    IShellFolder *psf;
    HRESULT hr = _QueryItemShellFolder(pidl, &psf);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlRenamed;
        hr = psf->SetNameOf(hwnd, pidl, PathFindFileName(pszName), dwRes, ppidlOut ? &pidlRenamed : NULL);
        if (SUCCEEDED(hr) && ppidlOut)
        {
            hr = AddDataToIDList(pidlRenamed, GetFolderIndex(pidl), NULL, DFDF_NONE, 0, 0, 0, ppidlOut);
            ILFree(pidlRenamed);
        }
        psf->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return _pfilter->GetDefaultSearchGUID(SAFECAST(this, IShellFolder2*), pGuid);
}

STDMETHODIMP CFindFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    return _pfilter->EnumSearches(SAFECAST(this, IShellFolder2*), ppenum);
}

HRESULT CFindFolder::_Folder(FIND_FOLDER_ITEM *pffli, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (pffli->psf)
        hr = S_OK;
    else
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, &pffli->idl, &pffli->psf));

    if (SUCCEEDED(hr))
        hr = pffli->psf->QueryInterface(riid, ppv);
    return hr;
}

HRESULT CFindFolder::GetFolder(int iFolder, REFIID riid, void **ppv)
{
    *ppv = NULL; 
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(iFolder);
    if (pffli)
        hr = _Folder(pffli, riid, ppv);

    LeaveCriticalSection(&_csSearch);

    return hr;
}

HRESULT CFindFolder::_FolderFromItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL; 
    HRESULT hr = E_FAIL;
    PCHIDDENDOCFINDDATA phdfd = _HiddenData(pidl);
    if (phdfd)
    {
        hr = SHBindToObject(NULL, riid, &phdfd->idlParent, ppv);
    }
    return hr;
}

HRESULT CFindFolder::_QueryItemShellFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf)
{
    *ppsf = NULL;
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(pidl);
    if (pffli)
    {
        if (pffli->psf)
            hr = S_OK;
        else
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, &pffli->idl, &pffli->psf));

        if (SUCCEEDED(hr))
        {
            *ppsf = pffli->psf;
            (*ppsf)->AddRef();
        }
    }

    LeaveCriticalSection(&_csSearch);

    if (FAILED(hr))
    {
        hr = _FolderFromItem(pidl, IID_PPV_ARG(IShellFolder, ppsf));
    }

    return hr;
}


HRESULT CFindFolder::_QueryItemInterface(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&_csSearch);

    FIND_FOLDER_ITEM *pffli = _FolderListItem(pidl);
    if (pffli)
        hr = _Folder(pffli, riid, ppv);

    LeaveCriticalSection(&_csSearch);

    if (FAILED(hr))
    {
        hr = _FolderFromItem(pidl, riid, ppv);
    }

    return hr;
}

HRESULT CFindFolder::_GetDetailsFolder()
{
    HRESULT hr;
    if (_psfDetails)
        hr = S_OK;  // in cache
    else 
    {
        IFindFilter *pfilter;
        hr = GetFindFilter(&pfilter);
        if (SUCCEEDED(hr)) 
        {
            hr = pfilter->GetColumnsFolder(&_psfDetails);
            pfilter->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetDetailsFolder();
    if (SUCCEEDED(hr))
        hr = _psfDetails->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

BOOL CFindFolder::_MapColIndex(UINT *piColumn)
{
    switch (*piColumn)
    {
    case IDFCOL_NAME:   // 0
        return FALSE;

    case IDFCOL_PATH:   // 1
    case IDFCOL_RANK:   // 2
        return TRUE;

    default:            // >= 3
        *piColumn -= IDFCOL_RANK;
        return FALSE;
    }
}

STDMETHODIMP CFindFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr;
    
    if (_MapColIndex(&iColumn))
    {
        *pdwState = c_find_cols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        hr = _GetDetailsFolder();
        if (SUCCEEDED(hr))
        {
            hr = _psfDetails->GetDefaultColumnState(iColumn, pdwState);
            *pdwState &= ~SHCOLSTATE_SLOW;  // virtual lv and defview
        }
    }
    return hr;
}

HRESULT CFindFolder::_GetFolderName(LPCITEMIDLIST pidl, DWORD gdnFlags, LPTSTR psz, UINT cch)
{
    LPITEMIDLIST pidlFolder;
    HRESULT hr = GetParentsPIDL(pidl, &pidlFolder);
    if (SUCCEEDED(hr))
    { 
        hr = SHGetNameAndFlags(pidlFolder, gdnFlags, psz, cch, NULL);
        ILFree(pidlFolder);
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr;
    if (IsEqualSCID(*pscid, SCID_RANK))
    {
        hr = InitVariantFromUINT(pv, _Rank(pidl));
    }
    else
    {
        IShellFolder2 *psf;
        hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
            psf->Release();
        }

        if (FAILED(hr))
        {
            if (IsEqualSCID(*pscid, SCID_DIRECTORY))
            {
                TCHAR szTemp[MAX_PATH];
                hr = _GetFolderName(pidl, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStr(pv, szTemp);
                }
            }
        }
    }
    return hr;
}

//  Figure out what the correct column index is to match the scid we are given
//  where the returned index is relative to the folder passed in.
int MapSCIDToColumnForFolder(IShellFolder2 *psf, SHCOLUMNID scidIn)
{
    SHCOLUMNID scidNew;
    for (UINT i = 0; SUCCEEDED(psf->MapColumnToSCID(i, &scidNew)); i++)
    {
        if (IsEqualSCID(scidNew, scidIn))
        {
            return i;   // found
        }
    }
    return -1;  // not found
}

STDMETHODIMP CFindFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        if (pidl)
        {
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = 0;
            if (IDFCOL_PATH == iColumn)   
            {
                _GetFolderName(pidl, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szTemp, ARRAYSIZE(szTemp));
            }
            else
            {
                ASSERT(IDFCOL_RANK == iColumn);
                ULONG uRank = _Rank(pidl);
                if (uRank)
                    AddCommas(uRank, szTemp, ARRAYSIZE(szTemp));
            }
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            hr = GetDetailsOfInfo(c_find_cols, ARRAYSIZE(c_find_cols), iColumn, pdi);
        }
    }
    else
    {
        if (pidl)
        {
            IShellFolder2 *psf;
            hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellFolder2, &psf));
            if (SUCCEEDED(hr))
            {
                //  We cannot simply ask for GetDetailsOf because some folders map different
                //  column numbers to differnt values.
                //  Translate the column index to the SHCOLUMNID relative to this folder.
                SHCOLUMNID colId;
                hr = _GetDetailsFolder();
                if (SUCCEEDED(hr))
                    hr = _psfDetails->MapColumnToSCID(iColumn, &colId);

                //  Use the SCID to get the correct column index...
                if (SUCCEEDED(hr))
                {
                    //  Get the column index for the SCID with respect to the other folder
                    int newIndex = MapSCIDToColumnForFolder(psf, colId);
                    if (newIndex != -1)
                    {
                        //  Found the correct column index, so use it to get the data
                        hr = psf->GetDetailsOf(pidl, newIndex, pdi);
                    }
                    else
                    {
                        //  Failed to find the correct column index.
                        hr = E_FAIL;
                    }
                }
                
                psf->Release();
            }
        }
        else
        {
            hr = _GetDetailsFolder();
            if (SUCCEEDED(hr))
                hr = _psfDetails->GetDetailsOf(NULL, iColumn, pdi);
        }
    }
    return hr;
}

STDMETHODIMP CFindFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        hr = MapColumnToSCIDImpl(c_find_cols, ARRAYSIZE(c_find_cols), iColumn, pscid);
    }
    else
    {
        hr = _GetDetailsFolder();
        if (SUCCEEDED(hr))
            hr = _psfDetails->MapColumnToSCID(iColumn, pscid);
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetFindFilter(IFindFilter **ppfilter)
{
    return _pfilter->QueryInterface(IID_PPV_ARG(IFindFilter, ppfilter));
}

// IShellIcon::GetIconOf
STDMETHODIMP CFindFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    IShellIcon * psiItem;
    HRESULT hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellIcon, &psiItem));
    if (SUCCEEDED(hr))
    {
        hr = psiItem->GetIconOf(pidl, flags, piIndex);
        psiItem->Release();
    }
    return hr;
}

// IShellIconOverlay
STDMETHODIMP CFindFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    IShellIconOverlay * psioItem;
    HRESULT hr = _QueryItemInterface(pidl, IID_PPV_ARG(IShellIconOverlay, &psioItem));
    if (SUCCEEDED(hr))
    {
        hr = psioItem->GetOverlayIndex(pidl, pIndex);
        psioItem->Release();
    }
    return hr;
}

STDMETHODIMP CFindFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFindFolder::RestoreSearchFromSaveFile(LPCITEMIDLIST pidlSaveFile, IShellFolderView *psfv)
{
    // See if we can restore most of the search from here...
    IStream *pstm;
    HRESULT hr = StgBindToObject(pidlSaveFile, STGM_READ | STGM_SHARE_DENY_WRITE, IID_PPV_ARG(IStream, &pstm));
    if (SUCCEEDED(hr))
    {
        ULONG cbRead;
        DFHEADER dfh;

        // Note: in theory I should test the size read by the size of the
        // smaller headers, but if the number of bytes read is smaller than
        // the few new things added then there is nothing to restore anyway...

        // Note: Win95/NT4 incorrectly failed newer versions of this structure.
        // Which is bogus since the struct was backward compatible (that's what
        // the offsets are for).  We fix for NT5 and beyond, but downlevel
        // systems are forever broken.  Hopefully this feature is rarely enough
        // used (and never mailed) that nobody will notice we're broken.

        if (SUCCEEDED(pstm->Read(&dfh, sizeof(dfh), &cbRead)) &&
            (sizeof(dfh) == cbRead) && (DOCFIND_SIG == dfh.wSig))
        {
            DFC_UNICODE_DESC desc;
            LARGE_INTEGER dlibMove = {0, 0};
            WORD fCharType = 0;

            // Check the stream's signature to see if it was generated by Win95 or NT.
            dlibMove.QuadPart = -(LONGLONG)sizeof(desc);
            pstm->Seek(dlibMove, STREAM_SEEK_END, NULL);
            pstm->Read(&desc, sizeof(desc), &cbRead);
            if (cbRead > 0 && desc.NTsignature == c_NTsignature)
            {
               // NT-generated stream.  Read in Unicode criteria.
               fCharType = DFC_FMT_UNICODE;
               dlibMove.QuadPart = desc.oUnicodeCriteria.QuadPart;
            }
            else
            {
               // Win95-generated stream.  Read in ANSI criteria.
               fCharType = DFC_FMT_ANSI;
               dlibMove.LowPart = dfh.oCriteria;
            }
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
            _pfilter->RestoreCriteria(pstm, dfh.cCriteria, fCharType);

            // Now read in the results
            dlibMove.LowPart = dfh.oResults;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);

            if (dfh.wVer > 1)
            {
                // only restore this way if version 2 data....
                // Now Restore away the folder list
                RestoreFolderList(pstm);
                int cItems = 0;
                RestoreItemList(pstm, &cItems);
                if (cItems > 0)
                    psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
            }
        }
        else
            hr = E_FAIL;
        pstm->Release();
    }
    return hr;
}

// a form of this code is duplicated in browseui searchext.cpp
//
BOOL RealFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile)
{
    // First create the top level browser...
    IWebBrowser2 *pwb2;
    HRESULT hr = CoCreateInstance(CLSID_ShellBrowserWindow, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        VARIANT varClsid;
        hr = InitBSTRVariantFromGUID(&varClsid, CLSID_FileSearchBand);
        if (SUCCEEDED(hr))
        {
            VARIANT varEmpty = {0};

            // show a search bar
            hr = pwb2->ShowBrowserBar(&varClsid, &varEmpty, &varEmpty);
            if (SUCCEEDED(hr))
            {
                // Grab the band's IUnknown from browser property.
                VARIANT varFsb;
                hr = pwb2->GetProperty(varClsid.bstrVal, &varFsb);
                if (SUCCEEDED(hr))
                {
                    //  QI for IFileSearchBand, which we'll use to program the search band's
                    //  search type (files or folders), inititial scope, and/or saved query file.
                    IFileSearchBand* pfsb;
                    if (SUCCEEDED(QueryInterfaceVariant(varFsb, IID_PPV_ARG(IFileSearchBand, &pfsb))))
                    {
                        BSTR bstrSearch;
                        hr = BSTRFromCLSID(SRCID_SFileSearch, &bstrSearch);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varQueryFile = {0}, varScope = {0};

                            //  assign initial scope
                            if (pidlFolder)
                                InitVariantFromIDList(&varScope, pidlFolder);
                            //  assign query file from which to restore search
                            else if (pidlSaveFile)
                                InitVariantFromIDList(&varQueryFile, pidlSaveFile);

                            pfsb->SetSearchParameters(&bstrSearch, VARIANT_TRUE, &varScope, &varQueryFile);

                            VariantClear(&varScope);
                            VariantClear(&varQueryFile);

                            SysFreeString(bstrSearch);
                        }
                        pfsb->Release();
                    }
                    VariantClear(&varFsb);
                }

                if (SUCCEEDED(hr))
                    hr = pwb2->put_Visible(TRUE);
            }
            VariantClear(&varClsid); // frees bstrFileSearchBand too
        }
        pwb2->Release();
    }
    return hr;
}

HRESULT CFindFolder::OpenContainingFolder(IUnknown *punkSite)
{
    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;
        hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IEnumIDList, &penum));
        if (S_OK == hr)
        {
            LPITEMIDLIST pidl;
            ULONG c;
            while (S_OK == penum->Next(1, &pidl, &c))
            {
                // Now get the parent of it.
                LPITEMIDLIST pidlParent;
                if (SUCCEEDED(GetParentsPIDL(pidl, &pidlParent)))
                {
                    SHOpenFolderAndSelectItems(pidlParent, 1, (LPCITEMIDLIST *)&pidl, 0);
                    ILFree(pidlParent);
                }
                ILFree(pidl);
            }
            penum->Release();
        }
        pfv->Release();
    }
    return hr;
}

// Save away the current search to a file on the desktop.
// For now the name will be automatically generated.
//
void CFindFolder::Save(IFindFilter* pfilter, HWND hwnd, DFBSAVEINFO * pSaveInfo, IShellView* psv, IUnknown *pObject)
{
    TCHAR szFilePath[MAX_PATH];
    IStream * pstm;
    DFHEADER dfh;
    TCHAR szTemp[MAX_PATH];
    SHORT cb;
    LARGE_INTEGER dlibMove = {0, 0};
    ULARGE_INTEGER libCurPos;
    FOLDERSETTINGS fs;
    HRESULT hr;
    
    //
    // See if the search already has a file name associated with it.  If so
    // we will save it in it, else we will create a new file on the desktop
    if (pfilter->FFilterChanged() == S_FALSE)
    {
        // Lets blow away the save file
        ILFree(pSaveInfo->pidlSaveFile);
        pSaveInfo->pidlSaveFile = NULL;
    }
    
    // If it still looks like we want to continue to use a save file then
    // continue.
    if (pSaveInfo->pidlSaveFile)
    {
        SHGetPathFromIDList(pSaveInfo->pidlSaveFile, szFilePath);
    }
    else
    {
        // First get the path name to the Desktop.
        SHGetSpecialFolderPath(NULL, szFilePath, CSIDL_PERSONAL, TRUE);
        
        // and update the title
        // we now do this before getting a filename because we generate
        // the file name from the title
        
        LPTSTR pszTitle;
        BOOL fNameOk = FALSE;

        pfilter->GenerateTitle(&pszTitle, TRUE);
        if (pszTitle)
        {
            // Now add on the extension.
            UINT cchRemaining = MAX_PATH - lstrlen(szFilePath);
            cchRemaining -= 1;          // "\" between path and filename
            cchRemaining -= 4;          // ".fnd" = 4 characters
            cchRemaining -= 3;          // "###" for unique-ify-ing the name
            cchRemaining -= 1;          // (no idea)

            hr = StringCchCopy(szTemp, cchRemaining, pszTitle);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT(".fnd"));
                if (SUCCEEDED(hr))
                {
                    fNameOk = TRUE;
                }
            }

            LocalFree(pszTitle);     // And free the title string.
        }

        if (!fNameOk)
        {
            szTemp[0] = 0;
        }
        
        // Now loop through and replace all of the invalid characters with _'s
        // we special case a few of the characters...
        for (LPTSTR lpsz = szTemp; *lpsz; lpsz = CharNext(lpsz))
        {
            if (PathGetCharType(*lpsz) & (GCT_INVALID|GCT_WILD|GCT_SEPARATOR))
            {
                switch (*lpsz) 
                {
                case TEXT(':'):
                    *lpsz = TEXT('-');
                    break;
                case TEXT('*'):
                    *lpsz = TEXT('@');
                    break;
                case TEXT('?'):
                    *lpsz = TEXT('!');
                    break;
                default:
                    *lpsz = TEXT('_');
                }
            }
        }
        
        TCHAR szShortName[12];
        LoadString(HINST_THISDLL, IDS_FIND_SHORT_NAME, szShortName, ARRAYSIZE(szShortName));
        if (!PathYetAnotherMakeUniqueName(szFilePath, szFilePath, szShortName, szTemp))
            return;
    }
    
    // Now lets bring up the save as dialog...
    TCHAR szFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szFilename[MAX_PATH];
    OPENFILENAME ofn = { 0 };
    
    LoadString(g_hinst, IDS_FINDFILESFILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString(g_hinst, IDS_FINDSAVERESULTSTITLE, szTitle, ARRAYSIZE(szTitle));
    
    //Strip out the # and make them Nulls for SaveAs Dialog
    LPTSTR psz = szFilter;
    while (*psz)
    {
        if (*psz == TEXT('#'))
            *psz = 0;
        psz++;
    }
    
    StringCchCopy(szFilename, ARRAYSIZE(szFilename), PathFindFileName(szFilePath));
    PathRemoveFileSpec(szFilePath);
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = g_hinst;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szFilePath;
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = TEXT("fnd");
    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | 
        OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;
    ofn.lpTemplateName = NULL;
    ofn.lpfnHook= NULL;
    ofn.lCustData = NULL;
    
    if (!GetSaveFileName(&ofn))
        return;
    
    if (FAILED(SHCreateStreamOnFile(szFilename, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstm)))
        return;
    
    // remember the file that we saved away to...
    ILFree(pSaveInfo->pidlSaveFile);
    SHParseDisplayName(szFilename, NULL, &pSaveInfo->pidlSaveFile, 0, NULL);
    
    // Now setup and write out header information
    ZeroMemory(&dfh, sizeof(dfh));
    dfh.wSig = DOCFIND_SIG;
    dfh.wVer = DF_CURFILEVER;
    dfh.dwFlags =  pSaveInfo->dwFlags;
    dfh.wSortOrder = (WORD)pSaveInfo->SortMode;
    dfh.wcbItem = sizeof(DFITEM);
    dfh.oCriteria = sizeof(dfh);
    // dfh.cCriteria = sizeof(s_aIndexes) / sizeof(SHORT);
    // dfh.oResults =;
    
    // Not used anymore...
    dfh.cResults = -1;
    
    // Note: Later we may convert this to DOCFILE where the
    // criteria is stored as properties.
    
    // Get the current Folder Settings
    if (SUCCEEDED(psv->GetCurrentInfo(&fs)))
        dfh.ViewMode = fs.ViewMode;
    else
        dfh.ViewMode = FVM_DETAILS;
    
    // Now call the filter object to save out his own set of criterias
    
    dlibMove.LowPart = dfh.oCriteria;
    pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    hr = pfilter->SaveCriteria(pstm, DFC_FMT_ANSI);
    if (SUCCEEDED(hr))
        dfh.cCriteria = GetScode(hr);
    
    // Now setup to output the results
    dlibMove.LowPart = 0;
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos); // Get current pos
    dfh.oResults = libCurPos.LowPart;
    //
    // Now Let our file folder serialize his results out here also...
    // But only if the option is set to do so...
    //
    cb = 0;
    
    // Write out a Trailing NULL for Folder list
    pstm->Write(&cb, sizeof(cb), NULL);
    // And item list.
    pstm->Write(&cb, sizeof(cb), NULL);
    
    // END of DFHEADER_WIN95 information
    // BEGIN of NT5 information:
    
    // Now setup to output the history stream
    if (pObject)
    {
        dlibMove.LowPart = 0;
        pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos); // Get current pos
        dfh.oHistory = libCurPos.LowPart;
        
        if (FAILED(SavePersistHistory(pObject, pstm)))
        {
            // On failure we might as well just pretend we didn't save this bit of data.
            // Do we need an error message -- the ui won't be right when relaunched...
            //
            dfh.oHistory = 0;
            dlibMove.LowPart = libCurPos.LowPart;
            pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
        }
    }
    
    // In NT the below was done AT THE END OF THE STREAM instead of
    // revving the DFHEADER struct.  (Okay, DFHEADEREX, since Win95
    // already broke DFHEADER back compat by in improper version check)
    // This could have been done by putting a propery signatured
    // DFHEADEREX that had proper versioning so we could add information
    // to.  Unfortunately another hardcoded struct was tacked on to
    // the end of the stream...   Next time, please fix the problem
    // instead of work around it.
    //
    // What this boils down to is we cannot put any information
    // after the DFC_UNICODE_DESC section, so might as well
    // always do this SaveCriteria section last...
    //
    // See comment at top of file for DFC_UNICODE_DESC.
    //
    DFC_UNICODE_DESC desc;
    
    //
    // Get the current location in stream.  This is the offset where
    // we'll write the unicode find criteria.  Save this
    // value (along with NT-specific signature) in the descriptor
    //
    dlibMove.LowPart = 0;
    pstm->Seek(dlibMove, STREAM_SEEK_CUR, &libCurPos);
    
    desc.oUnicodeCriteria.QuadPart = libCurPos.QuadPart;
    desc.NTsignature               = c_NTsignature;
    
    // Append the Unicode version of the find criteria.
    hr = pfilter->SaveCriteria(pstm, DFC_FMT_UNICODE);
    
    // Append the unicode criteria descriptor to the end of the file.
    pstm->Write(&desc, sizeof(desc), NULL);
    //
    // don't put any code between the above DFC_UNICDE_DESC section
    // and this back-patch of the dfh header...
    //
    // Finally output the header information at the start of the file
    // and close the file
    //
    pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
    pstm->Write(&dfh, sizeof(dfh), NULL);
    pstm->Release();
    
    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pSaveInfo->pidlSaveFile, NULL);
    SHChangeNotify(SHCNE_FREESPACE, SHCNF_IDLIST, pSaveInfo->pidlSaveFile, NULL);
}

// Broke out from class to share with old and new code
BOOL CFindFolder::HandleUpdateDir(LPCITEMIDLIST pidl, BOOL fCheckSubDirs)
{
    // 1. Start walk through list of dirs.  Find list of directories effected
    //    and mark them
    // 2. Walk the list of items that we have and mark each of the items that
    //    that are in our list of directories and then do a search...
    BOOL fCurrentItemsMayBeImpacted = FALSE;
    FIND_FOLDER_ITEM *pffli;
    INT cPidf;

    // First see which directories are effected...
    GetFolderListItemCount(&cPidf);
    for (int iPidf = 0; iPidf < cPidf; iPidf++)
    {        
        if (SUCCEEDED(GetFolderListItem(iPidf, &pffli)) 
            && !pffli->fUpdateDir) // We may have already impacted these...
        {
            pffli->fUpdateDir = ILIsParent(pidl, &pffli->idl, FALSE);
            fCurrentItemsMayBeImpacted |= pffli->fUpdateDir;
        }
    }

    if (fCurrentItemsMayBeImpacted)
    {
        // Now we need to walk through the whole list and remove any entries
        // that are no longer there...
        //
        int iItem;
        if (SUCCEEDED(GetItemCount(&iItem))) 
        {
            for (--iItem; iItem >= 0; iItem--)
            {
                FIND_ITEM *pesfi;
                if (SUCCEEDED(GetItem(iItem, &pesfi)) && pesfi)
                {
                    UINT iFolder = GetFolderIndex(&pesfi->idl);
                
                    // See if item may be impacted...
                    if (SUCCEEDED(GetFolderListItem(iFolder, &pffli)) && pffli->fUpdateDir)
                        pesfi->dwState |= CDFITEM_STATE_MAYBEDELETE;
                }
            }
        }
    }

    return fCurrentItemsMayBeImpacted;
}

void CFindFolder::UpdateOrMaybeAddPidl(IShellFolderView *psfv, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlOld)
{
    HRESULT hr;

    // First see if we should try to do an update...
    if (pidlOld)
    {
        LPITEMIDLIST pidlT;
        if (S_OK == MapToSearchIDList(pidl, TRUE, &pidlT))
        {
            SetItemsChangedSinceSort();
            UINT iItem;
            // cast needed for bad interface def
            hr = psfv->UpdateObject((LPITEMIDLIST)pidlOld, (LPITEMIDLIST)pidlT, &iItem);

            ILFree(pidlT);  // In either case simply blow away our generated pidl...
            if (SUCCEEDED(hr))
                return;
        }
    }

    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        BOOL fMatch = FALSE;
        // See if this item matches the filter...
        IFindFilter *pfilter;
        if (SUCCEEDED(GetFindFilter(&pfilter))) 
        {
            fMatch = pfilter->MatchFilter(psf, pidlChild) != 0;
            pfilter->Release();
        }

        psf->Release();

        if (fMatch)
        {
            LPITEMIDLIST pidlT;
            if (S_OK != MapToSearchIDList(pidl, TRUE, &pidlT))
            {
                fMatch = FALSE;

                // The folder has not been added before now...
                TCHAR szPath[MAX_PATH];
                SHGetPathFromIDList(pidl, szPath);
                if (!IsFileInBitBucket(szPath))
                {
                    PathRemoveFileSpec(szPath);

                    LPITEMIDLIST pidlFolder;
                    if (SUCCEEDED(SHParseDisplayName(szPath, NULL, &pidlFolder, 0, NULL)))
                    {
                        int iFolder;
                        hr = AddFolder(pidlFolder, TRUE, &iFolder);
                        if (SUCCEEDED(hr))
                        {
                            fMatch = (S_OK == MapToSearchIDList(pidl, TRUE, &pidlT));
                        }
                        ILFree(pidlFolder);
                    }
                }
            }

            if (fMatch)
            {
                // There are times we get notified twice.  To handle this
                // see if the item is already in our list.  If so punt...

                SetItemsChangedSinceSort();

                UINT iItem;
                if (FAILED(psfv->UpdateObject(pidlT, pidlT, &iItem)))
                {
                    // item not in the view yet... so we need to add it

                    if (SUCCEEDED(GetItemCount((INT *)&iItem))) 
                    {
                        // Normal case would be here to add the object
                        // We need to add this to our dpa and dsa...
                        FIND_ITEM *pesfi;
                        AddPidl(iItem, pidlT, (UINT)-1, &pesfi);
                        if (pesfi)
                            psfv->SetObjectCount(++iItem, SFVSOC_NOSCROLL);
                    }
                }
                ILFree(pidlT);
            }
            else
            {
                ASSERT(NULL == pidlT);
            }
        }
    }
}

void CFindFolder::HandleRMDir(IShellFolderView *psfv, LPCITEMIDLIST pidl)
{
    BOOL fCurrentItemsMayBeImpacted = FALSE;
    FIND_FOLDER_ITEM *pffli;
    INT cItems;
    FIND_ITEM *pesfi;

    // First see which directories are effected...
    GetFolderListItemCount(&cItems);
    for (int iItem = 0; iItem < cItems; iItem++)
    {         
        if (SUCCEEDED(GetFolderListItem(iItem, &pffli)))
        {
            pffli->fDeleteDir = ILIsParent(pidl, &pffli->idl, FALSE);
            fCurrentItemsMayBeImpacted |= pffli->fDeleteDir;
        }
        else 
        {
#ifdef DEBUG
            INT cItem;
            GetFolderListItemCount(&cItem);
            TraceMsg(TF_WARNING, "NULL pffli in _handleRMDir (iItem == %d, ItemCount()==%d)!!!", iItem, cItems);
#endif
        }
    }

    if (fCurrentItemsMayBeImpacted)
    {
        // Now we need to walk through the whole list and remove any entries
        // that are no longer there...
        if (SUCCEEDED(GetItemCount(&iItem))) 
        {
            for (--iItem; iItem >= 0; iItem--)
            {
                if (FAILED(GetItem(iItem, &pesfi)) || pesfi == NULL)
                    continue;

                // See if item may be impacted...
                UINT iFolder = GetFolderIndex(&pesfi->idl);
                if (SUCCEEDED(GetFolderListItem(iFolder, &pffli)) 
                    && pffli->fDeleteDir) 
                {
                    psfv->RemoveObject(&pesfi->idl, (UINT*)&cItems);
                }
            }
        }
    }
}

// export used for Start.Search-> cascade menu

STDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwnd, UINT idCmdFirst, UINT idCmdLast)
{
    IContextMenu * pcm = NULL;
    HKEY hkFind = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("FindExtensions"), FALSE);
    if (hkFind) 
    {
        if (SUCCEEDED(CDefFolderMenu_CreateHKeyMenu(hwnd, hkFind, &pcm))) 
        {
            int iItems = GetMenuItemCount(hmenu);
            // nuke all old entries
            while (iItems--) 
            {
                DeleteMenu(hmenu, iItems, MF_BYPOSITION);
            }

            pcm->QueryContextMenu(hmenu, 0, idCmdFirst, idCmdLast, CMF_NODEFAULT|CMF_INCLUDESTATIC|CMF_FINDHACK);
            iItems = GetMenuItemCount(hmenu);
            if (!iItems) 
            {
                TraceMsg(TF_DOCFIND, "no menus in find extension, blowing away context menu");
                pcm->Release();
                pcm = NULL;
            }
        }
        RegCloseKey(hkFind);
    }
    return pcm;
}


void _SetObjectCount(IShellView *psv, int cItems, DWORD dwFlags)
{
    IShellFolderView *psfv;
    if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv)))) 
    {
        psfv->SetObjectCount(cItems, dwFlags);
        psfv->Release();
    }
}

typedef struct
{
    PFNLVCOMPARE pfnCompare;
    LPARAM       lParamSort;
} FIND_SORT_INFO;

int CALLBACK _FindCompareItems(void *p1, void *p2, LPARAM lParam)
{
    FIND_SORT_INFO *pfsi = (FIND_SORT_INFO*)lParam;
    return pfsi->pfnCompare(PtrToInt(p1), PtrToInt(p2), pfsi->lParamSort);
}

HRESULT CFindFolderViewCB::OnSortListData(DWORD pv, PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
{
    EnterCriticalSection(&_pff->_csSearch);

    // First mark the focused item in the list so we can find it later...
    FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, _iFocused);    // indirect
    if (pesfi)
        pesfi->dwState |= LVIS_FOCUSED;

    int cItems = DPA_GetPtrCount(_pff->_hdpaItems);
    HDPA hdpaForSorting = NULL;
    if (cItems)
    {
        hdpaForSorting = DPA_Create(cItems);
    }

    if (hdpaForSorting)
    {
        for (int i = 0; i< cItems; i++)
        {
            DPA_SetPtr(hdpaForSorting, i, IntToPtr(i));
        }
        // sort out items
        FIND_SORT_INFO fsi;
        fsi.pfnCompare = pfnCompare;
        fsi.lParamSort = lParamSort;

        DPA_Sort(hdpaForSorting, _FindCompareItems, (LPARAM)&fsi);
        for (i = 0; i < cItems; i++)
        {
            int iIndex = PtrToInt(DPA_FastGetPtr(hdpaForSorting, i));

            // Move the items from _hdpaItems to hdpaForSorting in sorted order
            DPA_SetPtr(hdpaForSorting, i, DPA_FastGetPtr(_pff->_hdpaItems, iIndex));
        }
        // Now switch the two HDPA to get the sorted list in the member variable
        DPA_Destroy(_pff->_hdpaItems);
        _pff->_hdpaItems = hdpaForSorting;
    }

    // Now find the focused item and scroll it into place...
    IShellView *psv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
    {
        int iFocused = -1;

        // Tell the view we need to reshuffle....
        // Gross, this one defaults to invalidate all which for this one is fine...
        _SetObjectCount(psv, cItems, SFVSOC_INVALIDATE_ALL); // Invalidate all

        for (int iEnd = cItems - 1; iEnd >= 0; iEnd--)
        {
            pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iEnd);    // indirect
            if (pesfi && pesfi->dwState & LVIS_FOCUSED)
                iFocused = iEnd;
        }
        // Now handle the focused item...
        if (iFocused != -1)
        {
            _pff->_iGetIDList = iFocused;   // remember the last one we retrieved...
            pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iFocused);    // indirect
            if (pesfi)
            {
                // flags depend on first one and also if selected?
                psv->SelectItem(&pesfi->idl, SVSI_FOCUSED | SVSI_ENSUREVISIBLE | SVSI_SELECT);
                pesfi->dwState &= ~LVIS_FOCUSED;    // don't keep it around to get lost later...
            }
        }

        _iFocused = iFocused;
        _fIgnoreSelChange = FALSE;
        psv->Release();
    }
    LeaveCriticalSection(&_pff->_csSearch);

    return S_OK;
}

HRESULT CFindFolderViewCB::OnMergeMenu(DWORD pv, QCMINFO*lP)
{
    DebugMsg(DM_TRACE, TEXT("sh TR - DF_FSNCallBack DVN_MERGEMENU"));

    UINT idCmdFirst = lP->idCmdFirst;

    UINT idBGMain = 0, idBGPopup = 0;
    _pff->_pfilter->GetFolderMergeMenuIndex(&idBGMain, &idBGPopup);
    CDefFolderMenu_MergeMenu(HINST_THISDLL, 0, idBGPopup, lP);

    // Lets remove some menu items that are not useful to us.
    HMENU hmenu = lP->hmenu;
    DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTE, MF_BYCOMMAND);
    DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTELINK, MF_BYCOMMAND);
    // DeleteMenu(hmenu, idCmdFirst + SFVIDM_EDIT_PASTESPECIAL, MF_BYCOMMAND);

    // This is sortof bogus but if after the merge one of the
    // menus has no items in it, remove the menu.

    for (int i = GetMenuItemCount(hmenu) - 1; i >= 0; i--)
    {
        HMENU hmenuSub = GetSubMenu(hmenu, i);

        if (hmenuSub && (GetMenuItemCount(hmenuSub) == 0))
        {
            DeleteMenu(hmenu, i, MF_BYPOSITION);
        }
    }
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGETWORKINGDIR(DWORD pv, UINT wP, LPTSTR lP)
{
    HRESULT hr = E_FAIL;
    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        LPCITEMIDLIST *ppidls;      // pointer to a list of pidls.
        UINT cpidls = 0;            // Count of pidls that were returned.

        psfv->GetSelectedObjects(&ppidls, &cpidls);
        
        if (cpidls > 0)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_pff->GetParentsPIDL(ppidls[0], &pidl)))
            {
                SHGetPathFromIDList(pidl, lP);
                ILFree(pidl);
            }
            LocalFree((void *)ppidls);  // const -> non const
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
        psfv->Release();
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **ppstm)
{
    return _pff->_pfilter->GetColSaveStream(wP, ppstm);
}

HRESULT CFindFolderViewCB::OnGETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST *ppidl)
{
    FIND_ITEM *pesfi;

    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        *ppidl = &pesfi->idl;   // return alias!
        return S_OK;
    }

    *ppidl = NULL;
    return E_FAIL;
}

// in defviewx.c
STDAPI SHGetIconFromPIDL(IShellFolder *psf, IShellIcon *psi, LPCITEMIDLIST pidl, UINT flags, int *piImage);

HRESULT CFindFolderViewCB::OnGetItemIconIndex(DWORD pv, WPARAM iItem, int *piIcon)
{
    FIND_ITEM *pesfi;

    *piIcon = -1;
    
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        if (pesfi->iIcon == -1)
        {
            IShellFolder* psf = (IShellFolder*)_pff;
            SHGetIconFromPIDL(psf, NULL, &pesfi->idl, 0, &pesfi->iIcon);
        }

        *piIcon = pesfi->iIcon;
        return S_OK;
    }

    return E_FAIL;
}


HRESULT CFindFolderViewCB::OnSetItemIconOverlay(DWORD pv, WPARAM iItem, int iOverlayIndex)
{
    HRESULT hr = E_FAIL;
    FIND_ITEM *pesfi;
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        pesfi->dwMask |= ESFITEM_ICONOVERLAYSET;
        pesfi->dwState |= INDEXTOOVERLAYMASK(iOverlayIndex) & LVIS_OVERLAYMASK;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFindFolderViewCB::OnGetItemIconOverlay(DWORD pv, WPARAM iItem, int * piOverlayIndex)
{
    HRESULT hr = E_FAIL;
    *piOverlayIndex = SFV_ICONOVERLAY_DEFAULT;
    FIND_ITEM *pesfi;
    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        if (pesfi->dwMask & ESFITEM_ICONOVERLAYSET)
        {
            *piOverlayIndex = OVERLAYMASKTO1BASEDINDEX(pesfi->dwState & LVIS_OVERLAYMASK);
        }
        else
            *piOverlayIndex = SFV_ICONOVERLAY_UNSET;
        hr = S_OK;
    }

    return hr;
}


HRESULT CFindFolderViewCB::OnSETITEMIDLIST(DWORD pv, WPARAM iItem, LPITEMIDLIST pidl)
{
    FIND_ITEM *pesfi;

    _pff->_iGetIDList = (int) iItem;   // remember the last one we retrieved...    

    if (SUCCEEDED(_pff->GetItem((int) iItem, &pesfi)) && pesfi)
    {
        FIND_ITEM *pesfiNew;
        
        if (SUCCEEDED(_pff->AddPidl((int) iItem, pidl, 0, &pesfiNew) && pesfiNew)) 
        {
            pesfiNew->dwState = pesfi->dwState;
            LocalFree((HLOCAL)pesfi);   // Free the old one...
        }
        return S_OK;
    }

    return E_FAIL;
}

BOOL DF_ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL bRet = (pidl1 == pidl2);

    if (!bRet)
    {
        PCHIDDENDOCFINDDATA phdfd1 = (PCHIDDENDOCFINDDATA) ILFindHiddenID(pidl1, IDLHID_DOCFINDDATA);
        PCHIDDENDOCFINDDATA phdfd2 = (PCHIDDENDOCFINDDATA) ILFindHiddenID(pidl2, IDLHID_DOCFINDDATA);

        if (phdfd1 && phdfd2)
            bRet = (phdfd1->iFolder == phdfd2->iFolder) && ILIsEqual(pidl1, pidl2);
    }
    return bRet;
}

HRESULT CFindFolderViewCB::OnGetIndexForItemIDList(DWORD pv, int * piItem, LPITEMIDLIST pidl)
{
    int cItems;

    // Try to short circuit searching for pidls...
    if (SUCCEEDED(_pff->GetItemCount(&cItems)) && _pff->_iGetIDList < cItems)
    {
        FIND_ITEM *pesfi;
                
        if (SUCCEEDED(_pff->GetItem(_pff->_iGetIDList, &pesfi)) && pesfi)
        {
            if (DF_ILIsEqual(&pesfi->idl, pidl))
            {
                // Yep it was ours so return the index quickly..
                *piItem = _pff->_iGetIDList;
                return S_OK;
            }
        }
    }

    // Otherwise let it search the old fashion way...
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnDeleteItem(DWORD pv, LPCITEMIDLIST pidl)
{
    // We simply need to remove this item from our list.  The
    // underlying listview will decrement the count on their end...
    FIND_ITEM *pesfi;
    int iItem;
    int cItems;
    BOOL bFound;

    if (!pidl)
    {
        _pff->SetAsyncEnum(NULL);
        return S_OK;     // special case telling us all items deleted...
    }

    bFound = FALSE;
    
    if (SUCCEEDED(_pff->GetItem(_pff->_iGetIDList, &pesfi)) 
        && pesfi
        && (DF_ILIsEqual(&pesfi->idl, pidl)))
    {
        iItem = _pff->_iGetIDList;
        bFound = TRUE;
    }
    else
    {
        if (SUCCEEDED(_pff->GetItemCount(&cItems))) 
        {
            for (iItem = 0; iItem < cItems; iItem++)
            {                
                if (SUCCEEDED(_pff->GetItem(iItem, &pesfi)) && pesfi && (DF_ILIsEqual(&pesfi->idl, pidl)))
                {
                    bFound = TRUE;
                    break;
                }
            }
        }
    }

    if (bFound)
    {
        _pff->DeleteItem(iItem);
    }

    return S_OK;
}

HRESULT CFindFolderViewCB::OnODFindItem(DWORD pv, int * piItem, NM_FINDITEM* pnmfi)
{
    // We have to do the subsearch ourself to find the correct item...
    // As the listview has no information saved in it...

    int iItem = pnmfi->iStart;
    int cItem;
    UINT flags = pnmfi->lvfi.flags;

    if (FAILED(_pff->GetItemCount(&cItem))) 
        return E_FAIL;

    if ((flags & LVFI_STRING) == 0)
        return E_FAIL;      // Not sure what type of search this is...

    int cbString = lstrlen(pnmfi->lvfi.psz);

    for (int j = cItem; j-- != 0;)
    {
        if (iItem >= cItem)
        {
            if (flags & LVFI_WRAP)
                iItem = 0;
            else
                break;
        }

        // Now we need to get the Display name for this item...
        FIND_ITEM *pesfi;
        TCHAR szPath[MAX_PATH];
        IShellFolder* psf = (IShellFolder*)_pff;

        if (SUCCEEDED(_pff->GetItem(iItem, &pesfi)) && pesfi && 
            SUCCEEDED(DisplayNameOf(psf, &pesfi->idl, NULL, szPath, ARRAYSIZE(szPath))))
        {
            if (flags & (LVFI_PARTIAL|LVFI_SUBSTRING))
            {
                if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pnmfi->lvfi.psz, cbString, szPath, cbString) == 2)
                {
                    *piItem = iItem;
                    return S_OK;
                }
            }
            else if (lstrcmpi(pnmfi->lvfi.psz, szPath) == 0)
            {
                *piItem = iItem;
                return S_OK;
            }
        }

        ++iItem;
    }
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA *lP)
{
    // Try to remember which item is focused...
    if (lP->uNewState & LVIS_FOCUSED)
        _iFocused = wPh;

    return S_OK;
}

HRESULT CFindFolderViewCB::OnSetEmptyText(DWORD pv, UINT res, LPCTSTR pszText)
{
    if (pszText && 0 == lstrcmp(_szEmptyText, pszText))
        return S_OK;

    StringCchCopy(_szEmptyText, ARRAYSIZE(_szEmptyText), pszText ? pszText : TEXT(""));    // ok to truncate

    HWND hwndLV = ListviewFromViewUnk(_punkSite);
    if (hwndLV)
        SendMessage(hwndLV, LVM_RESETEMPTYTEXT, 0, 0);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetEmptyText(DWORD pv, UINT cchTextMax, LPTSTR pszText)
{
    HRESULT hr = S_OK;

    if (_szEmptyText[0])
    {
        hr = StringCchCopy(pszText, cchTextMax, _szEmptyText);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_FINDVIEWEMPTYINIT, pszText, cchTextMax);
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnReArrange(DWORD pv, LPARAM lparam)
{   
    UINT nCol = (UINT)lparam;

    // See if there is any controller object registered that may want to take over this...
    // if we are in a mixed query and we have already fetched the async items, simply sort
    // the dpa's...
    IFindEnum *pidfenum;
    if (S_OK == _pff->GetAsyncEnum(&pidfenum))
    {
        if (!((pidfenum->FQueryIsAsync() == DF_QUERYISMIXED) && _pff->_fAllAsyncItemsCached))
        {
            if (_pff->_pfcn)
            {
                // if they return S_FALSE it implies that they handled it and they do not
                // want the default processing to happen...
                if (_pff->_pfcn->DoSortOnColumn(nCol, _iColSort == nCol) == S_FALSE)
                {
                    _iColSort = nCol;
                    return S_OK;
                }
            }
            else 
            {
                // If we are running in the ROWSET way, we may want to have the ROWSET do the work...
                // pass one we spawn off a new search with the right column sorted
                if (_iColSort != nCol)
                {
                    _iColSort = nCol;      
                }
    
                // Warning the call above may release our AsyncEnum and generate a new one so
                // Don't rely on it's existence here...
                return S_OK;
            }
        }

        // we must pull in all the results from ci
        if (pidfenum->FQueryIsAsync() && !_pff->_fAllAsyncItemsCached)
            _pff->CacheAllAsyncItems();

#ifdef DEBUG
#define MAX_LISTVIEWITEMS  (100000000 & ~0xFFFF)
#define SANE_ITEMCOUNT(c)  ((int)min(c, MAX_LISTVIEWITEMS))
        if (pidfenum->FQueryIsAsync())
        {
            ASSERT(DPA_GetPtrCount(_pff->_hdpaItems) >= SANE_ITEMCOUNT(_pff->_cAsyncItems));
            for (int i = 0; i < SANE_ITEMCOUNT(_pff->_cAsyncItems); i++)
            {
                FIND_ITEM *pesfi = (FIND_ITEM *)DPA_GetPtr(_pff->_hdpaItems, i);

                ASSERT(pesfi);
                if (!pesfi)
                {
                    ASSERT(SUCCEEDED(_pff->GetItem(i, &pesfi)));
                }
            }
        }
#endif
    }

    // Use the common sort.
    return E_FAIL;
}

HRESULT CFindFolderViewCB::OnWindowCreated(DWORD pv, HWND hwnd)
{
    _ProfferService(TRUE);  // register our service w/ top level container
    return S_OK;
}

HRESULT CFindFolderViewCB::_ProfferService(BOOL bProffer)
{
    HRESULT hr = E_FAIL;

    if (bProffer)
    {
        //  shouldn't be redundantly registering our service
        ASSERT(NULL == _pps);
        ASSERT(-1 == _dwServiceCookie);
            
        IProfferService* pps;
        hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IProfferService, &pps));
        if (SUCCEEDED(hr))
        {
            hr = pps->ProfferService(SID_DocFindFolder, this, &_dwServiceCookie);
            if (SUCCEEDED(hr))
            {
                pps->AddRef();
                _pps = pps;
            }
            pps->Release();
        }
    }
    else
    {
        if (NULL == _pps)
        {
            hr = S_OK;
        }
        else
        {
            hr = _pps->RevokeService(_dwServiceCookie);
            if (SUCCEEDED(hr))
            {
                ATOMICRELEASE(_pps);
                _dwServiceCookie = -1;
            }
        }
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnWindowDestroy(DWORD pv, HWND wP)
{
    _ProfferService(FALSE); // unregister our service w/ top level container

    if (_pff->_pfcn)
        _pff->_pfcn->StopSearch();

    // The search may have a circular set of pointers.  So call the 
    // delete items and folders here to remove these back references...
    _pff->ClearItemList();
    _pff->ClearFolderList();

    IFindControllerNotify *pfcn;
    if (_pff->GetControllerNotifyObject(&pfcn) == S_OK)
    {
        pfcn->ViewDestroyed();
        pfcn->Release();
    }
    return S_OK;
}

HRESULT CFindFolderViewCB::OnIsOwnerData(DWORD pv, DWORD *pdwFlags)
{
    *pdwFlags |= FWF_OWNERDATA; // we want virtual defview support
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetODRangeObject(DWORD pv, WPARAM wWhich, ILVRange **plvr)
{
    HRESULT hr = E_FAIL;
    switch (wWhich)
    {
    case LVSR_SELECTION:
        hr = _pff->_dflvrSel.QueryInterface(IID_PPV_ARG(ILVRange, plvr));
        break;
    case LVSR_CUT:
        hr = _pff->_dflvrCut.QueryInterface(IID_PPV_ARG(ILVRange, plvr));
        break;
    }
    return hr;
}

HRESULT CFindFolderViewCB::OnODCacheHint(DWORD pv, NMLVCACHEHINT* pnmlvc)
{
    // The listview is giving us a hint of the items it is about to do something in a range
    // so make sure we have pidls for each of the items in the range...
    int iTo;
    
    _pff->GetItemCount(&iTo);
    if (iTo >= pnmlvc->iTo)
        iTo = pnmlvc->iTo;
    else
        iTo--;

    for (int i = pnmlvc->iFrom; i <= iTo; i++)
    {
        FIND_ITEM *pesfi;
        if (FAILED(_pff->GetItem(i, &pesfi)))
            break;
    }

    return S_OK;
}

HRESULT CFindFolderViewCB::OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP)
{
    *lP = FVM_DETAILS;  // match the advanced mode of SC (+ Win2K parity)
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_DETAILS | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CFindFolderViewCB::_OnOpenContainingFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFindFolderViewCB* pThis = (CFindFolderViewCB*)(void*)pv;
    return pThis->_pff->OpenContainingFolder(pThis->_punkSite);
}

const WVTASKITEM c_FindTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_SEARCH, IDS_HEADER_FIND_TT);
const WVTASKITEM c_FindTaskList[] =
{
    WVTI_ENTRY_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_OPENCONTAININGFOLDER, IDS_TASK_OPENCONTAININGFOLDER, 0, IDS_TASK_OPENCONTAININGFOLDER_TT, IDI_TASK_OPENCONTAININGFOLDER, NULL, CFindFolderViewCB::_OnOpenContainingFolder),
};

HRESULT CFindFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_FindTaskHeader, &(pData->pSpecialTaskHeader));

    LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_NETWORK) };
    CreateIEnumIDListOnCSIDLs(_pidl, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &pData->penumOtherPlaces);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_FindTaskList, ARRAYSIZE(c_FindTaskList), &pTasks->penumSpecialTasks);

    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme)
{
    ZeroMemory(pTheme, sizeof(*pTheme));

    pTheme->pszThemeID = L"search";
    
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetIPersistHistory(DWORD pv, IPersistHistory **ppph)
{
    // If they call us with ppph == NULL they simply want to know if we support
    // the history so return S_OK;
    if (ppph == NULL)
        return S_OK;

    // get the persist history from us and we hold folder and view objects
    *ppph = NULL;

    CFindPersistHistory *pdfph = new CFindPersistHistory();
    if (!pdfph)
        return E_OUTOFMEMORY;

    HRESULT hr = pdfph->QueryInterface(IID_PPV_ARG(IPersistHistory, ppph));
    pdfph->Release();
    return hr;
}

HRESULT CFindFolderViewCB::OnRefresh(DWORD pv, BOOL fPreRefresh)
{
    EnterCriticalSection(&_pff->_csSearch);

    _pff->_fInRefresh = BOOLIFY(fPreRefresh);
    // If we have old results tell defview the new count now...
    if (!fPreRefresh && _pff->_hdpaItems)
    {
        IShellFolderView *psfv;
        UINT cItems = DPA_GetPtrCount(_pff->_hdpaItems);
        if (cItems && _punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
        {   
            psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
            psfv->Release();
        }
    }
    LeaveCriticalSection(&_pff->_csSearch);
    return S_OK;
}

HRESULT CFindFolderViewCB::OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *phtd)
{
    if (IsOS(OS_ANYSERVER))
    {
        StringCchCopy(phtd->wszHelpFile, ARRAYSIZE(phtd->wszHelpFile), L"find.chm");   // ok to truncate
    }
    else
    {
        StringCchCopy(phtd->wszHelpTopic, ARRAYSIZE(phtd->wszHelpTopic), L"hcp://services/subsite?node=Unmapped/Search"); // ok to truncate
    }
    return S_OK;
}

STDMETHODIMP CFindFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGETWORKINGDIR);
    HANDLE_MSG(0, SFVM_GETCOLSAVESTREAM, OnGETCOLSAVESTREAM);
    HANDLE_MSG(0, SFVM_GETITEMIDLIST, OnGETITEMIDLIST);
    HANDLE_MSG(0, SFVM_SETITEMIDLIST, OnSETITEMIDLIST);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_INDEXOFITEMIDLIST, OnGetIndexForItemIDList);
    HANDLE_MSG(0, SFVM_DELETEITEM, OnDeleteItem);
    HANDLE_MSG(0, SFVM_ODFINDITEM, OnODFindItem);
    HANDLE_MSG(0, SFVM_ARRANGE, OnReArrange);
    HANDLE_MSG(0, SFVM_GETEMPTYTEXT, OnGetEmptyText);
    HANDLE_MSG(0, SFVM_SETEMPTYTEXT, OnSetEmptyText);
    HANDLE_MSG(0, SFVM_GETITEMICONINDEX, OnGetItemIconIndex);
    HANDLE_MSG(0, SFVM_SETICONOVERLAY, OnSetItemIconOverlay);
    HANDLE_MSG(0, SFVM_GETICONOVERLAY, OnGetItemIconOverlay);
    HANDLE_MSG(0, SFVM_FOLDERSETTINGSFLAGS, OnIsOwnerData);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWindowDestroy);
    HANDLE_MSG(0, SFVM_GETODRANGEOBJECT, OnGetODRangeObject);
    HANDLE_MSG(0, SFVM_ODCACHEHINT, OnODCacheHint);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDEFVIEWMODE);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTHEME, OnGetWebViewTheme);
    HANDLE_MSG(0, SFVM_GETIPERSISTHISTORY, OnGetIPersistHistory);
    HANDLE_MSG(0, SFVM_REFRESH, OnRefresh);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_SORTLISTDATA, OnSortListData);

    default:
        return E_FAIL;
    }

    return S_OK;
}

CFindFolderViewCB::CFindFolderViewCB(CFindFolder* pff) : 
    CBaseShellFolderViewCB(pff->_pidl, 0), _pff(pff), _fIgnoreSelChange(FALSE),
    _iColSort((UINT)-1), _iFocused((UINT)-1), _cSelected(0), _pps(NULL), _dwServiceCookie(-1)
{
    _pff->AddRef();
}

CFindFolderViewCB::~CFindFolderViewCB()
{
    _pff->Release();
    ASSERT(NULL == _pps);
    ASSERT(_dwServiceCookie == -1);
}

// give the find command code access to defview via this QS that we proffered

HRESULT CFindFolderViewCB::QueryService(REFGUID guidService, REFIID riid, void **ppv) 
{ 
    HRESULT hr = E_NOTIMPL;
    *ppv = NULL;
    if (guidService == SID_DocFindFolder)
    {
        hr = IUnknown_QueryService(_punkSite, SID_DefView, riid, ppv);
    }
    return hr;
}

CFindPersistHistory::CFindPersistHistory()
{
}

STDAPI CFindPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CFindPersistHistory *pdfph = new CFindPersistHistory();
    if (pdfph)
    {
        hr = pdfph->QueryInterface(riid, ppv);
        pdfph->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;    
}


// Functions to support persisting the document into the history stream...
STDMETHODIMP CFindPersistHistory::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DocFindPersistHistory;
    return S_OK;
}

IFindFolder *CFindPersistHistory::_GetDocFindFolder()
{
    IFindFolder *pdff = NULL;

    // the _punksite is to the defview so we can simply QI for frame...
    IFolderView *pfv;
    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv)))) 
    {
        pfv->GetFolder(IID_PPV_ARG(IFindFolder, &pdff));
        pfv->Release();
    }

    return pdff;
}

STDMETHODIMP CFindPersistHistory::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    int cItems = 0;
    IFindFolder *pdff = _GetDocFindFolder();
    if (pdff)
    {
        pdff->RestoreFolderList(pstm);
        pdff->RestoreItemList(pstm, &cItems);
        pdff->Release();
    }

    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        psfv->SetObjectCount(cItems, SFVSOC_NOSCROLL);
        psfv->Release();
    }

    // call our base class to allow it to restore it's stuff as well.
    return CDefViewPersistHistory::LoadHistory(pstm, pbc);
}


STDMETHODIMP CFindPersistHistory::SaveHistory(IStream *pstm)
{
    IFindFolder *pdff = _GetDocFindFolder();
    if (pdff)
    {
        pdff->SaveFolderList(pstm);       
        pdff->SaveItemList(pstm);       
        pdff->Release();
    }
    // Let base class save out as well
    return CDefViewPersistHistory::SaveHistory(pstm);
}

// use to manage the selection states for an owner data listview...

STDMETHODIMP_(ULONG) CFindLVRange::AddRef()
{
    return _pff->AddRef();
}
STDMETHODIMP_(ULONG) CFindLVRange::Release()
{ 
    return _pff->Release();
}

STDMETHODIMP CFindLVRange::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFindLVRange, ILVRange),          // IID_ILVRange
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// ILVRange methods
STDMETHODIMP CFindLVRange::IncludeRange(LONG iBegin, LONG iEnd)
{
    // Including the range must load the elements as we need the object ptr...
    FIND_ITEM *pesfi;
    int  iTotal;

    _pff->GetItemCount(&iTotal);
    if (iEnd > iTotal)
        iEnd = iTotal-1;
        
    for (long i = iBegin; i <= iEnd;i++)
    {
        if (SUCCEEDED(_pff->GetItem(i, &pesfi)) && pesfi)
        {
            if ((pesfi->dwState & _dwMask) == 0)
            {
                _cIncluded++;
                pesfi->dwState |= _dwMask;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CFindLVRange::ExcludeRange(LONG iBegin, LONG iEnd)    
{
    // Excluding the range is OK to not load the elements as this would be to deslect all...

    EnterCriticalSection(&_pff->_csSearch);
    if (iEnd >= DPA_GetPtrCount(_pff->_hdpaItems))
        iEnd = DPA_GetPtrCount(_pff->_hdpaItems) - 1;

    for (long i = iBegin; i <= iEnd; i++)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_FastGetPtr(_pff->_hdpaItems, i);
        if (pesfi)
        {
            if (pesfi->dwState & _dwMask)
            {
                _cIncluded--;
                pesfi->dwState &= ~_dwMask;
            }
        }
    }
    LeaveCriticalSection(&_pff->_csSearch);

    return S_OK;
}

STDMETHODIMP CFindLVRange::InvertRange(LONG iBegin, LONG iEnd)
{
    // Including the range must load the elements as we need the object ptr...
    int iTotal;

    _pff->GetItemCount(&iTotal);
    if (iEnd > iTotal)
        iEnd = iTotal-1;

    for (long i = iBegin; i <= iEnd;i++)
    {
        FIND_ITEM *pesfi;
        if (SUCCEEDED(_pff->GetItem(i, &pesfi)) && pesfi)
        {
            if ((pesfi->dwState & _dwMask) == 0)
            {
                _cIncluded++;
                pesfi->dwState |= _dwMask;
            }
            else
            {
                _cIncluded--;
                pesfi->dwState &= ~_dwMask;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CFindLVRange::InsertItem(LONG iItem)
{
    // We already maintain the list anyway...
    return S_OK;
}

STDMETHODIMP CFindLVRange::RemoveItem(LONG iItem)
{
    // We maintain the list so don't do anything...
    return S_OK;
}

STDMETHODIMP CFindLVRange::Clear()
{
    // If there are things selected, need to unselect them now...
    if (_cIncluded)
        ExcludeRange(0, LONG_MAX);

    _cIncluded = 0;
    _pff->ClearSaveStateList();
    return S_OK;
}

STDMETHODIMP CFindLVRange::IsSelected(LONG iItem)
{
    // Don't force the items to be generated if they were not before...
    HRESULT hr = S_FALSE;

    EnterCriticalSection(&_pff->_csSearch);
    FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
    if (pesfi)
        hr = pesfi->dwState & _dwMask ? S_OK : S_FALSE;
    LeaveCriticalSection(&_pff->_csSearch);

    // Assume not selected if we don't have the item yet...
    return hr;
}

STDMETHODIMP CFindLVRange::IsEmpty()
{
    return _cIncluded ? S_FALSE : S_OK;
}

STDMETHODIMP CFindLVRange::NextSelected(LONG iItem, LONG *piItem)
{
    EnterCriticalSection(&_pff->_csSearch);
    LONG cItems = DPA_GetPtrCount(_pff->_hdpaItems);

    while (iItem < cItems)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
        if (pesfi && (pesfi->dwState & _dwMask))
        {
            *piItem = iItem;
            LeaveCriticalSection(&_pff->_csSearch);
            return S_OK;
        }
        iItem++;
    }
    LeaveCriticalSection(&_pff->_csSearch);
    *piItem = -1;
    return S_FALSE;
}

STDMETHODIMP CFindLVRange::NextUnSelected(LONG iItem, LONG *piItem)
{
    EnterCriticalSection(&_pff->_csSearch);
    LONG cItems = DPA_GetPtrCount(_pff->_hdpaItems);

    while (iItem < cItems)
    {
        FIND_ITEM *pesfi = (FIND_ITEM*)DPA_GetPtr(_pff->_hdpaItems, iItem);
        if (!pesfi || ((pesfi->dwState & _dwMask) == 0))
        {
            *piItem = iItem;
            LeaveCriticalSection(&_pff->_csSearch);
            return S_OK;
        }
        iItem++;
    }
    LeaveCriticalSection(&_pff->_csSearch);
    *piItem = -1;
    return S_FALSE;
}

STDMETHODIMP CFindLVRange::CountIncluded(LONG *pcIncluded)
{
    *pcIncluded = _cIncluded;

    // Sortof Gross, but if looking at selection then also include the list of items
    // that are selected in our save list...
    if (_dwMask & LVIS_SELECTED)
        *pcIncluded += _pff->_cSaveStateSelected;
    return S_OK;
}


// Define OleDBEnum translation structure...
typedef struct _dfodbet         // DFET for short
{
    struct _dfodbet *pdfetNext;
    LPWSTR  pwszFrom;
    int     cbFrom;
    LPWSTR  pwszTo;
} DFODBET;


class CContentIndexEnum : public IFindEnum, public IShellService
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt);
    STDMETHODIMP Reset();
    STDMETHODIMP StopSearch();
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCOl, BOOL fAscending);

    // IShellService
    STDMETHODIMP SetOwner(IUnknown* punkOwner);
    
    CContentIndexEnum(IFindFilter *pfilter, IFindFolder *pff, DWORD grfFlags, 
                      int iColSort,  LPTSTR pszProgressText, IRowsetWatchNotify *prwn);

    HRESULT DoQuery(LPWSTR *apwszPaths, UINT *pcPaths);

private:
    ~CContentIndexEnum();

    HRESULT _BuildAndSetCommandTree(int iCol, BOOL fReverse);
    HRESULT _SetCmdProp(ICommand *pCommand);
    HRESULT _MapColumns(IUnknown *punk, DBORDINAL cCols, DBBINDING *pBindings, const DBID * pDbCols, HACCESSOR &hAccessor);
    void _ReleaseAccessor();
    HRESULT _CacheRowSet(UINT iItem);
    HRESULT _TranslateFolder(LPCWSTR pszParent, LPWSTR pszResult, UINT cchSize, BOOL *pfTranslated);
    void _ClearFolderState();

    LONG _cRef;
    IFindFilter *_pfilter;
    IRowsetWatchNotify *_prwn;
    IFindFolder *_pff;
    int _iColSort; 
    DWORD _grfFlags;
    DWORD _grfWarnings;
    LPTSTR _pszProgressText;

    TCHAR _szCurrentDir[MAX_PATH];
    IShellFolder *_psfCurrentDir;
    LPITEMIDLIST _pidlFolder;
    int _iFolder;

    HRESULT _hrCurrent;
    ICommand *_pCommand;
    IRowsetLocate *_pRowset;
    IRowsetAsynch *_pRowsetAsync;
    HACCESSOR   _hAccessor;
    HACCESSOR   _hAccessorWorkID;
    HROW        _ahrow[100];            // Cache 100 hrows out for now
    UINT        _ihrowFirst;            // The index of which row is cached out first
    DBCOUNTITEM _cRows;                 // number of hrows in _ahrow
    DFODBET     *_pdfetFirst;           // Name translation list.
};

STDAPI CreateOleDBEnum(IFindFilter *pfilter, IShellFolder *psf,
    LPWSTR *apwszPaths, UINT *pcPaths, DWORD grfFlags, int iColSort,
    LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppdfenum)
{
    *ppdfenum = NULL;
    HRESULT hr = E_OUTOFMEMORY;

    IFindFolder *pff;
    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &pff));

    CContentIndexEnum* pdfenum = new CContentIndexEnum(pfilter, pff, grfFlags, iColSort, pszProgressText, prwn);

    if (pdfenum)
    {
        hr = pdfenum->DoQuery(apwszPaths, pcPaths);
        if (hr == S_OK)       // We only continue to use this if query returne S_OK...
            *ppdfenum = (IFindEnum*)pdfenum;
        else
        {
            pdfenum->Release();     // release the memory we allocated
        }
    }

    if (pff)
        pff->Release();
    
    return hr;
}

const DBID c_aDbCols[] =
{
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_NAME}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_PATH}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_ATTRIBUTES}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_SIZE}},
    {{PSGUID_STORAGE}, DBKIND_GUID_PROPID, {(LPOLESTR)(ULONG_PTR)(ULONG)PID_STG_WRITETIME}},
    {{PSGUID_QUERY_D}, DBKIND_GUID_PROPID, {(LPOLESTR)                  PROPID_QUERY_RANK}},
};

const DBID c_aDbWorkIDCols[] =
{
    {{PSGUID_QUERY_D}, DBKIND_GUID_PROPID, {(LPOLESTR)PROPID_QUERY_WORKID}}
};

const LPCWSTR c_awszColSortNames[] = {
    L"FileName[a],Path[a]", 
    L"Path[a],FileName[a]", 
    L"Size[a]", 
    NULL, 
    L"Write[a]", 
    L"Rank[d]"
};

const ULONG c_cDbCols = ARRAYSIZE(c_aDbCols);
const DBID c_dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
const GUID c_guidQueryExt = DBPROPSET_QUERYEXT;
const GUID c_guidRowsetProps = {0xc8b522be,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}; 

CContentIndexEnum::CContentIndexEnum(IFindFilter *pfilter, IFindFolder *pff,
    DWORD grfFlags, int iColSort,  LPTSTR pszProgressText, IRowsetWatchNotify *prwn) :
    _cRef(1), _ihrowFirst((UINT)-1), _pfilter(pfilter),
    _pff(pff), _prwn(prwn), _grfFlags(grfFlags),
    _grfWarnings(DFW_DEFAULT), _iColSort(iColSort), _pszProgressText(pszProgressText)
{
    _szCurrentDir[0] = 0;

    ASSERT(_pRowset == 0);
    ASSERT(_pRowsetAsync == 0);
    ASSERT(_pCommand == 0);
    ASSERT(_hAccessor == 0);
    ASSERT(_hAccessorWorkID ==0);
    ASSERT(_cRows == 0);

    if (_pfilter)
    {
        _pfilter->AddRef();
        _pfilter->GetWarningFlags(&_grfWarnings);
    }
        
    if (_pff)              
        _pff->AddRef();

    if (_prwn)
        _prwn->AddRef();
}

void CContentIndexEnum::_ClearFolderState()
{
    ATOMICRELEASE(_psfCurrentDir);
    ILFree(_pidlFolder);
    _pidlFolder = NULL;
    _iFolder = -1;
    _szCurrentDir[0] = 0;
}

CContentIndexEnum::~CContentIndexEnum()
{
    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_pff);
    ATOMICRELEASE(_prwn);

    _ClearFolderState();
        
    if (_pRowset)
    {
        ATOMICRELEASE(_pRowsetAsync);

        // Release any cached rows.
       _CacheRowSet((UINT)-1);
          
        if (_hAccessor || _hAccessorWorkID)
            _ReleaseAccessor();

        _pRowset->Release();
    }

    ATOMICRELEASE(_pCommand);

    // Release any name translations we may have allocated.
    DFODBET *pdfet = _pdfetFirst;
    while (pdfet)
    {
        DFODBET *pdfetT = pdfet;
        pdfet = pdfet->pdfetNext;      // First setup to look at the next item before we free stuff...
        LocalFree((HLOCAL)pdfetT->pwszFrom);
        LocalFree((HLOCAL)pdfetT->pwszTo);
        LocalFree((HLOCAL)pdfetT);
    }
}

HRESULT CContentIndexEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CContentIndexEnum, IUnknown, IFindEnum), // IID_IUNKNOWN
        QITABENT(CContentIndexEnum, IShellService),          // IID_IShellService
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CContentIndexEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CContentIndexEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CContentIndexEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState)
{
    return E_PENDING;       // as good a return as any to say that we are async...
}

HRESULT CContentIndexEnum::Skip(int celt)
{
    return E_NOTIMPL;
}

HRESULT CContentIndexEnum::Reset()
{
    // overload Reset to mean dump the rowset cache!!!
    _CacheRowSet(-1);    
    // still return failiure
    return E_NOTIMPL;
}

HRESULT CContentIndexEnum::StopSearch()
{
    // Lets see if we can find one that works...
    HRESULT hr = _pCommand->Cancel();
    if (FAILED(hr))
        hr = _pRowsetAsync->Stop();
    if (FAILED(hr))
    {
        IDBAsynchStatus *pdbas;
        if (SUCCEEDED(_pRowset->QueryInterface(IID_PPV_ARG(IDBAsynchStatus, &pdbas))))
        {
            hr = pdbas->Abort(DB_NULL_HCHAPTER, DBASYNCHOP_OPEN);
            pdbas->Release();
        }
    }
    return hr; 
}

BOOL CContentIndexEnum::FQueryIsAsync()
{
    return TRUE;
}

HRESULT CContentIndexEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    if (!_pRowsetAsync)
        return E_FAIL;

    BOOL fMore;
    DBCOUNTITEM dwDen, dwNum;
    HRESULT hr = _pRowsetAsync->RatioFinished(&dwDen, &dwNum, pdwTotalAsync, &fMore);
    if (SUCCEEDED(hr))
    {
        *pfQueryDone = dwDen == dwNum;
        *pnPercentComplete = dwDen ? (int)((dwNum * 100) / dwDen) : 100;
    }
    else
        *pfQueryDone = TRUE;    // in case that is all they are looking at...
    return hr;
}

// modify pszPath until you can parse it, return result in *ppidl

HRESULT _StripToParseableName(LPTSTR pszPath, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    HRESULT hr = E_FAIL;

    PathRemoveBackslash(pszPath);
    while (PathRemoveFileSpec(pszPath) && FAILED(hr))
    {
        hr = SHParseDisplayName(pszPath, NULL, ppidl, 0, NULL);
    }
    return hr;
}

// we could not get pidl for this item for some reason.  we have to put 
// it in the list of bad items so that we can tell ci not to give it to
// us the next time we do search
void _ExcludeFromFutureSearch(LPCTSTR pszParent)
{
    HKEY hkey;
    HRESULT hr;

    TCHAR szParent[MAX_PATH];
    hr = StringCchCopy(szParent, ARRAYSIZE(szParent), pszParent);
    if (FAILED(hr))
    {
        return;
    }

    if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, CI_SPECIAL_FOLDERS, 0, L"", 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkey, NULL))
    {
        LPITEMIDLIST pidlT;
        if (SUCCEEDED(_StripToParseableName(szParent, &pidlT)))
        {
            ILFree(pidlT);
        
            DWORD dwInsert = 0; // init to zero in case query info bellow fails
            int iEnd;
            TCHAR sz[MAX_PATH], szName[12];
            RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, &dwInsert, NULL, NULL, NULL, NULL);
            // start from the end as there is a high chance we added this at the end
            for (int i = dwInsert - 1; i >= 0; i--)
            {                        
                StringCchPrintf(szName, ARRAYSIZE(szName), L"%d", i);  // ok to truncate
                if (ERROR_SUCCESS == SHRegGetString(hkey, NULL, szName, sz, ARRAYSIZE(sz)))
                {
                    LPTSTR pszTemp = StrStrI(sz + 1, szParent); // +1 to pass " that's at the beginning of the string
                    if (pszTemp && pszTemp == sz + 1)
                    {
                        dwInsert = i; // overwrite this value
                        break;
                    }
                    else
                    {
                        iEnd = lstrlen(sz);
                        if (EVAL(iEnd > 1))
                        {
                            int iBackslash = iEnd - 3;
                            ASSERT(sz[iBackslash] == L'\\');
                            sz[iBackslash] = L'\0';
                            pszTemp = StrStrI(szParent, sz + 1);
                            sz[iBackslash] = L'\\';
                            if (pszTemp && pszTemp == szParent)
                            {
                                dwInsert = -1;
                                break;
                            }
                        }
                    }
                }
            }

            if (dwInsert != -1)
            {
                hr = StringCchPrintf(szName, ARRAYSIZE(szName), L"%d", dwInsert);
                if (SUCCEEDED(hr))
                {
                    if (PathAppend(szParent, TEXT("*")))
                    {
                        PathQuoteSpaces(szParent);
                        RegSetValueEx(hkey, szName, 0, REG_SZ, (BYTE *)szParent, (lstrlen(szParent) + 1) * sizeof(szParent[0]));
                    }
                }
            }
        }
        RegCloseKey(hkey);
    }
}

// If it is a UNC it might be one we need to translate, to handle the case that 
// content index does not support redirected drives.

HRESULT CContentIndexEnum::_TranslateFolder(LPCTSTR pszParent, LPTSTR pszResult, UINT cchSize, BOOL *pfTranslated)
{
    BOOL fTranslated = FALSE;
    HRESULT hr = S_OK;

    if (PathIsUNC(pszParent))
    {
        for (DFODBET *pdfet = _pdfetFirst; pdfet; pdfet = pdfet->pdfetNext)
        {
            if ((StrCmpNIW(pszParent, pdfet->pwszFrom, pdfet->cbFrom) == 0)
                    && (pszParent[pdfet->cbFrom] == L'\\'))
            {
                // Ok we have a translation to use.
                hr = StringCchCopy(pszResult, cchSize, pdfet->pwszTo);
                if (SUCCEEDED(hr))
                {
                    // need + 1 here or we'll get something like "w:\\winnt" bogus path, that is.
                    hr = StringCchCat(pszResult, cchSize, &pszParent[pdfet->cbFrom + 1]);
                    if (SUCCEEDED(hr))
                    {
                        fTranslated = TRUE;
                    }
                }
            }
        }
    }

    if (!fTranslated)
    {
        // default to the same
        hr = StringCchCopy(pszResult, cchSize, pszParent);
    }

    *pfTranslated = fTranslated;

    return hr;
}

HRESULT CContentIndexEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr = _CacheRowSet(iItem);
    if (S_OK != hr)
    {
        return E_FAIL;    // we could not get the item someone asked for, so error...
    }

    PROPVARIANT* data[c_cDbCols];
    
    hr = _pRowset->GetData(_ahrow[iItem - _ihrowFirst], _hAccessor, &data);
    if (hr != S_OK)
    {
        return hr;
    }

    // data[0].pwszVal is the file name
    // data[1].pwszVal is the full path (including file name)
    // data[2].ulVal is the attribute
    // data[3].ulVal is the size in byte
    // data[4].filetime is the last write time in UTC
    // data[5].ulVal is the rank of the item...

    WIN32_FIND_DATA fd = {0};

    fd.dwFileAttributes = data[2]->ulVal;
    fd.nFileSizeLow = data[3]->ulVal;
    fd.ftLastWriteTime = data[4]->filetime;

    ASSERT(ShowSuperHidden() || !IsSuperHidden(fd.dwFileAttributes));   // query should exclude these

    hr = StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), data[0]->pwszVal);
    if (FAILED(hr))
    {
        return hr;
    }

    WCHAR szParent[MAX_PATH];

    hr = StringCchCopy(szParent, ARRAYSIZE(szParent), data[1]->pwszVal);    // full path
    if (FAILED(hr))
    {
        return hr;
    }

    PathRemoveFileSpec(szParent);           // strip to parent folder path

    WCHAR szTranslatedParent[MAX_PATH];
    BOOL fTranslated;

    hr = _TranslateFolder(szParent, szTranslatedParent, ARRAYSIZE(szTranslatedParent), &fTranslated);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Working with a new folder?
    //
    if (lstrcmp(szParent, _szCurrentDir) != 0)
    {
        _ClearFolderState();    // our previous "current folder" state is now invalid

        hr = SHParseDisplayName(szTranslatedParent, NULL, &_pidlFolder, 0, NULL);
        if (SUCCEEDED(hr))
        {
            hr = _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
            if (SUCCEEDED(hr))
            {
                hr = _pff->GetFolder(_iFolder, IID_PPV_ARG(IShellFolder, &_psfCurrentDir));
                if (SUCCEEDED(hr))
                {
                    // on succesful init of this folder save the cache key
                    hr = StringCchCopy(_szCurrentDir, ARRAYSIZE(_szCurrentDir), szParent);
                }
            }
        }
        else if (hr != E_OUTOFMEMORY && !fTranslated)
        {
            _ExcludeFromFutureSearch(szParent);
        }
        _hrCurrent = hr;    // save error state for next time around

        if (FAILED(hr))
            _ClearFolderState();
    }
    else
    {
        hr = _hrCurrent;
    }

    //
    // Now that we have changed to the current folder, lets get the item out
    // of the folder.
    //
    if (SUCCEEDED(hr))
    {
        // success implies the state of these variables
        ASSERT((NULL != _psfCurrentDir) && (NULL != _pidlFolder) && (_iFolder > 0));

        DWORD dwItemID;
        GetItemID(iItem, &dwItemID);

        LPITEMIDLIST pidl;
        hr = SHSimpleIDListFromFindData2(_psfCurrentDir, &fd, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = _pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_EXTRADATA, iItem, dwItemID, data[5]->ulVal, ppidl);
            ILFree(pidl);
        }
    }
    else
    {
        // failure implies these should be clear
        ASSERT((NULL == _psfCurrentDir) && (NULL == _pidlFolder));

        LPITEMIDLIST pidlFull;
        if (SUCCEEDED(_StripToParseableName(szTranslatedParent, &pidlFull)))
        {
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(SplitIDList(pidlFull, &_pidlFolder, &pidlChild)))
            {
                hr = _pff->AddFolder(_pidlFolder, TRUE, &_iFolder);
                if (SUCCEEDED(hr))
                {
                    hr = _pff->GetFolder(_iFolder, IID_PPV_ARG(IShellFolder, &_psfCurrentDir));
                    if (SUCCEEDED(hr))
                    {
                        hr = _pff->AddDataToIDList(pidlChild, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl);
                        if (SUCCEEDED(hr))
                        {
                            // on succesful init of this folder save the cache key
                            hr = StringCchCopy(_szCurrentDir, ARRAYSIZE(_szCurrentDir), szTranslatedParent);
                            if (SUCCEEDED(hr))
                            {
                                PathRemoveFileSpec(_szCurrentDir);
                            }
                        }
                    }
                }
            }
            ILFree(pidlFull);

            if (FAILED(hr))
                _ClearFolderState();
        }
    }


    return hr;
}

HRESULT CContentIndexEnum::GetItemID(UINT iItem, DWORD *puItemID)
{
    *puItemID = (UINT)-1;
    HRESULT hr = _CacheRowSet(iItem);
    if (S_OK == hr)
    {
        PROPVARIANT* data[1];
        hr = _pRowset->GetData(_ahrow[iItem - _ihrowFirst], _hAccessorWorkID, &data);
        if (S_OK == hr)
        {
            // Only one data column so this is easy...
            // The ULVal is the thing we are after...
            *puItemID = data[0]->ulVal;
        }
    }
    return hr;
}

HRESULT CContentIndexEnum::SortOnColumn(UINT iCol, BOOL fAscending)
{
    // Ok We need to generate the Sort String... 
    return _BuildAndSetCommandTree(iCol, fAscending);             
}

HRESULT CContentIndexEnum::SetOwner(IUnknown* punkOwner)
{
    // Used to set the docfind folder and from that the filter.
    ATOMICRELEASE(_pfilter);
    ATOMICRELEASE(_pff);

    if (punkOwner)
    {
        punkOwner->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
        if (_pff)
            _pff->GetFindFilter(&_pfilter);
    }
    return S_OK;
}

HRESULT CContentIndexEnum::_MapColumns(IUnknown *punk, DBORDINAL cCols,
                                  DBBINDING *pBindings, const DBID *pDbCols,
                                  HACCESSOR &hAccessor)
{
    DBORDINAL aMappedColumnIDs[c_cDbCols];

    IColumnsInfo *pColumnsInfo;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IColumnsInfo, &pColumnsInfo));
    if (SUCCEEDED(hr))
    {
        hr = pColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);
        if (SUCCEEDED(hr))
        {
            for (ULONG i = 0; i < cCols; i++)
                pBindings[i].iOrdinal = aMappedColumnIDs[i];

            IAccessor *pIAccessor;
            hr = punk->QueryInterface(IID_PPV_ARG(IAccessor, &pIAccessor));
            if (SUCCEEDED(hr))
            {
                hAccessor = 0;
                hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA, cCols, pBindings, 0, &hAccessor, 0);
                pIAccessor->Release();
            }
        }
        pColumnsInfo->Release();
    }

    return hr;
}

void CContentIndexEnum::_ReleaseAccessor()
{
    IAccessor *pIAccessor;
    HRESULT hr = _pRowset->QueryInterface(IID_PPV_ARG(IAccessor, &pIAccessor));
    if (SUCCEEDED(hr))
    {
        if (_hAccessor)
            pIAccessor->ReleaseAccessor(_hAccessor, 0);
        if (_hAccessorWorkID)
            pIAccessor->ReleaseAccessor(_hAccessorWorkID, 0);

        pIAccessor->Release();
    }
}

HRESULT CContentIndexEnum::_CacheRowSet(UINT iItem)
{
    HRESULT hr = S_OK;

    if (!_pRowset)
        return E_FAIL;
    
    if (!_cRows || !InRange(iItem, _ihrowFirst, _ihrowFirst+(UINT)_cRows-1) || (iItem == (UINT)-1))
    {
        // Release the last cached element we had.
        if (_cRows != 0)
            _pRowset->ReleaseRows(ARRAYSIZE(_ahrow), _ahrow, 0, 0, 0);

        // See if we are simply releasing our cached data...
        _cRows = 0;
        _ihrowFirst = (UINT)-1;
        if (iItem == (UINT)-1)
            return S_OK;

        // Ok try to read in the next on...
        BYTE bBookMark = (BYTE) DBBMK_FIRST;
        HROW *rghRows = (HROW *)_ahrow;

        // change this to fetch 100 or so rows at the time -- huge perf improvment
        hr = _pRowset->GetRowsAt(0, 0, sizeof(bBookMark), &bBookMark, iItem, ARRAYSIZE(_ahrow), &_cRows, &rghRows);
        if (FAILED(hr))
            return hr;
            
        _ihrowFirst = iItem;

        if ((DB_S_ENDOFROWSET == hr) || (_cRows == 0))
        {
            if (_cRows == 0)
                _ihrowFirst = -1;
            else
                hr = S_OK;  // we got some items and caller expects S_OK so change DB_S_ENDOFROWSET to noerror
        }
    }

    return hr;
}

HRESULT CContentIndexEnum::_SetCmdProp(ICommand *pCommand)
{
#define MAX_PROPS 8

    DBPROPSET aPropSet[MAX_PROPS];
    DBPROP aProp[MAX_PROPS];
    ULONG cProps = 0;
    HRESULT hr;

    // asynchronous query

    aProp[cProps].dwPropertyID = DBPROP_IRowsetAsynch;
    aProp[cProps].dwOptions = 0;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_BOOL;
    aProp[cProps].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidRowsetProps;

    cProps++;

    // don't timeout queries

    aProp[cProps].dwPropertyID = DBPROP_COMMANDTIMEOUT;
    aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_I4;
    aProp[cProps].vValue.lVal = 0;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidRowsetProps;

    cProps++;

    // We can handle PROPVARIANTs

    aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
    aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
    aProp[cProps].dwStatus = 0;
    aProp[cProps].colid = c_dbcolNull;
    aProp[cProps].vValue.vt = VT_BOOL;
    aProp[cProps].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProps].rgProperties = &aProp[cProps];
    aPropSet[cProps].cProperties = 1;
    aPropSet[cProps].guidPropertySet = c_guidQueryExt;

    cProps++;

    ICommandProperties * pCmdProp = 0;
    hr = pCommand->QueryInterface(IID_PPV_ARG(ICommandProperties, &pCmdProp));
    if (SUCCEEDED(hr))
    {
        hr = pCmdProp->SetProperties(cProps, aPropSet);
        pCmdProp->Release();
    }

    return hr;
}

// create the query command string

HRESULT CContentIndexEnum::_BuildAndSetCommandTree(int iCol, BOOL fReverse)
{
    LPWSTR pwszRestrictions = NULL;
    DWORD  dwGQRFlags;
    HRESULT hr = _pfilter->GenerateQueryRestrictions(&pwszRestrictions, &dwGQRFlags);
    if (SUCCEEDED(hr))
    {
        ULONG ulDialect;
        hr = _pfilter->GetQueryLanguageDialect(&ulDialect);
        if (SUCCEEDED(hr))
        {
            // NOTE: hard coded to our current list of columns
            WCHAR wszSort[80];      // use this to sort by different columns...
            wszSort[0] = 0;

            if ((iCol >= 0) && (iCol < ARRAYSIZE(c_awszColSortNames)) && c_awszColSortNames[iCol])
            {
                // Sort order is hardcoded for ascending.
                hr = StringCchCopy(wszSort, ARRAYSIZE(wszSort), c_awszColSortNames[iCol]);
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCat(wszSort, ARRAYSIZE(wszSort), L",Path[a],FileName[a]");
                }
                if (FAILED(hr))
                {
                    // don't sort on anything which doesn't let us
                    // do proper sort string construction
                    wszSort[0] = 0;
                }
            }
        
            if (SUCCEEDED(hr))
            {
                DBCOMMANDTREE *pTree = NULL;
                hr = CITextToFullTreeEx(pwszRestrictions, ulDialect,
                    L"FileName,Path,Attrib,Size,Write,Rank,WorkID",
                    wszSort[0] ? wszSort : NULL, 0, &pTree, 0, 0, LOCALE_USER_DEFAULT);
                if (FAILED(hr))
                {
                    // Map this to one that I know about
                    // Note: We will only do this if we require CI else we will try to fallback to old search...
                    // Note we are running into problems where CI says we are contained in a Catalog even if
                    // CI process is not running... So try to avoid this if possible
                    if (dwGQRFlags & GQR_REQUIRES_CI)
                        hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_CONSTRAINT);
                }

                if (SUCCEEDED(hr))
                {
                    ICommandTree *pCmdTree;
                    hr = _pCommand->QueryInterface(IID_PPV_ARG(ICommandTree, &pCmdTree));
                    if (SUCCEEDED(hr))
                    {
                        hr = pCmdTree->SetCommandTree(&pTree, DBCOMMANDREUSE_NONE, FALSE);
                        pCmdTree->Release();
                    }
                }
            }
        }
    }
    LocalFree((HLOCAL)pwszRestrictions);
    return hr;
}

#define cbP (sizeof (PROPVARIANT *))

// [in, out] apwszPaths this is modified
// [in, out] pcPaths

HRESULT CContentIndexEnum::DoQuery(LPWSTR *apwszPaths, UINT *pcPaths)
{
    UINT nPaths = *pcPaths;
    WCHAR** aScopes = NULL;
    WCHAR** aScopesOrig = NULL;
    ULONG* aDepths = NULL;
    WCHAR** aCatalogs = NULL;
    WCHAR** aMachines = NULL;
    WCHAR wszPath[MAX_PATH];
    LPWSTR pwszPath = wszPath;
    LPWSTR pszMachineAlloc = NULL, pszCatalogAlloc = NULL;
    LPWSTR pwszMachine, pwszCatalog;
    UINT i, iPath = 0;
    DWORD dwQueryRestrictions;

    // Initiailize all of our query values back to unused 
    _hAccessor = NULL;
    _hAccessorWorkID = NULL;
    _pRowset = NULL;
    _pRowsetAsync = NULL;
    _pCommand = NULL;

    // Get array of search paths...
#define MAX_MACHINE_NAME_LEN    32

    BOOL fIsCIRunning, fCiIndexed, fCiPermission;
    GetCIStatus(&fIsCIRunning, &fCiIndexed, &fCiPermission);

    // First pass see if we have anything that make use at all of CI if not lets simply bail and let
    // old code walk the list...
    HRESULT hr = _pfilter->GenerateQueryRestrictions(NULL, &dwQueryRestrictions);
    if (FAILED(hr))
        goto Abort;

    if ((dwQueryRestrictions & GQR_MAKES_USE_OF_CI) == 0)
    {
        hr = S_FALSE;
        goto Abort;
    }

    // allocate the arrays that we need to pass to CIMakeICommand and
    // the buffers needed for the machine name and catalog name
    aDepths = (ULONG*)LocalAlloc(LPTR, nPaths * sizeof(ULONG));
    aScopes = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aScopesOrig = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aCatalogs = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    aMachines = (WCHAR**)LocalAlloc(LPTR, nPaths * sizeof(WCHAR*));
    pszMachineAlloc = pwszMachine = (LPWSTR)LocalAlloc(LPTR, nPaths * MAX_MACHINE_NAME_LEN * sizeof(WCHAR));
    pszCatalogAlloc = pwszCatalog = (LPWSTR)LocalAlloc(LPTR, nPaths * MAX_PATH * sizeof(WCHAR));

    if (!aDepths || !aScopes || !aScopesOrig || !aCatalogs ||
        !aMachines || !pszMachineAlloc || !pszCatalogAlloc)
    {
        hr = E_OUTOFMEMORY;
        goto Abort;
    }

    // This following loop does two things,
    //  1. Check if all the scopes are indexed, if any one scope is not,
    //      fail the call and we'll do the win32 find.
    //  2. Prepare the arrays of parameters that we need to pass to
    //      CIMakeICommand().
    //
    // NOTE: Reinerf says this code looks busted for nPaths > 1.  See bug 199254 for comments.
    for (i = 0; i < nPaths; i++)
    {
        ULONG cchMachine = MAX_MACHINE_NAME_LEN;
        ULONG cchCatalog = MAX_PATH;
        WCHAR wszUNCPath[MAX_PATH];
        BOOL fRemapped = FALSE;

        // if CI is not running we can still do ci queries on a remote drive (if it is  indexed)
        // so we cannot just bail if ci is not running on user's machine
        if (!fIsCIRunning && !PathIsRemote(apwszPaths[i]))
            continue;  // do grep on this one

        hr = LocateCatalogsW(apwszPaths[i], 0, pwszMachine, &cchMachine, pwszCatalog, &cchCatalog);
        if (hr != S_OK)
        {
            // see if by chance this is a network redirected drive.  If so we CI does not handle
            // these.  See if we can remap to UNC path to ask again...
            if (!PathIsUNC(apwszPaths[i]))
            {
                DWORD nLength = ARRAYSIZE(wszUNCPath);
                // this api takes TCHAR, but we only compile this part for WINNT...
                DWORD dwType = SHWNetGetConnection(apwszPaths[i], wszUNCPath, &nLength);
                if ((dwType == NO_ERROR) || (dwType == ERROR_CONNECTION_UNAVAIL))
                {
                    fRemapped = TRUE;
                    LPWSTR pwsz = PathSkipRootW(apwszPaths[i]);
                    BOOL fOk = TRUE;
                    if (pwsz)
                    {
                        if (!PathAppendW(wszUNCPath, pwsz))
                        {
                            fOk = FALSE;
                        }
                    }
                    if (fOk)
                    {
                        cchMachine = MAX_MACHINE_NAME_LEN;  // reset in params
                        cchCatalog = MAX_PATH;

                        hr = LocateCatalogsW(wszUNCPath, 0, pwszMachine, &cchMachine, pwszCatalog, &cchCatalog);
                    }
                }
            }
        }
        if (hr != S_OK)
        {
            continue;   // this one is not indexed.
        }

        if (S_FALSE == CatalogUptodate(pwszCatalog, pwszMachine))
        {
            // not up todate
            if (dwQueryRestrictions & GQR_REQUIRES_CI)
            {
                // ci not up to date and we must use it..
                // inform the user that results may not be complete
                if (!(_grfWarnings & DFW_IGNORE_INDEXNOTCOMPLETE))
                {
                    hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_INDEXNOTCOMPLETE);
                    goto Abort;
                }
                //else use ci although index is not complete
            }
            else
            {
                // ci is not upto date so just use grep for this drive so user can get
                // complete results
                pwszCatalog[0] = 0; 
                pwszMachine[0] = 0;
                continue;
            }
        }

        aDepths[iPath] = (_grfFlags & DFOO_INCLUDESUBDIRS) ? QUERY_DEEP : QUERY_SHALLOW;
        aScopesOrig[iPath] = apwszPaths[i];
        if (fRemapped)
        {
            aScopes[iPath] = StrDupW(wszUNCPath);
            if (aScopes[iPath] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Abort;
            }
        }
        else
        {
            aScopes[iPath] = apwszPaths[i];
        }

        aCatalogs[iPath] = pwszCatalog;
        aMachines[iPath] = pwszMachine;
        
        pwszCatalog += MAX_PATH;    // advance the catalog and machine name buffer
        pwszMachine += MAX_MACHINE_NAME_LEN;
        iPath++;    // next item in this list
    }

    if (iPath == 0) 
    {
        // no catalogs found;  - We should check to see if by chance the user specified a query that
        // is CI based if so error apapropriately...
        hr = (dwQueryRestrictions & GQR_REQUIRES_CI) ? MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_INDEXSEARCH) : S_FALSE;
        goto Abort;
    }

    // Get ICommand.
    hr = CIMakeICommand(&_pCommand, iPath, aDepths, aScopes, aCatalogs, aMachines);
    if (SUCCEEDED(hr))
    {
        // create the query command string - Assume default sort...
        hr = _BuildAndSetCommandTree(_iColSort, FALSE);
        if (SUCCEEDED(hr))
        {
            if ((dwQueryRestrictions & GQR_REQUIRES_CI) && (nPaths != iPath))
            {
                // check warning flags to see if we should ignore and continue
                if (0 == (_grfWarnings & DFW_IGNORE_CISCOPEMISMATCH))
                {
                    hr = MAKE_HRESULT(3, FACILITY_SEARCHCOMMAND, SCEE_SCOPEMISMATCH);
                }
            }

            if (SUCCEEDED(hr))
            {
                // Get IRowset.
                _SetCmdProp(_pCommand);
                hr = _pCommand->Execute(0, IID_IRowsetLocate, 0, 0, (IUnknown **)&_pRowset);
                if (SUCCEEDED(hr))
                {
                    // we have the IRowset.
                    // Real work to get the Accessor
                    DBBINDING aPropMainCols[c_cDbCols] =
                    {
                        { 0,cbP*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*1,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*2,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*3,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*4,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 },
                        { 0,cbP*5,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0 }
                    };

                    hr = _MapColumns(_pRowset, c_cDbCols, aPropMainCols, c_aDbCols, _hAccessor);
                    if (SUCCEEDED(hr))
                    {
                        // OK lets also get the accessor for the WorkID...
                        hr = _MapColumns(_pRowset, ARRAYSIZE(c_aDbWorkIDCols), aPropMainCols, c_aDbWorkIDCols, _hAccessorWorkID);
                        if (SUCCEEDED(hr))
                        {
                            hr = _pRowset->QueryInterface(IID_PPV_ARG(IRowsetAsynch, &_pRowsetAsync));
                        }
                    }
                }
            }
        }
    }

    if (FAILED(hr))
        goto Abort;

    // If we got here than at least some of our paths are indexed
    // we may need to compress the list down of the ones we did not handle...
    *pcPaths = (nPaths - iPath);  // Let caller know how many we did not process

    // need to move all the ones we did not process to the start of the list...
    // we always process this list here as we may need to allocate translation lists to be used to
    // translate the some UNCS back to the mapped drive the user passed in.

    UINT j = 0, iInsert = 0;
    iPath--;    // make it easy to detect 
    for (i = 0; i < nPaths; i++) 
    {
        if (aScopesOrig[j] == apwszPaths[i])
        {
            if (aScopesOrig[j] != aScopes[j])
            {
                // There is a translation in place.
                DFODBET *pdfet = (DFODBET*)LocalAlloc(LPTR, sizeof(*pdfet));
                if (pdfet)
                {
                    pdfet->pdfetNext = _pdfetFirst;
                    _pdfetFirst = pdfet;
                    pdfet->pwszFrom = aScopes[j];
                    pdfet->cbFrom = lstrlenW(pdfet->pwszFrom);
                    pdfet->pwszTo = aScopesOrig[j];
                    aScopes[j] = aScopesOrig[j];    // Make sure loop below does not delete pwszFrom
                    apwszPaths[i] = NULL;           // Likewise for pswsTo...
                }

            }
            if (apwszPaths[i])
            {
                LocalFree((HLOCAL)apwszPaths[i]);
                apwszPaths[i] = NULL;
            }

            if (j < iPath)
                j++;
        }
        else
        {
            apwszPaths[iInsert++] = apwszPaths[i]; // move to right place
        }
    }
    iPath++;    // setup to go through cleanupcode...

     // Fall through to cleanup code...

Abort:                
    // Warning... Since a failure return from this function will
    // release this class, most all of the allocated items up till the failure should
    // be released...   Also cleanup any paths we may have allocated...
    for (i = 0; i < iPath; i++) 
    {
        if (aScopesOrig[i] != aScopes[i])
            LocalFree(aScopes[i]);
    }

    if (aDepths)
        LocalFree(aDepths);

    if (aScopes)
        LocalFree(aScopes);

    if (aScopesOrig)
        LocalFree(aScopesOrig);
    
    if (aCatalogs)
        LocalFree(aCatalogs);

    if (aMachines)
        LocalFree(aMachines);

    if (pszMachineAlloc)
        LocalFree(pszMachineAlloc);

    if (pszCatalogAlloc)
        LocalFree(pszCatalogAlloc);

    return hr;
}

// This is the main external entry point to start a search.  This will
// create a new thread to process the 
STDAPI_(BOOL) SHFindComputer(LPCITEMIDLIST, LPCITEMIDLIST)
{
    IContextMenu *pcm;
    HRESULT hr = CoCreateInstance(CLSID_ShellSearchExt, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        CMINVOKECOMMANDINFO ici = {0};

        ici.cbSize = sizeof(ici);
        ici.lpParameters = "{996E1EB1-B524-11d1-9120-00A0C98BA67D}"; // Search Guid of Find Computers
        ici.nShow  = SW_NORMAL;

        hr = pcm->InvokeCommand(&ici);

        pcm->Release();
    }
    return SUCCEEDED(hr);
}

BOOL _IsComputerPidl(LPCITEMIDLIST pidl)
{
    CLSID clsid;
    if (SUCCEEDED(GetCLSIDFromIDList(pidl, &clsid)))
    {
        return (IsEqualCLSID(clsid, CLSID_NetworkPlaces) 
             || IsEqualCLSID(clsid, CLSID_NetworkRoot)
             || IsEqualCLSID(clsid, CLSID_NetworkDomain));
    }
    return FALSE;
}

// This is the main external entry point to start a search.  This will
// create a new thread to process the
//
STDAPI_(BOOL) SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile)
{
    // are we allowed?
    if (SHRestricted(REST_NOFIND))
        return FALSE;
        
    // We Need a hack to allow Find to work for cases like
    // Rest of network and workgroups to map to find computer instead
    // This is rather gross, but what the heck.  It is also assumed that
    // the pidl is of the type that we know about (either File or network)
    if (pidlFolder && _IsComputerPidl(pidlFolder))    
    {
        return SHFindComputer(pidlFolder, pidlSaveFile);
    }

    return RealFindFiles(pidlFolder, pidlSaveFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\folder.h ===
STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName);
STDAPI_(int) GetSpecialFolderParentIDAndOffset(LPCITEMIDLIST pidl, ULONG *pcbOffset);

#define TEST_SUBFOLDER   0x00010000  // CSIDL_ values are < 0xFFFF
STDAPI_(int) GetSpecialFolderID(LPCTSTR pszFolder, const int *rgcsidl, UINT count);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fldrscut.cpp ===
//   Implements Folder Shortcut.

#include "shellprv.h"
#include "clsobj.h"

// implemented in filefldr.cpp
extern LPTSTR PathFindCLSIDExtension(LPCTSTR pszFile, CLSID *pclsid);

BOOL CreateFolderDesktopIni(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID | FCSM_FLAGS;
    fcs.pclsid = (GUID*)&CLSID_FolderShortcut;
    fcs.dwFlags = FCS_FLAG_DRAGDROP;
    return SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_FORCEWRITE));
}


EXTERN_C BOOL IsFolderShortcut(LPCTSTR pszName)
{
    SHFOLDERCUSTOMSETTINGS fcs = {0};
    CLSID clsid = {0};
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_CLSID;
    fcs.pclsid = &clsid;

    if (SUCCEEDED(SHGetSetFolderCustomSettings(&fcs, pszName, FCS_READ)))
    {
        return IsEqualGUID(clsid, CLSID_FolderShortcut);
    }
    return FALSE;
}


// exported from fsnotify.c
STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);


class CFolderShortcut : public IShellFolder2, 
                        public IPersistFolder3,
                        public IShellLinkA,
                        public IShellLinkW,
                        public IPersistFile,
                        public IExtractIcon,
                        public IQueryInfo,
                        public IFolderShortcutConvert,
                        public IPersistStreamInit,
                        public IPersistPropertyBag,
                        public IBrowserFrameOptions
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName,
                                  ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IPersistFolder3
    STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti);
    STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti);

    // IPersistStream
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm,int fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);

    // IPersistPropertyBag
    STDMETHODIMP Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    STDMETHODIMP Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);

    // IPersistPropertyBag/IPersistStreamInit
    STDMETHODIMP InitNew(void);

    // IPersistFile
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP IsDirty() { return E_NOTIMPL; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName) { return E_NOTIMPL; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IShellLinkW
    STDMETHODIMP GetPath(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD flags);
    STDMETHODIMP SetPath(LPCWSTR pszFile);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl);
    STDMETHODIMP GetDescription(LPWSTR pszName, int cchMaxName);
    STDMETHODIMP SetDescription(LPCWSTR pszName);
    STDMETHODIMP GetWorkingDirectory(LPWSTR pszDir, int cchMaxPath);
    STDMETHODIMP SetWorkingDirectory(LPCWSTR pszDir);
    STDMETHODIMP GetArguments(LPWSTR pszArgs, int cchMaxPath);
    STDMETHODIMP SetArguments(LPCWSTR pszArgs);
    STDMETHODIMP GetHotkey(WORD *pwHotkey);
    STDMETHODIMP SetHotkey(WORD wHotkey);
    STDMETHODIMP GetShowCmd(int *piShowCmd);
    STDMETHODIMP SetShowCmd(int iShowCmd);
    STDMETHODIMP GetIconLocation(LPWSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHODIMP SetIconLocation(LPCWSTR pszIconPath, int iIcon);
    STDMETHODIMP Resolve(HWND hwnd, DWORD fFlags);
    STDMETHODIMP SetRelativePath(LPCWSTR pszPathRel, DWORD dwReserved);

    // IShellLinkA
    STDMETHODIMP GetPath(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags);
    STDMETHODIMP SetPath(LPCSTR pszFile);
    STDMETHODIMP GetDescription(LPSTR pszName, int cchMaxName);
    STDMETHODIMP SetDescription(LPCSTR pszName);
    STDMETHODIMP GetWorkingDirectory(LPSTR pszDir, int cchMaxPath);
    STDMETHODIMP SetWorkingDirectory(LPCSTR pszDir);
    STDMETHODIMP GetArguments(LPSTR pszArgs, int cchMaxPath);
    STDMETHODIMP SetArguments(LPCSTR pszArgs);
    STDMETHODIMP GetIconLocation(LPSTR pszIconPath, int cchIconPath, int *piIcon);
    STDMETHODIMP SetIconLocation(LPCSTR pszIconPath, int iIcon);
    STDMETHODIMP SetRelativePath(LPCSTR pszPathRel, DWORD dwReserved);

    // IFolderShortcutConvert
    STDMETHODIMP ConvertToLink(LPCOLESTR pszPathLNK, DWORD fFlags);
    STDMETHODIMP ConvertToFolderShortcut(LPCOLESTR pszPathLNK, DWORD fFlags);

    // IExtractIcon
    STDMETHODIMP GetIconLocation(UINT uFlags, LPTSTR pszIconFile, UINT ucchMax, INT *pniIcon, UINT *puFlags);
    STDMETHODIMP Extract(LPCTSTR pcszFile, UINT uIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT ucIconSize);

    // IQueryInfo
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // IBrowserFrameOptions
    STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, IN BROWSERFRAMEOPTIONS * pdwOptions);

    CFolderShortcut();

protected:
    ~CFolderShortcut();

    void _ClearState();
    void _ClearTargetFolder();

private:
    HRESULT _LoadShortcut();
    HRESULT _GetTargetIDList(BOOL fResolve);
    HRESULT _BindFolder(BOOL fResolve);
    HRESULT _GetFolder(BOOL fForceResolve);
    HRESULT _GetFolder2();

    HRESULT _GetLink();
    HRESULT _GetLinkA();
    HRESULT _GetLinkQI(REFIID riid, void **ppv);
    HRESULT _PreBindCtxHelper(IBindCtx **ppbc);

    LONG                   _cRef;      

    LPITEMIDLIST           _pidlRoot;
    LPITEMIDLIST           _pidlTarget;
    LPITEMIDLIST           _pidlTargetFldrFromInit;
    IShellFolder*          _psfTarget;
    IShellFolder2*         _psf2Target;
    IShellLinkW*           _pslTarget;
    IShellLinkA*           _pslTargetA;
    LPTSTR                 _pszLastSave;
    BOOL                   _fHaveResolved;
    DWORD                  _dwAttributesTarget;
    TCHAR                  _szFolderPath[MAX_PATH];
};

//constructor/destructor and related functions
CFolderShortcut::CFolderShortcut() : _cRef(1), _dwAttributesTarget(FILE_ATTRIBUTE_DIRECTORY)
{
    ASSERT(_pidlRoot == NULL);
    ASSERT(_pidlTarget == NULL);
    ASSERT(_psfTarget == NULL);
    ASSERT(_psf2Target == NULL);
    ASSERT(_szFolderPath[0] == 0);
    ASSERT(_pidlTargetFldrFromInit == NULL);

    DllAddRef();
}

CFolderShortcut::~CFolderShortcut()
{
    _ClearState();
    DllRelease();
}

void CFolderShortcut::_ClearTargetFolder()
{
    ATOMICRELEASE(_psfTarget);
    ATOMICRELEASE(_psf2Target);
}

void CFolderShortcut::_ClearState()
{
    _fHaveResolved = FALSE;

    Pidl_Set(&_pidlRoot, NULL);
    Pidl_Set(&_pidlTarget, NULL);
    Pidl_Set(&_pidlTargetFldrFromInit, NULL);

    Str_SetPtr(&_pszLastSave, NULL);

    _ClearTargetFolder();

    ATOMICRELEASE(_pslTarget);
    ATOMICRELEASE(_pslTargetA);

}

STDAPI CFolderShortcut_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    // aggregation checking is handled in class factory
    CFolderShortcut* pfolder = new CFolderShortcut();
    if (pfolder)
    {
        hr = pfolder->QueryInterface(riid, ppv);
        pfolder->Release();
    }

    return hr;
}

// ensure that _pslTarget has been created and loaded

HRESULT CFolderShortcut::_LoadShortcut()
{
    HRESULT hr;

    if (_pslTarget)
    {
        hr = S_OK;
    }
    else if (_szFolderPath[0])
    {
        TCHAR szPath[MAX_PATH];

        // leave this shortcut visible so down level clients see it and can
        // navigate through it.
        if (PathCombine(szPath, _szFolderPath, TEXT("target.lnk")))
        {
            hr = LoadFromFile(CLSID_ShellLink, szPath, IID_PPV_ARG(IShellLinkW, &_pslTarget));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlTarget;

                // Prevalidate to prevent recusion
                // If GetIDList fails, that's okay; I guess it doesn't point to us after all
                if (_pslTarget->GetIDList(&pidlTarget) == S_OK)
                {
                    SHGetPathFromIDList(pidlTarget, szPath);

                    // Does this point to itself?
                    if (StrCmpI(szPath, _szFolderPath) == 0)
                    {
                        _pslTarget->Release();
                        _pslTarget = NULL;
                        hr = E_FAIL;
                    }

                    ILFree(pidlTarget);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// ensure that _pidlTarget is inited (requres _pslTarget)

HRESULT CFolderShortcut::_GetTargetIDList(BOOL bResolve)
{
    HRESULT hr = _LoadShortcut();
    if (SUCCEEDED(hr))
    {
        if (_pidlTarget)
        {
            hr = S_OK;
        }
        else
        {
            if (bResolve)
                _pslTarget->Resolve(NULL, SLR_UPDATE | SLR_NO_UI);

            hr = _pslTarget->GetIDList(&_pidlTarget);
            if (hr == S_FALSE)
                hr = E_FAIL;      // convert empty to failure

            if (SUCCEEDED(hr))
            {
                //  make sure we dont have another shortcut here
                IShellLink *psl;
                if (SUCCEEDED(SHBindToObject(NULL, IID_IShellLink, _pidlTarget, (void**)&psl)))
                {
                    ILFree(_pidlTarget);
                    hr = psl->GetIDList(&_pidlTarget);

                    if (SUCCEEDED(hr))
                    {
                        hr = _pslTarget->SetIDList(_pidlTarget);
                    }
                    
                    psl->Release();
                }
            }

            if (FAILED(hr) && _pidlTarget)
            {
                ILFree(_pidlTarget);
                _pidlTarget = NULL;
            }
        }
    }
    return hr;
}

// create _psfTarget (requires _pidlTarget)

HRESULT CFolderShortcut::_BindFolder(BOOL bResolve)
{
    ASSERT(_psfTarget == NULL);

    HRESULT hr = _GetTargetIDList(bResolve);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc = NULL;   // in/out param below
        hr = _PreBindCtxHelper(&pbc);    // avoid loops in the name space
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr))
            {
                IShellFolder *psfDesktop;
                hr = SHGetDesktopFolder(&psfDesktop);
                if (SUCCEEDED(hr))
                {
                    // Are we trying to bind to the desktop folder?
                    if (ILIsEmpty(_pidlTarget))
                    {
                        // Yes; Clone the desktop shell folder.
                        _psfTarget = psfDesktop;
                        _psfTarget->AddRef();
                        hr = S_OK;
                    }
                    else
                    {
                        // No. Bind to it.
                        hr = psfDesktop->BindToObject(_pidlTarget, pbc, IID_PPV_ARG(IShellFolder, &_psfTarget));
                    }

                    if (SUCCEEDED(hr))
                    {
                        // optionally re-target the folder (if he is a file system folder) 
                        // to separate the location in the name space (_pidlRoot) 
                        // and the folder being viewed (pfsfi.szFolderPath).

                        IPersistFolder3 *ppf;
                        if (SUCCEEDED(_psfTarget->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf))))
                        {
                            PERSIST_FOLDER_TARGET_INFO pfti = { 0 };

                            pfti.pidlTargetFolder = _pidlTarget;
                            pfti.dwAttributes = _dwAttributesTarget;
                            pfti.csidl = -1;

                            hr = ppf->InitializeEx(pbc, _pidlRoot, &pfti);
                            ppf->Release();
                        }
                    }
                    psfDesktop->Release();
                }
            }
            pbc->Release();
        }
    }
    return hr;
}

// ensure that _psfTarget is inited

HRESULT CFolderShortcut::_GetFolder(BOOL fForceResolve)
{
    HRESULT hr;

    if (fForceResolve)
    {
        if (_fHaveResolved)
        {
            hr = _psfTarget ? S_OK : E_FAIL;
        }
        else
        {
            _fHaveResolved = TRUE;  // don't do this again

            _ClearTargetFolder();
            Pidl_Set(&_pidlTarget, NULL);

            hr = _BindFolder(fForceResolve);
        }
    }
    else if (_psfTarget)
    {
        hr = S_OK;
    }
    else
    {
        hr = _BindFolder(fForceResolve);
    }
    return hr;
}

// ensure that _psf2Target is inited

HRESULT CFolderShortcut::_GetFolder2()
{
    if (_psf2Target)
        return S_OK;

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf2Target));
    return hr;
}

STDMETHODIMP CFolderShortcut::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFolderShortcut, IShellFolder, IShellFolder2),
        QITABENT(CFolderShortcut, IShellFolder2),
        QITABENTMULTI(CFolderShortcut, IPersist, IPersistFolder3),
        QITABENTMULTI(CFolderShortcut, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CFolderShortcut, IPersistFolder2, IPersistFolder3),
        QITABENT(CFolderShortcut, IPersistFolder3),
        QITABENT(CFolderShortcut, IPersistStreamInit),
        QITABENTMULTI(CFolderShortcut, IPersistStream, IPersistStreamInit),
        QITABENT(CFolderShortcut, IShellLinkA),
        QITABENT(CFolderShortcut, IShellLinkW),
        QITABENT(CFolderShortcut, IPersistFile),
        QITABENT(CFolderShortcut, IFolderShortcutConvert),
        QITABENT(CFolderShortcut, IExtractIcon),
        QITABENT(CFolderShortcut, IQueryInfo),
        QITABENT(CFolderShortcut, IPersistPropertyBag),
        QITABENT(CFolderShortcut, IBrowserFrameOptions),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFolderShortcut::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderShortcut::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// either create or init the passed bind ctx with the params to avoid loops in the name space

HRESULT CFolderShortcut::_PreBindCtxHelper(IBindCtx **ppbc)
{
    HRESULT hr;
    if (*ppbc)
    {
        (*ppbc)->AddRef();
        hr = S_OK;
    }
    else
    {
         hr = BindCtx_CreateWithMode(STGM_READ | STGM_SHARE_DENY_WRITE, ppbc);
    }

    if (SUCCEEDED(hr)) 
        (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellFolder2 *));

    return hr;
}

// IShellFolder methods

HRESULT CFolderShortcut::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;
    if (!pwszDisplayName)
        return E_INVALIDARG;

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
    {
        hr = _PreBindCtxHelper(&pbc);
        if (SUCCEEDED(hr))
        {
            hr = _psfTarget->ParseDisplayName(hwnd, pbc, pwszDisplayName, 
                                                pchEaten, ppidl, pdwAttributes);
            pbc->Release();
        }
    }
    return hr;
}

HRESULT CFolderShortcut::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    HRESULT hr = _GetFolder(TRUE);

    if (SUCCEEDED(hr))
        hr = _psfTarget->EnumObjects(hwnd, grfFlags, ppenumIDList);
    if (SUCCEEDED(hr))
        SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);
    
    return hr;
}

HRESULT CFolderShortcut::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder(TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _PreBindCtxHelper(&pbc);
        if (SUCCEEDED(hr))
        {
            hr = _psfTarget->BindToObject(pidl, pbc, riid, ppv);
            pbc->Release();

            if (SUCCEEDED(hr))
                SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);
        }
    }
    return hr;
}

HRESULT CFolderShortcut::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CFolderShortcut::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->CompareIDs(lParam, pidl1, pidl2);
    return hr;
}

HRESULT CFolderShortcut::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder(TRUE);

    if ( SUCCEEDED(hr) )
        hr = _psfTarget->CreateViewObject(hwnd, riid, ppv);

    if ( SUCCEEDED(hr) && (IsEqualIID(riid, IID_IShellView) || IsEqualIID(riid, IID_IShellView2)) )
        SHChangeNotifyRegisterAlias(_pidlTarget, _pidlRoot);

    return hr;
}

HRESULT CFolderShortcut::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    if (IsSelf (cidl, apidl))
    {
        // since our folder is marked "CallForAttributes" we get to report
        // our attributes at runtime instead of the normal way via the registry
        if (SHGetAppCompatFlags (ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT)
        {
            *rgfInOut = SFGAO_LINK | SFGAO_CAPABILITYMASK | SFGAO_FILESYSTEM;
        }
        else
        {
            *rgfInOut = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_STORAGE |
                          SFGAO_LINK | SFGAO_DROPTARGET | SFGAO_CANRENAME | SFGAO_CANDELETE |
                          SFGAO_CANLINK | SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_HASSUBFOLDER;
        }
        return S_OK;
    }

    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetAttributesOf(cidl, apidl, rgfInOut);
    return hr;
}

HRESULT CFolderShortcut::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    return hr;
}

HRESULT CFolderShortcut::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->GetDisplayNameOf(pidl, uFlags, pName);
    return hr;
}

HRESULT CFolderShortcut::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                                   LPCOLESTR pszName, DWORD uFlags,
                                   LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = _GetFolder(FALSE);
    if (SUCCEEDED(hr))
        hr = _psfTarget->SetNameOf(hwnd, pidl, pszName, uFlags, ppidlOut);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultSearchGUID(LPGUID lpGuid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultSearchGUID(lpGuid);
    return hr;
}

STDMETHODIMP CFolderShortcut::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->EnumSearches(ppenum);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{    
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDefaultColumnState(iColumn, pbState);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDetailsEx(pidl, pscid, pv);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetail)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->GetDetailsOf(pidl, iColumn, pDetail);
    return hr;
}

STDMETHODIMP CFolderShortcut::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2Target->MapColumnToSCID(iColumn, pscid);
    return hr;
}

// IPersist
HRESULT CFolderShortcut::GetClassID(CLSID *pCLSID)
{
    *pCLSID = CLSID_FolderShortcut;
    return S_OK;
}

// IPersistFolder
HRESULT CFolderShortcut::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // is the link loaded (could have been loaded through IPersistStream::Load)?
    if (_pslTarget)
    {
        // Yes, it's loaded so re-initialize
        // note, _szFolderPath will be empty since we are not loaded from the file system

        hr = Pidl_Set(&_pidlRoot, pidl) ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        // we explictly require initialization through 
        // IPersistFolder3::InitializeEx, if we don't do these we can
        // not defent against loops in the name space
        hr = E_FAIL;
    }

    return hr;
}

// IPersistFolder2
STDMETHODIMP CFolderShortcut::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(this->_pidlRoot, ppidl);
}

// IPersistFolder3
STDMETHODIMP CFolderShortcut::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = E_INVALIDARG;  // assume failure

    if ( NULL == pbc || (pbc && !SHSkipJunction(pbc, &CLSID_FolderShortcut)) )
    {
        _ClearState();

        if (pidlRoot)
            hr = SHILClone(pidlRoot, &_pidlRoot);

        if (pfti && pfti->pidlTargetFolder)
        {
            if ( SUCCEEDED(hr) )
                hr = SHILClone(pfti->pidlTargetFolder, &_pidlTargetFldrFromInit);

            if ( SUCCEEDED(hr) && !_szFolderPath[0] )
                hr = SHGetPathFromIDList(pfti->pidlTargetFolder, _szFolderPath) ? S_OK : E_FAIL;
        }
        else
        {
            if ( SUCCEEDED(hr) && !_szFolderPath[0] )
                hr = SHGetPathFromIDList(_pidlRoot, _szFolderPath) ? S_OK : E_FAIL;
        }

        if ( SUCCEEDED(hr) )
            hr = _LoadShortcut();
    }
    return hr;
}

HRESULT CFolderShortcut::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;

    ZeroMemory(pfti, sizeof(*pfti));

    if ( _pidlTargetFldrFromInit )
        hr = SHILClone(_pidlTargetFldrFromInit, &pfti->pidlTargetFolder);

    pfti->dwAttributes = -1;
    pfti->csidl = -1;
    return hr;
}

HRESULT CFolderShortcut::_GetLink()
{
    HRESULT hr = _LoadShortcut();
    if (FAILED(hr))
    {
        // get an empty one in case we are going to be asked to save
        hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLinkW, &_pslTarget));
    }
    return hr;
}

HRESULT CFolderShortcut::_GetLinkQI(REFIID riid, void **ppv)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->QueryInterface(riid, ppv);
    return hr;
}

HRESULT CFolderShortcut::_GetLinkA()
{
    return _pslTargetA ? S_OK : _GetLinkQI(IID_PPV_ARG(IShellLinkA, &_pslTargetA));
}

// IPersistFile
STDMETHODIMP CFolderShortcut::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    _ClearState();

    SHUnicodeToTChar(pszFileName, _szFolderPath, ARRAYSIZE(_szFolderPath));
    return _LoadShortcut();
}

BOOL _IsFolder(LPCITEMIDLIST pidl)
{
    ULONG rgInfo = SFGAO_FOLDER;
    HRESULT hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, NULL, 0, &rgInfo);
    return SUCCEEDED(hr) && (rgInfo & SFGAO_FOLDER);
}

void PathStripTrailingDots(LPTSTR szPath)
{
    if (szPath[0] == TEXT('\0'))
        return;

    LPTSTR psz = &szPath[lstrlen(szPath) - 1];

    while ((*psz == TEXT('.')) && 
           (psz >= szPath))
    {
        *psz-- = TEXT('\0');
    }

}


STDMETHODIMP CFolderShortcut::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr = _GetTargetIDList(FALSE);

    // We need to make sure the folder shortcut can be saved keeping in mind the MAX_PATH limitation
    // cchFSReserved is the number of characters to reserve for the largest file that will be created
    // in the foldershortcut directory, in this case, it is the ARRAYSIZE of "\\desktop.ini"
    static const int cchFSReserved = ARRAYSIZE(TEXT("\\desktop.ini")); 

    LPITEMIDLIST pidlInternet;

    // Don't create a folder shortcut to the internet folder.
    if (SUCCEEDED(hr) && SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_INTERNET, &pidlInternet)))
    {
        if (ILIsEqual(_pidlTarget, pidlInternet))
        {
            hr = E_INVALIDARG;
        }
        ILFree(pidlInternet);
    }

    if (SUCCEEDED(hr) && _IsFolder(_pidlTarget))
    {
        // we know the target is a folder, create a folder shortcut.
        BOOL fCreatedDir;
        TCHAR szName[MAX_PATH];

        SHUnicodeToTChar(pszFileName, szName, ARRAYSIZE(szName));

        // Remove any exisiting extension. 
        // We dont want "Shortcut To My Documents.lnk.{GUID}
        if (PathFindCLSIDExtension(szName,NULL))
        {
            PathRemoveExtension(szName);
        }

        PathStripTrailingDots(szName);

        // Can't create a fldrshcut with too long a path
        if ((MAX_PATH - cchFSReserved) < lstrlen(szName))
        {
            hr = CO_E_PATHTOOLONG;
        }
        
        if (SUCCEEDED(hr))
        {
            if (PathIsDirectory(szName))
                fCreatedDir = FALSE;
            else
                fCreatedDir = SHCreateDirectory(NULL, szName) == 0;

            CreateFolderDesktopIni(szName);

            // Now initialize the child link
            IPersistFile *ppf;
            hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                WCHAR wszName[MAX_PATH];
                SHTCharToUnicode(szName, wszName, ARRAYSIZE(wszName));

                if (PathAppendW(wszName, L"target.lnk"))
                {
                    hr = ppf->Save(wszName, fRemember);
                    if (SUCCEEDED(hr))
                    {
                        if (fRemember)
                            Str_SetPtr(&_pszLastSave, szName);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                }

                ppf->Release();
            }

            if (FAILED(hr) && fCreatedDir) 
            {
                RemoveDirectory(szName);    // cleanup after ourselves.
            }
        }
    }
    else
    {
        // ensure that if we save as a file we do so with the right extension
        WCHAR szFile[MAX_PATH];
        hr = StringCchCopy(szFile, ARRAYSIZE(szFile), pszFileName);
        if (SUCCEEDED(hr))
        {
            PathRenameExtension(szFile, L".lnk");

            // the target is not a folder, create a normal shortcut in this case
            IPersistFile *ppf;
            hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Save(szFile, fRemember);
                ppf->Release();
            }
        }
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT hr = E_FAIL;
    if (_pszLastSave)
        hr = SHStrDup(_pszLastSave, ppszFileName);
    else if (_pslTarget)
    {
        IPersistFile *ppf;
        hr = _pslTarget->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->GetCurFile(ppszFileName);
            ppf->Release();
        }
    }
    return hr;
}

// IShellLinkW

STDMETHODIMP CFolderShortcut::GetPath(LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD flags)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetPath(pszFile, cchMaxPath, pfd, flags);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetPath(LPCWSTR pwszFile)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr) && PathIsDirectoryW(pwszFile))
    {
        hr = _pslTarget->SetPath(pwszFile);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetIDList(ppidl);
    else
        *ppidl = NULL;
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIDList(LPCITEMIDLIST pidl)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
    {
        hr = _pslTarget->SetIDList(pidl);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDescription(LPWSTR wszName, int cchMaxName)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetDescription(wszName, cchMaxName);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetDescription(LPCWSTR wszName)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetDescription(wszName);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetWorkingDirectory(LPWSTR wszDir, int cchMaxPath)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetWorkingDirectory(wszDir, cchMaxPath);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetWorkingDirectory(LPCWSTR wszDir)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetWorkingDirectory(wszDir);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetArguments(LPWSTR wszArgs, int cchMaxPath)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetArguments(wszArgs, cchMaxPath);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::SetArguments(LPCWSTR wszArgs)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetArguments(wszArgs);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::GetHotkey(WORD *pwHotkey)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetHotkey(pwHotkey);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetHotkey(WORD wHotkey)
{
    HRESULT hr = _GetLink();
   if (SUCCEEDED(hr))
        hr = _pslTarget->SetHotkey(wHotkey);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetShowCmd(int *piShowCmd)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetShowCmd(piShowCmd);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetShowCmd(int iShowCmd)
{
    HRESULT hr = _GetLink();
   if (SUCCEEDED(hr))
        hr = _pslTarget->SetShowCmd(iShowCmd);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(LPWSTR wszIconPath, int cchIconPath, int *piIcon)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->GetIconLocation(wszIconPath, cchIconPath, piIcon);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIconLocation(LPCWSTR wszIconPath, int iIcon)
{
    HRESULT hr = _GetLink();
    if  (SUCCEEDED(hr))
        hr = _pslTarget->SetIconLocation(wszIconPath, iIcon);

    return hr;
}

STDMETHODIMP CFolderShortcut::Resolve(HWND hwnd, DWORD fFlags)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->Resolve(hwnd, fFlags);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetRelativePath(LPCWSTR wszPathRel, DWORD dwReserved)
{
    HRESULT hr = _GetLink();
    if (SUCCEEDED(hr))
        hr = _pslTarget->SetRelativePath(wszPathRel, dwReserved);

    return hr;
}

// IShellLinkA
STDMETHODIMP CFolderShortcut::GetPath(LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD flags)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetPath(pszFile, cchMaxPath, pfd, flags);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetDescription(LPSTR pszName, int cchMaxName)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetDescription(pszName, cchMaxName);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetWorkingDirectory(LPSTR pszDir, int cchMaxPath)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetWorkingDirectory(pszDir, cchMaxPath);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetArguments(LPSTR pszArgs, int cchMaxPath)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->GetArguments(pszArgs, cchMaxPath);//this is probably not at all useful.
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(LPSTR pszIconPath, int cchIconPath, int *piIcon)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr)) 
       hr = _pslTargetA->GetIconLocation(pszIconPath, cchIconPath, piIcon);    
    return hr;
}

STDMETHODIMP CFolderShortcut::SetPath(LPCSTR pszFile)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr) && PathIsDirectoryA(pszFile))
    {
        hr = _pslTargetA->SetPath(pszFile);
        Pidl_Set(&_pidlTarget, NULL);
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::SetDescription(LPCSTR pszName)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetDescription(pszName);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetWorkingDirectory(LPCSTR pszDir)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetWorkingDirectory(pszDir);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetArguments(LPCSTR pszArgs)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetArguments(pszArgs);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetIconLocation(LPCSTR pszIconPath, int iIcon)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))    
        hr = _pslTargetA->SetIconLocation(pszIconPath, iIcon);
    return hr;
}

STDMETHODIMP CFolderShortcut::SetRelativePath(LPCSTR pszPathRel, DWORD dwReserved)
{
    HRESULT hr = _GetLinkA();
    if (SUCCEEDED(hr))
        hr = _pslTargetA->SetRelativePath(pszPathRel, dwReserved);
    return hr;
}

STDMETHODIMP CFolderShortcut::GetIconLocation(UINT uFlags, LPTSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    IExtractIcon *pxi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        hr = pxi->GetIconLocation(uFlags, pszIconFile, ucchMax, pniIcon, puFlags);
        pxi->Release();
    }
    return hr;
}

STDMETHODIMP CFolderShortcut::Extract(LPCTSTR pcszFile, UINT uIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT ucIconSize)
{
    IExtractIcon *pxi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        hr = pxi->Extract(pcszFile, uIconIndex, phiconLarge, phiconSmall, ucIconSize);
        pxi->Release();
    }
    return hr;
}

HRESULT CFolderShortcut::GetInfoTip(DWORD dwFlags, WCHAR** ppwszText)
{
    IQueryInfo *pqi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        hr = pqi->GetInfoTip(dwFlags | QITIPF_LINKUSETARGET, ppwszText);
        pqi->Release();
    }
    return hr;
}

HRESULT CFolderShortcut::GetInfoFlags(DWORD *pdwFlags)
{
    IQueryInfo *pqi;
    HRESULT hr = _GetLinkQI(IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        hr = pqi->GetInfoFlags(pdwFlags);
        pqi->Release();
    }
    return hr;
}


// IBrowserFrameOptions
HRESULT CFolderShortcut::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, IN BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = _GetFolder(FALSE);

    *pdwOptions = BFO_NONE;
    if (SUCCEEDED(hr))
    {
        IBrowserFrameOptions *pbfo;

        hr = _psfTarget->QueryInterface(IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);        
            pbfo->Release();
        }
    }
    
    return hr;
}


// IPersistStream
STDMETHODIMP CFolderShortcut::Load(IStream *pStm)
{
    _ClearState();

    IPersistStream *pps;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->Load(pStm);
        if (SUCCEEDED(hr))
            pps->QueryInterface(IID_PPV_ARG(IShellLinkW, &_pslTarget));  // keep this guy
        pps->Release();
    }
    return hr;
}

// IPersistStream
STDMETHODIMP CFolderShortcut::Save(IStream *pStm, int fClearDirty)
{
    return E_NOTIMPL;
}

// IPersistStream
STDMETHODIMP CFolderShortcut::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    return E_NOTIMPL;
}

//
// IFolderShortcut::ConvertToLink.
//
// destructively convert a Folder Shortcut into a Shell Link.
//
//  pszFolderShortcut is the path to an existing folder shortcut
//  c:\Folder Shortcut.{guid}   - deleted
//  c:\Folder Shortcut.lnk      - created
//
STDMETHODIMP CFolderShortcut::ConvertToLink(LPCOLESTR pszFolderShortcut, DWORD fFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_PATH];

    SHUnicodeToTChar(pszFolderShortcut, szName, ARRAYSIZE(szName));

    if (PathIsDirectory(szName) && IsFolderShortcut(szName))
    {
        TCHAR szLinkName[MAX_PATH];

        // c:\Folder Shortcut\target.lnk 
        hr = StringCchCopy(szLinkName, ARRAYSIZE(szLinkName), szName);
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;

            if (PathAppend(szLinkName, TEXT("target.lnk")))
            {
                PathRenameExtension(szName, TEXT(".lnk"));

                // FS.{guid} -> FS.lnk
                if (CopyFile(szLinkName, szName, FALSE))
                {
                    PathRemoveExtension(szName);

                    if (DeleteFile(szLinkName)
                        && PathAppend(szName, TEXT("desktop.ini"))
                        && DeleteFile(szName)
                        && PathRemoveFileSpec(szName)
                        && RemoveDirectory(szName))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

//
// IFolderShortcut::ConvertToFolderShortcut.
//
// destructively convert a Shell Link (.lnk) -> Folder Shortcut (Folder.{guid}).
//  pszPathLNK is the path to an existing .lnk file
//  c:\Folder Shortcut.lnk      - deleted
//  c:\Folder Shortcut.{guid}   - created
//
STDMETHODIMP CFolderShortcut::ConvertToFolderShortcut(LPCOLESTR pszPathLNK, DWORD fFlags)
{
    //must bind to the link, resolve it, and make sure it points to a folder.
    IShellLink *psl;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))  
    {
        IPersistFile *ppf;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(pszPathLNK, STGM_READ);
            if (SUCCEEDED(hr))
            {
                hr = psl->Resolve(NULL, SLR_NO_UI); // make sure the link is real
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;

                    hr = psl->GetIDList(&pidl);
                    if (hr == S_OK)
                    {
                        // this should maybe work on the pidl so that 
                        // it doesn't have to worry about files.
                        if (_IsFolder(pidl))
                        {             
                            TCHAR szPath[MAX_PATH], szName[MAX_PATH]; 
                            SHUnicodeToTChar(pszPathLNK, szName, ARRAYSIZE(szName));

                            hr = StringCchCopy(szPath, ARRAYSIZE(szPath), szName);
                            if (SUCCEEDED(hr))
                            {
                                hr = E_FAIL;

                                PathRemoveExtension(szName);
                                BOOL fCreatedDir = SHCreateDirectory(NULL, szName) == 0;

                                if (CreateFolderDesktopIni(szName) &&
                                    PathAppend(szName, TEXT("target.lnk")))
                                {
                                    //copy the link file into the new directory.
                                    if (CopyFile(szPath, szName, FALSE))
                                    {
                                        if (DeleteFile(szPath)) //if all goes well, delete the old.
                                            hr = S_OK;
                                    }
                                    else
                                    {
                                        PathRemoveFileSpec(szName);
                                        if (fCreatedDir)
                                            RemoveDirectory(szName);
                                    }
                                }
                            }
                        }
                        else
                            hr = E_FAIL;
                        ILFree(pidl);
                    }
                    else
                        hr = E_FAIL;
                }
            }
            ppf->Release();
        }
        psl->Release();
    }
    
    return hr;
}

// IPersistPropertyBag
STDMETHODIMP CFolderShortcut::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

// IPersistPropertyBag
STDMETHODIMP CFolderShortcut::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    _ClearState();

    IPersistPropertyBag* pppb;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IPersistPropertyBag, &pppb));
    if (SUCCEEDED(hr))
    {
        hr = pppb->Load(pPropBag, pErrorLog);
        if (SUCCEEDED(hr))
        {
            hr = pppb->QueryInterface(IID_PPV_ARG(IShellLinkW, &_pslTarget));

            DWORD dwFlags;
            if (SUCCEEDED(SHPropertyBag_ReadDWORD(pPropBag, L"Attributes", &dwFlags)))
                _dwAttributesTarget = dwFlags;
        }
        pppb->Release();
    }

    return hr;
}

STDMETHODIMP CFolderShortcut::InitNew(void)
{
    _ClearState();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\folder.cpp ===
#include "shellprv.h"

#include "apithk.h"
#include "folder.h"
#include "ids.h"
#include "deskfldr.h"
#include <winnls.h>
#include "shitemid.h"
#include "sddl.h"
#ifdef _WIN64
#include <wow64t.h>
#endif
#include "filefldr.h"
#include "lmcons.h"
#include "netview.h"

//---------------------------------------------------------------------------
// Get the path for the CSIDL_ folders  and optionally create it if it
// doesn't exist.
//
// Returns FALSE if the special folder given isn't one of those above or the
// directory couldn't be created.
// By default all the special folders are in the windows directory.
// This can be overidden by a [.Shell Folders] section in win.ini with
// entries like Desktop = c:\stuff\desktop
// This in turn can be overidden by a "per user" section in win.ini eg
// [Shell Folder Ianel] - the user name for this section is the current
// network user name, if this fails the default network user name is used
// and if this fails the name given at setup time is used.
//
// "Shell Folders" is the key that records all the absolute paths to the
// shell folders.  The values there are always supposed to be present.
//
// "User Shell Folders" is the key where the user's modifications from
// the defaults are stored.
//
// When we need to find the location of a path, we look in "User Shell Folders"
// first, and if that's not there, generate the default path.  In either
// case we then write the absolute path under "Shell Folders" for other
// apps to look at.  This is so that HKEY_CURRENT_USER can be propagated
// to a machine with Windows installed in a different directory, and as
// long as the user hasn't changed the setting, they won't have the other
// Windows directory hard-coded in the registry.
//   -- gregj, 11/10/94

typedef enum {
    SDIF_NONE                   = 0,
    SDIF_CREATE_IN_ROOT         = 0x00000001,   // create in root (not in profiles dir)
    SDIF_CREATE_IN_WINDIR       = 0x00000002,   // create in the windows dir (not in profiles dir)
    SDIF_CREATE_IN_ALLUSERS     = 0x00000003,   // create in "All Users" folder (not in profiles dir)
    SDIF_CREATE_IN_MYDOCUMENTS  = 0x00000004,   // create in CSIDL_PERSONAL folder
    SDIF_CREATE_IN_LOCALSET     = 0x00000005,   // create in <user>\Local Settings folder

    SDIF_CREATE_IN_MASK         = 0x0000000F,   // mask for above values

    SDIF_CAN_DELETE             = 0x00000010,
    SDIF_SHORTCUT_RELATIVE      = 0x00000020,   // make shortcuts relative to this folder
    SDIF_HIDE                   = 0x00000040,   // hide these when we create them
    SDIF_EMPTY_IF_NOT_IN_REG    = 0x00000080,   // does not exist if nothing in the registry
    SDIF_NOT_FILESYS            = 0x00000100,   // not a file system folder
    SDIF_NOT_TRACKED            = 0x00000200,   // don't track this, it can't change
    SDIF_CONST_IDLIST           = 0x00000400,   // don't alloc or free this
    SDIF_REMOVABLE              = 0x00000800,   // Can exist on removable media
    SDIF_CANT_MOVE_RENAME       = 0x00001000,   // can't move or rename this
    SDIF_WX86                   = 0x00002000,   // do Wx86 thunking
    SDIF_NETWORKABLE            = 0x00004000,   // Can be moved to the net
    SDIF_MAYBE_ALIASED          = 0x00008000,   // could have an alias representation
    SDIF_PERSONALIZED           = 0x00010000,   // resource name is to be personalized
    SDIF_POLICY_NO_MOVE         = 0x00020000,   // policy blocks move
} ;
typedef DWORD FOLDER_FLAGS;

typedef void (*FOLDER_CREATE_PROC)(int id, LPCTSTR pszPath);

void _InitMyPictures(int id, LPCTSTR pszPath);
void _InitMyMusic(int id, LPCTSTR pszPath);
void _InitMyVideos(int id, LPCTSTR pszPath);
void _InitPerUserMyMusic(int id, LPCTSTR pszPath);
void _InitPerUserMyPictures(int id, LPCTSTR pszPath);
void _InitRecentDocs(int id, LPCTSTR pszPath);
void _InitFavorites(int id, LPCTSTR pszPath);

typedef struct {
    int id;                     // CSIDL_ value
    int idsDefault;             // string id of default folder name name
    LPCTSTR pszValueName;       // reg key (not localized)
    HKEY hKey;                  // HKCU or HKLM (Current User or Local Machine)
    FOLDER_FLAGS dwFlags;
    FOLDER_CREATE_PROC pfnInit;
    INT idsLocalizedName;
} FOLDER_INFO;

//  typical entry
#define FOLDER(csidl, ids, value, key, ff)                    \
    { csidl, ids, value, key, ff, NULL, 0}

//  FIXEDFOLDER entries must have be marked SDIF_CONST_IDLIST
//  or have code in _GetFolderDefaultPath() to create their path
//  if they have a filesys path
#define FIXEDFOLDER(csidl, value, ff)                           \
    { csidl, 0, value, NULL, ff, NULL, 0}

//  PROCFOLDER's have a FOLDER_CREATE_PROC pfn that gets
//  run in _PostCreateStuff()
#define PROCFOLDER(csidl, ids, value, key, ff, proc, idsLocal)  \
    {csidl, ids, value, key, ff, proc, idsLocal}

//  folder that needs SHSetLocalizedName() in _PostCreateStuff()
#define LOCALFOLDER(csidl, ids, value, key, ff, idsLocal)  \
    {csidl, ids, value, key, ff, NULL, idsLocal}

const FOLDER_INFO c_rgFolderInfo[] = 
{
FOLDER(         CSIDL_DESKTOP,
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("DesktopFolder"), 
                    NULL, 
                    SDIF_NOT_TRACKED | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_NETWORK,
                    TEXT("NetworkFolder"),
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_DRIVES,    
                    TEXT("DriveFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_INTERNET,  
                    TEXT("InternetFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_CONTROLS,  
                    TEXT("ControlPanelFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_PRINTERS,
                    TEXT("PrintersFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_BITBUCKET, 
                    TEXT("RecycleBinFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FIXEDFOLDER(    CSIDL_CONNECTIONS, 
                    TEXT("ConnectionsFolder"), 
                    SDIF_NOT_TRACKED | SDIF_NOT_FILESYS | SDIF_CONST_IDLIST),

FOLDER(         CSIDL_FONTS, 
                    0,
                    TEXT("Fonts"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NOT_TRACKED | SDIF_CREATE_IN_WINDIR | SDIF_CANT_MOVE_RENAME),

FOLDER(         CSIDL_DESKTOPDIRECTORY, 
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("Desktop"), 
                    HKEY_CURRENT_USER, SDIF_SHORTCUT_RELATIVE),

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order
FOLDER(         CSIDL_STARTUP,    
                    IDS_CSIDL_STARTUP, 
                    TEXT("Startup"), 
                    HKEY_CURRENT_USER, SDIF_NONE),
                    
FOLDER(         CSIDL_PROGRAMS,   
                    IDS_CSIDL_PROGRAMS, 
                    TEXT("Programs"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE),

FOLDER(         CSIDL_STARTMENU,  
                    IDS_CSIDL_STARTMENU, 
                    TEXT("Start Menu"), 
                    HKEY_CURRENT_USER, 
                    SDIF_SHORTCUT_RELATIVE),

PROCFOLDER(     CSIDL_RECENT,
                    IDS_CSIDL_RECENT, 
                    TEXT("Recent"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE,
                    _InitRecentDocs, 
                    IDS_FOLDER_RECENTDOCS),

FOLDER(         CSIDL_SENDTO,     
                    IDS_CSIDL_SENDTO, 
                    TEXT("SendTo"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

FOLDER(         CSIDL_PERSONAL,   
                    IDS_CSIDL_PERSONAL, 
                    TEXT("Personal"), 
                    HKEY_CURRENT_USER, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CONST_IDLIST | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE),
                    
PROCFOLDER(     CSIDL_FAVORITES,  
                    IDS_CSIDL_FAVORITES, 
                    TEXT("Favorites"), 
                    HKEY_CURRENT_USER, 
                    SDIF_POLICY_NO_MOVE,
                    _InitFavorites,
                    IDS_FOLDER_FAVORITES),

FOLDER(         CSIDL_NETHOOD,    
                    IDS_CSIDL_NETHOOD, 
                    TEXT("NetHood"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

FOLDER(         CSIDL_PRINTHOOD,  
                    IDS_CSIDL_PRINTHOOD, 
                    TEXT("PrintHood"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),
                    
FOLDER(         CSIDL_TEMPLATES,  
                    IDS_CSIDL_TEMPLATES, 
                    TEXT("Templates"), 
                    HKEY_CURRENT_USER, 
                    SDIF_HIDE),

    // Common special folders

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order

FOLDER(         CSIDL_COMMON_STARTUP,  
                    IDS_CSIDL_STARTUP,    
                    TEXT("Common Startup"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS | SDIF_CANT_MOVE_RENAME | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_PROGRAMS,  
                    IDS_CSIDL_PROGRAMS,  
                    TEXT("Common Programs"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_STARTMENU, 
                    IDS_CSIDL_STARTMENU, 
                    TEXT("Common Start Menu"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),
                    
FOLDER(         CSIDL_COMMON_DESKTOPDIRECTORY, 
                    IDS_CSIDL_DESKTOPDIRECTORY, 
                    TEXT("Common Desktop"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS),
                    
FOLDER(         CSIDL_COMMON_FAVORITES, 
                    IDS_CSIDL_FAVORITES, 
                    TEXT("Common Favorites"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS),

FOLDER(         CSIDL_COMMON_APPDATA,   
                    IDS_CSIDL_APPDATA,   
                    TEXT("Common AppData"),   
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CREATE_IN_ALLUSERS),

FOLDER(         CSIDL_COMMON_TEMPLATES, 
                    IDS_CSIDL_TEMPLATES, 
                    TEXT("Common Templates"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_CREATE_IN_ALLUSERS),
                    
LOCALFOLDER(    CSIDL_COMMON_DOCUMENTS, 
                    IDS_CSIDL_ALLUSERS_DOCUMENTS, 
                    TEXT("Common Documents"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    IDS_LOCALGDN_FLD_SHARED_DOC),

    // Application Data special folder
FOLDER(         CSIDL_APPDATA, 
                    IDS_CSIDL_APPDATA, 
                    TEXT("AppData"), 
                    HKEY_CURRENT_USER, SDIF_SHORTCUT_RELATIVE),
                    
FOLDER(         CSIDL_LOCAL_APPDATA, 
                    IDS_CSIDL_APPDATA, 
                    TEXT("Local AppData"), 
                    HKEY_CURRENT_USER, SDIF_CREATE_IN_LOCALSET),

    // Non-localized startup folder (do not localize this folder name)
FOLDER(         CSIDL_ALTSTARTUP, 
                    IDS_CSIDL_ALTSTARTUP, 
                    TEXT("AltStartup"), 
                    HKEY_CURRENT_USER, 
                    SDIF_EMPTY_IF_NOT_IN_REG),

    // Non-localized Common StartUp group (do not localize this folde name)
FOLDER(         CSIDL_COMMON_ALTSTARTUP, 
                    IDS_CSIDL_ALTSTARTUP, 
                    TEXT("Common AltStartup"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_EMPTY_IF_NOT_IN_REG | SDIF_CREATE_IN_ALLUSERS),

    // Per-user Internet-related folders

FOLDER(         CSIDL_INTERNET_CACHE, 
                    IDS_CSIDL_CACHE, 
                    TEXT("Cache"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CREATE_IN_LOCALSET),
                    
FOLDER(         CSIDL_COOKIES, 
                    IDS_CSIDL_COOKIES, 
                    TEXT("Cookies"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE),

FOLDER(         CSIDL_HISTORY, 
                    IDS_CSIDL_HISTORY, 
                    TEXT("History"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CREATE_IN_LOCALSET),

FIXEDFOLDER(    CSIDL_SYSTEM,
                    TEXT("System"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_SYSTEMX86, 
                    TEXT("SystemX86"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME | SDIF_WX86 | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_WINDOWS,
                    TEXT("Windows"), 
                    SDIF_NOT_TRACKED | SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME),

FIXEDFOLDER(    CSIDL_PROFILE,
                    TEXT("Profile"), 
                    SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME),
                    
PROCFOLDER(     CSIDL_MYPICTURES, 
                    IDS_CSIDL_MYPICTURES, 
                    TEXT("My Pictures"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_SHORTCUT_RELATIVE | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE, 
                    _InitPerUserMyPictures, 
                    0),

//
// CSIDL_PROGRAM_FILES must come after CSIDL_PROGRAM_FILESX86 so that shell links for x86 apps
// work correctly on non-x86 platforms.
// Example:  On IA64 a 32-bit app creates a shortcut via IShellLink to the Program
// Files directory.  A WOW64 registry hive maps "Program Files" to "Program Files (x86)". The shell
// link code then tries to abstract the special folder part of the path by mapping to one of the
// entries in this table.  Since CSIDL_PROGRAM_FILES and CSIDL_PROGRAM_FILESX86 are the same it
// will map to the one that appears first in this table.  When the shortcut is accessed in
// 64-bit mode the cidls are no longer the same.  If CSIDL_PROGRAM_FILES was used instead of
// CSIDL_PROGRAM_FILESX86 the shortcut will be broken.
#ifdef WX86
FIXEDFOLDER(    CSIDL_PROGRAM_FILESX86,
                    TEXT("ProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE|SDIF_WX86),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMONX86,   
                    TEXT("CommonProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_WX86),
#else
FIXEDFOLDER(    CSIDL_PROGRAM_FILESX86,
                    TEXT("ProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMONX86,   
                    TEXT("CommonProgramFilesX86"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE),
#endif

// CSIDL_PROGRAM_FILES must come after CSIDL_PROGRAM_FILESX86.  See comment above.
FIXEDFOLDER(    CSIDL_PROGRAM_FILES,
                    TEXT("ProgramFiles"), 
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE | SDIF_SHORTCUT_RELATIVE),

FIXEDFOLDER(    CSIDL_PROGRAM_FILES_COMMON,
                    TEXT("CommonProgramFiles"),     
                    SDIF_NOT_TRACKED | SDIF_CAN_DELETE),

LOCALFOLDER(    CSIDL_ADMINTOOLS,         
                    IDS_CSIDL_ADMINTOOLS, 
                    TEXT("Administrative Tools"), 
                    HKEY_CURRENT_USER, 
                    SDIF_NONE,
                    IDS_LOCALGDN_FLD_ADMIN_TOOLS),

LOCALFOLDER(    CSIDL_COMMON_ADMINTOOLS,  
                    IDS_CSIDL_ADMINTOOLS, 
                    TEXT("Common Administrative Tools"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CREATE_IN_ALLUSERS,
                    IDS_LOCALGDN_FLD_ADMIN_TOOLS),

PROCFOLDER(     CSIDL_MYMUSIC, 
                    IDS_CSIDL_MYMUSIC, 
                    TEXT("My Music"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE,
                    _InitPerUserMyMusic,
                    0),

PROCFOLDER(     CSIDL_MYVIDEO, 
                    IDS_CSIDL_MYVIDEO, 
                    TEXT("My Video"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_NETWORKABLE | SDIF_REMOVABLE | SDIF_CREATE_IN_MYDOCUMENTS | SDIF_MAYBE_ALIASED | SDIF_PERSONALIZED | SDIF_POLICY_NO_MOVE,
                    _InitMyVideos,
                    0),

PROCFOLDER(     CSIDL_COMMON_PICTURES, 
                    IDS_CSIDL_ALLUSERS_PICTURES, 
                    TEXT("CommonPictures"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyPictures, 
                    IDS_SHAREDPICTURES),

PROCFOLDER(     CSIDL_COMMON_MUSIC, 
                    IDS_CSIDL_ALLUSERS_MUSIC, 
                    TEXT("CommonMusic"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyMusic,
                    IDS_SHAREDMUSIC),

PROCFOLDER(     CSIDL_COMMON_VIDEO, 

                    IDS_CSIDL_ALLUSERS_VIDEO, 
                    TEXT("CommonVideo"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_SHORTCUT_RELATIVE | SDIF_CANT_MOVE_RENAME | SDIF_CAN_DELETE | SDIF_MAYBE_ALIASED | SDIF_CREATE_IN_ALLUSERS, 
                    _InitMyVideos,
                    IDS_SHAREDVIDEO),

FIXEDFOLDER(    CSIDL_RESOURCES, 
                    TEXT("ResourceDir"), 
                    SDIF_NOT_TRACKED),

FIXEDFOLDER(    CSIDL_RESOURCES_LOCALIZED, 
                    TEXT("LocalizedResourcesDir"), 
                    SDIF_NOT_TRACKED),

FOLDER(         CSIDL_COMMON_OEM_LINKS, 
                    IDS_CSIDL_ALLUSERS_OEM_LINKS, 
                    TEXT("OEM Links"), 
                    HKEY_LOCAL_MACHINE, 
                    SDIF_CAN_DELETE | SDIF_CREATE_IN_ALLUSERS | SDIF_EMPTY_IF_NOT_IN_REG),

FOLDER(         CSIDL_CDBURN_AREA, 
                    IDS_CSIDL_CDBURN_AREA, 
                    TEXT("CD Burning"), 
                    HKEY_CURRENT_USER, 
                    SDIF_CAN_DELETE | SDIF_CREATE_IN_LOCALSET),

FIXEDFOLDER(    CSIDL_COMPUTERSNEARME, 
                    TEXT("ComputersNearMe"), 
                    SDIF_NONE),

FIXEDFOLDER(-1, NULL, SDIF_NONE)
};


EXTERN_C const IDLREGITEM c_idlMyDocs =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_MYDOCS,
    { 0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03, },}, // CLSID_MyDocuments
    0,
} ;

EXTERN_C const IDREGITEM c_idlPrinters[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    {sizeof(IDREGITEM), SHID_CONTROLPANEL_REGITEM, 0,
    { 0x2227A280, 0x3AEA, 0x1069, 0xA2, 0xDE, 0x08, 0x00, 0x2B, 0x30, 0x30, 0x9D, },}, // CLSID_Printers
    0,
} ;

EXTERN_C const IDREGITEM c_idlControls[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    0,
} ;

EXTERN_C const IDLREGITEM c_idlBitBucket =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_RECYCLEBIN,
    { 0x645FF040, 0x5081, 0x101B, 0x9F, 0x08, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E, },}, // CLSID_RecycleBin
    0,
} ;

// this array holds a cache of the values of these folders. this cache can only
// be used in the hToken == NULL case otherwise we would need a per user version
// of this cache.

#define SFENTRY(x)  { (LPTSTR)-1, (LPITEMIDLIST)x , (LPITEMIDLIST)-1}

EXTERN_C const IDREGITEM c_aidlConnections[];

struct {
    LPTSTR       psz;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNonAlias;
} g_aFolderCache[] = {
    SFENTRY(&c_idlDesktop),    // CSIDL_DESKTOP                   (0x0000)
    SFENTRY(&c_idlInetRoot),   // CSIDL_INTERNET                  (0x0001)
    SFENTRY(-1),               // CSIDL_PROGRAMS                  (0x0002)
    SFENTRY(&c_idlControls),   // CSIDL_CONTROLS                  (0x0003)
    SFENTRY(&c_idlPrinters),   // CSIDL_PRINTERS                  (0x0004)
    SFENTRY(&c_idlMyDocs),     // CSIDL_PERSONAL                  (0x0005)
    SFENTRY(-1),               // CSIDL_FAVORITES                 (0x0006)
    SFENTRY(-1),               // CSIDL_STARTUP                   (0x0007)
    SFENTRY(-1),               // CSIDL_RECENT                    (0x0008)
    SFENTRY(-1),               // CSIDL_SENDTO                    (0x0009)
    SFENTRY(&c_idlBitBucket),  // CSIDL_BITBUCKET                 (0x000a)
    SFENTRY(-1),               // CSIDL_STARTMENU                 (0x000b)
    SFENTRY(-1),               // CSIDL_MYDOCUMENTS               (0x000c)
    SFENTRY(-1),               // CSIDL_MYMUSIC                   (0x000d)
    SFENTRY(-1),               // CSIDL_MYVIDEO                   (0x000e)
    SFENTRY(-1),               // <unused>                        (0x000f)
    SFENTRY(-1),               // CSIDL_DESKTOPDIRECTORY          (0x0010)
    SFENTRY(&c_idlDrives),     // CSIDL_DRIVES                    (0x0011)
    SFENTRY(&c_idlNet),        // CSIDL_NETWORK                   (0x0012)
    SFENTRY(-1),               // CSIDL_NETHOOD                   (0x0013)
    SFENTRY(-1),               // CSIDL_FONTS                     (0x0014)
    SFENTRY(-1),               // CSIDL_TEMPLATES                 (0x0015)
    SFENTRY(-1),               // CSIDL_COMMON_STARTMENU          (0x0016)
    SFENTRY(-1),               // CSIDL_COMMON_PROGRAMS           (0X0017)
    SFENTRY(-1),               // CSIDL_COMMON_STARTUP            (0x0018)
    SFENTRY(-1),               // CSIDL_COMMON_DESKTOPDIRECTORY   (0x0019)
    SFENTRY(-1),               // CSIDL_APPDATA                   (0x001a)
    SFENTRY(-1),               // CSIDL_PRINTHOOD                 (0x001b)
    SFENTRY(-1),               // CSIDL_LOCAL_APPDATA             (0x001c)
    SFENTRY(-1),               // CSIDL_ALTSTARTUP                (0x001d)
    SFENTRY(-1),               // CSIDL_COMMON_ALTSTARTUP         (0x001e)
    SFENTRY(-1),               // CSIDL_COMMON_FAVORITES          (0x001f)
    SFENTRY(-1),               // CSIDL_INTERNET_CACHE            (0x0020)
    SFENTRY(-1),               // CSIDL_COOKIES                   (0x0021)
    SFENTRY(-1),               // CSIDL_HISTORY                   (0x0022)
    SFENTRY(-1),               // CSIDL_COMMON_APPDATA            (0x0023)
    SFENTRY(-1),               // CSIDL_WINDOWS                   (0x0024)
    SFENTRY(-1),               // CSIDL_SYSTEM                    (0x0025)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES             (0x0026)
    SFENTRY(-1),               // CSIDL_MYPICTURES                (0x0027)
    SFENTRY(-1),               // CSIDL_PROFILE                   (0x0028)
    SFENTRY(-1),               // CSIDL_SYSTEMX86                 (0x0029)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILESX86          (0x002a)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES_COMMON      (0x002b)
    SFENTRY(-1),               // CSIDL_PROGRAM_FILES_COMMONX86   (0x002c)
    SFENTRY(-1),               // CSIDL_COMMON_TEMPLATES          (0x002d)
    SFENTRY(-1),               // CSIDL_COMMON_DOCUMENTS          (0x002e)
    SFENTRY(-1),               // CSIDL_COMMON_ADMINTOOLS         (0x002f)
    SFENTRY(-1),               // CSIDL_ADMINTOOLS                (0x0030)
    SFENTRY(c_aidlConnections), // CSIDL_CONNECTIONS              (0x0031)
    SFENTRY(-1),               //                                 (0x0032)
    SFENTRY(-1),               //                                 (0x0033)
    SFENTRY(-1),               //                                 (0x0034)
    SFENTRY(-1),               // CSIDL_COMMON_MUSIC              (0x0035)
    SFENTRY(-1),               // CSIDL_COMMON_PICTURES           (0x0036)
    SFENTRY(-1),               // CSIDL_COMMON_VIDEO              (0x0037)
    SFENTRY(-1),               // CSIDL_RESOURCES                 (0x0038)
    SFENTRY(-1),               // CSIDL_RESOURCES_LOCALIZED       (0x0039)
    SFENTRY(-1),               // CSIDL_COMMON_OEM_LINKS          (0x003a)
    SFENTRY(-1),               // CSIDL_CDBURN_AREA               (0x003b)
    SFENTRY(-1),               // <unused>                        (0x003c)
    SFENTRY(-1),               // CSIDL_COMPUTERSNEARME           (0x003d)
};

HRESULT _OpenKeyForFolder(const FOLDER_INFO *pfi, HANDLE hToken, LPCTSTR pszSubKey, HKEY *phkey);
void _UpdateShellFolderCache(void);
BOOL GetUserProfileDir(HANDLE hToken, TCHAR *pszPath, UINT cchPath);
HRESULT VerifyAndCreateFolder(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPTSTR pszPath) ;


#define _IsDefaultUserToken(hToken)     ((HANDLE)-1 == hToken)


const FOLDER_INFO *_GetFolderInfo(int csidl)
{
    const FOLDER_INFO *pfi;

    // make sure g_aFolderCache can be indexed by the CSIDL values

    COMPILETIME_ASSERT((ARRAYSIZE(g_aFolderCache) - 1) == CSIDL_COMPUTERSNEARME);

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->id == csidl)
            return pfi;
    }
    return NULL;
}


// expand an individual enviornment variable
// in:
//      pszVar      "%USERPROFILE%
//      pszValue    "c:\winnt\profiles\user"
//
// in/out:
//      pszToExpand in: %USERPROFILE%\My Docs", out: c:\winnt\profiles\user\My Docs"

BOOL ExpandEnvVar(LPCTSTR pszVar, LPCTSTR pszValue, LPTSTR pszToExpand, DWORD cchToExpand)
{
    TCHAR *pszStart = StrStrI(pszToExpand, pszVar);
    if (pszStart)
    {
        TCHAR szAfter[MAX_PATH];

        StrCpyN(szAfter, pszStart + lstrlen(pszVar), ARRAYSIZE(szAfter));   // save the tail
        StrCpyN(pszStart, pszValue, (int) (cchToExpand - (pszStart - pszToExpand)));
        StrCatBuff(pszToExpand, szAfter, cchToExpand);       // put the tail back on
        return TRUE;
    }
    return FALSE;
}

HANDLE GetCurrentUserToken()
{
    HANDLE hToken;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken) ||
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_IMPERSONATE, &hToken))
        return hToken;
    return NULL;
}


// like ExpandEnvironmentStrings but is robust to the enviornment variables
// not being set. this works on...
// %SYSTEMROOT%
// %SYSTEMDRIVE%
// %USERPROFILE%
// %ALLUSERSPROFILE%
//
// in the rare case (Winstone!) that there is a NULL enviornment block

DWORD ExpandEnvironmentStringsNoEnv(HANDLE hToken, LPCTSTR pszExpand, LPTSTR pszOut, UINT cchOut)
{
    TCHAR szPath[MAX_PATH];
    if (hToken && !_IsDefaultUserToken(hToken))
    {
        if (!SHExpandEnvironmentStringsForUser(hToken, pszExpand, pszOut, cchOut))
            lstrcpyn(pszOut, pszExpand, cchOut);
    }
    else if (hToken == NULL)
    {
        // to debug env expansion failure...
        // lstrcpyn(pszOut, pszExpand, cchOut);
        SHExpandEnvironmentStrings(pszExpand, pszOut, cchOut);
    }

    // manually expand in this order since 
    //  %USERPROFILE% -> %SYSTEMDRIVE%\Docs & Settings

    if (StrChr(pszOut, TEXT('%')) && (hToken == NULL))
    {
        hToken = GetCurrentUserToken();
        if (hToken)
        {
            // this does %USERPROFILE% and other per user stuff
            SHExpandEnvironmentStringsForUser(hToken, pszExpand, pszOut, cchOut);
            CloseHandle(hToken);
        }
    }
    else if (_IsDefaultUserToken(hToken) && StrChr(pszOut, TEXT('%')))
    {
        GetUserProfileDir(hToken, szPath, ARRAYSIZE(szPath));
        ExpandEnvVar(TEXT("%USERPROFILE%"), szPath, pszOut, cchOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetAllUsersDirectory(szPath);
        ExpandEnvVar(TEXT("%ALLUSERSPROFILE%"), szPath, pszOut, cchOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        ExpandEnvVar(TEXT("%SYSTEMROOT%"), szPath, pszOut, cchOut);
    }

    if (*pszOut == TEXT('%'))
    {
        GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        ASSERT(szPath[1] == TEXT(':')); // this better not be a UNC!
        szPath[2] = 0; // SYSTEMDRIVE = 'c:', not 'c:\'
        ExpandEnvVar(TEXT("%SYSTEMDRIVE%"), szPath, pszOut, cchOut);
    }

    if (*pszOut == TEXT('%'))
        *pszOut = 0;

    return lstrlen(pszOut) + 1;    // +1 to cover the NULL
}

// get the user profile directory:
// uses the hToken as needed to determine the proper user profile

BOOL GetUserProfileDir(HANDLE hToken, TCHAR *pszPath, UINT cchPath)
{
    DWORD dwcch = cchPath;
    HANDLE hClose = NULL;
    BOOL fRet;
    
    *pszPath = 0;       // in case of error

    if (!hToken)
    {
        hClose = hToken = GetCurrentUserToken();
    }
    if (_IsDefaultUserToken(hToken))
    {
        fRet = GetDefaultUserProfileDirectory(pszPath, &dwcch);
    }
    else
    {
        fRet = GetUserProfileDirectory(hToken, pszPath, &dwcch);
    }
    if (hClose)
    {
        CloseHandle(hClose);
    }
    return fRet;
}

#ifdef WX86
void SetUseKnownWx86Dll(const FOLDER_INFO *pfi, BOOL bValue)
{
    if (pfi->dwFlags & SDIF_WX86)
    {
        //  GetSystemDirectory() knows we're looking for the Wx86 system
        //  directory when this flag is set.
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = bValue ? TRUE : FALSE;
    }
}
#else
#define SetUseKnownWx86Dll(pfi, bValue)
#endif

// read from registry
BOOL GetProgramFiles(LPCTSTR pszValue, LPTSTR pszPath, UINT cchPath)
{
    DWORD cbPath = cchPath * sizeof(*pszPath);

    *pszPath = 0;

    SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), 
        pszValue, NULL, pszPath, &cbPath);
    return (BOOL)*pszPath;
}

LPTSTR GetFontsDirectory(LPTSTR pszPath, UINT cchPath)
{
    *pszPath = 0;

    ASSERT(cchPath >= MAX_PATH);
    if ((cchPath >= MAX_PATH) && GetWindowsDirectory(pszPath, cchPath))
    {
        PathAppend(pszPath, TEXT("Fonts"));
    }

    return pszPath;
}

void LoadDefaultString(int idString, LPTSTR lpBuffer, int cchBufferMax)
{
    BOOL fSucceeded = FALSE;
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;
    HMODULE hmod = GetModuleHandle(TEXT("SHELL32"));
    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hmod, (LPCWSTR)RT_STRING,
                                   (LPWSTR)((LONG_PTR)(((USHORT)idString >> 4) + 1)), GetSystemDefaultUILanguage())) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hmod, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            idString &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (idString-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            

            // lpsz isn't NULL terminated, it's a bunch of strings stuck together with
            // little cch counts in between.

            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

            fSucceeded = TRUE;

        }
    }

    if (!fSucceeded)
    {
        LoadString(HINST_THISDLL, idString, lpBuffer, cchBufferMax);
    }
}

BOOL GetLocalSettingsDir(HANDLE hToken, LPTSTR pszPath, UINT cchPath)
{
    *pszPath = 0;

    ASSERT(cchPath >= MAX_PATH);
    if (cchPath >= MAX_PATH)
    {
        GetUserProfileDir(hToken, pszPath, cchPath);

        if (*pszPath)
        {
            TCHAR szEntry[MAX_PATH];
            LoadDefaultString(IDS_LOCALSETTINGS, szEntry, ARRAYSIZE(szEntry));
            PathAppend(pszPath, szEntry);
        }
    }
    return *pszPath ? TRUE : FALSE;
}


HRESULT GetResourcesDir(IN BOOL fLocalized, IN LPTSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemp[MAX_PATH];

    RIP(IS_VALID_WRITE_BUFFER(pszPath, TCHAR, cchSize));
    pszPath[0] = 0; // Terminate in case we fail.

    if (SHGetSystemWindowsDirectory(szTemp, ARRAYSIZE(szTemp)))
    {
        // It's now "%windir%\resources\".
        if (PathAppend(szTemp, TEXT("resources")))
        {
            if (fLocalized)
            {
                LANGID  lidUI = GetUserDefaultUILanguage();
                TCHAR szSubDir[10];

                // Now make it "%windir%\resources\<LangID>\"
                if (SUCCEEDED(StringCchPrintf(szSubDir, ARRAYSIZE(szSubDir), TEXT("%04x"), lidUI)))
                {
                    if (PathAppend(szTemp, szSubDir))
                    {
                        StrCpyN(pszPath, szTemp, cchSize);
                        hr = S_OK;
                    }
                }
            }
            else
            {
                StrCpyN(pszPath, szTemp, cchSize);
                hr = S_OK;
            }
        }
    }

    return hr;
}


// out:
//      pszPath     fills in with the full path with no env gunk (MAX_PATH)

HRESULT _GetFolderDefaultPath(const FOLDER_INFO *pfi, HANDLE hToken, LPTSTR pszPath, DWORD cchPath)
{
    ASSERT(!(pfi->dwFlags & SDIF_NOT_FILESYS)); // speical folders should not come here

    *pszPath = 0;

    TCHAR szEntry[MAX_PATH];

    switch (pfi->id)
    {
    case CSIDL_PROFILE:
        GetUserProfileDir(hToken, pszPath, cchPath);
        break;

    case CSIDL_PROGRAM_FILES:
        GetProgramFiles(TEXT("ProgramFilesDir"), pszPath, cchPath);
        break;

    case CSIDL_PROGRAM_FILES_COMMON:
        GetProgramFiles(TEXT("CommonFilesDir"), pszPath, cchPath);
        break;

    case CSIDL_PROGRAM_FILESX86:
        GetProgramFiles(TEXT("ProgramFilesDir (x86)"), pszPath, cchPath);
        break;

    case CSIDL_PROGRAM_FILES_COMMONX86:
        GetProgramFiles(TEXT("CommonFilesDir (x86)"), pszPath, cchPath);
        break;
#ifdef _WIN64
    case CSIDL_SYSTEMX86:
        //
        // downlevel systems do not have GetSystemWindowsDirectory export,
        // but shell thunking layer handles this gracefully
        GetSystemWindowsDirectory(pszPath, cchPath); 
        //
        // tack on subdirectory
        //
        if ((cchPath < MAX_PATH) || !PathCombine(pszPath, pszPath, TEXT(WOW64_SYSTEM_DIRECTORY)))
        {
            *pszPath = 0;
        }
        break;
#else
    case CSIDL_SYSTEMX86:
#endif
    case CSIDL_SYSTEM:
        GetSystemDirectory(pszPath, cchPath);
        break;

    case CSIDL_WINDOWS:
        GetWindowsDirectory(pszPath, cchPath);
        break;

    case CSIDL_RESOURCES:
        GetResourcesDir(FALSE, pszPath, cchPath);
        break;

    case CSIDL_RESOURCES_LOCALIZED:
        GetResourcesDir(TRUE, pszPath, cchPath);
        break;

    case CSIDL_COMPUTERSNEARME:
        // no path for this
        break;

    case CSIDL_FONTS:
        GetFontsDirectory(pszPath, cchPath);
        break;

    default:
        switch (pfi->dwFlags & SDIF_CREATE_IN_MASK)
        {
        case SDIF_CREATE_IN_ROOT:
            GetWindowsDirectory(pszPath, cchPath);
            PathStripToRoot(pszPath);
            break;

        case SDIF_CREATE_IN_ALLUSERS:
            if (cchPath >= MAX_PATH)
            {
                GetAllUsersDirectory(pszPath);
            }
            break;

        case SDIF_CREATE_IN_WINDIR:
            GetWindowsDirectory(pszPath, cchPath);
            break;

        case SDIF_CREATE_IN_MYDOCUMENTS:
            //  99/10/21 Mil#104600: When asking for folders in "My Documents" don't
            //  verify their existance. Just return the path. The caller will make
            //  the decision to create the folder or not.

            // on failure *pszPath will be empty

            if (cchPath >= MAX_PATH)
            {
                SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, hToken, SHGFP_TYPE_CURRENT, pszPath);
            }
            break;

        case SDIF_CREATE_IN_LOCALSET:
            GetLocalSettingsDir(hToken, pszPath, cchPath);
            break;

        default:
            GetUserProfileDir(hToken, pszPath, cchPath);
            break;
        }

        if (*pszPath && (cchPath >= MAX_PATH))
        {
            LoadDefaultString(pfi->idsDefault, szEntry, ARRAYSIZE(szEntry));
            PathAppend(pszPath, szEntry);
        }
        break;
    }
    return *pszPath ? S_OK : E_FAIL;
}

 
void RegSetFolderPath(const FOLDER_INFO *pfi, LPCTSTR pszSubKey, LPCTSTR pszPath)
{
    HKEY hk;
    if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, pszSubKey, &hk)))
    {
        if (pszPath)
            RegSetValueEx(hk, pfi->pszValueName, 0, REG_SZ, (LPBYTE)pszPath, (1 + lstrlen(pszPath)) * sizeof(TCHAR));
        else
            RegDeleteValue(hk, pfi->pszValueName);
        RegCloseKey(hk);
    }
}

BOOL RegQueryPath(HKEY hk, LPCTSTR pszValue, LPTSTR pszPath, UINT cch)
{
    DWORD cbPath = cch * sizeof(TCHAR);

    *pszPath = 0;
    SHQueryValueEx(hk, pszValue, 0, NULL, pszPath, &cbPath);
    return (BOOL)*pszPath;
}


// More than 50 is silly
#define MAX_TEMP_FILE_TRIES         50

// returns:
//      S_OK        the path exists and it is a folder
//      FAILED()    result
HRESULT _IsFolderNotFile(LPCTSTR pszFolder)
{
    HRESULT hr;
    DWORD dwAttribs = GetFileAttributes(pszFolder);
    if (dwAttribs == -1)
    {
        DWORD err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
    }
    else
    {
        // see if it is a file, if so we need to rename that file
        if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        {
            hr = S_OK;
        }
        else
        {
            int iExt = 0;
            do
            {
                TCHAR szDst[MAX_PATH];

                wnsprintf(szDst, ARRAYSIZE(szDst), L"%s.%03d", pszFolder, iExt);
                if (MoveFile(pszFolder, szDst))
                    iExt = 0;
                else
                {
                    // Normally we fail because .00x already exists but that may not be true.
                    DWORD dwError = GetLastError();
                    if (ERROR_ALREADY_EXISTS == dwError)
                        iExt++;     // Try the next one...
                    else
                        iExt = 0;   // We have problems and need to give up. (No write access?)
                }

            } while (iExt && (iExt < MAX_TEMP_FILE_TRIES));

            hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        }
    }
    return hr;
}

HRESULT _OpenKeyForFolder(const FOLDER_INFO *pfi, HANDLE hToken, LPCTSTR pszSubKey, HKEY *phkey)
{
    TCHAR szRegPath[255];
    LONG err;
    HKEY hkRoot, hkeyToFree = NULL;

    *phkey = NULL;

    StrCpyN(szRegPath, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, pszSubKey, ARRAYSIZE(szRegPath));

    if (_IsDefaultUserToken(hToken) && (pfi->hKey == HKEY_CURRENT_USER))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, TEXT(".Default"), 0, KEY_READ, &hkRoot))
            hkeyToFree = hkRoot;
        else
            return E_FAIL;
    }
    else if (hToken && (pfi->hKey == HKEY_CURRENT_USER))
    {
        if (GetUserProfileKey(hToken, KEY_CREATE_SUB_KEY, &hkRoot))
            hkeyToFree = hkRoot;
        else
            return E_FAIL;
    }
    else
        hkRoot = pfi->hKey;

    //  This must be MAXIMUM_ALLOWED because the handle is handed out to
    //  various different callers and they expect to fail/succeeded on their
    //  individual calls with the handle.
    err = RegCreateKeyEx(hkRoot, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, phkey, NULL);
    
    if (hkeyToFree)
        RegCloseKey(hkeyToFree);

    return HRESULT_FROM_WIN32(err);
}

//
//  Roaming Profiles can set up the environment variables and registry
//  keys like so:
//
//  HOMESHARE=\\server\share\user
//  HOMEPATH=\
//  My Music=%HOMESHARE%%HOMEPATH%\My Music
//
//  so you end up with "\\server\share\user\\My Music", which is an
//  invalid path.  Clean them up; otherwise SHGetSpecialFolderLocation will
//  fail.
//
void _CleanExpandedEnvironmentPath(LPTSTR pszExpand)
{
    // Search for "\\" at a location other than the start of the string.
    // If found, collapse it.
    LPTSTR pszWhackWhack;
    while (lstrlen(pszExpand) > 2 &&
           (pszWhackWhack = StrStr(pszExpand+1, TEXT("\\\\"))))
    {
        // shlwapi handles overlap
        StrCpy(pszWhackWhack+1, pszWhackWhack+2);
    }
}

// returns:
//      S_OK        found in registry, path well formed
//      S_FALSE     empty registry
//      FAILED()    failure result

HRESULT _GetFolderFromReg(const FOLDER_INFO *pfi, HANDLE hToken, LPTSTR pszPath, size_t cchPath)
{
    HKEY hkUSF;
    HRESULT hr;

    *pszPath = 0;

    hr = _OpenKeyForFolder(pfi, hToken, TEXT("User Shell Folders"), &hkUSF);
    if (SUCCEEDED(hr))
    {
        TCHAR szExpand[MAX_PATH];
        DWORD dwType, cbExpand = sizeof(szExpand);

        if (SHRegGetValue(hkUSF, NULL, pfi->pszValueName, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, &dwType, szExpand, &cbExpand) == ERROR_SUCCESS)
        {
            if (REG_SZ == dwType)
            {
                lstrcpyn(pszPath, szExpand, cchPath);
            }
            else if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStringsNoEnv(hToken, szExpand, pszPath, cchPath);
                _CleanExpandedEnvironmentPath(pszPath);
            }
            TraceMsg(TF_PATH, "_CreateFolderPath 'User Shell Folders' %s = %s", pfi->pszValueName, pszPath);
        }

        if (*pszPath == 0)
        {
            hr = S_FALSE;     // empty registry, success but empty
        }
        else if ((PathGetDriveNumber(pszPath) != -1) || PathIsUNC(pszPath))
        {
            hr = S_OK;        // good reg path, fully qualified
        }
        else
        {
            *pszPath = 0;       // bad reg data
            hr = E_INVALIDARG;
        }

        RegCloseKey(hkUSF);
    }
    return hr;
}

HRESULT _GetFolderPath(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPTSTR pszPath, size_t cchPath)
{
    HRESULT hr;

    *pszPath = 0;       // assume failure

    if (pfi->hKey)
    {
        hr = _GetFolderFromReg(pfi, hToken, pszPath, cchPath);
        if (SUCCEEDED(hr))
        {
            if (hr == S_FALSE)
            {
                // empty registry, SDIF_EMPTY_IF_NOT_IN_REG means they don't exist
                // if the registry is not populated with a value. this lets us disable
                // the common items on platforms that don't want them

                if (pfi->dwFlags & SDIF_EMPTY_IF_NOT_IN_REG)
                    return S_FALSE;     // success, but empty

                hr = _GetFolderDefaultPath(pfi, hToken, pszPath, cchPath);
            }

            if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
            {
               hr = VerifyAndCreateFolder(hwnd, pfi, uFlags, pszPath) ;
            }

            if (hr != S_OK)
            {
                *pszPath = 0;
            }

            if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
            {
                HKEY hkey;
                // record value in "Shell Folders", even in the failure case

                // NOTE: we only do this for historical reasons. there may be some
                // apps that depend on these values being in the registry, but in general
                // the contetens here are unreliable as they are only written after someone
                // asks for the folder through this API.

                if (SUCCEEDED(_OpenKeyForFolder(pfi, hToken, TEXT("Shell Folders"), &hkey)))
                {
                    RegSetValueEx(hkey, pfi->pszValueName, 0, REG_SZ, (LPBYTE)pszPath, (1 + lstrlen(pszPath)) * sizeof(TCHAR));
                    RegCloseKey(hkey);
                }
            }
        }
    }
    else
    {
        hr = _GetFolderDefaultPath(pfi, hToken, pszPath, cchPath);

        if ((S_OK == hr) && !(uFlags & CSIDL_FLAG_DONT_VERIFY))
        {
            hr = VerifyAndCreateFolder(hwnd, pfi, uFlags, pszPath);
        }
        
        if (hr != S_OK)
        {
            *pszPath = 0;
        }
    }

    ASSERT(hr == S_OK ? *pszPath != 0 : *pszPath == 0);
    return hr;
}

void _PostCreateStuff(const FOLDER_INFO *pfi, LPTSTR pszPath, BOOL fUpgrade)
{
    if (pfi->pfnInit || pfi->idsLocalizedName || (pfi->dwFlags & SDIF_PERSONALIZED))
    {
        if (fUpgrade)
        {
            //  if we are upgrading, torch all our previous meta data
            TCHAR sz[MAX_PATH];
            if (PathCombine(sz, pszPath, TEXT("desktop.ini")))
            {
                if (PathFileExistsAndAttributes(sz, NULL))
                {
                    WritePrivateProfileSection(TEXT(".ShellClassInfo"), NULL, sz);
                    //  in the upgrade case, sometimes the desktop.ini
                    //  file was there but the folder wasnt marked.
                    //  insure that it is marked.
                    PathMakeSystemFolder(pszPath);
                }
            }
        }
    
        // now call the create proc if we have one
        if (pfi->pfnInit)
            pfi->pfnInit(pfi->id, pszPath);

        // does the table specify a localized resource name that we should be 
        // using for this object?
        if (pfi->idsLocalizedName)
            SHSetLocalizedName(pszPath, TEXT("shell32.dll"), pfi->idsLocalizedName);

        // do we need to store the user name for this folder?

        if (pfi->dwFlags & SDIF_PERSONALIZED)
        {
            TCHAR szName[UNLEN+1];
            DWORD dwName = ARRAYSIZE(szName);
            if (GetUserName(szName, &dwName))
            {
                // CSharedDocuments depends on a per system list of MyDocs folders
                // this is where we make sure that list is setup

                if (!IsOS(OS_DOMAINMEMBER) && (pfi->id == CSIDL_PERSONAL))
                {
                    SKSetValue(SHELLKEY_HKLM_EXPLORER, L"DocFolderPaths",
                               szName, REG_SZ, pszPath, (lstrlen(pszPath) + 1) * sizeof(TCHAR));
                }

                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("Owner"), szName);
                wnsprintf(szName, ARRAYSIZE(szName), L"%d", pfi->id);
                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", TEXT("Personalized"), szName);
                LoadDefaultString(pfi->idsDefault, szName, ARRAYSIZE(szName));
                SetFolderString(TRUE, pszPath, NULL, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("PersonalizedName"), szName);
            }
        }
    }
}

HRESULT VerifyAndCreateFolder(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPTSTR pszPath)
{
    HRESULT hr = _IsFolderNotFile(pszPath);

    // this code supports a UI mode of this API. but generally this is not used
    // this code should be removed
    if ((hr != S_OK) && hwnd)
    {
        // we might be able to reconnect if this is a net path
        if (PathIsUNC(pszPath))
        {
            if (SHValidateUNC(hwnd, pszPath, 0))
                hr = _IsFolderNotFile(pszPath);
        }
        else if (IsDisconnectedNetDrive(DRIVEID(pszPath)))
        {
            TCHAR szDrive[3];
            PathBuildSimpleRoot(DRIVEID(pszPath), szDrive);

            if (WNetRestoreConnection(hwnd, szDrive) == WN_SUCCESS)
                hr = _IsFolderNotFile(pszPath);
         }
    }

    // to avoid a sequence of long net timeouts or calls we know won't
    // succeed test for these specific errors and don't try to create
    // the folder

    if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ||
        hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH))
    {
        return hr;
    }

    if ((hr != S_OK) && (uFlags & CSIDL_FLAG_CREATE))
    {
        DWORD err = SHCreateDirectory(NULL, pszPath);
        hr = HRESULT_FROM_WIN32(err);
        if (hr == S_OK)
        {
            ASSERT(NULL == StrChr(pszPath, TEXT('%')));

            if (pfi->dwFlags & SDIF_HIDE)
                SetFileAttributes(pszPath, GetFileAttributes(pszPath) | FILE_ATTRIBUTE_HIDDEN);

            _PostCreateStuff(pfi, pszPath, FALSE);
        }   
    }
    else if (hr == S_OK)
    {
        if (uFlags & CSIDL_FLAG_PER_USER_INIT)
            _PostCreateStuff(pfi, pszPath, TRUE);
    }

    return hr;
}

void _SetPathCache(const FOLDER_INFO *pfi, LPCTSTR psz)
{
    LPTSTR pszOld = (LPTSTR)InterlockedExchangePointer((void **)&g_aFolderCache[pfi->id].psz, (void *)psz);
    if (pszOld && pszOld != (LPTSTR)-1)
    {
        // check for the concurent use... very rare case
        LocalFree(pszOld);
    }
}


HRESULT _GetFolderPathCached(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPTSTR pszPath, size_t cchPath)
{
    HRESULT hr;

    *pszPath = 0;

    // can only cache for the current user, hToken == NULL or per machine folders
    if (!hToken || (pfi->hKey != HKEY_CURRENT_USER))
    {
        _UpdateShellFolderCache();

        LPTSTR pszCache = (LPTSTR)InterlockedExchangePointer((void **)&g_aFolderCache[pfi->id].psz, (void *)-1);
        if ((pszCache == (LPTSTR)-1) || (pszCache == NULL))
        {
            // either not cached or cached failed state
            if ((pszCache == (LPTSTR)-1) || (uFlags & (CSIDL_FLAG_CREATE | CSIDL_FLAG_DONT_VERIFY)))
            {
                hr = _GetFolderPath(hwnd, pfi, hToken, uFlags, pszPath, cchPath);

                // only set the cache value if CSIDL_FLAG_DONT_VERIFY was NOT passed
                if (!(uFlags & CSIDL_FLAG_DONT_VERIFY))
                {
                    if (hr == S_OK)
                    {
                        // dupe the string so we can add it to the cache
                        pszCache = StrDup(pszPath);
                    }
                    else
                    {
                        // we failed to get the folder path, null out the cache
                        ASSERT(*pszPath == 0);
                        pszCache = NULL;
                    }
                    _SetPathCache(pfi, pszCache);
                }
            }
            else
            {
                // cache was null and user didnt pass create flag so we just fail
                ASSERT(pszCache == NULL);
                ASSERT(*pszPath == 0);
                hr = E_FAIL;
            }
        }
        else
        {
            // cache hit case: copy the cached string and then restore the cached value back
            lstrcpyn(pszPath, pszCache, cchPath);
            _SetPathCache(pfi, pszCache);
            hr = S_OK;
        }
    }
    else
    {
        hr = _GetFolderPath(hwnd, pfi, hToken, uFlags, pszPath, cchPath);
    }

    return hr;
}

// NOTE: possibly we need a csidlSkip param to avoid recursion?
BOOL _ReparentAliases(HWND hwnd, HANDLE hToken, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases)
{
    static const struct {DWORD dwXlate; int idPath; int idAlias; BOOL fCommon;} s_rgidAliases[]= 
    {
        { XLATEALIAS_MYDOCS, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, CSIDL_PERSONAL, FALSE},
        { XLATEALIAS_COMMONDOCS, CSIDL_COMMON_DOCUMENTS | CSIDL_FLAG_NO_ALIAS, CSIDL_COMMON_DOCUMENTS, FALSE},
        { XLATEALIAS_DESKTOP, CSIDL_DESKTOPDIRECTORY, CSIDL_DESKTOP, FALSE},
        { XLATEALIAS_DESKTOP, CSIDL_COMMON_DESKTOPDIRECTORY, CSIDL_DESKTOP, TRUE},
    };
    BOOL fContinue = TRUE;
    *ppidlAlias = NULL;
    
    for (int i = 0; fContinue && i < ARRAYSIZE(s_rgidAliases); i++)
    {
        LPITEMIDLIST pidlPath;
        if ((dwXlateAliases & s_rgidAliases[i].dwXlate) && 
            (S_OK == SHGetFolderLocation(hwnd, s_rgidAliases[i].idPath, hToken, 0, &pidlPath)))
        {
            LPCITEMIDLIST pidlChild = ILFindChild(pidlPath, pidl);
            if (pidlChild)
            {
                //  ok we need to use the alias instead of the path
                LPITEMIDLIST pidlAlias;
                if (S_OK == SHGetFolderLocation(hwnd, s_rgidAliases[i].idAlias, hToken, 0, &pidlAlias))
                {
                    if (SUCCEEDED(SHILCombine(pidlAlias, pidlChild, ppidlAlias)))
                    {
                        if (s_rgidAliases[i].fCommon && !ILIsEmpty(*ppidlAlias))
                        {
                            // find the size of the special part (subtacting for null pidl terminator)
                            UINT cbSize = ILGetSize(pidlAlias) - sizeof(pidlAlias->mkid.cb);
                            LPITEMIDLIST pidlChildFirst = _ILSkip(*ppidlAlias, cbSize);

                            // We set the first ID under the common path to have the SHID_FS_COMMONITEM so that when we bind we
                            // can hand this to the proper merged psf
                            pidlChildFirst->mkid.abID[0] |= SHID_FS_COMMONITEM;
                        }
                        ILFree(pidlAlias);
                    }
                    fContinue = FALSE;
                }
            }
            ILFree(pidlPath);
        }
    }

    return (*ppidlAlias != NULL);
}

STDAPI SHILAliasTranslate(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlAlias, DWORD dwXlateAliases)
{
    return _ReparentAliases(NULL, NULL, pidl, ppidlAlias, dwXlateAliases) ? S_OK : E_FAIL;
}
    
HRESULT _CreateFolderIDList(HWND hwnd, const FOLDER_INFO *pfi, HANDLE hToken, UINT uFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;

    *ppidl = NULL;      // assume failure or empty

    if (pfi->id == CSIDL_PRINTERS && (ACF_STAROFFICE5PRINTER & SHGetAppCompatFlags(ACF_STAROFFICE5PRINTER)))
    {
        // Star Office 5.0 relies on the fact that the printer pidl used to be like below.  They skip the 
        // first simple pidl (My Computer) and do not check if there is anything else, they assume that the
        // second simple pidl is the Printer folder one. (stephstm, 07/30/99)

        // CLSID_MyComputer, CLSID_Printers
        hr = ILCreateFromPathEx(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}"), NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, NULL);
    }
    else if (pfi->id == CSIDL_COMPUTERSNEARME)
    {
        if (IsOS(OS_DOMAINMEMBER))
        {
            // only if you are in a workgroup - fail otherwise
            hr = E_FAIL;
        }
        else
        {
            // we computer this IDLIST from the domain/workgroup you are a member of
            hr = SHGetDomainWorkgroupIDList(ppidl);
        }
    }
    else if ((pfi->id == CSIDL_COMMON_DOCUMENTS) 
         && !(uFlags & CSIDL_FLAG_NO_ALIAS))
    {
        // CLSID_MyComputer \ SharedDocumnets (canonical name)
        hr = ILCreateFromPathEx(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{59031a47-3f72-44a7-89c5-5595fe6b30ee},SharedDocuments"), NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, NULL);
    }
    else if ((pfi->dwFlags & SDIF_CONST_IDLIST)
         && (!(uFlags & CSIDL_FLAG_NO_ALIAS) || !(pfi->dwFlags & SDIF_MAYBE_ALIASED)))
    {
        // these are CONST, never change
        hr = SHILClone(g_aFolderCache[pfi->id].pidl, ppidl);     
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetFolderPathCached(hwnd, pfi, hToken, uFlags, szPath, ARRAYSIZE(szPath));
        if (hr == S_OK)
        {
            HRESULT hrInit = SHCoInitialize();
            hr = ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_SKIPJUNCTIONS, ppidl, NULL);

            // attempt to reparent aliased pidls.
            if (SUCCEEDED(hr) 
            && (pfi->dwFlags & SDIF_MAYBE_ALIASED) 
            && !(uFlags & CSIDL_FLAG_NO_ALIAS))
            {
                LPITEMIDLIST pidlAlias;
                if (_ReparentAliases(hwnd, hToken, *ppidl, &pidlAlias, XLATEALIAS_ALL))
                {
                    ILFree(*ppidl);
                    *ppidl = pidlAlias;
                }
            }
            
            SHCoUninitialize(hrInit);
        }
    }
                   
    return hr;
}

void _SetIDListCache(const FOLDER_INFO *pfi, LPCITEMIDLIST pidl, BOOL fNonAlias)
{
    if (fNonAlias || !(pfi->dwFlags & SDIF_CONST_IDLIST))
    {
        void **ppv = (void **) (fNonAlias ? &g_aFolderCache[pfi->id].pidlNonAlias : &g_aFolderCache[pfi->id].pidl);
        LPITEMIDLIST pidlOld = (LPITEMIDLIST)InterlockedExchangePointer(ppv, (void *)pidl);
        if (pidlOld && pidlOld != (LPITEMIDLIST)-1)
        {
            // check for the concurent use... very rare case
            // ASSERT(pidl == (LPCITEMIDLIST)-1);   // should not really be ASSERT
            ILFree(pidlOld);
        }
    }
}

LPITEMIDLIST _GetIDListCache(const FOLDER_INFO *pfi, BOOL fNonAlias)
{
    void **ppv = (void **) (fNonAlias ? &g_aFolderCache[pfi->id].pidlNonAlias : &g_aFolderCache[pfi->id].pidl);
    ASSERT(fNonAlias || !(pfi->dwFlags & SDIF_CONST_IDLIST));
    return (LPITEMIDLIST)InterlockedExchangePointer(ppv, (void *)-1);
}

// hold this lock for the minimal amout of time possible to avoid other users
// of this resource requring them to re-create the pidl

HRESULT _GetFolderIDListCached(HWND hwnd, const FOLDER_INFO *pfi, UINT uFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    BOOL fNonAlias = uFlags & CSIDL_FLAG_NO_ALIAS;

    ASSERT(pfi->id < ARRAYSIZE(g_aFolderCache));

    if ((pfi->dwFlags & SDIF_CONST_IDLIST) && 
        (!fNonAlias || !(pfi->dwFlags & SDIF_MAYBE_ALIASED)))
    {
        // these are CONST, never change
        hr = SHILClone(g_aFolderCache[pfi->id].pidl, ppidl);     
    }
    else
    {
        LPITEMIDLIST pidlCache;

        _UpdateShellFolderCache();
        pidlCache = _GetIDListCache(pfi, fNonAlias);

        if ((pidlCache == (LPCITEMIDLIST)-1) || (pidlCache == NULL))
        {
            // either uninitalized cache state OR cached failure (NULL)
            if ((pidlCache == (LPCITEMIDLIST)-1) || (uFlags & CSIDL_FLAG_CREATE))
            {
                // not initialized (or concurent use) try creating it for this use
                hr = _CreateFolderIDList(hwnd, pfi, NULL, uFlags, ppidl);
                if (S_OK == hr)
                    hr = SHILClone(*ppidl, &pidlCache); // create cache copy
                else
                    pidlCache = NULL;
            }
            else
                hr = E_FAIL;            // return cached failure
        }
        else
        {
            hr = SHILClone(pidlCache, ppidl);   // cache hit
        }

        // store back the PIDL if it is non NULL or they specified CREATE
        // and we failed to create it (cache the not existant state). this is needed
        // so we don't cache a NULL if the first callers don't ask for create and
        // subsequent callers do
        if (pidlCache || (uFlags & CSIDL_FLAG_CREATE))
            _SetIDListCache(pfi, pidlCache, fNonAlias);
    }

    return hr;
}

void _ClearCacheEntry(const FOLDER_INFO *pfi)
{
    if (!(pfi->dwFlags & SDIF_CONST_IDLIST))
        _SetIDListCache(pfi, (LPCITEMIDLIST)-1, FALSE);

    if (pfi->dwFlags & SDIF_MAYBE_ALIASED)
        _SetIDListCache(pfi, (LPCITEMIDLIST)-1, TRUE);
        
    _SetPathCache(pfi, (LPCTSTR)-1);
}

void _ClearAllCacheEntrys()
{
    for (const FOLDER_INFO *pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        _ClearCacheEntry(pfi);
    }
}

void _ClearAllAliasCacheEntrys()
{
    for (const FOLDER_INFO *pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->dwFlags & SDIF_MAYBE_ALIASED)
        {
            _SetIDListCache(pfi, (LPCITEMIDLIST)-1, FALSE); // nuke the aliased pidl
        }
    }
}

// Per instance count of mods to Special Folder cache.
EXTERN_C HANDLE g_hCounter;
HANDLE g_hCounter = NULL;   // Global count of mods to Special Folder cache.
int g_lPerProcessCount = 0;

// Make sure the special folder cache is up to date.
void _UpdateShellFolderCache(void)
{
    HANDLE hCounter = SHGetCachedGlobalCounter(&g_hCounter, &GUID_SystemPidlChange);

    // Is the cache up to date?
    long lGlobalCount = SHGlobalCounterGetValue(hCounter);
    if (lGlobalCount != g_lPerProcessCount)
    {
        _ClearAllCacheEntrys();
        g_lPerProcessCount = lGlobalCount;
    }
}

STDAPI_(void) SHFlushSFCache(void)
{
    // Increment the shared variable;  the per-process versions will no
    // longer match, causing this and/or other processes to refresh their
    // pidl caches when they next need to access a folder.
    if (g_hCounter)
        SHGlobalCounterIncrement(g_hCounter);
}

// use SHGetFolderLocation() instead using CSIDL_FLAG_CREATE

STDAPI_(LPITEMIDLIST) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate)
{
    LPITEMIDLIST pidlReturn;

    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;

    SHGetSpecialFolderLocation(hwnd, csidl, &pidlReturn);
    return pidlReturn;
}

STDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr = SHGetFolderLocation(hwnd, csidl, NULL, 0, ppidl);
    if (hr == S_FALSE)
        hr = E_FAIL;        // mail empty case into failure for compat with this API
    return hr;
}

// return IDLIST for special folder
//      fCreate encoded in csidl with CSIDL_FLAG_CREATE (new for NT5)
//
//  in:
//      hwnd    should be NULL
//      csidl   CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwType  must be SHGFP_TYPE_CURRENT
//
//  out:
//      *ppild  NULL on failure or empty, PIDL to be freed by caller on success
//
//  returns:
//      S_OK        *ppidl is non NULL
//      S_FALISE    *ppidl is NULL, but valid csidl was passed (folder does not exist)
//      FAILED(hr)

STDAPI SHGetFolderLocation(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPITEMIDLIST *ppidl)
{
    const FOLDER_INFO *pfi;
    HRESULT hr;

    *ppidl = NULL;  // in case of error or empty

    // -1 is an invalid csidl
    if ((dwType != SHGFP_TYPE_CURRENT) || (-1 == csidl))
        return E_INVALIDARG;    // no flags used yet, validate this param

    pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);
    if (pfi)
    {
        HANDLE hTokenToFree = NULL;

        if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
                hTokenToFree = hToken;
        }
        if (hToken && (pfi->hKey == HKEY_CURRENT_USER))
        {
            // we don't cache PIDLs for other users, do all of the work
            hr = _CreateFolderIDList(hwnd, pfi, hToken, csidl & CSIDL_FLAG_MASK, (LPITEMIDLIST *)ppidl);
        }
        else
        {
            hr = _GetFolderIDListCached(hwnd, pfi, csidl & CSIDL_FLAG_MASK, ppidl);
        }

        if (hTokenToFree)
            CloseHandle(hTokenToFree);
    }
    else
        hr = E_INVALIDARG;    // bad CSIDL (apps can check to veryify our support)
    return hr;
}

STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate)
{
    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;
    return SHGetFolderPath(hwnd, csidl, NULL, 0, pszPath) == S_OK;
}

//  in:
//      hwnd    should be NULL
//      csidl   CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwType  must be SHGFP_TYPE_CURRENT
//
//  out:
//      *pszPath    MAX_PATH buffer to get path name, zeroed on failure or empty case
//
//  returns:
//      S_OK        filled in pszPath with path value
//      S_FALSE     pszPath is NULL, valid CSIDL value, but this folder does not exist
//      E_FAIL

STDAPI SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;
    const FOLDER_INFO *pfi;

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, TCHAR, MAX_PATH));
    *pszPath = 0;

    pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);
    if (pfi && !(pfi->dwFlags & SDIF_NOT_FILESYS))
    {
        switch (dwType)
        {
        case SHGFP_TYPE_DEFAULT:
            ASSERT((csidl & CSIDL_FLAG_MASK) == 0); // meaningless for default
            hr = _GetFolderDefaultPath(pfi, hToken, pszPath, MAX_PATH); //assumed buffer size!
            break;
    
        case SHGFP_TYPE_CURRENT:
            {
                HANDLE hTokenToFree = NULL;
                if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
                {
                    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
                        hTokenToFree = hToken;
                }
                hr = _GetFolderPathCached(hwnd, pfi, hToken, csidl & CSIDL_FLAG_MASK, pszPath, MAX_PATH);  //assumed buffer size!

                if (hTokenToFree)
                    CloseHandle(hTokenToFree);
            }
            break;
        }
    }
    return hr;
}

STDAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPSTR pszPath)
{
    WCHAR wsz[MAX_PATH];
    HRESULT hr = SHGetFolderPath(hwnd, csidl, hToken, dwType, wsz);

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, CHAR, MAX_PATH));

    SHUnicodeToAnsi(wsz, pszPath, MAX_PATH);
    return hr;
}

STDAPI_(BOOL) SHGetSpecialFolderPathA(HWND hwnd, LPSTR pszPath, int csidl, BOOL fCreate)
{
    if (fCreate)
        csidl |= CSIDL_FLAG_CREATE;
    return SHGetFolderPathA(hwnd, csidl, NULL, 0, pszPath) == S_OK;
}

//  Similar to SHGetFolderPath, but appends an optional subdirectory path after
//  the csidl folder path. Handles creating the subdirectories.

STDAPI SHGetFolderPathAndSubDir(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszSubDir, LPWSTR pszPath)
{
    HRESULT hr = SHGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);

    if (S_OK == hr && pszSubDir && *pszSubDir)
    {
        // assumed pszPath >= MAX_PATH
        if (!PathAppend(pszPath, pszSubDir))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
        }
        else if (csidl & CSIDL_FLAG_CREATE)
        {
            int err = SHCreateDirectoryEx(NULL, pszPath, NULL);

            if (ERROR_ALREADY_EXISTS == err)
            {
                err = ERROR_SUCCESS;
            }
            hr = HRESULT_FROM_WIN32(err);
        }
        else if (!(csidl & CSIDL_FLAG_DONT_VERIFY))
        {
            DWORD dwAttributes;

            if (PathFileExistsAndAttributes(pszPath, &dwAttributes))
            {
                if ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
            }
        }

        if (S_OK != hr)
        {
            *pszPath = 0;
        }
    }

    return hr;
}

STDAPI SHGetFolderPathAndSubDirA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszSubDir, LPSTR pszPath)
{
    WCHAR wsz[MAX_PATH];
    WCHAR wszSubDir[MAX_PATH];

    SHAnsiToUnicode(pszSubDir, wszSubDir, MAX_PATH);

    HRESULT hr = SHGetFolderPathAndSubDir(hwnd, csidl, hToken, dwFlags, wszSubDir, wsz);

    ASSERT(IS_VALID_WRITE_BUFFER(pszPath, CHAR, MAX_PATH));

    SHUnicodeToAnsi(wsz, pszPath, MAX_PATH);
    return hr;
}

//  HRESULT SHSetFolderPath (int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
//
//  in:
//      csidl       CSIDL_ value with CSIDL_FLAG_ values ORed in as well
//      dwFlags     reserved: should be 0x00000000
//      pszPath     path to change shell folder to (will optionally be unexpanded)
//
//  returns:
//      S_OK        function succeeded and flushed cache

STDAPI SHSetFolderPath(int csidl, HANDLE hToken, DWORD dwFlags, LPCTSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    // Validate csidl and dwFlags. Add extra valid flags as needed.

    RIPMSG(((csidl & CSIDL_FLAG_MASK) & ~(CSIDL_FLAG_DONT_UNEXPAND | 0x00000000)) == 0, "SHSetFolderPath: CSIDL flag(s) invalid");
    RIPMSG(dwFlags == 0, "SHSetFolderPath: dwFlags parameter must be 0x00000000");

    // Exit with E_INVALIDARG if bad parameters.

    if ((((csidl & CSIDL_FLAG_MASK) & ~(CSIDL_FLAG_DONT_UNEXPAND | 0x00000000)) != 0) ||
        (dwFlags != 0) ||
        (pszPath == NULL) ||
        (pszPath[0] == 0))
    {
        return hr;
    }

    const FOLDER_INFO *pfi = _GetFolderInfo(csidl & ~CSIDL_FLAG_MASK);

    // Only allow setting for SDIF_NOT_FILESYS is clear
    //                        SDIF_NOT_TRACKED is clear
    //                        SDIF_CANT_MOVE_RENAME is clear
    // and for non-NULL value

    // If HKLM is used then rely on security or registry restrictions
    // to enforce whether the change can be made.

    if ((pfi != NULL) &&
        ((pfi->dwFlags & (SDIF_NOT_FILESYS | SDIF_NOT_TRACKED | SDIF_CANT_MOVE_RENAME)) == 0))
    {
        BOOL    fSuccessfulUnexpand, fSuccessfulExpand, fEmptyOrNullPath;
        LONG    lError;
        HANDLE  hTokenToFree;
        TCHAR   szPath[MAX_PATH];
        TCHAR   szExpandedPath[MAX_PATH];   // holds expanded path for "Shell Folder" compat key
        LPCTSTR pszWritePath;

        hTokenToFree = NULL;
        if ((hToken == NULL) && (pfi->hKey == HKEY_CURRENT_USER))
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
            {
                hTokenToFree = hToken;
            }
        }

        fEmptyOrNullPath = ((pszPath == NULL) || (pszPath[0] == 0));
        if (fEmptyOrNullPath)
        {
            HKEY    hKeyDefaultUser;

            pszWritePath = NULL;
            if (SUCCEEDED(_OpenKeyForFolder(pfi, (HANDLE)-1, TEXT("User Shell Folders"), &hKeyDefaultUser)))
            {
                DWORD cbPath = sizeof(szPath);
                if (ERROR_SUCCESS == SHRegGetValue(hKeyDefaultUser, NULL, pfi->pszValueName,
                                                     SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL, szPath, &cbPath))
                {
                    pszWritePath = szPath;
                }
                RegCloseKey(hKeyDefaultUser);
            }
            fSuccessfulUnexpand = TRUE;
        }
        else if (csidl & CSIDL_FLAG_DONT_UNEXPAND)
        {
            // Does the caller want to write the string as is? Leave
            // it alone if so.

            pszWritePath = pszPath;
            fSuccessfulUnexpand = TRUE;
        }
        else
        {
            if (pfi->hKey == HKEY_CURRENT_USER)
            {
                fSuccessfulUnexpand = (PathUnExpandEnvStringsForUser(hToken, pszPath, szPath, ARRAYSIZE(szPath)) != FALSE);
            }
            else
            {
                fSuccessfulUnexpand = FALSE;
            }

            // Choose the appropriate source if the unexpansion was successful or not.
            // Either way the unexpansion failure should be ignored.

            if (fSuccessfulUnexpand)
            {
                pszWritePath = szPath;
            }
            else
            {
                fSuccessfulUnexpand = TRUE;
                pszWritePath = pszPath;
            }
        }

        if (fSuccessfulUnexpand)
        {
            HKEY    hKeyUser, hKeyUSF, hKeyToFree;

            // we also get the fully expanded path so that we can write it out to the "Shell Folders" key for apps that depend on
            // the old registry values
            fSuccessfulExpand = (SHExpandEnvironmentStringsForUser(hToken, pszPath, szExpandedPath, ARRAYSIZE(szExpandedPath)) != 0);

            // Get either the current users HKCU or HKU\SID if a token
            // was specified and running in NT.

            if (hToken && GetUserProfileKey(hToken, KEY_READ, &hKeyUser))
            {
                hKeyToFree = hKeyUser;
            }
            else
            {
                hKeyUser = pfi->hKey;
                hKeyToFree = NULL;
            }

            // Open the key to the User Shell Folders and write the string
            // there. Clear the shell folder cache.

            // NOTE: This functionality is duplicated in SetFolderPath but
            // that function deals with the USF key only. This function
            // requires HKU\SID so while there is identical functionality
            // from the point of view of settings the USF value that is
            // where it ends. To make this function simple it just writes
            // the value to registry itself.

            // Additional note: there is a threading issue here with
            // clearing the cache entry incrementing the counter. This
            // should be locked access.

            lError = RegOpenKeyEx(hKeyUser, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"),
                                  0, KEY_READ | KEY_WRITE, &hKeyUSF);
            if (lError == ERROR_SUCCESS)
            {
                if (pszWritePath)
                {
                    lError = RegSetValueEx(hKeyUSF, pfi->pszValueName, 0, REG_EXPAND_SZ,
                                           (LPBYTE)pszWritePath, (lstrlen(pszWritePath) + 1) * sizeof(TCHAR));
                }
                else
                {
                    lError = RegDeleteValue(hKeyUSF, pfi->pszValueName);
                }
                RegCloseKey(hKeyUSF);

                // nuke the cache state for this folder
                _ClearCacheEntry(pfi);

                // and all folders that might be aliased as those
                // could be related to this folder (under MyDocs for example)
                // and now their aliases forms my no longer be valid
                _ClearAllAliasCacheEntrys();

                g_lPerProcessCount = SHGlobalCounterIncrement(g_hCounter);
            }

            // update the old "Shell Folders" value for compat
            if ((lError == ERROR_SUCCESS) && fSuccessfulExpand)
            {
                HKEY hkeySF;

                if (RegOpenKeyEx(hKeyUser, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
                                 0, KEY_READ | KEY_WRITE, &hkeySF) == ERROR_SUCCESS)
                {
                    if (pszWritePath)
                    {
                        RegSetValueEx(hkeySF, pfi->pszValueName, 0, REG_SZ,
                                      (LPBYTE)szExpandedPath, (lstrlen(szExpandedPath) + 1) * sizeof(TCHAR));
                    }
                    else
                    {
                        RegDeleteValue(hkeySF, pfi->pszValueName);
                    }

                    RegCloseKey(hkeySF);
                }
            }

            if ((lError == ERROR_SUCCESS) && (pfi->hKey == HKEY_CURRENT_USER))
            {
                switch (csidl & ~CSIDL_FLAG_MASK)
                {
                case CSIDL_APPDATA:
                    {
                        HKEY    hKeyVolatileEnvironment;

                        // In the case of AppData there is a matching environment variable
                        // for this shell folder. Make sure the place in the registry where
                        // userenv.dll places this value is updated and correct so that when
                        // the user context is created by winlogon it will have the updated
                        // value.

                        // It's probably also a good thing to check for a %APPDATA% variable
                        // in the calling process' context but this would only be good for
                        // the life of the process. What is really required is a mechanism
                        // to change the environment variable for the entire logon session.

                        lError = RegOpenKeyEx(hKeyUser, TEXT("Volatile Environment"), 0,
                                              KEY_READ | KEY_WRITE, &hKeyVolatileEnvironment);
                        if (lError == ERROR_SUCCESS)
                        {
                            if (SUCCEEDED(SHGetFolderPath(NULL, csidl | CSIDL_FLAG_DONT_VERIFY,
                                                          hToken, SHGFP_TYPE_CURRENT, szPath)))
                            {
                                lError = RegSetValueEx(hKeyVolatileEnvironment, TEXT("APPDATA"),
                                                       0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
                            }
                            RegCloseKey(hKeyVolatileEnvironment);
                        }
                        break;
                    }
                }
            }

            if (hKeyToFree)
            {
                RegCloseKey(hKeyToFree);
            }

            if (lError == ERROR_SUCCESS)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lError);
            }
        }
        if (hTokenToFree)
        {
            CloseHandle(hTokenToFree);
        }

        SHChangeDWORDAsIDList dwidl = { sizeof(dwidl) - sizeof(dwidl.cbZero), SHCNEE_UPDATEFOLDERLOCATION, csidl & ~CSIDL_FLAG_MASK, 0};
        SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_ONLYNOTIFYINTERNALS | SHCNF_IDLIST, (LPCITEMIDLIST)&dwidl, NULL);
    }

    return hr;
}

STDAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwType, LPCSTR pszPath)
{
    WCHAR wsz[MAX_PATH];

    SHAnsiToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
    return SHSetFolderPath(csidl, hToken, dwType, wsz);
}

// NOTE: called from DllEntry

void SpecialFolderIDTerminate()
{
    ASSERTDLLENTRY      // does not require a critical section

    _ClearAllCacheEntrys();

    if (g_hCounter)
    {
        CloseHandle(g_hCounter);
        g_hCounter = NULL;
    }
}

// update our cache and the registry for pfi with pszPath. this also invalidates the
// cache in other processes so they stay in sync

void SetFolderPath(const FOLDER_INFO *pfi, LPCTSTR pszPath)
{
    _ClearCacheEntry(pfi);
    
    if (pszPath)
    {
        HKEY hk;
        if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, TEXT("User Shell Folders"), &hk)))
        {
            LONG err;
            TCHAR szDefaultPath[MAX_PATH];
            
            // Check for an existing path, and if the unexpanded version
            // of the existing path does not match the new path, then
            // write the new path to the registry.
            //
            // RegQueryPath expands the environment variables for us
            // so we can't just blindly set the new value to the registry.
            //
            
            RegQueryPath(hk, pfi->pszValueName, szDefaultPath, ARRAYSIZE(szDefaultPath));
            
            if (lstrcmpi(szDefaultPath, pszPath) != 0)
            {
                // The paths are different. Write to the registry as file
                // system path.

                err = SHRegSetPath(hk, NULL, pfi->pszValueName, pszPath, 0);
            } 
            else
            {
                err = ERROR_SUCCESS;
            }
            
            // clear out any temp paths
            RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), NULL);
            
            if (err == ERROR_SUCCESS)
            {
                // this will force a new creation (see TRUE as fCreate).
                // This will also copy the path from "User Shell Folders"
                // to "Shell Folders".
                LPITEMIDLIST pidl;
                if (S_OK == _GetFolderIDListCached(NULL, pfi, CSIDL_FLAG_CREATE, &pidl))
                {
                    ILFree(pidl);
                }
                else
                {
                    // failed!  null out the entry.  this will go back to our default
                    RegDeleteValue(hk, pfi->pszValueName);
                    _ClearCacheEntry(pfi);
                }
            }
            RegCloseKey(hk);
        }
    }
    else
    {
        RegSetFolderPath(pfi, TEXT("User Shell Folders"), NULL);
        // clear out any temp paths
        RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), NULL);
    }
    
    // set the global different from the per process variable
    // to signal an update needs to happen other processes
    g_lPerProcessCount = SHGlobalCounterIncrement(g_hCounter);
}


// file system change notifies come in here AFTER the folders have been moved/deleted
// we fix up the registry to match what occured in the file system
EXTERN_C void SFP_FSEvent(LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
    const FOLDER_INFO *pfi;
    TCHAR szSrc[MAX_PATH];

    if (!(lEvent & (SHCNE_RENAMEFOLDER | SHCNE_RMDIR | SHCNE_MKDIR)) ||
        !SHGetPathFromIDList(pidl, szSrc)                            ||
        (pidlExtra && ILIsEqual(pidl, pidlExtra)))  // when volume label changes, pidl==pidlExtra so we detect this case and skip it for perf
    {
        return;
    }

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (0 == (pfi->dwFlags & (SDIF_NOT_TRACKED | SDIF_NOT_FILESYS)))
        {
            TCHAR szCurrent[MAX_PATH];
            if (S_OK == _GetFolderPathCached(NULL, pfi, NULL, CSIDL_FLAG_DONT_VERIFY, szCurrent, ARRAYSIZE(szCurrent)) &&
                PathIsEqualOrSubFolder(szSrc, szCurrent))
            {
                TCHAR szDest[MAX_PATH];

                szDest[0] = 0;

                if (lEvent & SHCNE_RMDIR)
                {
                    // complete the "move accross volume" case
                    HKEY hk;
                    if (SUCCEEDED(_OpenKeyForFolder(pfi, NULL, TEXT("User Shell Folders\\New"), &hk)))
                    {
                        RegQueryPath(hk, pfi->pszValueName, szDest, ARRAYSIZE(szDest));
                        RegCloseKey(hk);
                    }
                }
                else if (pidlExtra)
                {
                    SHGetPathFromIDList(pidlExtra, szDest);
                }

                if (szDest[0])
                {
                    // rename the specal folder
                    UINT cch = PathCommonPrefix(szCurrent, szSrc, NULL);
                    ASSERT(cch != 0);
                    
                    if (szCurrent[cch])
                    {
                        if (PathAppend(szDest, szCurrent + cch))
                            SetFolderPath(pfi, szDest);
                    }
                    else
                    {
                        SetFolderPath(pfi, szDest);
                    }
                }
            }
        }
    }
}

ULONG _ILGetChildOffset(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    DWORD cbOff = 0;
    LPCITEMIDLIST pidlChildT = ILFindChild(pidlParent, pidlChild);
    if (pidlChildT)
    {
        cbOff = (ULONG)((LPBYTE)pidlChildT - (LPBYTE)pidlChild);
    }
    return cbOff;
}

// returns the first special folder CSIDL_ id that is a parent
// of the passed in pidl or 0 if not found. only CSIDL_ entries marked as
// SDIF_SHORTCUT_RELATIVE are considered for this.
//
// returns:
//      CSIDL_ values
//      *pcbOffset  offset into pidl

STDAPI_(int) GetSpecialFolderParentIDAndOffset(LPCITEMIDLIST pidl, ULONG *pcbOffset)
{
    int iRet = 0;  //  everything is desktop relative
    const FOLDER_INFO *pfi;

    *pcbOffset = 0;

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->dwFlags & SDIF_SHORTCUT_RELATIVE)
        {
            LPITEMIDLIST pidlFolder;
            if (S_OK == _GetFolderIDListCached(NULL, pfi, 0, &pidlFolder))
            {
                ULONG cbOff = _ILGetChildOffset(pidlFolder, pidl);
                if (cbOff > *pcbOffset)
                {
                    *pcbOffset = cbOff;
                    iRet = pfi->id;
                }
                ILFree(pidlFolder);
            }
        }
    }
    return iRet;
}

// note, only works for file system path (bummer, we would like others supported too)

STDAPI_(BOOL) MakeShellURLFromPath(LPCTSTR pszPathIn, LPTSTR pszUrl, DWORD dwCch)
{
    const FOLDER_INFO *pfi;

    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if ((pfi->dwFlags & SDIF_SHORTCUT_RELATIVE) &&
            !(pfi->dwFlags & SDIF_NOT_FILESYS))
        {
            TCHAR szCurrent[MAX_PATH];
            if (S_OK == _GetFolderPathCached(NULL, pfi, 0, CSIDL_FLAG_DONT_VERIFY, szCurrent, ARRAYSIZE(szCurrent)))
            {
                if (PathIsPrefix(szCurrent, pszPathIn))
                {
                    StrCpyN(pszUrl, TEXT("shell:"), dwCch);
                    StrCatBuff(pszUrl, pfi->pszValueName, dwCch);
                    if ((dwCch >= MAX_PATH) && PathAppend(pszUrl, &pszPathIn[lstrlen(szCurrent)]))
                    {
                        return TRUE;
                    }
                }
            }
        }
    }
    return FALSE;
}

STDAPI_(BOOL) MakeShellURLFromPathA(LPCSTR pszPathIn, LPSTR pszUrl, DWORD dwCch)
{
    WCHAR szTmp1[MAX_PATH], szTmp2[MAX_PATH];
    SHAnsiToUnicode(pszPathIn, szTmp1, ARRAYSIZE(szTmp1));

    BOOL bRet = MakeShellURLFromPathW(szTmp1, szTmp2, ARRAYSIZE(szTmp2));

    SHUnicodeToAnsi(szTmp2, pszUrl, dwCch);
    return bRet;
}

BOOL MoveBlockedByPolicy(const FOLDER_INFO *pfi)
{
    BOOL bRet = FALSE;
    if (pfi->dwFlags & SDIF_POLICY_NO_MOVE)
    {
        // similar to code in mydocs.dll 
        TCHAR szValue[128];
        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("Disable%sDirChange"), pfi->pszValueName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                                            szValue, NULL, NULL, NULL))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}

// this is called from the copy engine (like all other copy hooks)
// this is where we put up UI blocking the delete/move of some special folders
EXTERN_C int PathCopyHookCallback(HWND hwnd, UINT wFunc, LPCTSTR pszSrc, LPCTSTR pszDest)
{
    int ret = IDYES;

    if ((wFunc == FO_DELETE) || (wFunc == FO_MOVE) || (wFunc == FO_RENAME))
    {
        const FOLDER_INFO *pfi;

        // is one of our system directories being affected?

        for (pfi = c_rgFolderInfo; ret == IDYES && pfi->id != -1; pfi++)
        {
            // even non tracked folders (windows, system) come through here
            if (0 == (pfi->dwFlags & SDIF_NOT_FILESYS))
            {
                TCHAR szCurrent[MAX_PATH];
                if (S_OK == _GetFolderPathCached(NULL, pfi, NULL, CSIDL_FLAG_DONT_VERIFY, szCurrent, ARRAYSIZE(szCurrent)) &&
                    PathIsEqualOrSubFolder(pszSrc, szCurrent))
                {
                    // Yes
                    if (wFunc == FO_DELETE)
                    {
                        if (pfi->dwFlags & SDIF_CAN_DELETE)
                        {
                            SetFolderPath(pfi, NULL);  // Let them delete some folders
                        }
                        else
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTDELETESPECIALDIR),
                                            MAKEINTRESOURCE(IDS_DELETE), MB_OK | MB_ICONINFORMATION, PathFindFileName(pszSrc));
                            ret = IDNO;
                        }
                    }
                    else
                    {
                        int idSrc = PathGetDriveNumber(pszSrc);
                        int idDest = PathGetDriveNumber(pszDest);

                        ASSERT((wFunc == FO_MOVE) || (wFunc == FO_RENAME));

                        if ((pfi->dwFlags & SDIF_CANT_MOVE_RENAME) || 
                            ((idSrc != -1) && (idDest == -1) && !(pfi->dwFlags & SDIF_NETWORKABLE)) ||
                            ((idSrc != idDest) && PathIsRemovable(pszDest) && !(pfi->dwFlags & SDIF_REMOVABLE)) ||
                            MoveBlockedByPolicy(pfi))
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CANTMOVESPECIALDIRHERE),
                                wFunc == FO_MOVE ? MAKEINTRESOURCE(IDS_MOVE) : MAKEINTRESOURCE(IDS_RENAME), 
                                MB_ICONERROR, PathFindFileName(pszSrc));
                            ret = IDNO;
                        }
                        else
                        {
                            //
                            //  store this info here
                            //  if we need it we will use it.
                            //
                            //  we used to try to optimise in the case of same
                            //  volume renames.  we assumed that if it was the same
                            //  volume we would later get a SHCNE_RENAME.  but sometimes
                            //  we have to do a copy even on the same volume.  so
                            //  we need to always set this value.
                            //
                            RegSetFolderPath(pfi, TEXT("User Shell Folders\\New"), pszDest);
                        }
                    }
                }
            }
        }
    }
    return ret;
}

// Given a key name ("programs", "desktop", "start menu"), convert it to
// the corresponding CSIDL.

STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName)
{
    // make sure g_aFolderCache can be indexed by the CSIDL values

    COMPILETIME_ASSERT((ARRAYSIZE(g_aFolderCache) - 1) == CSIDL_COMPUTERSNEARME);

    for (int i = 0; c_rgFolderInfo[i].id != -1; i++)
    {
        if (c_rgFolderInfo[i].pszValueName && 
            (0 == StrCmpI(pszName, c_rgFolderInfo[i].pszValueName)))
        {
            return c_rgFolderInfo[i].id;
        }
    }

    return -1;
}

// Return the special folder ID, if this folder is one of them.
// At this point, we handle PROGRAMS folder only.

//
//  GetSpecialFolderID() 
//  this allows a list of CSIDLs to be passed in.
//  they will be searched in order for the specified csidl
//  and the path will be checked against it.
//  if -1 is specified as the csidl, then all of array entries should
//  be checked for a match with the folder.
//
int GetSpecialFolderID(LPCTSTR pszFolder, const int *rgcsidl, UINT count)
{
    for (UINT i = 0; i < count; i++)
    {
        int csidlSpecial = rgcsidl[i] & ~TEST_SUBFOLDER;
        TCHAR szPath[MAX_PATH];
        if (S_OK == SHGetFolderPath(NULL, csidlSpecial | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath))
        {
            if (((rgcsidl[i] & TEST_SUBFOLDER) && PathIsEqualOrSubFolder(szPath, pszFolder)) ||
                (lstrcmpi(szPath, pszFolder) == 0))
            {
                return csidlSpecial;
            }
        }
    }

    return -1;
}



/**
 *  Tacks a name onto a CSIDL, e.g. gets a pidl for
 *  CSIDL_COMMON_PICTURES\Sample Pictures
 *  if it exists.
 *  Called must free ppidlSampleMedia
 *  Note: The folder is *not* created if it does not exist.
 */
HRESULT _AppendPathToPIDL(int nAllUsersMediaFolder, LPCWSTR pszName, LPITEMIDLIST *ppidlSampleMedia)
{
    LPITEMIDLIST pidlAllUsersMedia;
    HRESULT hr = SHGetFolderLocation(NULL, nAllUsersMediaFolder, NULL, 0, &pidlAllUsersMedia);

    if (SUCCEEDED(hr))
    {
        // Get the shellfolder for this guy.
        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlAllUsersMedia, &psf));
        if (SUCCEEDED(hr))
        {
            // And now the pidl for the sample folder
            LPITEMIDLIST pidlSampleMediaRel;
            ULONG dwAttributes = 0;
            hr = psf->ParseDisplayName(NULL, NULL, (LPOLESTR)pszName, NULL, &pidlSampleMediaRel, &dwAttributes);
            if (SUCCEEDED(hr))
            {
                // It exists!
                hr = SHILCombine(pidlAllUsersMedia, pidlSampleMediaRel, ppidlSampleMedia);
                ILFree(pidlSampleMediaRel);
            }
            psf->Release();
        }
        ILFree(pidlAllUsersMedia);
    }

    return hr;
}


/**
 * Returns a pidl to the samples folder under a particular CSIDL
 * Caller must free ppidlSampleMedia
 */
HRESULT _ParseSubfolderResource(int csidl, UINT ids, LPITEMIDLIST *ppidl)
{
    WCHAR szSub[MAX_PATH];
    LoadDefaultString(ids, szSub, ARRAYSIZE(szSub));

    return _AppendPathToPIDL(csidl, szSub, ppidl);
}

HRESULT SHGetSampleMediaFolder(int nAllUsersMediaFolder, LPITEMIDLIST *ppidlSampleMedia)
{
    UINT uID = -1;
    switch (nAllUsersMediaFolder)
    {
    case CSIDL_COMMON_PICTURES:
        uID = IDS_SAMPLEPICTURES;
        break;
    case CSIDL_COMMON_MUSIC:
        uID = IDS_SAMPLEMUSIC;
        break;
    default:
        ASSERT(FALSE);
        return E_INVALIDARG;
        break;
    }
    return _ParseSubfolderResource(nAllUsersMediaFolder, uID, ppidlSampleMedia);
}

void _CreateLinkToSampleMedia(LPCWSTR pszNewFolderPath, int nAllUsersMediaFolder, UINT uIDSampleFolderName)
{
    if (!IsOS(OS_DOMAINMEMBER))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSampleMediaFolder(nAllUsersMediaFolder, &pidl)))
        {
            // Check to make sure the link doesn't already exist.
            WCHAR szSampleFolderName[MAX_PATH];
            WCHAR szFullLnkPath[MAX_PATH];
            LoadString(HINST_THISDLL, uIDSampleFolderName, szSampleFolderName, ARRAYSIZE(szSampleFolderName));
            StrCatBuff(szSampleFolderName, L".lnk", ARRAYSIZE(szSampleFolderName));
            if (PathCombine(szFullLnkPath, pszNewFolderPath, szSampleFolderName))
            {
                if (!PathFileExists(szFullLnkPath))
                {
                    //  MUI-WARNING - we are not doing a SHSetLocalizedName for this link - ZekeL - 15-MAY-2001
                    //  this means that this link is always created in the default system UI language
                    //  we should probably call SHSetLocalizedName() here but i am scared right now of perf implications.
                    CreateLinkToPidl(pidl, pszNewFolderPath, NULL, 0);
                }
            }

            ILFree(pidl);
        }
    }
}


void _InitFolder(LPCTSTR pszPath, UINT idsInfoTip, HINSTANCE hinstIcon, UINT idiIcon)
{
    // Set the default custom settings for the folder.
    SHFOLDERCUSTOMSETTINGS fcs = {sizeof(fcs), 0};
    TCHAR szInfoTip[128];
    TCHAR szPath[MAX_PATH];

    // Get the infotip for this folder
    if (idsInfoTip)
    {
        wnsprintf(szInfoTip,ARRAYSIZE(szInfoTip),TEXT("@Shell32.dll,-%u"),idsInfoTip);
        fcs.pszInfoTip = szInfoTip;
        fcs.cchInfoTip = ARRAYSIZE(szInfoTip);

        fcs.dwMask |= FCSM_INFOTIP;
    }

    // this will be encoded to the %SystemRoot% style path when setting the folder information.
    if (idiIcon)
    {
        GetModuleFileName(hinstIcon, szPath, ARRAYSIZE(szPath));

        fcs.pszIconFile = szPath;
        fcs.cchIconFile = ARRAYSIZE(szPath);
        fcs.iIconIndex = idiIcon;

        fcs.dwMask |= FCSM_ICONFILE;
    }

    // NOTE: we need FCS_FORCEWRITE because we didn't used to specify iIconIndex
    // and so "0" was written to the ini file.  When we upgrade, this API won't
    // fix the ini file unless we pass FCS_FORCEWRITE

    SHGetSetFolderCustomSettings(&fcs, pszPath, FCS_FORCEWRITE);
}

void _InitMyPictures(int id, LPCTSTR pszPath)
{
    // Get the path to the icon.   We reference MyDocs.dll for backwards compat.
    HINSTANCE hinstMyDocs = LoadLibrary(TEXT("mydocs.dll"));
    if (hinstMyDocs)
    {
        _InitFolder(pszPath, IDS_FOLDER_MYPICS_TT, hinstMyDocs, -101); // known index for IDI_MYPICS in mydocs.dll
        FreeLibrary(hinstMyDocs);
    }
}

void _InitMyMusic(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_MYMUSIC_TT, HINST_THISDLL, -IDI_MYMUSIC);
}

void _InitPerUserMyPictures(int id, LPCTSTR pszPath)
{
    _InitMyPictures(id, pszPath);
    _CreateLinkToSampleMedia(pszPath, CSIDL_COMMON_PICTURES, IDS_SAMPLEPICTURES);
}

void _InitPerUserMyMusic(int id, LPCTSTR pszPath)
{
    _InitMyMusic(id, pszPath);
    _CreateLinkToSampleMedia(pszPath, CSIDL_COMMON_MUSIC, IDS_SAMPLEMUSIC);
}


void _InitMyVideos(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_MYVIDEOS_TT, HINST_THISDLL, -IDI_MYVIDEOS);
}

void _InitRecentDocs(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, IDS_FOLDER_RECENTDOCS_TT, HINST_THISDLL, -IDI_STDOCS); 
}

void _InitFavorites(int id, LPCTSTR pszPath)
{
    _InitFolder(pszPath, 0, HINST_THISDLL, -IDI_FAVORITES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\folderthumb.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include "ids.h"
#include "prop.h"
#include "copy.h"

// If these values are modified, the logic in Extract() must be modified too.
#define SMALLEST_THUMBNAIL_WITH_4_PREVIEWS 96
#define MAX_MINIPREVIEWS_COLLECT 8 // collect more than we're going to show, just in case one fails
#define MAX_MINIPREVIEWS 4

#define FOLDER_GUID TEXT("{A42CD7B6-E9B9-4D02-B7A6-288B71AD28BA}")

// Function in defview
void SHGetThumbnailSize(SIZE *psize);

typedef enum
{
    MINIPREVIEW_LAYOUT_1 = 0,
    MINIPREVIEW_LAYOUT_4 = 1,
} MINIPREVIEW_LAYOUT;

// The size of the mini-thumbnails for each thumbnail size. For each thumbnail
// size, there is a mini-thumbnail size for single layout and 2x2 layout.
LONG const alFolder120MinipreviewSize[] = {104, 48};
LONG const alFolder96MinipreviewSize[] = {82, 40};
LONG const alFolder80MinipreviewSize[] = {69, 32};

// These are the margins at which the mini-thumbnails appear within the main thumbnail.
// For thumbnails with only one large minipreview, we can just use x1,y1.
LONG const alFolder120MinipreviewOffsets[] = { 8, 64, 13, 67 }; // x1, x2, y1, y2
LONG const alFolder96MinipreviewOffsets[]  = { 7, 49, 11, 52 }; // x1, x2, y1, y2
LONG const alFolder80MinipreviewOffsets[]  = { 5, 42, 9,  45 }; // x1, x2, y1, y2


void FreeMiniPreviewPidls(LPITEMIDLIST apidlPreviews[], UINT cpidlPreviews);

// Helper functions
MINIPREVIEW_LAYOUT _GetMiniPreviewLayout(SIZE size);
void _GetMiniPreviewLocations(MINIPREVIEW_LAYOUT uLayout, SIZE sizeRequested, SIZE *psizeFolderBmp,
                                              POINT aptOrigins[], SIZE *psizeMiniPreview);
HRESULT _DrawMiniPreviewBackground(HDC hdc, SIZE sizeFolderBmp, BOOL fAlpha, BOOL* pIsAlpha, RGBQUAD *prgb);
HBITMAP _CreateDIBSection(HDC hdcBmp, int cx, int cy);
HRESULT _CreateMainRenderingDC(HDC* phdc, HBITMAP* phBmpThumbnail, HBITMAP* phbmpOld, int cx, int cy, RGBQUAD** pprgb);
void  _DestroyMainRenderingDC(HDC hdc, HBITMAP hbmpOld);
HRESULT _AddBitmap(HDC hdc, HBITMAP hbmpSub, POINT ptMargin, SIZE sizeDest, SIZE sizeSource, BOOL fAlphaSource, BOOL fAlphaDest, RGBQUAD *prgbDest, SIZE cxFolderSize);

// The files that can serve as thumbnails for folders:
const LPCWSTR c_szFolderThumbnailPaths[] = { L"folder.jpg", L"folder.gif" };

// We always have four now.
MINIPREVIEW_LAYOUT _GetMiniPreviewLayout(SIZE size)
{
    return MINIPREVIEW_LAYOUT_4;
}


void FreeMiniPreviewPidls(LPITEMIDLIST apidlPreviews[], UINT cpidlPreviews)
{
    for (UINT u = 0; u < cpidlPreviews; u++)
    {
        ILFree(apidlPreviews[u]);
    }
}


/**
 * In: uLayout - The layout (1 or 4 mini previews)
 *     sizeRequested - The size of the thumbnail we are trying to generate 
 *
 * Out:
 * -psizeFolderBmp is set to
 * the size of the bitmap.
 *
 * -aptOrigins array is filled in with the locations of the n minipreviews
 * (note, aptOrigins is assumed to have MAX_MINIPREVIEWS cells)
 * The size of the minipreviews (square) is returned in pSizeMinipreview;
 */
void _GetMiniPreviewLocations(MINIPREVIEW_LAYOUT uLayout, SIZE sizeRequested, SIZE *psizeFolderBmp, 
                                              POINT aptOrigins[], SIZE *psizeMiniPreview)
{

    const LONG *alOffsets;
    LONG lSize; // One of the standard sizes, that we have a folder bitmap for.
    LONG lSmallestDimension = min(sizeRequested.cx, sizeRequested.cy);

    if (lSmallestDimension > 96) // For stuff bigger than 96, we use the 120 size
    {
        lSize = 120;
        alOffsets = alFolder120MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder120MinipreviewSize[uLayout];
    }
    else if (lSmallestDimension > 80) // For stuff bigger than 80, but <= 96, we use the 96 size.
    {
        lSize = 96;
        alOffsets = alFolder96MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder96MinipreviewSize[uLayout];
    }
    else // For stuff <= 80, we use 80.
    {
        lSize = 80;
        alOffsets = alFolder80MinipreviewOffsets;
        psizeMiniPreview->cx = psizeMiniPreview->cy = alFolder80MinipreviewSize[uLayout];
    }

    psizeFolderBmp->cx = psizeFolderBmp->cy = lSize;

    COMPILETIME_ASSERT(4 == MAX_MINIPREVIEWS);

    aptOrigins[0].x = alOffsets[0];
    aptOrigins[0].y = alOffsets[2];
    aptOrigins[1].x = alOffsets[1];
    aptOrigins[1].y = alOffsets[2];
    aptOrigins[2].x = alOffsets[0];
    aptOrigins[2].y = alOffsets[3];
    aptOrigins[3].x = alOffsets[1];
    aptOrigins[3].y = alOffsets[3];
}

HBITMAP _CreateDIBSection(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

// Pre multiplies alpha channel
void PreProcessDIB(int cx, int cy, RGBQUAD* pargb)
{
    int cTotal = cx * cy;
    for (int i = 0; i < cTotal; i++)
    {
        RGBQUAD* prgb = &pargb[i];
        if (prgb->rgbReserved != 0)
        {
            prgb->rgbRed      = ((prgb->rgbRed   * prgb->rgbReserved) + 128) / 255;
            prgb->rgbGreen    = ((prgb->rgbGreen * prgb->rgbReserved) + 128) / 255;
            prgb->rgbBlue     = ((prgb->rgbBlue  * prgb->rgbReserved) + 128) / 255;
        }
        else
        {
            *((DWORD*)prgb) = 0;
        }
    }
}

// Is there an alpha channel?  Check for a non-zero alpha byte.
BOOL _HasAlpha(RECT rc, int cx, RGBQUAD *pargb)
{
    for (int y = rc.top; y < rc.bottom; y++)
    {
        for (int x = rc.left; x < rc.right; x++)
        {
            int iOffset = y * cx;
            if (pargb[x + iOffset].rgbReserved != 0)
                return TRUE;
        }
    }

    return FALSE;
}


/** In:
 *   fAlpha: Do we want the folder background to have an alpha channel?
 *   sizeFolderBmp: size of the thumbnail
 *
 *  Out:
 *   pIsAlpha: Did we get what we wanted, if we wanted an alpha channel?
 *             (e.g. we won't get it if we're in < 24bit mode.)
 */
HRESULT _DrawMiniPreviewBackground(HDC hdc, SIZE sizeFolderBmp, BOOL fAlpha, BOOL* pfIsAlpha, RGBQUAD *prgb)
{
    HRESULT hr = E_FAIL;

    HICON hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_FOLDER), IMAGE_ICON, sizeFolderBmp.cx, sizeFolderBmp.cy, 0);

    if (hicon)
    {
        *pfIsAlpha = FALSE;
        if (fAlpha)
        {
            // Try to blt an alpha channel icon into the dc
            ICONINFO io;
            if (GetIconInfo(hicon, &io))
            {
                BITMAP bm;
                if (GetObject(io.hbmColor, sizeof(bm), &bm))
                {
                    if (bm.bmBitsPixel == 32)
                    {
                        HDC hdcSrc = CreateCompatibleDC(hdc);
                        if (hdcSrc)
                        {
                            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcSrc, io.hbmColor);

                            BitBlt(hdc, 0, 0, sizeFolderBmp.cx, sizeFolderBmp.cy, hdcSrc, 0, 0, SRCCOPY);

                            // Preprocess the alpha
                            PreProcessDIB(sizeFolderBmp.cx, sizeFolderBmp.cy, prgb);

                            *pfIsAlpha = TRUE;
                            SelectObject(hdcSrc, hbmpOld);
                            DeleteDC(hdcSrc);
                        }   
                    }
                }

                DeleteObject(io.hbmColor);
                DeleteObject(io.hbmMask);
            }
        }

        if (!*pfIsAlpha)
        {
            // Didn't create an alpha bitmap
            // We're filling the background with background window color.
            RECT rc = { 0, 0, (long)sizeFolderBmp.cx + 1, (long)sizeFolderBmp.cy + 1};
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_WINDOW));

            // Then drawing the icon on top.
            DrawIconEx(hdc, 0, 0, hicon, sizeFolderBmp.cx, sizeFolderBmp.cy, 0, NULL, DI_NORMAL);

            // This may have resulted in an alpha channel - we need to know.  (If it
            // did, then when we add a nonalpha minibitmap to this main one, we need to restore
            // the nuked out alpha channel)
            // Check if we have alpha (prgb is the bits for the DIB of size sizeFolderBmp):
            rc.right = sizeFolderBmp.cx;
            rc.bottom = sizeFolderBmp.cy;
            *pfIsAlpha = _HasAlpha(rc, sizeFolderBmp.cx, prgb);
        }

        DestroyIcon(hicon);
        hr = S_OK;
    }

    return hr;
}

BOOL DoesFolderContainLogo(LPCITEMIDLIST pidlFull)
{
    BOOL bRet = FALSE;
    IPropertyBag * pPropBag;
    if (SUCCEEDED(SHGetViewStatePropertyBag(pidlFull, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &pPropBag))))
    {
        TCHAR szLogo[MAX_PATH]; 
        szLogo[0] = 0; 
        if (SUCCEEDED(SHPropertyBag_ReadStr(pPropBag, TEXT("Logo"), szLogo, ARRAYSIZE(szLogo))) && szLogo[0])
        {
            bRet = TRUE;
        }
        pPropBag->Release();
    }
    return bRet;
}

BOOL DoesFolderContainFolderJPG(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    // return false if there's not folder.jpg, or if folder.jpg is a folder (doh!)
    IShellFolder *psfSubfolder;

    // SHBTO can deal with NULL psf, he turns it into psfDesktop
    if (SUCCEEDED(SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfSubfolder))))
    {
        for (int i = 0; i < ARRAYSIZE(c_szFolderThumbnailPaths); i++)
        {
            DWORD dwFlags = SFGAO_FILESYSTEM | SFGAO_FOLDER;
            LPITEMIDLIST pidlItem;
            if (SUCCEEDED(psfSubfolder->ParseDisplayName(NULL, NULL, (LPOLESTR)c_szFolderThumbnailPaths[i], NULL, &pidlItem, &dwFlags)))
            {
                ILFree(pidlItem);
                if ((dwFlags & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM)
                {
                    bRet = TRUE;
                    break;
                }
            }
        }
        psfSubfolder->Release();
    }

    return bRet;
}

BOOL _IsShortcutTargetACandidate(IShellFolder *psf, LPCITEMIDLIST pidlPreview, BOOL *pbTryCached)
{
    BOOL bRet = FALSE;
    *pbTryCached = TRUE;
    IShellLink *psl;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlPreview, IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        LPITEMIDLIST pidlTarget = NULL;
        if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
        {
            DWORD dwTargetFlags = SFGAO_FOLDER;
            if (SUCCEEDED(SHGetNameAndFlags(pidlTarget, 0, NULL, 0, &dwTargetFlags)))
            {
                // return true if its not a folder, or if the folder contains a logo
                // note that this is kinda like recursing into the below function again
                bRet = (0 == (dwTargetFlags & SFGAO_FOLDER));
                
                if (!bRet)
                {
                    bRet = (DoesFolderContainLogo(pidlTarget) || DoesFolderContainFolderJPG(NULL, pidlTarget));
                    if (bRet)
                    {
                        // It's a logo folder, don't try the cached image.
                        *pbTryCached = FALSE;
                    }
                }
            }

            ILFree(pidlTarget);
        }
        psl->Release();
    }
    return bRet;
}


BOOL _IsMiniPreviewCandidate(IShellFolder *psf, LPCITEMIDLIST pidl, BOOL *pbTryCached)
{
    BOOL bRet = FALSE;
    DWORD dwAttr = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_LINK | SFGAO_FILESYSANCESTOR);
    *pbTryCached = TRUE; 

    // if its a folder, check and see if its got a logo
    // note that folder shortcuts will have both folder and link, and since we check folder first, we won't recurse into folder shortcuts
    // dont do anything unless pidl is a folder on a real filesystem (i.e. dont walk into zip/cab)
    if ((dwAttr & (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR)) == (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR))
    {
        LPITEMIDLIST pidlParent;
        if (SUCCEEDED(SHGetIDListFromUnk(psf, &pidlParent)))
        {
            LPITEMIDLIST pidlFull;
            if (SUCCEEDED(SHILCombine(pidlParent, pidl, &pidlFull)))
            {
                bRet = DoesFolderContainLogo(pidlFull);
                ILFree(pidlFull);
            }
            ILFree(pidlParent);
        }

        if (!bRet)
        {
            // no logo image, check for a "folder.jpg"
            // if its not there, then don't display pidl as a mini-preview, as it would recurse and produce dumb-looking 1/16 scale previews 
            bRet = DoesFolderContainFolderJPG(psf, pidl);
        }

        if (bRet)
        {
            // For logo folders, we don't look for a cached image (cached image won't have alpha, which we want)
            *pbTryCached = FALSE;
        }
    }
    else 
    {
        // Only if its not a link, or if its a link to a valid candidate, then we can get its extractor
        if (0 == (dwAttr & SFGAO_LINK) || 
            _IsShortcutTargetACandidate(psf, pidl, pbTryCached))
        {
            IExtractImage *pei;
            if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractImage, NULL, &pei))))
            {
                bRet = TRUE;
                pei->Release();
            }
        }
    }
    return bRet;
}


// We return the bits to the dibsection in the dc, if asked for.  We need this for preprocessing the alpha channel,
// if one exists.
HRESULT _CreateMainRenderingDC(HDC* phdc, HBITMAP* phbmp, HBITMAP* phbmpOld, int cx, int cy, RGBQUAD** pprgb)
{
    HRESULT hr = E_OUTOFMEMORY;
    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        *phdc = CreateCompatibleDC(hdc);
        if (*phdc)
        {
            RGBQUAD *prgbDummy;
            *phbmp = _CreateDIBSection(*phdc, cx, cy, &prgbDummy); 
            if (*phbmp)
            {
                *phbmpOld = (HBITMAP) SelectObject(*phdc, *phbmp);
                if (pprgb)
                    *pprgb = prgbDummy;
                hr = S_OK;
            }
            else
            {
                DeleteDC(*phdc);
            }
        }
        ReleaseDC(NULL, hdc);
    }

    return hr;
}

void _DestroyMainRenderingDC(HDC hdc, HBITMAP hbmpOld)    // Unselects the bitmap, and deletes the Dc
{
    if (hbmpOld)
        SelectObject(hdc, hbmpOld);
    DeleteDC(hdc);
}

// We just blt'd a nonalpha guy into an alpha'd bitmap.  This nuked out the alpha channel.
// Repair it by setting alpha channel to 0xff (opaque).
void _SetAlpha(RECT rc, SIZE sizeBmp, RGBQUAD *pargb)
{
    for (int y = (sizeBmp.cy - rc.bottom); y < (sizeBmp.cy - rc.top); y++)  // Origin at bottom left.
    {
        int iOffset = y * sizeBmp.cx;
        for (int x = rc.left; x < rc.right; x++)
        {
            pargb[x + iOffset].rgbReserved = 0xff;
        }
    }
}

/**
 * In
 *  hbmpSub - little bitmap that we're adding to the thumbnail bitmap.
 *  ptMargin - where we're adding it on the destination thumbnail bitmap.
 *  sizeDest - how big it needs to be on the destination thumbnail bitmap.
 *  sizeSource - how bit it is.
 *  fAlphaSource - does the bitmap we're adding have an alpha channel?
 *  fAlphaDest - does what we're adding it to, have an alpha channel?
 *  prgbDest - the bits of the destination bitmap - needed if we add a non-alpha bitmap
 *             to an alpha background, so we can reset the alpha.
 *  sizeFolderBmp - the size of the destination bitmap - need this along with prgbDest.
 */
HRESULT _AddBitmap(HDC hdc, HBITMAP hbmpSub, POINT ptMargin, SIZE sizeDest, SIZE sizeSource, BOOL fAlphaSource, BOOL fAlphaDest, RGBQUAD *prgbDest, SIZE sizeFolderBmp)
{
    HRESULT hr = E_OUTOFMEMORY;

    HDC hdcFrom = CreateCompatibleDC(hdc);
    if (hdcFrom)
    {
        // Select the bitmap into the source hdc.
        HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcFrom, hbmpSub);
        if (hbmpOld)
        {
            // Adjust destination size to preserve aspect ratio
            SIZE sizeDestActual;
            if ((1000 * sizeDest.cx / sizeSource.cx) <      // 1000 -> float simulation
                (1000 * sizeDest.cy / sizeSource.cy))
            {
                // Keep destination width
                sizeDestActual.cy = sizeSource.cy * sizeDest.cx / sizeSource.cx;
                sizeDestActual.cx = sizeDest.cx;
                ptMargin.y += (sizeDest.cy - sizeDestActual.cy) / 2; // Center
            }
            else
            {
                // Keep destination height
                sizeDestActual.cx = sizeSource.cx * sizeDest.cy / sizeSource.cy;
                sizeDestActual.cy = sizeDest.cy;
                ptMargin.x += (sizeDest.cx - sizeDestActual.cx) / 2; // Center
            }

            // Now blt the image onto our folder background.
            // Three alpha possibilities:
            // Dest: no alpha, Src: no alpha -> the normal case
            // Dest: no alpha, Src: alpha -> one of the minipreviews is a logo-ized folder.
            // Dest: alpha, Src: no alpha -> we're a logoized folder being rendered as a minipreview in
            //                               the parent folder's thumbnail.

            // If we got back an alpha image, we need to alphablend it.
            if (fAlphaSource)
            {
                // We shouldn't have gotten back an alpha image, if we're alpha'd too.  That would imply we're
                // doing a minipreview of a minipreview (1/16 scale).
                //ASSERT(!fAlphaDest);
                BLENDFUNCTION bf;
                bf.BlendOp = AC_SRC_OVER;
                bf.SourceConstantAlpha = 255;
                bf.AlphaFormat = AC_SRC_ALPHA;
                bf.BlendFlags = 0;
                if (AlphaBlend(hdc, ptMargin.x, ptMargin.y, sizeDestActual.cx, sizeDestActual.cy, hdcFrom, 0 ,0, sizeSource.cx, sizeSource.cy, bf))
                    hr = S_OK;
            }
            else
            {
                // Otherwise, just blt it.
                int iModeSave = SetStretchBltMode(hdc, HALFTONE);
                if (StretchBlt(hdc, ptMargin.x, ptMargin.y, sizeDestActual.cx, sizeDestActual.cy, hdcFrom, 0 ,0, sizeSource.cx, sizeSource.cy, SRCCOPY))
                    hr = S_OK;
                SetStretchBltMode(hdc, iModeSave);

                // Are we alpha'd?  We didn't have an alpha source, so where we blt'd it, we've
                // lost the alpha channel.  Restore it.
                if (fAlphaDest)
                {
                    // Set the alpha channel over where we just blt'd.
                    RECT rc = {ptMargin.x, ptMargin.y, ptMargin.x + sizeDestActual.cx, ptMargin.y + sizeDestActual.cy};
                    _SetAlpha(rc, sizeFolderBmp, prgbDest);
                }
            }
            SelectObject(hdcFrom, hbmpOld);
        }
        DeleteDC(hdcFrom);
    }

    return hr;
}


class CFolderExtractImage : public IExtractImage2,
                            public IPersistPropertyBag,
                            public IAlphaThumbnailExtractor,
                            public IRunnableTask
{
public:
    CFolderExtractImage();
    
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // IExtractImage/IExtractLogo
    STDMETHOD (GetLocation)(LPWSTR pszPath, DWORD cch, DWORD *pdwPriority, const SIZE *prgSize, DWORD dwRecClrDepth, DWORD *pdwFlags);
 
    STDMETHOD (Extract)(HBITMAP *phbm);

    // IExtractImage2
    STDMETHOD (GetDateStamp)(FILETIME *pftDateStamp);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistPropertyBag
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pErr);
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return E_NOTIMPL; }

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)(void);
    STDMETHOD (Resume)(void);
    STDMETHOD_(ULONG, IsRunning)(void);

    // IAlphaThumbnailExtractor
    STDMETHOD (RequestAlphaThumbnail)(void);

    STDMETHOD(Init)(IShellFolder *psf, LPCITEMIDLIST pidl);
private:
    ~CFolderExtractImage();
    LPCTSTR _GetImagePath(UINT cx);
    HRESULT _CreateWithMiniPreviews(IShellFolder *psf, const LPCITEMIDLIST *apidlPreviews, BOOL *abTryCached, UINT cpidlPreviews, MINIPREVIEW_LAYOUT uLayout, IShellImageStore *pImageStore, HBITMAP *phBmpThumbnail);
    HRESULT _FindMiniPreviews(LPITEMIDLIST apidlPreviews[], BOOL abTryCached[], UINT *cpidlPreviews);
    HRESULT _CheckThumbnailCache(HBITMAP *phbmp);
    void _CacheThumbnail(HBITMAP hbmp);

    IExtractImage  *_pExtract;
    IRunnableTask  *_pRun;
    long            _cRef;
    TCHAR           _szFolder[MAX_PATH];
    TCHAR           _szLogo[MAX_PATH];
    TCHAR           _szWideLogo[MAX_PATH];
    IShellFolder2  *_psf;
    SIZE            _size;
    LPITEMIDLIST    _pidl;
    IPropertyBag   *_ppb;
    LONG            _lState;
    BOOL            _fAlpha;

    DWORD _dwPriority;
    DWORD _dwRecClrDepth;

    DWORD _dwExtractFlags;
};

STDAPI CFolderExtractImage_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFolderExtractImage *pfei = new CFolderExtractImage;
    if (pfei)
    {
        hr = pfei->Init(psf, pidl);
        if (SUCCEEDED(hr))
            hr = pfei->QueryInterface(riid, ppv);
        pfei->Release();
    }
    return hr;
}

CFolderExtractImage::CFolderExtractImage() : _cRef(1), _lState(IRTIR_TASK_NOT_RUNNING)
{
}

CFolderExtractImage::~CFolderExtractImage()
{
    ATOMICRELEASE(_pExtract);
    ATOMICRELEASE(_psf);
    ILFree(_pidl);
    ATOMICRELEASE(_ppb);
}

STDMETHODIMP CFolderExtractImage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT      (CFolderExtractImage, IExtractImage2),
        QITABENTMULTI (CFolderExtractImage, IExtractImage,         IExtractImage2),
        QITABENTMULTI2(CFolderExtractImage, IID_IExtractLogo,      IExtractImage2),
        QITABENT      (CFolderExtractImage, IPersistPropertyBag),
        QITABENT      (CFolderExtractImage, IRunnableTask),
        QITABENT      (CFolderExtractImage, IAlphaThumbnailExtractor),
        QITABENTMULTI (CFolderExtractImage, IPersist,              IPersistPropertyBag),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderExtractImage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderExtractImage::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFolderExtractImage::GetDateStamp(FILETIME *pftDateStamp)
{
    HANDLE h = CreateFile(_szFolder, GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                          OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    HRESULT hr = (h != INVALID_HANDLE_VALUE) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        hr = GetFileTime(h, NULL, NULL, pftDateStamp) ? S_OK : E_FAIL;
        CloseHandle(h);
    }
    return hr;
}

HRESULT CFolderExtractImage::InitNew()
{
    IPropertyBag *ppb;
    // load up the default property bag for peruser perfolder
    // may have problems down the line with thumbs.db being alluser.
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        IUnknown_Set((IUnknown**)&_ppb, ppb);
        ppb->Release();
    }
    // return success always -- SHGVSPB can fail if _pidl is on a removable drive,
    // but we still want to do our thing.
    return S_OK;
}

HRESULT CFolderExtractImage::Load(IPropertyBag *ppb, IErrorLog *pErr)
{
    IUnknown_Set((IUnknown**)&_ppb, ppb);
    return S_OK;
}

LPCTSTR CFolderExtractImage::_GetImagePath(UINT cx)
{
    if (!_szLogo[0])
    {
        if (_ppb && SUCCEEDED(SHPropertyBag_ReadStr(_ppb, TEXT("Logo"), _szLogo, ARRAYSIZE(_szLogo))) && _szLogo[0])
        {
            if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, TEXT("WideLogo"), _szWideLogo, ARRAYSIZE(_szWideLogo))) && _szWideLogo[0])
                if (!PathCombine(_szWideLogo, _szFolder, _szWideLogo))   // relative path support
                    ZeroMemory(_szWideLogo, sizeof(_szWideLogo));

            if (!PathCombine(_szLogo, _szFolder, _szLogo))   // relative path support
                ZeroMemory(_szLogo, sizeof(_szLogo));
        }
        else
        {
            TCHAR szFind[MAX_PATH];

            for (int i = 0; i < ARRAYSIZE(c_szFolderThumbnailPaths); i++)
            {
                if (PathCombine(szFind, _szFolder, c_szFolderThumbnailPaths[i]))
                {
                    if (PathFileExists(szFind))
                    {
                        if (SUCCEEDED(StringCchCopy(_szLogo, ARRAYSIZE(_szLogo), szFind)))
                        {
                            break;
                        }
                        else
                        {
                            ZeroMemory(_szLogo,(sizeof(_szLogo)));
                        }
                    }
                }
            }
        }
    }

    LPCTSTR psz = ((cx > 120) && _szWideLogo[0]) ? _szWideLogo : _szLogo;
    return *psz ? psz : NULL;
}

STDMETHODIMP CFolderExtractImage::RequestAlphaThumbnail()
{
    _fAlpha = TRUE;
    return S_OK;
}

STDMETHODIMP CFolderExtractImage::GetLocation(LPWSTR pszPath, DWORD cch,
                                              DWORD *pdwPriority, const SIZE *prgSize,
                                              DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr;

    hr = StringCchCopy(pszPath, cch, _szFolder);

    if (SUCCEEDED(hr))
    {
        _size = *prgSize;
        _dwRecClrDepth = dwRecClrDepth;
        _dwExtractFlags = *pdwFlags;

        if (pdwFlags)
        {
            if (*pdwFlags & IEIFLAG_ASYNC)
                hr = E_PENDING;

            *pdwFlags &= ~IEIFLAG_CACHE; // We handle the caching of this thumbnail inside the folder
            *pdwFlags |= IEIFLAG_REFRESH; // We still want to handle the refresh verb
        }

        if (pdwPriority)
        {
            _dwPriority = *pdwPriority;
            *pdwPriority = 1;   // very low
        }
    }

    return hr;
}

STDMETHODIMP CFolderExtractImage::Extract(HBITMAP *phbm)
{
    // Set it to running (only if we're in the not running state).
    LONG lResOld = InterlockedCompareExchange(&_lState, IRTIR_TASK_RUNNING, IRTIR_TASK_NOT_RUNNING);

    if (lResOld != IRTIR_TASK_NOT_RUNNING)
    {
        // If we weren't in the not running state, bail.
        return E_FAIL;
    }

    // If we have an extractor, use that.
    HRESULT hr = E_FAIL;
    hr = _CheckThumbnailCache(phbm);
    if (FAILED(hr))
    {
        LPITEMIDLIST apidlPreviews[MAX_MINIPREVIEWS_COLLECT];
        BOOL abTryCached[MAX_MINIPREVIEWS_COLLECT];
        UINT cpidlPreviews = 0;

        LPCTSTR pszLogo = _GetImagePath(_size.cx);
        if (pszLogo)
        {
            // Don't do the standard mini-previews - we've got a special thumbnail
            ATOMICRELEASE(_pExtract);

            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(pszLogo, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder* psfLogo;
                hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psfLogo), &pidlChild);
                if (SUCCEEDED(hr))
                {
                    hr = _CreateWithMiniPreviews(psfLogo, &pidlChild, NULL, 1, MINIPREVIEW_LAYOUT_1, NULL, phbm);
                    psfLogo->Release();
                }
                ILFree(pidl);
            }
        }
        else
        {
            const struct 
            {
                int csidl;
                int res;
            } 
            thumblist[] = 
            {
                {CSIDL_PERSONAL,           IDI_MYDOCS},
                {CSIDL_MYMUSIC,            IDI_MYMUSIC},
                {CSIDL_MYPICTURES,         IDI_MYPICS},
                {CSIDL_MYVIDEO,            IDI_MYVIDEOS},
                {CSIDL_COMMON_DOCUMENTS,   IDI_MYDOCS},
                {CSIDL_COMMON_MUSIC,       IDI_MYMUSIC},
                {CSIDL_COMMON_PICTURES,    IDI_MYPICS},
                {CSIDL_COMMON_VIDEO,       IDI_MYVIDEOS}
            };
            BOOL bFound = FALSE;

            for (int i=0; i < ARRAYSIZE(thumblist) && !bFound; i++)
            {
                TCHAR szPath[MAX_PATH];
                SHGetFolderPath(NULL, thumblist[i].csidl, NULL, 0, szPath);
                if (!lstrcmp(_szFolder, szPath))
                {
                    // We return failure in this case so that the requestor can do
                    // the default action.
                    hr = E_FAIL;
                    bFound = TRUE;
                }
            }

            if (!bFound)
            {
                // Mini-previews.
                IShellImageStore *pDiskCache = NULL;

                // It's ok if this fails.
                if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
                    !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE) &&
                    !(_dwExtractFlags & IEIFLAG_QUALITY))
                {
                    LoadFromFile(CLSID_ShellThumbnailDiskCache, _szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
                }

                cpidlPreviews = ARRAYSIZE(apidlPreviews);
                hr = _FindMiniPreviews(apidlPreviews, abTryCached, &cpidlPreviews);
                if (SUCCEEDED(hr))
                {
                    if (cpidlPreviews)
                    {
                        hr = _CreateWithMiniPreviews(_psf, apidlPreviews, abTryCached, cpidlPreviews, _GetMiniPreviewLayout(_size), pDiskCache, phbm);
                        FreeMiniPreviewPidls(apidlPreviews, cpidlPreviews);
                    }
                    else
                    {
                        // We return failure in this case so that the requestor can do
                        // the default action
                        hr = E_FAIL; 
                    }
                }

                ATOMICRELEASE(pDiskCache);
            }
        }

        if (SUCCEEDED(hr) && *phbm)
        {
            _CacheThumbnail(*phbm);
        }
    }

    return hr;
}

STDMETHODIMP CFolderExtractImage::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Init(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _szFolder, ARRAYSIZE(_szFolder));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFolder;
        hr = SHGetIDListFromUnk(psf, &pidlFolder);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine(pidlFolder, pidl, &_pidl);
            if (SUCCEEDED(hr))
            {
                // hold the _psf for this guy so we can enum
                hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder2, &_psf));
                if (SUCCEEDED(hr))
                {
                    hr = InitNew();
                }
            }
            ILFree(pidlFolder);
        }
    }
    return hr;
}

// Not necessary --- IExtractImage::Extract() starts us up.
STDMETHODIMP CFolderExtractImage::Run(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Kill(BOOL fWait)
{
    // Try to kill the current subextraction task that's running, if any.
    if (_pRun != NULL)
    {
        _pRun->Kill(fWait);
        // If it didn't work, no big deal, we'll complete this subextraction task,
        // and bail before starting the next one.
    }

    // If we're running, set to pending.
    LONG lResOld = InterlockedCompareExchange(&_lState, IRTIR_TASK_PENDING, IRTIR_TASK_RUNNING);
    if (lResOld == IRTIR_TASK_RUNNING)
    {
        // We've now set it to pending - ready to die.
        return S_OK;
    }
    else if (lResOld == IRTIR_TASK_PENDING || lResOld == IRTIR_TASK_FINISHED)
    {
        // We've already been killed.
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP CFolderExtractImage::Suspend(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderExtractImage::Resume(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG) CFolderExtractImage::IsRunning(void)
{
    return _lState;
}

HRESULT CFolderExtractImage::_CreateWithMiniPreviews(IShellFolder *psf, const LPCITEMIDLIST *apidlPreviews, BOOL *abTryCached, UINT cpidlPreviews, MINIPREVIEW_LAYOUT uLayout, IShellImageStore *pImageStore, HBITMAP *phBmpThumbnail)
{
    *phBmpThumbnail = NULL;

    HBITMAP hbmpOld;
    HDC hdc;

    SIZE sizeOriginal;      // Size of the source bitmaps that go into the minipreview.
    SIZE sizeFolderBmp;     // Size of the folder bmp we use for the background.
    SIZE sizeMiniPreview;   // The size calculated for the minipreviews
    POINT aptOrigins[MAX_MINIPREVIEWS];
    RGBQUAD* prgb;          // the bits of the destination bitmap. 

    _GetMiniPreviewLocations(uLayout, _size, &sizeFolderBmp,
                             aptOrigins, &sizeMiniPreview);

    // sizeFolderBmp is the size of the folder background bitmap that we're working with,
    // not the size of the final thumbnail.
    HRESULT hr = _CreateMainRenderingDC(&hdc, phBmpThumbnail, &hbmpOld, sizeFolderBmp.cx, sizeFolderBmp.cy, &prgb);

    if (SUCCEEDED(hr))
    {
        BOOL fIsAlphaBackground;
        hr = _DrawMiniPreviewBackground(hdc, sizeFolderBmp, _fAlpha, &fIsAlphaBackground, prgb);

        if (SUCCEEDED(hr))
        {
            ULONG uPreviewLocation = 0;

            // Extract the images for the minipreviews
            for (ULONG i = 0 ; i < cpidlPreviews && uPreviewLocation < ARRAYSIZE(aptOrigins) ; i++)
            {
                BOOL bFoundAlphaImage = FALSE;

                // If we've been killed, stop the processing the minipreviews:
                // PENDING?, we're now FINISHED.
                InterlockedCompareExchange(&_lState, IRTIR_TASK_FINISHED, IRTIR_TASK_PENDING);

                if (_lState == IRTIR_TASK_FINISHED)
                {
                    // Get out.
                    hr = E_FAIL;
                    break;
                }

                HBITMAP hbmpSubs;
                BOOL bFoundImage = FALSE;

                // Try the image store first
                DWORD dwLock;
                HRESULT hr2 = (pImageStore && abTryCached[i]) ? pImageStore->Open(STGM_READ, &dwLock) : E_FAIL;
                if (SUCCEEDED(hr2))
                {
                    // Get the fullpidl of this guy.
                    TCHAR szSubPath[MAX_PATH];
                    if (SUCCEEDED(DisplayNameOf(psf, apidlPreviews[i], SHGDN_INFOLDER | SHGDN_FORPARSING, szSubPath, MAX_PATH)))
                    {
                        if (SUCCEEDED(pImageStore->GetEntry(szSubPath, STGM_READ, &hbmpSubs)))
                        {
                            bFoundImage = TRUE;
                        }
                    }
                    pImageStore->ReleaseLock(&dwLock);
                }

                // Resort to calling extractor if the image was not in the cache.
                if (!bFoundImage)
                {
                    IExtractImage *peiSub;
                    hr2 = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&apidlPreviews[i], IID_X_PPV_ARG(IExtractImage, NULL, &peiSub));
                    if (SUCCEEDED(hr2))
                    {
                    
                        // Now extract the image.
                        DWORD dwPriority = 0;
                        DWORD dwFlags = IEIFLAG_ORIGSIZE | IEIFLAG_QUALITY;// ORIGSIZE -> preserve aspect ratio

                        WCHAR szPathBuffer[MAX_PATH];
                        hr2 = peiSub->GetLocation(szPathBuffer, ARRAYSIZE(szPathBuffer), &dwPriority, &sizeMiniPreview, 24, &dwFlags);
                        if (SUCCEEDED(hr2) && StrCmpIW(szPathBuffer, _szFolder)) // Avoid simple recursion
                        {                           
                            IAlphaThumbnailExtractor *pati;
                            if (SUCCEEDED(peiSub->QueryInterface(IID_PPV_ARG(IAlphaThumbnailExtractor, &pati))))
                            {
                                if (SUCCEEDED(pati->RequestAlphaThumbnail()))
                                {
                                    bFoundAlphaImage = TRUE;
                                }
                                
                                pati->Release();
                            }

                            // After we check for IRTIR_TASK_PENDING, but before
                            // we call peiSub->Extract,  it is possible someone calls
                            // Kill on us.
                            // Since _pRun will be NULL, we will not kill
                            // the subtask, but will instead continue and call extract
                            // on it, and not bail until we try the next subthumbnail.
                            // Oh well.
                            // We could add another check here to reduce the window of
                            // opportunity in which this could happen.

                            // Try to get an IRunnableTask so that we can stop execution
                            // of this subtask if necessary.
                            peiSub->QueryInterface(IID_PPV_ARG(IRunnableTask, &_pRun));

                            if (SUCCEEDED(peiSub->Extract(&hbmpSubs)))
                            {
                                bFoundImage = TRUE;
                            }

                            ATOMICRELEASE(_pRun);
                        }
                        
                        peiSub->Release();
                    }
                }

                // Add the extracted bitmap to the main one...
                if (bFoundImage)
                {
                    // The bitmap will of course need to be resized:
                    BITMAP rgBitmap;
                    if  (::GetObject((HGDIOBJ)hbmpSubs, sizeof(rgBitmap), &rgBitmap))
                    {
                        sizeOriginal.cx = rgBitmap.bmWidth;
                        sizeOriginal.cy = rgBitmap.bmHeight;

                        // We need to check if this is really an alpha bitmap.  It's possible that the
                        // extractor said it could generate one, but ended up not being able to.
                        if (bFoundAlphaImage)
                        {
                            RECT rc = {0, 0, rgBitmap.bmWidth, rgBitmap.bmHeight};
                            bFoundAlphaImage = (rgBitmap.bmBitsPixel == 32) &&
                                                _HasAlpha(rc, rgBitmap.bmWidth, (RGBQUAD*)rgBitmap.bmBits);
                        }
                    }
                    else
                    {
                        // Couldn't get the info, oh well, no resize.
                        // alpha may also be screwed up here, but oh well.
                        sizeOriginal = sizeMiniPreview;
                    }

                    if (SUCCEEDED(_AddBitmap(hdc, hbmpSubs, aptOrigins[uPreviewLocation], sizeMiniPreview, sizeOriginal, bFoundAlphaImage, fIsAlphaBackground, prgb, sizeFolderBmp)))
                    {
                        uPreviewLocation++;
                    }

                    DeleteObject(hbmpSubs);
                }
            }

            if (!uPreviewLocation)
            {
                // For whatever reason, we have no mini thumbnails to show, so fail this entire extraction.
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Is the requested size one of the sizes of the folder background bitmaps?
            // Test against smallest requested dimension, because we're square, and we'll fit into that rectangle
            int iSmallestDimension = min(_size.cx, _size.cy);
            if ((sizeFolderBmp.cx != iSmallestDimension) || (sizeFolderBmp.cy != iSmallestDimension))
            {
                // Nope - we need to do some scaling.
                // Create another dc and bitmap the size of the requested bitmap
                HBITMAP hBmpThumbnailFinal = NULL;
                HBITMAP hbmpOld2;
                HDC hdcFinal;
                RGBQUAD *prgbFinal;
                hr = _CreateMainRenderingDC(&hdcFinal, &hBmpThumbnailFinal, &hbmpOld2, iSmallestDimension, iSmallestDimension, &prgbFinal);
                if (SUCCEEDED(hr))
                {
                    // Now scale it.
                    if (fIsAlphaBackground)
                    {
                        BLENDFUNCTION bf;
                        bf.BlendOp = AC_SRC_OVER;
                        bf.SourceConstantAlpha = 255;
                        bf.AlphaFormat = AC_SRC_ALPHA;
                        bf.BlendFlags = 0;
                        if (AlphaBlend(hdcFinal, 0, 0, iSmallestDimension, iSmallestDimension, hdc, 0 ,0, sizeFolderBmp.cx, sizeFolderBmp.cy, bf))
                            hr = S_OK;
                    }
                    else
                    {
                        int iModeSave = SetStretchBltMode(hdcFinal, HALFTONE);

                        if (StretchBlt(hdcFinal, 0, 0, iSmallestDimension, iSmallestDimension, hdc, 0 ,0, sizeFolderBmp.cx, sizeFolderBmp.cy, SRCCOPY))
                            hr = S_OK;

                        SetStretchBltMode(hdcFinal, iModeSave);
                    }

                    // Destroy the dc.
                    _DestroyMainRenderingDC(hdcFinal, hbmpOld2);

                    // Now do a switcheroo
                    // Don't need to check for success here.  Down below, we'll delete *phBmpThumbnail
                    // if StretchBlt FAILED - and in that case, *pbBmpThumbnail will be hBmpThumbnailFinal.
                    DeleteObject(*phBmpThumbnail); // delete this, we don't need it.
                    *phBmpThumbnail = hBmpThumbnailFinal; // This is the one we want.
                }
            }
        }
        _DestroyMainRenderingDC(hdc, hbmpOld);
    }


    if (FAILED(hr) && *phBmpThumbnail) // Something didn't work? Make sure we delete our bmp
    {
        DeleteObject(*phBmpThumbnail);
    }

    return hr;
}


/**
 * In/Out: cpidlPreviews - the number of preview items we should look for. Returns the number found.
 * number of pidls returned is cpidlPreviews.
 * Out: apidlPreviews - array of pidls found.  The caller must free them.
 */
HRESULT CFolderExtractImage::_FindMiniPreviews(LPITEMIDLIST apidlPreviews[], BOOL abTryCached[], UINT *pcpidlPreviews)
{   
    UINT cMaxPreviews = *pcpidlPreviews;
    int uNumPreviewsSoFar = 0;
    BOOL bKilled = FALSE;

    // Make sure our aFileTimes array is the right size...
    ASSERT(MAX_MINIPREVIEWS_COLLECT == cMaxPreviews);

    *pcpidlPreviews = 0; // start with none in case of failure

    IEnumIDList *penum;
    if (S_OK == _psf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
    {
        FILETIME aFileTimes[MAX_MINIPREVIEWS_COLLECT] = {0};

        LPITEMIDLIST pidl;
        BOOL bTryCached;
        while (S_OK == penum->Next(1, &pidl, NULL))
        {
            // _IsMiniPreviewCandidate is a potentially expensive operation, so before
            // doing it, we'll check to see if anyone has killed us.

            // Are we PENDING? Then we're FINISHED.
            InterlockedCompareExchange(&_lState, IRTIR_TASK_FINISHED, IRTIR_TASK_PENDING);

            // Get out?
            bKilled = (_lState == IRTIR_TASK_FINISHED);

            if (!bKilled && _IsMiniPreviewCandidate(_psf, pidl, &bTryCached))
            {
                // Get file time of this guy.
                FILETIME ft;
                if (SUCCEEDED(GetDateProperty(_psf, pidl, &SCID_WRITETIME, &ft)))
                {
                    for (int i = 0; i < uNumPreviewsSoFar; i++)
                    {
                        if (CompareFileTime(&aFileTimes[i], &ft) < 0)
                        {
                            int j;
                            // Put it in this slot. First, move guys down by one.
                            // No need to copy last guy:
                            if (uNumPreviewsSoFar == (int)cMaxPreviews)
                            {   
                                j = (cMaxPreviews - 2);
                                // And we must free the pidl we're nuking.
                                ILFree(apidlPreviews[cMaxPreviews - 1]);
                                apidlPreviews[cMaxPreviews - 1] = NULL;
                            }
                            else
                            {
                                j = uNumPreviewsSoFar - 1;
                                uNumPreviewsSoFar++;
                            }

                            for (; j >= i; j--)
                            {
                                apidlPreviews[j+1] = apidlPreviews[j];
                                abTryCached[j+1] = abTryCached[j];
                                aFileTimes[j+1] = aFileTimes[j];
                            }

                            aFileTimes[i] = ft;
                            apidlPreviews[i] = pidl;
                            abTryCached[i] = bTryCached;
                            pidl = NULL;    // don't free
                            break;  // for loop
                        }
                    }

                    // Did we complete the loop?
                    if (i == uNumPreviewsSoFar)
                    {
                        if (i < (int)cMaxPreviews)
                        {
                            // We still have room for more previews, so tack this on at the end.
                            uNumPreviewsSoFar++;
                            aFileTimes[i] = ft;
                            apidlPreviews[i] = pidl;
                            abTryCached[i] = bTryCached;
                            pidl = NULL;    // don't free below
                        }
                    }

                    *pcpidlPreviews = uNumPreviewsSoFar;
                }
            }
            ILFree(pidl);   // NULL pidl OK

            if (bKilled)
            {
                break;
            }
        }
        penum->Release();
    }

    if (bKilled)
    {
        FreeMiniPreviewPidls(apidlPreviews, *pcpidlPreviews);
        *pcpidlPreviews = 0;
        return E_FAIL;
    }
    else
    {
        return (uNumPreviewsSoFar > 0) ? S_OK : S_FALSE;
    }
}

HRESULT CFolderExtractImage::_CheckThumbnailCache(HBITMAP* phbmp)
{
    HRESULT hr = E_FAIL;
    
    if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE) &&
        !(_dwExtractFlags & IEIFLAG_QUALITY))
    {
        IShellImageStore *pDiskCache = NULL;
    
        hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, _szFolder, IID_PPV_ARG(IShellImageStore, &pDiskCache));
        if (SUCCEEDED(hr))
        {
            DWORD dwLock;
            
            hr = pDiskCache->Open(STGM_READ, &dwLock);
            if (SUCCEEDED(hr))
            {
                FILETIME ftTimeStamp = {0,0};

                hr = GetDateStamp(&ftTimeStamp);
                if (SUCCEEDED(hr))
                {
                    FILETIME ftTimeStampCache = {0,0};
                    hr = pDiskCache->IsEntryInStore(FOLDER_GUID, &ftTimeStampCache);
                    if (SUCCEEDED(hr))
                    {
                        if (hr == S_OK && (0 == CompareFileTime(&ftTimeStampCache, &ftTimeStamp)))
                        {
                            hr = pDiskCache->GetEntry(FOLDER_GUID, STGM_READ, phbmp);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                }
                pDiskCache->ReleaseLock(&dwLock);
                pDiskCache->Close(NULL);
            }
            pDiskCache->Release();
        }
    }

    TraceMsg(TF_DEFVIEW, "CFolderExtractImage::_CheckThumbnailCache (%s, %x)", _szFolder, hr);
    return hr;
}

void CFolderExtractImage::_CacheThumbnail(HBITMAP hbmp)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (!SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE))
    {
        SIZE sizeThumbnail;
        SHGetThumbnailSize(&sizeThumbnail);  // Don't cache the mini-thumbnail preview
        if (sizeThumbnail.cx == _size.cx && sizeThumbnail.cy == _size.cy)
        {
            IShellImageStore *pDiskCache = NULL;
            
            hr = LoadFromIDList(CLSID_ShellThumbnailDiskCache, _pidl, IID_PPV_ARG(IShellImageStore, &pDiskCache));
            if (SUCCEEDED(hr))
            {
                DWORD dwLock;
                
                hr = pDiskCache->Open(STGM_READWRITE, &dwLock);
                if (hr == STG_E_FILENOTFOUND)
                {
                    if (!IsCopyEngineRunning())
                    {
                        hr = pDiskCache->Create(STGM_WRITE, &dwLock);
                    }
                }
                
                if (SUCCEEDED(hr))
                {
                    FILETIME ftTimeStamp = {0,0};

                    hr = GetDateStamp(&ftTimeStamp);
                    if (SUCCEEDED(hr))
                    {
                        hr = pDiskCache->AddEntry(FOLDER_GUID, &ftTimeStamp, STGM_WRITE, hbmp);
                    }
                    pDiskCache->ReleaseLock(&dwLock);
                    pDiskCache->Close(NULL);
                }
                pDiskCache->Release();
            }
        }
    }
    TraceMsg(TF_DEFVIEW, "CFolderExtractImage::_CacheThumbnail (%s, %x)", _szFolder, hr);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\foldertypes.h ===
#ifndef __FOLDERTYPES_H__
#define __FOLDERTYPES_H__


// used in folder customization and sniffing

#define PROPSTR_FOLDERTYPE          L"FolderType"

#define STR_TYPE_DOCUMENTS          L"Documents"
#define STR_TYPE_MYDOCUMENTS        L"MyDocuments"
#define STR_TYPE_PICTURES           L"Pictures"
#define STR_TYPE_MYPICTURES         L"MyPictures"
#define STR_TYPE_PHOTOALBUM         L"PhotoAlbum"
#define STR_TYPE_MUSIC              L"Music"
#define STR_TYPE_MYMUSIC            L"MyMusic"
#define STR_TYPE_MUSICARTIST        L"MusicArtist"
#define STR_TYPE_MUSICALBUM         L"MusicAlbum"
#define STR_TYPE_VIDEOS             L"Videos"
#define STR_TYPE_MYVIDEOS           L"MyVideos"
#define STR_TYPE_VIDEOALBUM         L"VideoAlbum"
#define STR_TYPE_BOOKS              L"Books"
#define STR_TYPE_USELEGACYHTT       L"UseLegacyHTT"
#define STR_TYPE_COMMONDOCUMENTS    L"CommonDocuments"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\foldertip.cpp ===
#include "shellprv.h"
#include "ids.h"

class CFolderInfoTip : public IQueryInfo, public ICustomizeInfoTip, public IParentAndItem, public IShellTreeWalkerCallBack
{
public:
    CFolderInfoTip(IUnknown *punk, LPCTSTR pszFolder);
    
    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IQueryInfo methods.
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

    // IShellTreeWalkerCallBack methods
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws);
    STDMETHODIMP HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError);

private:
    ~CFolderInfoTip();

    HRESULT _GetTreeWalkerData(TREEWALKERSTATS *ptws);
    HRESULT _BufferInsert(LPWSTR pszBuffer, int *puBufferUsed, int uBufferMaxSize, LPCWSTR pwszPath, int cBufferItems);
    HRESULT _WalkTree(LPWSTR pszTip, DWORD cchSize);
    HRESULT _BuildSizeBlurb(HRESULT hr, LPWSTR pszSizeBlurb, DWORD cchSize);
    HRESULT _BuildFolderBlurb(HRESULT hr, LPWSTR pszFolderBlurb, DWORD cchSize);
    HRESULT _BuildFileBlurb(HRESULT hr, LPWSTR pszSizeBlurb, DWORD cchSize);

    LONG _cRef;                             // Reference Counter
    LPWSTR _pszFolderName;                  // File name of the target folder
    IQueryInfo *_pqiOuter;                  // Outer info tip for folders (say, for comments)

    ULONGLONG _ulTotalSize;                 // Total size of encountered files
    UINT _nSubFolders;                      // Total number of subfolders of target
    UINT _nFiles;                           // Total number of subfiles of target folder
    DWORD _dwSearchStartTime;               // Time when search started

    WCHAR _szFileList[60];                  // List of files in target folder
    int _nFileListCharsUsed;                // Number of characters used in buffer

    WCHAR _szFolderList[60];                // List of subfolders of target
    int _nFolderListCharsUsed;              // Number of chars used in folder buffer
};


// Constructor and Destructor do nothing more than set everything to
// 0 and ping the dll
CFolderInfoTip::CFolderInfoTip(IUnknown *punkOutter, LPCTSTR pszFolder) : _cRef(1)
{   
    // Init everything to 0
    _pszFolderName = StrDup(pszFolder);
    _szFileList[0] = 0;
    _nFileListCharsUsed = 0;
    _szFolderList[0] = 0;
    _nFolderListCharsUsed = 0;
    _ulTotalSize = 0;
    _nSubFolders = 0;
    _nFiles = 0;

    punkOutter->QueryInterface(IID_PPV_ARG(IQueryInfo, &_pqiOuter));

    DllAddRef();
}

CFolderInfoTip::~CFolderInfoTip()
{
    LocalFree(_pszFolderName);
    if (_pqiOuter)
        _pqiOuter->Release();
    DllRelease();
}

HRESULT CFolderInfoTip::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderInfoTip, IQueryInfo),
        QITABENT(CFolderInfoTip, ICustomizeInfoTip),
        QITABENT(CFolderInfoTip, IParentAndItem),
        QITABENT(CFolderInfoTip, IShellTreeWalkerCallBack),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFolderInfoTip::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderInfoTip::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IQueryInfo functions
STDMETHODIMP CFolderInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}

//
// Wrapper for FormatMessage.  Is this duplicated somewhere else?
DWORD _FormatMessageArg(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pszBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessage(dwFlags, lpSource, dwMessageID, dwLangID, pszBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

// This runs a TreeWalker that gets the info about files and file
// sizes, etc. and then takes those date and stuffs them into a infotip

STDMETHODIMP CFolderInfoTip::GetInfoTip(DWORD dwFlags, LPWSTR *ppwszTip)
{
    HRESULT hr = S_OK;
    *ppwszTip = NULL;

    if (_pszFolderName)
    {
        WCHAR szTip[INFOTIPSIZE]; // The info tip I build w/ folder contents
        szTip[0] = 0;

        // If we are to search, then search!
        if ((dwFlags & QITIPF_USESLOWTIP) &&
            SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("FolderContentsInfoTip"), 0, TRUE))
        {
            _WalkTree(szTip, ARRAYSIZE(szTip));
        }
        
        // Now that we've built or skipped our tip, get the outer tip's info.
        if (_pqiOuter)
        {
            if (szTip[0])
            {     
                LPWSTR pszOuterTip = NULL;
                _pqiOuter->GetInfoTip(dwFlags, &pszOuterTip);
                
                // Allocate and build the return tip, ommitting the outer tip if
                // it's  null, and putting a \n between them
                // if they both aren't.
                int cch = lstrlen(szTip) + (pszOuterTip ? lstrlen(pszOuterTip) + 1 : 0) + 1;
                
                *ppwszTip = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));
                if (*ppwszTip)
                {
                    **ppwszTip = 0; // zero init string

                    if (pszOuterTip && *pszOuterTip)
                    {
                        // outer tip first
                        StrCpyN(*ppwszTip, pszOuterTip, cch);
                        StrCatBuff(*ppwszTip, L"\n", cch);
                    }
                    StrCatBuff(*ppwszTip, szTip, cch);
                }

                if (pszOuterTip)
                {
                    SHFree(pszOuterTip);
                }
            }
            else
            {
                hr = _pqiOuter->GetInfoTip(dwFlags, ppwszTip);
            }
        }
    }
   
    return hr;
}

STDMETHODIMP CFolderInfoTip::SetPrefixText(LPCWSTR pszPrefix)
{
    ICustomizeInfoTip *pcit;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
    {
        pcit->SetPrefixText(pszPrefix);
        pcit->Release();
    }
    return S_OK;
}

STDMETHODIMP CFolderInfoTip::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    ICustomizeInfoTip *pcit;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
    {
        pcit->SetExtraProperties(pscid, cscid);
        pcit->Release();
    }
    return S_OK;
}

// IParentAndItem

STDMETHODIMP CFolderInfoTip::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IParentAndItem *ppai;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai))))
    {
        ppai->SetParentAndItem(pidlParent, psf, pidl);
        ppai->Release();
    }
    return S_OK;
}

STDMETHODIMP CFolderInfoTip::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    IParentAndItem *ppai;
    if (_pqiOuter && SUCCEEDED(_pqiOuter->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai))))
    {
        ppai->GetParentAndItem(ppidlParent, ppsf, ppidl);
        ppai->Release();
    }
    return S_OK;
}


// Helper functions for GetInfoTip    
HRESULT CFolderInfoTip::_WalkTree(LPWSTR pszTip, DWORD cchSize)
{
    // Get a CShellTreeWalker object to run the search for us.
    IShellTreeWalker *pstw;
    HRESULT hr = ::CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
    if (SUCCEEDED(hr)) 
    {
        TCHAR szFolderBlurb[128], szFileBlurb[128], szSizeBlurb[128];
        
        // Remember when we started so we know when to stop
        _dwSearchStartTime = GetTickCount();
        
        // Now, if hrTreeWalk is an error, it's not really an error; it just means
        // that the search was cut off early, so we don't bother to check 
        // it.  hrTreeWalk is passed to _BuildSizeBlurb so that it know whether or not
        // to add "greater than" to the string.
        HRESULT hrTreeWalk = pstw->WalkTree(WT_EXCLUDEWALKROOT | WT_NOTIFYFOLDERENTER,
            _pszFolderName, L"*.*", 32, SAFECAST(this, IShellTreeWalkerCallBack *));    
        
        // Create substrings for size, files, folders (may be empty if there's 
        // nothing to show)
        _BuildSizeBlurb(hrTreeWalk, szSizeBlurb, ARRAYSIZE(szSizeBlurb));
        _BuildFileBlurb(hrTreeWalk, szFileBlurb, ARRAYSIZE(szFileBlurb));
        _BuildFolderBlurb(hrTreeWalk, szFolderBlurb, ARRAYSIZE(szFolderBlurb));
        
        // Build our local tip
        TCHAR szFormatStr[64];
        LoadString(HINST_THISDLL, IDS_FIT_TipFormat, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszTip, 
            cchSize, szSizeBlurb, szFolderBlurb, szFileBlurb);
        
        pstw->Release();
    }
    return hr;
}

HRESULT CFolderInfoTip::_BuildSizeBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_ulTotalSize || (_nFiles || _nSubFolders)) 
    { 
        WCHAR szSizeString[20];  
        WCHAR szFormatStr[64];
        StrFormatByteSize(_ulTotalSize, szSizeString, ARRAYSIZE(szSizeString));
        
        if (SUCCEEDED(hr))
        {
            LoadString(HINST_THISDLL, IDS_FIT_Size, szFormatStr, ARRAYSIZE(szFormatStr));
        }
        else
        {
            LoadString(HINST_THISDLL, IDS_FIT_Size_LT, szFormatStr, ARRAYSIZE(szFormatStr));
        }

        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, szSizeString);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_FIT_Size_Empty, pszBlurb, cchSize);
    }
    
    return S_OK;
}            

HRESULT CFolderInfoTip::_BuildFileBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_nFiles && _nFileListCharsUsed)
    {
        WCHAR szFormatStr[64];

        LoadString(HINST_THISDLL, IDS_FIT_Files, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, _szFileList);
    }
    else 
    {
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, L"", 0, 0, pszBlurb, cchSize);
    }
    
    return S_OK;
}

HRESULT CFolderInfoTip::_BuildFolderBlurb(HRESULT hr, LPWSTR pszBlurb, DWORD cchSize)
{
    if (_nSubFolders)
    {
        WCHAR szFormatStr[64];

        LoadString(HINST_THISDLL, IDS_FIT_Folders, szFormatStr, ARRAYSIZE(szFormatStr));
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, szFormatStr, 0, 0, pszBlurb, cchSize, _szFolderList);
    }
    else 
    {
        _FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, L"", 0, 0, pszBlurb, cchSize);
    }
    
    return S_OK;
}

//
// A helper func that copies strings into a fixed size buffer,
// taking care of delimeters and everything.  Used by EnterFolder
// and FoundFile to build the file and folder lists.
HRESULT CFolderInfoTip::_BufferInsert(LPWSTR pszBuffer, int *pnBufferUsed,
                                      int nBufferMaxSize, LPCWSTR pszPath, int nBufferItems)
{
    TCHAR szDelimiter[100], szExtraItems[100];

    LoadString(HINST_THISDLL, IDS_FIT_Delimeter, szDelimiter, ARRAYSIZE(szDelimiter));
    LoadString(HINST_THISDLL, IDS_FIT_ExtraItems, szExtraItems, ARRAYSIZE(szExtraItems));

    // Check to see if the buffer is full, if not, proceed.
    if (*pnBufferUsed < nBufferMaxSize)
    {        
        // Holds the file name form the abs. path
        // Grab the file name
        LPWSTR pszFile = PathFindFileName(pszPath);
        if (pszFile)
        {
            // Calculates if the item will fit, remembering to leave room
            // not only for the delimeter, but for for the extra item marker
            // that might be added in the future. 
            if (*pnBufferUsed + lstrlen(pszFile) + lstrlen(szDelimiter) * 2 + lstrlen(szExtraItems) + 1 < 
                nBufferMaxSize)
            {
                // Add the delimeter if this is not the 1st item
                if (nBufferItems > 1)
                {
                    StrCpyN(&(pszBuffer[*pnBufferUsed]), 
                        szDelimiter, (nBufferMaxSize - *pnBufferUsed));
                    *pnBufferUsed += lstrlen(szDelimiter);
                }
         
                // Add the item to the buffer
                StrCpyN(&(pszBuffer[*pnBufferUsed]), pszFile, (nBufferMaxSize - *pnBufferUsed));
                *pnBufferUsed += lstrlen(pszFile);
            }
            else 
            {
                // In this case, the item won't fit, so just add the extra
                // items marker and set the buffer to be full
                if (nBufferItems > 1)
                {
                    StrCpyN(&(pszBuffer[*pnBufferUsed]), szDelimiter, (nBufferMaxSize - *pnBufferUsed));
                    *pnBufferUsed += lstrlen(szDelimiter);
                }

                StrCpyN(&(pszBuffer[*pnBufferUsed]), szExtraItems, (nBufferMaxSize - *pnBufferUsed));
                *pnBufferUsed = nBufferMaxSize;
            }
        }
    }

    return S_OK;
}


// IShellTreeWalkerCallBack functions
//
// The TreeWalker calls these whenever it finds a file, etc.  We grab
// the data out of the passed TREEWALKERSTATS *and use it to build the
// tip.  We also take the filenames that are passed to FoundFile  and to
// to EnterFolder to build the file and folder listings
STDMETHODIMP CFolderInfoTip::FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (ptws->nDepth == 0)
    {
        if (!(pwfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            _BufferInsert(_szFileList, &_nFileListCharsUsed, ARRAYSIZE(_szFileList), pwszPath, ptws->nFiles);
    }

    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd)
{
    if (ptws->nDepth == 0) 
    {
        if (!(pwfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            _BufferInsert(_szFolderList, &_nFolderListCharsUsed, ARRAYSIZE(_szFolderList), pwszPath, ptws->nFolders);
    }
    
    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::LeaveFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws) 
{
    return _GetTreeWalkerData(ptws);
}

STDMETHODIMP CFolderInfoTip::HandleError(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, HRESULT hrError)
{
    // TODO: look for HRESULT_FROM_WIN32(ACCESS_DENIED) for folders we can't look into.
    return _GetTreeWalkerData(ptws);
}

// copies data from the treewalker callback into
// class vars so that they can be used to build the InfoTip.  This also cuts
// off the search if too much time has elapsed.
HRESULT CFolderInfoTip::_GetTreeWalkerData(TREEWALKERSTATS *ptws) 
{
    HRESULT hr = S_OK;
    
    _ulTotalSize = ptws->ulTotalSize;
    _nSubFolders = ptws->nFolders;
    _nFiles = ptws->nFiles;
    
    if ((GetTickCount() - _dwSearchStartTime) > 3000)   // 3 seconds
    {
        hr = E_UNEXPECTED;
    } 
    
    return hr;
}

STDAPI CFolderInfoTip_CreateInstance(IUnknown *punkOuter, LPCTSTR pszFolder, REFIID riid, void **ppv)
{
    HRESULT hr;
    CFolderInfoTip *pdocp = new CFolderInfoTip(punkOuter, pszFolder);
    if (pdocp)
    {
        hr = pdocp->QueryInterface(riid, ppv);
        pdocp->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsdata.h ===
#ifndef __FSDATA_H__
#define __FSDATA_H__

#include "idldata.h"

class CFSIDLData : public CIDLDataObj
{
public:
    CFSIDLData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner): CIDLDataObj(pidlFolder, cidl, apidl, pdtInner) { };

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);

    STDMETHODIMP GetHDrop(LPFORMATETC pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP CreateHDrop(STGMEDIUM *pmedium, BOOL fAltName);

private:
    HRESULT _GetNetResource(STGMEDIUM *pmedium);
};

STDAPI CNetData_GetNetResourceForFS(IDataObject *pdtobj, STGMEDIUM *pmedium);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\folderviewhost.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#pragma hdrstop


// this is the comdlg frame that we will use to host the file picker object, it mostly is
// a stub that will forward accordingly
//
// the lifetime of this is handled by the DefView object we are attached to, which when
// the parent (CFolderViewHost) is destroyed will be taken down.

class CViewHostBrowser : public IShellBrowser, ICommDlgBrowser2, IServiceProvider
{
public:
    CViewHostBrowser(HWND hwndParent, IShellView *psvWeak, IUnknown *punkSiteWeak);
    ~CViewHostBrowser();
 
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)(HWND *lphwnd)
        { *lphwnd = _hwndParent; return S_OK; }
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode)
        { return S_OK; }

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
        { return E_NOTIMPL; }
    STDMETHOD(SetMenuSB)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
        { return S_OK; }
    STDMETHOD(RemoveMenusSB)(HMENU hmenuShared)
        { return E_NOTIMPL; }
    STDMETHOD(SetStatusTextSB)(LPCOLESTR lpszStatusText)
        { return S_OK; }
    STDMETHOD(EnableModelessSB)(BOOL fEnable)
        { return S_OK; }
    STDMETHOD(TranslateAcceleratorSB)(LPMSG lpmsg, WORD wID)
        { return S_FALSE; }

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(LPCITEMIDLIST pidl, UINT wFlags)
        { return E_FAIL; }
    STDMETHOD(GetViewStateStream)(DWORD grfMode, LPSTREAM *pStrm)
        { return E_FAIL; }
    STDMETHOD(GetControlWindow)(UINT id, HWND *lphwnd)
        { return E_NOTIMPL; }
    STDMETHOD(SendControlMsg)(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(IShellView *pshv)
        { return S_OK; }
    STDMETHOD(SetToolbarItems)(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags)
        { return S_OK; }

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand)(IShellView *ppshv)
        { return S_OK; }
    STDMETHOD(OnStateChange)(IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject)(IShellView *ppshv, LPCITEMIDLIST lpItem);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(Notify)(IShellView *ppshv, DWORD dwNotifyType)
        { return S_FALSE; }
    STDMETHOD(GetDefaultMenuText)(IShellView *ppshv, WCHAR *pszText, INT cchMax)
        { return S_FALSE; }
    STDMETHOD(GetViewFlags)(DWORD *pdwFlags)
        { *pdwFlags = 0; return S_OK; }

private:
    long _cRef;    
    HWND _hwndParent;

    IShellView *_psvWeak;
    IUnknown *_punkSiteWeak; // not addref'd.

    friend class CFolderViewHost;
};

CViewHostBrowser::CViewHostBrowser(HWND hwndParent, IShellView *psvWeak, IUnknown *punkSiteWeak) :
    _cRef(1), _hwndParent(hwndParent), _psvWeak(psvWeak), _punkSiteWeak(punkSiteWeak)
{
    // _psvWeak->AddRef();    // we hold a weak refernece to our parent, therefore don't AddRef()
    // _punkSiteWeak->AddRef(); // we hold a weak reference to our parent, therefore don't AddRef()!
}

CViewHostBrowser::~CViewHostBrowser()
{
    // _psvWeak->Release(); // this is scoped on the lifetime of our parent
    // _punkSiteWeak->Release(); // we hold a weak reference to our parent, therefore don't Release()!
}

HRESULT CViewHostBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CViewHostBrowser, IShellBrowser),                           // IID_IShellBrowser
        QITABENT(CViewHostBrowser, ICommDlgBrowser2),                        // IID_ICommDlgBrowser2
        QITABENTMULTI(CViewHostBrowser, ICommDlgBrowser, ICommDlgBrowser2),  // IID_ICommDlgBrowser
        QITABENT(CViewHostBrowser, IServiceProvider),                        // IID_IServiceProvider
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CViewHostBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CViewHostBrowser::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// IShellBrowser

HRESULT CViewHostBrowser::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret)
{
    if (pret)
        *pret = 0L;
    return S_OK;
}

HRESULT CViewHostBrowser::QueryActiveShellView(IShellView **ppshv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_psvWeak)
    {
        hr = _psvWeak->QueryInterface(IID_PPV_ARG(IShellView, ppshv));
    }
    return hr;
}


// ICommDlgBrowser - these are forwarded to our site object

HRESULT CViewHostBrowser::OnStateChange(IShellView *ppshv, ULONG uChange)
{
    HRESULT hr = S_OK;
    ICommDlgBrowser *pcdb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSiteWeak, SID_SCommDlgBrowser, IID_PPV_ARG(ICommDlgBrowser, &pcdb))))
    {
        hr = pcdb->OnStateChange(ppshv, uChange);
        pcdb->Release();
    }
    return hr;
}

HRESULT CViewHostBrowser::IncludeObject(IShellView *ppshv, LPCITEMIDLIST lpItem)
{
    HRESULT hr = S_OK;
    ICommDlgBrowser *pcdb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSiteWeak, SID_SCommDlgBrowser, IID_PPV_ARG(ICommDlgBrowser, &pcdb))))
    {
        hr = pcdb->IncludeObject(ppshv, lpItem);
        pcdb->Release();
    }
    return hr;
}


// IServiceProvider

HRESULT CViewHostBrowser::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL;
    
    if (IsEqualGUID(guidService, SID_SCommDlgBrowser))
    {
        hr = this->QueryInterface(riid, ppvObj);
    }

    return hr;
}



// this is the file picker object it creates an IShellView (which for us should result in 
// a defview implement).   from this we can then give the window to the caller and they 
// can place on their dialog as needed.

class CFolderViewHost : public IFolderViewHost, IServiceProvider, IOleWindow, IFolderView, CObjectWithSite
{
public:
    CFolderViewHost();
    ~CFolderViewHost();

    // *** IFolderViewHost ***
    STDMETHODIMP Initialize(HWND hwndParent, IDataObject *pdo, RECT *prc);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)(HWND *lphwnd)
        { *lphwnd = _hwndView; return S_OK; }
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode)
        { return S_OK; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv)
        { return IUnknown_QueryService(_punkSite, guidService, riid, ppv); }

    // IFolderView
    STDMETHODIMP GetCurrentViewMode(UINT *pViewMode)
        { return _pfv->GetCurrentViewMode(pViewMode); }
    STDMETHODIMP SetCurrentViewMode(UINT ViewMode)
        { return _pfv->SetCurrentViewMode(ViewMode); }
    STDMETHODIMP GetFolder(REFIID ridd, void **ppv)
        { return _pfv->GetFolder(ridd, ppv); }
    STDMETHODIMP Item(int iItemIndex, LPITEMIDLIST *ppidl)
        { return _pfv->Item(iItemIndex, ppidl); }
    STDMETHODIMP ItemCount(UINT uFlags, int *pcItems)
        { return _pfv->ItemCount(uFlags, pcItems); }
    STDMETHODIMP Items(UINT uFlags, REFIID riid, void **ppv)
        { return _pfv->Items(uFlags, riid, ppv); }
    STDMETHODIMP GetSelectionMarkedItem(int *piItem)
        { return _pfv->GetSelectionMarkedItem(piItem); }
    STDMETHODIMP GetFocusedItem(int *piItem)
        { return _pfv->GetFocusedItem(piItem); }
    STDMETHODIMP GetItemPosition(LPCITEMIDLIST pidl, POINT* ppt)
        { return _pfv->GetItemPosition(pidl, ppt); }
    STDMETHODIMP GetSpacing(POINT* ppt)
        { return _pfv->GetSpacing(ppt); }
    STDMETHODIMP GetDefaultSpacing(POINT* ppt)
        { return _pfv->GetDefaultSpacing(ppt); }
    STDMETHODIMP GetAutoArrange()
        { return _pfv->GetAutoArrange(); }
    STDMETHODIMP SelectItem(int iItem, DWORD dwFlags)
        { return _pfv->SelectItem(iItem, dwFlags); }
    STDMETHODIMP SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags)
        { return _pfv->SelectAndPositionItems(cidl, apidl, apt, dwFlags); }

private:
    long _cRef;
    IFolderView *_pfv;                      // IFolderView
    HWND _hwndView;
};


CFolderViewHost::CFolderViewHost() :
    _cRef(1)
{
}

CFolderViewHost::~CFolderViewHost()
{
    if (_pfv)
        _pfv->Release();
}

HRESULT CFolderViewHost::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderViewHost, IFolderViewHost),           // IID_IFolderViewHost
        QITABENT(CFolderViewHost, IOleWindow),                // IID_IOleWindow
        QITABENT(CFolderViewHost, IFolderView),               // IID_IFolderView
        QITABENT(CFolderViewHost, IServiceProvider),          // IID_IServiceProvider
        QITABENT(CFolderViewHost, IObjectWithSite),           // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderViewHost::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFolderViewHost::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// the initialize method handles the creation of the view object from the.

HRESULT CFolderViewHost::Initialize(HWND hwndParent, IDataObject *pdo, RECT *prc)
{
    // first we perform a namespace walk, this will retrieve our selection from the view
    // using this we can then create the view object.

    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST *aItems = NULL;
        UINT cItems = 0;

        hr = pnsw->Walk(pdo, NSWF_NONE_IMPLIES_ALL, 0, NULL);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf = NULL;

            hr = pnsw->GetIDArrayResult(&cItems, &aItems);
            if (S_OK == hr)
            {
                hr = SHBindToIDListParent(aItems[0], IID_PPV_ARG(IShellFolder, &psf), NULL);
            }
            else if (S_FALSE == hr)
            {
                hr = E_FAIL;                    // fail unless we perform the bind.

                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdo, &medium);
                if (pida)
                {
                    if (pida->cidl == 1)
                    {
                        LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
                        if (pidl)
                        {
                            hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
                            ILFree(pidl);
                        }
                    }
                    HIDA_ReleaseStgMedium(pida, &medium);
                }                
            }
            else
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {    
                IShellView *psv;
                hr = psf->CreateViewObject(hwndParent, IID_PPV_ARG(IShellView, &psv));
                if (SUCCEEDED(hr))
                {
                    CViewHostBrowser *pvhb = new CViewHostBrowser(hwndParent, psv, SAFECAST(this, IServiceProvider*));
                    if (pvhb)
                    {
                        hr = psv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));
                        if (SUCCEEDED(hr))
                        {
                            FOLDERSETTINGS fs = {0};
                            fs.ViewMode = FVM_THUMBNAIL;
                            fs.fFlags = FWF_AUTOARRANGE|FWF_NOWEBVIEW|FWF_HIDEFILENAMES|FWF_CHECKSELECT;

                            IFolderView *pfv;
                            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
                            {
                                pfv->GetCurrentViewMode(&fs.ViewMode);
                                pfv->Release();
                            }

                            hr = psv->CreateViewWindow(NULL, &fs, pvhb, prc, &_hwndView);
                            if (SUCCEEDED(hr))
                            {
                                hr = psv->UIActivate(SVUIA_INPLACEACTIVATE);
                            }
                        }

                        pvhb->Release();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    psv->Release();
                }

                for (int i = 0; SUCCEEDED(hr) && (i != cItems); i++)
                {
                    LPCITEMIDLIST pidlChild = ILFindLastID(aItems[i]);
                    hr = _pfv->SelectAndPositionItems(1, &pidlChild, NULL, SVSI_CHECK);
                }

                psf->Release();
            }

            FreeIDListArray(aItems, cItems);
        }

        pnsw->Release();
    }

    return hr;
}


STDAPI CFolderViewHost_CreateInstance(IUnknown *punkOut, REFIID riid, void **ppv)
{
    CFolderViewHost *pfp = new CFolderViewHost();
    if (!pfp)
        return E_OUTOFMEMORY;

    HRESULT hr = pfp->QueryInterface(riid, ppv);
    pfp->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsdrptgt.cpp ===
#include "shellprv.h"
#include <cowsite.h>
#include "datautil.h"
#include "ids.h"
#include "defview.h"
#include "_security.h"
#include "shitemid.h"
#include "idlcomm.h"
#include "bitbuck.h"
#include "bookmk.h"
#include "filefldr.h"
#include "brfcase.h"
#include "copy.h"
#include "filetbl.h"

#define TF_DRAGDROP 0x04000000


typedef struct
{
    HWND    hwnd;
    DWORD   dwFlags;
    POINTL  pt;
    CHAR    szUrl[INTERNET_MAX_URL_LENGTH];
} ADDTODESKTOP;


DWORD CALLBACK AddToActiveDesktopThreadProc(void *pv)
{
    ADDTODESKTOP* pToAD = (ADDTODESKTOP*)pv;
    CHAR szFilePath[MAX_PATH];
    DWORD cchFilePath = SIZECHARS(szFilePath);
    BOOL fAddComp = TRUE;

    if (SUCCEEDED(PathCreateFromUrlA(pToAD->szUrl, szFilePath, &cchFilePath, 0)))
    {
        fAddComp = FALSE;

        TCHAR szPath[MAX_PATH];
        SHAnsiToTChar(szFilePath, szPath, ARRAYSIZE(szPath));

        // If the Url is in the Temp directory
        if (PathIsTemporary(szPath))
        {
            if (IDYES == ShellMessageBox(g_hinst, pToAD->hwnd, MAKEINTRESOURCE(IDS_REASONS_URLINTEMPDIR),
                MAKEINTRESOURCE(IDS_AD_NAME), MB_YESNO | MB_ICONQUESTION))
            {
                TCHAR szFilter[64], szTitle[64];
                TCHAR szFilename[MAX_PATH];
                LPTSTR psz;

                LoadString(g_hinst, IDS_ALLFILESFILTER, szFilter, ARRAYSIZE(szFilter));
                LoadString(g_hinst, IDS_SAVEAS, szTitle, ARRAYSIZE(szTitle));

                psz = szFilter;

                //Strip out the # and make them Nulls for SaveAs Dialog
                while (*psz)
                {
                    if (*psz == (WCHAR)('#'))
                        *psz = (WCHAR)('\0');
                    psz++;
                }

                if (SUCCEEDED(StringCchCopy(szFilename, ARRAYSIZE(szFilename), PathFindFileName(szPath))))
                {
                    OPENFILENAME ofn = { 0 };
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = pToAD->hwnd;
                    ofn.hInstance = g_hinst;
                    ofn.lpstrFilter = szFilter;
                    ofn.lpstrFile = szFilename;
                    ofn.nMaxFile = ARRAYSIZE(szFilename);
                    ofn.lpstrTitle = szTitle;
                    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

                    if (GetSaveFileName(&ofn))
                    {
                        SHFILEOPSTRUCT sfo = { 0 };

                        szPath[lstrlen(szPath) + 1] = 0;
                        ofn.lpstrFile[lstrlen(ofn.lpstrFile) + 1] = 0;

                        sfo.hwnd = pToAD->hwnd;
                        sfo.wFunc = FO_COPY;
                        sfo.pFrom = szPath;
                        sfo.pTo = ofn.lpstrFile;

                        cchFilePath = SIZECHARS(szPath);
                        if (SHFileOperation(&sfo) == 0 &&
                            SUCCEEDED(UrlCreateFromPath(szPath, szPath, &cchFilePath, 0)))
                        {
                            SHTCharToAnsi(szPath, pToAD->szUrl, ARRAYSIZE(pToAD->szUrl));
                            fAddComp = TRUE;
                        }
                    }
                }
            }
        }
    }
    if (fAddComp)
        CreateDesktopComponents(pToAD->szUrl, NULL, pToAD->hwnd, pToAD->dwFlags, pToAD->pt.x, pToAD->pt.y);

    LocalFree((HLOCAL)pToAD);

    return 0;
}

typedef struct {
    DWORD        dwDefEffect;
    IDataObject *pdtobj;
    POINTL       pt;
    DWORD *      pdwEffect;
    HKEY         rghk[MAX_ASSOC_KEYS];
    DWORD        ck;
    HMENU        hmenu;
    UINT         idCmd;
    DWORD        grfKeyState;
} FSDRAGDROPMENUPARAM;

typedef struct
{
    HMENU   hMenu;
    UINT    uCopyPos;
    UINT    uMovePos;
    UINT    uLinkPos;
} FSMENUINFO;


class CFSDropTarget : CObjectWithSite, public IDropTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

    CFSDropTarget(CFSFolder *pFolder, HWND hwnd);

protected:
    virtual ~CFSDropTarget();
    BOOL _IsBriefcaseTarget() { return IsEqualCLSID(_pFolder->_clsidBind, CLSID_BriefcaseFolder); };

    BOOL _IsDesktopFolder() { return _GetIDList() && ILIsEmpty(_GetIDList()); };
    
    HRESULT _FilterFileContents(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterFileContentsOLEHack(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskCompHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                    DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterSneakernetBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterHIDA(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                           DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskImage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterDeskComp(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                               DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOlePackage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                 DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOleObj(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                             DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    HRESULT _FilterOleLink(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                              DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo);
    
    DWORD _FilesystemAdjustedDefaultEffect(DWORD dwCurEffectAvail);
    HRESULT _GetPath(LPTSTR pszPath, int cchPath);
    LPCITEMIDLIST _GetIDList();
    DWORD _LimitDefaultEffect(DWORD dwDefEffect, DWORD dwEffectsAllowed);
    DWORD _GetDefaultEffect(DWORD grfKeyState, DWORD dwCurEffectAvail, DWORD dwAllEffectAvail, DWORD dwOrigDefEffect);
    DWORD _DetermineEffects(DWORD grfKeyState, DWORD *pdwEffectInOut, HMENU hmenu);
    DWORD _EffectFromFolder();

    typedef struct
    {
        CFSDropTarget *pThis;
        IStream *pstmDataObj;
        IStream *pstmFolderView;
    } DROPTHREADPARAMS;

    static void _FreeThreadParams(DROPTHREADPARAMS *pdtp);

    static DWORD CALLBACK _DoDropThreadProc(void *pv);
    void _DoDrop(IDataObject *pdtobj, IFolderView* pfv);
    static void _AddVerbs(DWORD* pdwEffects, DWORD dwEffectAvail, DWORD dwDefEffect,
                          UINT idCopy, UINT idMove, UINT idLink,
                          DWORD dwForceEffect, FSMENUINFO* pfsMenuInfo);
    void _FixUpDefaultItem(HMENU hmenu, DWORD dwDefEffect);
    HRESULT _DragDropMenu(FSDRAGDROPMENUPARAM *pddm);

    HRESULT _CreatePackage(IDataObject *pdtobj);
    HRESULT _CreateURLDeskComp(IDataObject *pdtobj, POINTL pt);
    HRESULT _CreateDeskCompImage(IDataObject *pdtobj, POINTL pt);
    void _GetStateFromSite();
    BOOL _IsFromSneakernetBriefcase();
    BOOL _IsFromSameBriefcase();
    void _MoveCopy(IDataObject *pdtobj, IFolderView* pfv, HDROP hDrop);
    void _MoveSelectIcons(IDataObject *pdtobj, IFolderView* pfv, void *hNameMap, LPCTSTR pszFiles, BOOL fMove, HDROP hDrop);

    LONG            _cRef;
    CFSFolder       *_pFolder;
    HWND            _hwnd;                  // EVIL: used as a site and UI host
    UINT            _idCmd;
    DWORD           _grfKeyStateLast;       // for previous DragOver/Enter
    IDataObject     *_pdtobj;               // used durring Dragover() and DoDrop(), don't use on background thread
    DWORD           _dwEffectLastReturned;  // stashed effect that's returned by base class's dragover
    DWORD           _dwEffect;
    DWORD           _dwData;                // DTID_*
    DWORD           _dwEffectPreferred;     // if dwData & DTID_PREFERREDEFFECT
    DWORD           _dwEffectFolder;        // folder desktop.ini preferred effect
    BOOL            _fSameHwnd;             // the drag source and target are the same folder
    BOOL            _fDragDrop;             // 
    BOOL            _fUseExactDropPoint;    // Don't transform the drop point. The target knows exactly where it wants things.
    BOOL            _fBkDropTarget;
    POINT           _ptDrop;
    IFolderView*    _pfv;

    typedef struct {
        FORMATETC fmte;
        HRESULT (CFSDropTarget::*pfnGetDragDropInfo)(
                                      IN FORMATETC* pfmte,
                                      IN DWORD grfKeyFlags,
                                      IN DWORD dwEffectsAvail,
                                      IN OUT DWORD* pdwEffectsUsed,
                                      OUT DWORD* pdwDefaultEffect,
                                      IN OUT FSMENUINFO* pfsMenuInfo);
        CLIPFORMAT *pcfInit;
    } _DATA_HANDLER;

    // HACKHACK:  C++ doesn't let you initialize statics inside a class
    //            definition, and also doesn't let you specify an empty
    //            size (i.e., rg_data_handlers[]) inside a class definition
    //            either, so we have to have this bogus NUM_DATA_HANDLERS
    //            symbol that must manually be kept in sync.

    enum { NUM_DATA_HANDLERS = 16 };
    static _DATA_HANDLER rg_data_handlers[NUM_DATA_HANDLERS];
    static void _Init_rg_data_handlers();

private:
    friend HRESULT CFSDropTarget_CreateInstance(CFSFolder* pFolder, HWND hwnd, IDropTarget** ppdt);
};

CFSDropTarget::CFSDropTarget(CFSFolder *pFolder, HWND hwnd) : _cRef(1), _hwnd(hwnd), _pFolder(pFolder), _dwEffectFolder(-1)
{
    ASSERT(0 == _grfKeyStateLast);
    ASSERT(NULL == _pdtobj);
    ASSERT(0 == _dwEffectLastReturned);
    ASSERT(0 == _dwData);
    ASSERT(0 == _dwEffectPreferred);
    _pFolder->AddRef();
}

CFSDropTarget::~CFSDropTarget()
{
    AssertMsg(_pdtobj == NULL, TEXT("didn't get matching DragLeave, fix that bug"));

    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(_pfv);

    _pFolder->Release();
}

STDAPI CFSDropTarget_CreateInstance(CFSFolder* pFolder, HWND hwnd, IDropTarget** ppdt)
{
    *ppdt = new CFSDropTarget(pFolder, hwnd);
    return *ppdt ? S_OK : E_OUTOFMEMORY;
}

HRESULT CFSDropTarget::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFSDropTarget, IDropTarget),
        QITABENT(CFSDropTarget, IObjectWithSite),
        QITABENTMULTI2(CFSDropTarget, IID_IDropTargetWithDADSupport, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFSDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSDropTarget::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

void CFSDropTarget::_FreeThreadParams(DROPTHREADPARAMS *pdtp)
{
    pdtp->pThis->Release();
    ATOMICRELEASE(pdtp->pstmDataObj);
    ATOMICRELEASE(pdtp->pstmFolderView);
    LocalFree(pdtp);
}


// compute DTID_ bit flags from the data object to make format testing easier for
// DragOver() and Drop() code

STDAPI GetClipFormatFlags(IDataObject *pdtobj, DWORD *pdwData, DWORD *pdwEffectPreferred)
{
    *pdwData = 0;
    *pdwEffectPreferred = 0;

    if (pdtobj)
    {
        IEnumFORMATETC *penum;
        if (SUCCEEDED(pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
        {
            FORMATETC fmte;
            ULONG celt;
            while (S_OK == penum->Next(1, &fmte, &celt))
            {
                if (fmte.cfFormat == CF_HDROP && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_HDROP;

                if (fmte.cfFormat == g_cfHIDA && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_HIDA;

                if (fmte.cfFormat == g_cfNetResource && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_NETRES;

                if (fmte.cfFormat == g_cfEmbeddedObject && (fmte.tymed & TYMED_ISTORAGE))
                    *pdwData |= DTID_EMBEDDEDOBJECT;

                if (fmte.cfFormat == g_cfFileContents && (fmte.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE)))
                    *pdwData |= DTID_CONTENTS;
                
                if (fmte.cfFormat == g_cfFileGroupDescriptorA && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_FDESCA;

                if (fmte.cfFormat == g_cfFileGroupDescriptorW && (fmte.tymed & TYMED_HGLOBAL))
                    *pdwData |= DTID_FDESCW;

                if ((fmte.cfFormat == g_cfPreferredDropEffect) &&
                    (fmte.tymed & TYMED_HGLOBAL) &&
                    (DROPEFFECT_NONE != (*pdwEffectPreferred = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE))))
                {
                    *pdwData |= DTID_PREFERREDEFFECT;
                }
#ifdef DEBUG
                TCHAR szFormat[MAX_PATH];
                if (GetClipboardFormatName(fmte.cfFormat, szFormat, ARRAYSIZE(szFormat)))
                {
                    TraceMsg(TF_DRAGDROP, "CFSDropTarget - cf %s, tymed %d", szFormat, fmte.tymed);
                }
                else
                {
                    TraceMsg(TF_DRAGDROP, "CFSDropTarget - cf %d, tymed %d", fmte.cfFormat, fmte.tymed);
                }
#endif // DEBUG
                SHFree(fmte.ptd);
            }
            penum->Release();
        }

        //
        // HACK:
        // Win95 always did the GetData below which can be quite expensive if
        // the data is a directory structure on an ftp server etc.
        // dont check for FD_LINKUI if the data object has a preferred effect
        //
        if ((*pdwData & (DTID_PREFERREDEFFECT | DTID_CONTENTS)) == DTID_CONTENTS)
        {
            if (*pdwData & DTID_FDESCA)
            {
                FORMATETC fmteRead = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                STGMEDIUM medium = {0};
                if (S_OK == pdtobj->GetData(&fmteRead, &medium))
                {
                    FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)GlobalLock(medium.hGlobal);
                    if (pfgd)
                    {
                        if (pfgd->cItems >= 1)
                        {
                            if (pfgd->fgd[0].dwFlags & FD_LINKUI)
                                *pdwData |= DTID_FD_LINKUI;
                        }
                        GlobalUnlock(medium.hGlobal);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
            else if (*pdwData & DTID_FDESCW)
            {
                FORMATETC fmteRead = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                STGMEDIUM medium = {0};
                if (S_OK == pdtobj->GetData(&fmteRead, &medium))
                {
                    FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)GlobalLock(medium.hGlobal);
                    if (pfgd)
                    {
                        if (pfgd->cItems >= 1)
                        {
                            if (pfgd->fgd[0].dwFlags & FD_LINKUI)
                                *pdwData |= DTID_FD_LINKUI;
                        }
                        GlobalUnlock(medium.hGlobal);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
        }

        if (S_OK == OleQueryCreateFromData(pdtobj))
            *pdwData |= DTID_OLEOBJ;

        if (S_OK == OleQueryLinkFromData(pdtobj))
            *pdwData |= DTID_OLELINK;
    }
    return S_OK;    // for now always succeeds
}

STDMETHODIMP CFSDropTarget::DragEnter(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    ASSERT(NULL == _pdtobj);    // req DragDrop protocol, someone forgot to call DragLeave

    // init our registerd data formats
    IDLData_InitializeClipboardFormats();

    _grfKeyStateLast = grfKeyState;
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    GetClipFormatFlags(_pdtobj, &_dwData, &_dwEffectPreferred);

    *pdwEffect = _dwEffectLastReturned = _DetermineEffects(grfKeyState, pdwEffect, NULL);
    return S_OK;
}

STDMETHODIMP CFSDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    if (_grfKeyStateLast != grfKeyState)
    {
        _grfKeyStateLast = grfKeyState;
        *pdwEffect = _dwEffectLastReturned = _DetermineEffects(grfKeyState, pdwEffect, NULL);
    }
    else
    {
        *pdwEffect = _dwEffectLastReturned;
    }
    return S_OK;
}

STDMETHODIMP CFSDropTarget::DragLeave()
{
    IUnknown_Set((IUnknown **)&_pdtobj, NULL);
    return S_OK;
}


// init data from our site that we will need in processing the drop

void CFSDropTarget::_GetStateFromSite()
{
    IShellFolderView* psfv;

    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
    {
        _fSameHwnd = S_OK == psfv->IsDropOnSource((IDropTarget*)this);
        _fDragDrop = S_OK == psfv->GetDropPoint(&_ptDrop);
        _fBkDropTarget = S_OK == psfv->IsBkDropTarget(NULL);

        psfv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));

        psfv->Release();
    }
}

STDMETHODIMP CFSDropTarget::Drop(IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // OLE may give us a different data object (fully marshalled)
    // from the one we've got on DragEnter (this is not the case on Win2k, this is a nop)

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    _GetStateFromSite();

    // note, that on the drop the mouse buttons are not down so the grfKeyState
    // is not what we saw on the DragOver/DragEnter, thus we need to cache
    // the grfKeyState to detect left vs right drag
    //
    // ASSERT(this->grfKeyStateLast == grfKeyState);

    HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, POPUP_TEMPLATEDD);
    DWORD dwDefEffect = _DetermineEffects(grfKeyState, pdwEffect, hmenu);
    if (DROPEFFECT_NONE == dwDefEffect)
    {
        *pdwEffect = DROPEFFECT_NONE;
        DAD_SetDragImage(NULL, NULL);
        IUnknown_Set((IUnknown **)&_pdtobj, NULL);
        return S_OK;
    }

    TCHAR szPath[MAX_PATH];
    _GetPath(szPath, ARRAYSIZE(szPath));

    // this doesn't actually do the menu if (grfKeyState MK_LBUTTON)

    FSDRAGDROPMENUPARAM ddm;
    ddm.dwDefEffect = dwDefEffect;
    ddm.pdtobj = pdtobj;
    ddm.pt = pt;
    ddm.pdwEffect = pdwEffect;
    ddm.ck = SHGetAssocKeysForIDList(_GetIDList(), ddm.rghk, ARRAYSIZE(ddm.rghk));
    ddm.hmenu = hmenu;
    ddm.grfKeyState = grfKeyState;

    HRESULT hr = _DragDropMenu(&ddm);

    SHRegCloseKeys(ddm.rghk, ddm.ck);

    DestroyMenu(hmenu);

    if (hr == S_FALSE)
    {
        // let callers know where this is about to go
        // SHScrap cares because it needs to close the file so we can copy/move it
        DataObj_SetDropTarget(pdtobj, &CLSID_ShellFSFolder);

        switch (ddm.idCmd)
        {
        case DDIDM_CONTENTS_DESKCOMP:
            hr = CreateDesktopComponents(NULL, pdtobj, _hwnd, 0, ddm.pt.x, ddm.pt.y);
            break;

        case DDIDM_CONTENTS_DESKURL:
            hr = _CreateURLDeskComp(pdtobj, ddm.pt);
            break;

        case DDIDM_CONTENTS_DESKIMG:
            hr = _CreateDeskCompImage(pdtobj, ddm.pt);
            break;

        case DDIDM_CONTENTS_COPY:
        case DDIDM_CONTENTS_MOVE:
        case DDIDM_CONTENTS_LINK:
            hr = CFSFolder_AsyncCreateFileFromClip(_hwnd, szPath, pdtobj, pt, pdwEffect, _fBkDropTarget);
            break;

        case DDIDM_SCRAP_COPY:
        case DDIDM_SCRAP_MOVE:
        case DDIDM_DOCLINK:
            hr = SHCreateBookMark(_hwnd, szPath, pdtobj, pt, pdwEffect);
            break;

        case DDIDM_OBJECT_COPY:
        case DDIDM_OBJECT_MOVE:
            hr = _CreatePackage(pdtobj);
            if (E_UNEXPECTED == hr)
            {
                // _CreatePackage() can only expand certain types of packages
                // back into files.  For example, it doesn't handle CMDLINK files.
                //
                // If _CreatePackage() didn't recognize the stream format, we fall
                // back to SHCreateBookMark(), which should create a scrap:
                hr = SHCreateBookMark(_hwnd, szPath, pdtobj, pt, pdwEffect);
            }
            break;

        case DDIDM_COPY:
        case DDIDM_SYNCCOPY:
        case DDIDM_SYNCCOPYTYPE:
        case DDIDM_MOVE:
        case DDIDM_LINK:

            _dwEffect = *pdwEffect;
            _idCmd = ddm.idCmd;

            if (DataObj_CanGoAsync(pdtobj) || DataObj_GoAsyncForCompat(pdtobj))
            {
                // create another thread to avoid blocking the source thread.
                DROPTHREADPARAMS *pdtp;
                hr = SHLocalAlloc(sizeof(*pdtp), &pdtp);
                if (SUCCEEDED(hr))
                {
                    pdtp->pThis = this;
                    pdtp->pThis->AddRef();

                    CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pdtp->pstmDataObj);
                    CoMarshalInterThreadInterfaceInStream(IID_IFolderView,   _pfv, &pdtp->pstmFolderView);

                    if (SHCreateThread(_DoDropThreadProc, pdtp, CTF_COINIT, NULL))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        _FreeThreadParams(pdtp);
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                _DoDrop(pdtobj, _pfv);   // synchronously
            }


            // in these CF_HDROP cases "Move" is always an optimized move, we delete the
            // source. make sure we don't return DROPEFFECT_MOVE so the source does not 
            // try to do this too... 
            // even if we have not done anything yet since we may have 
            // kicked of a thread to do this
            
            DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, *pdwEffect);            
            if (DROPEFFECT_MOVE == *pdwEffect)
                *pdwEffect = DROPEFFECT_NONE;
            break;
        }
    }

    IUnknown_Set((IUnknown **)&_pdtobj, NULL);  // don't use this any more

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    ASSERT(*pdwEffect==DROPEFFECT_COPY || 
           *pdwEffect==DROPEFFECT_LINK || 
           *pdwEffect==DROPEFFECT_MOVE || 
           *pdwEffect==DROPEFFECT_NONE);
    return hr;
}

void CFSDropTarget::_AddVerbs(DWORD* pdwEffects, DWORD dwEffectAvail, DWORD dwDefEffect,
                              UINT idCopy, UINT idMove, UINT idLink,
                              DWORD dwForceEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    MENUITEMINFO mii;
    TCHAR szCmd[MAX_PATH];
    if (NULL != pfsMenuInfo)
    {
        mii.cbSize = sizeof(mii);
        mii.dwTypeData = szCmd;
        mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE | MIIM_DATA;
        mii.fType = MFT_STRING;
    }
    if ((DROPEFFECT_COPY == (DROPEFFECT_COPY & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_COPY)) || (dwForceEffect & DROPEFFECT_COPY)))
    {
        ASSERT(0 != idCopy);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idCopy + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_COPY == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idCopy;
            mii.dwItemData = DROPEFFECT_COPY;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uCopyPos, TRUE, &mii);
            pfsMenuInfo->uCopyPos++;
            pfsMenuInfo->uMovePos++;
            pfsMenuInfo->uLinkPos++;
        }
    }
    if ((DROPEFFECT_MOVE == (DROPEFFECT_MOVE & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_MOVE)) || (dwForceEffect & DROPEFFECT_MOVE)))
    {
        ASSERT(0 != idMove);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idMove + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_MOVE == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idMove;
            mii.dwItemData = DROPEFFECT_MOVE;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uMovePos, TRUE, &mii);
            pfsMenuInfo->uMovePos++;
            pfsMenuInfo->uLinkPos++;
        }
    }
    if ((DROPEFFECT_LINK == (DROPEFFECT_LINK & dwEffectAvail)) &&
        ((0 == (*pdwEffects & DROPEFFECT_LINK)) || (dwForceEffect & DROPEFFECT_LINK)))
    {
        ASSERT(0 != idLink);
        if (NULL != pfsMenuInfo)
        {
            LoadString(HINST_THISDLL, idLink + IDS_DD_FIRST, szCmd, ARRAYSIZE(szCmd));
            mii.fState = MFS_ENABLED | ((DROPEFFECT_LINK == dwDefEffect) ? MFS_DEFAULT : 0);
            mii.wID = idLink;
            mii.dwItemData = DROPEFFECT_LINK;
            InsertMenuItem(pfsMenuInfo->hMenu, pfsMenuInfo->uLinkPos, TRUE, &mii);
            pfsMenuInfo->uLinkPos++;
        }
    }
    *pdwEffects |= dwEffectAvail;
}

// determine the default drop effect (move/copy/link) from the file type
//
// HKCR\.cda "DefaultDropEffect" = 4   // DROPEFFECT_LINK

DWORD EffectFromFileType(IDataObject *pdtobj)
{
    DWORD dwDefEffect = DROPEFFECT_NONE; // 0

    LPITEMIDLIST pidl;
    if (SUCCEEDED(PidlFromDataObject(pdtobj, &pidl)))
    {
        IQueryAssociations *pqa;
        if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
        {
            DWORD cb = sizeof(dwDefEffect);
            pqa->GetData(0, ASSOCDATA_VALUE, L"DefaultDropEffect", &dwDefEffect, &cb);
            pqa->Release();
        }
        ILFree(pidl);
    }

    return dwDefEffect;
}

// compute the default effect based on 
//      the allowed effects
//      the keyboard state, 
//      the preferred effect that might be in the data object
//      and previously computed default effect (if the above yields nothing)

DWORD CFSDropTarget::_GetDefaultEffect(DWORD grfKeyState, DWORD dwCurEffectAvail, DWORD dwAllEffectAvail, DWORD dwOrigDefEffect)
{
    DWORD dwDefEffect = 0;
    //
    // keyboard, (explicit user input) gets first crack
    //
    switch (grfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
    case MK_CONTROL:
        dwDefEffect = DROPEFFECT_COPY;
        break;

    case MK_SHIFT:
        dwDefEffect = DROPEFFECT_MOVE;
        break;

    case MK_SHIFT | MK_CONTROL:
    case MK_ALT:
        dwDefEffect = DROPEFFECT_LINK;
        break;

    default: // no modifier keys case
        // if the data object contains a preferred drop effect, try to use it
        DWORD dwPreferred = DataObj_GetDWORD(_pdtobj, g_cfPreferredDropEffect, DROPEFFECT_NONE) & dwAllEffectAvail;

        if (DROPEFFECT_NONE == dwPreferred)
        {
            dwPreferred = EffectFromFileType(_pdtobj) & dwAllEffectAvail;
        }

        if (dwPreferred)
        {
            if (dwPreferred & DROPEFFECT_MOVE)
            {
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else if (dwPreferred & DROPEFFECT_COPY)
            {
                dwDefEffect = DROPEFFECT_COPY;
            }
            else if (dwPreferred & DROPEFFECT_LINK)
            {
                dwDefEffect = DROPEFFECT_LINK;
            }
        }
        else
        {
            dwDefEffect = dwOrigDefEffect;
        }
        break;
    }
    return dwDefEffect & dwCurEffectAvail;
}

HRESULT CFSDropTarget::_FilterDeskCompHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        hr = IsDeskCompHDrop(_pdtobj);
        if (S_OK == hr)
        {
            DWORD dwDefEffect = 0;
            DWORD dwEffectAdd = dwEffectsAvail & DROPEFFECT_LINK;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_CONTENTS_DESKCOMP,
                      DROPEFFECT_LINK, // force add the DDIDM_CONTENTS_DESKCOMP verb
                      pfsMenuInfo);
        }
    }
    return hr;
}

// see if a PIDL is scoped by a briefcaes

BOOL IsBriefcaseOrChild(LPCITEMIDLIST pidlIn)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidl = ILClone(pidlIn);
    if (pidl)
    {
        do
        {
            CLSID clsid;
            if (SUCCEEDED(GetCLSIDFromIDList(pidl, &clsid)) &&
                IsEqualCLSID(clsid, CLSID_Briefcase))
            {
                bRet = TRUE;    // it is a briefcase
                break;
            }
        } while (ILRemoveLastID(pidl));
        ILFree(pidl);
    }
    return bRet;
}

// returns true if the data object represents items in a sneakernet briefcase
// (briefcase on removable media)

BOOL CFSDropTarget::_IsFromSneakernetBriefcase()
{
    BOOL bRet = FALSE;  // assume no

    if (!_IsBriefcaseTarget())
    {
        STGMEDIUM medium = {0};
        LPIDA pida = DataObj_GetHIDA(_pdtobj, &medium);
        if (pida)
        {
            LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
            TCHAR szSource[MAX_PATH];
            if (SHGetPathFromIDList(pidlFolder, szSource))
            {
                // is source on removable device?
                if (!PathIsUNC(szSource) && IsRemovableDrive(DRIVEID(szSource)))
                {
                    TCHAR szTarget[MAX_PATH];
                    _GetPath(szTarget, ARRAYSIZE(szTarget));

                    // is the target fixed media?
                    if (PathIsUNC(szTarget) || !IsRemovableDrive(DRIVEID(szTarget)))
                    {
                        bRet = IsBriefcaseOrChild(pidlFolder);
                    }
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }
    return bRet;
}

// TRUE if any folders are in hdrop

BOOL DroppingAnyFolders(HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];
    
    for (UINT i = 0; DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath)); i++)
    {
        if (PathIsDirectory(szPath))
            return TRUE;
    }
    return FALSE;
}

// sneakernet case:
//      dragging a file/folder from a briefcase on removable media. we special case this
//  and use this as a chance to connect up this target folder with the content of the briefcase

HRESULT CFSDropTarget::_FilterSneakernetBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                                  DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    if (_IsFromSneakernetBriefcase())
    {
        // Yes; show the non-default briefcase cm
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            DWORD dwDefEffect = 0;
            DWORD dwEffectAdd = DROPEFFECT_COPY & dwEffectsAvail;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SYNCCOPY, 0, 0, 0, pfsMenuInfo);

            // Call _AddVerbs() again to force "Sync Copy of Type" as a 2nd DROPEFFECT_COPY verb:
            if ((DROPEFFECT_COPY & dwEffectsAvail) && 
                DroppingAnyFolders((HDROP)medium.hGlobal))
            {
                _AddVerbs(pdwEffects, DROPEFFECT_COPY, 0,
                          DDIDM_SYNCCOPYTYPE, 0, 0, DROPEFFECT_COPY, pfsMenuInfo);
            }
            
            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}

// returns true if the data object represents items from the same briefcase
// as this drop target
BOOL CFSDropTarget::_IsFromSameBriefcase()
{
    BOOL bRet = FALSE;

    STGMEDIUM medium;
    FORMATETC fmteBrief = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    
    // Yes; are they from the same briefcase as the target?
    if (SUCCEEDED(_pdtobj->GetData(&fmteBrief, &medium)))
    {
        BriefObj *pbo = (BriefObj *)GlobalLock(medium.hGlobal);

        TCHAR szBriefPath[MAX_PATH], szPath[MAX_PATH];
        if (SUCCEEDED(StringCchCopy(szBriefPath, ARRAYSIZE(szBriefPath), BOBriefcasePath(pbo))))
        {
            if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), BOFileList(pbo))))   // first file in list
            {
                TCHAR szPathTgt[MAX_PATH];
                _GetPath(szPathTgt, ARRAYSIZE(szPathTgt));

                int cch = PathCommonPrefix(szPath, szPathTgt, NULL);
                bRet = (0 < cch) && (lstrlen(szBriefPath) <= cch);
            }
        }
        
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }
    return bRet;
}

// briefcase drop target specific handling gets computed here

HRESULT CFSDropTarget::_FilterBriefcase(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    if (_IsBriefcaseTarget() && !_IsFromSameBriefcase())
    {
        STGMEDIUM medium = {0};
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            DWORD dwDefEffect = DROPEFFECT_COPY;
            DWORD dwEffectAdd = DROPEFFECT_COPY & dwEffectsAvail;
            if (pdwDefaultEffect)
            {
                dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                *pdwDefaultEffect = dwDefEffect;
            }
            
            _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SYNCCOPY, 0, 0, 0, pfsMenuInfo);

            // Call _AddVerbs() again to force "Sync Copy of Type" as a 2nd DROPEFFECT_COPY verb:
            if ((DROPEFFECT_COPY & dwEffectsAvail) && 
                DroppingAnyFolders((HDROP)medium.hGlobal))
            {
                _AddVerbs(pdwEffects, DROPEFFECT_COPY, 0,
                          DDIDM_SYNCCOPYTYPE, 0, 0, DROPEFFECT_COPY, pfsMenuInfo);
            }
            
            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}


HRESULT CFSDropTarget::_FilterHDROP(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                    DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    DWORD dwDefEffect = 0;
    DWORD dwEffectAdd = dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE);
    if (pdwDefaultEffect)
    {
        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, _FilesystemAdjustedDefaultEffect(dwEffectAdd));
        *pdwDefaultEffect = dwDefEffect;
    }
    
    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_COPY, DDIDM_MOVE, 0, 0, pfsMenuInfo);

    return S_OK;
}

HRESULT CFSDropTarget::_FilterFileContents(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                           DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    
    if ((_dwData & (DTID_CONTENTS | DTID_FDESCA)) == (DTID_CONTENTS | DTID_FDESCA) ||
        (_dwData & (DTID_CONTENTS | DTID_FDESCW)) == (DTID_CONTENTS | DTID_FDESCW))
    {
        DWORD dwEffectAdd, dwSuggestedEffect;
        //
        // HACK: if there is a preferred drop effect and no HIDA
        // then just take the preferred effect as the available effects
        // this is because we didn't actually check the FD_LINKUI bit
        // back when we assembled dwData! (performance)
        //
        if ((_dwData & (DTID_PREFERREDEFFECT | DTID_HIDA)) == DTID_PREFERREDEFFECT)
        {
            dwEffectAdd = _dwEffectPreferred;
            dwSuggestedEffect = _dwEffectPreferred;
        }
        else if (_dwData & DTID_FD_LINKUI)
        {
            dwEffectAdd = DROPEFFECT_LINK;
            dwSuggestedEffect = DROPEFFECT_LINK;
        }
        else
        {
            dwEffectAdd = DROPEFFECT_COPY | DROPEFFECT_MOVE;
            dwSuggestedEffect = DROPEFFECT_COPY;
        }
        dwEffectAdd &= dwEffectsAvail;

        DWORD dwDefEffect = 0;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, dwSuggestedEffect);
            *pdwDefaultEffect = dwDefEffect;
        }

        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                  DDIDM_CONTENTS_COPY, DDIDM_CONTENTS_MOVE, DDIDM_CONTENTS_LINK,
                  0, pfsMenuInfo);
    }
    return S_OK;
}

//
//  Old versions of OLE have a bug where if two FORMATETCs use the same
//  CLIPFORMAT, then only the first one makes it to the IEnumFORMATETC,
//  even if the other parameters (such as DVASPECT) are different.
//
//  This causes us problems because those other DVASPECTs might be useful.
//  So if we see a FileContents with the wrong DVASPECT, sniff at the
//  object to see if maybe it also contains a copy with the correct DVASPECT.
//
//  This bug was fixed in 1996 on the NT side, but the Win9x side was
//  not fixed.  The Win9x OLE team was disbanded before the fix could
//  be propagated.  So we get to work around this OLE bug forever.
//
HRESULT CFSDropTarget::_FilterFileContentsOLEHack(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                                  DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    FORMATETC fmte = *pfmte;
    fmte.dwAspect = DVASPECT_CONTENT;

    //
    //  Whoa, this test is so (intentionally) backwards it isn't funny.
    //
    //  We want to see whether there is a DVASPECT_CONTENT available in
    //  the real object.  So we first ask the object if it has a
    //  DVASPECT_CONTENT format already.  If the answer is yes, then we
    //  **skip** this FORMATETC, because it will be found (or has already
    //  been found) by our big EnumFORMATETC loop.
    //
    //  If the answer is NO, then maybe we're hitting an OLE bug.
    //  (They cache the list of available formats, but the bug is that
    //  their cache is broken.)  Bypass the cache by actually getting the
    //  data.  If it works, then run with it.  Otherwise, I guess OLE wasn't
    //  kidding.
    //
    //  Note that we do not GetData() unconditionally -- bad for perf.
    //  Only call GetData() after all the easy tests have failed.
    //

    HRESULT hr = _pdtobj->QueryGetData(&fmte);
    if (hr == DV_E_FORMATETC)
    {
        // Maybe we are hitting the OLE bug.  Try harder.
        STGMEDIUM stgm = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &stgm)))
        {
            // Yup.  OLE lied to us.
            ReleaseStgMedium(&stgm);

            hr = _FilterFileContents(&fmte, grfKeyFlags, dwEffectsAvail,
                                        pdwEffects, pdwDefaultEffect, pfsMenuInfo);
        }
        else
        {
            // Whaddya know, OLE was telling the truth.  Do nothing with this
            // format.
            hr = S_OK;
        }
    }
    else
    {
        // Either QueryGetData() failed in some bizarre way
        // (in which case we ignore the problem) or the QueryGetData
        // succeeded, in which case we ignore this FORMATETC since
        // the big enumeration will find (or has already found) the
        // DVASPECT_CONTENT.
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSDropTarget::_FilterHIDA(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                   DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);

    DWORD dwDefEffect = 0;
    DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
    // NOTE: we only add a HIDA default effect if HDROP isn't going to add a default
    // effect.  This preserves shell behavior with file system data objects without
    // requiring us to change the enumerator order in CIDLDataObj.  When we do change
    // the enumerator order, we can remove this special case:
    if (pdwDefaultEffect &&
        ((0 == (_dwData & DTID_HDROP)) ||
         (0 == _GetDefaultEffect(grfKeyFlags,
                                dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE),
                                dwEffectsAvail,
                                _FilesystemAdjustedDefaultEffect(dwEffectsAvail & (DROPEFFECT_COPY | DROPEFFECT_MOVE))))))
    {
        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
        *pdwDefaultEffect = dwDefEffect;
    }
    
    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_LINK, 0, pfsMenuInfo);

    return S_OK;
}

// {F20DA720-C02F-11CE-927B-0800095AE340}
const GUID CLSID_CPackage = {0xF20DA720L, 0xC02F, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40};
// old packager guid...
// {0003000C-0000-0000-C000-000000000046}
const GUID CLSID_OldPackage = {0x0003000CL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46};

HRESULT CFSDropTarget::_FilterOlePackage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                            DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    FORMATETC fmte = {g_cfObjectDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
    {
        // we've got an object descriptor
        OBJECTDESCRIPTOR* pOD = (OBJECTDESCRIPTOR*) GlobalLock(medium.hGlobal);
        if (pOD)
        {
            if (IsEqualCLSID(CLSID_OldPackage, pOD->clsid) ||
                IsEqualCLSID(CLSID_CPackage, pOD->clsid))
            {
                // This is a package - proceed
                DWORD dwDefEffect = 0;
                DWORD dwEffectAdd = (DROPEFFECT_COPY | DROPEFFECT_MOVE) & dwEffectsAvail;
                if (pdwDefaultEffect)
                {
                    dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
                    *pdwDefaultEffect = dwDefEffect;
                }
                
                _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                          DDIDM_OBJECT_COPY, DDIDM_OBJECT_MOVE, 0,
                          0, pfsMenuInfo);

                hr = S_OK;
            }
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

// REARCHITECT:
//    This code has lots of problems.  We need to fix this the text time we touch this code
// outside of ship mode.  TO FIX:
// 1. Use SHAnsiToUnicode(CP_UTF8, ) to convert pszHTML to unicode.  This will allow international
//    paths to work.
// 2. Obey the selected range.
// 3. Use MSHTML to get the image.  You can have trident parse the HTML via IHTMLTxtRange::pasteHTML.
//    MS HTML has a special collection of images.  Ask for the first image in that collection, or
//    the first image in that collection within the selected range.  (#1 isn't needed with this)
BOOL ExtractImageURLFromCFHTML(IN LPSTR pszHTML, IN SIZE_T cbHTMLSize, OUT LPSTR szImg, IN DWORD cchSize)
{
    BOOL fSucceeded = FALSE;

    // To avoid going nuts, only look at the first 64K of the HTML.
    // (Important on Win64 because StrCpyNA doesn't support more than 4GB.)
    if (cbHTMLSize > 0xFFFF)
        cbHTMLSize = 0xFFFF;

    // NT #391669: pszHTML isn't terminated, so terminate it now.
    LPSTR pszCopiedHTML = (LPSTR) LocalAlloc(LPTR, cbHTMLSize + 1);
    if (pszCopiedHTML)
    {
        if (SUCCEEDED(StringCchCopyA(pszCopiedHTML, (int)(cbHTMLSize + 1), pszHTML)))
        {
            //DANGER WILL ROBINSON:
            // HTML is comming in as UFT-8 encoded. Neither Unicode or Ansi,
            // We've got to do something.... I'm going to party on it as if it were
            // Ansi. This code will choke on escape sequences.....

            //Find the base URL
            //Locate <!--StartFragment-->
            //Read the <IMG SRC="
            //From there to the "> should be the Image URL
            //Determine if it's an absolute or relative URL
            //If relative, append to BASE url. You may need to lop off from the
            // last delimiter to the end of the string.

            //Pull out the SourceURL

            LPSTR pszTemp;
            LPSTR pszBase = StrStrIA(pszCopiedHTML,"SourceURL:"); // Point to the char after :
            if (pszBase)
            {
                pszBase += sizeof("SourceURL:")-1;

                //Since each line can be terminated by a CR, CR/LF or LF check each case...
                pszTemp = StrChrA(pszBase,'\n');
                if (!pszTemp)
                    pszTemp = StrChrA(pszBase,'\r');

                if (pszTemp)
                    *pszTemp = '\0';
                pszTemp++;
            }
            else
                pszTemp = pszCopiedHTML;


            //Pull out the Img Src
            LPSTR pszImgSrc = StrStrIA(pszTemp,"IMG");
            if (pszImgSrc != NULL)
            {
                pszImgSrc = StrStrIA(pszImgSrc,"SRC");
                if (pszImgSrc != NULL)
                {
                    LPSTR pszImgSrcOrig = pszImgSrc;
                    pszImgSrc = StrChrA(pszImgSrc,'\"');
                    if (pszImgSrc)
                    {
                        pszImgSrc++;     // Skip over the quote at the beginning of the src path.
                        pszTemp = StrChrA(pszImgSrc,'\"');    // Find the end of the path.
                    }
                    else
                    {
                        LPSTR pszTemp1;
                        LPSTR pszTemp2;

                        pszImgSrc = StrChrA(pszImgSrcOrig,'=');
                        if (pszImgSrc)
                        {
                            pszImgSrc++;     // Skip past the equals to the first char in the path.
                                            // Someday we may need to handle spaces between '=' and the path.

                            pszTemp1 = StrChrA(pszImgSrc,' ');   // Since the path doesn't have quotes around it, assume a space will terminate it.
                            pszTemp2 = StrChrA(pszImgSrc,'>');   // Since the path doesn't have quotes around it, assume a space will terminate it.

                            pszTemp = pszTemp1;      // Assume quote terminates path.
                            if (!pszTemp1)
                                pszTemp = pszTemp2;  // Use '>' if quote not found.

                            if (pszTemp1 && pszTemp2 && (pszTemp2 < pszTemp1))
                                pszTemp = pszTemp2;  // Change to having '>' terminate path if both exist and it comes first.
                        }
                    }

                    if (pszImgSrc && pszTemp)
                    {
                        *pszTemp = '\0'; // Terminate path.

                        //At this point, I've reduced the 2 important strings. Now see if I need to
                        //Join them.

                        //If this fails, then we don't have a full URL, Only a relative.
                        if (!UrlIsA(pszImgSrc, URLIS_URL) && pszBase)
                        {
                            if (SUCCEEDED(UrlCombineA(pszBase, pszImgSrc, szImg, &cchSize, 0)))
                            {
                                fSucceeded = TRUE;
                            }
                        }
                        else
                        {
                            if (lstrlenA(pszImgSrc) <= (int)cchSize)
                            {
                                StringCchCopyA(szImg, cchSize, pszImgSrc);
                                fSucceeded = TRUE;
                            }
                        }
                    }
                }
            }
        }
        LocalFree(pszCopiedHTML);
    }

    return fSucceeded;
}

HRESULT CFSDropTarget::_FilterDeskImage(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        FORMATETC fmte = {g_cfHTML, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            //DANGER WILL ROBINSON:
            //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
            // it as is it were ANSI. Find a way to escape the sequences...
            CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
            if (pszData)
            {
                CHAR szUrl[MAX_URL_STRING];
                if (ExtractImageURLFromCFHTML(pszData, GlobalSize(medium.hGlobal), szUrl, ARRAYSIZE(szUrl)))
                {
                    // The HTML contains an image tag - carry on...
                    DWORD dwDefEffect = 0;
                    DWORD dwEffectAdd = DROPEFFECT_LINK; // NOTE: ignoring dwEffectsAvail!
                    if (pdwDefaultEffect)
                    {
                        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd,
                                                        dwEffectsAvail | DROPEFFECT_LINK, DROPEFFECT_LINK);
                        *pdwDefaultEffect = dwDefEffect;
                    }
                    
                    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                              0, 0, DDIDM_CONTENTS_DESKIMG,
                              0, pfsMenuInfo);

                    hr = S_OK;
                }
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterDeskComp(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                       DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;

    if (pdwDefaultEffect)
    {
        *pdwDefaultEffect = 0;
    }

    if (!PolicyNoActiveDesktop() &&
        !SHRestricted(REST_NOADDDESKCOMP) &&
        _IsDesktopFolder())
    {
        FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
        {
            // DANGER WILL ROBINSON:
            // HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
            // it as is it were ANSI. Find a way to escape the sequences...
            CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
            if (pszData)
            {
                int nScheme = GetUrlSchemeA(pszData);
                if ((nScheme != URL_SCHEME_INVALID) && (nScheme != URL_SCHEME_FTP))
                {
                    // This is an internet scheme - carry on...
                    DWORD dwDefEffect = 0;
                    DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
                    if (pdwDefaultEffect)
                    {
                        dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
                        *pdwDefaultEffect = dwDefEffect;
                    }
                    
                    _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect,
                              0, 0, DDIDM_CONTENTS_DESKURL,
                              DROPEFFECT_LINK, // force add this verb
                              pfsMenuInfo);

                    hr = S_OK;
                }
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterOleObj(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                        DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (_dwData & DTID_OLEOBJ)
    {
        DWORD dwDefEffect = 0;
        DWORD dwEffectAdd = (DROPEFFECT_COPY | DROPEFFECT_MOVE) & dwEffectsAvail;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_COPY);
            *pdwDefaultEffect = dwDefEffect;
        }
    
        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, DDIDM_SCRAP_COPY, DDIDM_SCRAP_MOVE, 0, 0, pfsMenuInfo);

        hr = S_OK;
    }
    return hr;
}

HRESULT CFSDropTarget::_FilterOleLink(FORMATETC* pfmte, DWORD grfKeyFlags, DWORD dwEffectsAvail,
                                         DWORD* pdwEffects, DWORD* pdwDefaultEffect, FSMENUINFO* pfsMenuInfo)
{
    ASSERT(pdwEffects);
    HRESULT hr = S_FALSE;
    
    if (_dwData & DTID_OLELINK)
    {
        DWORD dwDefEffect = 0;
        DWORD dwEffectAdd = DROPEFFECT_LINK & dwEffectsAvail;
        if (pdwDefaultEffect)
        {
            dwDefEffect = _GetDefaultEffect(grfKeyFlags, dwEffectAdd, dwEffectsAvail, DROPEFFECT_LINK);
            *pdwDefaultEffect = dwDefEffect;
        }
    
        _AddVerbs(pdwEffects, dwEffectAdd, dwDefEffect, 0, 0, DDIDM_DOCLINK, 0, pfsMenuInfo);

        hr = S_OK;
    }
    return hr;
}

HRESULT CFSDropTarget::_CreateURLDeskComp(IDataObject *pdtobj, POINTL pt)
{
    // This code should only be entered if DDIDM_CONTENTS_DESKURL was added to the menu,
    // and it has these checks:
    ASSERT(!PolicyNoActiveDesktop() &&
           !SHRestricted(REST_NOADDDESKCOMP) &&
           _IsDesktopFolder());
           
    STGMEDIUM medium = {0};
    FORMATETC fmte = {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //DANGER WILL ROBINSON:
        //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
        // it as is it were ANSI. Find a way to escape the sequences...
        CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
        if (pszData)
        {
            int nScheme = GetUrlSchemeA(pszData);
            if ((nScheme != URL_SCHEME_INVALID) && (nScheme != URL_SCHEME_FTP))
            {
                // This is an internet scheme - URL

                hr = CreateDesktopComponents(pszData, NULL, _hwnd, DESKCOMP_URL, pt.x, pt.y);
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_FAIL;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

HRESULT CFSDropTarget::_CreateDeskCompImage(IDataObject *pdtobj, POINTL pt)
{
    ASSERT(!PolicyNoActiveDesktop() &&
           !SHRestricted(REST_NOADDDESKCOMP) &&
           _IsDesktopFolder());
           
    FORMATETC fmte = {g_cfHTML, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        //DANGER WILL ROBINSON:
        //HTML is UTF-8, a mostly ANSI cross of ANSI and Unicode. Play with
        // it as is it were ANSI. Find a way to escape the sequences...
        CHAR *pszData = (CHAR*) GlobalLock(medium.hGlobal);
        if (pszData)
        {
            CHAR szUrl[MAX_URL_STRING];
            if (ExtractImageURLFromCFHTML(pszData, GlobalSize(medium.hGlobal), szUrl, ARRAYSIZE(szUrl)))
            {
                // The HTML contains an image tag - carry on...
                ADDTODESKTOP *pToAD;
                hr = SHLocalAlloc(sizeof(*pToAD), &pToAD);
                if (SUCCEEDED(hr))
                {
                    pToAD->hwnd = _hwnd;
                    if (SUCCEEDED(StringCchCopyA(pToAD->szUrl, ARRAYSIZE(pToAD->szUrl), szUrl)))
                    {
                        pToAD->dwFlags = DESKCOMP_IMAGE;
                        pToAD->pt = pt;

                        if (SHCreateThread(AddToActiveDesktopThreadProc, pToAD, CTF_COINIT, NULL))
                        {
                            hr = S_OK;
                        }
                        else
                        {
                            LocalFree(pToAD);
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        LocalFree(pToAD);
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
            hr = E_FAIL;
        ReleaseStgMedium(&medium);
    }
    return hr;
}


//
// read byte by byte until we hit the null terminating char
// return: the number of bytes read
//
HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuf, UINT cchBuf)
{
    UINT cch = 0;
    
    do {
        *pszBuf = 0;
        pstm->Read(pszBuf, sizeof(CHAR), NULL);
        cch++;
    } while (*pszBuf++ && cch <= cchBuf);  
    return cch;
} 

HRESULT CopyStreamToFile(IStream* pstmSrc, LPCTSTR pszFile, ULONGLONG ullFileSize) 
{
    IStream *pstmFile;
    HRESULT hr = SHCreateStreamOnFile(pszFile, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, &pstmFile);
    if (SUCCEEDED(hr))
    {
        hr = CopyStreamUI(pstmSrc, pstmFile, NULL, ullFileSize);
        pstmFile->Release();
    }
    return hr;
}   

HRESULT CFSDropTarget::_CreatePackage(IDataObject *pdtobj)
{
    ILockBytes* pLockBytes;
    HRESULT hr = CreateILockBytesOnHGlobal(NULL, TRUE, &pLockBytes);
    if (SUCCEEDED(hr))
    {
        STGMEDIUM medium;
        medium.tymed = TYMED_ISTORAGE;
        hr = StgCreateDocfileOnILockBytes(pLockBytes,
                                        STGM_DIRECT | STGM_READWRITE | STGM_CREATE |
                                        STGM_SHARE_EXCLUSIVE, 0, &medium.pstg);
        if (SUCCEEDED(hr))
        {
            FORMATETC fmte = {g_cfEmbeddedObject, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE};
            hr = pdtobj->GetDataHere(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                IStream* pstm;
#ifdef DEBUG
                STATSTG stat;
                if (SUCCEEDED(medium.pstg->Stat(&stat, STATFLAG_NONAME)))
                {
                    ASSERT(IsEqualCLSID(CLSID_OldPackage, stat.clsid) ||
                           IsEqualCLSID(CLSID_CPackage, stat.clsid));
                }
#endif // DEBUG                        
                #define PACKAGER_ICON           2
                #define PACKAGER_CONTENTS       L"\001Ole10Native"
                #define PACKAGER_EMBED_TYPE     3
                hr = medium.pstg->OpenStream(PACKAGER_CONTENTS, 0,
                                               STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                               0, &pstm);
                if (SUCCEEDED(hr))
                {
                    DWORD dw;
                    WORD w;
                    CHAR szName[MAX_PATH];
                    CHAR szTemp[MAX_PATH];
                    if (SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)) && // pkg size
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // pkg appearance
                        (PACKAGER_ICON == w) &&
                        SUCCEEDED(StringReadFromStream(pstm, szName, ARRAYSIZE(szName))) &&
                        SUCCEEDED(StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp))) && // icon path
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // icon index
                        SUCCEEDED(pstm->Read(&w, sizeof(w), NULL)) &&   // panetype
                        (PACKAGER_EMBED_TYPE == w) &&
                        SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)) && // filename size
                        SUCCEEDED(pstm->Read(szTemp, min(dw, sizeof(szTemp)), NULL)) &&      // filename
                        SUCCEEDED(pstm->Read(&dw, sizeof(dw), NULL)))   // get file size
                    {
                        // The rest of the stream is the file contents
                        TCHAR szPath[MAX_PATH], szBase[MAX_PATH], szDest[MAX_PATH];
                        _GetPath(szPath, ARRAYSIZE(szPath));

                        SHAnsiToTChar(szName, szBase, ARRAYSIZE(szBase));
                        PathAppend(szPath, szBase);
                        if (PathYetAnotherMakeUniqueName(szDest, szPath, NULL, szBase))
                        {
                            TraceMsg(TF_GENERAL, "CFSIDLDropTarget pkg: %s", szDest);

                            hr = CopyStreamToFile(pstm, szDest, dw);

                            if (SUCCEEDED(hr))
                            {
                                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szDest, NULL);
                                if (_fBkDropTarget && _hwnd)
                                {
                                    PositionFileFromDrop(_hwnd, szDest, NULL);
                                }
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                    pstm->Release();
                }
            }
            medium.pstg->Release();
        }
        pLockBytes->Release();
    }
    return hr;
}

HRESULT CFSDropTarget::_GetPath(LPTSTR pszPath, int cchPath)
{
    return _pFolder->_GetPath(pszPath, cchPath);
}

LPCITEMIDLIST CFSDropTarget::_GetIDList()
{
    return _pFolder->_GetIDList();
}

DWORD CFSDropTarget::_EffectFromFolder()
{
    if (-1 == _dwEffectFolder)
    {
        _dwEffectFolder = DROPEFFECT_NONE;    // re-set to nothing (0)

        TCHAR szPath[MAX_PATH];
        // add a simple pathisroot check here to prevent it from hitting the disk (mostly floppy)
        // when we want the dropeffect probe to be fast (sendto, hovering over drives in view).
        // its not likely that we'll want to modify the root's drop effect, and this still allows
        // dropeffect modification on floppy subfolders.
        if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))) && !PathIsRoot(szPath) && PathAppend(szPath, TEXT("desktop.ini")))
        {
            _dwEffectFolder = GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("DefaultDropEffect"), 0, szPath);
        }
    }
    return _dwEffectFolder;
}

BOOL AllRegisteredPrograms(HDROP hDrop)
{
    TCHAR szPath[MAX_PATH];

    for (UINT i = 0; DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath)); i++)
    {
        if (!PathIsRegisteredProgram(szPath))
            return FALSE;
    }
    return TRUE;
}

BOOL IsBriefcaseRoot(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        // Is there a briefcase root in this pdtobj?
        IShellFolder2 *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, HIDA_GetPIDLFolder(pida), &psf))))
        {
            for (UINT i = 0; i < pida->cidl; i++) 
            {
                CLSID clsid;
                bRet = SUCCEEDED(GetItemCLSID(psf, IDA_GetIDListPtr(pida, i), &clsid)) &&
                        IsEqualCLSID(clsid, CLSID_Briefcase);
                if (bRet)
                    break;
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return bRet;
}

//
// the "default effect" defines what will be choosen out of the allowed effects
//
//  If the data object does NOT contain HDROP -> "none"
//  else if the source data object has a default drop effect folder list (maybe based on sub folderness)
//  else if the source is root or registered progam -> "link"
//   else if this is within a volume   -> "move"
//   else if this is a briefcase       -> "move"
//   else                              -> "copy"
//
DWORD CFSDropTarget::_FilesystemAdjustedDefaultEffect(DWORD dwCurEffectAvail)
{
    DWORD dwDefEffect = DROPEFFECT_NONE;

    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};
    if (SUCCEEDED(_pdtobj->GetData(&fmte, &medium)))
    {
        TCHAR szPath[MAX_PATH];
        DragQueryFile((HDROP) medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)); // focused item

        // DROPEFFECTFOLDERLIST allows the source of the data
        // to specify the desired drop effect for items under
        // certain parts of the name space.
        //
        // cd-burning does this to avoid the default move/copy computation
        // that would kick in for cross volume CD burning/staging area transfers

        FORMATETC fmteDropFolders = {g_cfDropEffectFolderList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM mediumDropFolders = {0};
        if (SUCCEEDED(_pdtobj->GetData(&fmteDropFolders, &mediumDropFolders)))
        {
            DROPEFFECTFOLDERLIST *pdefl = (DROPEFFECTFOLDERLIST*)GlobalLock(mediumDropFolders.hGlobal);
            if (pdefl)
            {
                // get the default effect from the list -- in the staging area case this is DROPEFFECT_COPY
                // so its a copy even if the staging area and source are on the same volume.
                dwDefEffect = pdefl->dwDefaultDropEffect;
                for (INT i = 0; i < pdefl->cFolders; i++)
                {
                    // some folders are excluded, for example if you move a file from one part of the staging
                    // area to another we override (to DROPEFFECT_MOVE in this case).
                    if (PathIsEqualOrSubFolder(pdefl->aFolders[i].wszPath, szPath))
                    {
                        dwDefEffect = pdefl->aFolders[i].dwDropEffect;
                        break;
                    }
                }
                GlobalUnlock(pdefl);          
            }
            ReleaseStgMedium(&mediumDropFolders);
        }

        if (DROPEFFECT_NONE == dwDefEffect)
        {
            dwDefEffect = _EffectFromFolder();
        }

        // If we didn't get a drop effect (==0) then lets fall back to the old checks
        if (DROPEFFECT_NONE == dwDefEffect)
        {
            TCHAR szFolder[MAX_PATH];
            _GetPath(szFolder, ARRAYSIZE(szFolder));

            // drive/UNC roots and installed programs get link
            if (PathIsRoot(szPath) || AllRegisteredPrograms((HDROP)medium.hGlobal))
            {
                dwDefEffect = DROPEFFECT_LINK;
            }
            else if (PathIsSameRoot(szPath, szFolder))
            {
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else if (IsBriefcaseRoot(_pdtobj))
            {
                // briefcase default to move even accross volumes
                dwDefEffect = DROPEFFECT_MOVE;
            }
            else
            {
                dwDefEffect = DROPEFFECT_COPY;
            }
        }
        ReleaseStgMedium(&medium);
    }
    else if (SUCCEEDED(_pdtobj->QueryGetData(&fmte)))
    {
        // but QueryGetData() succeeds!
        // this means this data object has HDROP but can't
        // provide it until it is dropped. Let's assume we are copying.
        dwDefEffect = DROPEFFECT_COPY;
    }

    // Switch default verb if the dwCurEffectAvail hint suggests that we picked an
    // unavailable effect (this code applies to MOVE and COPY only):
    dwCurEffectAvail &= (DROPEFFECT_MOVE | DROPEFFECT_COPY);
    if ((DROPEFFECT_MOVE == dwDefEffect) && (DROPEFFECT_COPY == dwCurEffectAvail))
    {
        // If we were going to return MOVE, and only COPY is available, return COPY:
        dwDefEffect = DROPEFFECT_COPY;
    }
    else if ((DROPEFFECT_COPY == dwDefEffect) && (DROPEFFECT_MOVE == dwCurEffectAvail))
    {
        // If we were going to return COPY, and only MOVE is available, return MOVE:
        dwDefEffect = DROPEFFECT_MOVE;
    }
    return dwDefEffect;
}

//
// make sure that the default effect is among the allowed effects
//
DWORD CFSDropTarget::_LimitDefaultEffect(DWORD dwDefEffect, DWORD dwEffectsAllowed)
{
    if (dwDefEffect & dwEffectsAllowed)
        return dwDefEffect;

    if (dwEffectsAllowed & DROPEFFECT_COPY)
        return DROPEFFECT_COPY;

    if (dwEffectsAllowed & DROPEFFECT_MOVE)
        return DROPEFFECT_MOVE;

    if (dwEffectsAllowed & DROPEFFECT_LINK)
        return DROPEFFECT_LINK;

    return DROPEFFECT_NONE;
}

// Handy abbreviation
#define TYMED_ALLCONTENT        (TYMED_HGLOBAL | TYMED_ISTREAM | TYMED_ISTORAGE)

// Use  FSDH for registered clipboard formats (anything of the form g_cf*)
// Use _FSDH for predefined clipboard formats (like CF_HDROP or 0)
// Generate the _DATA_HANDLER array
#define  FSDH(pfn, cf, dva, tymed) { {              0, NULL, dva, -1, tymed }, pfn, &cf  }
#define _FSDH(pfn, cf, dva, tymed) { { (CLIPFORMAT)cf, NULL, dva, -1, tymed }, pfn, NULL }

// NOTE: the order is important (particularly for multiple entries with the same FORMATETC)

CFSDropTarget::_DATA_HANDLER
CFSDropTarget::rg_data_handlers[NUM_DATA_HANDLERS] = {
    FSDH(_FilterFileContents,        g_cfFileGroupDescriptorW, DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterFileContentsOLEHack, g_cfFileGroupDescriptorW, DVASPECT_LINK,    TYMED_HGLOBAL),
    FSDH(_FilterFileContents,        g_cfFileGroupDescriptorA, DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterFileContentsOLEHack, g_cfFileGroupDescriptorA, DVASPECT_LINK,    TYMED_HGLOBAL),
    FSDH(_FilterFileContents,        g_cfFileContents,         DVASPECT_CONTENT, TYMED_ALLCONTENT),
    FSDH(_FilterFileContentsOLEHack, g_cfFileContents,         DVASPECT_LINK,    TYMED_ALLCONTENT),
   _FSDH(_FilterBriefcase,           CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL), 
   _FSDH(_FilterSneakernetBriefcase, CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterHDROP,               CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterDeskCompHDROP,       CF_HDROP,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterHIDA,                g_cfHIDA,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterOlePackage,          g_cfEmbeddedObject,       DVASPECT_CONTENT, TYMED_ISTORAGE),
    FSDH(_FilterDeskImage,           g_cfHTML,                 DVASPECT_CONTENT, TYMED_HGLOBAL),
    FSDH(_FilterDeskComp,            g_cfShellURL,             DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterOleObj,              0,                        DVASPECT_CONTENT, TYMED_HGLOBAL),
   _FSDH(_FilterOleLink,             0,                        DVASPECT_CONTENT, TYMED_HGLOBAL),
};

// Note that it's safe to race with another thread in this code
// since the function is idemponent.  (Call it as many times as you
// like -- only the first time through actually does anything.)

void CFSDropTarget::_Init_rg_data_handlers()
{
    for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
    {
        // If this assertion fires, then you have to change the value of
        // NUM_DATA_HANDLERS to match the number of entries in the array
        // definition.
        ASSERT(rg_data_handlers[i].fmte.tymed);

        if (rg_data_handlers[i].pcfInit)
        {
            rg_data_handlers[i].fmte.cfFormat = *rg_data_handlers[i].pcfInit;
        }
    }
}

//
// returns the default effect.
// also modifies *pdwEffectInOut to indicate "available" operations.
//
DWORD CFSDropTarget::_DetermineEffects(DWORD grfKeyState, DWORD *pdwEffectInOut, HMENU hmenu)
{
    DWORD dwDefaultEffect = DROPEFFECT_NONE;
    DWORD dwEffectsUsed = DROPEFFECT_NONE;

    _Init_rg_data_handlers();

    // Loop through formats, factoring in both the order of the enumerator and
    // the order of our rg_data_handlers to determine the default effect
    // (and possibly, to create the drop context menu)
    FSMENUINFO fsmi = { hmenu, 0, 0, 0 };
    IEnumFORMATETC *penum;
    AssertMsg((NULL != _pdtobj), TEXT("CFSDropTarget::_DetermineEffects() _pdtobj is NULL but we need it.  this=%#08lx"), this);
    if (_pdtobj && SUCCEEDED(_pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
    {
        FORMATETC fmte;
        ULONG celt;
        while (penum->Next(1, &fmte, &celt) == S_OK)
        {
            for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                if (rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat &&
                    rg_data_handlers[i].fmte.dwAspect == fmte.dwAspect &&
                    (rg_data_handlers[i].fmte.tymed & fmte.tymed))
                {
                    // keep passing dwDefaultEffect until someone computes one, this
                    // lets the first guy that figures out the default be the default
                    (this->*(rg_data_handlers[i].pfnGetDragDropInfo))(
                        &fmte, grfKeyState, *pdwEffectInOut, &dwEffectsUsed,
                        (DROPEFFECT_NONE == dwDefaultEffect) ? &dwDefaultEffect : NULL,
                        hmenu ? &fsmi : NULL);
                }
            }
            SHFree(fmte.ptd);
        }
        penum->Release();
    }
    // Loop through the rg_data_handlers that don't have an associated clipboard format last
    for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
    {
        if (0 == rg_data_handlers[i].fmte.cfFormat)
        {
            // if default effect is still not computed continue to pass that
            (this->*(rg_data_handlers[i].pfnGetDragDropInfo))(
               NULL, grfKeyState, *pdwEffectInOut, &dwEffectsUsed,
               (DROPEFFECT_NONE == dwDefaultEffect) ? &dwDefaultEffect : NULL,
               hmenu ? &fsmi : NULL);
        }
    }

    *pdwEffectInOut &= dwEffectsUsed;

    dwDefaultEffect = _LimitDefaultEffect(dwDefaultEffect, *pdwEffectInOut);

    DebugMsg(TF_FSTREE, TEXT("CFSDT::GetDefaultEffect dwDef=%x, dwEffUsed=%x, *pdw=%x"),
             dwDefaultEffect, dwEffectsUsed, *pdwEffectInOut);

    return dwDefaultEffect; // this is what we want to do
}

// This is used to map command id's back to dropeffect's:

const struct {
    UINT uID;
    DWORD dwEffect;
} c_IDFSEffects[] = {
    DDIDM_COPY,         DROPEFFECT_COPY,
    DDIDM_MOVE,         DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKCOMP,     DROPEFFECT_LINK,
    DDIDM_LINK,         DROPEFFECT_LINK,
    DDIDM_SCRAP_COPY,   DROPEFFECT_COPY,
    DDIDM_SCRAP_MOVE,   DROPEFFECT_MOVE,
    DDIDM_DOCLINK,      DROPEFFECT_LINK,
    DDIDM_CONTENTS_COPY, DROPEFFECT_COPY,
    DDIDM_CONTENTS_MOVE, DROPEFFECT_MOVE,
    DDIDM_CONTENTS_LINK, DROPEFFECT_LINK,
    DDIDM_CONTENTS_DESKIMG,     DROPEFFECT_LINK,
    DDIDM_SYNCCOPYTYPE, DROPEFFECT_COPY,        // (order is important)
    DDIDM_SYNCCOPY,     DROPEFFECT_COPY,
    DDIDM_OBJECT_COPY,  DROPEFFECT_COPY,
    DDIDM_OBJECT_MOVE,  DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKURL,  DROPEFFECT_LINK,
};

void CFSDropTarget::_FixUpDefaultItem(HMENU hmenu, DWORD dwDefEffect)
{
    // only do stuff if there is no default item already and we have a default effect
    if ((GetMenuDefaultItem(hmenu, MF_BYPOSITION, 0) == -1) && dwDefEffect)
    {
        for (int i = 0; i < GetMenuItemCount(hmenu); i++)
        {
            // for menu item matching default effect, make it the default.
            MENUITEMINFO mii = { 0 };
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_DATA | MIIM_STATE;
            if (GetMenuItemInfo(hmenu, i, MF_BYPOSITION, &mii) && (mii.dwItemData == dwDefEffect))
            {
                mii.fState |= MFS_DEFAULT;
                SetMenuItemInfo(hmenu, i, MF_BYPOSITION, &mii);
                break;
            }
        }
    }
}

HRESULT CFSDropTarget::_DragDropMenu(FSDRAGDROPMENUPARAM *pddm)
{
    HRESULT hr = E_OUTOFMEMORY;       // assume error
    DWORD dwEffectOut = 0;                              // assume no-ope.
    if (pddm->hmenu)
    {
        UINT idCmd;
        UINT idCmdFirst = DDIDM_EXTFIRST;
        HDXA hdxa = HDXA_Create();
        HDCA hdca = DCA_Create();
        if (hdxa && hdca)
        {
            // Enumerate the DD handlers and let them append menu items.
            for (DWORD i = 0; i < pddm->ck; i++)
            {
                DCA_AddItemsFromKey(hdca, pddm->rghk[i], STRREG_SHEX_DDHANDLER);
            }

            idCmdFirst = HDXA_AppendMenuItems(hdxa, pddm->pdtobj, pddm->ck,
                pddm->rghk, _GetIDList(), pddm->hmenu, 0,
                DDIDM_EXTFIRST, DDIDM_EXTLAST, 0, hdca);
        }

        // modifier keys held down to force operations that are not permitted (for example
        // alt to force a shortcut from the start menu, which does not have SFGAO_CANLINK)
        // can result in no default items on the context menu.  however in displaying the
        // cursor overlay in this case we fall back to DROPEFFECT_COPY.  a left drag then
        // tries to invoke the default menu item (user thinks its copy) but theres no default.

        // this function selects a default menu item to match the default effect if there
        // is no default item already.
        _FixUpDefaultItem(pddm->hmenu, pddm->dwDefEffect);

        // If this dragging is caused by the left button, simply choose
        // the default one, otherwise, pop up the context menu.  If there
        // is no key state info and the original effect is the same as the
        // current effect, choose the default one, otherwise pop up the
        // context menu.  
        if ((_grfKeyStateLast & MK_LBUTTON) ||
             (!_grfKeyStateLast && (*(pddm->pdwEffect) == pddm->dwDefEffect)))
        {
            idCmd = GetMenuDefaultItem(pddm->hmenu, MF_BYCOMMAND, 0);

            // This one MUST be called here. Please read its comment block.
            DAD_DragLeave();

            if (_hwnd)
                SetForegroundWindow(_hwnd);
        }
        else
        {
            // Note that SHTrackPopupMenu calls DAD_DragLeave().
            idCmd = SHTrackPopupMenu(pddm->hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pddm->pt.x, pddm->pt.y, 0, _hwnd, NULL);
        }

        //
        // We also need to call this here to release the dragged image.
        //
        DAD_SetDragImage(NULL, NULL);

        //
        // Check if the user selected one of add-in menu items.
        //
        if (idCmd == 0)
        {
            hr = S_OK;        // Canceled by the user, return S_OK
        }
        else if (InRange(idCmd, DDIDM_EXTFIRST, DDIDM_EXTLAST))
        {
            //
            // Yes. Let the context menu handler process it.
            //
            CMINVOKECOMMANDINFOEX ici = {
                sizeof(ici),
                0L,
                _hwnd,
                (LPSTR)MAKEINTRESOURCE(idCmd - DDIDM_EXTFIRST),
                NULL, NULL,
                SW_NORMAL,
            };

            // record if the shift/control keys were down at the time of the drop
            if (_grfKeyStateLast & MK_SHIFT)
            {
                ici.fMask |= CMIC_MASK_SHIFT_DOWN;
            }

            if (_grfKeyStateLast & MK_CONTROL)
            {
                ici.fMask |= CMIC_MASK_CONTROL_DOWN;
            }

            // We may not want to ignore the error code. (Can happen when you use the context menu
            // to create new folders, but I don't know if that can happen here.).
            HDXA_LetHandlerProcessCommandEx(hdxa, &ici, NULL);
            hr = S_OK;
        }
        else
        {
            for (int nItem = 0; nItem < ARRAYSIZE(c_IDFSEffects); ++nItem)
            {
                if (idCmd == c_IDFSEffects[nItem].uID)
                {
                    dwEffectOut = c_IDFSEffects[nItem].dwEffect;
                    break;
                }
            }

            hr = S_FALSE;
        }

        if (hdca)
            DCA_Destroy(hdca);

        if (hdxa)
            HDXA_Destroy(hdxa);

        pddm->idCmd = idCmd;
    }

    *pddm->pdwEffect = dwEffectOut;

    return hr;
}

void _MapName(void *hNameMap, LPTSTR pszPath, int cchPath)
{
    if (hNameMap)
    {
        SHNAMEMAPPING *pNameMapping;
        for (int i = 0; (pNameMapping = SHGetNameMappingPtr((HDSA)hNameMap, i)) != NULL; i++)
        {
            if (lstrcmpi(pszPath, pNameMapping->pszOldPath) == 0)
            {
                StringCchCopy(pszPath, cchPath, pNameMapping->pszNewPath);
                break;
            }
        }
    }
}

// convert double null list of files to array of pidls

int FileListToIDArray(LPCTSTR pszFiles, void *hNameMap, LPITEMIDLIST **pppidl)
{
    int i = 0;
    int nItems = CountFiles(pszFiles);
    LPITEMIDLIST *ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, nItems * sizeof(*ppidl));
    if (ppidl)
    {
        *pppidl = ppidl;

        while (*pszFiles)
        {
            TCHAR szPath[MAX_PATH];
            StrCpyN(szPath, pszFiles, ARRAYSIZE(szPath));

            _MapName(hNameMap, szPath, ARRAYSIZE(szPath));

            ppidl[i] = SHSimpleIDListFromPath(szPath);

            pszFiles += lstrlen(pszFiles) + 1;
            i++;
        }
    }
    return i;
}

// move items to the new drop location

void CFSDropTarget::_MoveSelectIcons(IDataObject *pdtobj, IFolderView* pfv, void *hNameMap, LPCTSTR pszFiles, BOOL fMove, HDROP hDrop)
{
    LPITEMIDLIST *ppidl = NULL;
    int cidl;

    if (pszFiles) 
    {
        cidl = FileListToIDArray(pszFiles, hNameMap, &ppidl);
    } 
    else 
    {
        cidl = CreateMoveCopyList(hDrop, hNameMap, &ppidl);
    }

    if (ppidl)
    {
        if (pfv)
            PositionItems(pfv, (LPCITEMIDLIST*)ppidl, cidl, pdtobj, fMove ? &_ptDrop : NULL);

        FreeIDListArray(ppidl, cidl);
    }
}

// this is the ILIsParent which matches up the desktop with the desktop directory.
BOOL AliasILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST pidlUse1 = SHLogILFromFSIL(pidl1);
    if (pidlUse1)
        pidl1 = pidlUse1;

    LPITEMIDLIST pidlUse2 = SHLogILFromFSIL(pidl2);
    if (pidlUse2)
        pidl2 = pidlUse2;

    BOOL fSame = ILIsParent(pidl1, pidl2, TRUE);

    ILFree(pidlUse1);   // NULL is OK here
    ILFree(pidlUse2);

    return fSame;
}

// in:
//      pszDestDir      destination dir for new file names
//      pszDestSpecs    double null list of destination specs
//
// returns:
//      double null list of fully qualified destination file names to be freed
//      with LocalFree()
//

LPTSTR RemapDestNamesW(LPCTSTR pszDestDir, LPCWSTR pszDestSpecs)
{
    UINT cbDestSpec = (lstrlen(pszDestDir) + 1) * sizeof(TCHAR);
    LPCWSTR pszTemp;
    UINT cbAlloc = sizeof(TCHAR);       // for double NULL teriminaion of entire string

    // compute length of buffer to aloc
    for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenW(pszTemp) + 1)
    {
        // +1 for null teriminator
        cbAlloc += cbDestSpec + (lstrlenW(pszTemp) + 1) * sizeof(TCHAR);
    }

    LPTSTR pszRet = (LPTSTR)LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;

        for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenW(pszTemp) + 1)
        {
            // PathCombine requires dest buffer of MAX_PATH size or it'll rip in call
            // to PathCanonicalize (IsBadWritePtr)
            TCHAR szTempDest[MAX_PATH];
            PathCombine(szTempDest, pszDestDir, pszTemp);
            // pszDest allocated exactly, strcpy okay.
            lstrcpy(pszDest, szTempDest);
            pszDest += lstrlen(pszDest) + 1;

            ASSERT((UINT)((BYTE *)pszDest - (BYTE *)pszRet) < cbAlloc);
            ASSERT(*pszDest == 0);      // zero init alloc
        }
        ASSERT((LPTSTR)((BYTE *)pszRet + cbAlloc - sizeof(TCHAR)) >= pszDest);
        ASSERT(*pszDest == 0);  // zero init alloc

    }
    return pszRet;
}

LPTSTR RemapDestNamesA(LPCTSTR pszDestDir, LPCSTR pszDestSpecs)
{
    UINT cbDestSpec = (lstrlen(pszDestDir) + 1) * sizeof(TCHAR);
    LPCSTR pszTemp;
    LPTSTR pszRet;
    UINT cbAlloc = sizeof(TCHAR);       // for double NULL teriminaion of entire string

    // compute length of buffer to aloc
    for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenA(pszTemp) + 1)
    {
        // +1 for null teriminator
        cbAlloc += cbDestSpec + (lstrlenA(pszTemp) + 1) * sizeof(TCHAR);
    }

    pszRet = (LPTSTR)LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;

        for (pszTemp = pszDestSpecs; *pszTemp; pszTemp += lstrlenA(pszTemp) + 1)
        {
            // PathCombine requires dest buffer of MAX_PATH size or it'll rip in call
            // to PathCanonicalize (IsBadWritePtr)
            TCHAR szTempDest[MAX_PATH];
            WCHAR wszTemp[MAX_PATH];
            SHAnsiToUnicode(pszTemp, wszTemp, ARRAYSIZE(wszTemp));
            PathCombine(szTempDest, pszDestDir, wszTemp);
            // pszDest allocated exactly, strcpy okay.
            lstrcpy(pszDest, szTempDest);
            pszDest += lstrlen(pszDest) + 1;

            ASSERT((UINT)((BYTE *)pszDest - (BYTE *)pszRet) < cbAlloc);
            ASSERT(*pszDest == 0);      // zero init alloc
        }
        ASSERT((LPTSTR)((BYTE *)pszRet + cbAlloc - sizeof(TCHAR)) >= pszDest);
        ASSERT(*pszDest == 0);  // zero init alloc

    }
    return pszRet;
}

LPTSTR _GetDestNames(IDataObject *pdtobj, LPCTSTR pszPath)
{
    LPTSTR pszDestNames = NULL;

    STGMEDIUM medium;
    FORMATETC fmte = {g_cfFileNameMapW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (S_OK == pdtobj->GetData(&fmte, &medium))
    {
        pszDestNames = RemapDestNamesW(pszPath, (LPWSTR)GlobalLock(medium.hGlobal));
        ReleaseStgMediumHGLOBAL(medium.hGlobal, &medium);
    }
    else
    {
        fmte.cfFormat = g_cfFileNameMapA;
        if (S_OK == pdtobj->GetData(&fmte, &medium))
        {
            pszDestNames = RemapDestNamesA(pszPath, (LPSTR)GlobalLock(medium.hGlobal));
            ReleaseStgMediumHGLOBAL(medium.hGlobal, &medium);
        }
    }
    return pszDestNames;
}

BOOL _IsInSameFolder(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        for (UINT i = 0; i < pida->cidl; i++) 
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, i);
            if (pidl)
            {
                // if we're doing keyboard cut/copy/paste
                //  to and from the same directories
                // This is needed for common desktop support - BobDay/EricFlo
                if (AliasILIsParent(pidlFolder, pidl))
                {
                    bRet = TRUE;
                }
                ILFree(pidl);
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return bRet;
}

LPCTSTR _RootSpecialCase(LPCTSTR pszFiles, LPTSTR pszSrc, UINT cchSrc, LPTSTR pszDest, UINT cchDest)
{
    if ((1 == CountFiles(pszFiles)) &&
        PathIsRoot(pszFiles) &&
        (cchDest >= MAX_PATH) && (cchSrc >= MAX_PATH))
    {
        SHFILEINFO sfi;

        // NOTE: don't use SHGFI_USEFILEATTRIBUTES because the simple IDList
        // support for \\server\share produces the wrong name
        if (SHGetFileInfo(pszFiles, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME)) 
        {
            if (!(PCS_FATAL & PathCleanupSpec(pszDest, sfi.szDisplayName)))
            {
                PathAppend(pszDest, sfi.szDisplayName); // sub dir name based on source root path
                PathCombine(pszSrc, pszFiles, TEXT("*.*")); // all files on source
                pszFiles = pszSrc;
            }
        }
    }
    return pszFiles;
}

void CFSDropTarget::_MoveCopy(IDataObject *pdtobj, IFolderView* pfv, HDROP hDrop)
{
#ifdef DEBUG
    if (_hwnd == NULL)
    {
        TraceMsg(TF_GENERAL, "_MoveCopy() without an hwnd which will prevent displaying insert disk UI");
    }
#endif // DEBUG

    DRAGINFO di = { sizeof(di) };
    if (DragQueryInfo(hDrop, &di))
    {
        TCHAR szDest[MAX_PATH] = {0}; // zero init for dbl null termination

        _GetPath(szDest, ARRAYSIZE(szDest));

        switch (_idCmd) 
        {
        case DDIDM_MOVE:

            if (_fSameHwnd)
            {
                _MoveSelectIcons(pdtobj, pfv, NULL, NULL, TRUE, hDrop);
                break;
            }

            // fall through...

        case DDIDM_COPY:
            {
                TCHAR szAltSource[MAX_PATH] = {0};  // zero init for dbl null termination
                LPCTSTR pszSource = _RootSpecialCase(di.lpFileList, szAltSource, ARRAYSIZE(szAltSource), szDest, ARRAYSIZE(szDest));

                SHFILEOPSTRUCT fo = 
                {
                    _hwnd,
                    (DDIDM_COPY == _idCmd) ? FO_COPY : FO_MOVE,
                    pszSource,
                    szDest,
                    FOF_WANTMAPPINGHANDLE | FOF_ALLOWUNDO | FOF_NOCONFIRMMKDIR
                };
                if (fo.wFunc == FO_MOVE && IsFolderSecurityModeOn())
                {
                    fo.fFlags |= FOF_NOCOPYSECURITYATTRIBS;
                }

                // if they are in the same hwnd or to and from
                // the same directory, turn on the automatic rename on collision flag
                if (_fSameHwnd || 
                    ((DDIDM_COPY == _idCmd) && _IsInSameFolder(_GetIDList(), pdtobj)))
                {
                    // do rename on collision for copy;
                    fo.fFlags |=  FOF_RENAMEONCOLLISION;
                }

                // see if there is a rename mapping from recycle bin (or someone else)

                LPTSTR pszDestNames = _GetDestNames(pdtobj, szDest);
                if (pszDestNames)
                {
                    fo.pTo = pszDestNames;
                    fo.fFlags |= FOF_MULTIDESTFILES;
                    fo.fFlags &= ~FOF_ALLOWUNDO;    // HACK, this came from the recycle bin, don't allow undo
                }

                {
                    static UINT s_cfFileOpFlags = 0;
                    if (0 == s_cfFileOpFlags)
                        s_cfFileOpFlags = RegisterClipboardFormat(TEXT("FileOpFlags"));

                    fo.fFlags = (FILEOP_FLAGS)DataObj_GetDWORD(pdtobj, s_cfFileOpFlags, fo.fFlags);
                }

                // Check if there were any errors
                if (SHFileOperation(&fo) == 0 && !fo.fAnyOperationsAborted)
                {
                    if (_fBkDropTarget)
                        ShellFolderView_SetRedraw(_hwnd, 0);

                    SHChangeNotifyHandleEvents();   // force update now
                    if (_fBkDropTarget) 
                    {
                        _MoveSelectIcons(pdtobj, pfv, fo.hNameMappings, pszDestNames, _fDragDrop, hDrop);
                        ShellFolderView_SetRedraw(_hwnd, TRUE);
                    }
                }

                if (fo.hNameMappings)
                    SHFreeNameMappings(fo.hNameMappings);

                if (pszDestNames)
                {
                    LocalFree((HLOCAL)pszDestNames);

                    // HACK, this usually comes from the bitbucket
                    // but in our shell, we don't handle the moves from the source
                    if (DDIDM_MOVE == _idCmd)
                        BBCheckRestoredFiles(pszSource);
                }
            }

            break;
        }
        SHFree(di.lpFileList);
    }
}

const UINT c_rgFolderShortcutTargets[] = {
    CSIDL_STARTMENU,
    CSIDL_COMMON_STARTMENU,
    CSIDL_PROGRAMS,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_NETHOOD,
};

BOOL _ShouldCreateFolderShortcut(LPCTSTR pszFolder)
{
    return PathIsEqualOrSubFolderOf(pszFolder, c_rgFolderShortcutTargets, ARRAYSIZE(c_rgFolderShortcutTargets));
}

void CFSDropTarget::_DoDrop(IDataObject *pdtobj, IFolderView* pfv)
{
    HRESULT hr = E_FAIL;

    // Sleep(10 * 1000);   // to debug async case

    TCHAR szPath[MAX_PATH];   
    _GetPath(szPath, ARRAYSIZE(szPath));
    SHCreateDirectory(NULL, szPath);      // if this fails we catch it later
    
    switch (_idCmd)
    {
    case DDIDM_SYNCCOPY:
    case DDIDM_SYNCCOPYTYPE:
        if (_IsBriefcaseTarget())
        {
            IBriefcaseStg *pbrfstg;
            if (SUCCEEDED(CreateBrfStgFromPath(szPath, _hwnd, &pbrfstg)))
            {
                hr = pbrfstg->AddObject(pdtobj, NULL,
                    (DDIDM_SYNCCOPYTYPE == _idCmd) ? AOF_FILTERPROMPT : AOF_DEFAULT,
                    _hwnd);
                pbrfstg->Release();
            }
        }
        else
        {
            // Perform a sneakernet addition to the briefcase
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                // Is there a briefcase root in this pdtobj?
                IBriefcaseStg *pbrfstg;
                if (SUCCEEDED(CreateBrfStgFromIDList(HIDA_GetPIDLFolder(pida), _hwnd, &pbrfstg)))
                {
                    hr = pbrfstg->AddObject(pdtobj, szPath,
                        (DDIDM_SYNCCOPYTYPE == _idCmd) ? AOF_FILTERPROMPT : AOF_DEFAULT,
                        _hwnd);
                    pbrfstg->Release();
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DDIDM_COPY:
    case DDIDM_MOVE:
        {
            STGMEDIUM medium;
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            hr = pdtobj->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                _MoveCopy(pdtobj, pfv, (HDROP)medium.hGlobal);
                ReleaseStgMedium(&medium);
            }
        }
        break;

    case DDIDM_LINK:
        {
            int i = 0;
            LPITEMIDLIST *ppidl = NULL;

            if (_fBkDropTarget)
            {
                i = DataObj_GetHIDACount(pdtobj);
                ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(*ppidl) * i);
            }

            // _grfKeyStateLast of 0 means this was a simulated drop
            UINT uCreateFlags = _grfKeyStateLast && !(_dwEffectFolder & DROPEFFECT_LINK) ? SHCL_USETEMPLATE : 0;

            if (_ShouldCreateFolderShortcut(szPath))
                uCreateFlags |= SHCL_MAKEFOLDERSHORTCUT;

            ShellFolderView_SetRedraw(_hwnd, FALSE);
            // passing ppidl == NULL is correct in failure case
            hr = SHCreateLinks(_hwnd, szPath, pdtobj, uCreateFlags, ppidl);
            if (ppidl)
            {
                if (pfv)
                    PositionItems(pfv, (LPCITEMIDLIST*)ppidl, i, pdtobj, &_ptDrop);

                FreeIDListArray(ppidl, i);
            }
            ShellFolderView_SetRedraw(_hwnd, TRUE);
        }
        break;
    }

    if (SUCCEEDED(hr) && _dwEffect)
    {
        DataObj_SetDWORD(pdtobj, g_cfLogicalPerformedDropEffect, _dwEffect);
        DataObj_SetDWORD(pdtobj, g_cfPerformedDropEffect, _dwEffect);
    }

    SHChangeNotifyHandleEvents();       // force update now
}

DWORD CALLBACK CFSDropTarget::_DoDropThreadProc(void *pv)
{
    DROPTHREADPARAMS *pdtp = (DROPTHREADPARAMS *)pv;

    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream(pdtp->pstmDataObj, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        IFolderView* pfv;
        if (FAILED(CoGetInterfaceAndReleaseStream(pdtp->pstmFolderView, IID_PPV_ARG(IFolderView, &pfv))))
            pfv = NULL;

        pdtp->pThis->_DoDrop(pdtobj, pfv);

        if (pfv)
            pfv->Release();

        pdtp->pstmFolderView = NULL;  // stream now invalid; CoGetInterfaceAndReleaseStream already released it
        pdtobj->Release();
    }

    pdtp->pstmDataObj    = NULL;  // stream now invalid; CoGetInterfaceAndReleaseStream already released it
    _FreeThreadParams(pdtp);

    CoFreeUnusedLibraries();
    return 0;
}

// REARCHITECT: view and drop related helpers, these use the ugly old private defview messages
// we should replace the usage of this stuff with IShellFolderView programming


// create the pidl array that contains the destination file names. this is
// done by taking the source file names, and translating them through the
// name mapping returned by the copy engine.
//
//
// in:
//      hDrop           HDROP containing files recently moved/copied
//      hNameMap   used to translate names
//
// out:
//      *pppidl         id array of length return value
//      # of items in pppida

//
//  WARNING!  You must use the provided HDROP.  Do not attempt to ask the
//  data object for a HDROP or HIDA or WS_FTP will break!  They don't like
//  it if you ask them for HDROP/HIDA, move the files to a new location
//  (via the copy engine), and then ask them for HDROP/HIDA a second time.
//  They notice that "Hey, those files I downloaded last time are gone!"
//  and then get confused.
//
STDAPI_(int) CreateMoveCopyList(HDROP hDrop, void *hNameMap, LPITEMIDLIST **pppidl)
{
    int nItems = 0;

    if (hDrop)
    {
        nItems = DragQueryFile(hDrop, (UINT)-1, NULL, 0);
        *pppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, nItems * sizeof(*pppidl));
        if (*pppidl)
        {
            for (int i = nItems - 1; i >= 0; i--)
            {
                TCHAR szPath[MAX_PATH];
                DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath));
                _MapName(hNameMap, szPath, ARRAYSIZE(szPath));
                (*pppidl)[i] = SHSimpleIDListFromPath(szPath);
            }
        }
    }
    return nItems;
}

// this is really not related to CFSFolder. it is generic over any view
// REARCHITECT: convert view hwnd programming to site pointer

STDAPI_(void) PositionFileFromDrop(HWND hwnd, LPCTSTR pszFile, DROPHISTORY *pdh)
{
    LPITEMIDLIST pidl = SHSimpleIDListFromPath(pszFile);
    if (pidl)
    {
        LPITEMIDLIST pidlNew = ILFindLastID(pidl);
        HWND hwndView = ShellFolderViewWindow(hwnd);
        SFM_SAP sap;
        
        SHChangeNotifyHandleEvents();
        
        // Fill in some easy SAP fields first.
        sap.uSelectFlags = SVSI_SELECT;
        sap.fMove = TRUE;
        sap.pidl = pidlNew;

        // Now compute the x,y coordinates.
        // If we have a drop history, use it to determine the
        // next point.

        if (pdh)
        {
            // fill in the anchor point first...
            if (!pdh->fInitialized)
            {
                ITEMSPACING is;
                
                ShellFolderView_GetDropPoint(hwnd, &pdh->ptOrigin);
                
                pdh->pt = pdh->ptOrigin;    // Compute the first point.
                
                // Compute the point deltas.
                if (ShellFolderView_GetItemSpacing(hwnd, &is))
                {
                    pdh->cxItem = is.cxSmall;
                    pdh->cyItem = is.cySmall;
                    pdh->xDiv = is.cxLarge;
                    pdh->yDiv = is.cyLarge;
                    pdh->xMul = is.cxSmall;
                    pdh->yMul = is.cySmall;
                }
                else
                {
                    pdh->cxItem = g_cxIcon;
                    pdh->cyItem = g_cyIcon;
                    pdh->xDiv = pdh->yDiv = pdh->xMul = pdh->yMul = 1;
                }
                
                // First point gets special flags.
                sap.uSelectFlags |= SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;
                
                pdh->fInitialized = TRUE;   // We be initialized.
            }
            // if we have no list of offsets, then just inc by icon size..
            else if ( !pdh->pptOffset )
            {
                // Simple computation of the next point.
                pdh->pt.x += pdh->cxItem;
                pdh->pt.y += pdh->cyItem;
            }
            
            // do this after the above stuff so that we always get our position relative to the anchor
            // point, if we use the anchor point as the first one things get screwy...
            if (pdh->pptOffset)
            {
                // Transform the old offset to our coordinates.
                pdh->pt.x = ((pdh->pptOffset[pdh->iItem].x * pdh->xMul) / pdh->xDiv) + pdh->ptOrigin.x;
                pdh->pt.y = ((pdh->pptOffset[pdh->iItem].y * pdh->yMul) / pdh->yDiv) + pdh->ptOrigin.y;
            }
            
            sap.pt = pdh->pt;   // Copy the next point from the drop history.
        }
        else
        {
            // Preinitialize this puppy in case the folder view doesn't
            // know what the drop point is (e.g., if it didn't come from
            // a drag/drop but rather from a paste or a ChangeNotify.)
            sap.pt.x = 0x7FFFFFFF;      // "don't know"
            sap.pt.y = 0x7FFFFFFF;

            // Get the drop point, conveniently already in
            // defview's screen coordinates.
            //
            // pdv->bDropAnchor should be TRUE at this point,
            // see DefView's GetDropPoint() for details.

            ShellFolderView_GetDropPoint(hwnd, &sap.pt);

            // Only point gets special flags.
            sap.uSelectFlags |= SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;
        }
        
        SendMessage(hwndView, SVM_SELECTANDPOSITIONITEM, 1, (LPARAM)&sap);
        
        ILFree(pidl);
    }
}

//
// Class used to scale and position items for drag and drops.  Handles
// scaling between different sized views.
//

//
// Bug 165413 (edwardp 8/16/00) Convert IShellFolderView usage in CItemPositioning to IFolderView
//

class CItemPositioning
{
    // Methods
public:
    CItemPositioning(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ppt);

    void DragSetPoints(void);
    void DropPositionItems(void);

private:

    typedef enum
    {
        DPIWP_AUTOARRANGE,
        DPIWP_DATAOBJ,
    } DPIWP;

    BOOL   _DragShouldPositionItems(void);
    BOOL   _DragGetPoints(POINT* apts);
    void   _DragPositionPoints(POINT* apts);
    void   _DragScalePoints(POINT* apts);

    POINT* _DropGetPoints(DPIWP dpiwp, STGMEDIUM* pMediam);
    void   _DropFreePoints(DPIWP dpiwp, POINT* apts, STGMEDIUM* pmedium);
    void   _DropPositionPoints(POINT* apts);
    void   _DropScalePoints(POINT* apts);
    void   _DropPositionItemsWithPoints(DPIWP dpiwp);
    void   _DropPositionItems(POINT* apts);

    void   _ScalePoints(POINT* apts, POINT ptFrom, POINT ptTo);
    POINT* _SkipAnchorPoint(POINT* apts);

    // Data
private:
    IFolderView*      _pfv;
    LPCITEMIDLIST*    _apidl;
    UINT              _cidl;
    IDataObject*      _pdtobj;
    POINT*            _ppt;
};

CItemPositioning::CItemPositioning(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ppt)
{
    ASSERT(pifv);
    ASSERT(apidl);
    ASSERT(cidl);
    ASSERT(pdtobj);

    _pfv    = pifv;    // No need to addref as long as CPostionItems is only used locally.
    _apidl  = apidl;
    _cidl   = cidl;
    _pdtobj = pdtobj;  // No need to addref as long as CPostionItems is only used locally.
    _ppt    = ppt;
}


void CItemPositioning::DragSetPoints(void)
{
    if (_DragShouldPositionItems())
    {
        POINT* apts = (POINT*) GlobalAlloc(GPTR, sizeof(POINT) * (_cidl + 1));

        if (apts)
        {
            if (_DragGetPoints(apts))
            {
                _DragPositionPoints(_SkipAnchorPoint(apts));
                _DragScalePoints(_SkipAnchorPoint(apts));

                if (FAILED(DataObj_SetGlobal(_pdtobj, g_cfOFFSETS, apts)))
                    GlobalFree((HGLOBAL)apts);
            }
            else
            {
                GlobalFree((HGLOBAL)apts);
            }
        }
    }
}

BOOL CItemPositioning::_DragShouldPositionItems()
{
    // Don't position multiple items if they come from a view that doesn't allow
    // positioning.  The position information is not likely to be usefull in this
    // case.
    // Always position single items so they show up at the drop point.
    // Don't bother with position data for 100 or more items.

    return ((S_OK == _pfv->GetSpacing(NULL)) || 1 == _cidl) && _cidl < 100;
}

BOOL CItemPositioning::_DragGetPoints(POINT* apts)
{
    BOOL fRet = TRUE;

    // The first point is the anchor.
    apts[0] = *_ppt;

    for (UINT i = 0; i < _cidl; i++)
    {
        if (FAILED(_pfv->GetItemPosition(_apidl[i], &apts[i + 1])))
        {
            if (1 == _cidl)
            {
                apts[i + 1].x = _ppt->x;
                apts[i + 1].y = _ppt->y;
            }
            else
            {
                fRet = FALSE;
            }
        }
    }

    return fRet;
}

void CItemPositioning::_DragPositionPoints(POINT* apts)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x -= _ppt->x;
        apts[i].y -= _ppt->y;
    }
}

void CItemPositioning::_DragScalePoints(POINT* apts)
{
    POINT ptFrom;
    POINT ptTo;

    _pfv->GetSpacing(&ptFrom);
    _pfv->GetDefaultSpacing(&ptTo);

    if (ptFrom.x != ptTo.x || ptFrom.y != ptTo.y)
        _ScalePoints(apts, ptFrom, ptTo);
}

void CItemPositioning::DropPositionItems(void)
{
    if (S_OK == _pfv->GetAutoArrange())
    {
        _DropPositionItemsWithPoints(DPIWP_AUTOARRANGE);
    }
    else if (S_OK == _pfv->GetSpacing(NULL) && _ppt)
    {
        _DropPositionItemsWithPoints(DPIWP_DATAOBJ);
    }
    else
    {
        _DropPositionItems(NULL);
    }
}

void CItemPositioning::_DropPositionItemsWithPoints(DPIWP dpiwp)
{
    STGMEDIUM medium;
    POINT*    apts = _DropGetPoints(dpiwp, &medium);

    if (apts)
    {
        if (DPIWP_DATAOBJ == dpiwp)
        {
            _DropScalePoints(_SkipAnchorPoint(apts));
            _DropPositionPoints(_SkipAnchorPoint(apts));
        }

        _DropPositionItems(_SkipAnchorPoint(apts));

        _DropFreePoints(dpiwp, apts, &medium);
    }
    else if (_ppt)
    {
        POINT *ppts = (POINT *)LocalAlloc(LPTR, _cidl * sizeof(POINT));

        if (ppts)
        {
            POINT   pt;

            _pfv->GetDefaultSpacing(&pt);

            for (UINT i = 0; i < _cidl; i++)
            {
                ppts[i].x = (-g_cxIcon / 2) + (i * pt.x);
                ppts[i].y = (-g_cyIcon / 2) + (i * pt.y);
            }
            _DropScalePoints(ppts);
            _DropPositionPoints(ppts);
            _DropPositionItems(ppts);

            LocalFree(ppts);
        }
        else
        {
            _DropPositionItems(NULL);
        }
    }
    else
    {
        _DropPositionItems(NULL);
    }
}

void CItemPositioning::_DropPositionItems(POINT* apts)
{
    // Drop the first item with special selection flags.
    LPCITEMIDLIST pidl = ILFindLastID(_apidl[0]);
    _pfv->SelectAndPositionItems(1, &pidl, apts, SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED);

    // Drop the rest of the items.
    if (_cidl > 1)
    {
        LPCITEMIDLIST* apidl = (LPCITEMIDLIST*)LocalAlloc(GPTR, sizeof(LPCITEMIDLIST) * (_cidl - 1));

        if (apidl)
        {
            for (UINT i = 1; i < _cidl; i++)
                apidl[i - 1] = ILFindLastID(_apidl[i]);

            _pfv->SelectAndPositionItems(_cidl - 1, apidl, (apts) ? &apts[1] : NULL, SVSI_SELECT);

            LocalFree(apidl);
        }
    }
}

POINT* CItemPositioning::_DropGetPoints(DPIWP dpiwp, STGMEDIUM* pmedium)
{
    POINT* pptRet = NULL;

    if (DPIWP_DATAOBJ == dpiwp)
    {
        FORMATETC fmte = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        if (SUCCEEDED(_pdtobj->GetData(&fmte, pmedium)))
        {
            if (pmedium->hGlobal)
            {
                POINT *pptSrc;

                pptSrc = (POINT *)GlobalLock(pmedium->hGlobal);

                if (pptSrc)
                {
                    pptRet = (POINT*)LocalAlloc(GPTR, (_cidl + 1) * sizeof(POINT));

                    if (pptRet)
                    {
                        for (UINT i = 0; i <= _cidl; i++)
                        {
                            pptRet[i] = pptSrc[i];
                        }
                    }

                    GlobalUnlock(pptSrc);
                }
            }

            ReleaseStgMedium(pmedium);
        }
    }
    else if (DPIWP_AUTOARRANGE == dpiwp)
    {
        if (_ppt)
        {
            pptRet = (POINT*)LocalAlloc(GPTR, (_cidl + 1) * sizeof(POINT));

            if (pptRet)
            {
                // skip first point to simulate data object use of first point

                for (UINT i = 1; i <= _cidl; i++)
                {
                    pptRet[i] = *_ppt;
                }
            }
        }
    }

    return pptRet;
}

void CItemPositioning::_DropFreePoints(DPIWP dpiwp, POINT* apts, STGMEDIUM* pmedium)
{
    LocalFree(apts);
}

void CItemPositioning::_DropScalePoints(POINT* apts)
{
    POINT ptFrom;
    POINT ptTo;

    _pfv->GetDefaultSpacing(&ptFrom);
    _pfv->GetSpacing(&ptTo);

    if (ptFrom.x != ptTo.x || ptFrom.y != ptTo.y)    
        _ScalePoints(apts, ptFrom, ptTo);
}

void CItemPositioning::_DropPositionPoints(POINT* apts)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x += _ppt->x;
        apts[i].y += _ppt->y;
    }
}

void CItemPositioning::_ScalePoints(POINT* apts, POINT ptFrom, POINT ptTo)
{
    for (UINT i = 0; i < _cidl; i++)
    {
        apts[i].x = MulDiv(apts[i].x, ptTo.x, ptFrom.x);
        apts[i].y = MulDiv(apts[i].y, ptTo.y, ptFrom.y);
    }
}

POINT* CItemPositioning::_SkipAnchorPoint(POINT* apts)
{
    return &apts[1];
}



STDAPI_(void) SetPositionItemsPoints(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrag)
{
    CItemPositioning cpi(pifv, apidl, cidl, pdtobj, ptDrag);
    cpi.DragSetPoints();
}

STDAPI_(void) PositionItems(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrop)
{
    CItemPositioning cip(pifv, apidl, cidl, pdtobj, ptDrop);
    cip.DropPositionItems();
}

//
// Don't use PositionItems_DontUse.  Instead convert to PositionItems.
// PositionItems_DontUse will be removed.
//
// Bug#163533 (edwardp 8/15/00) Remove this code. 

STDAPI_(void) PositionItems_DontUse(HWND hwndOwner, UINT cidl, const LPITEMIDLIST *ppidl, IDataObject *pdtobj, POINT *pptOrigin, BOOL fMove, BOOL fUseExactOrigin)
{
    if (!ppidl || !IsWindow(hwndOwner))
        return;

    SFM_SAP *psap = (SFM_SAP *)GlobalAlloc(GPTR, sizeof(SFM_SAP) * cidl);
    if (psap) 
    {
        UINT i, cxItem, cyItem;
        int xMul, yMul, xDiv, yDiv;
        STGMEDIUM medium;
        POINT *pptItems = NULL;
        POINT pt;
        ITEMSPACING is;
        // select those objects;
        // this had better not fail
        HWND hwnd = ShellFolderViewWindow(hwndOwner);

        if (fMove)
        {
            FORMATETC fmte = {g_cfOFFSETS, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)) &&
                medium.hGlobal)
            {
                pptItems = (POINT *)GlobalLock(medium.hGlobal);
                pptItems++; // The first point is the anchor
            }
            else
            {
                // By default, drop at (-g_cxIcon/2, -g_cyIcon/2), and increase
                // x and y by icon dimension for each icon
                pt.x = ((-3 * g_cxIcon) / 2) + pptOrigin->x;
                pt.y = ((-3 * g_cyIcon) / 2) + pptOrigin->y;
                medium.hGlobal = NULL;
            }

            if (ShellFolderView_GetItemSpacing(hwndOwner, &is))
            {
                xDiv = is.cxLarge;
                yDiv = is.cyLarge;
                xMul = is.cxSmall;
                yMul = is.cySmall;
                cxItem = is.cxSmall;
                cyItem = is.cySmall;
            }
            else
            {
                xDiv = yDiv = xMul = yMul = 1;
                cxItem = g_cxIcon;
                cyItem = g_cyIcon;
            }
        }

        for (i = 0; i < cidl; i++)
        {
            if (ppidl[i])
            {
                psap[i].pidl = ILFindLastID(ppidl[i]);
                psap[i].fMove = fMove;
                if (fMove)
                {
                    if (fUseExactOrigin)
                    {
                        psap[i].pt = *pptOrigin;
                    }
                    else
                    {
                        if (pptItems)
                        {
                            psap[i].pt.x = ((pptItems[i].x * xMul) / xDiv) + pptOrigin->x;
                            psap[i].pt.y = ((pptItems[i].y * yMul) / yDiv) + pptOrigin->y;
                        }
                        else
                        {
                            pt.x += cxItem;
                            pt.y += cyItem;
                            psap[i].pt = pt;
                        }
                    }
                }

                // do regular selection from all of the rest of the items
                psap[i].uSelectFlags = SVSI_SELECT;
            }
        }

        // do this special one for the first only
        psap[0].uSelectFlags = SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED;

        SendMessage(hwnd, SVM_SELECTANDPOSITIONITEM, cidl, (LPARAM)psap);

        if (fMove && medium.hGlobal)
            ReleaseStgMediumHGLOBAL(NULL, &medium);

        GlobalFree(psap);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\format.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "mtpt.h"
#include "hwcmmn.h"
#pragma  hdrstop

#include "apithk.h"

const static DWORD FmtaIds[] = 
{
    IDOK,               IDH_FORMATDLG_START,
    IDCANCEL,           IDH_CANCEL,
    IDC_CAPCOMBO,       IDH_FORMATDLG_CAPACITY,
    IDC_FSCOMBO,        IDH_FORMATDLG_FILESYS,
    IDC_ASCOMBO,        IDH_FORMATDLG_ALLOCSIZE,
    IDC_VLABEL,         IDH_FORMATDLG_LABEL,
    IDC_GROUPBOX_1,     IDH_COMM_GROUPBOX,
    IDC_QFCHECK,        IDH_FORMATDLG_QUICKFULL,
    IDC_ECCHECK,        IDH_FORMATDLG_COMPRESS,
    IDC_FMTPROGRESS,    IDH_FORMATDLG_PROGRESS,
    0,0
};

const static DWORD ChkaIds[] = 
{
    IDOK,               IDH_CHKDSKDLG_START,
    IDCANCEL,           IDH_CHKDSKDLG_CANCEL,
    IDC_GROUPBOX_1,     IDH_COMM_GROUPBOX,
    IDC_FIXERRORS,      IDH_CHKDSKDLG_FIXERRORS,
    IDC_RECOVERY,       IDH_CHKDSKDLG_SCAN,
    IDC_CHKDSKPROGRESS, IDH_CHKDSKDLG_PROGRESS,
    IDC_PHASE,          -1,
    0,0
};

// The following structure encapsulates our calling into the FMIFS.DLL
typedef struct
{
    HINSTANCE                 hFMIFS_DLL;
    PFMIFS_FORMATEX_ROUTINE   FormatEx;
    PFMIFS_QSUPMEDIA_ROUTINE  QuerySupportedMedia;
    PFMIFS_ENABLECOMP_ROUTINE EnableVolumeCompression;
    PFMIFS_CHKDSKEX_ROUTINE   ChkDskEx;
    PFMIFS_QUERY_DEVICE_INFO_ROUTINE    QueryDeviceInformation;
} FMIFS;

typedef
HRESULT
(*PDISKCOPY_MAKEBOOTDISK_ROUTINE)(
    IN  HINSTANCE hInstance, 
    IN  UINT iDrive, 
    IN  BOOL* pfCancelled, 
    IN  FMIFS_CALLBACK pCallback
    );

// The following structure encapsulates our calling into the DISKCOPY.DLL
typedef struct
{
    HINSTANCE                        hDISKCOPY_DLL;
    PDISKCOPY_MAKEBOOTDISK_ROUTINE   MakeBootDisk;
} DISKCOPY;

// This structure described the current formatting session
typedef struct
{
    LONG    cRef;                  // reference count on this structure
    UINT    drive;                 // 0-based index of drive to format
    UINT    fmtID;                 // Last format ID
    UINT    options;               // options passed to us via the API
    FMIFS   fmifs;                 // above
    DISKCOPY diskcopy;             // above
    HWND    hDlg;                  // handle to the format dialog
    BOOL    fIsFloppy;             // TRUE -> its a floppy
    BOOL    fIs35HDFloppy;         // TRUE -> its a standard 3.5" High Density floppy
    BOOL    fIsMemoryStick;        // TRUE -> its a memory stick (special formatting only)
    BOOL    fIsNTFSBlocked;        // TRUE -> its a NTFS not-supported device
    BOOL    fEnableComp;           // Last "Enable Comp" choice from user
    BOOL    fCancelled;            // User cancelled the last format
    BOOL    fShouldCancel;         // User has clicked cancel; pending abort
    BOOL    fWasFAT;               // Was it FAT originally?
    BOOL    fFinishedOK;           // Did format complete sucessfully?
    BOOL    fErrorAlready;         // Did we put up an error dialog already?
    BOOL    fDisabled;             // Is rgfControlEnabled[] valid?
    DWORD   dwClusterSize;         // Orig NT cluster size, or last choice
    WCHAR   wszVolName[MAX_PATH];  // Volume Label
    WCHAR   wszDriveName[4];       // Root path to drive (eg: A:\)
    HANDLE  hThread;               // Handle of format thread

    // Array of media types supported by the device
    // for NT5, we have an expanded list that includes japanese types.
    FMIFS_MEDIA_TYPE rgMedia[IDS_FMT_MEDIA_J22-IDS_FMT_MEDIA_J0];

    // Used to cache the enabled/disabled state of the dialog controls
    BOOL    rgfControlEnabled[DLG_FORMATDISK_NUMCONTROLS];

    // should we create a boot disk rather than a traditional format
    BOOL    fMakeBootDisk;

} FORMATINFO;

//
// An enumeration to make the filesystem combo-box code more readble
//

typedef enum tagFILESYSENUM
{
    e_FAT = 0,
    e_NTFS,
    e_FAT32
} FILESYSENUM;

#define FS_STR_NTFS  TEXT("NTFS")
#define FS_STR_FAT32 TEXT("FAT32")
#define FS_STR_FAT   TEXT("FAT")

//
// Private WM_USER messages we will use.  For some unknown reason, USER sends
// us a WM_USER during initialization, so I start my private messages at
// WM_USER + 0x0100
//

typedef enum tagPRIVMSGS
{
    PWM_FORMATDONE = WM_USER + 0x0100,
    PWM_CHKDSKDONE
} PRIVMSGS;

//
//  Synopsis:   Loads FMIFS.DLL and sets up the function entry points for
//              the member functions we are interested in.
//
HRESULT LoadFMIFS(FMIFS *pFMIFS)
{
    HRESULT hr = S_OK;

    //
    // Load the FMIFS DLL and query for the entry points we need
    //

    // SECURITY: what non-relative path do we use that will work on ia64 too?
    if (NULL == (pFMIFS->hFMIFS_DLL = LoadLibrary(TEXT("FMIFS.DLL"))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->FormatEx = (PFMIFS_FORMATEX_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "FormatEx")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->QuerySupportedMedia = (PFMIFS_QSUPMEDIA_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "QuerySupportedMedia")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->EnableVolumeCompression = (PFMIFS_ENABLECOMP_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "EnableVolumeCompression")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->ChkDskEx = (PFMIFS_CHKDSKEX_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "ChkdskEx")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pFMIFS->QueryDeviceInformation = (PFMIFS_QUERY_DEVICE_INFO_ROUTINE)
                GetProcAddress(pFMIFS->hFMIFS_DLL, "QueryDeviceInformation")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If anything failed, and we've got the DLL loaded, release the DLL
    //

    if (hr != S_OK && pFMIFS->hFMIFS_DLL)
    {
       FreeLibrary(pFMIFS->hFMIFS_DLL);
    }
    return hr;
}

//
//  Synopsis:   Loads DISKCOPY.DLL and sets up the function entry points for
//              the member functions we are interested in.
//
HRESULT LoadDISKCOPY(DISKCOPY *pDISKCOPY)
{
    HRESULT hr = S_OK;

    //
    // Load the DISKCOPY DLL and query for the entry points we need
    //

    // SECURITY: what non-relative path do we use that will work on ia64 too?
    if (NULL == (pDISKCOPY->hDISKCOPY_DLL = LoadLibrary(TEXT("DISKCOPY.DLL"))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (NULL == (pDISKCOPY->MakeBootDisk = (PDISKCOPY_MAKEBOOTDISK_ROUTINE)
                GetProcAddress(pDISKCOPY->hDISKCOPY_DLL, MAKEINTRESOURCEA(1)))) //MakeBootDisk is at ordinal 1 in diskcopy.dll
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If anything failed, and we've got the DLL loaded, release the DLL
    //

    if (hr != S_OK && pDISKCOPY->hDISKCOPY_DLL)
    {
       FreeLibrary(pDISKCOPY->hDISKCOPY_DLL);
    }
    return hr;
}

void AddRefFormatInfo(FORMATINFO *pFormatInfo)
{
    InterlockedIncrement(&pFormatInfo->cRef);
}

void ReleaseFormatInfo(FORMATINFO *pFormatInfo)
{
    ASSERT( 0 != pFormatInfo->cRef );
    if (InterlockedDecrement(&pFormatInfo->cRef) == 0) 
    {
        if (pFormatInfo->fmifs.hFMIFS_DLL)
        {
            FreeLibrary(pFormatInfo->fmifs.hFMIFS_DLL);
        }

        if (pFormatInfo->diskcopy.hDISKCOPY_DLL)
        {
            FreeLibrary(pFormatInfo->diskcopy.hDISKCOPY_DLL);
        }

        if (pFormatInfo->hThread)
        {
            CloseHandle(pFormatInfo->hThread);
        }

        LocalFree(pFormatInfo);
    }
}

//
// Thread-Local Storage index for our FORMATINFO structure pointer
//
static DWORD g_iTLSFormatInfo = 0;
static LONG  g_cTLSFormatInfo = 0;  // Usage count

//  Synopsis:   Allocates a thread-local index slot for this thread's
//              FORMATINFO pointer, if the index doesn't already exist.
//              In any event, stores the FORMATINFO pointer in the slot
//              and increments the index's usage count.
//
//  Arguments:  [pFormatInfo] -- The pointer to store
//
//  Returns:    HRESULT
//
HRESULT StuffFormatInfoPtr(FORMATINFO *pFormatInfo)
{
    HRESULT hr = S_OK;

    // Allocate an index slot for our thread-local FORMATINFO pointer, if one
    // doesn't already exist, then stuff our FORMATINFO ptr at that index.
    ENTERCRITICAL;
    if (0 == g_iTLSFormatInfo)
    {
        if (0xFFFFFFFF == (g_iTLSFormatInfo = TlsAlloc()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        g_cTLSFormatInfo = 0;
    }
    if (S_OK == hr)
    {
        if (TlsSetValue(g_iTLSFormatInfo, (void *) pFormatInfo))
        {
           g_cTLSFormatInfo++;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    LEAVECRITICAL;

    return hr;
}

//  Synopsis:   Decrements the usage count on our thread-local storage
//              index, and if it goes to zero the index is free'd
//
//  Arguments:  [none]
//
//  Returns:    none
//
void UnstuffFormatInfoPtr()
{
    ENTERCRITICAL;
    if (0 == --g_cTLSFormatInfo)
    {
        TlsFree(g_iTLSFormatInfo);
        g_iTLSFormatInfo = 0;
    }
    LEAVECRITICAL;
}

//  Synopsis:   Retrieves this threads FORMATINFO ptr by grabbing the
//              thread-local value previously stuff'd
//
//  Arguments:  [none]
//
//  Returns:    The pointer, of course
//
FORMATINFO *GetFormatInfoPtr()
{
    return (FORMATINFO*)TlsGetValue(g_iTLSFormatInfo);
}



//  Synopsis:   Ghosts all controls except "Cancel", saving their
//              previous state in the FORMATINFO structure
//
//  Arguments:  [pFormatInfo] -- Describes a format dialog session
//
//  Notes:      Also changes "Close" button text to read "Cancel"
//
void DisableControls(FORMATINFO *pFormatInfo)
{
    WCHAR wszCancel[64];

    // Do this only if we haven't disabled the controls yet, otherwise
    // we double-disable and our rgfControlEnabled[] array gets corrupted.
    if (!pFormatInfo->fDisabled)
    {
        int i;
        pFormatInfo->fDisabled = TRUE;
        for (i = 0; i < DLG_FORMATDISK_NUMCONTROLS; i++)
        {
            HWND hControl = GetDlgItem(pFormatInfo->hDlg, i + DLG_FORMATDISK_FIRSTCONTROL);
            pFormatInfo->rgfControlEnabled[i] = !EnableWindow(hControl, FALSE);
        }
    }

    EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDOK), FALSE);

    LoadString(HINST_THISDLL, IDS_FMT_CANCEL, wszCancel, ARRAYSIZE(wszCancel));
    SetWindowText(GetDlgItem(pFormatInfo->hDlg, IDCANCEL), wszCancel);
}

//  Synopsis:   Restores controls to the enabled/disabled state they were
//              before a previous call to DisableControls().
//
//  Arguments:  [pFormatInfo] -- Decribes a format dialog session
//              [fReady] - If TRUE, then enable everything
//                         If FALSE, then enable combo boxes but leave
//                         buttons in limbo because there is still a format
//                         pending
//
//  Notes:      Also changes "Cancel" button to say "Close"
//              Also sets focus to Cancel button instead of Start button
//
//--------------------------------------------------------------------------
void EnableControls(FORMATINFO *pFormatInfo, BOOL fReady)
{
    WCHAR wszClose[64];
    int i;
    HWND hwnd;

    // Do this only if we have valid info in rgfControlEnabled[].
    // This catches the case where we give up on a format because it is
    // unstuck, and then finally it unsticks itself and tells us,
    // so we go and re-enable a second time.
    if (pFormatInfo->fDisabled)
    {
        pFormatInfo->fDisabled = FALSE;

        for (i = 0; i < DLG_FORMATDISK_NUMCONTROLS; i++)
        {
            HWND hControl = GetDlgItem(pFormatInfo->hDlg, i + DLG_FORMATDISK_FIRSTCONTROL);
            EnableWindow(hControl, pFormatInfo->rgfControlEnabled[i]);
        }
    }

    hwnd = GetDlgItem(pFormatInfo->hDlg, IDOK);
    EnableWindow(hwnd, fReady);
    SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));

    LoadString(HINST_THISDLL, IDS_FMT_CLOSE, wszClose, ARRAYSIZE(wszClose));
    hwnd = GetDlgItem(pFormatInfo->hDlg, IDCANCEL);
    SetWindowText(hwnd, wszClose);
    SendMessage(hwnd, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
    SendMessage(pFormatInfo->hDlg, DM_SETDEFID, IDCANCEL, 0);

    // Shove focus only if it's on the OK button.  Otherwise we end up
    // yanking focus away from a user who is busy dorking with the dialog,
    // or -- worse -- dorking with a completely unrelated dialog!

    if (GetFocus() == GetDlgItem(pFormatInfo->hDlg, IDOK))
        SetFocus(hwnd);
}

//  Sets the dialog's title to "Format Floppy (A:)" or
//  "Formatting Floppy (A:)" 
void SetDriveWindowTitle(HWND hdlg, LPCWSTR pszDrive, UINT ids)
{
    SHFILEINFO sfi;
    WCHAR wszWinTitle[MAX_PATH]; // Format dialog window title

    LoadString(HINST_THISDLL, ids, wszWinTitle, ARRAYSIZE(wszWinTitle));

    if (SHGetFileInfo(pszDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                      SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        StringCchCat(wszWinTitle, ARRAYSIZE(wszWinTitle), sfi.szDisplayName);  // ok to truncate
    }

    SetWindowText(hdlg, wszWinTitle);
}

//
//  Synopsis:   Called when a user picks a filesystem in the dialog, this
//              sets the states of the other relevant controls, such as
//              Enable Compression, Allocation Size, etc.
//
//  Arguments:  [fsenum]      -- One of e_FAT, e_NTFS, or e_FAT32
//              [pFormatInfo] -- Current format dialog session
//
void FileSysChange(FILESYSENUM fsenum, FORMATINFO *pFormatInfo)
{
    WCHAR wszTmp[MAX_PATH];

    switch (fsenum)
    {
        case e_FAT:
        case e_FAT32:
        {
            // un-check & disable the "Enable Compression" checkbox
            CheckDlgButton(pFormatInfo->hDlg, IDC_ECCHECK, FALSE);
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ECCHECK), FALSE);

            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_RESETCONTENT, 0, 0);
            
            LoadString(HINST_THISDLL, IDS_FMT_ALLOC0, wszTmp, ARRAYSIZE(wszTmp));
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_ADDSTRING, 0, (LPARAM)wszTmp);
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 0, 0);
        }
        break;
            
        case e_NTFS:
        {
            int i;

            // un-check & disable the "Enable Compression" checkbox
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ECCHECK), TRUE);
            CheckDlgButton(pFormatInfo->hDlg, IDC_ECCHECK, pFormatInfo->fEnableComp);

            // Set up the NTFS Allocation choices, and select the current choice
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_RESETCONTENT, 0, 0);

            for (i = IDS_FMT_ALLOC0; i <= IDS_FMT_ALLOC4; i++)
            {
                LoadString(HINST_THISDLL, i, wszTmp, ARRAYSIZE(wszTmp));
                SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_ADDSTRING, 0, (LPARAM)wszTmp);
            }

            switch (pFormatInfo->dwClusterSize)
            {
                case 512:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 1, 0);
                    break;

                case 1024:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 2, 0);
                    break;

                case 2048:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 3, 0);
                    break;

                case 4096:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 4, 0);
                    break;

                default:
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_ASCOMBO, CB_SETCURSEL, 0, 0);
                    break;

            }
        }
        break;
    }
}

//
// Is this drive a GPT drive?
// GPT drive: Guid-Partition Table - a replacement for the Master Boot Record, used on some IA64 machines, can only use NTFS
BOOL IsGPTDrive(int iDrive)
{
    BOOL fRetVal = FALSE;
#ifdef _WIN64
    HANDLE hDrive;
    TCHAR szDrive[] = TEXT("\\\\.\\A:");

    ASSERT(iDrive < 26);
    szDrive[4] += (TCHAR)iDrive;
    
    hDrive = CreateFile(szDrive, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hDrive)
    {
        PARTITION_INFORMATION_EX partitionEx;
        DWORD cbReturned;
        if (DeviceIoControl(hDrive, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, (void*)&partitionEx, sizeof(PARTITION_INFORMATION_EX), &cbReturned, NULL))
        {
            if (partitionEx.PartitionStyle == PARTITION_STYLE_GPT) 
            {
                fRetVal = TRUE;
            }
        }
        CloseHandle(hDrive);
    }
#endif
    return fRetVal;
}

BOOL IsDVDRAMMedia(int iDrive)
{
    BOOL fRetVal = FALSE;
    CMountPoint *pmtpt = CMountPoint::GetMountPoint(iDrive);
    if (pmtpt)
    {
        DWORD dwMediaCap, dwDriveCap;
        if (SUCCEEDED(pmtpt->GetCDInfo(&dwDriveCap, &dwMediaCap)))
        {
            fRetVal = (dwMediaCap & HWDMC_DVDRAM);
        }
        pmtpt->Release();
    }

    return fRetVal;
}

#define GIG_INBYTES       (1024 * 1024 * 1024)

//
// FAT32 has some limit which prevents the number of clusters from being
// less than 65526.  And minimum cluster size is 512 bytes.  So minimum FAT32
// volume size is 65526*512.

#define FAT32_MIN           ((ULONGLONG)65526*512)

#define FMTAVAIL_MASK_MIN      0x1
#define FMTAVAIL_MASK_MAX      0x2
#define FMTAVAIL_MASK_REQUIRE  0x3
#define FMTAVAIL_MASK_FORBID   0x4

#define FMTAVAIL_TYPE_FLOPPY   0x1
#define FMTAVAIL_TYPE_DVDRAM   0x2
#define FMTAVAIL_TYPE_GPT      0x4
#define FMTAVAIL_TYPE_MEMSTICK 0x8
#define FMTAVAIL_TYPE_NTFS_BLOCKED 0x10

typedef struct _FMTAVAIL
{
    DWORD dwfs;
    DWORD dwMask;
    DWORD dwForbiddenTypes;
    ULONGLONG qMinSize;
    ULONGLONG qMaxSize;
} FMTAVAIL;

FMTAVAIL rgFmtAvail[] = {
    {e_FAT,   FMTAVAIL_MASK_MAX | FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_DVDRAM | FMTAVAIL_TYPE_GPT, 0, ((ULONGLONG)2 * GIG_INBYTES) },
    {e_FAT32, FMTAVAIL_MASK_MIN | FMTAVAIL_MASK_MAX | FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_GPT | FMTAVAIL_TYPE_FLOPPY | FMTAVAIL_TYPE_MEMSTICK, FAT32_MIN, ((ULONGLONG)32 * GIG_INBYTES) },
    {e_NTFS,  FMTAVAIL_MASK_FORBID, FMTAVAIL_TYPE_DVDRAM | FMTAVAIL_TYPE_FLOPPY | FMTAVAIL_TYPE_MEMSTICK | FMTAVAIL_TYPE_NTFS_BLOCKED, 0, 0 }
};

// is a particular disk format available for a drive with given parameters and capacity?
BOOL FormatAvailable (DWORD dwfs, FORMATINFO* pFormatInfo, ULONGLONG* pqwCapacity)
{
    BOOL fAvailable = TRUE;
    DWORD dwType = 0;

    if (pFormatInfo->fIsFloppy)
    {
        dwType |= FMTAVAIL_TYPE_FLOPPY;
    }
    if (IsDVDRAMMedia(pFormatInfo->drive))
    {
        dwType |= FMTAVAIL_TYPE_DVDRAM;
    }
    if (IsGPTDrive(pFormatInfo->drive)) 
    {
        dwType |= FMTAVAIL_TYPE_GPT;
    }
    if (pFormatInfo->fIsMemoryStick)
    {
        dwType |= FMTAVAIL_TYPE_MEMSTICK;
    }
    if (pFormatInfo->fIsNTFSBlocked)
    {
        dwType |= FMTAVAIL_TYPE_NTFS_BLOCKED;
    }

    for (int i = 0; i < ARRAYSIZE(rgFmtAvail); i++)
    {
        // check only entries that match the format we're looking for
        if (rgFmtAvail[i].dwfs == dwfs)
        {
            // if a failure conditions is true, then this format is unavailable
            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_FORBID) && (rgFmtAvail[i].dwForbiddenTypes & dwType))
            {
                fAvailable = FALSE;
                break;
            }

            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_MIN) && (*pqwCapacity < rgFmtAvail[i].qMinSize))
            {
                fAvailable = FALSE;
                break;
            }

            if ((rgFmtAvail[i].dwMask & FMTAVAIL_MASK_MAX) && (*pqwCapacity > rgFmtAvail[i].qMaxSize))
            {
                fAvailable = FALSE;
                break;
            }
        }
    }

    return fAvailable;
}

HRESULT GetPartitionSizeInBytes(int iDrive, ULONGLONG* pqwPartitionSize)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile;
    TCHAR szDrive[] = TEXT("\\\\.\\A:");

    *pqwPartitionSize = 0;

    ASSERT(iDrive < 26);
    szDrive[4] += (TCHAR)iDrive;
    
    hFile = CreateFile(szDrive, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        GET_LENGTH_INFORMATION LengthInfo;
        DWORD cbReturned;

        if (DeviceIoControl(hFile, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, (void*)&LengthInfo, sizeof(LengthInfo), &cbReturned, NULL) &&
            LengthInfo.Length.QuadPart)
        {
            *pqwPartitionSize = LengthInfo.Length.QuadPart;
            hr = S_OK;
        }

        CloseHandle(hFile);
    }

    return hr;
}

// this helper function adds a string to a combo box with the associated dword (dwfs) as its itemdata
void _AddFSString(HWND hwndCB, WCHAR* pwsz, DWORD dwfs)
{
    int iIndex = ComboBox_AddString(hwndCB, pwsz);
    if (iIndex != CB_ERR)
    {
        ComboBox_SetItemData(hwndCB, iIndex, dwfs);
    }
}

// We only support formatting these types of devices
const FMIFS_MEDIA_TYPE rgFmtSupported[] = { FmMediaRemovable, FmMediaFixed, 
                                            FmMediaF3_1Pt44_512, FmMediaF3_120M_512, FmMediaF3_200Mb_512};

//
//  Synopsis:   Initializes the format dialog to a default state.  Examines
//              the disk/partition to obtain default values.
//
//  Arguments:  [hDlg]        -- Handle to the format dialog
//              [pFormatInfo] -- Describes current format session
//
//  Returns:    HRESULT
//
HRESULT InitializeFormatDlg(FORMATINFO *pFormatInfo)
{
    HRESULT          hr              = S_OK;
    ULONG            cMedia;
    HWND             hCapacityCombo;
    HWND             hFilesystemCombo;
    HWND             hDlg = pFormatInfo->hDlg;
    WCHAR            wszBuffer[256];
    ULONGLONG        qwCapacity = 0;

    // Set up some typical default values
    pFormatInfo->fEnableComp       = FALSE;
    pFormatInfo->dwClusterSize     = 0;
    pFormatInfo->fIsFloppy         = TRUE;
    pFormatInfo->fIsMemoryStick    = FALSE;
    pFormatInfo->fIsNTFSBlocked    = FALSE;
    pFormatInfo->fIs35HDFloppy     = TRUE;
    pFormatInfo->fWasFAT           = TRUE;
    pFormatInfo->fFinishedOK       = FALSE;
    pFormatInfo->fErrorAlready     = FALSE;
    pFormatInfo->wszVolName[0]     = L'\0';

    // Initialize the Quick Format checkbox based on option passed to the SHFormatDrive() API
    Button_SetCheck(GetDlgItem(hDlg, IDC_QFCHECK), pFormatInfo->options & SHFMT_OPT_FULL);

    // Set the dialog title to indicate which drive we are dealing with
    PathBuildRootW(pFormatInfo->wszDriveName, pFormatInfo->drive);
    SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMAT);

    // Query the supported media types for the drive in question
    if (!pFormatInfo->fmifs.QuerySupportedMedia(pFormatInfo->wszDriveName,
                                                pFormatInfo->rgMedia,
                                                ARRAYSIZE(pFormatInfo->rgMedia),
                                                &cMedia))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // For each of the formats that the drive can handle, add a selection
    // to the capcity combobox.
    if (S_OK == hr)
    {
        UINT olderror;
        ULONG i;
        ULONG j;

        hCapacityCombo = GetDlgItem(hDlg, IDC_CAPCOMBO);
        hFilesystemCombo = GetDlgItem(hDlg, IDC_FSCOMBO);

        ASSERT(hCapacityCombo && hFilesystemCombo);

        FMIFS_DEVICE_INFORMATION fmifsdeviceinformation;
        BOOL fOk = pFormatInfo->fmifs.QueryDeviceInformation(
                        pFormatInfo->wszDriveName,
                        &fmifsdeviceinformation,
                        sizeof(fmifsdeviceinformation));

        if (fOk)
        {
            if (fmifsdeviceinformation.Flags & FMIFS_SONY_MS)
            {
                pFormatInfo->fIsMemoryStick = TRUE;
            }

            if (fmifsdeviceinformation.Flags & FMIFS_NTFS_NOT_SUPPORTED)
            {
                pFormatInfo->fIsNTFSBlocked = TRUE;
            }
        }

        // Allow only certain media types
        j = 0;
        for (i = 0; i < cMedia; i++)
        {
            for (int k = 0; k < ARRAYSIZE(rgFmtSupported); k++)
            {
                if (pFormatInfo->rgMedia[i] ==  rgFmtSupported[k])
                {
                    pFormatInfo->rgMedia[j] = pFormatInfo->rgMedia[i];
                    j++;
                    break;
                }
            }
        }
        cMedia = j;

        if (0 == cMedia)
        {
            hr = ERROR_UNRECOGNIZED_MEDIA;
        }
        else
        {
            for (i = 0; i < cMedia; i++)
            {
                // If we find any non-floppy format, clear the fIsFloppy flag
                if (FmMediaFixed == pFormatInfo->rgMedia[i] || FmMediaRemovable == pFormatInfo->rgMedia[i])
                {
                    pFormatInfo->fIsFloppy = FALSE;
                }

                // if we find any non-3.5" HD floppy format, clear the fIs35HDFloppy flag
                if (FmMediaF3_1Pt44_512 != pFormatInfo->rgMedia[i])
                {
                    pFormatInfo->fIs35HDFloppy = FALSE;
                }
                
                // For fixed media we query the size, for floppys we present
                // a set of options supported by the drive
                if (FmMediaFixed == pFormatInfo->rgMedia[i] || (FmMediaRemovable == pFormatInfo->rgMedia[i]))
                {
                    DWORD dwSectorsPerCluster,
                          dwBytesPerSector,
                          dwFreeClusters,
                          dwClusters;

                    if (SUCCEEDED(GetPartitionSizeInBytes(pFormatInfo->drive, &qwCapacity)))
                    {
                        // Add a capacity desciption to the combobox
                        ShortSizeFormat64(qwCapacity, wszBuffer, ARRAYSIZE(wszBuffer));
                    }
                    else
                    {
                        // Couldn't get the free space... prob. not fatal
                        LoadString(HINST_THISDLL, IDS_FMT_CAPUNKNOWN, wszBuffer, ARRAYSIZE(wszBuffer));
                    }
                    ComboBox_AddString(hCapacityCombo, wszBuffer);

                    if (GetDiskFreeSpace(pFormatInfo->wszDriveName,
                                         &dwSectorsPerCluster,
                                         &dwBytesPerSector,
                                         &dwFreeClusters,
                                         &dwClusters))
                    {
                        pFormatInfo->dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;
                    }
                }
                else
                {
                    // removable media:
                    //
                    // add a capacity desciption to the combo baseed on the sequential list of 
                    // media format descriptors
                    LoadString(HINST_THISDLL, IDS_FMT_MEDIA0 + pFormatInfo->rgMedia[i], wszBuffer, ARRAYSIZE(wszBuffer));
                    ComboBox_AddString(hCapacityCombo, wszBuffer);
                }
            }


            // set capacity to default 
            ComboBox_SetCurSel(hCapacityCombo, 0);

            // Add the appropriate filesystem selections to the combobox
            // We now prioritize NTFS
            if (FormatAvailable(e_NTFS, pFormatInfo, &qwCapacity))
            {
                _AddFSString(hFilesystemCombo, FS_STR_NTFS, e_NTFS);
            }

            if (FormatAvailable(e_FAT32, pFormatInfo, &qwCapacity))
            {

                _AddFSString(hFilesystemCombo, FS_STR_FAT32, e_FAT32);
            }

            if (FormatAvailable(e_FAT, pFormatInfo, &qwCapacity))
            {
                _AddFSString(hFilesystemCombo, FS_STR_FAT, e_FAT);
            }

            // By default, pick the 0-th entry in the _nonsorted_ combobox.
            // NOTE: this can be overwritten below
            ComboBox_SetCurSel(hFilesystemCombo, 0);

            // If we can determine something other than FAT is being used,
            // select it as the default in the combobox
            olderror = SetErrorMode(SEM_FAILCRITICALERRORS);

            if (GetVolumeInformation(pFormatInfo->wszDriveName,
                                     pFormatInfo->wszVolName,
                                     ARRAYSIZE(pFormatInfo->wszVolName),
                                     NULL,
                                     NULL,
                                     NULL,
                                     wszBuffer,
                                     ARRAYSIZE(wszBuffer)))
            {
                // If we got a current volume label, stuff it in the edit control
                if (pFormatInfo->wszVolName[0] != L'\0')
                {
                    SetWindowText(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), pFormatInfo->wszVolName);
                }

                // for non-floppies we default to keeping the FS the same as the current one
                if (!pFormatInfo->fIsFloppy)
                {
                    if (0 == lstrcmpi(FS_STR_NTFS, wszBuffer))
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_NTFS);
                        pFormatInfo->fWasFAT = FALSE;
                    }
                    else if (0 == lstrcmpi(FS_STR_FAT32, wszBuffer))
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_FAT32);
                        pFormatInfo->fWasFAT = TRUE;
                        pFormatInfo->dwClusterSize = 0;
                    }
                    else
                    {
                        ComboBox_SelectString(hFilesystemCombo, -1, FS_STR_FAT);
                        pFormatInfo->fWasFAT = TRUE;
                        pFormatInfo->dwClusterSize = 0;
                    }
                }
                // FEATURE - What about specialized file-systems?  Don't care for now.
            }

            
#ifndef _WIN64
            // if not WIN64, enable boot-disk creation if we are a 3.5" HD floppy
            EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_BTCHECK), pFormatInfo->fIs35HDFloppy);
#else
            // if WIN64, hide this option, since we can't use these boot floppies on WIN64
            ShowWindow(GetDlgItem(pFormatInfo->hDlg, IDC_BTCHECK), FALSE);
#endif


            // restore the old errormode
            SetErrorMode(olderror);

            // set the state of the chkboxes properly based on the FS chosen
            FileSysChange((FILESYSENUM)ComboBox_GetItemData(hFilesystemCombo, ComboBox_GetCurSel(hFilesystemCombo)), pFormatInfo);
        }
    }

    // If the above failed due to disk not in drive, notify the user
    if (FAILED(hr))
    {
        switch (HRESULT_CODE(hr))
        {
        case ERROR_UNRECOGNIZED_MEDIA:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_UNFORMATTABLE_DISK),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            NULL);

            break;

        case ERROR_NOT_READY:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_DRIVENOTREADY),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;

        case ERROR_ACCESS_DENIED:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_ACCESSDENIED),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;

        case ERROR_WRITE_PROTECT:
            ShellMessageBox(HINST_THISDLL,
                            hDlg,
                            MAKEINTRESOURCE(IDS_WRITEPROTECTED),
                            NULL,
                            MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK,
                            pFormatInfo->wszDriveName[0]);
            break;
        }
    }

    return hr;
}

//  Synopsis:   Called from within the FMIFS DLL's Format function, this
//              updates the format dialog's status bar and responds to
//              format completion/error notifications.
//
//  Arguments:  [PacketType]   -- Type of packet (ie: % complete, error, etc)
//              [PacketLength] -- Size, in bytes, of the packet
//              [pPacketData]  -- Pointer to the packet
//
//  Returns:    BOOLEAN continuation value
//
BOOLEAN FormatCallback(FMIFS_PACKET_TYPE PacketType, ULONG PacketLength, void *pPacketData)
{
    UINT iMessageID = IDS_FORMATFAILED;
    BOOL fFailed = FALSE;
    FORMATINFO* pFormatInfo = GetFormatInfoPtr();

    ASSERT(g_iTLSFormatInfo);

    // Grab the FORMATINFO structure for this thread
    if (pFormatInfo)
    {
        if (!pFormatInfo->fShouldCancel)
        {
            switch(PacketType)
            {
                case FmIfsIncompatibleFileSystem:
                    fFailed    = TRUE;
                    iMessageID = IDS_INCOMPATIBLEFS;
                    break;

                case FmIfsIncompatibleMedia:
                    fFailed    = TRUE;
                    iMessageID = IDS_INCOMPATIBLEMEDIA;
                    break;

                case FmIfsAccessDenied:
                    fFailed    = TRUE;
                    iMessageID = IDS_ACCESSDENIED;
                    break;

                case FmIfsMediaWriteProtected:
                    fFailed    = TRUE;
                    iMessageID = IDS_WRITEPROTECTED;
                    break;

                case FmIfsCantLock:
                    fFailed    = TRUE;
                    iMessageID = IDS_CANTLOCK;
                    break;

                case FmIfsCantQuickFormat:
                    fFailed    = TRUE;
                    iMessageID = IDS_CANTQUICKFORMAT;
                    break;

                case FmIfsIoError:
                    fFailed    = TRUE;
                    // display a different message if we're making a boot disk
                    iMessageID = pFormatInfo->fMakeBootDisk ? IDS_NEEDFORMAT : IDS_IOERROR;
                    // FUTURE Consider showing head/track etc where error was
                    break;

                case FmIfsBadLabel:
                    fFailed    = TRUE;
                    iMessageID = IDS_BADLABEL;
                    break;

                case FmIfsPercentCompleted:
                {
                    FMIFS_PERCENT_COMPLETE_INFORMATION * pPercent =
                      (FMIFS_PERCENT_COMPLETE_INFORMATION *) pPacketData;
            
                    SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS,
                                       PBM_SETPOS,
                                       pPercent->PercentCompleted, 0);
                }
                break;

                case FmIfsFinished:
                {
                    // Format is done; check for failure or success
                    FMIFS_FINISHED_INFORMATION* pFinishedInfo = (FMIFS_FINISHED_INFORMATION*)pPacketData;

                    pFormatInfo->fFinishedOK = pFinishedInfo->Success;

                    if (pFinishedInfo->Success)
                    {
                        // fmifs will "succeed" even if we already failed, so we need to double-check
                        // that we haven't already put up error UI
                        if (!pFormatInfo->fErrorAlready)
                        {
                            // If "Enable Compression" is checked, try to enable filesystem compression
                            if (IsDlgButtonChecked(pFormatInfo->hDlg, IDC_ECCHECK))
                            {
                                if (pFormatInfo->fmifs.EnableVolumeCompression(pFormatInfo->wszDriveName,
                                                                               COMPRESSION_FORMAT_DEFAULT) == FALSE)
                                {
                                    ShellMessageBox(HINST_THISDLL,
                                                    pFormatInfo->hDlg,
                                                    MAKEINTRESOURCE(IDS_CANTENABLECOMP),
                                                    NULL,
                                                    MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);
                                }
                            }

                            // Even though its a quick format, the progress meter should
                            // show 100% when the "Format Complete" requester is up
                            SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS,
                                               PBM_SETPOS,
                                               100, // set %100 Complete
                                               0);

                            // FUTURE Consider showing format stats, ie: ser no, bytes, etc
                            ShellMessageBox(HINST_THISDLL,
                                            pFormatInfo->hDlg,
                                            MAKEINTRESOURCE(IDS_FORMATCOMPLETE),
                                            NULL,
                                            MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);
                        }

                        // Restore the dialog title, reset progress and flags
                        SendDlgItemMessage(pFormatInfo->hDlg,
                                           IDC_FMTPROGRESS,
                                           PBM_SETPOS,
                                           0,   // Reset Percent Complete
                                           0);

                        // Set the focus onto the Close button
                        pFormatInfo->fCancelled = FALSE;
                    }
                    else
                    {
                        fFailed = TRUE;
                    }
                }
                break;
            }

            if (fFailed && !pFormatInfo->fErrorAlready)
            {
                // If we received any kind of failure information, put up a final
                // "Format Failed" message. UNLESS we've already put up some nice message
                ShellMessageBox(HINST_THISDLL,
                                pFormatInfo->hDlg,
                                MAKEINTRESOURCE(iMessageID),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);

                pFormatInfo->fErrorAlready = TRUE;
            }
        }
        else
        {
            // user hit cancel
            pFormatInfo->fCancelled = TRUE;
            fFailed = TRUE;
        }        
    }
    else
    {
        // no pFormatInfo? we're screwed
        fFailed = TRUE;
    }

    return (BOOLEAN) (fFailed == FALSE);
}

//
//  Synopsis:   Spun off as its own thread, this ghosts all controls in the
//              dialog except "Cancel", then does the actual format
//
//  Arguments:  [pIn] -- FORMATINFO structure pointer as a void *
//
//  Returns:    HRESULT thread exit code
//
DWORD WINAPI BeginFormat(void * pIn)
{
    FORMATINFO *pFormatInfo = (FORMATINFO*)pIn;
    HRESULT hr = S_OK;
    
    // Save the FORAMTINFO ptr for this thread, to be used in the format
    // callback function
    hr = StuffFormatInfoPtr(pFormatInfo);
    if (hr == S_OK)
    {
        HWND hwndFileSysCB = GetDlgItem(pFormatInfo->hDlg, IDC_FSCOMBO);
        int iCurSel;

        // Set the window title to indicate format in proress...
        SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMATTING);

        // Determine the user's choice of filesystem
        iCurSel = ComboBox_GetCurSel(hwndFileSysCB);
    
        if (iCurSel != CB_ERR)
        {
            LPCWSTR pwszFileSystemName;
            FMIFS_MEDIA_TYPE MediaType;
            LPITEMIDLIST pidlFormat;
            BOOLEAN fQuickFormat;

            FILESYSENUM fseType = (FILESYSENUM)ComboBox_GetItemData(hwndFileSysCB, iCurSel);

            switch (fseType)
            {
                case e_FAT:
                    pwszFileSystemName = FS_STR_FAT;
                    break;

                case e_FAT32:
                    pwszFileSystemName = FS_STR_FAT32;
                    break;

                case e_NTFS:
                    pwszFileSystemName = FS_STR_NTFS;
                    break;
            }

            // Determine the user's choice of media formats
            iCurSel = ComboBox_GetCurSel(GetDlgItem(pFormatInfo->hDlg, IDC_CAPCOMBO));
            if (iCurSel == CB_ERR)
            {
                iCurSel = 0;
            }
            MediaType = pFormatInfo->rgMedia[iCurSel];

            // Get the cluster size.  First selection ("Use Default") yields a zero,
            // while the next 4 select 512, 1024, 2048, or 4096
            iCurSel = ComboBox_GetCurSel(GetDlgItem(pFormatInfo->hDlg, IDC_ASCOMBO));
            if ((iCurSel == CB_ERR) || (iCurSel == 0))
            {
                pFormatInfo->dwClusterSize = 0;
            }
            else
            {
                pFormatInfo->dwClusterSize = 256 << iCurSel;
            }

            // Quickformatting?
            fQuickFormat = Button_GetCheck(GetDlgItem(pFormatInfo->hDlg, IDC_QFCHECK));

            // Clear the error state.
            pFormatInfo->fErrorAlready = FALSE;

            // Tell the shell to get ready...  Announce that the media is no
            // longer valid (so people who have active views on it will navigate
            // away) and tell the shell to close its FindFirstChangeNotifications.
            if (SUCCEEDED(SHILCreateFromPath(pFormatInfo->wszDriveName, &pidlFormat, NULL)))
            {
                SHChangeNotify(SHCNE_MEDIAREMOVED, SHCNF_IDLIST | SHCNF_FLUSH, pidlFormat, 0);
                SHChangeNotifySuspendResume(TRUE, pidlFormat, TRUE, 0);
            }
            else
            {
                pidlFormat = NULL;
            }

            if (!pFormatInfo->fMakeBootDisk)
            {
                // Do the format.
                pFormatInfo->fmifs.FormatEx(pFormatInfo->wszDriveName,
                                            MediaType,
                                            (PWSTR)pwszFileSystemName,
                                            pFormatInfo->wszVolName,
                                            fQuickFormat,
                                            pFormatInfo->dwClusterSize,
                                            FormatCallback);
            }
            else
            {
                pFormatInfo->diskcopy.MakeBootDisk(pFormatInfo->diskcopy.hDISKCOPY_DLL, pFormatInfo->drive, &pFormatInfo->fCancelled, FormatCallback);
            }

            //  Wake the shell back up.
            if (pidlFormat)
            {
                SHChangeNotifySuspendResume(FALSE, pidlFormat, TRUE, 0);
                ILFree(pidlFormat);
            }

            // Success or failure, we should fire a notification on the disk
            // since we don't really know the state after the format
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATHW, (void *)pFormatInfo->wszDriveName, NULL);
        }
        else
        {
            // couldn't get the filesys CB selection
            hr = E_FAIL;
        }

        // Release the TLS index
        UnstuffFormatInfoPtr();
    }

    // Post a message back to the DialogProc thread to let it know
    // the format is done.  We post the message since otherwise the
    // DialogProc thread will be too busy waiting for this thread
    // to exit to be able to process the PWM_FORMATDONE message
    // immediately.
    PostMessage(pFormatInfo->hDlg, (UINT) PWM_FORMATDONE, 0, 0);

    ReleaseFormatInfo(pFormatInfo);

    return (DWORD)hr;
}

BOOL_PTR CALLBACK FormatDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr   = S_OK;
    int iID   = GET_WM_COMMAND_ID(wParam, lParam);
    int iCMD  = GET_WM_COMMAND_CMD(wParam, lParam);

    // Grab our previously cached pointer to the FORMATINFO struct (see WM_INITDIALOG)
    FORMATINFO *pFormatInfo = (FORMATINFO *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        case PWM_FORMATDONE:
            // Format is done.  Reset the window title and clear the progress meter
            SetDriveWindowTitle(pFormatInfo->hDlg, pFormatInfo->wszDriveName, IDS_FMT_FORMAT);
            SendDlgItemMessage(pFormatInfo->hDlg, IDC_FMTPROGRESS, PBM_SETPOS, 0 /* Reset Percent Complete */, 0);
            EnableControls(pFormatInfo, TRUE);

            if (pFormatInfo->fCancelled)
            {
                // Don't put up UI if the background thread finally finished
                // long after the user issued the cancel
                if (!pFormatInfo->fShouldCancel)
                {
                    ShellMessageBox(HINST_THISDLL,
                                    pFormatInfo->hDlg,
                                    MAKEINTRESOURCE(IDS_FORMATCANCELLED),
                                    NULL,
                                    MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);
                }
                pFormatInfo->fCancelled = FALSE;
            }

            if (pFormatInfo->hThread)
            {
                CloseHandle(pFormatInfo->hThread);
                pFormatInfo->hThread = NULL;
            }
            break;

        case WM_INITDIALOG:
            // Initialize the dialog and cache the FORMATINFO structure's pointer
            // as our dialog's DWLP_USER data
            pFormatInfo = (FORMATINFO *) lParam;
            pFormatInfo->hDlg = hDlg;
            if (FAILED(InitializeFormatDlg(pFormatInfo)))
            {
                EndDialog(hDlg, 0);
                return -1;
            }
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            break;

        case WM_DESTROY:           
            if (pFormatInfo && pFormatInfo->hDlg)
            {
                pFormatInfo->hDlg = NULL;
            }
            break;

        case WM_COMMAND:
            if (iCMD == CBN_SELCHANGE)
            {
                // User made a selection in one of the combo boxes
                if (iID == IDC_FSCOMBO)
                {
                    // User selected a filesystem... update the rest of the dialog
                    // based on this choice
                    HWND hFilesystemCombo = (HWND)lParam;
                    int iCurSel = ComboBox_GetCurSel(hFilesystemCombo);

                    FileSysChange((FILESYSENUM)ComboBox_GetItemData(hFilesystemCombo, iCurSel), pFormatInfo);
                }
            }
            else
            {
                // Codepath for controls other than combo boxes...
                switch (iID)
                {
                case IDC_BTCHECK:
                        pFormatInfo->fMakeBootDisk = IsDlgButtonChecked(pFormatInfo->hDlg, IDC_BTCHECK);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_CAPCOMBO), !pFormatInfo->fMakeBootDisk);                        
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_FSCOMBO), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_ASCOMBO), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), !pFormatInfo->fMakeBootDisk);
                        EnableWindow(GetDlgItem(pFormatInfo->hDlg, IDC_QFCHECK), !pFormatInfo->fMakeBootDisk);
                        break;
                case IDC_ECCHECK:
                        pFormatInfo->fEnableComp = IsDlgButtonChecked(hDlg, IDC_ECCHECK);
                        break;

                    case IDOK:
                    {
                        // Get user verification for format, break out on CANCEL
                        if (IDCANCEL == ShellMessageBox(HINST_THISDLL,
                                                        hDlg,
                                                        MAKEINTRESOURCE(IDS_OKTOFORMAT),
                                                        NULL,
                                                        MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OKCANCEL))
                        {
                            break;
                        }

                        ASSERT(pFormatInfo->hThread == NULL);

                        DisableControls(pFormatInfo);
                        pFormatInfo->fCancelled = FALSE;
                        pFormatInfo->fShouldCancel = FALSE;
                        GetWindowText(GetDlgItem(pFormatInfo->hDlg, IDC_VLABEL), pFormatInfo->wszVolName, MAX_PATH);
                
                        AddRefFormatInfo(pFormatInfo);
                        pFormatInfo->hThread = CreateThread(NULL,
                                                            0,
                                                            BeginFormat,
                                                            (void *)pFormatInfo,
                                                            0,
                                                            NULL);
                        if (!pFormatInfo->hThread)
                        {
                            // ISSUE: we should probably do something...
                            ReleaseFormatInfo(pFormatInfo);
                        }
                    }
                    break;

                    case IDCANCEL:
                        // If the format thread is running, wait for it.  If not,
                        // exit the dialog
                        pFormatInfo->fShouldCancel = TRUE;
                        if (pFormatInfo->hThread)
                        {
                            DWORD dwWait;

                            do
                            {
                                dwWait =  WaitForSingleObject(pFormatInfo->hThread, 10000);
                            }
                            while ((WAIT_TIMEOUT == dwWait) &&
                                   (IDRETRY == ShellMessageBox(HINST_THISDLL,
                                                               hDlg,
                                                               MAKEINTRESOURCE(IDS_CANTCANCELFMT),
                                                               NULL,
                                                               MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL)));

                            // If the format doesn't admit to having been killed, it didn't
                            // give up peacefully.  Just abandon it and let it clean up
                            // when it finally gets around to it, at which point we will
                            // enable the OK button to let the user take another stab.
                            //
                            // Careful:  The format may have cleaned up while the dialog box
                            // was up, so revalidate.
                            if (pFormatInfo->hThread)
                            {
                                CloseHandle(pFormatInfo->hThread);
                                pFormatInfo->hThread = NULL;
                                pFormatInfo->fCancelled = TRUE;
                                EnableControls(pFormatInfo, FALSE);
                            }
                        }
                        else
                        {
                            EndDialog(hDlg, IDCANCEL);
                        }
                        break;
                 }
            }
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR) (LPSTR) FmtaIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR) (LPSTR) FmtaIds);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//
//  Synopsis:   The SHFormatDrive API provides access to the Shell
//              format dialog. This allows apps which want to format disks
//              to bring up the same dialog that the Shell does to do it.
//
//              NOTE that the user can format as many diskettes in the
//              specified drive, or as many times, as he/she wishes to.
//
//  Arguments:  [hwnd]    -- Parent window (Must NOT be NULL)
//              [drive]   -- 0 = A:, 1 = B:, etc.
//              [fmtID]   -- see below
//              [options] -- SHFMT_OPT_FULL    overrised default quickformat
//                           SHFMT_OPT_SYSONLY not support for NT
//
//  Returns:    See Notes
//
DWORD WINAPI SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options)
{    
    INT_PTR ret;
    FORMATINFO *pFormatInfo = (FORMATINFO *)LocalAlloc(LPTR, sizeof(*pFormatInfo));
    ASSERT(drive < 26);

    if (!pFormatInfo)
        return SHFMT_ERROR;

    HRESULT hrCoInit = SHCoInitialize();

    pFormatInfo->cRef = 1;
    pFormatInfo->drive = drive;
    pFormatInfo->fmtID = fmtID;
    pFormatInfo->options = options;

    // It makes no sense for NT to "SYS" a disk
    if (pFormatInfo->options & SHFMT_OPT_SYSONLY)
    {
        ret = 0;
        goto done;
    }

    // Load FMIFS.DLL and DISKCOPY.DLL and open the Format dialog
    if (S_OK == LoadFMIFS(&pFormatInfo->fmifs) &&
        S_OK == LoadDISKCOPY(&pFormatInfo->diskcopy))
    {
        DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_FORMATDISK),
                             hwnd, FormatDlgProc, (LPARAM) pFormatInfo);
    }
    else
    {
        ASSERT(0 && "Can't load FMIFS.DLL");
        ret = SHFMT_ERROR;
        goto done;
    }

    // Since time immemorial it has been almost impossible to
    // get SHFMT_CANCEL as a return code.  Most of the time, you get
    // SHFMT_ERROR if the user cancels.
    if (pFormatInfo->fCancelled)
    {
        ret = SHFMT_CANCEL;
    }
    else if (pFormatInfo->fFinishedOK)
    {
        // APPCOMPAT: (stephstm) We used to say that we return the Serial
        //   Number but we never did.  So keep on returning 0 for success.
        //   Furthermore, Serial number values could conflict SHFMT_*
        //   error codes.
        ret = 0;
    }
    else
    {
        ret = SHFMT_ERROR;
    }

done:
    ReleaseFormatInfo(pFormatInfo);
    SHCoUninitialize(hrCoInit);
    return (DWORD)ret;
}

////////////////////////////////////////////////////////////////////////////
//
// CHKDSK
//
////////////////////////////////////////////////////////////////////////////

//
// This structure described the current chkdsk session
//
typedef struct
{
    UINT    lastpercent;           // last percentage complete received
    UINT    currentphase;          // current chkdsk phase
    FMIFS   fmifs;                // ptr to FMIFS structure, above
    BOOL    fRecovery;             // Attempt to recover bad sectors
    BOOL    fFixErrors;            // Fix filesystem errors as found
    BOOL    fCancelled;            // Was chkdsk terminated early?
    BOOL    fShouldCancel;         // User has clicked cancel; pending abort
    HWND    hDlg;                  // handle to the chkdsk dialog
    HANDLE  hThread;
    BOOL    fNoFinalMsg;           // Do not put up a final failure message
    WCHAR   wszDriveName[MAX_PATH]; // For example, "A:\", or "C:\folder\mountedvolume\"
    LONG    cRef;                  // reference count on this structure
} CHKDSKINFO;

void AddRefChkDskInfo(CHKDSKINFO *pChkDskInfo)
{
    InterlockedIncrement(&pChkDskInfo->cRef);
}

void ReleaseChkDskInfo(CHKDSKINFO *pChkDskInfo)
{
    ASSERT( 0 != pChkDskInfo->cRef );
    if (InterlockedDecrement(&pChkDskInfo->cRef) == 0) 
    {
        if (pChkDskInfo->fmifs.hFMIFS_DLL)
        {
            FreeLibrary(pChkDskInfo->fmifs.hFMIFS_DLL);
        }

        if (pChkDskInfo->hThread)
        {
            CloseHandle(pChkDskInfo->hThread);
        }

        LocalFree(pChkDskInfo);
    }
}


static DWORD g_iTLSChkDskInfo = 0;
static LONG  g_cTLSChkDskInfo = 0;  // Usage count

//
//  Synopsis:   Allocates a thread-local index slot for this thread's
//              CHKDSKINFO pointer, if the index doesn't already exist.
//              In any event, stores the CHKDSKINFO pointer in the slot
//              and increments the index's usage count.
//
//  Arguments:  [pChkDskInfo] -- The pointer to store
//
//  Returns:    HRESULT
//
//
// Thread-Local Storage index for our CHKDSKINFO structure pointer
//
HRESULT StuffChkDskInfoPtr(CHKDSKINFO *pChkDskInfo)
{
    HRESULT hr = S_OK;

    // Allocate an index slot for our thread-local CHKDSKINFO pointer, if one
    // doesn't already exist, then stuff our CHKDSKINFO ptr at that index.
    
    ENTERCRITICAL;
    if (0 == g_iTLSChkDskInfo)
    {
        g_iTLSChkDskInfo = TlsAlloc();

        if (g_iTLSChkDskInfo == (DWORD)-1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        g_cTLSChkDskInfo = 0;
    }

    if (S_OK == hr)
    {
        if (TlsSetValue(g_iTLSChkDskInfo, (void *)pChkDskInfo))
        {
           g_cTLSChkDskInfo++;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    LEAVECRITICAL;

    return hr;
}

//
//  Synopsis:   Decrements the usage count on our thread-local storage
//              index, and if it goes to zero the index is free'd
//
//  Arguments:  [none]
//
//  Returns:    none
//
void UnstuffChkDskInfoPtr()
{
    ENTERCRITICAL;
    g_cTLSChkDskInfo--;

    if (g_cTLSChkDskInfo == 0)
    {
        TlsFree(g_iTLSChkDskInfo);
        g_iTLSChkDskInfo = 0;
    }
    LEAVECRITICAL;
}

//
//  Synopsis:   Retrieves this threads CHKDSKINFO ptr by grabbing the
//              thread-local value previously stuff'd
//
//  Arguments:  [none]
//
//  Returns:    The pointer, of course
//
CHKDSKINFO *GetChkDskInfoPtr()
{
    return (CHKDSKINFO *)TlsGetValue(g_iTLSChkDskInfo);
}

//
//  Synopsis:   Ghosts all controls except "Cancel", saving their
//              previous state in the CHKDSKINFO structure
//
//  Arguments:  [pChkDskInfo] -- Describes a ChkDsk dialog session
//
//  Notes:      Also changes "Close" button text to read "Cancel"
//
void DisableChkDskControls(CHKDSKINFO *pChkDskInfo)
{
    // We disable CANCEL because CHKDSK does not
    // allow interruption at the filesystem level.
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_FIXERRORS), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_RECOVERY), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDOK), FALSE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDCANCEL), FALSE);
}

//
//  Synopsis:   Restores controls to the enabled/disabled state they were
//              before a previous call to DisableControls().
//
//  Arguments:  [pChkDskInfo] -- Decribes a chkdsk dialog session
//
void EnableChkDskControls(CHKDSKINFO *pChkDskInfo)
{
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_FIXERRORS), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDC_RECOVERY), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDOK), TRUE);
    EnableWindow(GetDlgItem(pChkDskInfo->hDlg, IDCANCEL), TRUE);

    // Erase the current phase text
    SetWindowText(GetDlgItem(pChkDskInfo->hDlg, IDC_PHASE), TEXT(""));
    pChkDskInfo->lastpercent = 101;
    pChkDskInfo->currentphase = 0;
}

//
//  Synopsis:   Called from within the FMIFS DLL's ChkDsk function, this
//              updates the ChkDsk dialog's status bar and responds to
//              chkdsk completion/error notifications.
//
//  Arguments:  [PacketType]   -- Type of packet (ie: % complete, error, etc)
//              [PacketLength] -- Size, in bytes, of the packet
//              [pPacketData]  -- Pointer to the packet
//
//  Returns:    BOOLEAN continuation value
//
BOOLEAN ChkDskCallback(FMIFS_PACKET_TYPE PacketType, ULONG PacketLength, void *pPacketData)
{
    UINT iMessageID = IDS_CHKDSKFAILED;
    BOOL fFailed = FALSE;
    CHKDSKINFO* pChkDskInfo = GetChkDskInfoPtr();

    ASSERT(g_iTLSChkDskInfo);

    // Grab the CHKDSKINFO structure for this thread
    if (pChkDskInfo)
    {
        if (!pChkDskInfo->fShouldCancel)
        {
            switch(PacketType)
            {
                case FmIfsAccessDenied:
                    fFailed    = TRUE;
                    iMessageID = IDS_CHKACCESSDENIED;
                    break;

                case FmIfsCheckOnReboot:
                {
                    FMIFS_CHECKONREBOOT_INFORMATION * pRebootInfo = (FMIFS_CHECKONREBOOT_INFORMATION *)pPacketData;

                    // Check to see whether or not the user wants to schedule this
                    // chkdsk for the next reboot, since the drive cannot be locked
                    // right now.
                    if (IDYES == ShellMessageBox(HINST_THISDLL,
                                                 pChkDskInfo->hDlg,
                                                 MAKEINTRESOURCE(IDS_CHKONREBOOT),
                                                 NULL,
                                                 MB_SETFOREGROUND | MB_ICONINFORMATION | MB_YESNO))
                    {
                        // Yes, have FMIFS schedule an autochk for us
                        pRebootInfo->QueryResult = TRUE;
                        pChkDskInfo->fNoFinalMsg = TRUE;
                    }
                    else
                    {
                        // Nope, just fail out with "cant lock drive"
                        fFailed = TRUE;
                        iMessageID = IDS_CHKDSKFAILED;
                    }
                }
                break;

                case FmIfsMediaWriteProtected:
                    fFailed    = TRUE;
                    iMessageID = IDS_WRITEPROTECTED;
                    break;

                case FmIfsIoError:
                    fFailed    = TRUE;
                    iMessageID = IDS_IOERROR;
                    // FUTURE Consider showing head/track etc where error was
                    break;

                case FmIfsPercentCompleted:
                {
                    FMIFS_PERCENT_COMPLETE_INFORMATION* pPercent = (FMIFS_PERCENT_COMPLETE_INFORMATION *)pPacketData;

                    SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                PBM_SETPOS,
                                pPercent->PercentCompleted, // updatee % complete
                                0);

                    if (pPercent->PercentCompleted < pChkDskInfo->lastpercent)
                    {
                        WCHAR wszTmp[100];
                        WCHAR wszFormat[100];
                        
                        // If this % complete is less than the last one seen,
                        // we have completed a phase of the chkdsk and should
                        // advance to the next one.
                        LoadString(HINST_THISDLL, IDS_CHKPHASE, wszFormat, ARRAYSIZE(wszFormat));
                        StringCchPrintf(wszTmp, ARRAYSIZE(wszTmp), wszFormat, ++(pChkDskInfo->currentphase));  // ok to truncate
                        SetDlgItemText(pChkDskInfo->hDlg, IDC_PHASE, wszTmp);
                    }

                    pChkDskInfo->lastpercent = pPercent->PercentCompleted;
                }
                break;

                case FmIfsFinished:
                {
                    // ChkDsk is done; check for failure or success
                    FMIFS_FINISHED_INFORMATION * pFinishedInfo = (FMIFS_FINISHED_INFORMATION *) pPacketData;

                    // ChkDskEx now return the proper success value
                    if (pFinishedInfo->Success)
                    {
                        // Since we're done, force the progress gauge to 100%, so we
                        // don't sit here if the chkdsk code misled us
                        SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                    PBM_SETPOS,
                                    100,    // Percent Complete
                                    0);

                        ShellMessageBox(HINST_THISDLL,
                                        pChkDskInfo->hDlg,
                                        MAKEINTRESOURCE(IDS_CHKDSKCOMPLETE),
                                        NULL,
                                        MB_SETFOREGROUND | MB_ICONINFORMATION | MB_OK);

                        SetDlgItemText(pChkDskInfo->hDlg, IDC_PHASE, TEXT(""));

                        SendMessage(GetDlgItem(pChkDskInfo->hDlg, IDC_CHKDSKPROGRESS),
                                    PBM_SETPOS,
                                    0,  // reset Percent Complete
                                    0);
                    }
                    else
                    {
                        iMessageID = IDS_CHKDSKFAILED;
                        fFailed = TRUE;
                    }
                }
                break;
            }

            // If we received any kind of failure information, put up a final
            // "ChkDsk Failed" message.
            if (fFailed && (pChkDskInfo->fNoFinalMsg == FALSE))
            {
                pChkDskInfo->fNoFinalMsg = TRUE;

                ShellMessageBox(HINST_THISDLL,
                                pChkDskInfo->hDlg,
                                MAKEINTRESOURCE(iMessageID),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);

            }

        }
        else
        {
            // If the user has signalled to abort the ChkDsk, return
            // FALSE out of here right now
            pChkDskInfo->fCancelled = TRUE;
            fFailed = TRUE;
        }
    }
    else
    {
        fFailed = TRUE;
    }

    return (BOOLEAN) (fFailed == FALSE);
}

void DoChkDsk(CHKDSKINFO* pChkDskInfo, LPWSTR pwszFileSystem)
{
    TCHAR szVolumeGUID[50]; // 50: from doc
    FMIFS_CHKDSKEX_PARAM param = {0};

    param.Major = 1;
    param.Minor = 0;
    param.Flags = pChkDskInfo->fRecovery ? FMIFS_CHKDSK_RECOVER : 0;

    GetVolumeNameForVolumeMountPoint(pChkDskInfo->wszDriveName,
                                     szVolumeGUID,
                                     ARRAYSIZE(szVolumeGUID));

    // the backslash at the end means check for fragmentation.
    PathRemoveBackslash(szVolumeGUID);

    pChkDskInfo->fmifs.ChkDskEx(szVolumeGUID,
                                pwszFileSystem,
                                (BOOLEAN)pChkDskInfo->fFixErrors,
                                &param,
                                ChkDskCallback);
}


//
//  Synopsis:   Spun off as its own thread, this ghosts all controls in the
//              dialog except "Cancel", then does the actual ChkDsk
//
//  Arguments:  [pIn] -- CHKDSKINFO structure pointer as a void *
//
//  Returns:    HRESULT thread exit code
//
DWORD WINAPI BeginChkDsk(void * pIn)
{
    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *)pIn;
    HRESULT hr;

    // Save the CHKDSKINFO ptr for this thread, to be used in the ChkDsk
    // callback function
    hr = StuffChkDskInfoPtr(pChkDskInfo);
    if (hr == S_OK)
    {
        WCHAR swzFileSystem[MAX_PATH];

        // Get the filesystem in use on the device
        if (GetVolumeInformationW(pChkDskInfo->wszDriveName,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  swzFileSystem,
                                  MAX_PATH))
        {
            // Set the window title to indicate ChkDsk in proress...
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKINPROGRESS);

            pChkDskInfo->fNoFinalMsg = FALSE;

            // Should we try data recovery?
            pChkDskInfo->fRecovery = IsDlgButtonChecked(pChkDskInfo->hDlg, IDC_RECOVERY);

            // Should we fix filesystem errors?
            pChkDskInfo->fFixErrors = IsDlgButtonChecked(pChkDskInfo->hDlg, IDC_FIXERRORS);

            // just do it!
            DoChkDsk(pChkDskInfo, swzFileSystem);

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        
        // Release the TLS index
        UnstuffChkDskInfoPtr();
    }

    PostMessage(pChkDskInfo->hDlg, (UINT) PWM_CHKDSKDONE, 0, 0);
    ReleaseChkDskInfo(pChkDskInfo);

    return (DWORD)hr;
}

//
//  Synopsis:   DLGPROC for the chkdsk dialog
//
//  Arguments:  [hDlg]   -- Typical
//              [wMsg]   -- Typical
//              [wParam] -- Typical
//              [lParam] -- For WM_INIT, carries the CHKDSKINFO structure
//                          pointer passed to DialogBoxParam() when the
//                          dialog was created.
//
BOOL_PTR CALLBACK ChkDskDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{ 
    HRESULT hr   = S_OK;
    int iID = GET_WM_COMMAND_ID(wParam, lParam);   

    // Grab our previously cached pointer to the CHKDSKINFO struct (see WM_INITDIALOG)
    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        // done.  Reset the window title and clear the progress meter
        case PWM_CHKDSKDONE:
        {
            // chdsk is done.  Reset the window title and clear the progress meter
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKDISK);

            SendMessage(GetDlgItem(pChkDskInfo->hDlg,
                        IDC_CHKDSKPROGRESS),
                        PBM_SETPOS,
                        0,  // Reset Percent Complete
                        0);
            EnableChkDskControls(pChkDskInfo);

            if (pChkDskInfo->fCancelled)
            {
                ShellMessageBox(HINST_THISDLL,
                                pChkDskInfo->hDlg,
                                MAKEINTRESOURCE(IDS_CHKDSKCANCELLED),
                                NULL,
                                MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK);
            }

            if (pChkDskInfo->hThread)
            {
                CloseHandle(pChkDskInfo->hThread);
                pChkDskInfo->hThread = NULL;
            }

            EndDialog(hDlg, 0);
        }
        break;

        case WM_INITDIALOG:
            // Initialize the dialog and cache the CHKDSKINFO structure's pointer
            // as our dialog's DWLP_USER data
            pChkDskInfo = (CHKDSKINFO *) lParam;
            pChkDskInfo->hDlg = hDlg;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            // Set the dialog title to indicate which drive we are dealing with
            SetDriveWindowTitle(pChkDskInfo->hDlg, pChkDskInfo->wszDriveName, IDS_CHKDISK);
            break;

        case WM_DESTROY:
            if (pChkDskInfo && pChkDskInfo->hDlg)
            {
                pChkDskInfo->hDlg = NULL;
            }
            break;

        case WM_COMMAND:
        {
            switch (iID)
            {
                case IDC_FIXERRORS:
                    pChkDskInfo->fFixErrors = Button_GetCheck((HWND)lParam);
                    break;

                case IDC_RECOVERY:
                    pChkDskInfo->fRecovery = Button_GetCheck((HWND)lParam);
                    break;

                case IDOK:
                {
                    // Get user verification for chkdsk, break out on CANCEL
                    DisableChkDskControls(pChkDskInfo);

                    pChkDskInfo->fShouldCancel = FALSE;
                    pChkDskInfo->fCancelled    = FALSE;
                
                    AddRefChkDskInfo(pChkDskInfo);
                    pChkDskInfo->hThread = CreateThread(NULL,
                                                        0,
                                                        BeginChkDsk,
                                                        (void *)pChkDskInfo,
                                                        0,
                                                        NULL);
                    if (!pChkDskInfo->hThread)
                    {
                        // ISSUE: we should probably do something here...
                        ReleaseChkDskInfo(pChkDskInfo);
                    }
                }
                break;

                case IDCANCEL:
                {
                    // If the chdsk thread is running, wait for it.  If not,
                    // exit the dialog
                    pChkDskInfo->fCancelled = TRUE;
                    pChkDskInfo->fShouldCancel = TRUE;

                    if (pChkDskInfo->hThread)
                    {
                        DWORD dwWait;

                        do
                        {
                            dwWait =  WaitForSingleObject(pChkDskInfo->hThread, 10000);
                        }
                        while ((WAIT_TIMEOUT == dwWait) &&
                               (IDRETRY == ShellMessageBox(HINST_THISDLL,
                                                           hDlg,
                                                           MAKEINTRESOURCE(IDS_CANTCANCELCHKDSK),
                                                           NULL,
                                                           MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_RETRYCANCEL)));

                        // If the chkdsk doesn't admit to having been killed, it didn't
                        // give up peacefully.  Just abandon it and let it clean up
                        // when it finally gets around to it, at which point we will
                        // enable the controls to let the user take another stab.
                        //
                        // Careful:  The chkdsk may have cleaned up while the dialog box
                        // was up, so revalidate.
                        if (pChkDskInfo->hThread)
                        {
                            CloseHandle(pChkDskInfo->hThread);
                            pChkDskInfo->hThread = NULL;
                            pChkDskInfo->fCancelled = TRUE;
                            EnableChkDskControls(pChkDskInfo);
                        }
                    }
                    else
                    {
                        EndDialog(hDlg, IDCANCEL);
                    }
                }
                break;
            }
        }
        break;
    
        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPSTR)ChkaIds);
            break;
        
        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)ChkaIds);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


#define GET_INTRESOURCE(r) (LOWORD((UINT_PTR)(r)))

static HDPA hpdaChkdskActive = NULL;

//
//  Synopsis:   Same as SHChkDskDrive but takes a path rather than a drive int ID
//              Call this fct for both path and drive int ID to be protected
//              against chkdsk'ing the same drive simultaneously
//
//  Arguments:  [hwnd]     -- Parent window (Must NOT be NULL)
//              [pszDrive] -- INTRESOURCE: string if mounted on folder, drive
//                            number if mounted on drive letter (0 based)
//
STDAPI_(DWORD) SHChkDskDriveEx(HWND hwnd, LPWSTR pszDrive)
{
    HRESULT hr = SHFMT_ERROR;
    WCHAR szUniqueID[50]; // 50: size of VolumeGUID, which can fit "A:\\" too

    CHKDSKINFO *pChkDskInfo = (CHKDSKINFO *)LocalAlloc(LPTR, sizeof(*pChkDskInfo));

    if (pChkDskInfo)
    {
        hr = S_OK;

        // We use a last percentage-complete value of 101, to guarantee that the
        // next one received will be less, indicating next (first) phase
        pChkDskInfo->lastpercent = 101;
        pChkDskInfo->cRef = 1;

        hr = StringCchCopy(pChkDskInfo->wszDriveName, ARRAYSIZE(pChkDskInfo->wszDriveName), pszDrive);
        if (SUCCEEDED(hr))
        {
            if (PathAddBackslash(pChkDskInfo->wszDriveName))
            {
                // Prevent multiple chkdsks of the same drive
                GetVolumeNameForVolumeMountPoint(pChkDskInfo->wszDriveName, szUniqueID, ARRAYSIZE(szUniqueID));

                // scoping ENTERCRITICAL's var definitions to make it cooperate with other ENTERCRITICAL
                {
                    ENTERCRITICAL;
                    if (!hpdaChkdskActive)
                    {
                        hpdaChkdskActive = DPA_Create(1);
                    }

                    if (hpdaChkdskActive)
                    {
                        int i, n = DPA_GetPtrCount(hpdaChkdskActive);

                        // Go through the DPA of currently chkdsk'ed volumes, and check if we're already
                        // processing this volume
                        for (i = 0; i < n; ++i)
                        {
                            LPWSTR pszUniqueID = (LPWSTR)DPA_GetPtr(hpdaChkdskActive, i);

                            if (pszUniqueID)
                            {
                                if (!lstrcmpi(szUniqueID, pszUniqueID))
                                {
                                    // we're already chkdsk'ing this drive
                                    hr = E_FAIL;
                                    break;
                                }
                            }
                        }

                        // Looks like we're currently not chkdsk'ing this volume, add it to the DPA of currently
                        // chkdsk'ed volumes
                        if (S_OK == hr)
                        {
                            LPWSTR pszUniqueID = StrDup(szUniqueID);
                            if (pszUniqueID)
                            {
                                if (-1 == DPA_AppendPtr(hpdaChkdskActive, pszUniqueID))
                                {
                                     LocalFree((HLOCAL)pszUniqueID);

                                     // if can't allocate room to store a pointer, pretty useless to go on
                                     hr = E_FAIL;
                                }
                            }
                        }
                    }
                    LEAVECRITICAL;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
            }
        }

        // Load the FMIFS DLL and open the ChkDsk dialog
        if (S_OK == hr)
        {
            if (S_OK == LoadFMIFS(&(pChkDskInfo->fmifs)))
            {
                INT_PTR ret;
                INITCOMMONCONTROLSEX icc = {sizeof(icc), ICC_PROGRESS_CLASS};
                InitCommonControlsEx(&icc);

                ret = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_CHKDSK),
                                     hwnd, ChkDskDlgProc, (LPARAM) pChkDskInfo);
                if (-1 == ret)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    if (IDCANCEL == ret)
                    {
                        hr = S_FALSE;
                    }
                }
            }
            else
            {
                ASSERT(0 && "Can't load FMIFS.DLL");
                hr = E_OUTOFMEMORY;
            }

            // We're finish for this volume, remove from the list of currently processed volumes
            ENTERCRITICAL;
            if (hpdaChkdskActive)
            {
                int i, n = DPA_GetPtrCount(hpdaChkdskActive);

                for (i = 0; i < n; ++i)
                {
                    LPWSTR pszUniqueID = (LPWSTR)DPA_GetPtr(hpdaChkdskActive, i);
                    if (pszUniqueID)
                    {
                        if (!lstrcmpi(szUniqueID, pszUniqueID))
                        {
                            LocalFree((HLOCAL)pszUniqueID);

                            DPA_DeletePtr(hpdaChkdskActive, i);
                            break;
                        }
                    }
                }
            }
            LEAVECRITICAL;
        }

        // If the DPA is empty delete it
        ENTERCRITICAL;
        if (hpdaChkdskActive && !DPA_GetPtrCount(hpdaChkdskActive))
        {
            DPA_Destroy(hpdaChkdskActive);
            hpdaChkdskActive = NULL;
        }
        LEAVECRITICAL;

        ReleaseChkDskInfo(pChkDskInfo);
    }

    return (DWORD) hr;
}

//****************************************************************************
//
//  Special hook for Win9x app compat
//
//  Some Win9x apps like to WinExec("DEFRAG") or WinExec("SCANDSKW")
//  even though those apps don't exist on Windows NT.  When such apps
//  are found, we can shim them to come here instead.
BOOL ScanDskW_OnInitDialog(HWND hdlg)
{
    HICON hico;
    HWND hwndList;
    SHFILEINFO sfi;
    HIMAGELIST himlSys;
    RECT rc;
    LVCOLUMN lvc;
    int iDrive;
    TCHAR szDrive[4];

    hico = (HICON)SendDlgItemMessage(hdlg, IDC_SCANDSKICON, STM_GETICON, 0, 0);
    SendMessage(hdlg, WM_SETICON, ICON_BIG, (LPARAM)hico);
    SendMessage(hdlg, WM_SETICON, ICON_SMALL, (LPARAM)hico);

    hwndList = GetDlgItem(hdlg, IDC_SCANDSKLV);

    if (Shell_GetImageLists(NULL, &himlSys))
    {
        ListView_SetImageList(hwndList, himlSys, LVSIL_SMALL);
    }

    GetClientRect(hwndList, &rc);

    lvc.mask = LVCF_WIDTH;
    lvc.cx = rc.right;
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwndList, 0, &lvc);

    for (iDrive = 0; iDrive < 26; iDrive++)
    {
        PathBuildRoot(szDrive, iDrive);
        switch (GetDriveType(szDrive))
        {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        case DRIVE_REMOTE:
        case DRIVE_CDROM:
            break;          // Can't scan these drives

        default:
            if (SHGetFileInfo(szDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                              SHGFI_USEFILEATTRIBUTES |
                              SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_DISPLAYNAME))
            {
                LVITEM lvi;
                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvi.iItem = MAXLONG;
                lvi.iSubItem = 0;
                lvi.pszText = sfi.szDisplayName;
                lvi.iImage = sfi.iIcon;
                lvi.lParam = iDrive;
                ListView_InsertItem(hwndList, &lvi);
            }
            break;
        }

    }

    return TRUE;
}

void ScanDskW_OnOk(HWND hdlg)
{
    HWND hwndList = GetDlgItem(hdlg, IDC_SCANDSKLV);

    LVITEM lvi;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (lvi.iItem >= 0)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;
        if (ListView_GetItem(hwndList, &lvi))
        {
            TCHAR szDrive[4];
            PathBuildRoot(szDrive, (int)lvi.lParam);
            SHChkDskDriveEx(hdlg, szDrive);
        }
    }
}

INT_PTR CALLBACK
ScanDskW_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
        case WM_INITDIALOG:
            return ScanDskW_OnInitDialog(hdlg);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    ScanDskW_OnOk(hdlg);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, 0);
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm->code == LVN_ITEMCHANGED)
            {
                EnableWindow(GetDlgItem(hdlg, IDOK), ListView_GetSelectedCount(GetDlgItem(hdlg, IDC_SCANDSKLV)));
            }
        }
        break;
    }

    return FALSE;
}

// Right now, we have only one app compat shim entry point (SCANDSKW)
// In the future we can add others to the command line.

STDAPI_(void) AppCompat_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    TCHAR szCmd[MAX_PATH];
    LPTSTR pszArgs;

    HRESULT hr = StringCchCopy(szCmd, ARRAYSIZE(szCmd), lpwszCmdLine);
    if (SUCCEEDED(hr))
    {
        pszArgs = PathGetArgs(szCmd);
        PathRemoveArgs(szCmd);


        if (lstrcmpi(szCmd, L"SCANDSKW") == 0) {
            DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_SCANDSKW), NULL,
                           ScanDskW_DlgProc, (LPARAM)pszArgs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsassoc.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <limits.h>
#include <shlwapi.h>
#include <objwindow.h>
#include "ids.h"
#include "fassoc.h"

STDAPI InitFileFolderClassNames(void);

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid);

#define AIF_TEMPKEY     0x1     // temp class key created for the selected exe
#define AIF_SHELLNEW    0x2     // class key with shellnew subkey

#define MAXKEYNAME    128



HRESULT _GetURL(BOOL fXMLLookup, LPCTSTR pszExt, LPTSTR pszURL, DWORD cchSize)
{
    LANGID nLangID = GetUserDefaultUILanguage();
    LPCTSTR pszValue = (fXMLLookup ? TEXT("XMLLookup") : TEXT("Application"));

    ASSERT(pszExt && pszExt[0] && pszExt[0] == L'.' && pszExt[1]);

    if (0x0409 != nLangID)
    {
        // We redirect to a single web page on intl so we can handle any languages we don't support
        pszValue = TEXT("intl");
    }

    TCHAR szUrlTemplate[MAX_URL_STRING];
    DWORD cbSize = sizeof(szUrlTemplate);
    HRESULT hr = SKGetValue(SHELLKEY_HKLM_EXPLORER, TEXT("Associations"), pszValue, NULL, szUrlTemplate, &cbSize);
    if (SUCCEEDED(hr))
    {
        wnsprintf(pszURL, cchSize, szUrlTemplate, nLangID, CharNext(pszExt));
    }

    return hr;
}


HRESULT _OpenDownloadURL(HWND hwnd, LPCTSTR pszExt)
{
    TCHAR szUrl[MAX_URL_STRING];
    HRESULT hr = _GetURL(FALSE, pszExt, szUrl, ARRAYSIZE(szUrl));

    if (SUCCEEDED(hr))
    {
        HINSTANCE hReturn = ShellExecute(hwnd, NULL, szUrl, NULL, NULL, SW_SHOWNORMAL);

        if (hReturn < (HINSTANCE)32)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return S_OK;
}



class CInternetOpenAs : public CObjectWindow
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT DisplayDialog(HWND hwndParent, LPCTSTR pszFile);

    CInternetOpenAs(void);

private:
    virtual ~CInternetOpenAs(void);
    // Private Member Variables
    long                    m_cRef;

    LPTSTR                  _pszFilename;
    LPTSTR                  _pszExt;
    HWND                    _hwndParent;


    // Private Member Functions
    HRESULT _OnInitDlg(HWND hDlg);
    HRESULT _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnNotify(HWND hDlg, LPARAM lParam);

    INT_PTR _InternetOpenDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK InternetOpenDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#define WMUSER_CREATETOOLTIP        (WM_USER + 1)       // lParam is the hwndParent, wParam is the WSTR.


typedef CAppInfo APPINFO;

class COpenAs
{
public:
    ULONG AddRef();
    ULONG Release();

    friend BOOL_PTR CALLBACK OpenAsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend BOOL_PTR CALLBACK NoOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend HRESULT OpenAsDialog(HWND hwnd, POPENASINFO poainfo);

    void OnOk();

private:
    // params
    HWND _hwnd;                          // parent window
    POPENASINFO _poainfo;

    // local data
    long _cRef;
    int _idDlg;                          // open as dialog type: DLG_OPENAS_NOTYPE or DLG_OPENAS
    HWND _hDlg;                          // open as dialog window handle
    HWND _hwndList;                      // app list
    LPTSTR _pszExt;
    TCHAR _szNoOpenMsg[MAX_PATH];
    TCHAR _szDescription[CCH_KEYMAX];    // file type description
    HRESULT _hr;
    HTREEITEM _hItemRecommended;         // root items to group programs
    HTREEITEM _hItemOthers;

    // constructer
    COpenAs(HWND hwnd, POPENASINFO poainfo) : _hwnd(hwnd), _poainfo(poainfo), _cRef(1)
    {
        _pszExt = PathFindExtension(poainfo->pcszFile);
    }

    // other methods
    HTREEITEM _AddAppInfoItem(APPINFO *pai, HTREEITEM hParentItem);
    HTREEITEM _AddFromNewStorage(IAssocHandler *pah);
    HTREEITEM _AddRootItem(BOOL bRecommended);
    APPINFO *_TVFindAppInfo(HTREEITEM hItem);
    HTREEITEM _TVFindItemByHandler(HTREEITEM hParentItem, LPCTSTR pszHandler);
    UINT _FillListByEnumHandlers();
    UINT _FillListWithHandlers();
    void _InitOpenAsDlg();
    BOOL RunAs(APPINFO *pai);
    void OpenAsOther();
    BOOL OpenAsMakeAssociation(LPCWSTR pszDesc, LPCWSTR pszHandler, HKEY hkey);
    void _InitNoOpenDlg();
    HRESULT _OpenAsDialog();
    void _OnNotify(HWND hDlg, LPARAM lParam);
    HRESULT _InternetOpen(void);
};

ULONG COpenAs::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}

ULONG COpenAs::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI SHCreateAssocHandler(LPCWSTR pszExt, LPCWSTR pszApp, IAssocHandler **ppah);
void COpenAs::OpenAsOther()
{
    TCHAR szApp[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    *szApp = '\0';
    SHExpandEnvironmentStrings(TEXT("%ProgramFiles%"), szPath, ARRAYSIZE(szPath));
    // do a file open browse
    if (GetFileNameFromBrowse(_hDlg, szApp, ARRAYSIZE(szApp), szPath,
            MAKEINTRESOURCE(IDS_EXE), MAKEINTRESOURCE(IDS_PROGRAMSFILTER), MAKEINTRESOURCE(IDS_OPENAS)))
    {
        IAssocHandler *pah;        
        if (SUCCEEDED(SHCreateAssocHandler(_pszExt, szApp, &pah)))
        {
            CAppInfo *pai = new CAppInfo(pah);
            if (pai)
            {
                HTREEITEM hItem = NULL;
                if (pai->Init())
                {
                    hItem = _TVFindItemByHandler(_hItemRecommended, pai->Name());
                    if (!hItem && _hItemOthers)
                        hItem = _TVFindItemByHandler(_hItemOthers, pai->Name());

                    if (!hItem)
                    {
                        hItem = _AddAppInfoItem(pai, _hItemOthers);
                        if (hItem)
                            pai = NULL;
                    }
                            
                }
                // Select it
                if (hItem)
                {
                    TreeView_SelectItem(_hwndList, hItem);
                    SetFocus(_hwndList);
                }

                if (pai)
                    delete pai;
            }
            pah->Release();
        }
    }
}

HTREEITEM COpenAs::_AddAppInfoItem(APPINFO *pai, HTREEITEM hParentItem)
{
    TVINSERTSTRUCT tvins = {0}; 
 
    tvins.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM; 
    tvins.item.iSelectedImage = tvins.item.iImage = pai->IconIndex();        

    tvins.item.pszText = (LPWSTR) pai->UIName();
    tvins.item.cchTextMax = lstrlen(pai->UIName())+1; 
    
    tvins.item.lParam = (LPARAM) pai; 
    tvins.hInsertAfter = TVI_SORT;

    // If NULL, all programs are listed as root items
    tvins.hParent = hParentItem; 
    
    return TreeView_InsertItem(_hwndList, &tvins); 
}

HTREEITEM COpenAs::_AddFromNewStorage(IAssocHandler *pah)
{
    HTREEITEM hitem = NULL;
    CAppInfo *pai = new CAppInfo(pah);
    if (pai)
    {
        // Trim duplicate items before we add them for other programs
        if (pai->Init()
        && (!_hItemRecommended || !_TVFindItemByHandler(_hItemRecommended, pai->Name())))
        {
            hitem = _AddAppInfoItem(pai, S_OK == pah->IsRecommended() ? _hItemRecommended : _hItemOthers);
        }

        if (!hitem)
        {
            delete pai;
        }
    }
    return hitem;
}

HTREEITEM COpenAs::_AddRootItem(BOOL bRecommended)
{
    TCHAR sz[MAX_PATH];

    int iLen = LoadString(g_hinst, (bRecommended? IDS_OPENWITH_RECOMMENDED : IDS_OPENWITH_OTHERS), sz, ARRAYSIZE(sz));

    if (iLen)
    {
        TVINSERTSTRUCT tvins = {0}; 
 
        tvins.item.mask = TVIF_TEXT | TVIF_STATE |TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvins.item.pszText = sz;
        tvins.item.cchTextMax = iLen;
        tvins.item.stateMask = tvins.item.state = TVIS_EXPANDED; // Expand child items by default
        tvins.hInsertAfter = TVI_ROOT; 
        tvins.hParent = NULL;
        //
        // Currently, we use program icon.
        // Change it if PM/UI designer have more appropriate one.
        //
        tvins.item.iSelectedImage = tvins.item.iImage = Shell_GetCachedImageIndex(c_szShell32Dll, II_STPROGS, 0); 

        return TreeView_InsertItem(_hwndList, &tvins);
    }

    return NULL;
}

APPINFO *COpenAs::_TVFindAppInfo(HTREEITEM hItem)
{
    // if hItem not specified, use current selected item
    if (!hItem)
        hItem = TreeView_GetSelection(_hwndList);

    if (hItem)
    {
        TVITEM tvi = {0};

        tvi.mask = TVIF_HANDLE;
        tvi.hItem = hItem;

        if (TreeView_GetItem(_hwndList, &tvi))        
            return ((APPINFO *) tvi.lParam);
    }

    return NULL;
}


HTREEITEM COpenAs::_TVFindItemByHandler(HTREEITEM hParentItem, LPCTSTR pszHandler)
{
    // if we have parent item, search its children, otherwise search root items
    HTREEITEM hItem = TreeView_GetNextItem(_hwndList, hParentItem, hParentItem ? TVGN_CHILD : TVGN_ROOT );
    while (hItem)
    {
        APPINFO *pai = _TVFindAppInfo(hItem);

        if (pai && !StrCmpI(pai->Name(), pszHandler))
            return hItem;

        hItem = TreeView_GetNextItem(_hwndList, hItem, TVGN_NEXT);
    }

    return NULL;
}


UINT COpenAs::_FillListByEnumHandlers()
{
    IEnumAssocHandlers *penum;
    UINT cHandlers = 0;

    if (SUCCEEDED(SHAssocEnumHandlers(_pszExt, &penum)))
    {
        HTREEITEM hitemFocus = NULL;
        BOOL fFirst = TRUE;
        IAssocHandler *pah;
        while (S_OK == penum->Next(1, &pah, NULL))
        {
            if (fFirst)
            {
                //
                // Group programs to "recommended" and "others" only when we can get two different group of programs
                // Otherwise, all programs are listed as root items
                // Note: in our storage,  general handlers is always a superset of extension related handlers
                //
                //  if the first item is recommended,
                //  then we add the recommended node
                //
                if (S_OK == pah->IsRecommended())
                {
                    _hItemRecommended = _AddRootItem(TRUE);
                    _hItemOthers = _AddRootItem(FALSE);
                }
                fFirst = FALSE;
            }
                
            HTREEITEM hitem = _AddFromNewStorage(pah);
            if (!hitemFocus && hitem && S_OK == pah->IsRecommended())
            {
                //  we put focus on the first recommended item
                //  the enum starts with the best 
                hitemFocus = hitem;
            }

            cHandlers++;
        }

        if (cHandlers && _hItemRecommended)
        {
            if (!hitemFocus)
                hitemFocus = TreeView_GetNextItem(_hwndList, _hItemRecommended, TVGN_CHILD);
            TreeView_SelectItem(_hwndList, hitemFocus);
        }
        
        penum->Release();
    }

    return cHandlers;
}


UINT COpenAs::_FillListWithHandlers()
{
    UINT cHandlers = _FillListByEnumHandlers();

    //
    // Set focus on the first recommended program if we have program groups
    // Otherwise, all programs are root items, focus will be set to the first item by default
    //

    return cHandlers;
}

void COpenAs::_InitOpenAsDlg()
{
    TCHAR szFileName[MAX_PATH];
    BOOL fDisableAssociate;
    HIMAGELIST himl;
    RECT rc;

    // Don't let the file name go beyond the width of one line...
    lstrcpy(szFileName, PathFindFileName(_poainfo->pcszFile));
    GetClientRect(GetDlgItem(_hDlg, IDD_TEXT), &rc);

    PathCompactPath(NULL, szFileName, rc.right - 4 * GetSystemMetrics(SM_CXBORDER));

    SetDlgItemText(_hDlg, IDD_FILE_TEXT, szFileName);

    // AraBern 07/20/99, specific to TS on NT, but can be used on NT without TS
    //  this restriction doesnt apply to admins
    if (SHRestricted(REST_NOFILEASSOCIATE) && !IsUserAnAdmin())
    {
        CheckDlgButton(_hDlg, IDD_MAKEASSOC, FALSE);
        ShowWindow(GetDlgItem(_hDlg, IDD_MAKEASSOC), SW_HIDE);
    }
    else
    {
        // Don't allow associations to be made for things we consider exes...
        fDisableAssociate = (! (_poainfo->dwInFlags & OAIF_ALLOW_REGISTRATION) ||
                        PathIsExe(_poainfo->pcszFile));
                        
        // check IDD_MAKEASSOC only for unknown file type and those with OAIF_FORCE_REGISTRATION flag set
        if ((_poainfo->dwInFlags & OAIF_FORCE_REGISTRATION) ||
            (_idDlg != DLG_OPENAS && !fDisableAssociate))
        {
            CheckDlgButton(_hDlg, IDD_MAKEASSOC, TRUE);
        }

        if (fDisableAssociate)
            EnableWindow(GetDlgItem(_hDlg, IDD_MAKEASSOC), FALSE);
    }

    _hwndList = GetDlgItem(_hDlg, IDD_APPLIST);
    Shell_GetImageLists(NULL, &himl);
    TreeView_SetImageList(_hwndList, himl, TVSIL_NORMAL); 

    // Leave space between ICON images - SM_CXEDGE
    TreeView_SetItemHeight(_hwndList, TreeView_GetItemHeight(_hwndList) + GetSystemMetrics(SM_CXEDGE));

    if (!_FillListWithHandlers())
    {
        // lets force the expensive walk
        IRunnableTask *ptask;
        if (SUCCEEDED(CTaskEnumHKCR_Create(&ptask)))
        {
            ptask->Run();
            ptask->Release();
            _FillListWithHandlers();
        }
    }

    // initialize the OK button
    EnableWindow(GetDlgItem(_hDlg, IDOK), (TreeView_GetSelection(_hwndList) != NULL));

    ShowWindow(GetDlgItem(_hDlg, IDD_OPENWITH_WEBSITE), (_poainfo->dwInFlags & OAIF_ALLOW_REGISTRATION) ? SW_SHOW : SW_HIDE);
    
    InitFileFolderClassNames();
}


BOOL COpenAs::RunAs(APPINFO *pai)
{
    pai->Handler()->Exec(_hwnd, _poainfo->pcszFile);
    SHAddToRecentDocs(SHARD_PATH, _poainfo->pcszFile);
    return TRUE;
}

void COpenAs::_InitNoOpenDlg()
{
    SHFILEINFO sfi;
    HICON hIcon;
    TCHAR szFormat[MAX_PATH], szTemp[MAX_PATH];

    GetDlgItemText(_hDlg, IDD_TEXT1, szFormat, ARRAYSIZE(szFormat));
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szFormat, _szDescription, (_pszExt ? _pszExt : TEXT("")));
    SetDlgItemText(_hDlg, IDD_TEXT1, szTemp);

    if (*_szNoOpenMsg)
        SetDlgItemText(_hDlg, IDD_TEXT2, _szNoOpenMsg);

    if (SHGetFileInfo(_poainfo->pcszFile, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON)
        && NULL != sfi.hIcon)
    {
        hIcon = sfi.hIcon;
    }
    else
    {
        HIMAGELIST himl;
        Shell_GetImageLists(&himl, NULL);
        hIcon = ImageList_ExtractIcon(g_hinst, himl, II_DOCNOASSOC);
    }
    hIcon = (HICON)SendDlgItemMessage(_hDlg, IDD_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    if ( hIcon )
    {
        DestroyIcon(hIcon);
    }
}


HRESULT COpenAs::_InternetOpen(void)
{
    HRESULT hr = E_OUTOFMEMORY;
    CInternetOpenAs * pInternetOpenAs = new CInternetOpenAs();

    if (pInternetOpenAs)
    {
        DWORD dwValue;
        DWORD cbSize = sizeof(dwValue);
        DWORD dwType;

        hr = S_OK;
        if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"), TEXT("NoInternetOpenWith"), &dwType, (void *)&dwValue, &cbSize)) || (0 == dwValue))
        {
            // If the policy is not set, use the feature.
            hr = pInternetOpenAs->DisplayDialog(_hwnd, _poainfo->pcszFile);
        }

        pInternetOpenAs->Release();
    }

    return hr;
}

class COpenAsAssoc
{
public:
    COpenAsAssoc(PCWSTR pszExt);
    ~COpenAsAssoc() {ATOMICRELEASE(_pqa);}

    BOOL HasClassKey();
    BOOL HasCommand();
    BOOL GetDescription(PWSTR psz, DWORD cch);
    BOOL GetNoOpen(PWSTR psz, DWORD cch);

protected:
    IQueryAssociations *_pqa;        
    HRESULT _hrInit;
};

COpenAsAssoc::COpenAsAssoc(PCWSTR pszExt)
{
    AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));
    if (FAILED(_pqa->Init(ASSOCF_INIT_DEFAULTTOSTAR, pszExt, NULL, NULL)))
        ATOMICRELEASE(_pqa);
}
    
BOOL COpenAsAssoc::HasClassKey()
{
    BOOL fRet = FALSE;
    if (_pqa)
    {
        HKEY hk;
        if (SUCCEEDED(_pqa->GetKey(ASSOCF_IGNOREBASECLASS, ASSOCKEY_CLASS, NULL, &hk)))
        {
            RegCloseKey(hk);
            fRet = TRUE;
        }
    }
    return fRet;
}
    
BOOL COpenAsAssoc::HasCommand()
{
    DWORD cch;
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(ASSOCF_IGNOREBASECLASS, ASSOCSTR_COMMAND, NULL, NULL, &cch));
    return FALSE;
}
    
BOOL COpenAsAssoc::GetDescription(PWSTR psz, DWORD cch)
{
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, psz, &cch));
    return FALSE;
}

BOOL COpenAsAssoc::GetNoOpen(PWSTR psz, DWORD cch)
{
    if (_pqa)
        return SUCCEEDED(_pqa->GetString(ASSOCF_IGNOREBASECLASS, ASSOCSTR_NOOPEN, NULL, psz, &cch));
    return FALSE;
}    

const PCWSTR s_rgImageExts[] = 
{
    { TEXT(".bmp")},
    { TEXT(".dib")},
    { TEXT(".emf")},
    { TEXT(".gif")},
    { TEXT(".jfif")},
    { TEXT(".jpg")},
    { TEXT(".jpe")},
    { TEXT(".jpeg")},
    { TEXT(".png")},
    { TEXT(".tif")},
    { TEXT(".tiff")},
    { TEXT(".wmf")},
    { NULL}
};

BOOL _IsImageExt(PCWSTR pszExt)
{
    for (int i = 0; s_rgImageExts[i] ; i++)
    {
        if (0 == StrCmpIW(pszExt, s_rgImageExts[i]))
            return TRUE;
    }
    return FALSE;
}

static const PCWSTR s_rgZipExts[] = 
{
    { TEXT(".zip")},
    { NULL}
};

static const struct 
{
    const PCWSTR *rgpszExts;
    PCWSTR pszDll;
} s_rgFixAssocs[] = {
    { s_rgImageExts, L"shimgvw.dll" },
    { s_rgZipExts, L"zipfldr.dll" },
    //     { s_rgWmpExts, L"wmp.dll" },
};


PCWSTR _WhichDll(PCWSTR pszExt)
{
    for (int i = 0; i < ARRAYSIZE(s_rgFixAssocs); i++)
    {
        for (int j = 0; s_rgFixAssocs[i].rgpszExts[j] ; j++)
        {
            if (0 == StrCmpIW(pszExt, s_rgFixAssocs[i].rgpszExts[j]))
                return s_rgFixAssocs[i].pszDll;
        }
    }
    return NULL;
}

BOOL _CreateProcessWithArgs(LPCTSTR pszApp, LPCTSTR pszArgs, LPCTSTR pszDirectory, PROCESS_INFORMATION *ppi)
{
    STARTUPINFO si = {0};
    si.cb = sizeof(si);
    TCHAR szCommandLine[MAX_PATH * 2];
    wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), L"\"%s\" %s", pszApp, pszArgs);
    return CreateProcess(pszApp, szCommandLine, NULL, NULL, FALSE, 0, NULL, pszDirectory, &si, ppi);
}


void _GetSystemPathItem(PCWSTR pszItem, PWSTR pszPath, DWORD cch)
{
    GetSystemDirectory(pszPath, cch);
    PathCombine(pszPath, pszPath, pszItem);
}
    
BOOL _Regsvr32Dll(PCWSTR pszDll)
{
    WCHAR szReg[MAX_PATH];
    WCHAR szDll[MAX_PATH + 3] = L"/s ";
    _GetSystemPathItem(L"regsvr32.exe", szReg, ARRAYSIZE(szReg));
    _GetSystemPathItem(pszDll, szDll + 3, ARRAYSIZE(szDll) - 3);
    
    PROCESS_INFORMATION pi = {0};
    if (_CreateProcessWithArgs(szReg, szDll, NULL, &pi))
    {
        WaitForSingleObject(pi.hProcess, INFINITE);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return TRUE;
    }
    return FALSE;
}

BOOL _FixAssocs(PCWSTR pszExt)
{
    PCWSTR pszDll = _WhichDll(pszExt);
    if (pszDll)
    {
        _Regsvr32Dll(pszDll);
        COpenAsAssoc oac(pszExt);
        return oac.HasCommand();
    }
    return FALSE;
}

HRESULT COpenAs::_OpenAsDialog()
{
    BOOL fHasCommand = FALSE;
    int idDlg = DLG_OPENAS_NOTYPE;

    // Depending on policy, do not allow user to change file type association.
    if (SHRestricted(REST_NOFILEASSOCIATE))
    {
        _poainfo->dwInFlags &= ~OAIF_ALLOW_REGISTRATION & ~OAIF_REGISTER_EXT;
    }

    // We don't allow association for files without extension or with only "." as extension
    if (!_pszExt || !_pszExt[0] || !_pszExt[1])
    {
        idDlg = DLG_OPENAS;
        _poainfo->dwInFlags &= ~OAIF_ALLOW_REGISTRATION;
    }
    // Known file type(has verb): use DLG_OPENAS
    // NoOpen file type(has NoOpen value): use DLG_NOOPEN
    // Unknown file type(All others): use DLG_OPENAS_NOTYPE
    else
    {
        COpenAsAssoc oac(_pszExt);
        fHasCommand = oac.HasCommand();
        if (oac.HasClassKey())
        {
            idDlg = DLG_OPENAS;
            oac.GetDescription(_szDescription, ARRAYSIZE(_szDescription));
            if (oac.GetNoOpen(_szNoOpenMsg, ARRAYSIZE(_szNoOpenMsg))
            && !fHasCommand)
            {
                INITCOMMONCONTROLSEX initComctl32;

                initComctl32.dwSize = sizeof(initComctl32); 
                initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
                InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow
                if ((-1 != DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_NOOPEN), _hwnd, NoOpenDlgProc, (LPARAM)this)) 
                    && _hr == S_FALSE)
                {
                    // user selected cancel
                    return _hr;
                }
            }                
        }

        //  if this is a busted file association, maybe we can fix it...
        if ((OAIF_REGISTER_EXT & _poainfo->dwInFlags) && !fHasCommand)
        {
            //  this feels like an unknown type
            if (_FixAssocs(_pszExt))
            {
                SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL);

                // Exec if requested. 
                if (_poainfo->dwInFlags & OAIF_EXEC)
                {
                    IAssocHandler *pah;        
                    if (SUCCEEDED(SHCreateAssocHandler(_pszExt, NULL, &pah)))
                    {
                        CAppInfo *pai = new CAppInfo(pah);
                        if (pai)
                        {
                            if (pai->Init())
                            {
                                RunAs(pai);
                            }
                            delete pai;
                        }
                        pah->Release();
                    }
                }

                return S_OK;
            }
        }
    }
    
    _idDlg = idDlg;

    HRESULT hr = _hr;
    LinkWindow_RegisterClass();
    // If this is the dialog where we don't know the file type and the feature is turned on,
    // use the Internet Open As dialog.
    //  only do internet stuff if we can should affect file assoc's
    if ((FALSE == fHasCommand) && (_poainfo->dwInFlags & OAIF_ALLOW_REGISTRATION) &&
        SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("InternetOpenWith"), FALSE, TRUE))
    {
        hr = _InternetOpen();
    }

    // Display the old dialog if fUseInternetOpenAs is NOT set.  Or display it if the user
    // chooses "Choose..." in that dialog.
    if (SUCCEEDED(hr))
    {
        INITCOMMONCONTROLSEX initComctl32;

        initComctl32.dwSize = sizeof(initComctl32); 
        initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
        InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow
        if (TRUE != DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(idDlg), _hwnd, OpenAsDlgProc, (LPARAM)this))
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}


BOOL_PTR CALLBACK NoOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    COpenAs *pOpenAs = (COpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pOpenAs = (COpenAs *)lParam;
        pOpenAs->_hDlg = hDlg;
        pOpenAs->_InitNoOpenDlg();
        break;

    case WM_COMMAND:
        ASSERT(pOpenAs);
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_OPENWITH:
            //  this will cause the open with dialog
            //  to follow this dialog
            pOpenAs->_hr = S_OK;
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            pOpenAs->_hr = S_FALSE;
            EndDialog(hDlg, TRUE);
            break;
        }
        break;

    default:
        return FALSE;
    }
    
    return TRUE;
}



const static DWORD aOpenAsHelpIDs[] = {  // Context Help IDs
    IDD_ICON,             IDH_FCAB_OPENAS_APPLIST,
    IDD_TEXT,             IDH_FCAB_OPENAS_APPLIST,
    IDD_FILE_TEXT,        (DWORD) -1,
    IDD_DESCRIPTIONTEXT,  IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_DESCRIPTION,      IDH_FCAB_OPENAS_DESCRIPTION,
    IDD_APPLIST,          IDH_FCAB_OPENAS_APPLIST,
    IDD_MAKEASSOC,        IDH_FCAB_OPENAS_MAKEASSOC,
    IDD_OTHER,            IDH_FCAB_OPENAS_OTHER,
    IDD_OPENWITH_BROWSE,  IDH_FCAB_OPENAS_OTHER,
    IDD_OPENWITH_WEBSITE, IDH_FCAB_OPENWITH_LOOKONWEB,
    0, 0
};

const static DWORD aOpenAsDownloadHelpIDs[] = {  // Context Help IDs
    IDD_ICON,             (DWORD) -1,
    IDD_FILE_TEXT,        (DWORD) -1,
    // For DLG_OPENAS_DOWNALOAD
    IDD_WEBAUTOLOOKUP,    IDH_CANNOTOPEN_USEWEB,
    IDD_OPENWITHLIST,     IDH_CANNOTOPEN_SELECTLIST,

    0, 0
};

void COpenAs::_OnNotify(HWND hDlg, LPARAM lParam)
{
    switch (((NMHDR *)lParam)->code)
    {
    case TVN_DELETEITEM:
        if (lParam)
        {
            APPINFO *pai = (APPINFO *)(((LPNMTREEVIEW) lParam )->itemOld.lParam);
            if (pai)
            {
                delete pai;
            }
        }
        break;

    case TVN_SELCHANGED:            
        EnableWindow(GetDlgItem(hDlg, IDOK), (_TVFindAppInfo(TreeView_GetSelection(NULL)) != NULL));
        break;

    case NM_DBLCLK:
        if (IsWindowEnabled(GetDlgItem(hDlg, IDOK)))
            PostMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, hDlg, 0));
        break;

    case NM_RETURN:
    case NM_CLICK:
        if (lParam)
        {
            PNMLINK pNMLink = (PNMLINK) lParam;

            if (!StrCmpW(pNMLink->item.szID, L"Browse"))
            {
                _OpenDownloadURL(_hwnd, _pszExt);
                EndDialog(hDlg, FALSE);
            }
        }
        break;
    }
}

void COpenAs::OnOk()
{
    APPINFO *pai = _TVFindAppInfo(NULL);

    if (pai)
    {
        // See if we should make an association or not...
        GetDlgItemText(_hDlg, IDD_DESCRIPTION, _szDescription, ARRAYSIZE(_szDescription));
    
        if ((_poainfo->dwInFlags & OAIF_REGISTER_EXT)
        && (IsDlgButtonChecked(_hDlg, IDD_MAKEASSOC)))
        {
            pai->Handler()->MakeDefault(_szDescription);
        }

        // Did we register the association? 
        _hr = IsDlgButtonChecked(_hDlg, IDD_MAKEASSOC) ? S_OK : S_FALSE;

        // Exec if requested. 
        if (_poainfo->dwInFlags & OAIF_EXEC)
        {
            RunAs(pai);
        }

        EndDialog(_hDlg, TRUE);
    }
}


BOOL_PTR CALLBACK OpenAsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    COpenAs *pOpenAs = (COpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pOpenAs = (COpenAs *)lParam;
        if (pOpenAs)
        {
            pOpenAs->_hDlg = hDlg;
            pOpenAs->_InitOpenAsDlg();
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aOpenAsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
            return FALSE;   // don't process it
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *)aOpenAsHelpIDs);
        break;

    case WM_NOTIFY:
        if (pOpenAs)
        {
            pOpenAs->_OnNotify(hDlg, lParam);
        }
        break;

    case WM_COMMAND:
        ASSERT(pOpenAs);
        if (pOpenAs)
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDD_OPENWITH_BROWSE:
                pOpenAs->OpenAsOther();
                break;

            case IDOK:
                {
                    pOpenAs->OnOk();
                }
                break;

            case IDCANCEL:
                pOpenAs->_hr = E_ABORT;            
                EndDialog(hDlg, FALSE);
                break;
            }
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

// external API version

HRESULT 
OpenAsDialog(
    HWND        hwnd, 
    POPENASINFO poainfo)
{
    HRESULT hr = E_OUTOFMEMORY;    

    COpenAs *pOpenAs = new COpenAs(hwnd, poainfo);
    DebugMsg(DM_TRACE, TEXT("Enter OpenAs for %s"), poainfo->pcszFile);
    if (pOpenAs)
    {
        hr = pOpenAs->_OpenAsDialog();
        pOpenAs->Release();
    }

    return hr;
}

void WINAPI OpenAs_RunDLL(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();            // Needed for SysLink's IAccessability (LresultFromObject)
    OPENASINFO oainfo = { 0 };

    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);

        DebugMsg(DM_TRACE, TEXT("OpenAs_RunDLL is called with (%s)"), lpwszCmdLine);

        oainfo.pcszFile = lpwszCmdLine;
        oainfo.dwInFlags = (OAIF_ALLOW_REGISTRATION |
                            OAIF_REGISTER_EXT |
                            OAIF_EXEC);

        OpenAsDialog(hwnd, &oainfo);

        LocalFree(lpwszCmdLine);
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}


void WINAPI OpenAs_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();            // Needed for SysLink's IAccessability (LresultFromObject)
    OPENASINFO oainfo = { 0 };

    DebugMsg(DM_TRACE, TEXT("OpenAs_RunDLL is called with (%s)"), lpwszCmdLine);

    oainfo.pcszFile = lpwszCmdLine;
    oainfo.dwInFlags = (OAIF_ALLOW_REGISTRATION |
                        OAIF_REGISTER_EXT |
                        OAIF_EXEC);

    OpenAsDialog(hwnd, &oainfo);

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}





#ifdef DEBUG
//
// Type checking
//
const static RUNDLLPROCA lpfnRunDLL = OpenAs_RunDLL;
const static RUNDLLPROCW lpfnRunDLLW = OpenAs_RunDLLW;
#endif

//===========================
// *** Private Methods ***
//===========================
HRESULT CreateWindowTooltip(HWND hDlg, HWND hwndWindow, LPCTSTR pszText)
{
    HRESULT hr = E_OUTOFMEMORY;
    HWND hwndToolTipo = CreateWindow(TOOLTIPS_CLASS, c_szNULL, WS_POPUP | TTS_NOPREFIX, CW_USEDEFAULT, CW_USEDEFAULT,
                                    CW_USEDEFAULT, CW_USEDEFAULT, hDlg, NULL, HINST_THISDLL, NULL);

    if (hwndToolTipo)
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = hDlg;
        ti.uId = (UINT_PTR)hwndWindow;
        ti.lpszText = (LPTSTR)pszText;  // const -> non const
        ti.hinst = HINST_THISDLL;
        SendMessage(hwndToolTipo, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        hr = S_OK;
    }

    return hr;
}


HRESULT CInternetOpenAs::_OnInitDlg(HWND hDlg)
{
    _hwnd = hDlg;

    SetWindowText(GetDlgItem(_hwnd, IDD_FILE_TEXT), _pszFilename);
    CheckDlgButton(hDlg, IDD_WEBAUTOLOOKUP, BST_CHECKED);

    return S_OK;
}


HRESULT CInternetOpenAs::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UINT idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    UINT wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDCANCEL:
        EndDialog(hDlg, E_FAIL);
        break;

    case IDOK:
        if (BST_UNCHECKED != IsDlgButtonChecked(hDlg, IDD_WEBAUTOLOOKUP))
        {
            _OpenDownloadURL(_hwnd, _pszExt);
            EndDialog(hDlg, E_FAIL);
        }
        else
        {
            EndDialog(hDlg, S_OK);      // return S_OK so it will open the next dialog.
        }
        break;
    }

    return S_OK;
}


HRESULT CInternetOpenAs::_OnNotify(HWND hDlg, LPARAM lParam)
{
    switch (((NMHDR *)lParam)->code)
    {
    case NM_CLICK:
        if (lParam)
        {
            PNMLINK pNMLink = (PNMLINK) lParam;

            if (!StrCmpW(pNMLink->item.szID, L"GoOnline"))
            {
                _OpenDownloadURL(_hwnd, _pszExt);
                EndDialog(hDlg, E_FAIL);
            }
            else if (!StrCmpW(pNMLink->item.szID, L"Choose"))
            {
                EndDialog(hDlg, S_OK);      // return S_OK so it will open the next dialog.
            }
        }
        break;
    }

    return S_OK;
}


INT_PTR CALLBACK CInternetOpenAs::InternetOpenDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetOpenAs * pThis = (CInternetOpenAs *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CInternetOpenAs *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_InternetOpenDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


// This Property Sheet appear in the top level of the "Display Control Panel".
INT_PTR CInternetOpenAs::_InternetOpenDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        _OnInitDlg(hDlg);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_NOTIFY:
        _OnNotify(hDlg, lParam);
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR)  aOpenAsDownloadHelpIDs);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) aOpenAsDownloadHelpIDs);
        break;

    case WMUSER_CREATETOOLTIP:
        CreateWindowTooltip(_hwnd, (HWND)lParam, (LPCWSTR)wParam);
        break;
    }

    return FALSE;
}

//===========================
// *** Public Methods ***
//===========================
HRESULT CInternetOpenAs::DisplayDialog(HWND hwnd, LPCTSTR pszFile)
{
    HRESULT hr = E_OUTOFMEMORY;
    INITCOMMONCONTROLSEX initComctl32;

    initComctl32.dwSize = sizeof(initComctl32); 
    initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
    InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow

    Str_SetPtrW(&_pszFilename, PathFindFileName(pszFile));
    _pszExt = PathFindExtension(_pszFilename);
    if (_pszExt)
    {
        _hwndParent = hwnd;

        hr = (HRESULT) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_OPENAS_DOWNALOAD), _hwnd, CInternetOpenAs::InternetOpenDlgProc, (LPARAM)this);
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CInternetOpenAs::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CInternetOpenAs::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CInternetOpenAs::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CInternetOpenAs, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CInternetOpenAs::CInternetOpenAs(void) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pszExt);
}


CInternetOpenAs::~CInternetOpenAs()
{
    Str_SetPtrW(&_pszFilename, NULL);

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsdata.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"
#include "brfcase.h"
#include "views.h"
#include "fsdata.h"

//
// This function is called from CFSIDLData_GetData().
//
// Paramters:
//  this    -- Specifies the IDLData object (selected objects)
//  pmedium -- Pointer to STDMEDIUM to be filled; NULL if just querying.
//
HRESULT CFSIDLData::_GetNetResource(STGMEDIUM *pmedium)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        BOOL bIsMyNet = IsIDListInNameSpace(HIDA_GetPIDLFolder(pida), &CLSID_NetworkPlaces);

        HIDA_ReleaseStgMedium(pida, &medium);

        if (!bIsMyNet)
            return DV_E_FORMATETC;

        if (!pmedium)
            return S_OK; // query, yes we have it

        return CNetData_GetNetResourceForFS(this, pmedium);
    }
    return E_FAIL;
}

HRESULT CFSIDLData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if ((pformatetc->cfFormat == CF_HDROP) ||
            (pformatetc->cfFormat == g_cfFileNameA) ||
            (pformatetc->cfFormat == g_cfFileNameW))
        {
            return S_OK;
        }
        else if (pformatetc->cfFormat == g_cfNetResource)
        {
            return _GetNetResource(NULL);
        }
    }

    return CIDLDataObj::QueryGetData(pformatetc);
}

HRESULT CFSIDLData::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr = CIDLDataObj::SetData(pformatetc, pmedium, fRelease);

    // this enables:
    //      1) in the shell "cut" some files
    //      2) in an app "paste" to copy the data
    //      3) here we complete the "cut" by deleting the files

    if ((pformatetc->cfFormat == g_cfPasteSucceeded) &&
        (pformatetc->tymed == TYMED_HGLOBAL))
    {
        DWORD *pdw = (DWORD *)GlobalLock(pmedium->hGlobal);
        if (pdw)
        {
            // NOTE: the old code use g_cfPerformedDropEffect == DROPEFFECT_MOVE here
            // so to work on downlevel shells be sure to set the "Performed Effect" before
            // using "Paste Succeeded".

            // complete the "unoptimized move"
            if (DROPEFFECT_MOVE == *pdw)
            {
                DeleteFilesInDataObject(NULL, CMIC_MASK_FLAG_NO_UI, this, 0);
            }
            GlobalUnlock(pmedium->hGlobal);
        }
    }
    return hr;
}

// Creates CF_HDROP clipboard format block of memory (HDROP) from HIDA in data object

HRESULT CFSIDLData::CreateHDrop(STGMEDIUM *pmedium, BOOL fAltName)
{
    ZeroMemory(pmedium, sizeof(*pmedium));

    HRESULT hr;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        ASSERT(pidlFolder);

        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
        if (SUCCEEDED(hr))
        {
            // Allocate too much to start out with, then re-alloc when we are done
            UINT cbAlloc = sizeof(DROPFILES) + sizeof(TCHAR);        // header + null terminator
            UINT cbOriginalAlloc = cbAlloc + pida->cidl * MAX_PATH * sizeof(TCHAR);
            pmedium->hGlobal = GlobalAlloc(GPTR, cbOriginalAlloc);
            if (pmedium->hGlobal)
            {
                DROPFILES *pdf = (DROPFILES *)pmedium->hGlobal;
                LPTSTR pszFiles = (LPTSTR)(pdf + 1);
                pdf->pFiles = sizeof(DROPFILES);
                pdf->fWide = (sizeof(TCHAR) == sizeof(WCHAR));

                for (UINT i = 0; i < pida->cidl; i++)
                {
                    LPCITEMIDLIST pidlItem = HIDA_GetPIDLItem(pida, i);

                    // If we run across the Desktop pidl, then punt because it's
                    // not a file
                    if (ILIsEmpty(pidlItem) && ILIsEmpty(pidlFolder))
                    {
                        hr = DV_E_CLIPFORMAT; // No hdrop for you!
                        break;
                    }

                    ASSERT(ILIsEmpty(_ILNext(pidlItem)) || ILIsEmpty(pidlFolder)); // otherwise GDNO will fail

                    TCHAR szPath[MAX_PATH];
                    hr = DisplayNameOf(psf, pidlItem, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));
                    if (FAILED(hr))
                        break;  // something bad happened

                    if (fAltName)
                        GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));

                    int cch = lstrlen(szPath) + 1;

                    // prevent buffer overrun
                    if ((LPBYTE)(pszFiles + cch) > ((LPBYTE)pmedium->hGlobal) + cbOriginalAlloc)
                    {
                        TraceMsg(TF_WARNING, "hdrop:%d'th file caused us to exceed allocated memory, breaking", i);
                        break;
                    }
                    // we allocated MAX_PATH for each of the entries in this big double-null terminated buffer.
                    StrCpyN(pszFiles, szPath, cch); // will write NULL terminator for us
                    pszFiles += cch;
                    cbAlloc += cch * sizeof(TCHAR);
                }

                if (SUCCEEDED(hr))
                {
                    *pszFiles = 0; // double NULL terminate
                    ASSERT((LPTSTR)((BYTE *)pdf + cbAlloc - sizeof(TCHAR)) == pszFiles);

                    // re-alloc down to the amount we actually need
                    // note that pdf and pszFiles are now both invalid (and not used anymore)
                    pmedium->hGlobal = GlobalReAlloc(pdf, cbAlloc, GMEM_MOVEABLE);

                    // If realloc failed, then just use the original buffer.  It's
                    // a bit wasteful of memory but it's all we've got.
                    if (!pmedium->hGlobal)
                        pmedium->hGlobal = (HGLOBAL)pdf;

                    pmedium->tymed = TYMED_HGLOBAL;
                }
                else
                {
                    GlobalFree(pmedium->hGlobal);
                    pmedium->hGlobal = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;

            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_FAIL;

    return hr;
}

// Attempt to get the HDrop format: Create one from the HIDA if necessary
HRESULT CFSIDLData::GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    STGMEDIUM tempmedium;
    HRESULT hr = CIDLDataObj::GetData(pformatetcIn, &tempmedium);
    if (FAILED(hr))
    {
        // Couldn't get HDROP format, create it
        // Set up a dummy formatetc to save in case multiple tymed's were specified
        FORMATETC fmtTemp = *pformatetcIn;
        fmtTemp.tymed = TYMED_HGLOBAL;

        hr = CreateHDrop(&tempmedium, pformatetcIn->dwAspect == DVASPECT_SHORTNAME);
        if (SUCCEEDED(hr))
        {
            // And we also want to cache this new format
            // .. Ensure that we actually free the memory associated with the HDROP
            //    when the data object destructs (pUnkForRelease = NULL)
            ASSERT(tempmedium.pUnkForRelease == NULL);

            if (SUCCEEDED(SetData(&fmtTemp, &tempmedium, TRUE)))
            {
                // Now the old medium that we just set is owned by the data object - call
                // GetData to get a medium that is safe to release when we're done.
                hr = CIDLDataObj::GetData(pformatetcIn, &tempmedium);
            }
            else
            {
                TraceMsg(TF_WARNING, "Couldn't save the HDrop format to the data object - returning private version");
            }
        }
    }

    // HACKHACK
    // Some context menu extensions just release the hGlobal instead of
    // calling ReleaseStgMedium. This causes a reference counted data
    // object to fail. Therefore, we always allocate a new HGLOBAL for
    // each request.  Unfortunately necessary because Quickview
    // Pro does this.
    //
    // Ideally we'd like to set the pUnkForRelease and not have to
    // dup the hGlobal each time, but alas Quickview has called our bluff
    // and GlobalFree()'s it.
    if (SUCCEEDED(hr))
    {
        if (pmedium)
        {
            *pmedium = tempmedium;
            pmedium->pUnkForRelease = NULL;

            // Make a copy of this hglobal to pass back
            SIZE_T cbhGlobal = GlobalSize(tempmedium.hGlobal);
            if (cbhGlobal)
            {
                pmedium->hGlobal = GlobalAlloc(0, (UINT)cbhGlobal);
                if (pmedium->hGlobal)
                {
                    CopyMemory(pmedium->hGlobal, tempmedium.hGlobal, cbhGlobal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        ReleaseStgMedium(&tempmedium);
    }

    return hr;
}

// subclass member function to support CF_HDROP and CF_NETRESOURCE

HRESULT CFSIDLData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    // If we don't zero out the pmedium then briefcase will fault on win9x.  Breifcase tries
    // to free this medium even if this function returns an error.  Not all paths below correctly
    // set the pmedium in all cases.
    ZeroMemory(pmedium, sizeof(*pmedium));

    if ((pformatetcIn->cfFormat == CF_HDROP) && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = GetHDrop(pformatetcIn, pmedium);
    }
    else if ((pformatetcIn->cfFormat == g_cfFileNameA || pformatetcIn->cfFormat == g_cfFileNameW) && 
             (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        FORMATETC format = *pformatetcIn;
        BOOL bUnicode = pformatetcIn->cfFormat == g_cfFileNameW;

        // assume g_cfFileNameA clients want short name
        if (pformatetcIn->cfFormat == g_cfFileNameA)
            format.dwAspect = DVASPECT_SHORTNAME;

        STGMEDIUM medium;
        hr = GetHDrop(&format, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)))
            {
                UINT cch = lstrlen(szPath) + 1;
                UINT uSize = cch * (bUnicode ? sizeof(WCHAR) : sizeof(CHAR));

                pmedium->hGlobal = GlobalAlloc(GPTR, uSize);
                if (pmedium->hGlobal)
                {
                    if (bUnicode)
                        SHTCharToUnicode(szPath, (LPWSTR)pmedium->hGlobal, cch);
                    else
                        SHTCharToAnsi(szPath, (LPSTR)pmedium->hGlobal, cch);

                    pmedium->tymed = TYMED_HGLOBAL;
                    pmedium->pUnkForRelease = NULL;
                    hr = S_OK;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = E_UNEXPECTED;
            }
            ReleaseStgMedium(&medium);
        }
    }
    else if (pformatetcIn->cfFormat == g_cfNetResource && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = _GetNetResource(pmedium);
    }
    else
    {
        hr = CIDLDataObj::GetData(pformatetcIn, pmedium);
    }
    return hr;
}

STDAPI SHCreateFileDataObject(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl,
                              IDataObject *pdtInner, IDataObject **ppdtobj)
{
    *ppdtobj = new CFSIDLData(pidlFolder, cidl, apidl, pdtInner);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}

/*
Purpose: Gets the root path of the briefcase storage and copies
it into the buffer.

  This function obtains the briefcase storage root by
  binding to an IShellFolder (briefcase) instance of the
  pidl.  This parent is be an CFSBrfFolder *, so we can
  call the IBriefcaseStg::GetExtraInfo member function.
  
    Returns: standard result
    Cond:    --
*/
HRESULT GetBriefcaseRoot(LPCITEMIDLIST pidl, LPTSTR pszBuf, int cchBuf)
{
    IBriefcaseStg *pbrfstg;
    HRESULT hr = CreateBrfStgFromIDList(pidl, NULL, &pbrfstg);
    if (SUCCEEDED(hr))
    {
        hr = pbrfstg->GetExtraInfo(NULL, GEI_ROOT, (WPARAM)cchBuf, (LPARAM)pszBuf);
        pbrfstg->Release();
    }
    return hr;
}

// Packages a BriefObj struct into pmedium from a HIDA.

HRESULT CBriefcaseData_GetBriefObj(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl = ILCreate();
    if (pidl)
    {
        STGMEDIUM medium;
        
        if (DataObj_GetHIDA(pdtobj, &medium))
        {
            UINT cFiles = HIDA_GetCount(medium.hGlobal);
            // "cFiles+1" includes the briefpath...
            UINT cbSize = sizeof(BriefObj) + MAX_PATH * sizeof(TCHAR) * (cFiles + 1) + 1;
            
            PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalAlloc(GPTR, cbSize);
            if (pbo)
            {
                LPITEMIDLIST pidlT;
                LPTSTR pszFiles = (LPTSTR)((LPBYTE)pbo + _IOffset(BriefObj, data));
                
                pbo->cbSize = cbSize;
                pbo->cItems = cFiles;
                pbo->cbListSize = MAX_PATH * sizeof(TCHAR) * cFiles + 1;
                pbo->ibFileList = _IOffset(BriefObj, data);
                
                for (UINT i = 0; i < cFiles; i++)
                {
                    pidlT = HIDA_FillIDList(medium.hGlobal, i, pidl);
                    if (NULL == pidlT)
                        break;      // out of memory
                    
                    pidl = pidlT;
                    SHGetPathFromIDList(pidl, pszFiles); // pszFiles has room for MAX_PATH on each file
                    pszFiles += lstrlen(pszFiles)+1;
                }
                *pszFiles = TEXT('\0');
                
                if (i < cFiles)
                {
                    // Out of memory, fail
                    ASSERT(NULL == pidlT);
                }
                else
                {
                    // Make pszFiles point to beginning of szBriefPath buffer
                    pszFiles++;
                    pbo->ibBriefPath = (UINT) ((LPBYTE)pszFiles - (LPBYTE)pbo);
                    pidlT = HIDA_FillIDList(medium.hGlobal, 0, pidl);
                    if (pidlT)
                    {
                        pidl = pidlT;
                        // we have room for the briefcase path from our +1 above
                        hr = GetBriefcaseRoot(pidl, pszFiles, MAX_PATH);
                        
                        pmedium->tymed = TYMED_HGLOBAL;
                        pmedium->hGlobal = pbo;
                        
                        // Indicate that the caller should release hmem.
                        pmedium->pUnkForRelease = NULL;
                    }
                }
            }
            
            HIDA_ReleaseStgMedium(NULL, &medium);
        }
        ILFree(pidl);
    }
    return hr;
}

class CBriefcaseData : public CFSIDLData
{
public:
    CBriefcaseData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pidlFolder, cidl, apidl, NULL) { };

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
};

STDMETHODIMP CBriefcaseData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr;
    
    if (pformatetcIn->cfFormat == g_cfBriefObj && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        hr = CBriefcaseData_GetBriefObj(this, pmedium);
    }
    else
    {
        hr = CFSIDLData::GetData(pformatetcIn, pmedium);
    }
    
    return hr;
}

// IDataObject::QueryGetData

STDMETHODIMP CBriefcaseData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->cfFormat == g_cfBriefObj && (pformatetc->tymed & TYMED_HGLOBAL))
        return S_OK;
    
    return CFSIDLData::QueryGetData(pformatetc);
}

STDAPI CBrfData_CreateDataObj(LPCITEMIDLIST pidl, UINT cidl, LPCITEMIDLIST *ppidl, IDataObject **ppdtobj)
{
    *ppdtobj = new CBriefcaseData(pidl, cidl, ppidl);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H

#include <objbase.h>

// Message values for callback
#define FMM_ADD         0
#define FMM_SETLASTPIDL 1

typedef HRESULT (CALLBACK *PFNFMCALLBACK)(UINT fmm, LPARAM lParam, IShellFolder *psf, LPCITEMIDLIST pidl);

// Structure for composing a filemenu
typedef struct
{
    DWORD           dwMask;         // FMC_ flags
    UINT            idCmd;
    DWORD           grfFlags;       // SHCONTF_ flags
    IShellFolder    *psf;
    PFNFMCALLBACK   pfnCallback;    // Callback
    LPARAM          lParam;         // Callback's LPARAM
    OUT int         cItems;         // Returned
} FMCOMPOSE;

// Mask values for FMCOMPOSE.dwMask
#define FMC_NOEXPAND    0x00000001

// Method ordinals for FileMenu_Compose
#define FMCM_INSERT     0
#define FMCM_APPEND     1
#define FMCM_REPLACE    2

STDAPI            FileMenu_Compose(HMENU hmenu, UINT nMethod, FMCOMPOSE *pfmc);
STDAPI_(BOOL)     FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent);
STDAPI_(BOOL)     FileMenu_IsUnexpanded(HMENU hmenu);
STDAPI_(void)     FileMenu_DelayedInvalidate(HMENU hmenu);
STDAPI_(BOOL)     FileMenu_IsDelayedInvalid(HMENU hmenu);
STDAPI            FileMenu_InitMenuPopup(HMENU hmenu);
STDAPI_(LRESULT)  FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *lpdi);
STDAPI_(LRESULT)  FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi);
STDAPI_(void)     FileMenu_DeleteAllItems(HMENU hmenu);
STDAPI_(LRESULT)  FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch);


#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fsmenu.cpp ===
#include "shellprv.h"
#include "fsmenu.h"
#include "ids.h"
#include <limits.h>
#include "filetbl.h"
#include <oleacc.h>     // MSAAMENUINFO stuff

#define CXIMAGEGAP      6

typedef enum
{
    FMII_DEFAULT =      0x0000,
    FMII_BREAK =        0x0001
} FMIIFLAGS;

#define FMI_MARKER          0x00000001
#define FMI_EXPAND          0x00000004
#define FMI_EMPTY           0x00000008
#define FMI_ON_MENU         0x00000040

// One of these per file menu.
typedef struct
{
    HMENU           hmenu;                      // Menu.
    HDPA            hdpa;                       // List of items (see below).
    const struct _FILEMENUITEM *pfmiLastSel;
    UINT            idCmd;                      // Command.
    UINT            grfFlags;                   // enum filter
    DWORD           dwMask;                     // FMC_ flags
    PFNFMCALLBACK   pfnCallback;                // Callback function.
    LPARAM          lParam;                     // Parameter passed for callback handler
    int             cyMenuSizeSinceLastBreak;   // Size of menu (cy)
} FILEMENUHEADER;

// One of these for each file menu item.
//
//  !!! Note: the testers have a test utility which grabs
//      the first 7 fields of this structure.  If you change
//      the order or meaning of these fields, make sure they
//      are notified so they can update their automated tests.
//
typedef struct _FILEMENUITEM
{
    MSAAMENUINFO    msaa;               // accessibility must be first.
    FILEMENUHEADER *pfmh;               // The header.
    IShellFolder   *psf;                // Shell Folder.
    LPITEMIDLIST    pidl;               // IDlist for item.
    int             iImage;             // Image index to use.
    DWORD           dwFlags;            // Misc flags above.
    DWORD           dwAttributes;       // GetAttributesOf(), SFGAO_ bits (only some)
    LPTSTR          psz;                // Text when not using pidls.
    LPARAM          lParam;             // Application data
} FILEMENUITEM;

#if defined(DEBUG)

BOOL IsValidPFILEMENUHEADER(FILEMENUHEADER *pfmh)
{
    return (IS_VALID_WRITE_PTR(pfmh, FILEMENUHEADER) &&
            IS_VALID_HANDLE(pfmh->hmenu, MENU) &&
            IS_VALID_HANDLE(pfmh->hdpa, DPA));
}    

BOOL IsValidPFILEMENUITEM(FILEMENUITEM *pfmi)
{
    return (IS_VALID_WRITE_PTR(pfmi, FILEMENUITEM) &&
            IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER) &&
            (NULL == pfmi->pidl || IS_VALID_PIDL(pfmi->pidl)) &&
            (NULL == pfmi->psz || IS_VALID_STRING_PTR(pfmi->psz, -1)));
}    
#endif


DWORD GetItemTextExtent(HDC hdc, LPCTSTR lpsz)
{
    SIZE sz;

    GetTextExtentPoint(hdc, lpsz, lstrlen(lpsz), &sz);
    // NB This is OK as long as an item's extend doesn't get very big.
    return MAKELONG((WORD)sz.cx, (WORD)sz.cy);
}

void FileMenuItem_GetDisplayName(FILEMENUITEM *pfmi, LPTSTR pszName, UINT cchName)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    // Is this a special empty item?
    if (pfmi->dwFlags & FMI_EMPTY)
    {
        // Yep, load the string from a resource.
        LoadString(HINST_THISDLL, IDS_NONE, pszName, cchName);
    }
    else
    {
        *pszName = 0;
        // If it's got a pidl use that, else just use the normal menu string.
        if (pfmi->psz)
        {
            lstrcpyn(pszName, pfmi->psz, cchName);
        }
        else if (pfmi->pidl && pfmi->psf && SUCCEEDED(DisplayNameOf(pfmi->psf, pfmi->pidl, SHGDN_NORMAL, pszName, cchName)))
        {
            pfmi->psz = StrDup(pszName);
        }
    }
}

// Create a menu item structure to be stored in the hdpa

BOOL FileMenuItem_Create(FILEMENUHEADER *pfmh, IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwFlags, FILEMENUITEM **ppfmi)
{
    FILEMENUITEM *pfmi = (FILEMENUITEM *)LocalAlloc(LPTR, sizeof(*pfmi));
    if (pfmi)
    {
        pfmi->pfmh = pfmh;
        pfmi->iImage = -1;
        pfmi->dwFlags = dwFlags;
        pfmi->pidl = pidl ? ILClone(pidl) : NULL;
        pfmi->psf = psf;
        if (pfmi->psf)
            pfmi->psf->AddRef();

        if (pfmi->psf && pfmi->pidl)
        {
            pfmi->dwAttributes = SFGAO_FOLDER;
            pfmi->psf->GetAttributesOf(1, &pidl, &pfmi->dwAttributes);
        }

        // fill in msaa stuff
        pfmi->msaa.dwMSAASignature = MSAA_MENU_SIG;

        // prep the pfmi->psz cached displayname
        WCHAR sz[MAX_PATH];
        FileMenuItem_GetDisplayName(pfmi, sz, ARRAYSIZE(sz));

        // just use the same string ref, so we dont dupe the allocation.
        pfmi->msaa.pszWText = pfmi->psz;
        pfmi->msaa.cchWText = pfmi->msaa.pszWText ? lstrlenW(pfmi->msaa.pszWText) : 0;
    }

    *ppfmi = pfmi;

    return (NULL != pfmi);
}

BOOL FileMenuItem_Destroy(FILEMENUITEM *pfmi)
{
    BOOL fRet = FALSE;
    if (pfmi)
    {
        ILFree(pfmi->pidl);
        LocalFree(pfmi->psz);
        ATOMICRELEASE(pfmi->psf);
        LocalFree(pfmi);
        fRet = TRUE;
    }
    return fRet;
}

// Enumerates the folder and adds the files to the DPA.
// Returns: count of items in the list
int FileList_Build(FILEMENUHEADER *pfmh, IShellFolder *psf, int cItems)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    
    if (pfmh->hdpa)
    {
        // special case the single empty item, and remove it.
        // this is because we expect to get called multiple times in FileList_Build on a single menu.
        if ((1 == cItems) && (1 == DPA_GetPtrCount(pfmh->hdpa)))
        {
            FILEMENUITEM *pfmiEmpty = (FILEMENUITEM*)DPA_GetPtr(pfmh->hdpa, 0);
            if (pfmiEmpty->dwFlags & FMI_EMPTY)
            {
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmiEmpty);
                DPA_DeletePtr(pfmh->hdpa, 0);

                cItems = 0;
            }
        }

        // We now need to iterate over the children under this guy...
        IEnumIDList *penum;
        if (S_OK == psf->EnumObjects(NULL, pfmh->grfFlags, &penum))
        {
            LPITEMIDLIST pidl;
            while (S_OK == penum->Next(1, &pidl, NULL))
            {
                FILEMENUITEM *pfmi;
                
                if (FileMenuItem_Create(pfmh, psf, pidl, 0, &pfmi))
                {
                    int idpa = DPA_AppendPtr(pfmh->hdpa, pfmi);
                    ASSERTMSG(idpa != -1, "DPA_AppendPtr failed when adding file menu item");
                    
                    if (idpa != -1)
                    {
                        // if the caller returns S_FALSE then we will remove the item from the
                        // menu, otherwise we behave as before.
                        if (pfmh->pfnCallback(FMM_ADD, pfmh->lParam, psf, pidl) == S_FALSE)
                        {
                            FileMenuItem_Destroy(pfmi);
                            DPA_DeletePtr(pfmh->hdpa, idpa);
                        }
                        else
                        {
                            cItems++;
                        }
                    }
                }
                ILFree(pidl);
            }
            penum->Release();
        }
    }
    
    // Insert a special Empty item
    if (!cItems && pfmh->hdpa)
    {
        FILEMENUITEM *pfmi;
        
        if (FileMenuItem_Create(pfmh, NULL, NULL, FMI_EMPTY, &pfmi))
        {
            DPA_SetPtr(pfmh->hdpa, cItems, pfmi);
            cItems++;
        }
    }
    return cItems;
}

// Use the text extent of the given item and the size of the image to work
// what the full extent of the item will be.
DWORD GetItemExtent(HDC hdc, FILEMENUITEM *pfmi)
{
    TCHAR szName[MAX_PATH];

    szName[0] = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

    FILEMENUHEADER *pfmh = pfmi->pfmh;
    ASSERT(pfmh);

    DWORD dwExtent = GetItemTextExtent(hdc, szName);

    UINT uHeight = HIWORD(dwExtent);

    // If no custom height - calc it.
    uHeight = max(uHeight, ((WORD)g_cySmIcon)) + 6;

    ASSERT(pfmi->pfmh);

    //    string, image, gap on either side of image, popup triangle
    //    and background bitmap if there is one.
    // FEATURE: popup triangle size needs to be real
    UINT uWidth = LOWORD(dwExtent) + GetSystemMetrics(SM_CXMENUCHECK);

    // Space for image if there is one.
    // NB We currently always allow room for the image even if there
    // isn't one so that imageless items line up properly.
    uWidth += g_cxSmIcon + (2 * CXIMAGEGAP);

    return MAKELONG(uWidth, uHeight);
}


// Get the FILEMENUITEM *of this menu item
FILEMENUITEM *FileMenu_GetItemData(HMENU hmenu, UINT iItem, BOOL bByPos)
{
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;

    return GetMenuItemInfo(hmenu, iItem, bByPos, &mii) ? (FILEMENUITEM *)mii.dwItemData : NULL;
}

FILEMENUHEADER *FileMenu_GetHeader(HMENU hmenu)
{
    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (pfmi && 
        EVAL(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM)) &&
        EVAL(IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER)))
    {
        return pfmi->pfmh;
    }

    return NULL;
}

// Create a file menu header.  This header is to be associated 
// with the given menu handle.
// If the menu handle already has header, simply return the
// existing header.

FILEMENUHEADER *FileMenuHeader_Create(HMENU hmenu, const FMCOMPOSE *pfmc)
{
    FILEMENUHEADER *pfmh;
    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    // Does this guy already have a header?
    if (pfmi)
    {
        // Yes; use it
        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    }
    else
    {
        // Nope, create one now.
        pfmh = (FILEMENUHEADER *)LocalAlloc(LPTR, sizeof(*pfmh));
        if (pfmh)
        {
            pfmh->hdpa = DPA_Create(0);
            if (pfmh->hdpa == NULL)
            {
                LocalFree((HLOCAL)pfmh);
                pfmh = NULL;
            }
            else
            {
                pfmh->hmenu = hmenu;
            }
        }
    }

    if (pfmc && pfmh)
    {
        pfmh->idCmd = pfmc->idCmd;
        pfmh->grfFlags = pfmc->grfFlags;
        pfmh->dwMask = pfmc->dwMask;
        pfmh->pfnCallback = pfmc->pfnCallback;
        pfmh->lParam = pfmc->lParam;
    }
    return pfmh;
}

BOOL FileMenuHeader_InsertMarkerItem(FILEMENUHEADER *pfmh, IShellFolder *psf);

// This functions adds the given item (index into DPA) into the actual menu.
BOOL FileMenuHeader_InsertItem(FILEMENUHEADER *pfmh, UINT iItem, FMIIFLAGS fFlags)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Normal item.
    FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, iItem);
    if (!pfmi || (pfmi->dwFlags & FMI_ON_MENU))
        return FALSE;

    pfmi->dwFlags |= FMI_ON_MENU;

    // The normal stuff.
    UINT fMenu = MF_BYPOSITION | MF_OWNERDRAW;
    // Keep track of where it's going in the menu.

    // The special stuff...
    if (fFlags & FMII_BREAK)
    {
        fMenu |= MF_MENUBARBREAK;
    }

    // Is it a folder (that's not open yet)?
    if ((pfmi->dwAttributes & SFGAO_FOLDER) && !(pfmh->dwMask & FMC_NOEXPAND))
    {
        // Yep. Create a submenu item.
        HMENU hmenuSub = CreatePopupMenu();
        if (hmenuSub)
        {
            FMCOMPOSE fmc = {0};

            // Set the callback now so it can be called when adding items
            fmc.lParam      = pfmh->lParam;  
            fmc.pfnCallback = pfmh->pfnCallback;
            fmc.dwMask      = pfmh->dwMask;
            fmc.idCmd       = pfmh->idCmd;
            fmc.grfFlags    = pfmh->grfFlags;

            // Insert it into the parent menu.
            InsertMenu(pfmh->hmenu, iItem, fMenu | MF_POPUP, (UINT_PTR)hmenuSub, (LPTSTR)pfmi);

            // Set it's ID.
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;
            mii.wID = pfmh->idCmd;
            SetMenuItemInfo(pfmh->hmenu, iItem, TRUE, &mii);

            IShellFolder *psf;
            if (SUCCEEDED(pfmi->psf->BindToObject(pfmi->pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                FILEMENUHEADER *pfmhSub = FileMenuHeader_Create(hmenuSub, &fmc);
                if (pfmhSub)
                {
                    // Build it a bit at a time.
                    FileMenuHeader_InsertMarkerItem(pfmhSub, psf);
                }
                psf->Release();
            }
        }
    }
    else
    {
        // Nope.
        if (pfmi->dwFlags & FMI_EMPTY)
            fMenu |= MF_DISABLED | MF_GRAYED;

        InsertMenu(pfmh->hmenu, iItem, fMenu, pfmh->idCmd, (LPTSTR)pfmi);
    }

    return TRUE;
}

// Give the submenu a marker item so we can check it's a filemenu item
// at initpopupmenu time.
BOOL FileMenuHeader_InsertMarkerItem(FILEMENUHEADER *pfmh, IShellFolder *psf)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    FILEMENUITEM *pfmi;
    if (FileMenuItem_Create(pfmh, psf, NULL, FMI_MARKER | FMI_EXPAND, &pfmi))
    {
        DPA_SetPtr(pfmh->hdpa, 0, pfmi);
        FileMenuHeader_InsertItem(pfmh, 0, FMII_DEFAULT);
        return TRUE;
    }
    return FALSE;
}

// Enumerates the DPA and adds each item into the
// menu.  Inserts vertical breaks if the menu becomes too long.
// Returns: count of items added to menu
int FileList_AddToMenu(FILEMENUHEADER *pfmh)
{
    int cItemMac = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (pfmh->hdpa)
    {
        int cyItem = 0;
        int cyMenu = pfmh->cyMenuSizeSinceLastBreak;

        int cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

        // Get the rough height of an item so we can work out when to break the
        // menu. User should really do this for us but that would be useful.
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    HFONT hfontOld = SelectFont(hdc, hfont);
                    cyItem = HIWORD(GetItemExtent(hdc, (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, 0)));
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                }
            }
            ReleaseDC(NULL, hdc);
        }

        UINT cItems = DPA_GetPtrCount(pfmh->hdpa);

        for (UINT i = 0; i < cItems; i++)
        {
            // Keep a rough count of the height of the menu.
            cyMenu += cyItem;
            if (cyMenu > cyMenuMax)
            {
                // Add a vertical break?
                FileMenuHeader_InsertItem(pfmh, i, FMII_BREAK);
                cyMenu = cyItem;
            }
            else
            {
                FileMenuHeader_InsertItem(pfmh, i, FMII_DEFAULT);
                cItemMac++;
            }
        }

        // Save the current cy size so we can use this again
        // if more items are appended to this menu.

        pfmh->cyMenuSizeSinceLastBreak = cyMenu;
    }

    return cItemMac;
}


BOOL FileList_AddImages(FILEMENUHEADER *pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = DPA_GetPtrCount(pfmh->hdpa);
    for (int i = 0; i < cItems; i++)
    {
        FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, i);
        if (pfmi && pfmi->pidl && (pfmi->iImage == -1))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(pfmi->psf, pfmi->pidl, NULL);
        }
    }
    return TRUE;
}

// We create subemnu's with one marker item so we can check it's a file menu
// at init popup time but we need to delete it before adding new items.
BOOL FileMenuHeader_DeleteMarkerItem(FILEMENUHEADER *pfmh, IShellFolder **ppsf)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (GetMenuItemCount(pfmh->hmenu) == 1)
    {
        if (GetMenuItemID(pfmh->hmenu, 0) == pfmh->idCmd)
        {
            FILEMENUITEM *pfmi = FileMenu_GetItemData(pfmh->hmenu, 0, TRUE);
            if (pfmi && (pfmi->dwFlags & FMI_MARKER))
            {
                // Delete it.
                ASSERT(pfmh->hdpa);
                ASSERT(DPA_GetPtrCount(pfmh->hdpa) == 1);

                if (ppsf)
                {
                    *ppsf = pfmi->psf;  // transfer the ref
                    pfmi->psf = NULL;
                }
                ASSERT(NULL == pfmi->psf);
                // NB The marker shouldn't have a pidl.
                ASSERT(NULL == pfmi->pidl);

                LocalFree((HLOCAL)pfmi);

                DPA_DeletePtr(pfmh->hdpa, 0);
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                // Cleanup OK.
                return TRUE;
            }
        }
    }
    return FALSE;
}

// Add files to a file menu header. This function goes thru
// the following steps:
// - enumerates the folder and fills the hdpa list with items
// (files and subfolders)
// - sorts the list
// - gets the images for the items in the list
// - adds the items from list into actual menu
// The last step also (optionally) caps the length of the
// menu to the specified height.  Ideally, this should
// happen at the enumeration time, except the required sort
// prevents this from happening.  So we end up adding a
// bunch of items to the list and then removing them if
// there are too many.
// returns: count of items added

HRESULT FileMenuHeader_AddFiles(FILEMENUHEADER *pfmh, IShellFolder *psf, int iPos, int *pcItems)
{
    HRESULT hr;
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = FileList_Build(pfmh, psf, iPos);

    // If the build was aborted cleanup and early out.
    *pcItems = cItems;

    if (cItems != 0)
    {
        // Add the images *after* adding to the menu, since the menu
        // may be capped to a maximum height, and we can then prevent
        // adding images we won't need.
        *pcItems = FileList_AddToMenu(pfmh);
        FileList_AddImages(pfmh);
    }

    hr = (*pcItems < cItems) ? S_FALSE : S_OK;

    TraceMsg(TF_MENU, "FileMenuHeader_AddFiles: Added %d filemenu items.", cItems);
    return hr;
}

// Add files to this menu.
// Returns: number of items added
HRESULT FileMenu_AddFiles(HMENU hmenu, UINT iPos, FMCOMPOSE *pfmc)
{
    HRESULT hr = E_OUTOFMEMORY;
    BOOL fMarker = FALSE;

    // (FileMenuHeader_Create might return an existing header)
    FILEMENUHEADER *pfmh = FileMenuHeader_Create(hmenu, pfmc);
    if (pfmh)
    {
        FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            // Clean up marker item if there is one.
            if ((FMI_MARKER | FMI_EXPAND) == (pfmi->dwFlags & (FMI_MARKER | FMI_EXPAND)))
            {
                // Nope, do it now.
                FileMenuHeader_DeleteMarkerItem(pfmh, NULL);
                fMarker = TRUE;
                if (iPos)
                    iPos--;
            }
        }

        hr = FileMenuHeader_AddFiles(pfmh, pfmc->psf, iPos, &pfmc->cItems);

        if ((0 == pfmc->cItems) && fMarker)
        {
            // Aborted or no items. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh, NULL);
        }
    }

    return hr;
}

// creator of the filemenu has to explicitly call to free
// up FileMenu items because USER doesn't send WM_DELETEITEM for ownerdraw
// menu. Great eh?
// Returns the number of items deleted.

void FileMenu_DeleteAllItems(HMENU hmenu)
{
    FILEMENUHEADER *pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        // Clean up the items.
        UINT cItems = DPA_GetPtrCount(pfmh->hdpa);
        // backwards stop things dont move as we delete
        for (int i = cItems - 1; i >= 0; i--)
        {
            FILEMENUITEM *pfmi = (FILEMENUITEM *)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);    // cascade item?
                if (hmenuSub)
                {
                    // Yep. Get the submenu for this item, Delete all items.
                    FileMenu_DeleteAllItems(hmenuSub);
                }
                // Delete the item itself.
                DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmi);
                DPA_DeletePtr(pfmh->hdpa, i);
            }
        }

        // Clean up the header.
        DPA_Destroy(pfmh->hdpa);
        LocalFree((HLOCAL)pfmh);
    }
}

STDAPI FileMenu_Compose(HMENU hmenu, UINT nMethod, FMCOMPOSE *pfmc)
{
    HRESULT hr = E_INVALIDARG;

    switch (nMethod)
    {
    case FMCM_INSERT:
        hr = FileMenu_AddFiles(hmenu, 0, pfmc);
        break;

    case FMCM_APPEND:
        hr = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu), pfmc);
        break;

    case FMCM_REPLACE:
        FileMenu_DeleteAllItems(hmenu);
        hr = FileMenu_AddFiles(hmenu, 0, pfmc);
        break;
    }
    return hr;
}

LPITEMIDLIST FileMenuItem_FullIDList(const FILEMENUITEM *pfmi)
{
    LPITEMIDLIST pidlFolder, pidl = NULL;
    if (SUCCEEDED(SHGetIDListFromUnk(pfmi->psf, &pidlFolder)))
    {
        pidl = ILCombine(pidlFolder, pfmi->pidl);
        ILFree(pidlFolder);
    }
    return pidl;
}

void FileMenuItem_SetItem(const FILEMENUITEM *pfmi, BOOL bClear)
{
    if (bClear)
    {
        pfmi->pfmh->pfmiLastSel = NULL;
        pfmi->pfmh->pfnCallback(FMM_SETLASTPIDL, pfmi->pfmh->lParam, NULL, NULL);
    }
    else
    {
        pfmi->pfmh->pfmiLastSel = pfmi;

        LPITEMIDLIST pidl = FileMenuItem_FullIDList(pfmi);
        if (pidl)
        {
            pfmi->pfmh->pfnCallback(FMM_SETLASTPIDL, pfmi->pfmh->lParam, NULL, pidl);
            ILFree(pidl);
        }
    }
}

LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    BOOL fFlatMenu = FALSE;
    BOOL fFrameRect = FALSE;

    SystemParametersInfo(SPI_GETFLATMENU, 0, (void *)&fFlatMenu, 0);

    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        HBRUSH hbrOld = NULL;
        FILEMENUITEM *pfmi = (FILEMENUITEM *)pdi->itemData;

        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
       
        if (!pfmi)
        {
            TraceMsg(TF_ERROR, "FileMenu_DrawItem: Filemenu is invalid (no item data).");
            return FALSE;
        }

        FILEMENUHEADER *pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        // Adjust for large/small icons.
        int cxIcon = g_cxSmIcon;
        int cyIcon = g_cxSmIcon;

        // Is the menu just starting to get drawn?
        if (pdi->itemAction & ODA_DRAWENTIRE)
        {
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0))
            {
                // Yes; reset the last selection item
                FileMenuItem_SetItem(pfmi, TRUE);
            }
        }

        if (pdi->itemState & ODS_SELECTED)
        {
            // Determine the selection colors
            //
            // Normal menu colors apply until we are in edit mode, in which
            // case the menu item is drawn unselected and an insertion caret 
            // is drawn above or below the current item.  The exception is 
            // if the item is a cascaded menu item, then we draw it 
            // normally, but also show the insertion caret.  (We do this
            // because Office does this, and also, USER draws the arrow
            // in the selected color always, so it looks kind of funny 
            // if we don't select the menu item.)
            //
            if (fFlatMenu)
            {
                SetBkColor(pdi->hDC, GetSysColor(COLOR_MENUHILIGHT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUHILIGHT));
                fFrameRect = TRUE;
            }
            else
            {
                // No
                SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_HIGHLIGHTTEXT));
            }

            // inform callback of last item
            FileMenuItem_SetItem(pfmi, FALSE);
        }
        else
        {
            // dwRop = SRCAND;
            hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
        }

        // Initial start pos.
        int x = pdi->rcItem.left + CXIMAGEGAP;

        // Get the name.
        TCHAR szName[MAX_PATH];
        FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

        // NB Keep a plain copy of the name for testing and accessibility.
        if (!pfmi->psz)
            pfmi->psz = StrDup(szName);

        DWORD dwExtent = GetItemTextExtent(pdi->hDC, szName);
        int y = (pdi->rcItem.bottom+pdi->rcItem.top - HIWORD(dwExtent)) / 2;

        // Shrink the selection rect for small icons a bit.
        pdi->rcItem.top += 1;
        pdi->rcItem.bottom -= 1;

        // Draw the text.
        int fDSFlags;

        if ((pfmi->dwFlags & FMI_ON_MENU) == 0)
        {
            // Norton Desktop Navigator 95 replaces the Start->&Run
            // menu item with a &Run pidl.  Even though the text is
            // from a pidl, we still want to format the "&R" correctly.
            fDSFlags = DST_PREFIXTEXT;
        }
        else
        {
            // All other strings coming from pidls are displayed
            // as is to preserve any & in their display name.
            fDSFlags = DST_TEXT;
        }

        if (pfmi->dwFlags & FMI_EMPTY)
        {
            if (pdi->itemState & ODS_SELECTED)
            {
                if (GetSysColor(COLOR_GRAYTEXT) == GetSysColor(COLOR_HIGHLIGHTTEXT))
                {
                    fDSFlags |= DSS_UNION;
                }
                else
                {
                    SetTextColor(pdi->hDC, GetSysColor(COLOR_GRAYTEXT));
                }
            }
            else
            {
                fDSFlags |= DSS_DISABLED;
            }

            ExtTextOut(pdi->hDC, 0, 0, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x + cxIcon + CXIMAGEGAP, y, 0, 0, fDSFlags);
        }
        else
        {
            ExtTextOut(pdi->hDC, x + cxIcon + CXIMAGEGAP, y, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x + cxIcon + CXIMAGEGAP, y, 0, 0, fDSFlags);
        }

        if (fFrameRect)
        {
            HBRUSH hbrFill = (HBRUSH)GetSysColorBrush(COLOR_HIGHLIGHT);
            HBRUSH hbrSave = (HBRUSH)SelectObject(pdi->hDC, hbrFill);
            int x = pdi->rcItem.left;
            int y = pdi->rcItem.top;
            int cx = pdi->rcItem.right - x - 1;
            int cy = pdi->rcItem.bottom - y - 1;

            PatBlt(pdi->hDC, x, y, 1, cy, PATCOPY);
            PatBlt(pdi->hDC, x + 1, y, cx, 1, PATCOPY);
            PatBlt(pdi->hDC, x, y + cy, cx, 1, PATCOPY);
            PatBlt(pdi->hDC, x + cx, y + 1, 1, cy, PATCOPY);

            SelectObject(pdi->hDC, hbrSave);
        }

        // Get the image if it needs it,
        if ((pfmi->iImage == -1) && pfmi->pidl && pfmi->psf)
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(pfmi->psf, pfmi->pidl, NULL);
        }

        // Draw the image (if there is one).
        if (pfmi->iImage != -1)
        {
            // Try to center image.
            y = (pdi->rcItem.bottom + pdi->rcItem.top - cyIcon) / 2;

            HIMAGELIST himl;
            Shell_GetImageLists(NULL, &himl);

            ImageList_DrawEx(himl, pfmi->iImage, pdi->hDC, x, y, 0, 0,
                GetBkColor(pdi->hDC), CLR_NONE, ILD_NORMAL);
        }
        if (hbrOld)
            SelectObject(pdi->hDC, hbrOld);
    }
    return TRUE;
}


DWORD FileMenuItem_GetExtent(FILEMENUITEM *pfmi)
{
    DWORD dwExtent = 0;

    if (pfmi)
    {
        FILEMENUHEADER *pfmh = pfmi->pfmh;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        HDC hdcMem = CreateCompatibleDC(NULL);
        if (hdcMem)
        {
            // Get the rough height of an item so we can work out when to break the
            // menu. User should really do this for us but that would be useful.
            NONCLIENTMETRICS ncm = {0};
            ncm.cbSize = sizeof(ncm);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
            {
                HFONT hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    HFONT hfontOld = SelectFont(hdcMem, hfont);
                    dwExtent = GetItemExtent(hdcMem, pfmi);
                    SelectFont(hdcMem, hfontOld);
                    DeleteObject(hfont);
                }
            }
            DeleteDC(hdcMem);
        }
    }
    return dwExtent;
}

LRESULT FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *pmi)
{
    DWORD dwExtent = FileMenuItem_GetExtent((FILEMENUITEM *)pmi->itemData);
    pmi->itemHeight = HIWORD(dwExtent);
    pmi->itemWidth = LOWORD(dwExtent);
    return TRUE;
}

// Fills the given filemenu with contents of the appropriate folder
//
// Returns: S_OK if all the files were added
//         error on something bad

STDAPI FileMenu_InitMenuPopup(HMENU hmenu)
{
    HRESULT hr = E_FAIL;

    FILEMENUITEM *pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi)
    {
        FILEMENUHEADER *pfmh = pfmi->pfmh;
        if (pfmh)
        {
            hr = S_OK;

            // Have we already filled this thing out?
            if ((FMI_MARKER | FMI_EXPAND) == (pfmi->dwFlags & (FMI_MARKER | FMI_EXPAND)))
            {
                // No, do it now.  Get the previously init'ed header.
                IShellFolder *psf;
                if (FileMenuHeader_DeleteMarkerItem(pfmh, &psf))
                {
                    // Fill it full of stuff.
                    int cItems;
                    hr = FileMenuHeader_AddFiles(pfmh, psf, 0, &cItems);
                    psf->Release();
                }
            }
        }
    }

    return hr;
}

int FileMenuHeader_LastSelIndex(FILEMENUHEADER *pfmh)
{
    for (int i = GetMenuItemCount(pfmh->hmenu) - 1; i >= 0; i--)
    {
        FILEMENUITEM *pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi && (pfmi == pfmh->pfmiLastSel))
            return i;
    }
    return -1;
}

// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    // Find the first ampersand.
    LPTSTR pchAS = StrChr(lpsz, TEXT('&'));
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (CharUpperChar(*CharNext(pchAS)) == CharUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (CharUpperChar(*lpsz) == CharUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}

STDAPI_(LRESULT) FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    FILEMENUITEM *pfmi;
    TCHAR szName[MAX_PATH];

    int iFoundOne = -1;
    UINT iStep = 0;
    UINT iItem = 0;
    UINT cItems = GetMenuItemCount(hmenu);

    // Start from the last place we looked from.
    FILEMENUHEADER *pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        iItem = FileMenuHeader_LastSelIndex(pfmh) + 1;
        if (iItem >= cItems)
            iItem = 0;
    }

    while (iStep < cItems)
    {
        pfmi = FileMenu_GetItemData(hmenu, iItem, TRUE);
        if (pfmi)
        {
            FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));
            if (_MenuCharMatch(szName, ch, pfmi->pidl ? TRUE : FALSE))
            {
                // Found (another) match.
                if (iFoundOne != -1)
                {
                    // More than one, select the first.
                    return MAKELRESULT(iFoundOne, MNC_SELECT);
                }
                else
                {
                    // Found at least one.
                    iFoundOne = iItem;
                }
            }

        }
        iItem++;
        iStep++;
        // Wrap.
        if (iItem >= cItems)
            iItem = 0;
    }

    // Did we find one?
    if (iFoundOne != -1)
    {
        // Just in case the user types ahead without the selection being drawn.
        pfmi = FileMenu_GetItemData(hmenu, iFoundOne, TRUE);
        FileMenuItem_SetItem(pfmi, FALSE);

        return MAKELRESULT(iFoundOne, MNC_EXECUTE);
    }
    else
    {
        // Didn't find it.
        return MAKELRESULT(0, MNC_IGNORE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftaction.h ===
#ifndef FTACTION_H
#define FTACTION_H

#include "ftdlg.h"

class CFTActionDlg : public CFTDlg
{
public:
    CFTActionDlg(PROGIDACTION* pProgIDAction, LPTSTR pszProgIDDescr, BOOL fEdit);

protected:
    ~CFTActionDlg();

public:
    void SetShowAgain();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    //Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    //Control specific
    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);
    LRESULT OnUseDDE(WORD wNotif);
    LRESULT OnBrowse(WORD wNotif);

private:
// Member variables
    PROGIDACTION* _pProgIDAction;
    LPTSTR _pszProgIDDescr;

    BOOL _fEdit;
    // used when need to reshow dlg because user entered bad data
    BOOL _fShowAgain;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    // AssocStore
    BOOL _Validate();
    void _ResizeDlgForDDE(BOOL fShow);
};

#endif //FTACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftascstr.cpp ===
#include "shellprv.h"
#include "ftascstr.h"
#include "ftassoc.h" //for now, until use CoCreateInstance
#include "ftenum.h" //for now, until use CoCreateInstance

HRESULT CFTAssocStore::_hresAccess = -1;

HRESULT CFTAssocStore::EnumAssocInfo(ASENUM asenumFlags, LPTSTR pszStr, 
        AIINIT aiinitFlags, IEnumAssocInfo** ppEnum)
{
    //for now
    *ppEnum = new CFTEnumAssocInfo();

    if (*ppEnum)
    {
        (*ppEnum)->Init(asenumFlags, pszStr, aiinitFlags);
    }

    return (*ppEnum) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CFTAssocStore::GetAssocInfo(LPTSTR pszStr, AIINIT aiinitFlags, IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;

    *ppAI = new CFTAssocInfo();

    if (*ppAI)
        hres = (*ppAI)->Init(aiinitFlags, pszStr);
    else
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CFTAssocStore::GetComplexAssocInfo(LPTSTR pszStr1, AIINIT aiinitFlags1, 
    LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;

    *ppAI = new CFTAssocInfo();

    if (*ppAI)
        hres = (*ppAI)->InitComplex(aiinitFlags1, pszStr1, aiinitFlags2, pszStr2);
    else
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CFTAssocStore::CheckAccess()
{
    if (-1 == _hresAccess)
    {
        TCHAR szGUID[] = TEXT("{A4BFEC7C-F821-11d2-86BE-0000F8757D7E}");
        DWORD dwDisp = 0;
        int cTry = 0;
        HKEY hkey;

        _hresAccess = S_FALSE;

        // we want to try this only two times
        while ((S_FALSE == _hresAccess) && (cTry <= 1))
        {
            ++cTry;

            // we try to write a GUID to HKCR and delete it
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szGUID, 0, NULL, REG_OPTION_NON_VOLATILE,
                MAXIMUM_ALLOWED, NULL, &hkey, &dwDisp))
            {
                // Did we really created a new key?
                if (REG_CREATED_NEW_KEY == dwDisp)
                {
                    // yes
                    RegCloseKey(hkey);

                    if (ERROR_SUCCESS == RegDeleteKey(HKEY_CLASSES_ROOT, szGUID))
                    {
                        _hresAccess = S_OK;
                    }
                }
                else
                {
                    // No, there was already one, maybe we crashed right in the middle of this fct
                    // some other time in the past

                    // delete the key and try again
                    RegDeleteKey(HKEY_CLASSES_ROOT, szGUID);
                }
            }
        }
    }

    return _hresAccess;
}
///////////////////////////////////////////////////////////////////////////////
//
CFTAssocStore::CFTAssocStore()
{
    _hresCoInit = SHCoInitialize();

    //DLLAddRef();
}

CFTAssocStore::~CFTAssocStore()
{
    //DLLRelease();
    SHCoUninitialize(_hresCoInit);
}

//IUnknown methods
HRESULT CFTAssocStore::QueryInterface(REFIID riid, PVOID* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown*>(this);
    else
        *ppv = static_cast<IAssocStore*>(this);

    return S_OK;
}

ULONG CFTAssocStore::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTAssocStore::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftadv.h ===
#ifndef FTADVDLG
#define FTADVDLG

#include "ftdlg.h"
#include "ftcmmn.h"

class CFTAdvDlg : public CFTDlg
{
public:
    CFTAdvDlg(LPTSTR pszProgID, LPTSTR pszExt = NULL);

protected:
    ~CFTAdvDlg();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:

    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
// Message handlers
    // Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    LRESULT OnDrawItem(WPARAM wParam, LPARAM lParam);
    LRESULT OnMeasureItem(WPARAM wParam, LPARAM lParam);

    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

    // Control specific
    //
    //      Action buttons
    LRESULT OnNewButton(WORD wNotif);
    LRESULT OnEditButton(WORD wNotif);
    LRESULT OnChangeIcon(WORD wNotif);
    LRESULT OnSetDefault(WORD wNotif);
    LRESULT OnRemoveButton(WORD wNotif);
    //      ListView
    LRESULT OnNotifyListView(UINT uCode, LPNMHDR pNMHDR);
    LRESULT OnListViewSelItem(int iItem, LPARAM lParam);

private:
// Member variables
    TCHAR       _szProgID[MAX_PROGID];
    TCHAR       _szExt[MAX_EXT];
    

    HICON       _hIcon;

    HFONT       _hfontReg;
    HFONT       _hfontBold;
    int         _iDefaultAction;
    int         _iLVSel;

    HDPA        _hdpaActions;
    HDPA        _hdpaRemovedActions;

    TCHAR       _szIconLoc[MAX_ICONLOCATION];
    TCHAR       _szOldIconLoc[MAX_ICONLOCATION];
    int         _iOldIcon;

    HANDLE      _hHeapProgID;

///////////////////////////////////////////////////////////////////////////////
//  Helpers
    inline HWND _GetLVHWND();

    HRESULT _FillListView();
    HRESULT _FillProgIDDescrCombo();

    HRESULT _InitDefaultActionFont();
    HRESULT _InitListView();
    HRESULT _InitDefaultAction();
    HRESULT _InitChangeIconButton();
    HRESULT _InitDescription();

    HRESULT _SetDocIcon(int iIndex = -1);
    int _GetIconIndex();
    HRESULT _SelectListViewItem(int i);
    HRESULT _SetDefaultAction(int iIndex);
    void _SetDefaultActionHelper(int iIndex, BOOL fDefault);

    HRESULT _UpdateActionButtons();
    HRESULT _UpdateCheckBoxes();

    // PROGIDACTION helpers
    HRESULT _RemovePROGIDACTION(PROGIDACTION* pPIDA);
    HRESULT _CreatePROGIDACTION(PROGIDACTION** ppPIDA);
    HRESULT _CopyPROGIDACTION(PROGIDACTION* pPIDADest, PROGIDACTION* pPIDASrc);
    HRESULT _GetPROGIDACTION(LPTSTR pszAction, PROGIDACTION** ppPIDA);
    HRESULT _AppendPROGIDACTION(PROGIDACTION* pPIDA);
    HRESULT _FillPROGIDACTION(PROGIDACTION* pPIDA, LPTSTR pszActionReg,
                                     LPTSTR pszActionFN);
    void _DeletePROGIDACTION(PROGIDACTION* pPIDA);
    BOOL _IsNewPROGIDACTION(LPTSTR pszAction);
    BOOL _FindActionLVITEM(LPTSTR pszActionReg, LVITEM* plvItem);

    BOOL _GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem);
    int _InsertListViewItem(int iItem, LPTSTR pszActionReg, LPTSTR pszActionFN);
    BOOL _IsDefaultAction(LPTSTR pszActionReg);
    BOOL _GetDefaultAction(LPTSTR pszActionReg, DWORD cchActionReg);
    void _CleanupProgIDs();
    LPTSTR _AddProgID(LPTSTR pszProgID);
    void _CheckDefaultAction();

    BOOL _CheckForDuplicateEditAction(LPTSTR pszActionRegOriginal, LPTSTR pszActionReg,
        LPTSTR pszActionFNOriginal, LPTSTR pszActionFN);
    BOOL _CheckForDuplicateNewAction(LPTSTR pszActionReg, LPTSTR pszActionFN);
};

#endif //FTADVDLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftadv.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "apithk.h"
#include "ascstr.h"
#include "filetype.h"
#include "ftdlg.h"
#include "ftadv.h"
#include "ftaction.h"

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_NO_HELP_1,              NO_HELP,
    IDC_FT_EDIT_DOCICON,        IDH_FCAB_FT_EDIT_DOCICON,
    IDC_FT_EDIT_DESC,           IDH_FCAB_FT_EDIT_DESC,
    IDC_FT_EDIT_CHANGEICON,     IDH_FCAB_FT_EDIT_CHANGEICON,
    IDC_FT_EDIT_LV_CMDSTEXT,    IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_LV_CMDS,        IDH_FCAB_FT_EDIT_LV_CMDS,
    IDC_FT_EDIT_NEW,            IDH_FCAB_FT_EDIT_NEW,
    IDC_FT_EDIT_EDIT,           IDH_FCAB_FT_EDIT_EDIT,
    IDC_FT_EDIT_REMOVE,         IDH_FCAB_FT_EDIT_REMOVE,
    IDC_FT_EDIT_DEFAULT,        IDH_FCAB_FT_EDIT_DEFAULT,
    IDC_FT_EDIT_CONFIRM_OPEN,   IDH_CONFIRM_OPEN,
    IDC_FT_EDIT_SHOWEXT,        IDH_FCAB_FT_EDIT_SHOWEXT,
    IDC_FT_EDIT_BROWSEINPLACE,  IDH_SAME_WINDOW,
    0, 0
};

struct LV_ADDDATA
{
    BOOL    fDefaultAction;
    TCHAR   szActionReg[MAX_ACTION];
};

#define ADDDATA_ACTIONREG(plvItem) (((LV_ADDDATA*)((plvItem)->lParam))->szActionReg)
#define ADDDATA_DEFAULTACTION(plvItem) (((LV_ADDDATA*)((plvItem)->lParam))->fDefaultAction)

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CFTAdvDlg::CFTAdvDlg(LPTSTR pszProgID, LPTSTR pszExt) :
    CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray),
    _iDefaultAction(-1), _iLVSel(-1)
{
    _szProgID[0] = NULL;
    if (pszProgID)
        StringCchCopy(_szProgID,  ARRAYSIZE(_szProgID), pszProgID);

    _szExt[0] = NULL;
    if (pszExt && (*pszExt != NULL))
    {
        StringCchPrintf(_szExt, ARRAYSIZE(_szExt), TEXT(".%s"), pszExt);        
    }

    _hdpaActions = DPA_Create(4);
    _hdpaRemovedActions = DPA_Create(1);
}

static int _DeleteLocalAllocCB(void *pItem, void *pData)
{
    LocalFree((HLOCAL)pItem);
    return 1;
}

CFTAdvDlg::~CFTAdvDlg()
{
    if (_hIcon)
        DeleteObject(_hIcon);

    if (_hfontReg)
        DeleteObject(_hfontReg);

    if (_hfontBold)
        DeleteObject(_hfontBold);

    if (_hdpaActions)
        DPA_DestroyCallback(_hdpaActions, _DeleteLocalAllocCB, NULL);

    if (_hdpaRemovedActions)
        DPA_DestroyCallback(_hdpaRemovedActions, _DeleteLocalAllocCB, NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTAdvDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = _InitAssocStore();
    DECLAREWAITCURSOR;

    SetWaitCursor();

    if (SUCCEEDED(hres))
    {
        _InitListView();

        _InitDefaultActionFont();

    // FTEdit_AreDefaultViewersInstalled ????

        if (*_szProgID)
        {
            _SetDocIcon();

            _InitDescription();

            _FillListView();

            _InitDefaultAction();

            _SelectListViewItem(0);

            _InitChangeIconButton();

            _UpdateCheckBoxes();
        }   
    }
    else
        EndDialog(_hwnd, -1);

    ResetWaitCursor();

    // Return TRUE so that system set focus
    return TRUE;
}

int CFTAdvDlg::_GetIconIndex()
{
    // check under the file progid
    int iImageIndex = -1;
    IAssocInfo* pAI = NULL;
    HRESULT hr = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hr))
    {
        hr = pAI->GetDWORD(AIDWORD_DOCLARGEICON, (DWORD*)&iImageIndex);
        pAI->Release();
    }
    return iImageIndex;
}

HRESULT CFTAdvDlg::_SetDocIcon(int iIndex)
{
    HRESULT hres = E_FAIL;

    if (-1 == iIndex)
    {
        iIndex = _GetIconIndex();
    }

    if (-1 != iIndex)
    {
        HIMAGELIST hIL = NULL;

        Shell_GetImageLists(&hIL, NULL);

        if (_hIcon)
        {
            DeleteObject(_hIcon);
            _hIcon = NULL;
        }

        if (hIL)
        {
            _hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIndex);

            _hIcon = (HICON)CopyImage(_hIcon, IMAGE_ICON, 32, 32, LR_COPYDELETEORG);

            HICON hiOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_EDIT_DOCICON, STM_SETIMAGE, IMAGE_ICON,
                (LPARAM)_hIcon);

            if (hiOld)
                DestroyIcon(hiOld);
        }
    }

    return hres;
}

LRESULT CFTAdvDlg::OnListViewSelItem(int iItem, LPARAM lParam)
{
    _UpdateActionButtons();

    return TRUE;
}

LRESULT CFTAdvDlg::OnMeasureItem(WPARAM wParam, LPARAM lParam)
{
    TEXTMETRIC tm = {0};
    RECT rect;
    LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;

    HDC hdc = GetDC(NULL);
    HFONT hfontOld = (HFONT)SelectObject(hdc, _hfontBold);

    GetTextMetrics(hdc, &tm);

    GetClientRect(_GetLVHWND(), &rect);

    lpmis->itemWidth = rect.right;
    lpmis->itemHeight = tm.tmHeight;

    SelectObject(hdc, hfontOld);

    ReleaseDC(NULL, hdc);

    return TRUE;
}

LRESULT CFTAdvDlg::OnDrawItem(WPARAM wParam, LPARAM lParam)
{
    LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)lParam;
    LRESULT lRet = FALSE;
    
    if (ODT_LISTVIEW == lpDIS->CtlType)
    {
        HWND hwndLV = _GetLVHWND();
        LVITEM lvItem = {0};
        HFONT hfontOld = NULL;
        BOOL fSel = FALSE;
        BOOL fListFocus = FALSE;
        TCHAR szAction[MAX_ACTION];
        COLORREF crBkgd = 0;
        COLORREF crOldText = 0;
        
        lvItem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
        lvItem.iItem = lpDIS->itemID;
        lvItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
        lvItem.pszText = szAction;
        lvItem.cchTextMax = ARRAYSIZE(szAction);

        ListView_GetItem(hwndLV, &lvItem);

        fSel = (lvItem.state & LVIS_SELECTED);
        fListFocus = (GetFocus() == hwndLV);
        
        crBkgd = (fSel ? (fListFocus ? COLOR_HIGHLIGHT : COLOR_3DFACE) : COLOR_WINDOW);

        SetBkColor(lpDIS->hDC, GetSysColor(crBkgd));

        FillRect(lpDIS->hDC, &lpDIS->rcItem, (HBRUSH)IntToPtr(crBkgd + 1));

        crOldText = SetTextColor(lpDIS->hDC, 
            GetSysColor(fSel ? (fListFocus ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT) :
            COLOR_WINDOWTEXT));

        // Use Bold font for default action
        hfontOld = (HFONT)SelectObject(lpDIS->hDC, 
            _IsDefaultAction(ADDDATA_ACTIONREG(&lvItem)) ? _hfontBold : _hfontReg);
        
        int iOldBkMode = SetBkMode(lpDIS->hDC, OPAQUE);

        DrawText(lpDIS->hDC, szAction, lstrlen(szAction), &lpDIS->rcItem, 0);

        SetBkMode(lpDIS->hDC, iOldBkMode);

        SetTextColor(lpDIS->hDC, crOldText);

        SelectObject(lpDIS->hDC, hfontOld);
        
        if(fListFocus && (lvItem.state & LVIS_FOCUSED))
            DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);

        lRet = TRUE;
    }

    return lRet;
}

HRESULT CFTAdvDlg::_InitDefaultActionFont()
{
    HFONT hfontDlg = GetWindowFont(_hwnd);
    LOGFONT lf = {0};

    LOGFONT lfDlg = {0};
    GetObject(hfontDlg, sizeof(LOGFONT), &lfDlg);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);

    // Normal font
    lf.lfWeight = FW_NORMAL;
    lf.lfHeight = lfDlg.lfHeight;    
    _hfontReg = CreateFontIndirect(&lf);

    // Bold font
    lf.lfWeight = FW_BOLD;
    _hfontBold = CreateFontIndirect(&lf);

    return (_hfontReg && _hfontBold) ? S_OK : E_FAIL;
}

HRESULT CFTAdvDlg::_SelectListViewItem(int i)
{
    LVITEM lvItem = {0};

    lvItem.iItem = i;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_GetLVHWND(), &lvItem);

    return S_OK;
}

// pszText and cchTextMax needs to be set
BOOL CFTAdvDlg::_FindActionLVITEM(LPTSTR pszActionReg, LVITEM* plvItem)
{
    HWND hwndLV = _GetLVHWND();
    int iCount = ListView_GetItemCount(hwndLV);
    BOOL fRet = FALSE;

    plvItem->mask = LVIF_TEXT | LVIF_PARAM;

    for (int i = 0; i < iCount; ++i)
    {
        plvItem->iItem = i;

        if (ListView_GetItem(hwndLV, plvItem))
        {
            if (!lstrcmpi(pszActionReg, ADDDATA_ACTIONREG(plvItem)))
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

HRESULT CFTAdvDlg::_InitDefaultAction()
{
    // Get it from the classstore
    IAssocInfo* pAI = NULL;
    HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hres))
    {
        TCHAR szActionReg[MAX_ACTION];
        DWORD cchActionReg = ARRAYSIZE(szActionReg);
        HWND hwndLV = _GetLVHWND();
        int iIndex = -1;

        hres = pAI->GetString(AISTR_PROGIDDEFAULTACTION, szActionReg, &cchActionReg);

        if (SUCCEEDED(hres))
        {
            TCHAR szActionLVI[MAX_ACTION];
            LVITEM lvItem = {0};

            lvItem.pszText = szActionLVI;
            lvItem.cchTextMax = ARRAYSIZE(szActionLVI);

            if (_FindActionLVITEM(szActionReg, &lvItem))
                hres = _SetDefaultAction(lvItem.iItem);
            else
                hres = S_OK;
        }

        pAI->Release();
    }

    return hres;
}

BOOL CFTAdvDlg::_GetDefaultAction(LPTSTR pszActionReg, DWORD cchActionReg)
{
    BOOL fRet = FALSE;
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    int iCount = ListView_GetItemCount(hwndLV);
    TCHAR szActionRegLocal[MAX_ACTION];

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.pszText = szActionRegLocal;
    lvItem.cchTextMax = ARRAYSIZE(szActionRegLocal);

    for (int i = 0; i < iCount; ++i)
    {
        lvItem.iItem = i;

        if (ListView_GetItem(hwndLV, &lvItem))
        {
            if (ADDDATA_DEFAULTACTION(&lvItem))
            {
                if(SUCCEEDED(StringCchCopy(pszActionReg, cchActionReg, ADDDATA_ACTIONREG(&lvItem))))
                    fRet = TRUE;
                else
                    fRet = FALSE;
                break;
            }
        }
    }

    return fRet;
}

BOOL CFTAdvDlg::_IsDefaultAction(LPTSTR pszActionReg)
{
    BOOL fRet = FALSE;
    TCHAR szActionReg[MAX_ACTION];

    if (_GetDefaultAction(szActionReg, ARRAYSIZE(szActionReg)))
    {
        if (!lstrcmpi(szActionReg, pszActionReg))
            fRet = TRUE;
    }

    return fRet;
}

void CFTAdvDlg::_CheckDefaultAction()
{
    HWND hwndLV = _GetLVHWND();
    // Is there only one elem?
    if (1 == ListView_GetItemCount(hwndLV))
    {
        _SetDefaultActionHelper(0, TRUE);
    }
}

HRESULT CFTAdvDlg::_SetDefaultAction(int iIndex)
{
    HWND hwndLV = _GetLVHWND();
    // Remove previous default if any

    if (-1 != _iDefaultAction)
    {
        _SetDefaultActionHelper(_iDefaultAction, FALSE);

        ListView_RedrawItems(hwndLV, _iDefaultAction, _iDefaultAction);
    }

    // Set new
    _iDefaultAction = iIndex;

    // iIndex == -1 means no default
    if (iIndex >= 0)    
    {
        _SetDefaultActionHelper(_iDefaultAction, TRUE);

        ListView_RedrawItems(hwndLV, _iDefaultAction, _iDefaultAction);
    }
    
    return S_OK;
}

void CFTAdvDlg::_SetDefaultActionHelper(int iIndex, BOOL fDefault)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iIndex;

    _iDefaultAction = -1;

    if (ListView_GetItem(hwndLV, &lvItem))
    {
        ADDDATA_DEFAULTACTION(&lvItem) = fDefault;
        _iDefaultAction = iIndex;
    }
}

HRESULT CFTAdvDlg::_InitListView()
{
    LVCOLUMN lvColumn = {0};
    HWND hwndLV = _GetLVHWND();
    RECT rc = {0};

    {
        // What's this?
        // We need to handle the WM_MEASUREITEM message from the listview.  This msg
        // is sent before we receive the WM_INITDIALOG and thus before we connect the
        // this C++ obj to the HWND.  By changing the style here we receive the msg
        // after the C++ obj and the HWND are connected.
        LONG lStyle = GetWindowLong(hwndLV, GWL_STYLE);

        lStyle &= ~LVS_LIST;

        SetWindowLong(hwndLV, GWL_STYLE, lStyle | LVS_REPORT);
    }

    //
    // Set the columns
    //
    GetClientRect(hwndLV, &rc);

    lvColumn.mask = LVCF_SUBITEM|LVCF_WIDTH;
    lvColumn.cx = rc.right - GetSystemMetrics(SM_CXBORDER);
    lvColumn.iSubItem = 0;

    ListView_InsertColumn(hwndLV, 0, &lvColumn);

    return S_OK;
}

HRESULT CFTAdvDlg::_UpdateActionButtons()
{
    HRESULT hres = E_FAIL;
    TCHAR szAction[MAX_ACTION];
    BOOL bRet = FALSE;

    LVITEM lvItem = {0};
    lvItem.pszText = szAction;
    lvItem.cchTextMax = ARRAYSIZE(szAction);

    bRet = _GetListViewSelectedItem(LVIF_TEXT | LVIF_PARAM, 0, &lvItem);

    // If we don't have a selected item Or we don't have any text for that item.
    if (!bRet || !(*(lvItem.pszText)))
    {
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT), TRUE);        

        hres = S_OK;
    }
    else
    {
        if (_IsNewPROGIDACTION(lvItem.pszText))
        {
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT), TRUE);
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE), TRUE);

            hres = S_OK;
        }
        else
        {
            IAssocInfo* pAI = NULL;

            hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
            if (SUCCEEDED(hres))
            {
                DWORD dwAttributes;
                HWND hwndLV = _GetLVHWND();

                // REARCHITECT: This code should be in ftassoc.cpp, and we should have
                // more AIBOOL_ flags for this
                hres = pAI->GetDWORD(AIDWORD_PROGIDEDITFLAGS, &dwAttributes);

                if (FAILED(hres))
                {
                    // It failed, probably there is no EditFlags value for this progID, let's
                    // set some default value for dwAttributes
                    dwAttributes = 0;
                }
                // REARCHITECT (end)

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT),
                    !((dwAttributes & FTA_NoEditVerb) &&
                    !(dwAttributes & FTAV_UserDefVerb)));

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_REMOVE),
                    !((dwAttributes & FTA_NoRemoveVerb) &&
                    !(dwAttributes & FTAV_UserDefVerb)));

                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT),
                    !(dwAttributes & FTA_NoEditDflt));  

                // Enable the default button only if the action is not already
                // the default action
                EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DEFAULT),
                    !_IsDefaultAction(ADDDATA_ACTIONREG(&lvItem)));

                pAI->Release();
            }
        }
    }

    return hres;
}

HRESULT CFTAdvDlg::_UpdateCheckBoxes()
{
    BOOL fBool;

    IAssocInfo* pAI = NULL;

    HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hres))
    {
        hres = pAI->GetBOOL(AIBOOL_CONFIRMOPEN, &fBool);

        if (SUCCEEDED(hres))
            CheckDlgButton(_hwnd, IDC_FT_EDIT_CONFIRM_OPEN, !fBool);

        hres = pAI->GetBOOL(AIBOOL_ALWAYSSHOWEXT, &fBool);

        if (SUCCEEDED(hres))
            CheckDlgButton(_hwnd, IDC_FT_EDIT_SHOWEXT, fBool);

        hres = pAI->GetBOOL(AIBOOL_BROWSEINPLACEENABLED, &fBool);

        if (SUCCEEDED(hres))
        {
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_BROWSEINPLACE), fBool);

            if (fBool)
            {
                hres = pAI->GetBOOL(AIBOOL_BROWSEINPLACE, &fBool);

                if (SUCCEEDED(hres))
                    CheckDlgButton(_hwnd, IDC_FT_EDIT_BROWSEINPLACE, fBool);
            }
            else
                CheckDlgButton(_hwnd, IDC_FT_EDIT_BROWSEINPLACE, FALSE);
        }
        pAI->Release();
    }

    return hres;
}

HRESULT CFTAdvDlg::_InitChangeIconButton()
{
    HRESULT hres = E_FAIL;
    BOOL fChangeIcon = TRUE;

    IAssocInfo* pAI = NULL;

    hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

    if (SUCCEEDED(hres))
    {
        hres = pAI->GetBOOL(AIBOOL_EDITDOCICON, &fChangeIcon);
    
        if (SUCCEEDED(hres))
            EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_CHANGEICON), fChangeIcon);

        pAI->Release();
    }

    return hres;
}

HRESULT CFTAdvDlg::_InitDescription()
{
    HRESULT hres = E_FAIL;
    BOOL fEditDescr = TRUE;

    IAssocInfo* pAI = NULL;

    hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

    if (SUCCEEDED(hres))
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

        hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);
    
        if (SUCCEEDED(hres))
            SetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr);

        hres = pAI->GetBOOL(AIBOOL_EDITDESCR, &fEditDescr);

        EnableWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_DESC), fEditDescr);

        pAI->Release();

        Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_EDIT_DESC), MAX_PROGIDDESCR - 1);
    }

    return hres;
}

HRESULT CFTAdvDlg::_FillListView()
{
    HRESULT hres = E_FAIL;

    IEnumAssocInfo* pEnum = NULL;

    hres = _pAssocStore->EnumAssocInfo(ASENUM_ACTION, _szProgID, AIINIT_PROGID, &pEnum);

    if (SUCCEEDED(hres))
    {
        int iItem = 0;
        IAssocInfo* pAI = NULL;

        while (S_OK == pEnum->Next(&pAI))
        {
            TCHAR szActionReg[MAX_ACTION];
            DWORD cchActionReg = ARRAYSIZE(szActionReg);

            hres = pAI->GetString(AISTR_ACTION, szActionReg, &cchActionReg);

            if (SUCCEEDED(hres))
            {
                TCHAR szActionFN[MAX_ACTION];
                DWORD cchActionFN = ARRAYSIZE(szActionFN);

                hres = pAI->GetString(AISTR_ACTIONFRIENDLY, szActionFN, &cchActionFN);

                if (SUCCEEDED(hres))
                {
                    if (S_FALSE == hres)
                    {
                        hres = StringCchCopy(szActionFN, ARRAYSIZE(szActionFN), szActionReg);
                    }

                    if (SUCCEEDED(hres) && -1 != _InsertListViewItem(iItem, szActionReg, szActionFN))
                    {
                        ++iItem;
                    }
                }
            }

            pAI->Release();
        }

        pEnum->Release();
    }

    return hres;
}

LRESULT CFTAdvDlg::OnChangeIcon(WORD wNotif)
{
    IAssocInfo* pAI;
    HRESULT hr = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);
    if (SUCCEEDED(hr))
    {
        DWORD cchIconLoc = ARRAYSIZE(_szOldIconLoc);
        hr = pAI->GetString(AISTR_ICONLOCATION, _szOldIconLoc, &cchIconLoc);
        pAI->Release();

        _iOldIcon = PathParseIconLocation(_szOldIconLoc);
    }

    if (FAILED(hr))
    {
        hr = StringCchCopy(_szOldIconLoc, ARRAYSIZE(_szOldIconLoc), TEXT("shell32.dll"));
        if(SUCCEEDED(hr))
        {
            _iOldIcon = -(IDI_SYSFILE);
        }
    }

    if (SUCCEEDED(hr))
    {
        // setup the in params
        int iIcon = _iOldIcon;
        hr = StringCchCopy(_szIconLoc,  ARRAYSIZE(_szIconLoc), _szOldIconLoc);
        if (SUCCEEDED(hr) && PickIconDlg(_hwnd, _szIconLoc, ARRAYSIZE(_szIconLoc), &iIcon))
        {
            _SetDocIcon(Shell_GetCachedImageIndex(_szIconLoc, iIcon, 0));

            // Format the _szIconLoc
            int iLen = lstrlen(_szIconLoc);
            hr = StringCchPrintf(_szIconLoc + iLen, ARRAYSIZE(_szIconLoc) - iLen, TEXT(",%d"), iIcon);
        }
        else
        {
            _szIconLoc[0] = 0;
        }
    }

    return FALSE;
}

// Return value: 
//  TRUE:  Check succeeded, everything is OK
//  FALSE: Check failed
BOOL CFTAdvDlg::_CheckForDuplicateNewAction(LPTSTR pszActionReg, LPTSTR pszActionFN)
{
    // we just go through the listview content
    HWND hwndLV = _GetLVHWND();
    int cItem = ListView_GetItemCount(hwndLV);
    BOOL fRet = TRUE;

    for (int i = 0; (i < cItem) && fRet; ++i)
    {
        TCHAR szActionFN[MAX_ACTION];
        LVITEM lvItem = {0};

        lvItem.mask = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem = i;
        lvItem.pszText = szActionFN;
        lvItem.cchTextMax = ARRAYSIZE(szActionFN);

        ListView_GetItem(hwndLV, &lvItem);

        if (!lstrcmpi(lvItem.pszText, pszActionFN))
        {
            fRet = FALSE;
        }
        else
        {
            if (!lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionReg))
            {
                fRet = FALSE;
            }
        }
    }

    return fRet;
}

// Return value: 
//  TRUE:  Check succeeded, everything is OK
//  FALSE: Check failed
BOOL CFTAdvDlg::_CheckForDuplicateEditAction(LPTSTR pszActionRegOriginal, LPTSTR pszActionReg,
                                             LPTSTR pszActionFNOriginal, LPTSTR pszActionFN)
{
    // we just go through the listview content
    HWND hwndLV = _GetLVHWND();
    int cItem = ListView_GetItemCount(hwndLV);
    BOOL fRet = TRUE;

    for (int i = 0; (i < cItem) && fRet; ++i)
    {
        TCHAR szActionFN[MAX_ACTION];
        LVITEM lvItem = {0};

        lvItem.mask = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem = i;
        lvItem.pszText = szActionFN;
        lvItem.cchTextMax = ARRAYSIZE(szActionFN);

        ListView_GetItem(hwndLV, &lvItem);

        if (!lstrcmpi(lvItem.pszText, pszActionFN))
        {
            // they are the same, this can happen if this is the Action we were editing
            // and we did not change the action name

            // Is this the original one we were editing?
            if (lstrcmpi(szActionFN, pszActionFNOriginal))
            {
                // No, it's not the original, we have a dup
                fRet = FALSE;
            }
        }
        else
        {
            if (!lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionReg))
            {
                // they are the same, this can happen if this is the Action we were editing
                // and we did not change the action name

                // Is this the original one we were editing?
                if (lstrcmpi(ADDDATA_ACTIONREG(&lvItem), pszActionRegOriginal))
                {
                    // No, it's not the original, we have a dup
                    fRet = FALSE;
                }
            }
        }
    }

    return fRet;
}

LRESULT CFTAdvDlg::OnNewButton(WORD wNotif)
{
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    PROGIDACTION pida = {0};
    CFTActionDlg* pActionDlg = NULL;

    pida.fNew = TRUE;

    GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr, ARRAYSIZE(szProgIDDescr));

    // FALSE: New (not-Edit)
    pActionDlg = new CFTActionDlg(&pida, szProgIDDescr, FALSE);

    if (pActionDlg)
    {
        BOOL fShowAgain;

        do
        {
            fShowAgain = FALSE;

            if (IDOK == pActionDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), _hwnd))
            {
                // Do we have duplicate actions?
                if (_CheckForDuplicateNewAction(pida.szActionReg, pida.szAction))
                {
                    // No
                    HRESULT hres = _AppendPROGIDACTION(&pida);

                    if (SUCCEEDED(hres))
                    {
                        int iItem = _InsertListViewItem(0, pida.szActionReg, pida.szAction);

                        hres = S_OK;

                        if (-1 != iItem)
                            _SelectListViewItem(iItem);
                    }
                }
                else
                {
                    // Yes
                    fShowAgain = TRUE;

                    pActionDlg->SetShowAgain();
                }
            }

            if (fShowAgain)
            {
                ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXISTINGACTION), 
                    MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP, pida.szAction);
            }

        } while (fShowAgain);

        pActionDlg->Release();
    }

    _CheckDefaultAction();

    return FALSE;
}

LRESULT CFTAdvDlg::OnEditButton(WORD wNotif)
{
    TCHAR szAction[MAX_ACTION];
    HRESULT hres = E_FAIL;
    LONG lRes = 0;

    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;
    lvItem.pszText = szAction;
    lvItem.cchTextMax = ARRAYSIZE(szAction);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        PROGIDACTION* pPIDA = NULL;
        PROGIDACTION pida = {0};

        GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr, ARRAYSIZE(szProgIDDescr));

        BOOL fNewOrEdit = SUCCEEDED(_GetPROGIDACTION(lvItem.pszText, &pPIDA));

        if (!fNewOrEdit)
        {
            hres = _FillPROGIDACTION(&pida, ADDDATA_ACTIONREG(&lvItem), szAction);

            pPIDA = &pida;
        }
        else
        {
            hres = S_OK;
        }

        if (SUCCEEDED(hres))
        {
            // TRUE: Edit
            CFTActionDlg* pActionDlg = new CFTActionDlg(pPIDA, szProgIDDescr, TRUE);

            if (pActionDlg)
            {
                BOOL fShowAgain;

                do
                {
                    fShowAgain = FALSE;

                    if (IDOK == pActionDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSCMD), _hwnd))
                    {
                        // Do we have duplicate actions?
                        if (_CheckForDuplicateEditAction(ADDDATA_ACTIONREG(&lvItem), pPIDA->szActionReg,
                            lvItem.pszText, pPIDA->szAction))
                        {
                            // No
                            if (!fNewOrEdit)
                            {
                                hres = _AppendPROGIDACTION(pPIDA);
                            }
                            else
                            {
                                hres = S_OK;
                            }

                            if (SUCCEEDED(hres))
                            {
                                // Replace the current item text
                                hres = StringCchCopy(lvItem.pszText, lvItem.cchTextMax, pPIDA->szAction);
                                if(SUCCEEDED(hres))
                                {
                                    ListView_SetItem(_GetLVHWND(), &lvItem);
                                }
                            }
                        }
                        else
                        {
                            // Yes
                            fShowAgain = TRUE;

                            pActionDlg->SetShowAgain();
                        }
                    }

                    if (fShowAgain)
                    {
                        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXISTINGACTION), 
                            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP, pPIDA->szAction);
                    }

                } while (fShowAgain);

                pActionDlg->Release();
            }
        }
    }

    return FALSE;
}

LRESULT CFTAdvDlg::OnSetDefault(WORD wNotif)
{
    BOOL bRet;
    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;

    bRet = _GetListViewSelectedItem(0, 0, &lvItem);

    if (bRet)
        _SetDefaultAction(lvItem.iItem);
    else
        _SetDefaultAction(-1);
        
    return FALSE;
}

LRESULT CFTAdvDlg::OnRemoveButton(WORD wNotif)
{
    TCHAR szExt[MAX_EXT];
    HRESULT hres = E_FAIL;
    LONG lRes = 0;

    LVITEM lvItem = {0};
    // lvItem.iSubItem = 0;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        if (IDYES == ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_REMOVEACTION),
            MAKEINTRESOURCE(IDS_FT), MB_YESNO | MB_ICONQUESTION))
        {
            //
            // First take care of data side
            //

            // Yes.  Is this a new Action?
            PROGIDACTION* pPIDA = NULL;
            if (SUCCEEDED(_GetPROGIDACTION(lvItem.pszText, &pPIDA)) && pPIDA->fNew)
            {
                // Yes, we'll just remove it from the DPA
                hres = _RemovePROGIDACTION(pPIDA);
            }
            else
            {
                // No, add its name to the list to delete if user press OK
                DWORD cchSize = ARRAYSIZE(ADDDATA_ACTIONREG(&lvItem));

                LPTSTR pszActionToRemove = (LPTSTR)LocalAlloc(LPTR, 
                    cchSize * sizeof(TCHAR));
                hres = E_OUTOFMEMORY;

                if (pszActionToRemove)
                {
                    hres = StringCchCopy(pszActionToRemove, cchSize, ADDDATA_ACTIONREG(&lvItem));
                    if (SUCCEEDED(hres) && -1 != DPA_AppendPtr(_hdpaRemovedActions, pszActionToRemove))
                        hres = S_OK;
                    else
                        LocalFree((HLOCAL)pszActionToRemove);
                }

                if (E_OUTOFMEMORY == hres)
                {
                    //Out of memory
                    ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                        ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                        MB_OK | MB_ICONSTOP);
                }
            }

            //
            // Then update UI, I/A
            //
            if (SUCCEEDED(hres))
            {
                HWND hwndLV = _GetLVHWND();
                int iCount = ListView_GetItemCount(hwndLV);
                int iNextSel = -1;        
        
                ListView_DeleteItem(hwndLV, lvItem.iItem);
        
                if (iCount > lvItem.iItem)
                    iNextSel = lvItem.iItem;
                else
                    if (lvItem.iItem > 0)
                        iNextSel = lvItem.iItem - 1;

                if (-1 != iNextSel)
                    _SelectListViewItem(iNextSel);
            }
        }
        else
            hres = S_FALSE;
    }
    
    _CheckDefaultAction();

    return FALSE;
}

LRESULT CFTAdvDlg::OnOK(WORD wNotif)
{
    BOOL fChecksPassed = FALSE;

    // Yes, we need to:
    //  - remove "removed" items, modify "edited" ones,
    //    and add "New" ones
    //  - update checkboxes related stuff
    //  - set the default action
    //  - set the icon
    //  - set the description
    {
        int n = DPA_GetPtrCount(_hdpaRemovedActions);

        if (n)
        {
            IAssocInfo* pAI;
            HRESULT hres = E_FAIL;

            for (int i = 0; i < n; ++i)
            {
                LPTSTR pszActionToRemove = (LPTSTR)DPA_GetPtr(_hdpaRemovedActions, i);

                if (pszActionToRemove && *pszActionToRemove)
                {
                    hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                        pszActionToRemove, AIINIT_ACTION, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        pAI->Delete(AIALL_NONE);
                        pAI->Release();
                    }

                    LocalFree((HLOCAL)pszActionToRemove);
                    DPA_DeletePtr(_hdpaRemovedActions, i);
                }
            }
        }
    }
    {
        int n = DPA_GetPtrCount(_hdpaActions);

        if (n)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            for (int i = n - 1; i >= 0; --i)
            {
                PROGIDACTION* pPIDAFromList = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

                if (pPIDAFromList)
                {   
                    // Is it an Edited one?
                    if (!pPIDAFromList->fNew)
                    {
                        // Yes, remove the old one first
                        hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                            pPIDAFromList->szOldActionReg, AIINIT_ACTION, &pAI);

                        if (SUCCEEDED(hres))
                        {
                            pAI->Delete(AIALL_NONE);                        
                            pAI->Release();
                        }
                    }

                    // Add new data
                    hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
                        pPIDAFromList->szActionReg, AIINIT_ACTION, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        hres = pAI->SetData(AIDATA_PROGIDACTION, (PBYTE)pPIDAFromList,
                            sizeof(*pPIDAFromList));

                        pAI->Release();
                    }

                    // Clean up DPA
                    _DeletePROGIDACTION(pPIDAFromList);

                    DPA_DeletePtr(_hdpaActions, i);
                }
            }
        }
    }
    {
        IAssocInfo* pAI = NULL;
        HWND hwndLV = _GetLVHWND();
        LVFINDINFO lvFindInfo = {0};
        int iIndex = -1;
        HRESULT hres = _pAssocStore->GetAssocInfo(_szProgID, AIINIT_PROGID, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szActionReg[MAX_ACTION];

            hres = pAI->SetBOOL(AIBOOL_CONFIRMOPEN, 
                !IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_CONFIRM_OPEN));

            hres = pAI->SetBOOL(AIBOOL_ALWAYSSHOWEXT, 
                IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_SHOWEXT));

            hres = pAI->SetBOOL(AIBOOL_BROWSEINPLACE, 
                IsDlgButtonChecked(_hwnd, IDC_FT_EDIT_BROWSEINPLACE));

            // Set the default action, if any
            if (_GetDefaultAction(szActionReg, ARRAYSIZE(szActionReg)))
            {
                hres = pAI->SetString(AISTR_PROGIDDEFAULTACTION, szActionReg);
            }
            else
            {
                hres = pAI->SetString(AISTR_PROGIDDEFAULTACTION, TEXT(""));
            }

            // Set the icon, if changed
            if (_szIconLoc[0])
            {
                // Set it in the registry
                hres = pAI->SetString(AISTR_ICONLOCATION, _szIconLoc);
                if (_szOldIconLoc[0])
                {
                    int iIconIndex = Shell_GetCachedImageIndex(_szOldIconLoc, _iOldIcon, 0);

                    SHUpdateImage(_szOldIconLoc, _iOldIcon, 0, iIconIndex);
                }
            }

            // Set the description
            {
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];

                GetDlgItemText(_hwnd, IDC_FT_EDIT_DESC, szProgIDDescr,
                    ARRAYSIZE(szProgIDDescr));

                hres = pAI->SetString(AISTR_PROGIDDESCR, szProgIDDescr);
            }

            pAI->Release();
        }
    }

    EndDialog(_hwnd, IDOK);

    return FALSE;
}

LRESULT CFTAdvDlg::OnNotifyListView(UINT uCode, LPNMHDR pNMHDR)
{
    HWND hwndLV = _GetLVHWND();
    LRESULT lres = FALSE;

    switch(uCode)
    {
        case NM_DBLCLK:
            if (IsWindowEnabled(GetDlgItem(_hwnd, IDC_FT_EDIT_EDIT)))
                PostMessage(_hwnd, WM_COMMAND, (WPARAM)IDC_FT_EDIT_EDIT, 0);

            break;
//review: do I really need to do this?
        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
            UpdateWindow(hwndLV);
            break;

        case LVN_DELETEITEM:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            if (pNMLV->lParam)
            {
                LocalFree((HLOCAL)(pNMLV->lParam));
            }

            break;
        }

        case LVN_ITEMCHANGED:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected/unselected? 
            if (pNMLV->uChanged & LVIF_STATE)
            {
                // Yes
                OnListViewSelItem(pNMLV->iItem, NULL);
            }
            break;
        }
    }

    return lres;
}

LRESULT CFTAdvDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

LRESULT CFTAdvDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}

BOOL CFTAdvDlg::_GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem)
{
    BOOL fSel = FALSE;
    HWND hwndLV = _GetLVHWND();

    plvItem->mask = uMask | LVIF_STATE | LVIF_PARAM;
    plvItem->stateMask = uStateMask | LVIS_SELECTED;

    // Do we have the selection cached?
    if (-1 != _iLVSel)
    {
        // Yes, make sure it's valid
        plvItem->iItem = _iLVSel;

        ListView_GetItem(hwndLV, plvItem);

        if (plvItem->state & LVIS_SELECTED)
            fSel = TRUE;
    }
 
    // Cache was wrong
    if (!fSel)
    {
        int iCount = ListView_GetItemCount(hwndLV);

        for (int i=0; (i < iCount) && !fSel; ++i)
        {
            plvItem->iItem = i;
            ListView_GetItem(hwndLV, plvItem);

            if (plvItem->state & LVIS_SELECTED)
                fSel = TRUE;
        }

        if (fSel)
            _iLVSel = i;
    }

    return fSel;
}

int CFTAdvDlg::_InsertListViewItem(int iItem, LPTSTR pszActionReg, LPTSTR pszActionFN)
{
    int iRet = -1;
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;

    // Extension
    lvItem.iItem = iItem;
    lvItem.pszText = pszActionFN;
    lvItem.cchTextMax = lstrlen(pszActionFN);

    LV_ADDDATA* plvadddata = (LV_ADDDATA*)LocalAlloc(LPTR, sizeof(LV_ADDDATA));

    if (plvadddata)
    {
        lvItem.lParam = (LPARAM)plvadddata;
        if(SUCCEEDED(StringCchCopy(ADDDATA_ACTIONREG(&lvItem),  ARRAYSIZE(ADDDATA_ACTIONREG(&lvItem)), pszActionReg)))
        {
            ADDDATA_DEFAULTACTION(&lvItem) = 0;
            iRet = ListView_InsertItem(hwndLV, &lvItem);
        }
        else
        {
            LocalFree(plvadddata);
        }
    }
    
    return iRet;
}

HWND CFTAdvDlg::_GetLVHWND()
{
    return GetDlgItem(_hwnd, IDC_FT_EDIT_LV_CMDS);
}

void CFTAdvDlg::_DeletePROGIDACTION(PROGIDACTION* pPIDA)
{
    if (pPIDA)
        LocalFree((HLOCAL)pPIDA);
}

HRESULT CFTAdvDlg::_RemovePROGIDACTION(PROGIDACTION* pPIDA)
{
    HRESULT hres = E_FAIL;

    int n = DPA_GetPtrCount(_hdpaActions);

    for (int i = 0; (i < n) && FAILED(hres); ++i)
    {
        PROGIDACTION* pPIDAFromList = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

        if (pPIDAFromList == pPIDA)
        {
            _DeletePROGIDACTION(pPIDAFromList);

            DPA_DeletePtr(_hdpaActions, i);

            hres = S_OK;
        }
    }

    return hres;
}

HRESULT CFTAdvDlg::_CreatePROGIDACTION(PROGIDACTION** ppPIDA)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppPIDA = (PROGIDACTION*)LocalAlloc(LPTR, sizeof(PROGIDACTION));
    
    if (*ppPIDA)
        hres = S_OK;

    return hres;
}

HRESULT CFTAdvDlg::_CopyPROGIDACTION(PROGIDACTION* pPIDADest, PROGIDACTION* pPIDASrc)
{
    memcpy(pPIDADest, pPIDASrc, sizeof(PROGIDACTION));

    return S_OK;
}

HRESULT CFTAdvDlg::_GetPROGIDACTION(LPTSTR pszActionFN, PROGIDACTION** ppPIDA)
{
    HRESULT hres = E_FAIL;

    *ppPIDA = NULL;

    if (pszActionFN && *pszActionFN)
    {
        int n = DPA_GetPtrCount(_hdpaActions);

        for (int i = 0; (i < n) && FAILED(hres); ++i)
        {
            *ppPIDA = (PROGIDACTION*)DPA_GetPtr(_hdpaActions, i);

            if (!StrCmpN((*ppPIDA)->szAction, pszActionFN, ARRAYSIZE((*ppPIDA)->szAction)))
                hres = S_OK;
        }
    }

    if (FAILED(hres))
        *ppPIDA = NULL;

    return hres;
}

HRESULT CFTAdvDlg::_AppendPROGIDACTION(PROGIDACTION* pPIDA)
{
    PROGIDACTION* pPIDANew = NULL;

    HRESULT hres = _CreatePROGIDACTION(&pPIDANew);

    if (SUCCEEDED(hres))
    {
        _CopyPROGIDACTION(pPIDANew, pPIDA);

        if (-1 != DPA_AppendPtr(_hdpaActions, pPIDANew))
        {
            hres = S_OK;
        }
        else
        {
            _DeletePROGIDACTION(pPIDANew);

            hres = E_OUTOFMEMORY;
        }
    }

    if (E_OUTOFMEMORY == hres)
    {
        //Out of memory
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
            ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
            MB_OK | MB_ICONSTOP);
    }

    return hres;
}

BOOL CFTAdvDlg::_IsNewPROGIDACTION(LPTSTR pszActionFN)
{
    BOOL fRet = FALSE;
    PROGIDACTION* pPIDA = NULL;

    HRESULT hres = _GetPROGIDACTION(pszActionFN, &pPIDA);

    if (SUCCEEDED(hres))
        if (pPIDA->fNew)
            fRet = TRUE;

    return fRet;
}

HRESULT CFTAdvDlg::_FillPROGIDACTION(PROGIDACTION* pPIDA, LPTSTR pszActionReg,
                                     LPTSTR pszActionFN)
{
    PROGIDACTION* pPIDAList = NULL;
    HRESULT hres = _GetPROGIDACTION(pszActionFN, &pPIDAList);

    if (SUCCEEDED(hres))
    {
        _CopyPROGIDACTION(pPIDA, pPIDAList);
    }
    else
    {
        IAssocInfo* pAI = NULL;

        hres = _pAssocStore->GetComplexAssocInfo(_szProgID, AIINIT_PROGID, 
            pszActionReg, AIINIT_ACTION, &pAI);

        if (SUCCEEDED(hres))
        {
            DWORD cbPIDA = sizeof(*pPIDA);

            hres = pAI->GetData(AIDATA_PROGIDACTION, (PBYTE)pPIDA, &cbPIDA);

            pAI->Release();
        }
    }

    return hres;    
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTAdvDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_EDIT_NEW:
            lRes = OnNewButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_REMOVE:
            lRes = OnRemoveButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_EDIT:
            lRes = OnEditButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_CHANGEICON:
            lRes = OnChangeIcon(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_DEFAULT:
            lRes = OnSetDefault(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTAdvDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    //GET_WM_COMMAND_CMD
    switch(idFrom)
    {
        case IDC_FT_EDIT_LV_CMDS:
            OnNotifyListView(uCode, pNMHDR);
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
        default:
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTAdvDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_DRAWITEM:
            lRes = OnDrawItem(wParam, lParam);
            break;

        case WM_MEASUREITEM:
            lRes = OnMeasureItem(wParam, lParam);
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fstreex.h ===
#ifndef _FSTREEX_INC
#define _FSTREEX_INC

#include "idlcomm.h"
#include <filetype.h>
#include "pidl.h"       // IDFOLDER
#include "shitemid.h"

STDAPI_(LPCIDFOLDER) CFSFolder_IsValidID(LPCITEMIDLIST pidl);
STDAPI_(BOOL)        CFSFolder_IsCommonItem(LPCITEMIDLIST pidl);
STDAPI_(BOOL)        CFSFolder_MakeCommonItem(LPITEMIDLIST pidl);

STDAPI CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
STDAPI_(DWORD) CFSFolder_PropertiesThread(void *pv);
STDAPI CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pf, REFIID riid, void **ppv);

STDAPI_(void) SHGetTypeName(LPCTSTR pszFile, HKEY hkey, BOOL fFolder, LPTSTR pszName, int cchNameMax);

STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR  pszProfile, int cchMax, LPCTSTR pszKey);

STDAPI CFSFolder_AsyncCreateFileFromClip(HWND hwnd, LPCTSTR pszPath, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, BOOL fIsBkDropTarget);

STDAPI_(BOOL) SHGetClassKey(LPCITEMIDLIST pidl, HKEY *phkeyProgID, HKEY *phkeyBaseID);
STDAPI_(void) SHCloseClassKey(HKEY hkey);

// CFSFolder::_GetClassFlags
#define SHCF_ICON_INDEX             0x00000FFF
#define SHCF_ICON_PERINSTANCE       0x00001000
#define SHCF_ICON_DOCICON           0x00002000
#define SHCF_00004000               0x00004000
#define SHCF_00008000               0x00008000

#define SHCF_HAS_ICONHANDLER        0x00020000

#define SHCF_IS_DOCOBJECT           0x00100000

#define SHCF_IS_SHELLEXT            0x00400000
#define SHCF_00800000               0x00800000

#define SHCF_IS_LINK                0x01000000
#define SHCF_UNKNOWN                0x04000000
#define SHCF_ALWAYS_SHOW_EXT        0x08000000
#define SHCF_NEVER_SHOW_EXT         0x10000000
#define SHCF_20000000               0x20000000
#define SHCF_40000000               0x40000000
#define SHCF_80000000               0x80000000

STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlAbs, LPCTSTR pszDir, LPITEMIDLIST* ppidl, UINT uFlags);

STDAPI GetIconOverlayManager(IShellIconOverlayManager **ppsiom);

typedef struct {
    BOOL fInitialized;
    POINT pt;
    POINT ptOrigin;
    UINT cxItem, cyItem;
    int xMul, yMul, xDiv, yDiv;
    POINT *pptOffset;
    UINT iItem;
} DROPHISTORY;

STDAPI_(void) PositionFileFromDrop(HWND hwnd, LPCTSTR pszFile, DROPHISTORY *pdh);
STDAPI_(int)  CreateMoveCopyList(HDROP hdrop, void *hNameMappings, LPITEMIDLIST **pppidl);
STDAPI_(void) PositionItems(IFolderView* pifv, LPCITEMIDLIST* apidl, UINT cidl, IDataObject* pdtobj, POINT* ptDrop);
STDAPI_(void) PositionItems_DontUse(HWND hwndOwner, UINT cidl, const LPITEMIDLIST *ppidl, IDataObject *pdtobj, POINT *pptOrigin, BOOL fMove, BOOL fUseExactOrigin);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fstree.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include <shellp.h>
#include <shguidp.h>
#include "idlcomm.h"
#include "pidl.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "datautil.h"
#include "prop.h"
#include "basefvcb.h"
#include "brutil.h"
#include "enumuicommand.h"
#include "enumidlist.h"
#include "wia.h"
#include "shimgvw.h"
#include "cdburn.h"
#include "foldertypes.h"
#include "htmlhelp.h"
#include "buytasks.h"
#include <crypto\md5.h>     // for MD5DIGESTLEN

const SHOP_INFO c_BuySampleMusic =    { L"BuyURL",      L"http://go.microsoft.com/fwlink/?LinkId=730&clcid={SUB_CLCID}", FALSE};
const SHOP_INFO c_BuyMusic          = { L"MusicBuyURL", L"http://go.microsoft.com/fwlink/?LinkId=493&clcid={SUB_CLCID}", TRUE};
const SHOP_INFO c_BuySamplePictures = { L"BuyURL",      L"http://go.microsoft.com/fwlink/?LinkId=625&clcid={SUB_CLCID}", TRUE};

class CFSFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CFSFolderViewCB(CFSFolder *pfsf);
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    STDMETHODIMP SetSite(IUnknown* pUnkSite);

private:
    ~CFSFolderViewCB();

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy);
    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane);
    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax);
    HRESULT OnWindowCreated(DWORD pv, HWND wP);
    HRESULT OnInsertDeleteItem(int iMul, LPCITEMIDLIST wP);
    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnUpdateStatusBar(DWORD pv, BOOL wP);
    HRESULT OnRefresh(DWORD pv, BOOL fPreRefresh);
    HRESULT OnSelectAll(DWORD pv);
    HRESULT OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR lP);
    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST* rgpidl);
    HRESULT OnGetViewData(DWORD pv, UINT uViewMode, SFVM_VIEW_DATA* pvi);
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme);
    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE*lP);
    HRESULT OnGetCustomViewInfo(DWORD pv, SFVM_CUSTOMVIEWINFO_DATA* pData);
    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnQueryReuseExtView(DWORD pv, BOOL *pfReuseAllowed);
    HRESULT OnGetNotify(DWORD pv, LPITEMIDLIST*wP, LONG*lP);
    HRESULT OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings);

    BOOL _CollectDefaultFolderState();
    PERCEIVED _GetFolderPerceivedType(LPCIDFOLDER pidf);
    HRESULT _GetStringForFolderType(int iType, LPWSTR pszFolderType, UINT cchBuf);
    BOOL _IsBarricadedFolder();

    UINT _cItems;

    FSSELCHANGEINFO _fssci;
    CFSFolder* _pfsf;
    BOOL _fStatusInitialized;

    TRIBIT _fHasWIADevices;

    IPreview3 * _pPreview;
    HRESULT _GetPreview3(IPreview3** ppPreview3);

    HRESULT _GetShoppingBrowsePidl(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, const SHOP_INFO *pShopInfo, LPITEMIDLIST *ppidl);
    HRESULT _GetShoppingURL(const SHOP_INFO *pShopInfo, LPTSTR pszURL, DWORD cchURL);


    HRESULT _DataObjectFromItemsOrFolder(IShellItemArray *psiItemArray, IDataObject **ppdto);

public:
    // webview task implementations:
    static HRESULT _HasWiaDevices(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _HasItems(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanBuyPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _OnCommonDocumentsHelp(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShopForMusicOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShopForPicturesOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnGetFromCamera(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSlideShow(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

    static HRESULT _CanPlay(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, int fDATAOBJCB);
    static HRESULT _OnPlay(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, int fDATAOBJCB);
};

#define FS_EVENTS (SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_NETSHARE | SHCNE_NETUNSHARE)

CFSFolderViewCB::CFSFolderViewCB(CFSFolder *pfsf) : CBaseShellFolderViewCB(pfsf->_pidl, FS_EVENTS), _pfsf(pfsf)
{ 
    _pfsf->AddRef();

    ZeroMemory(&_fssci, sizeof(_fssci));

    // _fssci.szDrive[0] == '\0' means "unknown" / "not available"
    _fssci.cbFree = -1;        // this field uses -1 to mean
                               // "unknown" / "not available"

    _pPreview = NULL;
    ASSERT(!_fStatusInitialized);
}

CFSFolderViewCB::~CFSFolderViewCB()
{
    if (_pPreview)
    {
        IUnknown_SetSite(_pPreview, NULL);
        _pPreview->Release();
    }

    _pfsf->Release();
}

STDMETHODIMP CFSFolderViewCB::SetSite(IUnknown* punkSite)
{
    if (_pPreview)
    {
        IUnknown_SetSite(_pPreview, punkSite);
    }
    return CBaseShellFolderViewCB::SetSite(punkSite);
}

HRESULT CFSFolderViewCB::OnSize(DWORD pv, UINT cx, UINT cy)
{
    ResizeStatus(_punkSite, cx);
    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
{
    if (PANE_ZONE == dwPaneID)
        *pdwPane = 2;
    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax)
{
    TCHAR szName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(_pfsf, pidlItem, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
    {
        _pfsf->GetMaxLength(szName, (int *)pcchMax);
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnWindowCreated(DWORD pv, HWND wP)
{
    if (SUCCEEDED(_pfsf->_GetPath(_fssci.szDrive, ARRAYSIZE(_fssci.szDrive))))
    {
        _fssci.cbFree = -1;                            // not known yet

        if (!_fStatusInitialized)
        {
            InitializeStatus(_punkSite);
            _fStatusInitialized = TRUE;
        }
        
        return S_OK;
    
    }
    return E_FAIL;
}

HRESULT CFSFolderViewCB::OnInsertDeleteItem(int iMul, LPCITEMIDLIST wP)
{
    ViewInsertDeleteItem(_pfsf, &_fssci, wP, iMul);

    // Tell the FSFolder that it needs to update the extended columns
    // when we get an insert item.  This will cause the next call to
    // IColumnProvider::GetItemData to flush it's row-wise cache.
    if (1 == iMul)
    {
        _pfsf->_bUpdateExtendedCols = TRUE;
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP)
{
    ViewSelChange(_pfsf, lP, &_fssci);
    return S_OK;
}

HRESULT CFSFolderViewCB::OnUpdateStatusBar(DWORD pv, BOOL wP)
{
    if (!_fStatusInitialized)
    {
        InitializeStatus(_punkSite);
        _fStatusInitialized = TRUE;
    }

    // if initializing, force refresh of disk free space
    if (wP)
        _fssci.cbFree = -1;
    return ViewUpdateStatusBar(_punkSite, _pidl, &_fssci);
}

HRESULT CFSFolderViewCB::OnRefresh(DWORD pv, BOOL fPreRefresh)
{
    // pre refresh...
    if (fPreRefresh)
    {
        _fHasWIADevices = TRIBIT_UNDEFINED; // so we re-query
    }
    else
    {
        _fssci.cHiddenFiles = _pfsf->_cHiddenFiles;
        _fssci.cbSize = _pfsf->_cbSize;
    }
    return S_OK;
}

HRESULT CFSFolderViewCB::OnSelectAll(DWORD pv)
{
    HRESULT hr = S_OK;

    if (_fssci.cHiddenFiles > 0) 
    {
        if (ShellMessageBox(HINST_THISDLL, _hwndMain, 
            MAKEINTRESOURCE(IDS_SELECTALLBUTHIDDEN), 
            MAKEINTRESOURCE(IDS_SELECTALL), MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONWARNING, 
            _fssci.cHiddenFiles) == IDCANCEL)
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR lP)
{
    return _pfsf->_GetPath(lP, MAX_PATH);  // assumed buffer size!  possible overflow.
}

HRESULT CFSFolderViewCB::_HasWiaDevices(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    if (TRIBIT_UNDEFINED == pThis->_fHasWIADevices && fOkToBeSlow)
    {
        pThis->_fHasWIADevices = TRIBIT_FALSE;

        // strings stolen from stiregi.h
        // REGSTR_PATH_SOFT_STI, REGSTR_VAL_WIA_PRESEN

        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage"), 
            TEXT("WIADevicePresent"), NULL, NULL, NULL))
        {
            IWiaDevMgr* pwia;
            if (SUCCEEDED(CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IWiaDevMgr, &pwia))))
            {
                IEnumWIA_DEV_INFO* penum;
                if (S_OK == pwia->EnumDeviceInfo(0, &penum))
                {
                    ULONG cItems;
                    if ((S_OK == penum->GetCount(&cItems)) &&
                        cItems > 0)
                    {
                        pThis->_fHasWIADevices = TRIBIT_TRUE;
                    }
                    penum->Release();
                }
                pwia->Release();
            }
        }
    }

    *puisState = (TRIBIT_TRUE == pThis->_fHasWIADevices) ? UIS_ENABLED : UIS_HIDDEN;
    return TRIBIT_UNDEFINED == pThis->_fHasWIADevices ? E_PENDING : S_OK;
}

HRESULT CFSFolderViewCB::_HasItems(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    *puisState = UIS_ENABLED;

    if (!psiItemArray)
    {
        // empty folders don't want this task
        *puisState = UIS_DISABLED;

        IFolderView* pfv;
        IDataObject *pdo;

        if (pThis->_punkSite && SUCCEEDED(pThis->_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
        {
            if (SUCCEEDED(pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo))))
            {
                *puisState = UIS_ENABLED;
                pdo->Release();
            }

            pfv->Release();
        }

    }

    return S_OK;
}

// Image options
#define IMAGEOPTION_CANROTATE    0x00000001
#define IMAGEOPTION_CANWALLPAPER 0x00000002

HRESULT CFSFolderViewCB::_CanWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;
    IDataObject *pdo;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo))))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(PidlFromDataObject(pdo, &pidl))) // could get this dircetly from ShellItemArray
        {
            IAssociationArray *paa;
            if (SUCCEEDED(SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IAssociationArray, &paa))))
            {
                DWORD dwFlags, cb = sizeof(dwFlags);
                if (SUCCEEDED(paa->QueryDword(ASSOCELEM_MASK_QUERYNORMAL, AQN_NAMED_VALUE, L"ImageOptionFlags", &dwFlags)) &&
                    (dwFlags & IMAGEOPTION_CANWALLPAPER))
                {
                    *puisState = UIS_ENABLED;
                }
                paa->Release();
            }
            ILFree(pidl);
        }

        pdo->Release();
    }

    return S_OK;
}

enum
{
    DATAOBJCB_IMAGE = 0x1,
    DATAOBJCB_MUSIC = 0x2,
    DATAOBJCB_VIDEO = 0x4,

    DATAOBJCB_ONLYCHECKEXISTENCE = 0x80000000
};
class CDataObjectCallback : public INamespaceWalkCB
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

    CDataObjectCallback(DWORD dwFlags);
    BOOL Found();

private:
    DWORD _dwFlags;
    BOOL _fAlreadyFound;
};

STDMETHODIMP_(ULONG) CDataObjectCallback::AddRef()
{
    return 3;
}

STDMETHODIMP_(ULONG) CDataObjectCallback::Release()
{
    return 2;
}

CDataObjectCallback::CDataObjectCallback(DWORD dwFlags)
{
    _dwFlags = dwFlags;
    _fAlreadyFound = FALSE;
}

BOOL CDataObjectCallback::Found()
{
    return _fAlreadyFound;
}

STDMETHODIMP CDataObjectCallback::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDataObjectCallback, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP CDataObjectCallback::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // a slight misuse of the walker -- we bail out early if we know we've already found
    // what we're looking for
    if ((_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE) && _fAlreadyFound)
        return E_FAIL;

    PERCEIVED gen = GetPerceivedType(psf, pidl);
    if ((_dwFlags & DATAOBJCB_IMAGE) && (gen == GEN_IMAGE) ||
        (_dwFlags & DATAOBJCB_MUSIC) && (gen == GEN_AUDIO) ||
        (_dwFlags & DATAOBJCB_VIDEO) && (gen == GEN_VIDEO))
    {
        if (_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE)
        {
            _fAlreadyFound = TRUE;
        }
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CDataObjectCallback::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if ((_dwFlags & DATAOBJCB_ONLYCHECKEXISTENCE) && _fAlreadyFound)
        return E_FAIL;
    return S_OK;
}

STDMETHODIMP CDataObjectCallback::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CDataObjectCallback::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
{
    *ppszCancel = NULL; // use default

    TCHAR szMsg[128];
    LoadString(HINST_THISDLL, IDS_WALK_PROGRESS_TITLE, szMsg, ARRAYSIZE(szMsg));
    return SHStrDup(szMsg, ppszTitle);
}

HRESULT InvokeVerbsOnItems(HWND hwndOwner, const LPCSTR rgszVerbs[], UINT cVerbs, LPITEMIDLIST *ppidls, UINT cItems)
{
    IContextMenu *pcm;
    HRESULT hr = SHGetUIObjectFromFullPIDL(ppidls[0], NULL, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        ITEMIDLIST id = {0};
        IDataObject *pdtobj;
        hr = SHCreateFileDataObject(&id, cItems, (LPCITEMIDLIST *)ppidls, NULL, &pdtobj);
        if (SUCCEEDED(hr))
        {
            IShellExtInit *psei;
            hr = pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                psei->Initialize(NULL, pdtobj, NULL);
                psei->Release();
            }
            pdtobj->Release();
        }

        hr = SHInvokeCommandsOnContextMenu(hwndOwner, NULL, pcm, 0, rgszVerbs, cVerbs);
        pcm->Release();
    }
    return hr;
}

HRESULT PlayFromUnk(IUnknown *punk, HWND hwndOwner, int fDATAOBJCB)
{
    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        CDataObjectCallback cb(fDATAOBJCB);
        hr = pnsw->Walk(punk, NSWF_NONE_IMPLIES_ALL | NSWF_ONE_IMPLIES_ALL | NSWF_SHOW_PROGRESS | NSWF_FLAG_VIEWORDER, 10, &cb);
        if (SUCCEEDED(hr))
        {
            UINT cItems;
            LPITEMIDLIST *ppidls;
            hr = pnsw->GetIDArrayResult(&cItems, &ppidls);
            if (SUCCEEDED(hr))
            {
                if (cItems)
                {
                    const LPCSTR c_rgszVerbs[] = { "Play", "Open" };

                    hr = InvokeVerbsOnItems(hwndOwner, c_rgszVerbs, ARRAYSIZE(c_rgszVerbs), ppidls, cItems);
                }
                else
                {
                    ShellMessageBox(
                        HINST_THISDLL,
                        hwndOwner,
                        MAKEINTRESOURCE(IDS_PLAYABLEFILENOTFOUND),
                        NULL,
                        MB_OK | MB_ICONERROR);
                    hr = S_FALSE;
                }
                FreeIDListArray(ppidls, cItems);
            }
        }
        pnsw->Release();
    }
    return hr;
}

HRESULT CFSFolderViewCB::_OnCommonDocumentsHelp(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    SHELLEXECUTEINFO sei = { 0 };

    sei.cbSize = sizeof(sei);
    sei.fMask = 0;
    sei.hwnd = ((CFSFolderViewCB*)(void*)pv)->_hwndMain;
    sei.nShow = SW_SHOWNORMAL;
    sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_shared_documents_folder.htm&select=TopLevelBucket_2/Networking_and_the_Web/Sharing_files__printers__and_other_resources";

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CFSFolderViewCB::_CanOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    *puisState = UIS_DISABLED;

    if (SHRestricted(REST_NOONLINEPRINTSWIZARD))
    {
        // bail out early with UIS_HIDDEN, we dont show the verb
        return S_OK;
    }

    IDataObject *pdo = NULL;
    HRESULT hr = psiItemArray ? psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo)) : S_OK;
    if (SUCCEEDED(hr))
    {
        if (pThis->_fssci.nItems > 0)   // Files selected.  Determine if any images...
        {
            INamespaceWalk *pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
            if (SUCCEEDED(hr))
            {
                CDataObjectCallback cb(DATAOBJCB_IMAGE | DATAOBJCB_ONLYCHECKEXISTENCE);
                pnsw->Walk(psiItemArray ? pdo : pThis->_punkSite, NSWF_NONE_IMPLIES_ALL | NSWF_DONT_ACCUMULATE_RESULT, 0, &cb);
                if (cb.Found())
                {
                    *puisState = UIS_ENABLED;
                }
                pnsw->Release();
            }
        }
        else
        {
            *puisState = UIS_ENABLED;   // No files selected.  Assume image files exist.
            hr = S_OK;                  // Note we "assume" for the TODO perf reason above.
        }

        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_CanPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    HRESULT hr;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    if (psiItemArray)
    {
        *puisState = UIS_DISABLED;

        IDataObject *pdo;
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            INamespaceWalk *pnsw;
            hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
            if (SUCCEEDED(hr))
            {
                CDataObjectCallback cb(DATAOBJCB_IMAGE | DATAOBJCB_ONLYCHECKEXISTENCE);
                pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 0, &cb);
                if (cb.Found())
                {
                    *puisState = UIS_ENABLED;
                }
                pnsw->Release();
            }

            pdo->Release();
        }
    }
    else
    {
        *puisState = UIS_ENABLED;   // No files selected.  Assume image files exist.
        hr = S_OK;                  // Note we "assume" for the TODO perf reason above.
    }

    return hr;
}


HRESULT CFSFolderViewCB::_CanBuyPictures(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    *puisState = UIS_DISABLED;

    // If there is a BuyURL in the desktop.ini, then we'll show the buy pictures task.
    WCHAR szIniPath[MAX_PATH];
    if (pThis->_pfsf->_CheckDefaultIni(NULL, szIniPath, ARRAYSIZE(szIniPath)) && PathFileExistsAndAttributes(szIniPath, NULL))
    {
        WCHAR szURLArguments[MAX_PATH];
        if (GetPrivateProfileString(L".ShellClassInfo", c_BuySamplePictures.szURLKey, L"", szURLArguments, ARRAYSIZE(szURLArguments), szIniPath))
        {
            // Note:
            //  String validation does not occur here (by design).  This is
            //  simply an "existance" check.  Validation will occur only if
            //  the user actually clicks on this task and we need to execute.

            // Yes - there's something.
            *puisState = UIS_ENABLED;
        }
    }

    return S_OK;
}


HRESULT CFSFolderViewCB::_CanPlayMusic(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    return _CanPlay(pv, psiItemArray, fOkToBeSlow, puisState, DATAOBJCB_MUSIC | DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_CanPlayVideos(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    return _CanPlay(pv, psiItemArray, fOkToBeSlow, puisState, DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_CanPlay(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, int fDATAOBJCB)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    *puisState = UIS_DISABLED;

    // TODO:  Use fOkToBeSlow (with a return of E_PENDING) to allow walk to
    // occur on a background task thread (for performance reasons).  However,
    // it doesn't work at present because it's completely specialized for WIA
    // stuff, and it will not be trivial to adapt to the general case.  Thus,
    // we make assumptions as best we can in determining the state for now.

    IDataObject *pdo = NULL;
    HRESULT hr = psiItemArray ? psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo)) : S_OK;
    if (SUCCEEDED(hr))
    {
        RIPMSG(!psiItemArray || pdo, "CFSFolderViewCB::_CanPlay - BindToHandler returned S_OK but NULL pdo");
        RIPMSG(psiItemArray || pThis->_punkSite, "CFSFolderViewCB::_CanPlay - no _punkSite!");

        if (pThis->_fssci.cFiles > 0)
        {
            if (pThis->_fssci.nItems > 0)   // Files selected.  Determine if any playable...
            {
                INamespaceWalk *pnsw;
                hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
                if (SUCCEEDED(hr))
                {
                    CDataObjectCallback cb(fDATAOBJCB | DATAOBJCB_ONLYCHECKEXISTENCE);
                    pnsw->Walk(psiItemArray ? pdo : pThis->_punkSite, NSWF_DONT_ACCUMULATE_RESULT, 4, &cb);
                    if (cb.Found())
                    {
                        *puisState = UIS_ENABLED;
                    }
                    pnsw->Release();
                }
            }
            else
                *puisState = UIS_ENABLED;   // No files selected.  Assume playable files exist.
        }                                   // Note we "assume" for the TODO perf reason above.

        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnPlayMusic(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return _OnPlay(pv, psiItemArray, pbc, DATAOBJCB_MUSIC | DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_OnPlayVideos(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return _OnPlay(pv, psiItemArray, pbc, DATAOBJCB_VIDEO);
}

HRESULT CFSFolderViewCB::_OnPlay(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, int fDATAOBJCB)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    HRESULT hr;

    if (psiItemArray)
    {
        IDataObject *pdo;
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            hr = PlayFromUnk(pdo, pThis->_hwndMain, fDATAOBJCB);
            pdo->Release();
        }
    }
    else
    {
        hr = PlayFromUnk(pThis->_punkSite, pThis->_hwndMain, fDATAOBJCB);
    }

    return hr;
}

HRESULT CFSFolderViewCB::_GetShoppingURL(const SHOP_INFO *pShopInfo, LPTSTR pszURL, DWORD cchURL)
{
    HRESULT hr = URLSubstitution(pShopInfo->szURLPrefix, pszURL, cchURL, URLSUB_CLCID);

    if (SUCCEEDED(hr))
    {
        WCHAR szIniPath[MAX_PATH];

        // If we can't just use the fwlink with no arguments, then assume failure.
        hr = pShopInfo->bUseDefault ? S_OK : E_FAIL;

        if (_pfsf->_CheckDefaultIni(NULL, szIniPath, ARRAYSIZE(szIniPath)) && PathFileExistsAndAttributes(szIniPath, NULL))
        {
            WCHAR szURLArguments[MAX_PATH];
            if (GetPrivateProfileString(L".ShellClassInfo", pShopInfo->szURLKey, L"", szURLArguments, ARRAYSIZE(szURLArguments), szIniPath))
            {
                // Note:
                //  All URL's are read from hard-coded strings in the code
                //  base, and are of the form:
                //
                //      http://go.microsoft.com/fwlink/?LinkId=730&clcid={SUB_CLCID}
                //
                //  The desktop.ini simply offers an avenue to add additional
                //  arguments onto the end of the URL to refine the redirect.
                //  We do not validate these arguments here, because it is
                //  assumed the fwlink service is robust enough to handle bad
                //  input.  If it wasn't, than anyone could type a bad fwlink
                //  URL in their address bar and wreck havoc on the fwlink
                //  service.
                StringCchCat(pszURL, cchURL, L"&");
                StringCchCat(pszURL, cchURL, szURLArguments);

                // Got some arguments - we're definitely ok.
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::_GetShoppingBrowsePidl(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc, const SHOP_INFO *pShopInfo, LPITEMIDLIST *ppidl)
{
    WCHAR wszShoppingURL[MAX_URL_STRING];
    HRESULT hr = _GetShoppingURL(pShopInfo, wszShoppingURL, ARRAYSIZE(wszShoppingURL));
    if (SUCCEEDED(hr))
    {
        IShellFolder *psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            hr = IShellFolder_ParseDisplayName(psfDesktop, NULL, NULL, wszShoppingURL, NULL, ppidl, NULL);
            psfDesktop->Release();
        }
    }

    return hr;
}



HRESULT CFSFolderViewCB::_OnShopForMusicOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    LPITEMIDLIST pidl;

    // See if there is a sample music BuyURL
    // (do this check first, because the regular music buy URL should always succeed)
    HRESULT hr = pThis->_GetShoppingBrowsePidl(pv, psiItemArray, pbc, &c_BuySampleMusic, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = pThis->_BrowseObject(pidl, SBSP_NEWBROWSER);
        ILFree(pidl);
    }
    else
    {
        // Nope - look for the regular music buy URL
        hr = pThis->_GetShoppingBrowsePidl(pv, psiItemArray, pbc, &c_BuyMusic, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = pThis->_BrowseObject(pidl, SBSP_NEWBROWSER);           
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnShopForPicturesOnline(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    WCHAR wszShoppingURL[MAX_URL_STRING];

    HRESULT hr = pThis->_GetShoppingURL(&c_BuySamplePictures, wszShoppingURL, ARRAYSIZE(wszShoppingURL));

    if (SUCCEEDED(hr))
    {
        HINSTANCE hinstRet = ShellExecute(NULL, NULL, wszShoppingURL, NULL, NULL, SW_SHOWNORMAL);

        hr = ((UINT_PTR)hinstRet) <= 32 ? E_FAIL : S_OK;
    }
    
    return hr;
}


HRESULT CFSFolderViewCB::_DataObjectFromItemsOrFolder(IShellItemArray *psiItemArray, IDataObject **ppdto)
{
    *ppdto = NULL;

    HRESULT hr;
    if (psiItemArray)
    {
        // Something selected -- work with selected items.
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, ppdto));
    }
    else
    {
        // Nothing selected -- imply folder selected.
        hr = SHGetUIObjectOf(_pidl, NULL, IID_PPV_ARG(IDataObject, ppdto));
    }
    return hr;
}

HRESULT CFSFolderViewCB::_CanSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    *puisState = UIS_DISABLED;

    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        // todo: use fOkToBeSlow to get off the UI thread -- right now it wont work because
        // its specialized just for the WIA stuff and things that have global state
        ICDBurn *pcdb;
        if (SUCCEEDED(CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb))))
        {
            // media player will get invoked, so we only worry about if the system has a
            // recordable drive at all -- whether the shell burning is enabled or not doesnt matter
            BOOL fHasRecorder;
            if (SUCCEEDED(pcdb->HasRecordableDrive(&fHasRecorder)) && fHasRecorder)
            {
                IUnknown *punk;
                // if this probe works, we can get something thats good to go and itll burn cds.
                if (SUCCEEDED(CDBurn_GetExtensionObject(CDBE_TYPE_MUSIC, pdo, IID_PPV_ARG(IUnknown, &punk))))
                {
                    *puisState = UIS_ENABLED;
                    punk->Release();
                }
            }
            pcdb->Release();
        }

        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnSendToAudioCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        IDropTarget *pdt;
        hr = CDBurn_GetExtensionObject(CDBE_TYPE_MUSIC, pdo, IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr))
        {
            hr = SHSimulateDrop(pdt, pdo, 0, NULL, NULL);
            pdt->Release();
        }
        pdo->Release();
    }
    return hr;
}

HRESULT CFSFolderViewCB::_CanSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    WCHAR szDrive[4];
    if (SUCCEEDED(CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))))
    {
        // if this succeeds, shell cd burning is enabled.
        *puisState = UIS_ENABLED;
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::_OnSendToCD(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        WCHAR szDrive[4];
        hr = CDBurn_GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(szDrive, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                IDropTarget *pdt;
                hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IDropTarget, &pdt));
                if (SUCCEEDED(hr))
                {
                    hr = SHSimulateDropWithSite(pdt, pdo, 0, NULL, NULL, pThis->_punkSite);
                    pdt->Release();
                }
                ILFree(pidl);
            }
        }
        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnGetFromCamera(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_DOENVSUBST;
    sei.hwnd = ((CFSFolderViewCB*)(void*)pv)->_hwndMain;
    sei.lpFile = TEXT("%SystemRoot%\\System32\\wiaacmgr.exe");
    sei.lpParameters = TEXT("/SelectDevice");
    sei.nShow = SW_SHOWNORMAL;

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CFSFolderViewCB::_GetPreview3(IPreview3** ppPreview3)
{
    HRESULT hr = E_FAIL;
    *ppPreview3 = NULL;

    if (!_pPreview)
    {
        hr = CoCreateInstance(CLSID_Preview, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPreview3, &_pPreview));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(_pPreview, _punkSite);
        }
    }

    if (_pPreview)
    {
        *ppPreview3 = _pPreview;
        _pPreview->AddRef();
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnSlideShow(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    IPreview3* pPreview3;
    HRESULT hr = pThis->_GetPreview3(&pPreview3);
    if (SUCCEEDED(hr))
    {
        hr = pPreview3->SlideShow();
        pPreview3->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnWallpaper(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;

    HRESULT hr = E_FAIL;
    IDataObject *pdo;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo))))
    {
        IPreview3* pPreview3;
        if (SUCCEEDED(pThis->_GetPreview3(&pPreview3)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(PathFromDataObject(pdo, szPath, ARRAYSIZE(szPath))))
            {
                hr = pPreview3->SetWallpaper(szPath);
            }
            pPreview3->Release();
        }

        pdo->Release();
    }

    return hr;
}

HRESULT CFSFolderViewCB::_OnOrderPrints(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropOnClsid(CLSID_InternetPrintOrdering, pThis->_punkSite, pdo);
        pdo->Release();
    }   

    return hr;
}

HRESULT CFSFolderViewCB::_OnPrintPictures(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CFSFolderViewCB* pThis = (CFSFolderViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = pThis->_DataObjectFromItemsOrFolder(psiItemArray, &pdo);
    if (SUCCEEDED(hr))
    {
        hr = SHSimulateDropOnClsid(CLSID_PrintPhotosDropTarget, pThis->_punkSite, pdo);
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_CommonDocumentsSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_COMMONDOCUMENTS, IDS_HEADER_COMMONDOCUMENTS_TT);
const WVTASKITEM c_CommonDocumentsSpecialTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_COMMONDOCUMENTSHELP, IDS_TASK_COMMONDOCUMENTSHELP_TT, IDI_TASK_HELP, NULL, CFSFolderViewCB::_OnCommonDocumentsHelp),
};
const LPCTSTR c_DocumentsOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_MusicSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MUSIC, IDS_HEADER_MUSIC_TT);
const WVTASKITEM c_MusicSpecialTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(UICID_PlayMusic,    L"shell32.dll", IDS_TASK_PLAYALL,          IDS_TASK_PLAYALL,       IDS_TASK_PLAY,          IDS_TASK_PLAY,          IDS_TASK_PLAY_TT,               IDI_TASK_PLAY_MUSIC,    CFSFolderViewCB::_CanPlayMusic,     CFSFolderViewCB::_OnPlayMusic),
    WVTI_ENTRY_ALL(UICID_ShopForMusicOnline, L"shell32.dll", IDS_TASK_SHOPFORMUSICONLINE,                                                                       IDS_TASK_SHOPFORMUSICONLINE_TT, IDI_TASK_BUY_MUSIC,     NULL,                               CFSFolderViewCB::_OnShopForMusicOnline),
    WVTI_ENTRY_ALL_TITLE(GUID_NULL,          L"shell32.dll", IDS_TASK_COPYTOAUDIOCDALL, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD, IDS_TASK_COPYTOAUDIOCD_TT,      IDI_TASK_SENDTOAUDIOCD, CFSFolderViewCB::_CanSendToAudioCD, CFSFolderViewCB::_OnSendToAudioCD),
};
const LPCTSTR c_MusicOtherPlaces[]   = { MAKEINTRESOURCE(CSIDL_MYMUSIC), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyMusicOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_MUSIC), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_PicturesSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_PICTURES, IDS_HEADER_PICTURES_TT);
const WVTASKITEM c_PicturesSpecialTaskList[] =
{
    WVTI_ENTRY_ALL(UICID_GetFromCamera, L"shell32.dll", IDS_TASK_GETFROMCAMERA,                                                                                             IDS_TASK_GETFROMCAMERA_TT,  IDI_TASK_GETFROMCAMERA, CFSFolderViewCB::_HasWiaDevices,    CFSFolderViewCB::_OnGetFromCamera),
    WVTI_ENTRY_ALL(UICID_SlideShow,     L"shell32.dll", IDS_TASK_SLIDESHOW,                                                                                                 IDS_TASK_SLIDESHOW_TT,      IDI_TASK_SLIDESHOW,     CFSFolderViewCB::_HasItems,         CFSFolderViewCB::_OnSlideShow),
    WVTI_ENTRY_ALL(CLSID_NULL,          L"shell32.dll", IDS_TASK_ORDERPRINTS,                                                                                               IDS_TASK_ORDERPRINTS_TT,    IDI_TASK_ORDERPRINTS,   CFSFolderViewCB::_CanOrderPrints,   CFSFolderViewCB::_OnOrderPrints),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_PRINT_PICTURE_FOLDER,  IDS_TASK_PRINT_PICTURE, IDS_TASK_PRINT_PICTURE_FOLDER,  IDS_TASK_PRINT_PICTURES,    IDS_TASK_PRINT_PICTURES_TT, IDI_TASK_PRINTPICTURES, CFSFolderViewCB::_CanPrintPictures, CFSFolderViewCB::_OnPrintPictures),
    WVTI_ENTRY_FILE(UICID_SetAsWallpaper,L"shell32.dll",IDS_TASK_SETASWALLPAPER,                                                                                            IDS_TASK_SETASWALLPAPER_TT, IDI_TASK_SETASWALLPAPER,CFSFolderViewCB::_CanWallpaper,     CFSFolderViewCB::_OnWallpaper),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_COPYTOCDALL,           IDS_TASK_COPYTOCD,      IDS_TASK_COPYTOCD,              IDS_TASK_COPYTOCD,          IDS_TASK_COPYTOCD_TT,       IDI_TASK_SENDTOCD,      CFSFolderViewCB::_CanSendToCD,      CFSFolderViewCB::_OnSendToCD),
    // Note: temporarily using IDI_ORDERPRINTS for the following task:
    WVTI_ENTRY_ALL(UICID_ShopForPicturesOnline, L"shell32.dll", IDS_TASK_SHOPFORPICTURESONLINE,                                                                             IDS_TASK_SHOPFORPICTURESONLINE_TT, IDI_TASK_ORDERPRINTS, CFSFolderViewCB::_CanBuyPictures, CFSFolderViewCB::_OnShopForPicturesOnline),
};
const LPCTSTR c_PicturesOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_MYPICTURES), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyPicturesOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_PICTURES), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

const WVTASKITEM c_VideosSpecialTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_VIDEOS, IDS_HEADER_VIDEOS_TT);
const WVTASKITEM c_VideosSpecialTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_PLAYALL,               IDS_TASK_PLAYALL,       IDS_TASK_PLAY,                  IDS_TASK_PLAY,              IDS_TASK_PLAY_VIDEOS_TT,    IDI_TASK_PLAY_MUSIC,    CFSFolderViewCB::_CanPlayVideos,    CFSFolderViewCB::_OnPlayVideos),
    WVTI_ENTRY_ALL(UICID_GetFromCamera, L"shell32.dll", IDS_TASK_GETFROMCAMERA,                                                                                             IDS_TASK_GETFROMCAMERA_TT,  IDI_TASK_GETFROMCAMERA, CFSFolderViewCB::_HasWiaDevices,    CFSFolderViewCB::_OnGetFromCamera),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL,    L"shell32.dll", IDS_TASK_COPYTOCDALL,           IDS_TASK_COPYTOCD,      IDS_TASK_COPYTOCD,              IDS_TASK_COPYTOCD,          IDS_TASK_COPYTOCD_TT,       IDI_TASK_SENDTOCD,      CFSFolderViewCB::_CanSendToCD,      CFSFolderViewCB::_OnSendToCD)
};
const LPCTSTR c_VideosOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_MYVIDEO), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
const LPCTSTR c_MyVideosOtherPlaces[] = { MAKEINTRESOURCE(CSIDL_COMMON_VIDEO), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };

typedef struct {
    const WVTASKITEM *pwvIntroText;
    const WVTASKITEM *pwvSpecialHeader;
    const WVTASKITEM *pwvSpecialTaskList;
    UINT              cSpecialTaskList;
    const WVTASKITEM *pwvFolderHeader;
    const WVTASKITEM *pwvFolderTaskList;
    UINT              cFolderTaskList;
    const LPCTSTR    *pdwOtherPlacesList;
    UINT              cOtherPlacesList;
    LPCWSTR           pszThemeInfo;
} WVCONTENT_DATA;

#define WVCONTENT_DEFVIEWDEFAULT(op) { NULL, NULL, NULL, 0, NULL, NULL, 0, (op), ARRAYSIZE(op), NULL }
#define WVCONTENT_FOLDER(fh, ft, op) { NULL, NULL, NULL, 0, &(fh), (ft), ARRAYSIZE(ft), (op), ARRAYSIZE(op), NULL }
#define WVCONTENT_SPECIAL(sh, st, op, th) { NULL, &(sh), (st), ARRAYSIZE(st), NULL, NULL, 0, (op), ARRAYSIZE(op), (th) }

const WVCONTENT_DATA c_wvContent[] =
{
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),                                                                                   // FVCBFT_DOCUMENTS
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),                                                                                   // FVCBFT_MYDOCUMENTS
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_PicturesOtherPlaces,      L"picture"),// FVCBFT_PICTURES
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_MyPicturesOtherPlaces,    L"picture"),// FVCBFT_MYPICTURES
    WVCONTENT_SPECIAL(c_PicturesSpecialTaskHeader,          c_PicturesSpecialTaskList,          c_PicturesOtherPlaces,      L"picture"),// FVCBFT_PHOTOALBUM
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSIC
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MyMusicOtherPlaces,       L"music"),  // FVCBFT_MYMUSIC
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSICARTIST
    WVCONTENT_SPECIAL(c_MusicSpecialTaskHeader,             c_MusicSpecialTaskList,             c_MusicOtherPlaces,         L"music"),  // FVCBFT_MUSICALBUM
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_VideosOtherPlaces,        L"video"),  // FVCBFT_VIDEOS
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_MyVideosOtherPlaces,      L"video"),  // FVCBFT_MYVIDEOS
    WVCONTENT_SPECIAL(c_VideosSpecialTaskHeader,            c_VideosSpecialTaskList,            c_VideosOtherPlaces,        L"video"),  // FVCBFT_VIDEOALBUM
    WVCONTENT_DEFVIEWDEFAULT(c_DocumentsOtherPlaces),// stub, it should not be used as legacy htts wont have DUI view.                  // FVCBFT_USELEGACYHTT
    WVCONTENT_SPECIAL(c_CommonDocumentsSpecialTaskHeader,   c_CommonDocumentsSpecialTaskList,   c_DocumentsOtherPlaces,     NULL),      // FVCBFT_COMMONDOCUMENTS
};

// This structure describes what a Folder Type can control:
//
typedef struct {
    BOOL              fIncludeThumbstrip;
    FOLDERVIEWMODE    fvmFew;
    FOLDERVIEWMODE    fvmMid;
    FOLDERVIEWMODE    fvmMany;
    const SHCOLUMNID* pscidSort;
    int               iSortDirection;
} FVCBFOLDERTYPEDATA;

// Here are all the Folder Types we know about:
const FVCBFOLDERTYPEDATA c_rgFolderType[] =
{  // flmstrip  // <25         // 25..49      //50...        //sort by           //sort dir
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_DOCUMENTS
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_MYDOCUMENTS
    { TRUE,     FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_PICTURES
    { TRUE,     FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_MYPICTURES
    { TRUE,     FVM_THUMBSTRIP,FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_PHOTOALBUM
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_DETAILS,   &SCID_NAME,         1},    // FVCBFT_MUSIC
    { FALSE,    FVM_THUMBNAIL, FVM_TILE,      FVM_LIST,      &SCID_NAME,         1},    // FVCBFT_MYMUSIC
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,        -1},    // FVCBFT_MUSICARTIST
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_DETAILS,   &SCID_NAME,         1},    // FVCBFT_MUSICALBUM, SCID_MUSIC_Track is the same as SCID_NAME
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_VIDEOS
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_MYVIDEOS
    { FALSE,    FVM_THUMBNAIL, FVM_THUMBNAIL, FVM_THUMBNAIL, &SCID_NAME,         1},    // FVCBFT_VIDEOALBUM
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_USELEGACYHTT, only for listview state to look like FVCBFT_DOCUMENTS
    { FALSE,    FVM_TILE,      FVM_TILE,      FVM_ICON,      &SCID_NAME,         1},    // FVCBFT_COMMONDOCUMENTS
};

// This is used to sniff the Folder Type based on folder location:
typedef struct {
    UINT           csidl;
    FVCBFOLDERTYPE ft;
    DWORD          dwFlags;
} FVCBDATA;

#define FVCBDF_SUBFOLDERS_ONLY    1
#define FVCBDF_THISFOLDER_ONLY    2

const FVCBDATA c_rgFolderState[] =
{
    {CSIDL_COMMON_PICTURES, FVCBFT_PHOTOALBUM,      FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_MYPICTURES,      FVCBFT_PHOTOALBUM,      FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_COMMON_PICTURES, FVCBFT_PICTURES,        FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYPICTURES,      FVCBFT_MYPICTURES,      FVCBDF_THISFOLDER_ONLY},
    {CSIDL_COMMON_MUSIC,    FVCBFT_MUSIC,           FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYMUSIC,         FVCBFT_MYMUSIC,         FVCBDF_THISFOLDER_ONLY},
    {CSIDL_MYMUSIC,         FVCBFT_MUSICARTIST,     FVCBDF_SUBFOLDERS_ONLY},
    {CSIDL_COMMON_VIDEO,    FVCBFT_VIDEOS,          0},
    {CSIDL_MYVIDEO,         FVCBFT_MYVIDEOS,        0},
    {CSIDL_COMMON_DOCUMENTS,FVCBFT_COMMONDOCUMENTS, FVCBDF_THISFOLDER_ONLY},
    {CSIDL_PERSONAL,        FVCBFT_MYDOCUMENTS,     FVCBDF_THISFOLDER_ONLY},
};

// these are special folders that used to be web view folders.  we override the "support legacy" for this list:
const UINT c_rgFolderStateNoLegacy[] =
{
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_PROGRAM_FILES,
};

// This is used to map desktop.ini's folder type into our Folder Type
const struct {
    LPCWSTR pszType;
    FVCBFOLDERTYPE ft;
} c_rgPropBagFolderType[] =
{
    {STR_TYPE_DOCUMENTS,        FVCBFT_DOCUMENTS},
    {STR_TYPE_MYDOCUMENTS,      FVCBFT_MYDOCUMENTS},
    {STR_TYPE_PICTURES,         FVCBFT_PICTURES},
    {STR_TYPE_MYPICTURES,       FVCBFT_MYPICTURES},
    {STR_TYPE_PHOTOALBUM,       FVCBFT_PHOTOALBUM},
    {STR_TYPE_MUSIC,            FVCBFT_MUSIC},
    {STR_TYPE_MYMUSIC,          FVCBFT_MYMUSIC},
    {STR_TYPE_MUSICARTIST,      FVCBFT_MUSICARTIST},
    {STR_TYPE_MUSICALBUM,       FVCBFT_MUSICALBUM},
    {STR_TYPE_VIDEOS,           FVCBFT_VIDEOS},
    {STR_TYPE_MYVIDEOS,         FVCBFT_MYVIDEOS},
    {STR_TYPE_VIDEOALBUM,       FVCBFT_VIDEOALBUM},
    {STR_TYPE_USELEGACYHTT,     FVCBFT_USELEGACYHTT},
    {STR_TYPE_COMMONDOCUMENTS,  FVCBFT_COMMONDOCUMENTS},
};

const struct 
{
    PERCEIVED gen;
    FVCBFOLDERTYPE ft;
} 
c_rgSniffType[] =
{
    {GEN_AUDIO,    FVCBFT_MUSIC},
    {GEN_IMAGE,    FVCBFT_PHOTOALBUM},
    {GEN_VIDEO,    FVCBFT_VIDEOS},
};

HRESULT _GetFolderTypeForString(LPCWSTR pszFolderType, FVCBFOLDERTYPE *piType)
{
    HRESULT hr = E_FAIL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropBagFolderType); i++)
    {
        if (!StrCmpI(c_rgPropBagFolderType[i].pszType, pszFolderType))
        {
            *piType = c_rgPropBagFolderType[i].ft;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

HRESULT CFSFolderViewCB::_GetStringForFolderType(int iType, LPWSTR pszFolderType, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropBagFolderType); i++)
    {
        if (c_rgPropBagFolderType[i].ft == iType)
        {
            hr = StringCchCopy(pszFolderType, cchBuf, c_rgPropBagFolderType[i].pszType);
            break;
        }
    }
    return hr;
}

extern HRESULT GetTemplateInfoFromHandle(HANDLE h, UCHAR * pKey, DWORD *pdwSize);

FVCBFOLDERTYPE _GetFolderType(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder)
{
    // Assume we don't find a match
    FVCBFOLDERTYPE nFolderType = FVCBFT_NOTSPECIFIED;
    WCHAR szFolderType[MAX_PATH];
    szFolderType[0] = 0;

    // peruser is first
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        IPropertyBag *ppb;
        if (SUCCEEDED(SHGetViewStatePropertyBag(pidl, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            SHPropertyBag_ReadStr(ppb, L"FolderType", szFolderType, ARRAYSIZE(szFolderType));
            if (szFolderType[0])
                _GetFolderTypeForString(szFolderType, &nFolderType);

            ppb->Release();
        }
    }
    
    // next, alluser
    if ((FVCBFT_NOTSPECIFIED == nFolderType) && fIsSystemFolder)
    {
        GetFolderString(pszPath, NULL, szFolderType, ARRAYSIZE(szFolderType), TEXT("FolderType"));
        if (szFolderType[0])
        {
            _GetFolderTypeForString(szFolderType, &nFolderType);
        }
    }

    // Check the location of this folder is next
    //
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        for (int i = 0; i < ARRAYSIZE(c_rgFolderState); i++)
        {
            if (FVCBDF_THISFOLDER_ONLY & c_rgFolderState[i].dwFlags)
            {
                if (PathIsOneOf(pszPath, &(c_rgFolderState[i].csidl), 1))
                {
                    nFolderType = c_rgFolderState[i].ft;
                    break;
                }
            }
            else if (FVCBDF_SUBFOLDERS_ONLY & c_rgFolderState[i].dwFlags)
            {
                if (PathIsDirectChildOf(MAKEINTRESOURCE(c_rgFolderState[i].csidl), pszPath))
                {
                    nFolderType = c_rgFolderState[i].ft;
                    break;
                }
            }
            else if (PathIsEqualOrSubFolder(MAKEINTRESOURCE(c_rgFolderState[i].csidl), pszPath))
            {
                nFolderType = c_rgFolderState[i].ft;
                break;
            }
        }
    }

    // Upgrade old webviews to their DUI equivalents, if we can
    if (FVCBFT_NOTSPECIFIED == nFolderType && fIsSystemFolder && SHRestricted(REST_ALLOWLEGACYWEBVIEW))
    {
        // Don't check for legacy webview on our special folders
        if (!PathIsOneOf(pszPath, c_rgFolderStateNoLegacy, ARRAYSIZE(c_rgFolderStateNoLegacy)))
        {        
            SFVM_WEBVIEW_TEMPLATE_DATA wvData;
            if (SUCCEEDED(DefaultGetWebViewTemplateFromPath(pszPath, &wvData)))
            {
                if (StrStrI(wvData.szWebView, L"ImgView.htt"))
                {
                    nFolderType = FVCBFT_PHOTOALBUM;
                }
                else if (StrStrI(wvData.szWebView, L"classic.htt")  ||
                         StrStrI(wvData.szWebView, L"default.htt")  ||
                         StrStrI(wvData.szWebView, L"standard.htt"))
                {
                    // map all of these to "documents", since DUI should take care
                    // of what the old templates did automatically
                    nFolderType = FVCBFT_DOCUMENTS;
                }
                else if (StrStrI(wvData.szWebView, L"folder.htt"))
                {
                    LPTSTR pszFilePrefix = StrStrI(wvData.szWebView, L"file://");
                    HANDLE hfile = CreateFileWrapW(
                        pszFilePrefix && (&pszFilePrefix[6] < &wvData.szWebView[MAX_PATH - 1]) ? &pszFilePrefix[7] : wvData.szWebView,
                        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
                    if (INVALID_HANDLE_VALUE != hfile)
                    {
                        DWORD dwSize;
                        UCHAR pKey[MD5DIGESTLEN];
                        if (SUCCEEDED(GetTemplateInfoFromHandle(hfile, pKey, &dwSize)))
                        {
                            static const struct {
                                UCHAR pKey[MD5DIGESTLEN];
                                FVCBFOLDERTYPE nFolderType;
                            } c_paLegacyKeyMap[] = {
                                { { 0xf6, 0xad, 0x42, 0xbd, 0xfa, 0x92, 0xb6, 0x61, 0x08, 0x13, 0xd3, 0x71, 0x32, 0x18, 0x85, 0xc7 }, FVCBFT_DOCUMENTS },  // Win98 Gold Program Files
                                { { 0x80, 0xea, 0xcb, 0xc7, 0x85, 0x1e, 0xbb, 0x99, 0x12, 0x7b, 0x9d, 0xc7, 0x80, 0xa6, 0x55, 0x2f }, FVCBFT_DOCUMENTS },  // Win98 Gold System
                              //{ { 0x80, 0xea, 0xcb, 0xc7, 0x85, 0x1e, 0xbb, 0x99, 0x12, 0x7b, 0x9d, 0xc7, 0x80, 0xa6, 0x55, 0x2f }, FVCBFT_DOCUMENTS },  // Win98 Gold Windows
                                { { 0x13, 0x0b, 0xe7, 0xaa, 0x42, 0x6f, 0x9c, 0x2e, 0xab, 0x6b, 0x90, 0x77, 0xce, 0x2d, 0xd1, 0x04 }, FVCBFT_DOCUMENTS },  // Win98 Gold - folder.htt
                              //{ { 0xf6, 0xad, 0x42, 0xbd, 0xfa, 0x92, 0xb6, 0x61, 0x08, 0x13, 0xd3, 0x71, 0x32, 0x18, 0x85, 0xc7 }, FVCBFT_DOCUMENTS },  // Win98 SE Program Files
                                { { 0xc4, 0xab, 0x8f, 0x60, 0xf8, 0xfc, 0x5d, 0x07, 0x9e, 0x16, 0xd8, 0xea, 0x12, 0x2c, 0xad, 0x5c }, FVCBFT_DOCUMENTS },  // Win98 SE System
                              //{ { 0xc4, 0xab, 0x8f, 0x60, 0xf8, 0xfc, 0x5d, 0x07, 0x9e, 0x16, 0xd8, 0xea, 0x12, 0x2c, 0xad, 0x5c }, FVCBFT_DOCUMENTS },  // Win98 SE Windows
                              //{ { 0x13, 0x0b, 0xe7, 0xaa, 0x42, 0x6f, 0x9c, 0x2e, 0xab, 0x6b, 0x90, 0x77, 0xce, 0x2d, 0xd1, 0x04 }, FVCBFT_DOCUMENTS },  // Win98 SE - folder.htt
                                { { 0xef, 0xd0, 0x3e, 0x9e, 0xd8, 0x5e, 0xf3, 0xc5, 0x7e, 0x40, 0xbd, 0x8e, 0x52, 0xbc, 0x9c, 0x67 }, FVCBFT_DOCUMENTS },  // WinME Program Files
                                { { 0x49, 0xdb, 0x25, 0x79, 0x7a, 0x5c, 0xb2, 0x8a, 0xe2, 0x57, 0x59, 0xde, 0x2b, 0xd2, 0xa6, 0x70 }, FVCBFT_DOCUMENTS },  // WinME System
                              //{ { 0x49, 0xdb, 0x25, 0x79, 0x7a, 0x5c, 0xb2, 0x8a, 0xe2, 0x57, 0x59, 0xde, 0x2b, 0xd2, 0xa6, 0x70 }, FVCBFT_DOCUMENTS },  // WinME Windows
                                { { 0x2b, 0xcd, 0xc3, 0x11, 0x72, 0x28, 0x34, 0x46, 0xfa, 0x88, 0x31, 0x34, 0xfc, 0xee, 0x7a, 0x3b }, FVCBFT_DOCUMENTS },  // WinME - classic.htt
                                { { 0x68, 0x20, 0xa0, 0xa1, 0x6c, 0xba, 0xbf, 0x67, 0x80, 0xfe, 0x1e, 0x70, 0xdf, 0xcb, 0xd6, 0x34 }, FVCBFT_DOCUMENTS },  // WinME - folder.htt
                                { { 0x5e, 0x18, 0xaf, 0x48, 0xb1, 0x9f, 0xb8, 0x12, 0x58, 0x64, 0x4a, 0xa2, 0xf5, 0x12, 0x0f, 0x01 }, FVCBFT_PHOTOALBUM }, // WinME - imgview.htt
                                { { 0x33, 0x94, 0x21, 0x3b, 0x17, 0x31, 0x2b, 0xeb, 0xac, 0x93, 0x84, 0x13, 0xb8, 0x1f, 0x95, 0x24 }, FVCBFT_DOCUMENTS },  // WinME - standard.htt
                                { { 0x47, 0x03, 0x19, 0xf8, 0x0c, 0x20, 0xc4, 0x4f, 0x10, 0xfd, 0x63, 0xf1, 0x2d, 0x2d, 0x0a, 0xcb }, FVCBFT_DOCUMENTS },  // WinME - starter.htt
                                { { 0x60, 0x7d, 0xea, 0xa5, 0xaf, 0x5e, 0xbb, 0x9b, 0x10, 0x18, 0xf9, 0x59, 0x9e, 0x43, 0x89, 0x62 }, FVCBFT_DOCUMENTS },  // Win2k Program Files
                                { { 0x1c, 0xa6, 0x22, 0xd4, 0x4a, 0x31, 0x57, 0x93, 0xa7, 0x26, 0x68, 0x3c, 0x87, 0x95, 0x8c, 0xce }, FVCBFT_DOCUMENTS },  // Win2k System32
                              //{ { 0x1c, 0xa6, 0x22, 0xd4, 0x4a, 0x31, 0x57, 0x93, 0xa7, 0x26, 0x68, 0x3c, 0x87, 0x95, 0x8c, 0xce }, FVCBFT_DOCUMENTS },  // Win2k Windows (WinNT)
                                { { 0x03, 0x43, 0x48, 0xed, 0xe4, 0x9f, 0xd6, 0xc0, 0x58, 0xf7, 0x72, 0x3f, 0x1b, 0xd0, 0xa7, 0x10 }, FVCBFT_DOCUMENTS },  // Win2k - classic.htt
                                { { 0xa8, 0x84, 0xf9, 0x37, 0x84, 0x10, 0xde, 0x7c, 0x0b, 0x34, 0x90, 0x37, 0x23, 0x9e, 0x54, 0x35 }, FVCBFT_DOCUMENTS },  // Win2k - folder.htt
                                { { 0x75, 0x1f, 0xcf, 0xca, 0xdd, 0xc7, 0x1d, 0xc7, 0xe1, 0xaf, 0x0c, 0x3e, 0x1e, 0xae, 0x18, 0x51 }, FVCBFT_PHOTOALBUM }, // Win2k - imgview.htt
                                { { 0xcc, 0x3f, 0x15, 0xce, 0x4b, 0xfa, 0x36, 0xdf, 0x9b, 0xd8, 0x24, 0x82, 0x3a, 0x9c, 0x0b, 0xa7 }, FVCBFT_DOCUMENTS },  // Win2k - standard.htt
                                { { 0x6c, 0xd1, 0xbf, 0xcf, 0xf9, 0x24, 0x24, 0x24, 0x22, 0xfa, 0x1a, 0x8d, 0xd2, 0x1a, 0x41, 0x73 }, FVCBFT_DOCUMENTS },  // Win2k - starter.htt
                            };
                            static const size_t c_nLegacyKeys = ARRAYSIZE(c_paLegacyKeyMap);

                            for (size_t i = 0; i < c_nLegacyKeys; i++)
                            {
                                if (0 == memcmp(pKey, c_paLegacyKeyMap[i].pKey, sizeof(UCHAR) * MD5DIGESTLEN))
                                {
                                    // It's a known legacy folder.htt.
                                    nFolderType = c_paLegacyKeyMap[i].nFolderType;
                                    break;
                                }
                            }
                        }

                        CloseHandle(hfile);
                    }

                    // If we can't say it's a known legacy folder.htt...
                    if (FVCBFT_NOTSPECIFIED == nFolderType)
                    {
                        // ...don't map it to a DUI folder type (preserve customizations).
                        nFolderType = FVCBFT_USELEGACYHTT;
                    }
                }
                else
                {
                    nFolderType = FVCBFT_USELEGACYHTT;
                }
            }
        }
    }

    return nFolderType;
}

BOOL CFSFolderViewCB::_IsBarricadedFolder()
{
    BOOL bResult = FALSE;
    TCHAR szPath[MAX_PATH];

    if (SUCCEEDED(_pfsf->_GetPath(szPath, ARRAYSIZE(szPath))))
    {
        const UINT uiFolders[] = {CSIDL_PROGRAM_FILES, CSIDL_WINDOWS, CSIDL_SYSTEM};
        if (PathIsOneOf(szPath, uiFolders, ARRAYSIZE(uiFolders)))
            bResult = TRUE;
        else
        {
            TCHAR szSystemDrive[4];
            ExpandEnvironmentStrings(TEXT("%SystemDrive%\\"), szSystemDrive, ARRAYSIZE(szSystemDrive));
            if (!lstrcmpi(szPath, szSystemDrive))
                bResult = TRUE;
        }
    }

    return bResult;
}

static const struct { FVCBFOLDERTYPE type; PCWSTR pszClass; PERCEIVED gen;} c_rgDirectoryClasses[] = 
{
    {FVCBFT_PICTURES,    L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_MYPICTURES,  L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_PHOTOALBUM,  L"Directory.Image",    GEN_IMAGE},
    {FVCBFT_MUSIC,       L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MYMUSIC,     L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MUSICARTIST, L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_MUSICALBUM,  L"Directory.Audio",    GEN_AUDIO},
    {FVCBFT_VIDEOS,      L"Directory.Video",    GEN_VIDEO},
    {FVCBFT_MYVIDEOS,    L"Directory.Video",    GEN_VIDEO},
    {FVCBFT_VIDEOALBUM,  L"Directory.Video",    GEN_VIDEO},
};

LPCWSTR _GetDirectoryClass(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder)
{
    FVCBFOLDERTYPE type = _GetFolderType(pszPath, pidl, fIsSystemFolder);
    if (type != FVCBFT_NOTSPECIFIED)
    {
        for (int i = 0; i < ARRAYSIZE(c_rgDirectoryClasses); i++)
        {
            if (c_rgDirectoryClasses[i].type == type)
                return c_rgDirectoryClasses[i].pszClass;
        }
    }
    return NULL;
}

PERCEIVED CFSFolderViewCB::_GetFolderPerceivedType(LPCIDFOLDER pidf)
{
    PERCEIVED gen = GEN_FOLDER;
    WCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_pfsf->_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath))))
    {
        LPITEMIDLIST pidl = ILCombine(_pfsf->_GetIDList(), (LPCITEMIDLIST)pidf);
        if (pidl)
        {
            FVCBFOLDERTYPE type = _GetFolderType(szPath, pidl, CFSFolder::_IsSystemFolder(pidf));
            if (type != -1)
            {
                for (int i = 0; i < ARRAYSIZE(c_rgDirectoryClasses); i++)
                {
                    if (c_rgDirectoryClasses[i].type == type)
                    {
                        gen = c_rgDirectoryClasses[i].gen;
                        break;
                    }
                }
            }
            ILFree(pidl);
        }
    }
    return gen;
}


HRESULT CFSFolderViewCB::OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST* rgpidl)
{
    // Remember the count of items
    _cItems = celt;

    FVCBFOLDERTYPE nFolderType = FVCBFT_NOTSPECIFIED;
    WCHAR szHere[MAX_PATH];
    if (SUCCEEDED(_pfsf->_GetPath(szHere, ARRAYSIZE(szHere))))
    {
        nFolderType = _GetFolderType(szHere, _pfsf->_GetIDList(), _pfsf->_CheckDefaultIni(NULL, NULL, 0));
    }

    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        if (_IsBarricadedFolder())
        {
            nFolderType = FVCBFT_DOCUMENTS;
        }
    }

    // Our location didn't do the trick, so look at the enumerated contents
    if (FVCBFT_NOTSPECIFIED == nFolderType && celt > 0)
    {
        DWORD dwExtCount[ARRAYSIZE(c_rgSniffType)] = {0};

        // look at each pidl -> what type is it
        //
        // But don't look at too many pidls or we really slow down folder
        // creation time.  If we can't figure it out in the first 100, give up.
        //
        DWORD dwTotalCount = 0;
        for (UINT n = 0; n < celt && dwTotalCount < 100; n++)
        {
            LPCIDFOLDER pidf = CFSFolder_IsValidID(rgpidl[n]);
            ASSERT(pidf);
            CFileSysItemString fsi(pidf);
            PERCEIVED gen = fsi.PerceivedType();

            if (gen == GEN_FOLDER)
            {
                gen = _GetFolderPerceivedType(pidf);
            }
                
            for (int i = 0; i < ARRAYSIZE(c_rgSniffType); i++)
            {
                if (c_rgSniffType[i].gen == gen)
                {
                    dwExtCount[i]++;
                    break;
                }
            }

            if (gen != GEN_FOLDER)
                dwTotalCount++;
        }

        // if we found files we determine the overall folder type
        if (dwTotalCount > 0)
        {
            DWORD dwSixtyPercent = MulDiv(dwTotalCount, 3, 5);
            for (int i = 0; i < ARRAYSIZE(c_rgSniffType); i++)
            {
                if (dwExtCount[i] >= dwSixtyPercent)
                {
                    nFolderType = c_rgSniffType[i].ft;
                    break;
                }
            }
        }
    }

    // if at this point we've already decided on a folder type, then it either came from sniffing
    // or the folder location and we can safely persist that out.
    // if celt != 0 then we've sniffed it and we dont want to sniff again, so persist that out.
    // otherwise we're in a random folder with 0 elements and we'll sniff it next time.
    BOOL fCommit = (FVCBFT_NOTSPECIFIED != nFolderType) || (celt != 0);

    // Last resort, assume we're a document folder:
    if (FVCBFT_NOTSPECIFIED == nFolderType)
    {
        nFolderType = FVCBFT_DOCUMENTS;
    }

    // store what we found out back into the bag.
    IPropertyBag *ppb;
    if (fCommit && SUCCEEDED(SHGetViewStatePropertyBag(_pfsf->_GetIDList(), VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        WCHAR szFolderType[MAX_PATH];
        if (SUCCEEDED(_GetStringForFolderType(nFolderType, szFolderType, ARRAYSIZE(szFolderType))))
        {
            SHPropertyBag_WriteStr(ppb, PROPSTR_FOLDERTYPE, szFolderType);
        }
        ppb->Release();
    }

    _pfsf->_nFolderType = nFolderType;

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetViewData(DWORD pv, UINT uViewMode, SFVM_VIEW_DATA* pvi)
{
    // Normally whatever defview wants is good for us
    pvi->dwOptions = SFVMQVI_NORMAL;

    // If our sniff type likes THUMBSTRIP, then override defview
    //
    if (FVM_THUMBSTRIP == uViewMode)
    {
        if (c_rgFolderType[_pfsf->_nFolderType].fIncludeThumbstrip)
        {
            pvi->dwOptions = SFVMQVI_INCLUDE;
        }
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    HRESULT hr = E_FAIL;

    if (FVCBFT_USELEGACYHTT == _pfsf->_nFolderType)
    {
        TCHAR szHere[MAX_PATH];
        if (SUCCEEDED(_pfsf->_GetPath(szHere, ARRAYSIZE(szHere))) && _pfsf->_CheckDefaultIni(NULL, NULL, 0))
        {
            hr = DefaultGetWebViewTemplateFromPath(szHere, pvit);
        }
    }
    return hr;
}

// Note: defview provides this implementation, this is only for testing
// so the WIA guys can override defview's behavior (and as a way for us
// to force DUI in the presence of HTML content)
//
HRESULT CFSFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    HRESULT hr = E_FAIL;

    if (FVCBFT_USELEGACYHTT != _pfsf->_nFolderType)
    {
        ZeroMemory(pData, sizeof(*pData));

        pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;

        if (FVM_THUMBSTRIP == uViewMode)
        {        
            pData->dwLayout = SFVMWVL_PREVIEW | SFVMWVL_FILES;
            // duiview will do a release on this pointer when the control is destroyed
            _GetPreview3((IPreview3 **)&pData->punkPreview);
        }

        // RAID 242382
        //  If we have an image folder, we want to unconditionally hide DefView's
        //  default "Print this file" folder task since we will supply a context
        //  appropriate "Print pictures" special task.
        //
        // RAID 359567
        //  If we have a music folder, we want to unconditionally hide DefView's
        //  default "Publish this file" folder task.  Not sure the rationale
        //  behind this, but perhaps they don't want us to be seen as a Napster.
        //
        // Note:
        //  This is a HACK added for Whistler, which should be removed in Blackcomb.
        //
        switch (_pfsf->_nFolderType)
        {
        case FVCBFT_PICTURES:
        case FVCBFT_MYPICTURES:
        case FVCBFT_PHOTOALBUM:
        case FVCBFT_VIDEOS:
        case FVCBFT_MYVIDEOS:
        case FVCBFT_VIDEOALBUM:
            pData->dwLayout |= SFVMWVL_NOPRINT;
            break;

        case FVCBFT_MUSIC:
        case FVCBFT_MYMUSIC:
        case FVCBFT_MUSICARTIST:
        case FVCBFT_MUSICALBUM:
            pData->dwLayout |= SFVMWVL_NOPUBLISH;
            break;
        }

        hr = S_OK;
    }

    return hr;
}


HRESULT CFSFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    // Check if the folder we are currently over is one of the blockaded folders.
    if (_IsBarricadedFolder())
    {
        pData->dwFlags = SFVMWVF_BARRICADE;
    }

    if (c_wvContent[_pfsf->_nFolderType].pwvIntroText)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvIntroText, &(pData->pIntroText));

    if (c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader && c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader, &(pData->pSpecialTaskHeader));

    if (c_wvContent[_pfsf->_nFolderType].pwvFolderHeader && c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList)
        Create_IUIElement(c_wvContent[_pfsf->_nFolderType].pwvFolderHeader, &(pData->pFolderTaskHeader));

    if (c_wvContent[_pfsf->_nFolderType].pdwOtherPlacesList)
        CreateIEnumIDListOnCSIDLs(_pfsf->_pidl, (LPCTSTR *)c_wvContent[_pfsf->_nFolderType].pdwOtherPlacesList, c_wvContent[_pfsf->_nFolderType].cOtherPlacesList, &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    if (c_wvContent[_pfsf->_nFolderType].pwvSpecialHeader && c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList)
    {
        Create_IEnumUICommand((IUnknown*)(void*)this, c_wvContent[_pfsf->_nFolderType].pwvSpecialTaskList, c_wvContent[_pfsf->_nFolderType].cSpecialTaskList, &pTasks->penumSpecialTasks);
    }

    if (c_wvContent[_pfsf->_nFolderType].pwvFolderHeader && c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList)
    {
        Create_IEnumUICommand((IUnknown*)(void*)this, c_wvContent[_pfsf->_nFolderType].pwvFolderTaskList, c_wvContent[_pfsf->_nFolderType].cFolderTaskList, &pTasks->penumFolderTasks);
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetWebViewTheme(DWORD pv, SFVM_WEBVIEW_THEME_DATA* pTheme)
{
    ZeroMemory(pTheme, sizeof(*pTheme));

    pTheme->pszThemeID = c_wvContent[_pfsf->_nFolderType].pszThemeInfo;
    
    return S_OK;
}

HRESULT CFSFolderViewCB::OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pfvm)
{
    HRESULT hr = E_FAIL;

    IPropertyBag* pPB;
    if (SUCCEEDED(SHGetViewStatePropertyBag(_pfsf->_GetIDList(), VS_BAGSTR_EXPLORER, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &pPB))))
    {
        SHELLVIEWID vidDefault;
        if (SUCCEEDED(SHPropertyBag_ReadGUID(pPB, L"ExtShellFolderViews\\Default", &vidDefault)))
        {
            hr = ViewModeFromSVID(&vidDefault, pfvm);
        }
        pPB->Release();
    }

    if (FAILED(hr))
    {
        if (IsOS(OS_SERVERADMINUI))
            *pfvm = FVM_DETAILS;    // Server Admin always gets DETAILS
        else if (_cItems < DEFVIEW_FVM_FEW_CUTOFF)
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmFew;
        else if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmMid;
        else
            *pfvm = c_rgFolderType[_pfsf->_nFolderType].fvmMany;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolderViewCB::OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings)
{
    HRESULT hr = OnDefViewMode(pv, &pSettings->fvm);
    if (SUCCEEDED(hr))
    {
        pSettings->fGroupView     = (_cItems >= 100) && !IsEqualSCID(SCID_NAME, *c_rgFolderType[_pfsf->_nFolderType].pscidSort);
        pSettings->iSortDirection = c_rgFolderType[_pfsf->_nFolderType].iSortDirection;

        if (pSettings->fvm == FVM_THUMBNAIL || pSettings->fvm == FVM_THUMBSTRIP || pSettings->fvm == FVM_TILE)
            pSettings->fFlags = FWF_AUTOARRANGE;

        if (FAILED(_pfsf->_MapSCIDToColumn(c_rgFolderType[_pfsf->_nFolderType].pscidSort, &pSettings->uSortCol)))
            pSettings->uSortCol = 0;
    }

    return hr;
}


HRESULT CFSFolderViewCB::OnGetCustomViewInfo(DWORD pv, SFVM_CUSTOMVIEWINFO_DATA* pData)
{
    HRESULT hr = E_FAIL;

    TCHAR szIniFile[MAX_PATH];
    if (_pfsf->_CheckDefaultIni(NULL, szIniFile, ARRAYSIZE(szIniFile)))
    {
        if (PathFileExistsAndAttributes(szIniFile, NULL))
        {
            // Read the custom colors
            //
            const LPCTSTR c_szCustomColors[CRID_COLORCOUNT] =
            {
                TEXT("IconArea_TextBackground"),
                TEXT("IconArea_Text")
            };
            for (int i = 0; i < CRID_COLORCOUNT; i++)
            {
                pData->crCustomColors[i] = GetPrivateProfileInt(TEXT("{BE098140-A513-11D0-A3A4-00C04FD706EC}"), c_szCustomColors[i], CLR_MYINVALID, szIniFile);
            }

            // Read the background image
            TCHAR szTemp1[MAX_PATH];
            if (0 < GetPrivateProfileString(TEXT("{BE098140-A513-11D0-A3A4-00C04FD706EC}") /* VID_FolderState */, TEXT("IconArea_Image"), TEXT(""), szTemp1, ARRAYSIZE(szTemp1), szIniFile))
            {
                TCHAR szTemp2[MAX_PATH];
                SHExpandEnvironmentStrings(szTemp1, szTemp2, ARRAYSIZE(szTemp2)); // expand the env vars if any

                if (SUCCEEDED(_pfsf->_GetPath(szTemp1, ARRAYSIZE(szTemp1))))
                {
                    if (PathCombine(szTemp2, szTemp1, szTemp2))
                    {
                        if (FAILED(StringCchCopy(pData->szIconAreaImage, ARRAYSIZE(pData->szIconAreaImage), szTemp2)))
                        {
                            pData->szIconAreaImage[0] = NULL;
                        }
                    }
                }
            }

            // Success if we have any real data
            hr = (*(pData->szIconAreaImage) ||
                  pData->crCustomColors[0]!=CLR_MYINVALID ||
                  pData->crCustomColors[1]!=CLR_MYINVALID)
                 ? S_OK : E_FAIL;
        }
    }

    return hr;
}


const CLSID *c_rgFilePages[] = {
    &CLSID_FileTypes,
    &CLSID_OfflineFilesOptions
};

// add optional pages to Explore/Options.

HRESULT SFVCB_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA *ppagedata)
{
    for (int i = 0; i < ARRAYSIZE(c_rgFilePages); i++)
    {
        IShellPropSheetExt * pspse;

        HRESULT hr = SHCoCreateInstance(NULL, c_rgFilePages[i], NULL, IID_PPV_ARG(IShellPropSheetExt, &pspse));
        if (SUCCEEDED(hr))
        {
            pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
            pspse->Release();
        }
    }

    return S_OK;
}

HRESULT CFSFolderViewCB::OnGetNotify(DWORD pv, LPITEMIDLIST*wP, LONG*lP) 
{
    if (IsExplorerModeBrowser(_punkSite))
        _lEvents |= SHCNE_FREESPACE; // need free space info here too

    return E_FAIL;  // return failure to let base guy do the rest
}

STDMETHODIMP CFSFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(1 , SFVM_INSERTITEM, OnInsertDeleteItem);
    HANDLE_MSG(-1, SFVM_DELETEITEM, OnInsertDeleteItem);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_REFRESH, OnRefresh);
    HANDLE_MSG(0, SFVM_SELECTALL, OnSelectAll);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_GETVIEWDATA, OnGetViewData);
    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTHEME, OnGetWebViewTheme);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETCUSTOMVIEWINFO, OnGetCustomViewInfo);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETNOTIFY, OnGetNotify);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnGetDeferredViewSettings);

    default:
        return E_FAIL;
    }

    return S_OK;
}


STDAPI CFSFolderCallback_Create(CFSFolder *pfsf, IShellFolderViewCB **ppsfvcb)
{
    *ppsfvcb = new CFSFolderViewCB(pfsf);
    return *ppsfvcb ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftaction.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ftadv.h"
#include "ftcmmn.h"
#include "ftaction.h"
#include "ftassoc.h"

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_FT_CMD_ACTION,         IDH_FCAB_FT_CMD_ACTION,
    IDC_FT_CMD_EXETEXT,        IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_EXE,            IDH_FCAB_FT_CMD_EXE,
    IDC_FT_CMD_BROWSE,         IDH_FCAB_FT_CMD_BROWSE,
    IDC_FT_CMD_DDEGROUP,       IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_USEDDE,         IDH_FCAB_FT_CMD_USEDDE,
    IDC_FT_CMD_DDEMSG,         IDH_FCAB_FT_CMD_DDEMSG,
    IDC_FT_CMD_DDEAPP,         IDH_FCAB_FT_CMD_DDEAPP,
    IDC_FT_CMD_DDEAPPNOT,      IDH_FCAB_FT_CMD_DDEAPPNOT,
    IDC_FT_CMD_DDETOPIC,       IDH_FCAB_FT_CMD_DDETOPIC,
    0, 0
};

CFTActionDlg::CFTActionDlg(PROGIDACTION* pProgIDAction, LPTSTR pszProgIDDescr,
                BOOL fEdit) :
                CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray), 
                _pProgIDAction(pProgIDAction), _pszProgIDDescr(pszProgIDDescr),
                _fEdit(fEdit)
{
}

CFTActionDlg::~CFTActionDlg()
{
}

///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTActionDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    DECLAREWAITCURSOR;

    SetWaitCursor();

    if (_fEdit || _fShowAgain)
    {
        TCHAR szTitle[50 + MAX_PROGIDDESCR + 5];
        TCHAR szTitleTemplate[50];

        _fShowAgain = FALSE;

        if (LoadString(g_hinst, IDS_FT_EDITTITLE, szTitleTemplate, ARRAYSIZE(szTitleTemplate)))
        {
            StringCchPrintf(szTitle, ARRAYSIZE(szTitle), szTitleTemplate, _pszProgIDDescr);
            SetWindowText(_hwnd, szTitle);
        }

        SetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, _pProgIDAction->szAction);
        SetDlgItemText(_hwnd, IDC_FT_CMD_EXE, _pProgIDAction->szCmdLine);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEMSG, _pProgIDAction->szDDEMsg);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPP, _pProgIDAction->szDDEApplication);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPPNOT, _pProgIDAction->szDDEAppNotRunning);
        SetDlgItemText(_hwnd, IDC_FT_CMD_DDETOPIC, _pProgIDAction->szDDETopic);

        CheckDlgButton(_hwnd, IDC_FT_CMD_USEDDE, _pProgIDAction->fUseDDE);
        _ResizeDlgForDDE(_pProgIDAction->fUseDDE);
    }
    else
    {
        CheckDlgButton(_hwnd, IDC_FT_CMD_USEDDE, FALSE);
        _ResizeDlgForDDE(FALSE);
    }

    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_ACTION), MAX_ACTION - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_EXE), MAX_ACTIONCMDLINE - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEMSG), MAX_ACTIONDDEMSG - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPP), MAX_ACTIONAPPL - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPPNOT), MAX_ACTIONDDEAPPNOTRUN - 1);
    Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_CMD_DDETOPIC), MAX_ACTIONTOPIC - 1);

    ResetWaitCursor();

    // Return TRUE so that system set focus
    return TRUE;
}

BOOL CFTActionDlg::_Validate()
{
    BOOL bRet = TRUE;

    // Check the Action
    TCHAR szAction[MAX_ACTION];

    if (!GetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, szAction, ARRAYSIZE(szAction)) ||
        !*szAction)
    {
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_NOACTION), 
            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0, 
            (LPARAM)GetDlgItem(_hwnd, IDC_FT_CMD_ACTION));

        bRet = FALSE;
    }

    if (bRet)
    {
        TCHAR szPath[MAX_PATH];
        LPTSTR pszFileName = NULL;
    
        // Check for valid exe
        GetDlgItemText(_hwnd, IDC_FT_CMD_EXE, szPath, ARRAYSIZE(szPath));
        PathRemoveArgs(szPath);
        PathUnquoteSpaces(szPath);

        pszFileName = PathFindFileName(szPath);

        if(!(*szPath) ||
            !(PathIsExe(szPath)) ||
            ((!(PathFileExists(szPath))) && (!(PathFindOnPath(pszFileName, NULL)))))
        {
            // Tell user that this exe is invalid
            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_EXETEXT),
                MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

            PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
                (LPARAM)GetDlgItem(_hwnd, IDC_FT_CMD_EXE));

            bRet = FALSE;
        }
    }

    return bRet;
}

void CFTActionDlg::SetShowAgain()
{
    _fShowAgain = TRUE;
}

BOOL _IsThereAnyPercentArgument(LPTSTR pszCommand)
{
    BOOL fRet = FALSE;
    LPTSTR pszArgs = PathGetArgs(pszCommand);

    if (pszArgs && *pszArgs)
    {
        if (StrStr(pszArgs, TEXT("%")))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

LRESULT CFTActionDlg::OnOK(WORD wNotif)
{
    if (_Validate())
    {
        GetDlgItemText(_hwnd, IDC_FT_CMD_ACTION, _pProgIDAction->szAction, MAX_ACTION);

        // Is this a new action?
        if (!_fEdit)
        {
            // Yes, initialize the old action field
            StringCchCopy(_pProgIDAction->szOldAction, ARRAYSIZE(_pProgIDAction->szOldAction), _pProgIDAction->szAction);

            // Build the ActionReg
            StringCchCopy(_pProgIDAction->szActionReg, ARRAYSIZE(_pProgIDAction->szActionReg), _pProgIDAction->szAction);

            // Replace spaces with underscores
            LPTSTR psz = _pProgIDAction->szActionReg;
    
            while (*psz)
            {
                if (TEXT(' ') == *psz)
                {
                    *psz = TEXT('_');
                }

                psz = CharNext(psz);
            }

            StringCchCopy(_pProgIDAction->szOldActionReg, ARRAYSIZE(_pProgIDAction->szOldActionReg), 
                _pProgIDAction->szActionReg);
        }

        GetDlgItemText(_hwnd, IDC_FT_CMD_EXE, _pProgIDAction->szCmdLine, MAX_ACTIONCMDLINE);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEMSG, _pProgIDAction->szDDEMsg, MAX_ACTIONDDEMSG);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPP, _pProgIDAction->szDDEApplication, MAX_ACTIONAPPL);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDEAPPNOT, _pProgIDAction->szDDEAppNotRunning, MAX_ACTIONDDEAPPNOTRUN);
        GetDlgItemText(_hwnd, IDC_FT_CMD_DDETOPIC, _pProgIDAction->szDDETopic, MAX_ACTIONTOPIC);

        _pProgIDAction->fUseDDE = IsDlgButtonChecked(_hwnd, IDC_FT_CMD_USEDDE);

        // Append %1 to action field, if required
        if (!_IsThereAnyPercentArgument(_pProgIDAction->szCmdLine))
        {
            TCHAR* pszPercentToAppend;

            if (StrChr(_pProgIDAction->szCmdLine,TEXT('\\')))
            {
                if (App_IsLFNAware(_pProgIDAction->szCmdLine))
                    pszPercentToAppend = TEXT(" \"%1\"");
                else
                    pszPercentToAppend = TEXT(" %1");
            }
            else
            {
                TCHAR szFullPathFileName[MAX_PATH];
                //
                StringCchCopy(szFullPathFileName, ARRAYSIZE(szFullPathFileName), _pProgIDAction->szCmdLine);
                //PathFindOnPath: first param is the filename, if it is on the path
                //  then it returns fully qualified, if not return false.
                //Second param is optional directory to look in first
                if (PathFindOnPath(szFullPathFileName, NULL))
                {
                    if (App_IsLFNAware(szFullPathFileName))
                        pszPercentToAppend = TEXT(" \"%1\"");
                    else
                        pszPercentToAppend = TEXT(" %1");
                }
                else
                {//just in case, default to good old behavior.  Should not come here because
                    // ActionExeIsValid was done earlier
                    pszPercentToAppend = TEXT(" %1");
                }
            }
            //append...
            StringCchCat(_pProgIDAction->szCmdLine, ARRAYSIZE(_pProgIDAction->szCmdLine), pszPercentToAppend);
        }

        EndDialog(_hwnd, IDOK);
    }
    
    return FALSE;
}

LRESULT CFTActionDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

LRESULT CFTActionDlg::OnUseDDE(WORD wNotif)
{
    _ResizeDlgForDDE(IsDlgButtonChecked(_hwnd, IDC_FT_CMD_USEDDE));

    return FALSE;
}

LRESULT CFTActionDlg::OnBrowse(WORD wNotif)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szTitle[40];
    TCHAR szEXE[MAX_PATH];
    TCHAR szFilters[MAX_PATH];
    LPTSTR psz;
    
    szPath[0] = 0;
    
    EVAL(LoadString(g_hinst, IDS_CAP_OPENAS, szTitle, ARRAYSIZE(szTitle)));
    EVAL(LoadString(g_hinst, IDS_FT_EXE, szEXE, ARRAYSIZE(szEXE)));
    
    // And we need to convert #'s to \0's...
    EVAL(LoadString(g_hinst, IDS_PROGRAMSFILTER, szFilters, ARRAYSIZE(szFilters)));

    psz = szFilters;
    while (*psz)
    {
        if (*psz == TEXT('#'))
        {
            LPTSTR pszT = psz;
            psz = CharNext(psz);
            *pszT = TEXT('\0');
        }
        else
            psz = CharNext(psz);
    }
    
    if (GetFileNameFromBrowse(_hwnd, szPath, ARRAYSIZE(szPath), NULL, szEXE, szFilters, szTitle))
    {
        PathQuoteSpaces(szPath);
        SetDlgItemText(_hwnd, IDC_FT_CMD_EXE, szPath);
    }
    
    return FALSE;
}

void CFTActionDlg::_ResizeDlgForDDE(BOOL fShow)
{
    RECT rcDialog;
    RECT rcControl;
    
    GetWindowRect(_hwnd, &rcDialog);
    
    if(fShow)
        GetWindowRect(GetDlgItem(_hwnd, IDC_FT_CMD_DDEGROUP), &rcControl);
    else
        GetWindowRect(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE), &rcControl);
    
    // Hide/Show the windows to take care of the Tabbing.  If we don't hide them then
    // we tab through the "visible" window outside of the dialog.

    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEMSG), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPP), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEAPPNOT), fShow);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDETOPIC), fShow);

    ShowWindow(GetDlgItem(_hwnd, IDC_FT_CMD_DDEGROUP), fShow);
    SetWindowPos(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE), HWND_TOPMOST, 
        0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
    
    MoveWindow(_hwnd, rcDialog.left, rcDialog.top, rcDialog.right - rcDialog.left,
        (rcControl.bottom - rcDialog.top) + 10, TRUE);
    
    SetFocus(GetDlgItem(_hwnd, IDC_FT_CMD_USEDDE));
}

LRESULT CFTActionDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTActionDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_CMD_USEDDE:
            // Resize Dialog to see/hide DDE controls
            lRes = OnUseDDE(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_CMD_BROWSE:
            lRes = OnBrowse(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftascstr.h ===
#ifndef FTASCSTR_H
#define FTASCSTR_H

#include "ascstr.h"

class CFTAssocStore : public IAssocStore
{
public:
    CFTAssocStore();
    ~CFTAssocStore();
public:
	//IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
	STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	//IAssocStore methods
    //	Enum
    STDMETHOD(EnumAssocInfo)(ASENUM asenumFlags, LPTSTR pszStr, 
		AIINIT aiinitFlags, IEnumAssocInfo** ppEnum);
    //  Get/Set
    STDMETHOD(GetAssocInfo)(LPTSTR pszStr, AIINIT aiinitFlags, 
		IAssocInfo** ppAI);
    STDMETHOD(GetComplexAssocInfo)(LPTSTR pszStr1, AIINIT aiinitFlags1, 
		LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI);

    // S_OK: We have create/delete access,
    // S_FALSE: we do not have create and/or delete access to HKCR
    STDMETHOD(CheckAccess)();

private:
	friend class CFTEnumAssocInfo;
	static HRESULT __GetProgIDDescr(LPTSTR pszProgID, LPTSTR pszProgIDdescr,
		                    DWORD cchProgIDdescr);
private:
    HRESULT                _hresCoInit;
    LONG                   _cRef;
    static HRESULT         _hresAccess;
};

#endif //FTASCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftassoc.cpp ===
#include "shellprv.h"
#include "filetype.h"

#include "ftascstr.h" //for now, until CoCreateInstance
#include "ftassoc.h"
#include "fassoc.h"

HIMAGELIST CFTAssocInfo::_himlSysSmall = NULL;
HIMAGELIST CFTAssocInfo::_himlSysLarge = NULL;

CFTAssocInfo::CFTAssocInfo() : _cRef(1)
{
}

HRESULT CFTAssocInfo::Init(AIINIT aiinitFlags, LPTSTR pszStr)
{
    HRESULT hres = E_INVALIDARG;

    _aiinitFlags1 = aiinitFlags;
    *_szInitStr2 = 0;
    _aiinitFlags2 = AIINIT_NONE;

    if (!pszStr && (AIINIT_PROGID == aiinitFlags))
    {
        // This happens when we create a new ProgID
        hres = S_OK;
    }
    else
    {
        if (pszStr && *pszStr && (AIINIT_NONE != aiinitFlags))
        {
            if ((AIINIT_EXT == aiinitFlags) && (TEXT('.') != *pszStr))
            {
                *_szInitStr1 = TEXT('.');
                StrCpyN(_szInitStr1 + 1, pszStr, ARRAYSIZE(_szInitStr1) - 1);
            }
            else
                StrCpyN(_szInitStr1, pszStr, ARRAYSIZE(_szInitStr1));

            hres = S_OK;
        }
    }

    // set the info for the registry support
    RSInitRoot(HKEY_CLASSES_ROOT, _szInitStr1, NULL, REG_OPTION_NON_VOLATILE, 
        REG_OPTION_NON_VOLATILE);

    return hres;
}

HRESULT CFTAssocInfo::InitComplex(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2)
{
    HRESULT hres = E_INVALIDARG;

    if ((pszStr1 && *pszStr1 && (AIINIT_NONE != aiinitFlags1)) &&
        (pszStr2 && *pszStr2&& (AIINIT_NONE != aiinitFlags2)))
    {
        TCHAR szSubKey[MAX_PROGID + 7 + MAX_ACTION];

        StrCpyN(_szInitStr1, pszStr1, ARRAYSIZE(_szInitStr1));
        _aiinitFlags1 = aiinitFlags1;
        StrCpyN(_szInitStr2, pszStr2, ARRAYSIZE(_szInitStr2));
        _aiinitFlags2 = aiinitFlags2;

        // set the info for the registry support
        StrCpyN(szSubKey, _szInitStr1, MAX_PROGID);
        StringCchCat(szSubKey, ARRAYSIZE(szSubKey), TEXT("\\shell"));

        RSInitRoot(HKEY_CLASSES_ROOT, szSubKey, _szInitStr2, REG_OPTION_NON_VOLATILE, 
            REG_OPTION_NON_VOLATILE);

        hres = S_OK;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetString(AISTR aistrFlags, LPTSTR pszStr, DWORD* pcchStr)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_APPFRIENDLY:
                    hres = _GetOpenWithInfo(pszStr, pcchStr);
                    break;

                case AISTR_EXT:
                    StrCpyN(pszStr, _szInitStr1 + 1, *pcchStr);
                    hres = S_OK;
                    break;

                case AISTR_DOTEXT:
                    StrCpyN(pszStr, _szInitStr1, *pcchStr);
                    hres = S_OK;
                    break;

                case AISTR_PROGID:
                    hres = (RSGetTextValue(NULL, NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
                    break;

		        // We fall back to using the progid for the AISTR_XXX's below
		        case AISTR_ICONLOCATION:
                case AISTR_PROGIDDESCR:
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);
                    IAssocInfo* pAI = NULL;
                    CFTAssocStore* pAssocStore = new CFTAssocStore();
                    if ( !pAssocStore )
                    {
                        hres = E_OUTOFMEMORY;
                        break;
                    }

                    hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                    if (SUCCEEDED(hres))
                    {
                        hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                        pAI->Release();

                        if (SUCCEEDED(hres))
                        {
                            hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                            if (SUCCEEDED(hres))
                            {
                                hres = pAI->GetString(aistrFlags, pszStr, pcchStr);

                                pAI->Release();
                            }
                        }
                    }

                    delete pAssocStore;

                    break;
                }

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aistrFlags)
                {
                    case AISTR_PROGIDDEFAULTACTION:
                        hres = _GetProgIDDefaultAction(pszStr, pcchStr);
                        break;

                    case AISTR_ICONLOCATION:
                        hres = _GetIconLocation(pszStr, pcchStr);
                        break;

                    case AISTR_PROGID:
                        StrCpyN(pszStr, _szInitStr1, *pcchStr);
                        hres = S_OK;
                        break;

                    case AISTR_PROGIDDESCR:
                        hres = _GetProgIDDescr(pszStr, pcchStr);
                        break;

                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                if (AIINIT_ACTION == _aiinitFlags2)
                {
                    switch (aistrFlags)
                    {
                        case AISTR_ACTION:
                        {
                            StrCpyN(pszStr, _szInitStr2, *pcchStr);
                            hres = S_OK;
                            break;
                        }
                        case AISTR_ACTIONFRIENDLY:
                        {
                            if (RSGetTextValue(NULL, NULL, pszStr, pcchStr))
                            {
                                if (*pszStr)
                                {
                                    hres = S_OK;
                                }
                                else
                                {
                                    hres = S_FALSE;
                                }
                            }
                            else
                            {
                                hres = S_FALSE;
                            }
                            break;
                        }
                    }
                }
                else
                    hres = E_INVALIDARG;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetDWORD(AIDWORD aidwordFlags, DWORD* pdwData)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aidwordFlags)
            {
                case AIDWORD_DOCSMALLICON:
                case AIDWORD_DOCLARGEICON:
                {
                    hres = _GetExtDocIcon(_szInitStr1, 
                        (AIDWORD_DOCSMALLICON == aidwordFlags), (int*)pdwData);

                    if (FAILED(hres))
                    {
                        TCHAR szProgID[MAX_PROGID];
                        DWORD cchProgID = ARRAYSIZE(szProgID);
                        IAssocInfo* pAI = NULL;
                        CFTAssocStore* pAssocStore = new CFTAssocStore();

                        if (pAssocStore)
                        {
                            hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                            if (SUCCEEDED(hres))
                            {
                                hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                                pAI->Release();

                                if (SUCCEEDED(hres))
                                {
                                    hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                                    if (SUCCEEDED(hres))
                                    {
                                        hres = pAI->GetDWORD(aidwordFlags, pdwData);

                                        pAI->Release();
                                    }
                                }
                            }

                            delete pAssocStore;
                        }
                    }
                    break;
                }

                case AIDWORD_DOCSMALLICON | AIALL_PERUSER:
                case AIDWORD_APPSMALLICON:
                    hres = _GetAppIcon(TRUE, (int*)pdwData);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aidwordFlags)
                {
                    case AIDWORD_PROGIDEDITFLAGS:
                        hres = _GetProgIDEditFlags(pdwData);
                        break;
                    case AIDWORD_DOCSMALLICON:
                    case AIDWORD_DOCLARGEICON:
                        hres = _GetProgIDDocIcon((AIDWORD_DOCSMALLICON == aidwordFlags), 
                            (int*)pdwData);
                        break;
                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                hres = E_INVALIDARG;

                if (AIINIT_ACTION == _aiinitFlags2)
                    if (AIDWORD_ACTIONATTRIBUTES == aidwordFlags)
                        hres = _GetProgIDActionAttributes(pdwData);
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;    
}

HRESULT CFTAssocInfo::GetData(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData)
{
    HRESULT hres = E_INVALIDARG;

    if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2) &&
        (AIDATA_PROGIDACTION == aidataFlags))
    {
        LPTSTR pszProgID = _szInitStr1;
        PROGIDACTION* pPIDA = (PROGIDACTION*)pbData;
        LPTSTR pszActionReg = _szInitStr2;
        DWORD cchStr = 0;

        pPIDA->fUseDDE = FALSE;

        StrCpyN(pPIDA->szActionReg, pszActionReg, ARRAYSIZE(pPIDA->szActionReg));
        StrCpyN(pPIDA->szOldActionReg, pszActionReg, ARRAYSIZE(pPIDA->szOldActionReg));

        cchStr = ARRAYSIZE(pPIDA->szAction);

        if (!RSGetTextValue(NULL, NULL, pPIDA->szAction, &cchStr))
        {
            // By default the friendly name will be the same as the reg key name
            StrCpyN(pPIDA->szAction, pszActionReg, ARRAYSIZE(pPIDA->szAction));
        }

        StrCpyN(pPIDA->szOldAction, pPIDA->szAction, ARRAYSIZE(pPIDA->szOldAction));

        cchStr = ARRAYSIZE(pPIDA->szCmdLine);

        hres = AssocQueryString(0, ASSOCSTR_COMMAND, pszProgID, pszActionReg,
            pPIDA->szCmdLine, &cchStr);

        if (SUCCEEDED(hres))
        {
            HRESULT hresTmp = E_FAIL;

            cchStr = ARRAYSIZE(pPIDA->szDDEMsg);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDECOMMAND, pszProgID, pszActionReg,
                pPIDA->szDDEMsg, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDEApplication);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDEAPPLICATION, pszProgID, pszActionReg,
                pPIDA->szDDEApplication, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDEAppNotRunning);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDEIFEXEC, pszProgID, pszActionReg,
                pPIDA->szDDEAppNotRunning, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;

            cchStr = ARRAYSIZE(pPIDA->szDDETopic);
            hresTmp = AssocQueryString(0, ASSOCSTR_DDETOPIC, pszProgID, pszActionReg,
                pPIDA->szDDETopic, &cchStr);

            if (SUCCEEDED(hresTmp))
                pPIDA->fUseDDE = TRUE;
        }
    }
    return hres;    
}

HRESULT CFTAssocInfo::SetData(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData)
{
    HRESULT hres = E_INVALIDARG;

    if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2) &&
        (AIDATA_PROGIDACTION == aidataFlags))
    {
        HKEY hProgIDKey = NULL;
        LONG lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1, 0,  KEY_WRITE, &hProgIDKey);

        hres = E_FAIL;

        // <ProgID>
        //  |_ shell
        //      |_ <action>
        //          |  (Default): Fr&iendly name (value) (optional) (no UI to set it)
        //          |  "EditFlags": 0x000.... (value) (optional) (no UI to set it)
        //          |_ Command
        //          |    (Default): e.g. c:\winnt\system32\notepad.exe "%1"
        //          |_ ddeexec
        //               |  (Default): DDE msg
        //               |_ Application
        //               |    (Default): Application
        //               |_ IfExec
        //               |    (Default): ifexec
        //               |_ Topic
        //                    (Default): topic
        if (ERROR_SUCCESS == lRes)
        {
            HKEY hShellKey = NULL;
            HKEY hActionKey = NULL;
            HKEY hCommandKey = NULL;
            HKEY hDDEKey = NULL;
            DWORD dwKey = 0;
            PROGIDACTION* pPIDA = (PROGIDACTION*)pbData;

            lRes = RegCreateKeyEx(hProgIDKey, TEXT("shell"), 0, NULL,
                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hShellKey, &dwKey);

            RegCloseKey(hProgIDKey);

            if (ERROR_SUCCESS == lRes)
            {
                lRes = RegCreateKeyEx(hShellKey, _szInitStr2, 0, NULL,
                    REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hActionKey, &dwKey);

                RegCloseKey(hShellKey);
            }

            if (ERROR_SUCCESS == lRes)
            {
                // Set the friendly name, if different
                if (lstrcmp(pPIDA->szAction, pPIDA->szActionReg))
                {
                    lRes = RegSetValueEx(hActionKey, NULL, NULL, REG_SZ, (PBYTE)pPIDA->szAction,
                        lstrlen(pPIDA->szAction) * sizeof(TCHAR));
                }

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = RegCreateKeyEx(hActionKey, TEXT("command"), 0, NULL,
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hCommandKey, &dwKey);
                }
            }

            if (ERROR_SUCCESS == lRes)
            {
                int iLen = lstrlen(pPIDA->szCmdLine);

                lRes = RegSetValueEx(hCommandKey, NULL, 0, REG_SZ, (PBYTE)(pPIDA->szCmdLine),
                            iLen * sizeof(TCHAR));
            }

            if (ERROR_SUCCESS == lRes)
            {
                if (pPIDA->fUseDDE)
                {
                    lRes = RegCreateKeyEx(hActionKey, TEXT("ddeexec"), 0, NULL,
                        REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hDDEKey, &dwKey);

                    if (ERROR_SUCCESS == lRes)
                    {
                        HKEY hTmpKey = NULL;
                        int iLen = 0;

                        hres = S_OK;

                        if (*(pPIDA->szDDEMsg))
                        {
                            iLen = lstrlen(pPIDA->szDDEMsg);

                            lRes = RegSetValueEx(hDDEKey, NULL, 0, REG_SZ, (PBYTE)(pPIDA->szDDEMsg),
                                        iLen * sizeof(TCHAR));

                            if (ERROR_SUCCESS != lRes)
                                hres = E_FAIL;
                        }
                        if (*(pPIDA->szDDEApplication))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("Application"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDEApplication);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ, 
                                    (PBYTE)(pPIDA->szDDEApplication), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                        if (*(pPIDA->szDDEAppNotRunning))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("IfExec"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDEAppNotRunning);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ, 
                                    (PBYTE)(pPIDA->szDDEAppNotRunning), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                        if (*(pPIDA->szDDETopic))
                        {
                            lRes = RegCreateKeyEx(hDDEKey, TEXT("Topic"), 0, NULL,
                                REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hTmpKey, &dwKey);
                            
                            if (ERROR_SUCCESS == lRes)
                            {
                                iLen = lstrlen(pPIDA->szDDETopic);

                                lRes = RegSetValueEx(hTmpKey, NULL, 0, REG_SZ,
                                    (PBYTE)(pPIDA->szDDETopic), iLen * sizeof(TCHAR));

                                if (ERROR_SUCCESS != lRes)
                                    hres = E_FAIL;

                                RegCloseKey(hTmpKey);
                            }
                        }
                    }
                }
            }

            if (hActionKey)
                RegCloseKey(hActionKey);

            if (hCommandKey)
                RegCloseKey(hCommandKey);

            if (hDDEKey)
                RegCloseKey(hDDEKey);
        }
    }
    return hres;    
}

HRESULT CFTAssocInfo::SetDWORD(AIDWORD aidwordFlags, DWORD dwData)
{
    return E_NOTIMPL;
}

HRESULT CFTAssocInfo::SetString(AISTR aistrFlags, LPTSTR pszStr)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_PROGID:
        {
            if (AIINIT_NONE == _aiinitFlags2)
            {
                switch(aistrFlags)
                {
                    case AISTR_PROGIDDEFAULTACTION:
                        hres = _SetProgIDDefaultAction(pszStr);
                        break;

                    case AISTR_PROGIDDESCR:
                        hres = (RSSetTextValue(NULL, NULL, pszStr) ? S_OK : E_FAIL);
                        break;

                    case AISTR_ICONLOCATION:
                        hres = _SetIconLocation(pszStr);
                        break;

                    default:
                        hres = E_INVALIDARG;
                        break;
                }
            }
            else
            {
                hres = E_INVALIDARG;
            }
            break;
        }
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_PROGID:
                    hres = (RSSetTextValue(NULL, NULL,pszStr) ? S_OK : E_FAIL);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::GetBOOL(AIBOOL aiboolFlags, BOOL* pfBool)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_EXTEXIST:
                {
                    HKEY hKey = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
                        0, KEY_READ, &hKey))
                    {
                        *pfBool = TRUE;
                        RegCloseKey(hKey);
                    }
                    else
                        *pfBool = FALSE;

                    hres = S_OK;

                    break;
                }
                case AIBOOL_EXTASSOCIATED:
                    hres = _ExtIsAssociated(pfBool);
                    break;

                case AIBOOL_PERUSERINFOAVAILABLE:
                {
                    IQueryAssociations *pQA;
                    WCHAR szwExt[MAX_EXT];

                    SHTCharToUnicode(_szInitStr1, szwExt, ARRAYSIZE(szwExt));

                    // This need to return FALSE on failure
                    *pfBool = FALSE;

                    if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&pQA)))
                    {
                        pQA->Init(0, szwExt, NULL, NULL);

                        if (pQA->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL) == S_OK)
                            *pfBool = TRUE;

                        pQA->Release();

                        hres = S_OK;
                    }

                    break;
                }

                case AIBOOL_EXCLUDE:
                {
                    CFTAssocStore* pAssocStore = new CFTAssocStore();

                    if (pAssocStore)
                    {
                        IAssocInfo* pAI = NULL;

                        hres = pAssocStore->GetAssocInfo(_szInitStr1, AIINIT_EXT, &pAI);

                        if (SUCCEEDED(hres))
                        {
                            TCHAR szProgID[MAX_PROGID];
                            DWORD cchProgID = ARRAYSIZE(szProgID);

                            hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                            pAI->Release();

                            if (SUCCEEDED(hres))
                            {
                                hres = pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAI);

                                if (SUCCEEDED(hres))
                                {
                                    hres = pAI->GetBOOL(aiboolFlags, pfBool);

                                    pAI->Release();
                                }
                            }
                        }

                        delete pAssocStore;
                    }

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        case AIINIT_PROGID:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_CONFIRMOPEN:
                case AIBOOL_EDITDESCR:
                case AIBOOL_EDITDOCICON:
                case AIBOOL_EDIT:
                case AIBOOL_EDITREMOVE:
                case AIBOOL_EXCLUDE:
                case AIBOOL_SHOW:
                case AIBOOL_PROGIDHASNOEXT:
                {
                    hres = _IsEditFlagSet(aiboolFlags, pfBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACE:
                {
                    hres = _IsBrowseInPlace(pfBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACEENABLED:
                {
                    hres = _IsBrowseInPlaceEnabled(pfBool);
                    break;
                }
                case AIBOOL_ALWAYSSHOWEXT:
                {
                    *pfBool = RSValueExist(NULL, TEXT("AlwaysShowExt"));
                    hres = S_OK;
                        
                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::SetBOOL(AIBOOL aiboolFlags, BOOL fBool)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_PROGID:
        {
            switch(aiboolFlags)
            {
                case AIBOOL_CONFIRMOPEN:
                {
                    hres = _SetEditFlagSet(aiboolFlags, fBool);
                    break;
                }
                case AIBOOL_BROWSEINPLACE:
                {
                    hres = _SetBrowseInPlace(fBool);
                    break;
                }
                case AIBOOL_ALWAYSSHOWEXT:
                {
                    if (fBool)
                    {
                        RSDeleteValue(NULL, TEXT("NeverShowExt"));
                        hres = (RSSetTextValue(NULL, TEXT("AlwaysShowExt"), TEXT("")) ? S_OK : E_FAIL);
                    }
                    else
                        hres = (RSDeleteValue(NULL, TEXT("AlwaysShowExt")) ? S_OK : E_FAIL);

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::Create()
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            HKEY hKey = NULL;
            DWORD dwKey = 0;
            
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
                0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hKey, &dwKey))
            {
                RegCloseKey(hKey);
                hres = S_OK;
            }

            break;
        }
        case AIINIT_PROGID:
        {
            hres = _CreateProgID();
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;    
}

HRESULT CFTAssocInfo::DelString(AISTR aistrFlags)
{
    HRESULT hres = E_FAIL;

    switch(_aiinitFlags1)
    {
        case AIINIT_EXT:
        {
            switch(aistrFlags)
            {
                case AISTR_PROGID:
                {
                    hres = (RSDeleteValue(NULL, NULL) ? S_OK : E_FAIL);

                    break;
                }
                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }
    return hres;
}

HRESULT CFTAssocInfo::Delete(AIALL aiallFlags)
{
    HRESULT hres = E_INVALIDARG;

    switch (aiallFlags)
    {
        case AIALL_NONE:
        {
            LONG lRes = -1;

            if ((AIINIT_PROGID == _aiinitFlags1) && (AIINIT_ACTION == _aiinitFlags2))
            {
                TCHAR szProgIDShell[MAX_PROGID + 1 + 5 + 1];
                HKEY hProgIDKey = NULL;

                StrCpyN(szProgIDShell, _szInitStr1, ARRAYSIZE(szProgIDShell));
                StringCchCat(szProgIDShell, ARRAYSIZE(szProgIDShell), TEXT("\\shell"));

                lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, szProgIDShell, 0, KEY_ALL_ACCESS,
                                &hProgIDKey);

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = SHDeleteKey(hProgIDKey, _szInitStr2);
                    RegCloseKey(hProgIDKey);
                }
            }
            else
            {
                if (AIINIT_EXT == _aiinitFlags1)
                    lRes = SHDeleteKey(HKEY_CLASSES_ROOT, _szInitStr1);
            }

            hres = (ERROR_SUCCESS == lRes) ? S_OK : E_FAIL;
            break;
        }
        case AIALL_PERUSER:
        {
            if (AIINIT_EXT == _aiinitFlags1)
            {
                UserAssocSet(UASET_CLEAR, _szInitStr1, NULL);

                hres = S_OK;
            }
            else
            {
                hres = E_NOTIMPL;
            }

            break;
        }
    }

    return hres;
}

HRESULT CFTAssocInfo::_CreateProgID()
{
    HRESULT hres = E_FAIL;
    LRESULT lRes = -1;
    DWORD dwKey = REG_OPENED_EXISTING_KEY;
    int i = 1;

    do
    {
        HKEY hKey = NULL;
        
        wnsprintf(_szInitStr1, ARRAYSIZE(_szInitStr1), TEXT("ft%06d"), i);

        lRes = RegCreateKeyEx(HKEY_CLASSES_ROOT, _szInitStr1,
            0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hKey, &dwKey);

        if (ERROR_SUCCESS == lRes)
            RegCloseKey(hKey);

        ++i;
    }
    while((ERROR_SUCCESS == lRes) && (REG_OPENED_EXISTING_KEY == dwKey));

    if (REG_OPENED_EXISTING_KEY != dwKey)
        hres = S_OK;

    return hres;
}

HRESULT CFTAssocInfo::_SetIconLocation(LPTSTR pszStr)
{
    HKEY hProgIDKey = NULL;
    LONG lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, _szInitStr1, 0,  KEY_WRITE, &hProgIDKey);

    // ProgID
    //  |_ DefaultIcon
    //      |_ (Default) "path\filename.ext, index"
    //
    if (ERROR_SUCCESS == lRes)
    {
        HKEY hDefaultIconKey = NULL;
        DWORD dwKey = NULL;

        lRes = RegCreateKeyEx(hProgIDKey, TEXT("DefaultIcon"), 0, NULL,
          REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL, &hDefaultIconKey, &dwKey);

        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegSetValueEx(hDefaultIconKey, NULL, 0, REG_SZ, (PBYTE)pszStr,
                lstrlen(pszStr) * sizeof(TCHAR));

            RegCloseKey(hDefaultIconKey);
        }
        RegCloseKey(hProgIDKey);
    }

    return ((ERROR_SUCCESS == lRes) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetProgIDDefaultAction(LPTSTR pszStr, DWORD* pcchStr)
{
    return (RSGetTextValue(TEXT("shell"), NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_SetProgIDDefaultAction(LPTSTR pszStr)
{
    return (RSSetTextValue(TEXT("shell"), NULL, pszStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_IsBrowseInPlaceEnabled(BOOL* pfBool)
{
    HRESULT hres = (RSSubKeyExist(TEXT("DocObject")) ? S_OK : E_FAIL);

    if (SUCCEEDED(hres))
        *pfBool = TRUE;
    else
        *pfBool = FALSE;

    if (FAILED(hres))
        hres = S_FALSE;

    return hres;
}

HRESULT CFTAssocInfo::_IsBrowseInPlace(BOOL* pfBool)
{
    HRESULT hres = E_FAIL;
    LPTSTR pszProgID = _szInitStr1;
    
    ASSERT(_aiinitFlags1 == AIINIT_PROGID);

    *pfBool = FALSE;

    if (RSSubKeyExist(TEXT("DocObject")))
    {
        DWORD dwValue;

        hres = (RSGetDWORDValue(NULL, TEXT("BrowserFlags"), &dwValue) ? S_OK : E_FAIL);

        if (SUCCEEDED(hres))
        {
            *pfBool = IsFlagClear(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
        }
        else
        {
            *pfBool = TRUE;
        }
    }   

    if (FAILED(hres))
        hres = S_FALSE;

    return hres;
}

HRESULT CFTAssocInfo::_SetBrowseInPlace(BOOL fBool)
{
    DWORD dwValue;
    DWORD cbSize = sizeof(dwValue);
    LPTSTR pszProgID = _szInitStr1;

    if (RSGetDWORDValue(NULL, TEXT("BrowserFlags"), &dwValue))
    {
        // Watch out: Inverse of fBool
        if (fBool)
            ClearFlag(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
        else
            SetFlag(dwValue, BROWSEHACK_DONTINPLACENAVIGATE);
    }   
    else
    {
        dwValue = fBool ? 0 : BROWSEHACK_DONTINPLACENAVIGATE;
    }
    
    if (dwValue)
    {
        RSSetDWORDValue(NULL, TEXT("BrowserFlags"), dwValue);
    }
    else
    {
        RSDeleteValue(NULL, TEXT("BrowserFlags"));
    }

    return S_OK;
}

HRESULT CFTAssocInfo::_IsEditFlagSet(DWORD dwMask, BOOL* pfBool)
{
    DWORD dwEditFlags = 0;
    LPTSTR pszProgID = _szInitStr1;

    HRESULT hres = _GetProgIDEditFlags(&dwEditFlags);

    if (FAILED(hres))
    {
        hres = S_FALSE;

        // let's put a default value
        dwEditFlags = 0;
    }

    switch(dwMask)
    {
        case AIBOOL_CONFIRMOPEN:
            *pfBool = IsFlagSet(dwEditFlags, FTA_OpenIsSafe);
            break;
        case AIBOOL_EDITDESCR:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEditDesc));
            break;
        case AIBOOL_EDITDOCICON:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEditIcon));
            break;
        case AIBOOL_EDIT:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoEdit));
            break;
        case AIBOOL_EDITREMOVE:
            *pfBool = !(IsFlagSet(dwEditFlags, FTA_NoRemove));
            break;
        case AIBOOL_EXCLUDE:
            *pfBool = IsFlagSet(dwEditFlags, FTA_Exclude);
            break;
        case AIBOOL_SHOW:
            *pfBool = IsFlagSet(dwEditFlags, FTA_Show);
            break;
        case AIBOOL_PROGIDHASNOEXT:
            *pfBool = !IsFlagSet(dwEditFlags, FTA_HasExtension);
            break;
    }

    return hres;
}

HRESULT CFTAssocInfo::_SetEditFlagSet(DWORD dwMask, BOOL fBool)
{
    DWORD dwEditFlags = 0;
    DWORD dwToSet = 0;

    HRESULT hres = _GetProgIDEditFlags(&dwEditFlags);

    if (FAILED(hres))
        dwEditFlags = 0;

    switch(dwMask)
    {
        case AIBOOL_CONFIRMOPEN:
            dwToSet = FTA_OpenIsSafe;
            hres = S_OK;
            break;

        default:
            hres = E_FAIL;
            break;
    }

    if (SUCCEEDED(hres))
    {
        if (fBool)
            SetFlag(dwEditFlags, dwToSet);
        else
            ClearFlag(dwEditFlags, dwToSet);

        if (!RSSetDWORDValue(NULL, TEXT("EditFlags"), dwEditFlags))
        {
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDActionAttributes(DWORD* pdwAttributes)
{
    DWORD dwSize = sizeof(*pdwAttributes);
    HRESULT hres = E_FAIL;
    
    // Was there an EditFlags key?
    if (RSGetDWORDValue(NULL, TEXT("EditFlags"), pdwAttributes))
    {
        // Yes
        hres = S_OK;
    }
    else
    {
        // No default to attributes = 0
        *pdwAttributes = 0;
        hres = S_FALSE;
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDEditFlags(DWORD* pdwEditFlags)
{
    DWORD dwSize = sizeof(*pdwEditFlags);
    LPTSTR pszProgID = _szInitStr1;

    return (RSGetDWORDValue(NULL, TEXT("EditFlags"), pdwEditFlags) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetIconLocation(LPTSTR pszStr, DWORD* pcchStr)
{
    return (RSGetTextValue(TEXT("DefaultIcon"), NULL, pszStr, pcchStr) ? S_OK : E_FAIL);
}

HRESULT CFTAssocInfo::_GetOpenWithInfo(LPTSTR pszStr, DWORD* pcchStr)
{
    int iRet = -1;
    LPTSTR pszExt = _szInitStr1;

    IQueryAssociations* pQA = NULL;
    HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                            (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwExt[MAX_EXT];

        SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

        hres = pQA->Init(0, szwExt, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwAppFriendlyName[MAX_APPFRIENDLYNAME];
            DWORD cchAFName = ARRAYSIZE(szwAppFriendlyName);
            TCHAR szAppl[MAX_PATH];
    
            HRESULT hresFriendlyName = pQA->GetString(ASSOCF_VERIFY | ASSOCF_OPEN_BYEXENAME,
                ASSOCSTR_FRIENDLYAPPNAME, NULL, szwAppFriendlyName, &cchAFName);

            // Did we get a friendly name?
            if (SUCCEEDED(hresFriendlyName))
            {
                // Yes, use it
                SHUnicodeToTChar(szwAppFriendlyName, pszStr, *pcchStr);
            }

            // Reuse szwAppFriendlyName
            hres = pQA->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL,
                szwAppFriendlyName, &cchAFName);

            if (SUCCEEDED(hres))
            {
                SHUnicodeToTChar(szwAppFriendlyName, szAppl, ARRAYSIZE(szAppl));

                if (FAILED(hresFriendlyName))
                {
                    // We failed to get a friendly name, use the EXE name
                    StrCpyN(pszStr, szAppl, *pcchStr);
                }
            }
        }
        pQA->Release();
    }

    if (FAILED(hres))
        *(pszStr) = 0;
    
    return hres;
}

HRESULT CFTAssocInfo::_GetAppIcon(BOOL fSmall, int* piIcon)
{
    LPTSTR pszExt = _szInitStr1;

    IQueryAssociations* pQA = NULL;
    HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                            (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwExt[MAX_EXT];

        SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

        hres = pQA->Init(0, szwExt, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwExecutable[MAX_PATH];
            DWORD cchExecutable = ARRAYSIZE(szwExecutable);
    
            hres = pQA->GetString(ASSOCF_VERIFY,
                ASSOCSTR_EXECUTABLE, NULL, szwExecutable, &cchExecutable);

            if (SUCCEEDED(hres))
            {
                HIMAGELIST himl = fSmall ? _himlSysSmall : _himlSysLarge;
                int iImage = -1;
                TCHAR szExe[MAX_PATH];

                SHUnicodeToTChar(szwExecutable, szExe, ARRAYSIZE(szExe));

                SHFILEINFO sfi = {0};
                UINT uFlags = SHGFI_USEFILEATTRIBUTES;

                uFlags |= (fSmall ? (SHGFI_SMALLICON|SHGFI_ICON) : SHGFI_ICON);

                if (SHGetFileInfo(szExe, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), uFlags))
                {
                    *piIcon = sfi.iIcon;
                    DestroyIcon(sfi.hIcon);                

                    hres = S_OK;
                }
            }
        }
        pQA->Release();
    }

    return hres;
}

HRESULT CFTAssocInfo::_ExtIsAssociated(BOOL* pfIsAssociated)
{
    TCHAR szProgID[MAX_PROGID];
    DWORD cchProgID = ARRAYSIZE(szProgID);
    LPTSTR pszExt = _szInitStr1;

    if (RSGetTextValue(NULL, NULL, szProgID, &cchProgID) && szProgID[0])
    {
        *pfIsAssociated = TRUE;
    }
    else
    {
        *pfIsAssociated = FALSE;
    }

    return S_OK;
}

HRESULT CFTAssocInfo::_GetExtDocIcon(LPTSTR pszExt, BOOL fSmall, int* piIcon)
{
    HRESULT hres = E_FAIL;
    SHFILEINFO sfi = {0};

    ASSERT(TEXT('.') == *pszExt);

    UINT uFlags = SHGFI_USEFILEATTRIBUTES;

    uFlags |= (fSmall ? (SHGFI_SMALLICON|SHGFI_ICON) : SHGFI_ICON);

    if (SHGetFileInfo(pszExt, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(SHFILEINFO), uFlags))
    {
        *piIcon = sfi.iIcon;
        DestroyIcon(sfi.hIcon);                

        hres = S_OK;
    }

    return hres;
}

HRESULT CFTAssocInfo::_GetProgIDDocIcon(BOOL fSmall, int* piIcon)
{
    HRESULT hres = E_FAIL;
    SHFILEINFO sfi = {0};
    LPTSTR pszProgID = _szInitStr1;
    HIMAGELIST himl = fSmall ? _himlSysSmall : _himlSysLarge;
    BOOL fHasNoExtension = FALSE;

    // Try the extension(s) first, unless this is a progID without extension

    IEnumAssocInfo* pEnum = NULL;

    if (AIINIT_PROGID == _aiinitFlags1)
        GetBOOL(AIBOOL_PROGIDHASNOEXT, &fHasNoExtension);

    if (!fHasNoExtension)
    {
        CFTAssocStore* pAssocStore = new CFTAssocStore();

        if (pAssocStore)
        {
            hres = pAssocStore->EnumAssocInfo(ASENUM_EXT, pszProgID, AIINIT_PROGID, &pEnum);

            delete pAssocStore;
        }

        if (SUCCEEDED(hres))
        {
            IAssocInfo* pAI = NULL;

            hres = E_FAIL;

            while (FAILED(hres) && (S_OK == pEnum->Next(&pAI)))
            {
                TCHAR szExt[MAX_EXT];
                DWORD cchExt = ARRAYSIZE(szExt);

                hres = pAI->GetString(AISTR_DOTEXT, szExt, &cchExt);

                if (SUCCEEDED(hres))
                    hres = _GetExtDocIcon(szExt, fSmall, piIcon);

                pAI->Release();
            }

            pEnum->Release();
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes get it from the progID "DefaultIcon" key, if any
        hres = E_FAIL;
        TCHAR szDefaultIcon[MAX_ICONLOCATION];
        DWORD cchDefaultIcon = ARRAYSIZE(szDefaultIcon);

        __InitImageLists();

        if (RSGetTextValue(TEXT("DefaultIcon"), NULL, szDefaultIcon, &cchDefaultIcon) &&
            szDefaultIcon[0])
        {
            int iIndex = PathParseIconLocation(szDefaultIcon);

            *piIcon = Shell_GetCachedImageIndex(szDefaultIcon, iIndex, 0);

            hres = ((-1 == *piIcon) ? E_FAIL : S_OK);
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes, get simulated doc icon if from exe name
        IQueryAssociations* pQA = NULL;
        hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
                                (LPVOID*)&pQA);

        if (SUCCEEDED(hres))
        {
            WCHAR szwProgID[MAX_PROGID];

            SHTCharToUnicode(pszProgID, szwProgID, ARRAYSIZE(szwProgID));

            hres = pQA->Init(0, szwProgID, NULL, NULL);

            if (SUCCEEDED(hres))
            {
                TCHAR szExeName[MAX_PATH];
                WCHAR szwExeName[MAX_PATH];
                DWORD dwExeName = ARRAYSIZE(szwExeName);
                
                hres = pQA->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL,
                    szwExeName, &dwExeName);

                if (SUCCEEDED(hres))
                {
                    int iImage = 0;

                    SHUnicodeToTChar(szwExeName, szExeName, ARRAYSIZE(szExeName));

                    *piIcon = Shell_GetCachedImageIndex(szExeName, 0, GIL_SIMULATEDOC);
                }
            }

            pQA->Release();
        }
    }

    // Did it fail?
    if (FAILED(hres))
    {
        // Yes, get the shell's default icon
        *piIcon = II_DOCNOASSOC;

        hres = S_OK;
    }

    return hres;
}

//static
HRESULT CFTAssocInfo::_GetProgIDDescr(LPTSTR pszProgIDDescr, DWORD* pcchProgIDdescr)
{
    HRESULT hres = E_FAIL;

    IQueryAssociations* pQA = NULL;
    hres = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations,
        (LPVOID*)&pQA);

    if (SUCCEEDED(hres))
    {
        WCHAR szwProgID[MAX_PROGID];

        SHTCharToUnicode(_szInitStr1, szwProgID, ARRAYSIZE(szwProgID));

        hres = pQA->Init(0, szwProgID, NULL, NULL);

        if (SUCCEEDED(hres))
        {
            WCHAR szwProgIDDescr[MAX_PROGIDDESCR];
            // Prepare progID description
            // Reuse szwProgID
            hres = pQA->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, szwProgIDDescr,
                (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szwProgIDDescr)));

            if (SUCCEEDED(hres))
                SHUnicodeToTChar(szwProgIDDescr, pszProgIDDescr, *pcchProgIDdescr);
        }
        pQA->Release();
    }

    return hres;
}

HRESULT CFTAssocInfo::__InitImageLists()
{
    if (!_himlSysLarge ||!_himlSysSmall)
        Shell_GetImageLists(&_himlSysLarge, &_himlSysSmall);

    return S_OK;
}

//IUnknown methods
HRESULT CFTAssocInfo::QueryInterface(REFIID riid, PVOID* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown*>(this);
    else
        *ppv = static_cast<IAssocInfo*>(this);

    return S_OK;
}

ULONG CFTAssocInfo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTAssocInfo::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftassoc.h ===
#ifndef FTASSOC_H
#define FTASSOC_H

#include "ascstr.h"
#include "regsprtb.h"

class CFTAssocInfo : public IAssocInfo, private CRegSupportBuf
{
public:
    CFTAssocInfo();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IAssocInfo methods
    //  Init
    STDMETHOD(Init)(AIINIT aiinitFlags, LPTSTR pszStr);
    STDMETHOD(InitComplex)(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2);
    //  Get
    STDMETHOD(GetString)(AISTR aistrFlags, LPTSTR pszStr, DWORD* cchStr);
    STDMETHOD(GetDWORD)(AIDWORD aidwordFlags, DWORD* pdwdata);
    STDMETHOD(GetBOOL)(AIDWORD aidwordFlags, BOOL* pBool);
    STDMETHOD(GetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData);

    //  Set
    STDMETHOD(SetString)(AISTR aistrFlags, LPTSTR pszStr);
    STDMETHOD(SetDWORD)(AIDWORD aidwordFlags, DWORD dwData);
    STDMETHOD(SetBOOL)(AIDWORD aiboolFlags, BOOL fBool);
    STDMETHOD(SetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData);

    //  Create
    STDMETHOD(Create)();

    //  Delete
    STDMETHOD(DelString)(AISTR aistrFlags);
    STDMETHOD(Delete)(AIALL aiallFlags);

protected:
    HRESULT _IsBrowseInPlace(BOOL* pfBool);
    HRESULT _SetBrowseInPlace(BOOL fBool);
    HRESULT _IsBrowseInPlaceEnabled(BOOL* pfBool);

    HRESULT _IsEditFlagSet(DWORD dwMask, BOOL* pfBool);
    HRESULT _SetEditFlagSet(DWORD dwMask, BOOL fBool);

    HRESULT _CreateProgID();
    HRESULT _GetProgIDActionAttributes(DWORD* pdwAttributes);
    HRESULT _GetProgIDEditFlags(DWORD* pdwEditFlags);
    HRESULT _GetOpenWithInfo(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _ExtIsAssociated(BOOL* pfIsAssociated);
    HRESULT _GetExtDocIcon(LPTSTR pszExt, BOOL fSmall, int* piIcon);
    HRESULT _GetProgIDDocIcon(BOOL fSmall, int* piIcon);
    HRESULT _GetAppIcon(BOOL fSmall, int* piIcon);
    HRESULT _GetIconLocation(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _SetIconLocation(LPTSTR pszStr);

    HRESULT _GetProgIDDefaultAction(LPTSTR pszStr, DWORD* pcchStr);
    HRESULT _SetProgIDDefaultAction(LPTSTR pszStr);

    HRESULT _GetProgIDDescr(LPTSTR pszProgIDDescr, DWORD* pcchProgIDdescr);

    HRESULT __InitImageLists();

protected:
    TCHAR                   _szInitStr1[MAX_FTMAX];
    AIINIT                  _aiinitFlags1;
    TCHAR                   _szInitStr2[MAX_FTMAX];
    AIINIT                  _aiinitFlags2;

    static HIMAGELIST       _himlSysSmall;
    static HIMAGELIST       _himlSysLarge;
private:
    LONG                    _cRef;
};

#endif //FTASSOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "ftcmmn.h"
#include "ftdlg.h"
#include "ftascstr.h" //there only for the new CFTAssocStore

CFTDlg::CFTDlg(ULONG_PTR ulpAHelpIDsArray) :
    CBaseDlg(ulpAHelpIDsArray), _pAssocStore(NULL)
{}

CFTDlg::~CFTDlg()
{
    if (_pAssocStore)
        delete _pAssocStore;
}

HRESULT CFTDlg::_InitAssocStore()
{
    ASSERT(!_pAssocStore);

    _pAssocStore = new CFTAssocStore();

    return _pAssocStore ? S_OK : E_OUTOFMEMORY;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_CTRL_SETFOCUS:
            lRes = OnCtrlSetFocus(wParam, lParam);
            break;

        default:
            lRes = CBaseDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}

LRESULT CFTDlg::OnCtrlSetFocus(WPARAM wParam, LPARAM lParam)
{
    SetFocus((HWND)lParam);

    return TRUE;
}

//static
void CFTDlg::MakeDefaultProgIDDescrFromExt(LPTSTR pszProgIDDescr, DWORD cchProgIDDescr,
        LPTSTR pszExt)
{
    TCHAR szTemplate[25];
    TCHAR szExt[MAX_EXT];

    StringCchCopy(szExt, ARRAYSIZE(szExt), pszExt);

    LoadString(g_hinst, IDS_EXTTYPETEMPLATE, szTemplate, ARRAYSIZE(szTemplate));

    CharUpper(szExt);

    StringCchPrintf(pszProgIDDescr, cchProgIDDescr, szTemplate, szExt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftedit.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "ascstr.h"
#include "ftdlg.h"
#include "ftedit.h"
#include "ftcmmn.h"

#define ID_TIMER 2222

const static DWORD cs_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_FT_EDIT_EXT_EDIT_TEXT,  IDH_FCAB_FT_NE_FILEEXT,
    IDC_FT_EDIT_EXT_EDIT,       IDH_FCAB_FT_NE_FILEEXT,
    IDC_FT_EDIT_PID_COMBO_TEXT, IDH_FCAB_FT_NE_FILETYPE,
    IDC_FT_EDIT_PID_COMBO,      IDH_FCAB_FT_NE_FILETYPE,
    IDC_FT_EDIT_ADVANCED,       IDH_FCAB_FT_NE_ADV_BUT,
    IDC_NO_HELP_1,              NO_HELP,
    0, 0
};

CFTEditDlg::CFTEditDlg(FTEDITPARAM* pftEditParam) :
    CFTDlg((ULONG_PTR)cs_rgdwHelpIDsArray), _pftEditParam(pftEditParam),
    _iLVSel(-1)
{
}

CFTEditDlg::~CFTEditDlg()
{
}
///////////////////////////////////////////////////////////////////////////////
// Logic specific to our problem
LRESULT CFTEditDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = E_FAIL;  

    if (_pftEditParam)
    {
        hres = _InitAssocStore();

        if (SUCCEEDED(hres))
        {
            _hHeapProgID = HeapCreate(0, 8 * 1024, 0);

            if (!_hHeapProgID)
                hres = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hres))
            SetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, TEXT(""));
    }

    if (FAILED(hres))
        EndDialog(_hwnd, -1);
    else
        Edit_LimitText(GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT), MAX_EXT - 1);

    // Return TRUE so that system set focus
    return TRUE;
}

LRESULT CFTEditDlg::OnEdit(WORD wNotif)
{
    if (_fAdvanced)
    {
        if (EN_CHANGE == wNotif)
        {
            if (_nTimer)
            {
                KillTimer(_hwnd, _nTimer);
                _nTimer = 0;
            }

            _nTimer = SetTimer(_hwnd, ID_TIMER, 400, NULL);
        }
    }

    return FALSE;
}

LRESULT CFTEditDlg::OnTimer(UINT nTimer)
{
    // Kill the timer
    KillTimer(_hwnd, _nTimer);
    _nTimer = 0;

    _ProgIDComboHelper();

    return TRUE;
}

HRESULT CFTEditDlg::_ProgIDComboHelper()
{
    TCHAR szExt[MAX_EXT];
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
    HRESULT hres = E_FAIL;

    GetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, szExt, ARRAYSIZE(szExt));

    hres = _GetProgIDDescrFromExt(szExt, szProgIDDescr, &cchProgIDDescr);
    
    if (SUCCEEDED(hres))
        _SelectProgIDDescr(szProgIDDescr);

    return hres;
}

HRESULT CFTEditDlg::_GetProgIDDescrFromExt(LPTSTR pszExt, LPTSTR pszProgIDDescr,
        DWORD* pcchProgIDDescr)
{
    IAssocInfo* pAI = NULL;
    HRESULT hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

    if (SUCCEEDED(hres))
    {
        hres = pAI->GetString(AISTR_PROGIDDESCR, pszProgIDDescr, pcchProgIDDescr);
        pAI->Release();
    }
    return hres;
}

LRESULT CFTEditDlg::OnAdvancedButton(WORD wNotif)
{
    DECLAREWAITCURSOR;
    TCHAR szAdvBtnText[50];

    SetWaitCursor();

    _fAdvanced = !_fAdvanced;

    LoadString(g_hinst, _fAdvanced ? IDS_FT_ADVBTNTEXTEXPAND : IDS_FT_ADVBTNTEXTCOLLAPS,
        szAdvBtnText, ARRAYSIZE(szAdvBtnText));

    SetWindowText(GetDlgItem(_hwnd, IDC_FT_EDIT_ADVANCED), szAdvBtnText);

    _ConfigureDlg();

    UpdateWindow(_hwnd);

    if (_fAdvanced)
    {
        HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);

        // Is the combobox filled yet?
        if (!ComboBox_GetCount(hwndCombo))
        {
            _FillProgIDDescrCombo();

            // Select the <New> item

            if (FAILED(_ProgIDComboHelper()))
            {
                TCHAR szNew[20];

                if (LoadString(g_hinst, IDS_FT_NEW, szNew, ARRAYSIZE(szNew)))
                {
                    int iIndex = ComboBox_FindStringExact(hwndCombo, -1, szNew);

                    if (CB_ERR != iIndex)
                        ComboBox_SetCurSel(hwndCombo, iIndex);
                }
            }
        }
    }

    ResetWaitCursor();

    return FALSE;
}

void CFTEditDlg::_ConfigureDlg()
{
    // Need to:
    //  - position OK and Cancel
    //  - resize dlg
    //  - Show/hide Combo and its text

    RECT rcControl;
    RECT rcDialog;
    RECT rcCancel;
    RECT rcOK;

    int iStdMargins = 0;
    int iStdSpaceBetweenControls = 0;

    GetWindowRect(_hwnd, &rcDialog);

    GetWindowRect(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO_TEXT), 
        &rcControl);

    // Calculate the folowing (cannot be fixed, varies with dialog font)

    // [msadek]; screen coordinates. need to consider the mirrored case
    if(IS_WINDOW_RTL_MIRRORED(_hwnd))
    {
        iStdMargins = rcDialog.right - rcControl.right;
    }
    else
    {
        iStdMargins = rcControl.left - rcDialog.left;    
    }
    iStdSpaceBetweenControls = MulDiv(4, iStdMargins, 7);

    // Move Cancel and OK button
    GetWindowRect(GetDlgItem(_hwnd, 
        _fAdvanced ? IDC_FT_EDIT_PID_COMBO : IDC_FT_EDIT_EXT_EDIT), 
        &rcControl);

    MapWindowRect(HWND_DESKTOP, _hwnd, &rcControl);

    GetWindowRect(GetDlgItem(_hwnd, IDCANCEL), &rcCancel);
    MapWindowRect(HWND_DESKTOP, _hwnd, &rcCancel);

    OffsetRect(&rcCancel, 0, -rcCancel.top);

    GetWindowRect(GetDlgItem(_hwnd, IDOK), &rcOK);
    MapWindowRect(HWND_DESKTOP, _hwnd, &rcOK); 
    OffsetRect(&rcOK, 0, -rcOK.top);

    OffsetRect(&rcCancel, 0, rcControl.bottom + iStdSpaceBetweenControls);
    OffsetRect(&rcOK, 0, rcControl.bottom + iStdSpaceBetweenControls);

    SetWindowPos(GetDlgItem(_hwnd, IDOK), NULL, 
            rcOK.left, rcOK.top, 0, 0, SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOZORDER);
    SetWindowPos(GetDlgItem(_hwnd, IDCANCEL), NULL, 
            rcCancel.left, rcCancel.top, 0, 0, SWP_NOSIZE|SWP_SHOWWINDOW|SWP_NOZORDER);

    // Resize Dlg
    ClientToScreen(_hwnd, ((POINT*)&rcCancel) + 1);

    rcDialog.bottom = rcCancel.bottom + iStdMargins;
    SetWindowPos(_hwnd, NULL, 
            0, 0, rcDialog.right - rcDialog.left, rcDialog.bottom - rcDialog.top,
            SWP_NOMOVE|SWP_SHOWWINDOW|SWP_NOZORDER);

    // Show/Hide Combo and its text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO_TEXT), _fAdvanced);
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO), _fAdvanced);

    // Set focus to combo
    SetFocus(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO));
}

LRESULT CFTEditDlg::OnOK(WORD wNotif)
{
    HRESULT hres = S_FALSE;

    // Pick up the extension
    GetDlgItemText(_hwnd, IDC_FT_EDIT_EXT_EDIT, _pftEditParam->szExt,
        _pftEditParam->dwExt);

    // Is it empty?
    if (0 != (*_pftEditParam->szExt))
    {
        // No, that's good

        // FEATURE: do some check for valid extension name

        IAssocInfo* pAI = NULL;

        hres = _pAssocStore->GetAssocInfo(_pftEditParam->szExt, 
                            AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            BOOL fExist = FALSE;

            hres = pAI->GetBOOL(AIBOOL_EXTEXIST, &fExist);

            // Is this extension already existing?
            if (SUCCEEDED(hres) && !fExist)
            {
                // No, create it
                // Check for spaces in the ext name
                LPTSTR pszExt = _pftEditParam->szExt;

                while (*pszExt && (S_FALSE != hres))
                {
                    if (TEXT(' ') == *pszExt)
                    {
                        hres = S_FALSE;

                        ShellMessageBox(g_hinst, _hwnd,
                            MAKEINTRESOURCE(IDS_FT_MB_NOSPACEINEXT),
                            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

                        // Set focus to Ext combo
                        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
                            (LPARAM)GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT));
                    }

                    ++pszExt;
                }

                if (S_OK==hres)
                    hres = pAI->Create();
            }

            if (S_OK==hres)
                hres = _HandleProgIDAssoc(pAI, _pftEditParam->szExt, fExist);

            pAI->Release();
        }
    }
    else
    {
        ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_NOEXT),
            MAKEINTRESOURCE(IDS_FT), MB_OK | MB_ICONSTOP);

        // Set focus to Ext combo
        PostMessage(_hwnd, WM_CTRL_SETFOCUS, (WPARAM)0,
            (LPARAM)GetDlgItem(_hwnd, IDC_FT_EDIT_EXT_EDIT));
    }
    
    // If we fail, we are in serious trouble, so we just close the dialog
    ASSERT(SUCCEEDED(hres));

    if (S_FALSE != hres)
        EndDialog(_hwnd, IDOK);

    return FALSE;
}

HRESULT CFTEditDlg::_GetProgIDInfo(IAssocInfo* pAI, LPTSTR pszProgID,
    DWORD* pcchProgID, BOOL* pfNewProgID, BOOL* pfExplicitNew)
{
    HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);
    HRESULT hr = S_OK;

    *pfNewProgID = FALSE;
    *pfExplicitNew = FALSE;

    if (ComboBox_GetCount(hwndCombo))
    {
        int iSel = ComboBox_GetCurSel(hwndCombo);

        if (CB_ERR != iSel)
        {
            LPTSTR pszTmpProgID = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSel);

            // Is this the "<New>" item (the only one with a ProgID == NULL)?
            if (!pszTmpProgID)
            {
                // Yes
                *pfNewProgID = TRUE;
                *pfExplicitNew = TRUE;
            }
            else
            {
                // No
                hr = StringCchCopy(pszProgID, *pcchProgID, pszTmpProgID);
            }
        }        
    }
    else
    {
        *pfNewProgID = TRUE;
    }

    return hr;
}

HRESULT CFTEditDlg::_HandleProgIDAssoc(IAssocInfo* pAI, LPTSTR pszExt, BOOL fExtExist)
{
    TCHAR szProgID[MAX_PROGID];
    DWORD cchProgID = ARRAYSIZE(szProgID);
    BOOL fNewProgID = FALSE;
    BOOL fExplicitNew = FALSE;

    *szProgID = 0;
    HRESULT hres = _GetProgIDInfo(pAI, szProgID, &cchProgID, &fNewProgID, &fExplicitNew);

    if (SUCCEEDED(hres))
    {
        // Is this Extension already existing?
        if (fExtExist)
        {
            //
            // First make sure it's not the exact same ext - progID assoc
            //
            TCHAR szTmpProgID[MAX_PROGID];
            DWORD cchTmpProgID = ARRAYSIZE(szTmpProgID);

            hres = pAI->GetString(AISTR_PROGID, szTmpProgID, &cchTmpProgID);

            // Did we got a progID?
            if (SUCCEEDED(hres))
            { 
                // Yes
                // Are they the same?
                if (0 == lstrcmpi(szTmpProgID, szProgID))
                {
                    // Yes, fail, nothing more to do
                    hres = E_FAIL;
                }
                else
                {
                    // No, go on
                    hres = S_OK;
                }
            }
            else
            {
                // No, there probably is no ProgID, go on
                hres = S_OK;
            }
            //
            // Unless the user chose <New> explicitly ask if he wants to break the assoc
            //
            // Did the user explicitly chose <New> (and we did not failed already)?
            if (!fExplicitNew && SUCCEEDED(hres))
            {
                // We need to warn user that he will break existing assoc
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

                hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

                if (SUCCEEDED(hres))
                {
                    if (IDNO == ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_EDIT_ALREADYASSOC),
                        MAKEINTRESOURCE(IDS_FT_EDIT_ALRASSOCTITLE), MB_YESNO | MB_ICONEXCLAMATION,
                        pszExt, szProgIDDescr, pszExt, szProgIDDescr))
                    {
                        // S_FALSE means user does not want to go on
                        hres = S_FALSE;
                    }
                }
                else
                {
                    // no progIDDescr...  Check if we have a progID
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    if (FAILED(hres))
                    {
                        // no progID, set hres to S_OK so that we go on and create one
                        hres = S_OK;
                    }
                }
            }
        }

        // Should we go on and create new progID?
        if (S_OK==hres && fNewProgID)
        {
            // Yes, create it
            IAssocInfo* pAIProgID = NULL;

            hres = _pAssocStore->GetAssocInfo(NULL, AIINIT_PROGID, &pAIProgID);

            if (SUCCEEDED(hres))
            {
                hres = pAIProgID->Create();

                if (SUCCEEDED(hres))
                {
                    TCHAR szExt[MAX_EXT];
                    DWORD cchExt = ARRAYSIZE(szExt);
                    TCHAR szProgIDDescr[MAX_PROGIDDESCR];

                    HRESULT hresTmp = pAI->GetString(AISTR_EXT, szExt, &cchExt);

                    if (SUCCEEDED(hresTmp) && *szExt)
                    {
                        MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), szExt);

                        hresTmp = pAIProgID->SetString(AISTR_PROGIDDESCR, szProgIDDescr);
                    }

                    // Get the ProgID for later use
                    pAIProgID->GetString(AISTR_PROGID, szProgID, &cchProgID);
                }

                pAIProgID->Release();
            }
        }

        if (S_OK==hres)
        {
            // Set the new extension progID
            hres = pAI->SetString(AISTR_PROGID, szProgID);

            if (SUCCEEDED(hres))
            {
                // Get the description
                pAI->GetString(AISTR_PROGIDDESCR, _pftEditParam->szProgIDDescr,
                    &(_pftEditParam->dwProgIDDescr));
            }
        }
    }

    return hres;
}

LRESULT CFTEditDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

HRESULT CFTEditDlg::_FillProgIDDescrCombo()
{
    HWND hwndCombo = GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO);

    // Data stuff
    IEnumAssocInfo* pEnum = NULL;
    HRESULT hres = _pAssocStore->EnumAssocInfo(
        ASENUM_PROGID | ASENUM_ASSOC_ALL, NULL, AIINIT_NONE, &pEnum);

    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;

        while ((E_OUTOFMEMORY != hres) && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                int iIndex = CB_ERR;
                
                if (*szProgIDDescr)
                {
                    if (CB_ERR == ComboBox_FindStringExact(hwndCombo, -1, szProgIDDescr))
                        iIndex = ComboBox_AddString(hwndCombo, szProgIDDescr);
                }

                if ((CB_ERR != iIndex) && (CB_ERRSPACE != iIndex))
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    if (SUCCEEDED(hres))
                    {
                        LPTSTR pszProgID = _AddProgID(szProgID);    // allocate and copy ID
                        if(pszProgID)
                        {
                            ComboBox_SetItemData(hwndCombo, iIndex, pszProgID);
                        }
                        else
                        {
                            hres = E_OUTOFMEMORY;

                            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                                ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                                MB_OK | MB_ICONSTOP);

                            // Already allocated mem will be cleaned-up in OnDestroy
                        }
                    }
                }
            }

            pAI->Release();
        }
        pEnum->Release();

        if (SUCCEEDED(hres))
        {
            TCHAR szNew[20];

            if (LoadString(g_hinst, IDS_FT_NEW, szNew, ARRAYSIZE(szNew)))
            {
                int iIndex = ComboBox_InsertString(hwndCombo, 0, szNew);

                if (CB_ERR != iIndex)
                    ComboBox_SetItemData(hwndCombo, iIndex, NULL);
            }
        }
    }

    return hres;
}

BOOL CFTEditDlg::_SelectProgIDDescr(LPTSTR pszProgIDDescr)
{
    int iIndex = ComboBox_SelectString(GetDlgItem(_hwnd, IDC_FT_EDIT_PID_COMBO),
        -1, pszProgIDDescr);

    return ((CB_ERR != iIndex) ? TRUE : FALSE);
}

LRESULT CFTEditDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _CleanupProgIDs();

    CFTDlg::OnDestroy(wParam, lParam);

    return FALSE;
}


// Clone a progID
LPTSTR CFTEditDlg::_AddProgID(LPTSTR pszProgID)
{
    ASSERT(_hHeapProgID);
    DWORD dwStrBufferLen = lstrlen(pszProgID) + 1;
    LPTSTR pNewID = (LPTSTR) HeapAlloc(_hHeapProgID, 0, dwStrBufferLen * sizeof(TCHAR));
    if(pNewID)
    {
        StringCchCopy(pNewID, dwStrBufferLen, pszProgID);
    }
    return pNewID;
}

void CFTEditDlg::_CleanupProgIDs()
{
    if (_hHeapProgID)
        HeapDestroy(_hHeapProgID);
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTEditDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_EDIT_ADVANCED:
            lRes = OnAdvancedButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_EDIT_EXT_EDIT:
            lRes = OnEdit(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTEditDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_TIMER:
            if (ID_TIMER == wParam)
                lRes = OnTimer((UINT)wParam);
            else
                lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftdlg.h ===
#ifndef FTDLG_H
#define FTDLG_H

#include "basedlg.h"

class IAssocStore;

class CFTDlg : public CBaseDlg
{
public:
    CFTDlg(ULONG_PTR ulpAHelpIDsArray);

protected:
    virtual ~CFTDlg();

    LRESULT OnCtrlSetFocus(WPARAM wParam, LPARAM lParam);
    virtual LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _InitAssocStore();

    static void MakeDefaultProgIDDescrFromExt(LPTSTR pszProgIDDescr, DWORD dwProgIDDescr,
        LPTSTR pszExt);

protected:
    // Our connection to the data
    IAssocStore*    _pAssocStore;
};

#endif //FTDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftedit.h ===
#ifndef FTEDIT_H
#define FTEDIT_H

#include "ftdlg.h"

typedef struct tagFTEDITPARAM
{
    TCHAR   szExt[MAX_EXT];
    DWORD   dwExt;
    TCHAR   szProgIDDescr[MAX_PROGIDDESCR];
    DWORD   dwProgIDDescr;
    TCHAR   szProgID[MAX_PROGID];
    DWORD   dwProgID;
} FTEDITPARAM;

class CFTEditDlg : public CFTDlg
{
public:
    CFTEditDlg(FTEDITPARAM* pftEditParam);
protected:
    ~CFTEditDlg();

///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    //Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    //Control specific
    LRESULT OnAdvancedButton(WORD wNotif);
    LRESULT OnEdit(WORD wNotif);

    LRESULT OnTimer(UINT nTimer);

// Misc
    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

// Member variables
private:
    int             _iLVSel;

    BOOL            _fAdvanced;

    UINT_PTR        _nTimer;

    HANDLE          _hHeapProgID;
    FTEDITPARAM*    _pftEditParam;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    HRESULT _GetProgIDDescrFromExt(LPTSTR pszExt, LPTSTR pszProgIDDescr,
        DWORD* pcchProgIDDescr);
    HRESULT _GetProgIDInfo(IAssocInfo* pAI, LPTSTR pszProgID, DWORD* pcchProgID,
        BOOL* pfNewProgID, BOOL* pfExplicitNew);
    HRESULT _HandleProgIDAssoc(IAssocInfo* pAI, LPTSTR pszExt, BOOL fExtExist);
    HRESULT _ProgIDComboHelper();
    void _ResizeDlg();
    HRESULT _FillProgIDDescrCombo();
    BOOL _SelectProgIDDescr(LPTSTR pszProgIDDescr);
    void _ConfigureDlg();
    LPTSTR _AddProgID(LPTSTR pszProgID);
    void _CleanupProgIDs();
};

#endif //FTEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftcmmn.h ===
#ifndef FTCMMN_H
#define FTCMMN_H

#define WM_CTRL_SETFOCUS WM_USER + 1

#define MAX_EXT                 MAX_PATH
#define MAX_PROGID              MAX_PATH
#define MAX_PROGIDDESCR         200 //no reason
#define MAX_APPFRIENDLYNAME     260
#define MAX_ACTION	    		63
#define MAX_ACTIONDESCR			200 //no reason
#define MAX_ACTIONCMDLINE       (MAX_PATH * 2) //no reason
#define MAX_ACTIONAPPL			MAX_PATH
#define MAX_ACTIONDDEAPPNOTRUN	MAX_PATH
#define MAX_ACTIONDDEMSG		200 //no reason
#define MAX_ACTIONTOPIC			200 //no reason
#define MAX_MIME				50 //no reason
#define MAX_FTMAX				MAX_EXT

#define BROWSEHACK_DONTINPLACENAVIGATE     0x00000008

// ...Reg: the Reg key name

typedef struct tagPROGIDACTION
{
    BOOL  fNew;
    BOOL  fUseDDE;
    TCHAR szAction[MAX_ACTION];
    TCHAR szActionReg[MAX_ACTION];
    TCHAR szOldAction[MAX_ACTION];
    TCHAR szOldActionReg[MAX_ACTION];
    TCHAR szCmdLine[MAX_ACTIONCMDLINE];
    TCHAR szDDEMsg[MAX_ACTIONDDEMSG];
    TCHAR szDDEApplication[MAX_ACTIONAPPL];
    TCHAR szDDEAppNotRunning[MAX_ACTIONDDEAPPNOTRUN];
    TCHAR szDDETopic[MAX_ACTIONTOPIC];
}PROGIDACTION;

#endif //FTCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftenum.cpp ===
#include "shellprv.h"

#include "ftascstr.h" //for now, until CoCreateInstance
#include "ftassoc.h" //for now, until CoCreate IAssocInfo
#include "ftenum.h"

#define EHKCR_NONE      0
#define EHKCR_EXT       1
#define EHKCR_PROGID    2

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  CFTEnumAssocInfo

///////////////////////////////////////////////////////////////////////////////
// Contructor / Destructor

CFTEnumAssocInfo::CFTEnumAssocInfo() : _cRef(1)
{
    //DLLAddRef();
}

CFTEnumAssocInfo::~CFTEnumAssocInfo()
{
    //DLLRelease();
}

///////////////////////////////////////////////////////////////////////////////
// IUnknown methods

HRESULT CFTEnumAssocInfo::QueryInterface(REFIID riid, void **ppv)
{
    //nothing for now
    return E_NOTIMPL;
}

ULONG CFTEnumAssocInfo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFTEnumAssocInfo::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}
///////////////////////////////////////////////////////////////////////////////
// IEnum methods

HRESULT CFTEnumAssocInfo::Init(ASENUM asenumFlags, LPTSTR pszStr, 
                               AIINIT aiinitFlags)
{
    HRESULT hres = E_INVALIDARG;

    if (((ASENUM_PROGID & asenumFlags) && !(ASENUM_EXT & asenumFlags)) ||
        (!(ASENUM_PROGID & asenumFlags) && (ASENUM_EXT & asenumFlags)) ||
        (ASENUM_ACTION & asenumFlags) )
    {
        hres = S_OK;

        _asenumFlags = asenumFlags;
        _aiinitFlags = aiinitFlags;

        if (pszStr)
            StrCpyN(_szInitStr, pszStr, ARRAYSIZE(_szInitStr));
        else
            _szInitStr[0] = 0;
    }

    return hres;
}

HRESULT CFTEnumAssocInfo::Next(IAssocInfo** ppAI)
{
    HRESULT hres = E_FAIL;
    TCHAR szStr[MAX_FTMAX];
    DWORD cchStr = ARRAYSIZE(szStr);
    AIINIT aiinitFlags = 0;

    *szStr = 0;

    switch(_aiinitFlags)
    {
        // We go through the registry
        case AIINIT_NONE:
        {
            switch(_asenumFlags & ASENUM_MAINMASK)
            {
                case ASENUM_EXT:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_EXT;
                    break;

                case ASENUM_PROGID:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_PROGID;
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        // In theory, we go through the value linked to a progID
        case AIINIT_PROGID:
        {
            switch(_asenumFlags & ASENUM_MAINMASK)
            {
                case ASENUM_EXT:
                    hres = _EnumHKCR(_asenumFlags, szStr, &cchStr);
                    aiinitFlags = AIINIT_EXT;
                    break;

                case ASENUM_ACTION:
                    hres = _EnumProgIDActions(szStr, &cchStr);
                    break;

                default:
                    hres = E_INVALIDARG;
                    break;
            }
            break;
        }
        default:
            hres = E_INVALIDARG;
            break;
    }

    if (S_OK==hres)
    {
        if (*szStr)
        {
            *ppAI = new CFTAssocInfo();

            if (*ppAI)
            {
                if (ASENUM_ACTION != (_asenumFlags & ASENUM_MAINMASK))
                    hres = (*ppAI)->Init(aiinitFlags, szStr);
                else
                    hres = (*ppAI)->InitComplex(AIINIT_PROGID, _szInitStr, AIINIT_ACTION, szStr);
            }
            else
                hres = E_OUTOFMEMORY;
        }
        else
            hres = E_FAIL;
    }

    return hres;
}

// This beast goes through the HKCR reg key and check that the
// key meets the criteria of dwFlags (mostly extension vs progID)
HRESULT CFTEnumAssocInfo::_EnumHKCR(ASENUM asenumFlags, LPTSTR pszStr, 
                                    DWORD* pcchStr)
{
    HRESULT hres = E_FAIL;
    BOOL fNext = TRUE;

    while (fNext)
    {
        // This will mean "no more item"
        hres = S_FALSE;

        DWORD cchStr = *pcchStr;

        LONG lRes = RegEnumKeyEx(HKEY_CLASSES_ROOT, _dwIndex, pszStr, &cchStr, NULL, NULL,
            NULL, NULL);

        ++_dwIndex;

        if (lRes != ERROR_NO_MORE_ITEMS)
        {
            if (TEXT('*') != *pszStr)
            {
                if (!_EnumKCRStop(asenumFlags, pszStr))
                {
                    if (!_EnumKCRSkip(asenumFlags, pszStr))
                    {
                        hres = S_OK;
                        fNext = FALSE;
                    }
                }
                else
                {
                    hres = S_FALSE;
                    fNext = FALSE;
                }
            }
        }
        else
        {
            fNext = FALSE;
        }
    }

    // Did we found the first ext?
    if (!_fFirstExtFound && S_OK==hres && (TEXT('.') == *pszStr))
    {
        // Yes
        _fFirstExtFound = TRUE;
    }

    return hres;
}

HRESULT CFTEnumAssocInfo::_EnumProgIDActions(LPTSTR pszStr, DWORD* pcchStr)
{
    // 5 for "shell"
    TCHAR szSubKey[MAX_PROGID + 5 + 1];
    HRESULT hres = S_OK;
    HKEY hKey = NULL;

    StrCpyN(szSubKey, _szInitStr, MAX_PROGID);
    StrCatBuff(szSubKey, TEXT("\\shell"), ARRAYSIZE(szSubKey));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_READ, &hKey))
    {
        LONG lRes = RegEnumKeyEx(hKey, _dwIndex, pszStr, pcchStr, NULL,
            NULL, NULL, NULL);

        if (ERROR_SUCCESS !=lRes)
        {
            if (ERROR_NO_MORE_ITEMS == lRes)
                hres = S_FALSE;
            else
                hres = E_FAIL;
        }

        ++_dwIndex;

        RegCloseKey(hKey);
    }

    return hres;
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

BOOL CFTEnumAssocInfo::_EnumKCRSkip(DWORD asenumFlags, LPTSTR pszExt)
{
    BOOL fRet = FALSE;

    if (AIINIT_NONE == _aiinitFlags)
    {
        CFTAssocStore* pAssocStore = NULL;

        // Do we want the Exts?
        if (!(ASENUM_EXT & asenumFlags))
        {
            // No
            // Is the first char a '.'?
            if (TEXT('.') == *pszExt)
            {
                // Yes, skip this one
                fRet = TRUE;
            }
        }
        else
        {
            // Yes
            // Is the first char a '.'?
            if (TEXT('.') != *pszExt)
            {
                // No, skip it
                fRet = TRUE;
            }
        }

        // we want to skip all the ext having explorer.exe as the executable for
        // their default verb.
        if ((ASENUM_NOEXPLORERSHELLACTION & asenumFlags) && !fRet)
        {
            IQueryAssociations* pQA = NULL;

            ASSERT(ASENUM_EXT & asenumFlags);

            HRESULT hres = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pQA));

            if (SUCCEEDED(hres))
            {
                WCHAR szwExt[MAX_EXT];
                SHTCharToUnicode(pszExt, szwExt, ARRAYSIZE(szwExt));

                hres = pQA->Init(0, szwExt, NULL, NULL);
        
                if (SUCCEEDED(hres))
                {
                    WCHAR szwExec[MAX_APPFRIENDLYNAME];
                    DWORD cchExec = ARRAYSIZE(szwExec);

                    hres = pQA->GetString(ASSOCF_VERIFY,
                        ASSOCSTR_EXECUTABLE, NULL, szwExec, &cchExec);

                    // "canonicalization", but the side effects arent a big deal.
                    if (!StrCmpIW(PathFindFileNameW(szwExec), L"explorer.exe"))
                    {
                        fRet = TRUE;
                    }
                }
                pQA->Release();
            }
        }

        if ((ASENUM_NOEXCLUDED & asenumFlags) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();

            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_EXCLUDE, &fRet);

                pAI->Release();
            }
        }

        if ((ASENUM_NOEXE & asenumFlags) && !fRet)
        {
            ASSERT(ASENUM_EXT & asenumFlags);

            fRet = PathIsExe(pszExt);
        }

        if ((ASENUM_ASSOC_YES & asenumFlags) &&
            (ASENUM_ASSOC_ALL != (ASENUM_ASSOC_ALL & asenumFlags)) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();
            
            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                BOOL fExtAssociated = FALSE;
                hres = pAI->GetBOOL(AIBOOL_EXTASSOCIATED, &fExtAssociated);

                fRet = (fExtAssociated ? FALSE : TRUE);

                pAI->Release();
            }
        }

        if ((ASENUM_ASSOC_NO & asenumFlags) &&
            (ASENUM_ASSOC_ALL != (ASENUM_ASSOC_ALL & asenumFlags)) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();
            
            ASSERT(ASENUM_EXT & asenumFlags);

            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);
            
            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_EXTASSOCIATED, &fRet);

                pAI->Release();
            }
        }

        if ((ASENUM_SHOWONLY & asenumFlags) && !fRet)
        {
            IAssocInfo* pAI = NULL;
            HRESULT hres = E_FAIL;

            if (!pAssocStore)
                pAssocStore = new CFTAssocStore();

            ASSERT(ASENUM_PROGID & asenumFlags);

            // I know pszExt is not an Extension but a progID...
            if (pAssocStore)
                hres = pAssocStore->GetAssocInfo(pszExt, AIINIT_PROGID, &pAI);
            
            if (SUCCEEDED(hres))
            {
                BOOL fTmpRet = FALSE;

                hres = pAI->GetBOOL(AIBOOL_SHOW, &fTmpRet);

                // If it has the show flag (FTA_Show), we don't skip it, so
                // invert the fTmpRet
                fRet = fTmpRet ? FALSE : TRUE;

                pAI->Release();
            }
        }

        if (pAssocStore)
            delete pAssocStore;
    }
    else
    {
        if (AIINIT_PROGID == _aiinitFlags)
        {
            fRet = TRUE;
            // Do we want the Exts?
            if (ASENUM_EXT & asenumFlags)
            {
                DWORD dwType = 0;
                TCHAR szProgID[MAX_PROGID];
                DWORD cbProgID = ARRAYSIZE(szProgID) * sizeof(TCHAR);

                LONG lRes = SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL,
                    &dwType, szProgID, &cbProgID);

                if (ERROR_SUCCESS == lRes)
                {
                    // Does it have the same progID?
                    if (!lstrcmpi(szProgID, _szInitStr))
                    {
                        // Yes, don't skip
                        fRet = FALSE;
                    }
                }
            }
        }
    }
    
    return fRet;
}

BOOL CFTEnumAssocInfo::_EnumKCRStop(DWORD asenumFlags, LPTSTR pszExt)
{
    BOOL fRet = FALSE;

    // NT returns the extension in alphabetical order, not Win9X
    // If we want only the extensions, and the first char is not a '.', then stop
    if (ASENUM_EXT & asenumFlags)
    {
        // Don't go out if we haven't found the first extension
        if ((TEXT('.') != *pszExt) && _fFirstExtFound)
            fRet = TRUE;
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
// Non-implemented IEnum methods

HRESULT CFTEnumAssocInfo::Clone(IEnumAssocInfo* pEnum)
{
    // Will never be implemented
    return E_FAIL;
}

HRESULT CFTEnumAssocInfo::Skip(DWORD dwSkip)
{
    return E_NOTIMPL;
}

HRESULT CFTEnumAssocInfo::Reset()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftprop.h ===
#ifndef FTPROP_H
#define FTPROP_H

#include "ftdlg.h"

class CFTPropDlg : public CFTDlg
{
public:
    CFTPropDlg();
   
///////////////////////////////////////////////////////////////////////////////
//  Implementation
private:
// Message handlers
    LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Dialog messages
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnFinishInitDialog();
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    // Misc
    LRESULT OnCtlColorStatic(WPARAM wParam, LPARAM lParam);

    // Control specific
        // ListView
    LRESULT OnNotifyListView(UINT uCode, LPNMHDR pNMHDR);
    LRESULT OnListViewSelItem(int iItem, LPARAM lParam);
    LRESULT OnListViewColumnClick(int iCol);
        // New, Remove, Edit buttons    
    LRESULT OnNewButton(WORD wNotif);
    LRESULT OnDeleteButton(WORD wNotif);
    LRESULT OnRemoveButton(WORD wNotif);
    LRESULT OnEditButton(WORD wNotif);
    LRESULT OnAdvancedButton(WORD wNotif);
    LRESULT OnChangeButton(WORD wNotif);


// Misc
    BOOL _GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem);
// Member variables
private:
    HIMAGELIST          _hImageList;
    BOOL                _fPerUserAdvButton;
    BOOL                _fStopThread;
    BOOL                _fUpdateImageAgain;

    // Optimization
    int                 _iLVSel;
///////////////////////////////////////////////////////////////////////////////
//  Helpers
private:
    // General
    inline HWND _GetLVHWND();
    // Lower pane
    HRESULT _UpdateProgIDButtons(LPTSTR pszExt, LPTSTR pszProgID);
    HRESULT _UpdateGroupBox(LPTSTR pszExt, BOOL fExt);
    HRESULT _UpdateDeleteButton(BOOL fExt);
    HRESULT _UpdateOpensWith(LPTSTR pszExt, LPTSTR pszProgID);
    HRESULT _UpdateAdvancedText(LPTSTR pszExt, LPTSTR pszFileType, BOOL fExt);
    HRESULT _EnableLowerPane(BOOL fEnable = TRUE);
    // ListView
    HRESULT _InitListView();
    HRESULT _FillListView();
    HRESULT _SelectListViewItem(int i);
    HRESULT _DeleteListViewItem(int i);
    void _UpdateListViewItem(LVITEM* plvItem);

    HRESULT _InitPreFillListView();
    HRESULT _InitPostFillListView();

    DWORD _UpdateAllListViewItemImages();

    void _SetAdvancedRestoreButtonHelpID(DWORD dwID);

    int _GetNextNAItemPos(int iFirstNAItem, int cNAItem, LPTSTR pszProgIDDescr);

    static DWORD WINAPI _UpdateAllListViewItemImagesWrapper(LPVOID lpParameter);
    static DWORD WINAPI _FillListViewWrapper(LPVOID lpParameter);
    static DWORD WINAPI _ThreadAddRefCallBack(LPVOID lpParameter);

    int _InsertListViewItem(int iItem, LPTSTR pszExt, LPTSTR pszProgIDDescr, LPTSTR pszProgID = NULL);

    BOOL _ShouldEnableButtons();
};

#endif //FTPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\guids.h ===
#ifndef _GUIDS_H
#define _GUIDS_H

DEFINE_GUID(IID_IThumbnailMaker, 0x7aaa28d2, 0x3bf2, 0x11cf, 0xb6, 0xe6, 0x0, 0xaa, 0x0, 0xbb, 0xba, 0x9e);

// {2D09F2E0-6846-11d0-B811-00C04FD706EC}
DEFINE_GUID( TOID_DiskCacheTask, 0x2d09f2e0, 0x6846, 0x11d0, 0xb8, 0x11, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {1728D630-69E3-11d0-B815-00C04FD706EC}
DEFINE_GUID( TOID_ImgCacheTidyup, 0x1728d630, 0x69e3, 0x11d0, 0xb8, 0x15, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {78212180-BF15-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(TOID_ExtractImageTask, 0x78212180, 0xbf15, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {6DFD582C-92E3-11d1-98A3-00C04FB687DA}
DEFINE_GUID(TOID_DiskCacheCleanup, 0x6dfd582c, 0x92e3, 0x11d1, 0x98, 0xa3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {EFC5437C-9847-11d1-98A4-00C04FB687DA}
DEFINE_GUID(TOID_UpdateDirHandler, 0xefc5437c, 0x9847, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {e7b2e826-7d5a-4011-8c88-9abb7dac6746}
DEFINE_GUID(TOID_ReadAheadHandler, 0xe7b2e826, 0x7d5a, 0x4011, 0x8c, 0x88, 0x9a, 0xbb, 0x7d, 0xac, 0x67, 0x46);

// {c87f14ef-b7f4-4a80-a406-2ed3c7ba8bd1}
DEFINE_GUID(TOID_WriteCacheHandler, 0xc87f14ef, 0xb7f4, 0x4a80, 0xa4, 0x06, 0x2e, 0xd3, 0xc7, 0xba, 0x8b, 0xd1);  

// {7EC9321A-0E09-11d2-81F8-00C04FB687DA}
DEFINE_GUID(TOID_CheckCacheTask, 0x7ec9321a, 0xe09, 0x11d2, 0x81, 0xf8, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {09F75242-D1A3-4969-A4DB-2298518D381D}
DEFINE_GUID(TOID_FolderImageTask, 0x9f75242, 0xd1a3, 0x4969, 0xa4, 0xdb, 0x22, 0x98, 0x51, 0x8d, 0x38, 0x1d);

// {4EF59929-6C53-4934-B4F4-AF65EC42AAB4}
DEFINE_GUID(IID_IPrintersBindInfo, 0x4ef59929, 0x6c53, 0x4934, 0xb4, 0xf4, 0xaf, 0x65, 0xec, 0x42, 0xaa, 0xb4);
#define PRINTER_BIND_INFO TEXT("PrintersBindInfo")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hwcmmn.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "hwcmmn.h"
#include "mtptl.h"

HRESULT _GetAutoplayHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,    
    LPCWSTR pszContentTypeHandler, IAutoplayHandler** ppiah)
{
    HRESULT hr = CoCreateInstance(CLSID_HWEventSettings, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IAutoplayHandler, ppiah));

    if (SUCCEEDED(hr))
    {
        hr = (*ppiah)->InitWithContent(pszDeviceID, pszEventType,
            pszContentTypeHandler);

        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket((*ppiah),
               RPC_C_AUTHN_WINNT,
               RPC_C_AUTHZ_NONE,
               NULL,
               RPC_C_AUTHN_LEVEL_CALL,
               RPC_C_IMP_LEVEL_IMPERSONATE,
               NULL,
               EOAC_NONE
            );
        }

        if (FAILED(hr))
        {
            (*ppiah)->Release();

            *ppiah = NULL;
        }
    }

    return hr;
}

HRESULT _GetAutoplayHandlerNoContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,    
    IAutoplayHandler** ppiah)
{
    HRESULT hr = CoCreateInstance(CLSID_HWEventSettings, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IAutoplayHandler, ppiah));

    if (SUCCEEDED(hr))
    {
        hr = (*ppiah)->Init(pszDeviceID, pszEventType);

        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket((*ppiah),
               RPC_C_AUTHN_WINNT,
               RPC_C_AUTHZ_NONE,
               NULL,
               RPC_C_AUTHN_LEVEL_CALL,
               RPC_C_IMP_LEVEL_IMPERSONATE,
               NULL,
               EOAC_NONE
            );
        }

        if (FAILED(hr))
        {
            (*ppiah)->Release();

            *ppiah = NULL;
        }
    }

    return hr;
}

HRESULT _GetHWDevice(LPCWSTR pszDeviceID, IHWDevice** ppihwdevice)
{
    HRESULT hr = CoCreateInstance(CLSID_HWDevice, NULL,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHWDevice, ppihwdevice));

    if (SUCCEEDED(hr))
    {
        hr = (*ppihwdevice)->Init(pszDeviceID);

        if (FAILED(hr))
        {
            (*ppihwdevice)->Release();
            *ppihwdevice = NULL;
        }
    }

    return hr;
}

HICON _GetIconFromIconLocation(LPCWSTR pszIconLocation, BOOL fBigIcon)
{
    WCHAR szIconLocation[MAX_PATH + 12];
    HIMAGELIST himagelist;
    int iImage;

    Shell_GetImageLists(fBigIcon ? &himagelist : NULL, fBigIcon ? NULL : &himagelist);

    StringCchCopy(szIconLocation, ARRAYSIZE(szIconLocation), pszIconLocation);

    iImage = Shell_GetCachedImageIndex(szIconLocation,
        PathParseIconLocation(szIconLocation), 0);
    
    return ImageList_GetIcon(himagelist, iImage, ILD_TRANSPARENT);
}

HRESULT _GetHardwareDevices(IHardwareDevices** ppihwdevices)
{
    return CoCreateInstance(CLSID_HardwareDevices, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHardwareDevices, ppihwdevices));
}

BOOL IsShellServiceRunning()
{
    BOOL fRunning = FALSE;
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCM)
    {
        SC_HANDLE hService = OpenService(hSCM, TEXT("ShellHWDetection"),
            SERVICE_INTERROGATE);

        if (hService)
        {
            SERVICE_STATUS ss;

            if (ControlService(hService, SERVICE_CONTROL_INTERROGATE, &ss))
            {
                if (SERVICE_RUNNING == ss.dwCurrentState)
                {
                    fRunning = TRUE;
                }
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hSCM);
    }

    return fRunning;
}

STDAPI GetDeviceProperties(LPCWSTR pszDeviceID, IHWDeviceCustomProperties **ppdcp)
{
    HRESULT hr = CoCreateInstance(CLSID_HWDeviceCustomProperties, NULL,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG, IID_PPV_ARG(IHWDeviceCustomProperties, ppdcp));
    if (SUCCEEDED(hr))
    {
        BOOL fVolumeFlag = TRUE;
        const TCHAR cszDeviceHeader[] = TEXT("\\\\?\\");
        if (!StrCmpN(cszDeviceHeader, pszDeviceID, ARRAYSIZE(cszDeviceHeader) - 1))
        {
            fVolumeFlag = CMtPtLocal::IsVolume(pszDeviceID);
        }

        hr = (*ppdcp)->InitFromDeviceID(pszDeviceID, fVolumeFlag ? HWDEVCUSTOMPROP_USEVOLUMEPROCESSING : 0);
        if (FAILED(hr))
        {
            (*ppdcp)->Release();
            *ppdcp = NULL;
        }
    }

    return hr;
}

struct CONTENTTYPEINFO
{
    DWORD       dwContentType;
    LPCWSTR     pszContentTypeHandler;
    int         iContentTypeFriendlyName;
    LPCWSTR     pszContentTypeIconLocation;
};

static const CONTENTTYPEINFO contenttypeinfo[] =
{
    { CT_CDAUDIO         , TEXT("CDAudioContentHandler"), IDS_AP_CDAUDIOCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-228") },
    { CT_DVDMOVIE        , TEXT("DVDMovieContentHandler"), IDS_AP_DVDMOVIECONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-222") },
    { CT_BLANKCDRW       , TEXT("BlankCDContentHandler"), IDS_AP_BLANKCDCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-260") },
    { CT_BLANKCDR        , TEXT("BlankCDContentHandler"), IDS_AP_BLANKCDCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-260") },
    { CT_AUTOPLAYMUSIC   , TEXT("MusicFilesContentHandler"), IDS_AP_MUSICFILESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-225") },
    { CT_AUTOPLAYPIX     , TEXT("PicturesContentHandler"), IDS_AP_PICTURESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shimgvw.dll,3") },
    { CT_AUTOPLAYMOVIE   , TEXT("VideoFilesContentHandler"), IDS_AP_VIDEOFILESCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-224") },

    { CT_AUTOPLAYMIXEDCONTENT, TEXT("MixedContentHandler"), IDS_AP_MIXEDCONTENTCONTENTHANDLER,
        TEXT("%SystemRoot%\\system32\\shell32.dll,-227") },
        
    { CT_AUTORUNINF      , NULL, 0, NULL },
    { CT_UNKNOWNCONTENT  , NULL, 0, NULL },
    { CT_BLANKDVDR       , NULL, 0, NULL },
    { CT_BLANKDVDRW      , NULL, 0, NULL },
};

HRESULT _GetContentTypeInfo(DWORD dwContentType, LPWSTR pszContentTypeFriendlyName,
    DWORD cchContentTypeFriendlyName, LPWSTR pszContentTypeIconLocation,
    DWORD cchContentTypeIconLocation)
{
    HRESULT hr = E_FAIL;

    for (DWORD dw = 0; dw < ARRAYSIZE(contenttypeinfo); ++dw)
    {
        //
        //  First matching entry wins.
        //

        if (contenttypeinfo[dw].dwContentType & dwContentType)
        {
            ASSERT(contenttypeinfo[dw].pszContentTypeHandler);

            if (!LoadString(g_hinst, contenttypeinfo[dw].iContentTypeFriendlyName,
                pszContentTypeFriendlyName, cchContentTypeFriendlyName))
            {
                *pszContentTypeFriendlyName = 0;
            }

            hr = StringCchCopy(pszContentTypeIconLocation, cchContentTypeIconLocation,
                contenttypeinfo[dw].pszContentTypeIconLocation);

            break;
        }
    }

    return hr;
}

BOOL IsMixedContent(DWORD dwContentType)
{
    BOOL fRet;

    switch (CT_ANYAUTOPLAYCONTENT & dwContentType)
    {
        case 0:
        case CT_AUTOPLAYMUSIC:
        case CT_AUTOPLAYPIX:
        case CT_AUTOPLAYMOVIE:
            fRet = FALSE;
            break;

        default:
            fRet = TRUE;
            break;
    }

    return fRet;
}

HRESULT _GetContentTypeHandler(DWORD dwContentType, LPWSTR pszContentTypeHandler,
    DWORD cchContentTypeHandler)
{
    HRESULT hr = E_FAIL;

    if (IsMixedContent(dwContentType))
    {
        hr = StringCchCopy(pszContentTypeHandler, cchContentTypeHandler, TEXT("MixedContentHandler"));
    }
    else
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(contenttypeinfo); ++dw)
        {
            //
            //  First matching entry wins.
            //

            if (contenttypeinfo[dw].dwContentType & dwContentType)
            {
                hr = StringCchCopy(pszContentTypeHandler, cchContentTypeHandler,
                    contenttypeinfo[dw].pszContentTypeHandler);

                break;
            }
        }
    }

    return hr;
}

HRESULT _GetHandlerInvokeProgIDAndVerb(LPCWSTR pszHandler, LPWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, LPWSTR pszInvokeVerb, DWORD cchInvokeVerb)
{
    IAutoplayHandlerProperties* pahp;
    HRESULT hr = CoCreateInstance(CLSID_AutoplayHandlerProperties, NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG,
        IID_PPV_ARG(IAutoplayHandlerProperties, &pahp));

    if (SUCCEEDED(hr))
    {
        hr = pahp->Init(pszHandler);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszInvokeProgIDLocal;
            LPWSTR pszInvokeVerbLocal;

            hr = pahp->GetInvokeProgIDAndVerb(&pszInvokeProgIDLocal, &pszInvokeVerbLocal);

            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(pszInvokeProgID, cchInvokeProgID, pszInvokeProgIDLocal);

                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopy(pszInvokeVerb, cchInvokeVerb, pszInvokeVerbLocal);
                }

                CoTaskMemFree(pszInvokeProgIDLocal);
                CoTaskMemFree(pszInvokeVerbLocal);
            }
        }

        pahp->Release();
    }

    return hr;
}

//
CCrossThreadFlag::~CCrossThreadFlag()
{
    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::~CCrossThreadFlag called");

    if (_hEvent)
    {
        CloseHandle(_hEvent);
    }
}

BOOL CCrossThreadFlag::Init()
{
    ASSERT(!_fInited);

    _hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

#ifdef DEBUG
    if (_hEvent)
    {
        _fInited = TRUE;
    }
#endif

    return !!_hEvent;
}

BOOL CCrossThreadFlag::Signal()
{
    ASSERT(_fInited);

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::Signal called");

    return SetEvent(_hEvent);
}

BOOL CCrossThreadFlag::IsSignaled()
{
    ASSERT(_fInited);
    BOOL fRet = (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0));

    TraceMsg(TF_MOUNTPOINT, "AUTOPLAY: CCrossThreadFlag::IsSignaled called: %d", fRet);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftenum.h ===
#ifndef FTENUM_H
#define FTENUM_H

#include "ascstr.h"

class CFTEnumAssocInfo : public IEnumAssocInfo
{
public:
    CFTEnumAssocInfo();
    ~CFTEnumAssocInfo();

public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumAssocInfo methods
    //  Initialization
    STDMETHOD(Init)(ASENUM asenumFlags, LPTSTR pszStr,
        AIINIT aiinitFlags);

    //  Standard IEnum methods
    STDMETHOD(Next)(IAssocInfo** ppAI);
    STDMETHOD(Skip)(DWORD dwSkip);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumAssocInfo* pEnum);

protected:
    STDMETHOD(_EnumHKCR)(ASENUM asenumFlags, LPTSTR pszStr, 
                                        DWORD* pcchStr);
    STDMETHOD(_EnumProgIDActions)(LPTSTR pszStr, DWORD* pcchStr);
    STDMETHOD_(BOOL, _EnumKCRSkip)(DWORD asenumFlags, LPTSTR pszExt);
    STDMETHOD_(BOOL, _EnumKCRStop)(DWORD asenumFlags, LPTSTR pszExt);

protected:
    LONG                    _cRef;

    ASENUM                  _asenumFlags;
    TCHAR                   _szInitStr[MAX_FTMAX];
    AIINIT                  _aiinitFlags;

    BOOL                    _fFirstExtFound;

    DWORD                   _dwIndex;
};

#endif //FTENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ftprop.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "help.h"

#include "ascstr.h"
#include "ftcmmn.h"

#include "ftprop.h"
#include "ftedit.h"
#include "ftadv.h"

#define SUBITEM_EXT         0
#define SUBITEM_PROGIDDESCR 1

#define WM_FINISHFILLLISTVIEW (WM_USER + 1)

static DWORD s_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_NO_HELP_1,                NO_HELP,
    IDC_FT_PROP_LV_FILETYPES,     IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_ANIM,             IDH_FCAB_FT_PROP_LV_FILETYPES,
    IDC_FT_PROP_NEW,              IDH_FCAB_FT_PROP_NEW,
    IDC_FT_PROP_OPENEXE_TXT,      IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENICON,         IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_OPENEXE,          IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_CHANGEOPENSWITH,  IDH_FPROP_GEN_CHANGE,
    IDC_FT_PROP_TYPEOFFILE_TXT,   IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_EDITTYPEOFFILE,   IDH_FCAB_FT_PROP_EDIT,
    IDC_FT_PROP_GROUPBOX,         IDH_FCAB_FT_PROP_DETAILS,
    IDC_FT_PROP_REMOVE,           IDH_FCAB_FT_PROP_REMOVE,
    0, 0
};

CFTPropDlg::CFTPropDlg() :
    CFTDlg((ULONG_PTR)s_rgdwHelpIDsArray), _iLVSel(-1), _fStopThread(FALSE)
{}


LRESULT CFTPropDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = _InitAssocStore();

    if (SUCCEEDED(hres))
        hres = _InitListView();

    if (SUCCEEDED(hres))
        _InitPreFillListView();
    
    if (SUCCEEDED(hres))
        SHCreateThread(_FillListViewWrapper, (LPVOID)this,  0, _ThreadAddRefCallBack);

    return TRUE;
}

LRESULT CFTPropDlg::OnFinishInitDialog()
{
    HRESULT hres;
    
    _InitPostFillListView();
    hres = _SelectListViewItem(0);


    if (FAILED(hres))
    {
        if (E_OUTOFMEMORY == hres)
        {
            ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_ERROR + 
                ERROR_NOT_ENOUGH_MEMORY), MAKEINTRESOURCE(IDS_FT), 
                MB_OK | MB_ICONSTOP);
        }

        EndDialog(_hwnd, -1);
    }
    else
        SHCreateThread(_UpdateAllListViewItemImagesWrapper, (LPVOID)this,  0, _ThreadAddRefCallBack);

    return TRUE;
}

LRESULT CFTPropDlg::OnCtlColorStatic(WPARAM wParam, LPARAM lParam)
{
    LRESULT fRet = FALSE;
    // This is to set the color of the background of the animate control
    // see doc on ACS_TRANSPARENT and WM_CTLCOLORSTATIC
    if ((HWND)lParam == GetDlgItem(_hwnd, IDC_FT_PROP_ANIM))
    {
        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, WM_CTLCOLORSTATIC), GetSysColor(COLOR_WINDOW));
        fRet = (LRESULT)GetSysColorBrush(COLOR_WINDOW);
    }

    return fRet;
}

//static
DWORD WINAPI CFTPropDlg::_FillListViewWrapper(LPVOID lpParameter)
{
    ((CFTPropDlg*)lpParameter)->_FillListView();
    ((CFTPropDlg*)lpParameter)->Release();
    return 0;
}

//static
DWORD WINAPI CFTPropDlg::_UpdateAllListViewItemImagesWrapper(LPVOID lpParameter)
{
    ((CFTPropDlg*)lpParameter)->_UpdateAllListViewItemImages();
    ((CFTPropDlg*)lpParameter)->Release();
    return 0;
}

//static
DWORD WINAPI CFTPropDlg::_ThreadAddRefCallBack(LPVOID lpParameter)
{
    return ((CFTPropDlg*)lpParameter)->AddRef();
}


LRESULT CFTPropDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    DWORD dwRet = FALSE;
    int iCount = 0;
    LVITEM lvItem = {0};
    HWND hwndLV = _GetLVHWND();

    _fStopThread = TRUE;
    
    HICON hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_GETIMAGE, IMAGE_ICON,
        (LPARAM)0);

    if (hIconOld)
        DeleteObject(hIconOld);

    // go through all the items in the listview and delete the strings dynamically
    // allocated for progIDs
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = SUBITEM_EXT;

    iCount = ListView_GetItemCount(hwndLV);

    for (lvItem.iItem = 0; lvItem.iItem < iCount; ++lvItem.iItem)
    {
        ListView_GetItem(hwndLV, &lvItem);

        if (lvItem.lParam)
        {
            LocalFree((HLOCAL)lvItem.lParam);
        }
    }

    CFTDlg::OnDestroy(wParam, lParam);

    return TRUE;
}

struct LVCOMPAREINFO
{
    HWND    hwndLV;
    int     iCol;
};

int CALLBACK AlphaCompareItem(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    struct LVCOMPAREINFO   *plvci = (struct LVCOMPAREINFO *)lParamSort;
    TCHAR   sz1[MAX_PATH];
    TCHAR   sz2[MAX_PATH];

    ListView_GetItemText(plvci->hwndLV, lParam1, plvci->iCol, sz1, ARRAYSIZE(sz1));
    ListView_GetItemText(plvci->hwndLV, lParam2, plvci->iCol, sz2, ARRAYSIZE(sz2));

    return lstrcmpi(sz1, sz2);
}

LRESULT CFTPropDlg::OnListViewColumnClick(int iCol)
{
    struct LVCOMPAREINFO lvci;
    
    lvci.hwndLV = _GetLVHWND();
    lvci.iCol = iCol;

    _fUpdateImageAgain = TRUE;

    return SendMessage(_GetLVHWND(), LVM_SORTITEMSEX, (WPARAM)&lvci, (LPARAM)AlphaCompareItem);    
}

LRESULT CFTPropDlg::OnListViewSelItem(int iItem, LPARAM lParam)
{
    //
    // Need to update the lower pane of the dialog
    //
    // Get the extension
    TCHAR szExt[MAX_EXT];
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    LVITEM lvItem = {0};

    _iLVSel = iItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    ListView_GetItem(_GetLVHWND(), &lvItem);

    ListView_GetItemText(_GetLVHWND(), iItem, SUBITEM_PROGIDDESCR, szProgIDDescr,
        ARRAYSIZE(szProgIDDescr));

    _EnableLowerPane(TRUE);

    if (!lvItem.lParam)
    {
        _UpdateGroupBox(szExt, TRUE);
    }
    else
    {
        _UpdateGroupBox(szProgIDDescr, FALSE);
    }

    _UpdateProgIDButtons(szExt, (LPTSTR)lvItem.lParam);

    // We rely on this being after _UpdateProgIDButtons (see _fPerUserAdvButton)
    _UpdateDeleteButton(lvItem.lParam ? FALSE : TRUE);
    _UpdateAdvancedText(szExt, szProgIDDescr, lvItem.lParam ? FALSE : TRUE);

    _UpdateOpensWith(szExt, (LPTSTR)lvItem.lParam);

    return FALSE;
}

HRESULT CFTPropDlg::_UpdateDeleteButton(BOOL fExt)
{
    BOOL fTrue = _ShouldEnableButtons();

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE),
        (_fPerUserAdvButton || !fExt) ? FALSE : fTrue);

    return S_OK;
}

HRESULT CFTPropDlg::_UpdateProgIDButtons(LPTSTR pszExt, LPTSTR pszProgID)
{
    HRESULT hres = E_FAIL;

    if (pszExt && *pszExt)
    {
        TCHAR szButtonText[50];
        HWND hwndAdvButton = GetDlgItem(_hwnd, IDC_FT_PROP_EDITTYPEOFFILE);

        _SetAdvancedRestoreButtonHelpID(IDH_FCAB_FT_PROP_EDIT);

        // Is this a progID only association?
        if (!pszProgID)
        {
            // No
            IAssocInfo* pAI;

            hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &_fPerUserAdvButton);

                ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == _fPerUserAdvButton)));

                if (_fPerUserAdvButton)
                {
                    // Restore mode
                    LoadString(g_hinst, IDS_FT_PROP_BTN_RESTORE, szButtonText, ARRAYSIZE(szButtonText));

                    _SetAdvancedRestoreButtonHelpID(IDH_FCAB_FT_PROP_EDIT_RESTORE);
                }
                else
                {
                    TCHAR szProgID[MAX_PROGID];
                    DWORD cchProgID = ARRAYSIZE(szProgID);

                    hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                    LoadString(g_hinst, IDS_FT_PROP_BTN_ADVANCED, szButtonText, ARRAYSIZE(szButtonText));

                    if (SUCCEEDED(hres))
                    {
                        IAssocInfo * pAIProgID;

                        hres = _pAssocStore->GetAssocInfo(szProgID, AIINIT_PROGID, &pAIProgID);

                        if (SUCCEEDED(hres))
                        {
                            BOOL fEdit = _ShouldEnableButtons();

                            if (fEdit)
                            {
                                pAIProgID->GetBOOL(AIBOOL_EDIT, &fEdit);
                            }

                            EnableWindow(hwndAdvButton, fEdit);

                            pAIProgID->Release();
                        }
                    }
                }

                pAI->Release();
            }
        }
        else
        {
            // Yes
            IAssocInfo* pAIProgID;

            LoadString(g_hinst, IDS_FT_PROP_BTN_ADVANCED, szButtonText, ARRAYSIZE(szButtonText));

            hres = _pAssocStore->GetAssocInfo(pszProgID, AIINIT_PROGID, &pAIProgID);

            if (SUCCEEDED(hres))
            {
                BOOL fEdit = _ShouldEnableButtons();

                if (fEdit)
                {
                    pAIProgID->GetBOOL(AIBOOL_EDIT, &fEdit);
                }

                EnableWindow(hwndAdvButton, fEdit);

                pAIProgID->Release();
            }

            EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_CHANGEOPENSWITH), FALSE);
        }

        SetWindowText(hwndAdvButton, szButtonText);
    }

    return hres;
}

LRESULT CFTPropDlg::OnDeleteButton(WORD wNotif)
{
    // Warn user about the evil consequences of his act
    if (ShellMessageBox(g_hinst, _hwnd, MAKEINTRESOURCE(IDS_FT_MB_REMOVETYPE),
        MAKEINTRESOURCE(IDS_FT), MB_YESNO | MB_ICONQUESTION) == IDYES)
    {
        LVITEM lvItem = {0};
        TCHAR szExt[MAX_EXT];

        // Set stuff
        lvItem.iSubItem = SUBITEM_EXT;
        lvItem.pszText = szExt;
        lvItem.cchTextMax = ARRAYSIZE(szExt);

        if (_GetListViewSelectedItem(LVIF_TEXT | LVIF_IMAGE, 0, &lvItem))
        {
            HRESULT hres;
            IAssocInfo* pAI;

            hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->Delete(AIALL_NONE);

                if (SUCCEEDED(hres))
                {
                    _DeleteListViewItem(lvItem.iItem);

                    PropSheet_CancelToClose(GetParent(_hwnd));
                }

                pAI->Release();
            }
        }
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnNewButton(WORD wNotif)
{
    FTEDITPARAM ftEditParam;
    CFTEditDlg* pEditDlg = NULL;

    // Fill structure
    ftEditParam.dwExt = ARRAYSIZE(ftEditParam.szExt);
    ftEditParam.dwProgIDDescr = ARRAYSIZE(ftEditParam.szProgIDDescr);

    // This one should be one way, it will come back with a value
    *ftEditParam.szProgID = 0;
    ftEditParam.dwProgID = ARRAYSIZE(ftEditParam.szProgID);

    pEditDlg = new CFTEditDlg(&ftEditParam);

    if (pEditDlg)
    {
        if (IDOK == pEditDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSEDITNEW),
                        _hwnd))
        {
            HWND hwndLV = _GetLVHWND();
            LRESULT lRes = 0;
            int iIndex = -1;
            HRESULT hres = E_FAIL;
            IAssocInfo* pAI = NULL;
            LVFINDINFO lvFindInfo = {0};
            LPTSTR pszExtNoDot = NULL;
            LVITEM lvItem = {0};
            TCHAR szExt[MAX_EXT];

            lvItem.pszText = szExt;
            lvItem.cchTextMax = ARRAYSIZE(szExt);

            pszExtNoDot = (TEXT('.') != *(ftEditParam.szExt)) ? ftEditParam.szExt :
                ftEditParam.szExt + 1;

            lvFindInfo.flags = LVFI_STRING;
            lvFindInfo.psz = pszExtNoDot;

            iIndex = ListView_FindItem(hwndLV, -1, &lvFindInfo);

            // Is this a brand new Ext-ProgID association?
            if (-1 == iIndex)
            {
                // Yes, Insert a new item
                SetWindowRedraw(hwndLV, FALSE);
            
                // Add new ext-progID association
                hres = _pAssocStore->GetAssocInfo(ftEditParam.szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                    DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

                    hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

                    if (FAILED(hres) || !*szProgIDDescr)
                    {
                        MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), pszExtNoDot);
                    }

                    // Add to the listview
                    iIndex = _InsertListViewItem(0, pszExtNoDot, szProgIDDescr);
                    pAI->Release();
                }

                // Select newly inserted item
                if (-1 != iIndex)
                {
                    _SelectListViewItem(iIndex);
                }

                // Redraw our list
                SetWindowRedraw(hwndLV, TRUE);

                _GetListViewSelectedItem(LVIF_PARAM | LVIF_TEXT, 0, &lvItem);

                lvItem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
            }
            else
            {
                // No just update the item
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvItem.iItem = iIndex;

                ListView_GetItem(hwndLV, &lvItem);
            }

            _UpdateListViewItem(&lvItem);

            PropSheet_CancelToClose(GetParent(_hwnd));
        }

        pEditDlg->Release();
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnAdvancedButton(WORD wNotif)
{
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];

    // Set stuff
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM, 0, &lvItem))
    {
        HRESULT hres;
        IAssocInfo* pAI;

        if (_fPerUserAdvButton)
        {
            // Restore mode
            hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

            if (SUCCEEDED(hres))
            {
                hres = pAI->Delete(AIALL_PERUSER);

                _UpdateListViewItem(&lvItem);

                OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

                pAI->Release();

                PropSheet_CancelToClose(GetParent(_hwnd));
            }
        }
        else
        {
            // we might deal with an ext-progid assoc or only a progID
            TCHAR szProgID[MAX_PROGID];

            // Is this a progID only?
            if (lvItem.lParam)
            {
                // Yes
                StringCchCopy(szProgID, ARRAYSIZE(szProgID), (LPTSTR)lvItem.lParam);

                hres = S_OK;
            }
            else
            {
                // No
                DWORD cchProgID = ARRAYSIZE(szProgID);

                hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    hres = THR(pAI->GetString(AISTR_PROGID, szProgID, &cchProgID));

                    pAI->Release();
                }
            }

            if (SUCCEEDED(hres))
            {
                CFTAdvDlg* pAdvDlg = new CFTAdvDlg(szProgID, szExt);

                if (pAdvDlg)
                {
                    if (IDOK == pAdvDlg->DoModal(g_hinst, MAKEINTRESOURCE(DLG_FILETYPEOPTIONSEDIT), _hwnd))
                    {
                        _UpdateListViewItem(&lvItem);

                        OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

                        PropSheet_CancelToClose(GetParent(_hwnd));
                    }

                    pAdvDlg->Release();
                }
            }
        }
    }

    return FALSE;
}

LRESULT CFTPropDlg::OnChangeButton(WORD wNotif)
{
    // Bring up the "Open With" dialog
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];

    // Set stuff
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (_GetListViewSelectedItem(LVIF_TEXT, 0, &lvItem))
    {
        TCHAR szDotExt[MAX_EXT];
        OPENASINFO oai;

        *szDotExt = TEXT('.');
        StringCchCopy(szDotExt + 1, ARRAYSIZE(szDotExt) - 1, szExt);

        oai.pcszFile = szDotExt;
        oai.pcszClass = NULL;
        oai.dwInFlags = (OAIF_REGISTER_EXT | OAIF_FORCE_REGISTRATION); // we want the association to be made

        if (SUCCEEDED(OpenAsDialog(GetParent(_hwnd), &oai)))
        {
            // we changed the association so update the "Opens with:" text
            _UpdateOpensWith(szExt, NULL);

            // we don't need LVIF_PARAM since we enable the Change button only for Ext-ProgID asssoc
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE;

            _UpdateListViewItem(&lvItem);

            OnListViewSelItem(lvItem.iItem, (LPARAM)NULL);

            PropSheet_CancelToClose(GetParent(_hwnd));
        }
    }

    return FALSE;
}

HRESULT CFTPropDlg::_UpdateGroupBox(LPTSTR pszText, BOOL fExt)
{
    HRESULT hres = E_OUTOFMEMORY;
    LPTSTR psz = NULL;

    if (fExt)
    {
        psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_DETAILSFOR), pszText);
    }
    else
    {
        psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_DETAILSFORPROGID), pszText);
    }

    if (psz)
    {
        SetDlgItemText(_hwnd, IDC_FT_PROP_GROUPBOX, psz);
        LocalFree(psz);
        hres = S_OK;
    }

    return hres;
}

HRESULT CFTPropDlg::_UpdateOpensWith(LPTSTR pszExt, LPTSTR pszProgID)
{
    HICON hIconOld = NULL;

    if (!pszProgID)
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szAppFriendlyName[MAX_APPFRIENDLYNAME];
            DWORD dwAppFriendlyName = ARRAYSIZE(szAppFriendlyName);

            hres = pAI->GetString(AISTR_APPFRIENDLY, szAppFriendlyName, &dwAppFriendlyName);

            if (SUCCEEDED(hres))
            {
                HICON hIcon = NULL;
                int iIcon;
                SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, szAppFriendlyName);

                hres = pAI->GetDWORD(AIDWORD_APPSMALLICON, (DWORD*)&iIcon);

                HIMAGELIST hIL = NULL;

                // PERF: Why don't we just use _hImageList?  Or ListView_GetImageList()?
                Shell_GetImageLists(NULL, &hIL);

                if (hIL && SUCCEEDED(hres))
                {
                    hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIcon);
                }

                hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
                    (LPARAM)hIcon);

                if (hIconOld)
                    DestroyIcon(hIconOld);
            }
            else
            {
                SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, TEXT(" "));

                hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
                    (LPARAM)NULL);

                if (hIconOld)
                    DestroyIcon(hIconOld);
            }

            pAI->Release();
        }
    }
    else
    {
        SetDlgItemText(_hwnd, IDC_FT_PROP_OPENEXE, TEXT(" "));

        hIconOld = (HICON)SendDlgItemMessage(_hwnd, IDC_FT_PROP_OPENICON, STM_SETIMAGE, IMAGE_ICON,
            (LPARAM)NULL);

        if (hIconOld)
            DestroyIcon(hIconOld);
    }
    
    return S_OK;
}

HRESULT CFTPropDlg::_UpdateAdvancedText(LPTSTR pszExt, LPTSTR pszFileType, BOOL fExt)
{
    HRESULT hres = S_OK;
    LPTSTR psz = NULL;

    if (_fPerUserAdvButton)
    {
        TCHAR szProgIDDescr[MAX_PROGIDDESCR];
        DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
        IAssocInfo* pAI = NULL;

        // we need to show the previous progIDDescr
        hres = _pAssocStore->GetAssocInfo(pszExt, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                    &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                // Restore mode
                psz = ShellConstructMessageString(HINST_THISDLL,
                    MAKEINTRESOURCE(IDS_FT_PROP_RESTORE),
                    pszExt, szProgIDDescr);
            }

            pAI->Release();
        }
    }
    else
    {
        if (fExt)
        {
            psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_ADVANCED),
                        pszExt, pszFileType, pszFileType);
        }
        else
        {
            psz = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FT_PROP_ADVANCED_PROGID),
                        pszFileType);
        }
    }

    if (SUCCEEDED(hres))
    {
        if (psz)
        {
            SetDlgItemText(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT, psz);
            LocalFree(psz);
        }
        else
            hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CFTPropDlg::_EnableLowerPane(BOOL fEnable)
{
    BOOL fTrue = _ShouldEnableButtons();

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_OPENEXE_TXT), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_OPENEXE), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_GROUPBOX ), fEnable);

    // if user is locked down then we do not enable the buttons
    if (!fTrue)
        fEnable = FALSE;

    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_CHANGEOPENSWITH), fEnable);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_EDITTYPEOFFILE), fEnable);

    return S_OK;
}

HRESULT CFTPropDlg::_InitPreFillListView()
{
    // Disable New and Delete
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_NEW), FALSE);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE), FALSE);

    _EnableLowerPane(FALSE);
    _UpdateGroupBox(TEXT(""), TRUE);

    // Hide the advanced text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), SW_HIDE);

    return S_OK;
}

HRESULT CFTPropDlg::_InitPostFillListView()
{
    BOOL fTrue = _ShouldEnableButtons();

    // Enable New and Delete
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_NEW),  fTrue);
    EnableWindow(GetDlgItem(_hwnd, IDC_FT_PROP_REMOVE), fTrue);

    // Show the advanced text
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_TYPEOFFILE_TXT), SW_SHOW);

    Animate_Stop(GetDlgItem(_hwnd, IDC_FT_PROP_ANIM));
    ShowWindow(GetDlgItem(_hwnd, IDC_FT_PROP_ANIM), SW_HIDE);
    ShowWindow(_GetLVHWND(), SW_SHOW);

    SetFocus(_GetLVHWND());

    return S_OK;
}

HRESULT CFTPropDlg::_InitListView()
{
    HRESULT hres = S_OK;
    LVCOLUMN lvColumn = {0};
    HWND hwndLV = _GetLVHWND();
    TCHAR szColumnTitle[40];
    RECT rc = {0};
    int iWidth = 80;
    HWND hwndAni;

    //
    // Styles
    //
    ListView_SetExtendedListViewStyleEx(hwndLV, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    //
    // Set the columns
    //
    lvColumn.mask = LVCF_TEXT|LVCF_SUBITEM|LVCF_WIDTH;

    // Extensions column
    LoadString(g_hinst, IDS_FT_PROP_EXTENSIONS, szColumnTitle, ARRAYSIZE(szColumnTitle));

    lvColumn.cx = 60;
    lvColumn.pszText = szColumnTitle;
    lvColumn.cchTextMax = lstrlen(szColumnTitle);
    lvColumn.iSubItem = SUBITEM_EXT;

    ListView_InsertColumn(hwndLV, SUBITEM_EXT, &lvColumn);

    // ProgIDs column
    LoadString(g_hinst, IDS_FT, szColumnTitle, ARRAYSIZE(szColumnTitle));

    lvColumn.cchTextMax = lstrlen(szColumnTitle);
    lvColumn.iSubItem = SUBITEM_PROGIDDESCR;
    ListView_InsertColumn(hwndLV, SUBITEM_PROGIDDESCR, &lvColumn);

    // Adjust columns width
    // we need to do it after inserting both col, cause the last column resizing 
    // is special cased in list view code.

    // Ext column
    ListView_SetColumnWidth(hwndLV, SUBITEM_EXT, LVSCW_AUTOSIZE_USEHEADER);
    iWidth = ListView_GetColumnWidth(hwndLV, SUBITEM_EXT);

    // File type column
    GetClientRect(hwndLV, &rc);
    ListView_SetColumnWidth(hwndLV, SUBITEM_PROGIDDESCR,
        rc.right - iWidth - GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL));

    //
    // ImageList
    //
    Shell_GetImageLists(NULL, &_hImageList);

    if (_hImageList)
        ListView_SetImageList(hwndLV, _hImageList, LVSIL_SMALL);

    GetWindowRect(hwndLV, &rc);
    MapWindowPoints(NULL, _hwnd, (POINT*)&rc, 2);

    hwndAni = GetDlgItem(_hwnd, IDC_FT_PROP_ANIM);

    Animate_Open(hwndAni, MAKEINTRESOURCE(IDA_SEARCH)); // open the resource
    Animate_Play(hwndAni, 0, -1, -1);     // play from start to finish and repeat

    MoveWindow(hwndAni, rc.left, rc.top,
        rc.right - rc.left, rc.bottom - rc.top, TRUE);

    ShowWindow(hwndLV, SW_HIDE);

    ShowWindow(hwndAni, SW_SHOW);

    return hres;
}

HRESULT CFTPropDlg::_FillListView()
{
    // Data stuff
    IEnumAssocInfo* pEnum = NULL;
    HRESULT hres = E_FAIL;
    int iFirstNAItem = -1;
    HWND hwndLV = NULL;
    int iItem = 0;
    TCHAR szNA[50];

    ASSERT(_pAssocStore);

    // Do the extension first
    if (!_fStopThread)
    {
        hwndLV = _GetLVHWND();
        SetWindowRedraw(hwndLV, FALSE);
    }

    if (!_fStopThread)
    {
        LoadString(g_hinst, IDS_FT_NA, szNA, ARRAYSIZE(szNA));
        hres = _pAssocStore->EnumAssocInfo(ASENUM_EXT |
            ASENUM_ASSOC_YES | ASENUM_NOEXCLUDED | ASENUM_NOEXPLORERSHELLACTION |
            ASENUM_NOEXE, NULL, AIINIT_NONE, &pEnum);
    }
    else
        hres = E_FAIL;

    
    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;
    
        while (!_fStopThread && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szExt[MAX_EXT];
            DWORD cchExt = ARRAYSIZE(szExt);

            hres = pAI->GetString(AISTR_EXT, szExt, &cchExt);

            if (SUCCEEDED(hres))
            {
                BOOL fPerUser = FALSE;
                TCHAR szProgIDDescr[MAX_PROGIDDESCR];
                DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
                HRESULT hresTmp = E_FAIL;

                hresTmp = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

                ASSERT(SUCCEEDED(hresTmp) || (FAILED(hresTmp) && (FALSE == fPerUser)));

                if (!fPerUser)
                {
                    hresTmp = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                            &cchProgIDDescr);
                }
            
                if (fPerUser || FAILED(hresTmp) || !*szProgIDDescr)
                    MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), szExt);
                    
                if (!_fStopThread)
                    _InsertListViewItem(iItem, szExt, szProgIDDescr);

                // See comment in ftenum.cpp, CFTEnumAssocInfo::_EnumKCRStop about sorting
                // Check if this is where we need to insert the N/A item later
                if ((-1 == iFirstNAItem) && (lstrcmpi(szExt, szNA) > 0))
                {
                    iFirstNAItem = iItem;
                }
                ++iItem;
            }

            pAI->Release();

            hres = S_OK;
        }

        pEnum->Release();
        pEnum = NULL;
    }

    // Then do the ProgIDs
    if (!_fStopThread)    
        hres = _pAssocStore->EnumAssocInfo(ASENUM_PROGID | ASENUM_SHOWONLY, NULL, AIINIT_NONE, &pEnum);
    else
        hres = E_FAIL;
        
    if (SUCCEEDED(hres))
    {
        IAssocInfo* pAI = NULL;
        int cNAItem = 0;

        while (!_fStopThread && (S_OK == pEnum->Next(&pAI)))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);

            hres = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr, &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                TCHAR szProgID[MAX_PROGID];
                DWORD cchProgID = ARRAYSIZE(szProgID);

                hres = pAI->GetString(AISTR_PROGID, szProgID, &cchProgID);

                if (SUCCEEDED(hres))
                {
                    // we need to sort the N/A items by the description since they all begin with "N/A"
                    int iNAItem;

                    if (!cNAItem)
                    {
                        iNAItem = iFirstNAItem;
                    }
                    else
                    {
                        if (!_fStopThread)
                            iNAItem = _GetNextNAItemPos(iFirstNAItem, cNAItem, szProgIDDescr);
                    }

                    if (!_fStopThread)
                    {
                        _InsertListViewItem(iNAItem, szNA, szProgIDDescr, szProgID);
                        ++cNAItem;
                    }
                }
            }

            pAI->Release();

            hres = S_OK;
        }

        pEnum->Release();
    }

    if (!_fStopThread)
    {
        SetWindowRedraw(hwndLV, TRUE);
        PostMessage(_hwnd, WM_FINISHFILLLISTVIEW, 0, 0);
    }
    
    return hres;
}

int CFTPropDlg::_GetNextNAItemPos(int iFirstNAItem, int cNAItem, LPTSTR pszProgIDDescr)
{
    LVITEM lvItem = {0};
    TCHAR szProgIDDescr[MAX_PROGIDDESCR];
    int iItem = iFirstNAItem;
    HWND hwndLV = _GetLVHWND();

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_PROGIDDESCR;
    lvItem.pszText = szProgIDDescr;
    lvItem.cchTextMax = ARRAYSIZE(szProgIDDescr);

    while (iItem < (iFirstNAItem + cNAItem))
    {
        if (ListView_GetItem(hwndLV, &lvItem))
        {
            if (lstrcmpi(pszProgIDDescr, lvItem.pszText) >= 0)
            {
                ++iItem;
                lvItem.iItem = iItem;
            }
            else
            {
                break;
            }
        }
        else
        {
            // This happens when the listview is destroyed (on another thread),
            // but this thread is still doing some work.  The call above fails,
            // we break here or else we'll never go out of the loop.
            break;
        }
    }

    return iItem;
}

DWORD CFTPropDlg::_UpdateAllListViewItemImages()
{
    HWND hwndLV = NULL;
    int iCount = 0;
    LVITEM lvItem = {0};
    TCHAR szExt[MAX_EXT];
    HRESULT hres = E_FAIL;


    HRESULT hrInit = SHCoInitialize();
 
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = szExt;
    lvItem.cchTextMax = ARRAYSIZE(szExt);

    if (!_fStopThread)
        hwndLV = _GetLVHWND();

    do
    {
        _fUpdateImageAgain = FALSE;
        
        if (!_fStopThread)
            iCount = ListView_GetItemCount(hwndLV);
        
        for (lvItem.iItem = 0; !_fStopThread && (lvItem.iItem < iCount);
            ++lvItem.iItem)
        {
            IAssocInfo* pAI = NULL;

            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            
            if (!_fStopThread)
                ListView_GetItem(hwndLV, &lvItem);
            
            if (!_fStopThread && !lvItem.lParam)
            {
                hres = _pAssocStore->GetAssocInfo(szExt, AIINIT_EXT, &pAI);

                if (SUCCEEDED(hres))
                {
                    BOOL fPerUser = FALSE;

                    hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

                    ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == fPerUser)));

                    if (fPerUser)
                        hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON | AIALL_PERUSER, (DWORD*)&lvItem.iImage);
                    else
                        hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);
                }
            }
            else
            {
                hres = _pAssocStore->GetAssocInfo((LPTSTR)lvItem.lParam, AIINIT_PROGID, &pAI);

                if (SUCCEEDED(hres))
                {
                    hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);
                }
            }

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                
                if (!_fStopThread)
                    ListView_SetItem(hwndLV, &lvItem);
            }

            if (pAI)
                pAI->Release();
        }
    }
    while (_fUpdateImageAgain && !_fStopThread);

    SHCoUninitialize(hrInit);

    return (DWORD)_fStopThread;
}

void CFTPropDlg::_UpdateListViewItem(LVITEM* plvItem)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = *plvItem;

    // Need to:
    //  - update image
    //  - update progIDDescr

    if (!lvItem.lParam)
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo(lvItem.pszText, AIINIT_EXT, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
            HRESULT hresTmp = E_FAIL;

            SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
        
            // Icon
            BOOL fPerUser = FALSE;

            hres = pAI->GetBOOL(AIBOOL_PERUSERINFOAVAILABLE, &fPerUser);

            ASSERT(SUCCEEDED(hres) || (FAILED(hres) && (FALSE == fPerUser)));

            if (fPerUser)
                hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON | AIALL_PERUSER, (DWORD*)&lvItem.iImage);
            else
                hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                ListView_SetItem(hwndLV, &lvItem);
            }

            // ProgID Description
            if (!fPerUser)
            {
                hresTmp = pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                        &cchProgIDDescr);
            }
    
            if (fPerUser || FAILED(hresTmp) || !*szProgIDDescr)
                MakeDefaultProgIDDescrFromExt(szProgIDDescr, ARRAYSIZE(szProgIDDescr), lvItem.pszText);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.iSubItem = SUBITEM_PROGIDDESCR;
                lvItem.pszText = szProgIDDescr;
                lvItem.cchTextMax = lstrlen(szProgIDDescr);

                ListView_SetItem(hwndLV, &lvItem);
            }

            ListView_RedrawItems(hwndLV, lvItem.iItem, lvItem.iItem);

            pAI->Release();
        }
    }
    else
    {
        IAssocInfo* pAI = NULL;

        HRESULT hres = _pAssocStore->GetAssocInfo((LPTSTR)lvItem.lParam, AIINIT_PROGID, &pAI);

        if (SUCCEEDED(hres))
        {
            TCHAR szProgIDDescr[MAX_PROGIDDESCR];
            DWORD cchProgIDDescr = ARRAYSIZE(szProgIDDescr);
            HRESULT hresTmp = E_FAIL;

            SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
        
            // Icon
            hres = pAI->GetDWORD(AIDWORD_DOCSMALLICON, (DWORD*)&lvItem.iImage);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_IMAGE;
                ListView_SetItem(hwndLV, &lvItem);
            }

            // ProgID Description
            pAI->GetString(AISTR_PROGIDDESCR, szProgIDDescr,
                    &cchProgIDDescr);

            if (SUCCEEDED(hres))
            {
                lvItem.mask = LVIF_TEXT;
                lvItem.iSubItem = SUBITEM_PROGIDDESCR;
                lvItem.pszText = szProgIDDescr;
                lvItem.cchTextMax = lstrlen(szProgIDDescr);

                ListView_SetItem(hwndLV, &lvItem);
            }
            ListView_RedrawItems(hwndLV, lvItem.iItem, lvItem.iItem);

            pAI->Release();
        }
    }
}

int CFTPropDlg::_InsertListViewItem(int iItem, LPTSTR pszExt, LPTSTR pszProgIDDescr,
                                    LPTSTR pszProgID)
{
    HWND hwndLV = _GetLVHWND();
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

    // Put generic icon

    lvItem.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_DOCNOASSOC, 0);

    CharUpper(pszExt);

    // Extension
    if (pszProgID)
    {
        DWORD cch = lstrlen(pszProgID) + 1;
        lvItem.lParam = (LPARAM)LocalAlloc(LPTR, cch * sizeof(TCHAR));

        if (lvItem.lParam)
        {
            StringCchCopy((LPTSTR)lvItem.lParam, cch, pszProgID);
        }
    }
    else
    {
        lvItem.lParam = NULL;
    }

    lvItem.iItem = iItem;
    lvItem.iSubItem = SUBITEM_EXT;
    lvItem.pszText = pszExt;
    lvItem.cchTextMax = lstrlen(pszExt);

    lvItem.iItem = ListView_InsertItem(hwndLV, &lvItem);

    if (-1 != lvItem.iItem)
    {
        // ProgID Description
        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = SUBITEM_PROGIDDESCR;
        lvItem.pszText = pszProgIDDescr;
        lvItem.cchTextMax = lstrlen(pszProgIDDescr);

        ListView_SetItem(hwndLV, &lvItem);
    }
    else
    {
        // LocalFree checks for NULL
        LocalFree((HLOCAL)lvItem.lParam);
    }

    return lvItem.iItem;
}

HRESULT CFTPropDlg::_SelectListViewItem(int i)
{
    LVITEM lvItem = {0};

    lvItem.iItem = i;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(_GetLVHWND(), &lvItem);
    ListView_EnsureVisible(_GetLVHWND(), i, FALSE);

    return S_OK;
}

HRESULT CFTPropDlg::_DeleteListViewItem(int i)
{
    HWND hwndLV = _GetLVHWND();
    int iCount = ListView_GetItemCount(hwndLV);
    int iNextSel = -1;        
    LVITEM lvItem = {0};

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = i;
    lvItem.iSubItem = SUBITEM_EXT;

    ListView_GetItem(hwndLV, &lvItem);

    if (lvItem.lParam)
    {
        LocalFree((HLOCAL)lvItem.lParam);
    }

    ListView_DeleteItem(hwndLV, i);

    if (iCount > i)
        iNextSel = i;
    else
        if (i > 0)
            iNextSel = i - 1;

    if (-1 != iNextSel)
        _SelectListViewItem(iNextSel);

    return S_OK;
}

BOOL CFTPropDlg::_ShouldEnableButtons()
{
    // if we have a locked down user, then we never enable the buttons
    BOOL fRet = TRUE;

    if (S_FALSE == _pAssocStore->CheckAccess())
    {
        fRet = FALSE;
    }

    // If the REST_NOFILEASSOCIATE is set (TRUE), 
    // then we want to NOT enable buttons.
    fRet &= !SHRestricted(REST_NOFILEASSOCIATE);

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
// Misc
BOOL CFTPropDlg::_GetListViewSelectedItem(UINT uMask, UINT uStateMask, LVITEM* plvItem)
{
    BOOL fSel = FALSE;
    HWND hwndLV = _GetLVHWND();

    plvItem->mask = uMask | LVIF_STATE;
    plvItem->stateMask = uStateMask | LVIS_SELECTED;

    // Do we have the selection cached?
    if (-1 != _iLVSel)
    {
        // Yes, make sure it's valid
        plvItem->iItem = _iLVSel;

        ListView_GetItem(hwndLV, plvItem);

        if (plvItem->state & LVIS_SELECTED)
            fSel = TRUE;
    }
 
    // Cache was wrong
    if (!fSel)
    {
        int iCount = ListView_GetItemCount(hwndLV);

        for (int i=0; (i < iCount) && !fSel; ++i)
        {
            plvItem->iItem = i;
            ListView_GetItem(hwndLV, plvItem);

            if (plvItem->state & LVIS_SELECTED)
                fSel = TRUE;
        }

        if (fSel)
            _iLVSel = i;
    }

    return fSel;
}

HWND CFTPropDlg::_GetLVHWND()
{
    return GetDlgItem(_hwnd, IDC_FT_PROP_LV_FILETYPES);
}

void CFTPropDlg::_SetAdvancedRestoreButtonHelpID(DWORD dwID)
{
    for (int i = 0; i < ARRAYSIZE(s_rgdwHelpIDsArray); i += 2)
    {
        if (IDC_FT_PROP_EDITTYPEOFFILE == s_rgdwHelpIDsArray[i])
        {
            if (i + 1 < ARRAYSIZE(s_rgdwHelpIDsArray))
                s_rgdwHelpIDsArray[i + 1] = dwID;

            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CFTPropDlg::OnNotifyListView(UINT uCode, LPNMHDR pNMHDR)
{
    LRESULT lRes = FALSE;

    switch(uCode)
    {
        case LVN_GETINFOTIP:
        {
            NMLVGETINFOTIP* plvn = (NMLVGETINFOTIP*)pNMHDR;

            break;
        }
        case LVN_ITEMCHANGED:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected?
            if ((pNMLV->uChanged & LVIF_STATE) &&
                (pNMLV->uNewState & (LVIS_SELECTED | LVIS_FOCUSED)))
            {
                // Yes
                OnListViewSelItem(pNMLV->iItem, pNMLV->lParam);
            }
            break;
        }

        case LVN_COLUMNCLICK:
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            OnListViewColumnClick(pNMLV->iSubItem);
            break;
        }

        case NM_DBLCLK:
            if (IsWindowEnabled(GetDlgItem(_hwnd, IDC_FT_PROP_EDIT)))
                PostMessage(_hwnd, WM_COMMAND, (WPARAM)IDC_FT_PROP_EDIT, 0);
            break;
    }

    return lRes;
}

LRESULT CFTPropDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_FT_PROP_NEW:
            lRes = OnNewButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_REMOVE:
            lRes = OnDeleteButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_EDITTYPEOFFILE:
            lRes = OnAdvancedButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDC_FT_PROP_CHANGEOPENSWITH:
            lRes = OnChangeButton(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            lRes = CFTDlg::OnCommand(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTPropDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    //GET_WM_COMMAND_CMD
    switch(idFrom)
    {
        case IDC_FT_PROP_LV_FILETYPES:
            lRes = OnNotifyListView(uCode, pNMHDR);
            break;
        default:
            lRes = CFTDlg::OnNotify(wParam, lParam);
            break;
    }

    return lRes;    
}

LRESULT CFTPropDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch(uMsg)
    {
        case WM_CTLCOLORSTATIC:
            lRes = OnCtlColorStatic(wParam, lParam);
            break;

        case WM_FINISHFILLLISTVIEW:
            lRes = OnFinishInitDialog();
            break;

        default:
            lRes = CFTDlg::WndProc(uMsg, wParam, lParam);
            break;
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hash.c ===
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: Hash.c
//
// Comments:
//      This file contains functions that are roughly equivelent to the
//      kernel atom function.  There are two main differences.  The first
//      is that in 32 bit land the tables are maintined in our shared heap,
//      which makes it shared between all of our apps.  The second is that
//      we can assocate a long pointer with each of the items, which in many
//      cases allows us to keep from having to do a secondary lookup from
//      a different table
//
// History:
//  09/08/93 - Created                                      KurtE
//  ??/??/94 - ported for unicode                           (anonymous)
//  10/26/95 - rearranged hashitems for perf, alignment     FrancisH
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"    // for SHCF_ICON_INDEX

#define DM_PERF     0           // perf stats

//--------------------------------------------------------------------------
// First define a data structure to use to maintain the list

#define DEF_HASH_BUCKET_COUNT   71

// NOTE a PHASHITEM is defined as a LPCSTR externaly (for old code to work)
#undef PHASHITEM
typedef struct _HashItem * PHASHITEM;

//-----------------------------------------------------------------------------
//
// Hash item layout:
//
//  [extra data][_HashItem struct][item text]
//
//-----------------------------------------------------------------------------

typedef struct _HashItem
{
    //
    // this part of the struct is aligned
    //
    PHASHITEM   phiNext;        //
    WORD        wCount;         // Usage count
    WORD        cchLen;          // Length of name in characters.

    //
    // this member is just a placeholder
    //
    TCHAR        szName[1];      // name with room for NULL terminator

} HASHITEM;

#pragma warning(disable:4200)   // Zero-sized array in struct

typedef struct _HashTable
{
    UINT    uBuckets;           // Number of buckets
    UINT    uItems;             // Number of items
    UINT    cbExtra;            // Extra bytes per item
    LPCTSTR pszHTCache;         // MRU ptr for last lookup/add/etc.
    PHASHITEM ahiBuckets[0];    // Set of buckets for the table
} HASHTABLE, * PHASHTABLE;

#define HIFROMSZ(sz)            ((PHASHITEM)((BYTE*)(sz) - FIELD_OFFSET(HASHITEM, szName)))
#define HIDATAPTR(pht, sz)      ((void *)(((BYTE *)HIFROMSZ(sz)) - (pht? pht->cbExtra : 0)))
#define HIDATAARRAY(pht, sz)    ((DWORD_PTR *)HIDATAPTR(pht, sz))

#define  LOOKUPHASHITEM     0
#define  ADDHASHITEM        1
#define  DELETEHASHITEM     2
#define  PURGEHASHITEM      3   // DANGER: EVIL!

static HHASHTABLE g_hHashTable = NULL;

HHASHTABLE GetGlobalHashTable();
PHASHTABLE _CreateHashTable(UINT uBuckets, UINT cbExtra);

//--------------------------------------------------------------------------
// This function allocs a hashitem.
//
PHASHITEM _AllocHashItem(PHASHTABLE pht, DWORD cchName)
{
    BYTE *mem;

    ASSERT(pht);

    // Note: NULL terminator for the string is included in the sizeof HASHITEM
    mem = (BYTE *)LocalAlloc(LPTR, SIZEOF(HASHITEM) + (cchName * SIZEOF(TCHAR)) + pht->cbExtra);

    if (mem)
        mem += pht->cbExtra;

    return (PHASHITEM)mem;
}

//--------------------------------------------------------------------------
// This function frees a hashitem.
//
__inline void _FreeHashItem(PHASHTABLE pht, PHASHITEM phi)
{
    ASSERT(pht && phi);
    LocalFree((BYTE *)phi - pht->cbExtra);
}

// PERF_CACHE
//***   c_szHTNil -- 1-element MRU for hashtable
// DESCRIPTION
//  it turns out we have long runs of duplicate lookups (e.g. "Directory"
// and ".lnk").  a 1-element MRU is a v. cheap way of speeding things up.

// rather than check for the (rare) special case of NULL each time we
// check our cache, we pt at at this guy.  then iff we think it's a
// cache hit, we make sure it's not pting at this special guy.
const TCHAR c_szHTNil[] = TEXT("");     // arbitrary value, unique-&

#ifdef DEBUG
int g_cHTTot, g_cHTHit;
int g_cHTMod = 100;
#endif

// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
ULONG _CalculateHashKey(LPCTSTR pszName, WORD *pcch)
{
  // initialize HashKey to a reasonably large constant so very
  // short keys won't get mapped to small values. Virtually any
  // large odd constant will do. 
  unsigned int   HashKey  = 314159269 ; 
  TUCHAR *pC       = (TUCHAR *)pszName;

  for(; *pC; pC++){
    HashKey ^= (HashKey<<11) + (HashKey<<5) + (HashKey>>2) + (unsigned int) *pC  ;
  }

  if (pcch)
      *pcch = (WORD)(pC - pszName);

  return (HashKey & 0x7FFFFFFF) ;
}

void _GrowTable(HHASHTABLE hht)
{
    // hht can't be NULL here
    PHASHTABLE pht = *hht;
    PHASHTABLE phtNew = _CreateHashTable((pht->uBuckets * 2) -1, pht->cbExtra);

    if (phtNew)
    {
        int i;
        for (i=0; i<(int)pht->uBuckets; i++) 
        {
            PHASHITEM phi;
            PHASHITEM phiNext;
            for (phi=pht->ahiBuckets[i]; phi; phi=phiNext) 
            {
                // We always use case sensitive hash here since the case has already been fixed when adding the key.
                ULONG uBucket = _CalculateHashKey(phi->szName, NULL) % phtNew->uBuckets;

                phiNext = phi->phiNext;

                // And link it in to the right bucket
                phi->phiNext = phtNew->ahiBuckets[uBucket];
                phtNew->ahiBuckets[uBucket] = phi;
                phtNew->uItems++; // One more item in the table
            }
        }
        ASSERT(phtNew->uItems == pht->uItems);

        // Now switch the 2 tables
        LocalFree(pht);
        *hht = phtNew;
    }
}

//--------------------------------------------------------------------------
// This function looks up the name in the hash table and optionally does
// things like add it, or delete it.
//
LPCTSTR LookupItemInHashTable(HHASHTABLE hht, LPCTSTR pszName, int iOp)
{
    // First thing to do is calculate the hash value for the item
    UINT    uBucket;
    WORD    cchName;
    PHASHITEM phi, phiPrev;
    PHASHTABLE pht;

    ENTERCRITICAL;

    pht = hht ? *hht : NULL;

    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    if (pht == NULL) 
    {
        hht = GetGlobalHashTable();
        if (hht)
        {
            pht = *hht;
        }

        if (pht == NULL) {
            TraceMsg(TF_WARNING, "LookupItemInHashTable() - Can't get global hash table!");
            LEAVECRITICAL;
            return NULL;
        }
    }

#ifdef DEBUG
    if ((g_cHTTot % g_cHTMod) == 0)
        TraceMsg(DM_PERF, "ht: tot=%d hit=%d", g_cHTTot, g_cHTHit);
#endif
    DBEXEC(TRUE, g_cHTTot++);
    if (*pszName == *pht->pszHTCache && iOp == LOOKUPHASHITEM) {
        // StrCmpC is a fast ansi strcmp, good enough for a quick/approx check
        if (StrCmpC(pszName, pht->pszHTCache) == 0 && pht->pszHTCache != c_szHTNil) {
            DBEXEC(TRUE, g_cHTHit++);

            LEAVECRITICAL;          // see 'semi-race' comment below
            return (LPCTSTR)pht->pszHTCache;
        }
    }

    uBucket = _CalculateHashKey(pszName, &cchName) % pht->uBuckets;

    // now search for the item in the buckets.
    phiPrev = NULL;
    phi = pht->ahiBuckets[uBucket];

    while (phi)
    {
        if (phi->cchLen == cchName)
        {
            if (!lstrcmp(pszName, phi->szName))
                break;      // Found match
        }
        phiPrev = phi;      // Keep the previous item
        phi = phi->phiNext;
    }

    //
    // Sortof gross, but do the work here
    //
    switch (iOp)
    {
    case ADDHASHITEM:
        if (phi)
        {
            // Simply increment the reference count
            DebugMsg(TF_HASH, TEXT("Add Hit on '%s'"), pszName);

            phi->wCount++;
        }
        else
        {
            DebugMsg(TF_HASH, TEXT("Add MISS on '%s'"), pszName);

            // Not Found, try to allocate it out of the heap
            if ((phi = _AllocHashItem(pht, cchName)) != NULL)
            {
                // Initialize it
                phi->wCount = 1;        // One use of it
                phi->cchLen = cchName;        // The length of it;
                StrCpyN(phi->szName, pszName, cchName+1);

                // And link it in to the right bucket
                phi->phiNext = pht->ahiBuckets[uBucket];
                pht->ahiBuckets[uBucket] = phi;
                pht->uItems++; // One more item in the table

                if (pht->uItems > pht->uBuckets)
                {
                    _GrowTable(hht);
                    pht = *hht;
                }

                TraceMsg(TF_HASH, "Added new hash item %x(phiNext=%x,szName=\"%s\") for hash table %x at bucket %x",
                    phi, phi->phiNext, phi->szName, pht, uBucket);
            }
        }
        break;

    case PURGEHASHITEM:
    case DELETEHASHITEM:
        if (phi && ((iOp == PURGEHASHITEM) || (!--phi->wCount)))
        {
            // Useage count went to zero so unlink it and delete it
            if (phiPrev != NULL)
                phiPrev->phiNext = phi->phiNext;
            else
                pht->ahiBuckets[uBucket] = phi->phiNext;

            // And delete it
            TraceMsg(TF_HASH, "Free hash item %x(szName=\"%s\") from hash table %x at bucket %x",
                phi, phi->szName, pht, uBucket);

            _FreeHashItem(pht, phi);
            phi = NULL;
            pht->uItems--; // One less item in the table
        }
    }

    // kill cache if this was a PURGE/DELETEHASHITEM, o.w. cache it.
    // note that there's a semi-race on pht->pszHTCache ops, viz. that
    // we LEAVECRITICAL but then return a ptr into our table.  however
    // it's 'no worse' than the existing races.  so i guess the caller
    // is supposed to avoid a concurrent lookup/delete.
    pht->pszHTCache = phi ? phi->szName : c_szHTNil;

    LEAVECRITICAL;

    // If find was passed in simply return it.
    if (phi)
        return (LPCTSTR)phi->szName;
    else
        return NULL;
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI FindHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, LOOKUPHASHITEM);
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI AddHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, ADDHASHITEM);
}

//--------------------------------------------------------------------------

LPCTSTR WINAPI DeleteHashItem(HHASHTABLE hht, LPCTSTR lpszStr)
{
    return LookupItemInHashTable(hht, lpszStr, DELETEHASHITEM);
}

//--------------------------------------------------------------------------
// this sets the extra data in an HashItem

void WINAPI SetHashItemData(HHASHTABLE hht, LPCTSTR sz, int n, DWORD_PTR dwData)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    if ((pht != NULL) && (n >= 0) && (n < (int)(pht->cbExtra/SIZEOF(DWORD_PTR))))
        HIDATAARRAY(pht, sz)[n] = dwData;

    LEAVECRITICAL;
}

//======================================================================
// this is like SetHashItemData, except it gets the HashItem data...

DWORD_PTR WINAPI GetHashItemData(HHASHTABLE hht, LPCTSTR sz, int n)
{
    DWORD_PTR dwpRet;
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    if (pht != NULL && n <= (int)(pht->cbExtra/SIZEOF(DWORD_PTR)))
        dwpRet = HIDATAARRAY(pht, sz)[n];
    else
        dwpRet = 0;

    LEAVECRITICAL;
    return dwpRet;
}

//======================================================================
// like GetHashItemData, except it just gets a pointer to the buffer...

void * WINAPI GetHashItemDataPtr(HHASHTABLE hht, LPCTSTR sz)
{
    void *pvRet;
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either
    // string must be from the hash table
    ASSERT(FindHashItem(hht, sz) == sz);

    // the default hash table does not have extra data!
    pvRet = (pht? HIDATAPTR(pht, sz) : NULL);

    LEAVECRITICAL;
    return pvRet;
}

//======================================================================

PHASHTABLE _CreateHashTable(UINT uBuckets, UINT cbExtra)
{
    PHASHTABLE pht;

    if (uBuckets == 0)
        uBuckets = DEF_HASH_BUCKET_COUNT;

    pht = (PHASHTABLE)LocalAlloc(LPTR, SIZEOF(HASHTABLE) + uBuckets * SIZEOF(PHASHITEM));

    if (pht) 
    {
        pht->uBuckets = uBuckets;
        pht->cbExtra = (cbExtra + sizeof(DWORD_PTR) - 1) & ~(sizeof(DWORD_PTR)-1);  // rounding to the next DWORD_PTR size
        pht->pszHTCache = c_szHTNil;
    }
    return pht;
}


HHASHTABLE WINAPI CreateHashItemTable(UINT uBuckets, UINT cbExtra)
{
    PHASHTABLE *hht = NULL;
    PHASHTABLE pht;

    pht = _CreateHashTable(uBuckets, cbExtra);

    if (pht) 
    {
        hht = (PHASHTABLE *)LocalAlloc(LPTR, sizeof(PHASHTABLE));
        if (hht)
        {
            *hht = pht;
        }
        else
        {
            LocalFree(pht);
        }
    }

    TraceMsg(TF_HASH, "Created hash table %x(uBuckets=%x, cbExtra=%x)",
        pht, pht->uBuckets, pht->cbExtra);

    return hht;
}

//======================================================================

void WINAPI EnumHashItems(HHASHTABLE hht, HASHITEMCALLBACK callback, DWORD_PTR dwParam)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    if (!pht && g_hHashTable)
        pht = *g_hHashTable;

    if (pht) 
    {
        int i;
        PHASHITEM phi;
        PHASHITEM phiNext;
#ifdef DEBUG
        ULONG uCount = 0;
#endif

        for (i=0; i<(int)pht->uBuckets; i++) 
        {
            for (phi=pht->ahiBuckets[i]; phi; phi=phiNext) 
            {
                phiNext = phi->phiNext;
                (*callback)(hht, phi->szName, phi->wCount, dwParam);
#ifdef DEBUG
                uCount++;
#endif
            }
        }
        ASSERT(uCount == pht->uItems);
    }

    LEAVECRITICAL;
} 

//======================================================================

void _DeleteHashItem(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    _FreeHashItem(pht, HIFROMSZ(sz));
    LEAVECRITICAL;
} 

//======================================================================

void WINAPI DestroyHashItemTable(HHASHTABLE hht)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    ASSERT(!hht || pht); // If hht is not NULL, then pht can't be NULL either

    TraceMsg(TF_HASH, "DestroyHashItemTable(pht=%x)", pht);

    if (pht == NULL) 
    {
        if (g_hHashTable)
        {
            pht = *g_hHashTable;
            hht = g_hHashTable;
            g_hHashTable = NULL;
        }
    }

    if (pht) 
    {
        EnumHashItems(hht, _DeleteHashItem, 0);
        LocalFree(pht);
    }

    if (hht)
    {
        LocalFree(hht);
    }

    LEAVECRITICAL;
} 


//======================================================================

HHASHTABLE GetGlobalHashTable()
{
    if (!g_hHashTable)
    {
        ENTERCRITICAL;

        g_hHashTable = CreateHashItemTable(0, 0);

        LEAVECRITICAL;
    }

    return g_hHashTable;
}

//======================================================================

#ifdef DEBUG

static int TotalBytes;

void CALLBACK _DumpHashItem(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    DebugMsg(TF_ALWAYS, TEXT("    %08x %5ld \"%s\""), HIFROMSZ(sz), usage, sz);
    TotalBytes += (HIFROMSZ(sz)->cchLen * SIZEOF(TCHAR)) + SIZEOF(HASHITEM);
    LEAVECRITICAL;
}

void CALLBACK _DumpHashItemWithData(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR param)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    DebugMsg(TF_ALWAYS, TEXT("    %08x %5ld %08x \"%s\""), HIFROMSZ(sz), usage, HIDATAARRAY(pht, sz)[0], sz);
    TotalBytes += (HIFROMSZ(sz)->cchLen * SIZEOF(TCHAR)) + SIZEOF(HASHITEM) + (pht? pht->cbExtra : 0);

    LEAVECRITICAL;
}

void WINAPI DumpHashItemTable(HHASHTABLE hht)
{
    PHASHTABLE pht;

    ENTERCRITICAL;
    pht = hht ? *hht : NULL;
    TotalBytes = 0;

    if (IsFlagSet(g_dwDumpFlags, DF_HASH))
    {
        DebugMsg(TF_ALWAYS, TEXT("Hash Table: %08x"), pht);

        if (pht && (pht->cbExtra > 0)) {
            DebugMsg(TF_ALWAYS, TEXT("    Hash     Usage dwEx[0]  String"));
            DebugMsg(TF_ALWAYS, TEXT("    -------- ----- -------- ------------------------------"));
            EnumHashItems(hht, _DumpHashItemWithData, 0);
        }
        else {
            DebugMsg(TF_ALWAYS, TEXT("    Hash     Usage String"));
            DebugMsg(TF_ALWAYS, TEXT("    -------- ----- --------------------------------"));
            EnumHashItems(hht, _DumpHashItem, 0);
        }

        DebugMsg(TF_ALWAYS, TEXT("Total Bytes: %d"), TotalBytes);
    }
    LEAVECRITICAL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\futil.c ===
#include "shellprv.h"
#pragma  hdrstop
#include "netview.h"

// drivesx.c
DWORD PathGetClusterSize(LPCTSTR pszPath);

// get connection information including disconnected drives
//
// in:
//     pszDev   device name "A:" "LPT1:", etc.
//     bConvertClosed
//              if FALSE closed or error drives will be converted to
//              WN_SUCCESS return codes.  if TRUE return not connected
//              and error state values (ie, the caller knows about not
//              connected and error state drives)
//
// out:
//     lpPath   filled with net name if return is WN_SUCCESS (or not connected/error)
// returns:
//     WN_*     error code

DWORD GetConnection(LPCTSTR pszDev, LPTSTR pszPath, UINT cchPath, BOOL bConvertClosed)
{
    DWORD err;
    int iType = DriveType(DRIVEID(pszDev));
    if (DRIVE_REMOVABLE == iType || DRIVE_FIXED == iType || DRIVE_CDROM == iType || DRIVE_RAMDISK == iType)
        err = WN_NOT_CONNECTED;
    else
    {
        err = SHWNetGetConnection((LPTSTR)pszDev, pszPath, &cchPath);

        if (!bConvertClosed)
            if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
                err = WN_SUCCESS;
    }
    return err;
}

// this is called for every drive at init time so it must
// be sure to not trigget things like the phantom B: drive support
//
// in:
//      iDrive  zero based drive number (0 = A, 1 = B)
//
// returns:
//      0       not a net drive
//      1       is a net drive, properly connected
//      2       disconnected/error state connection

STDAPI_(int) IsNetDrive(int iDrive)
{
    if ((iDrive >= 0) && (iDrive < 26))
    {
        DWORD err;
        TCHAR szDrive[4], szConn[MAX_PATH];     // this really should be WNBD_MAX_LENGTH

        PathBuildRoot(szDrive, iDrive);

        err = GetConnection(szDrive, szConn, ARRAYSIZE(szConn), TRUE);

        if (err == WN_SUCCESS)
            return 1;

        if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
            if ((GetLogicalDrives() & (1 << iDrive)) == 0)
                return 2;
    }
    
    return 0;
}

typedef BOOL (WINAPI* PFNISPATHSHARED)(LPCTSTR pszPath, BOOL fRefresh);

HMODULE g_hmodShare = (HMODULE)-1;
PFNISPATHSHARED g_pfnIsPathShared = NULL;

// ask the share provider if this path is shared

BOOL IsShared(LPNCTSTR pszPath, BOOL fUpdateCache)
{
    TCHAR szPath[MAX_PATH];

    // See if we have already tried to load this in this context
    if (g_hmodShare == (HMODULE)-1)
    {
        DWORD cb = sizeof(szPath);

        g_hmodShare = NULL;     // asume failure

        if (ERROR_SUCCESS == SHRegGetValue(HKEY_CLASSES_ROOT, TEXT("Network\\SharingHandler"), NULL, SRRF_RT_REG_SZ, NULL, szPath, &cb)
            && szPath[0])
        {
            g_hmodShare = LoadLibrary(szPath);
            if (g_hmodShare)
                g_pfnIsPathShared = (PFNISPATHSHARED)GetProcAddress(g_hmodShare, "IsPathSharedW");
        }
    }

    if (g_pfnIsPathShared)
    {
#ifdef ALIGNMENT_SCENARIO
        ualstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
        return g_pfnIsPathShared(szPath, fUpdateCache);
#else        
        return g_pfnIsPathShared(pszPath, fUpdateCache);
#endif
    }

    return FALSE;
}

// invalidate the DriveType cache for one entry, or all
STDAPI_(void) InvalidateDriveType(int iDrive)
{}

#define ROUND_TO_CLUSER(qw, dwCluster)  ((((qw) + (dwCluster) - 1) / dwCluster) * dwCluster)

//
// GetCompresedFileSize is NT only, so we only implement the SHGetCompressedFileSizeW
// version. This will return the size of the file on disk rounded to the cluster size.
//
STDAPI_(DWORD) SHGetCompressedFileSizeW(LPCWSTR pszFileName, LPDWORD pFileSizeHigh)
{
    DWORD dwClusterSize;
    ULARGE_INTEGER ulSizeOnDisk;

    if (!pszFileName || !pszFileName[0])
    {
        ASSERT(FALSE);
        *pFileSizeHigh = 0;
        return 0;
    }

    dwClusterSize = PathGetClusterSize(pszFileName);

    ulSizeOnDisk.LowPart = GetCompressedFileSizeW(pszFileName, &ulSizeOnDisk.HighPart);

    if ((ulSizeOnDisk.LowPart == (DWORD)-1) && (GetLastError() != NO_ERROR))
    {
        WIN32_FILE_ATTRIBUTE_DATA fad;

        TraceMsg(TF_WARNING, "GetCompressedFileSize failed on %s (lasterror = %x)", pszFileName, GetLastError());

        if (GetFileAttributesExW(pszFileName, GetFileExInfoStandard, &fad))
        {
            // use the normal size, but round it to the cluster size
            ulSizeOnDisk.LowPart = fad.nFileSizeLow;
            ulSizeOnDisk.HighPart = fad.nFileSizeHigh;
            
            ROUND_TO_CLUSER(ulSizeOnDisk.QuadPart, dwClusterSize);
        }
        else
        {
            // since both GetCompressedFileSize and GetFileAttributesEx failed, we
            // just return zero
            ulSizeOnDisk.QuadPart = 0;
        }
    }

    // for files < one cluster, GetCompressedFileSize returns real size so we need
    // to round it up to one cluster
    if (ulSizeOnDisk.QuadPart < dwClusterSize)
    {
        ulSizeOnDisk.QuadPart = dwClusterSize;
    }

    *pFileSizeHigh = ulSizeOnDisk.HighPart;
    return ulSizeOnDisk.LowPart;
}

STDAPI_(BOOL) SHGetDiskFreeSpaceEx(LPCTSTR pszDirectoryName,
                                   PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                                   PULARGE_INTEGER pulTotalNumberOfBytes,
                                   PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    BOOL bRet = GetDiskFreeSpaceEx(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
    if (bRet)
    {
#ifdef DEBUG
        if (pulTotalNumberOfFreeBytes)
        {
            DWORD dw, dwSize = sizeof(dw);
            if (ERROR_SUCCESS == SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DiskSpace"),
                                                 pszDirectoryName, NULL, &dw, &dwSize, TRUE, NULL, 0))
            {
                pulTotalNumberOfFreeBytes->QuadPart = dw * (ULONGLONG)0x100000; // convert to MB
            }
        }
#endif
    }
    return bRet;
}

#ifdef UNICODE
BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName,
                           PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pulTotalNumberOfBytes,
                           PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    TCHAR szName[MAX_PATH];

    SHAnsiToTChar(pszDirectoryName, szName, SIZECHARS(szName));
    return SHGetDiskFreeSpaceEx(szName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
}
#else

BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName,
                           PULARGE_INTEGER pulFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pulTotalNumberOfBytes,
                           PULARGE_INTEGER pulTotalNumberOfFreeBytes)
{
    TCHAR szName[MAX_PATH];

    SHUnicodeToTChar(pszDirectoryName, szName, SIZECHARS(szName));
    return SHGetDiskFreeSpaceEx(szName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\help.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1992
//
// File: help.c
//
// History:
//  6 Apr 94    MikeSh  Created
//
//---------------------------------------------------------------------------

#include "shellprv.h"
#pragma  hdrstop
#include "printer.h"
#include "drives.h" // for ShowMountedVolumeProperties

//
// (internal) entry point for Help "Shortcuts".
//
STDAPI_(void) SHHelpShortcuts_RunDLL_Common(HWND hwndStub, HINSTANCE hAppInstance, LPCTSTR pszCmdLine, int nCmdShow)
{
    if (!lstrcmp(pszCmdLine, TEXT("AddPrinter")))
    {
        // install a new printer

        LPITEMIDLIST pidl = Printers_PrinterSetup(hwndStub, MSP_NEWPRINTER, (LPTSTR)c_szNewObject, 0, NULL);
        ILFree(pidl);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("PrintersFolder")))
    {
        // bring up the printers folder
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_PRINTERS), SW_SHOWNORMAL);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("FontsFolder")))
    {
        // bring up the printers folder
        InvokeFolderPidl(MAKEINTIDLIST(CSIDL_FONTS), SW_SHOWNORMAL);
    }
    else if (!lstrcmp(pszCmdLine, TEXT("Connect")))
    {
        SHNetConnectionDialog(hwndStub, NULL, RESOURCETYPE_DISK);
        goto FlushDisconnect;
    }
    else if (!lstrcmp(pszCmdLine, TEXT("Disconnect")))
    {
        WNetDisconnectDialog(hwndStub, RESOURCETYPE_DISK);
FlushDisconnect:
        SHChangeNotifyHandleEvents();   // flush any drive notifications
    }
#ifdef DEBUG
    else if (!StrCmpN(pszCmdLine, TEXT("PrtProp "), 8))
    {
        SHObjectProperties(hwndStub, SHOP_PRINTERNAME, &(pszCmdLine[8]), TEXT("Sharing"));
    }
    else if (!StrCmpN(pszCmdLine, TEXT("FileProp "), 9))
    {
        SHObjectProperties(hwndStub, SHOP_FILEPATH, &(pszCmdLine[9]), TEXT("Sharing"));
    }
#endif
}

VOID WINAPI SHHelpShortcuts_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPCSTR lpszCmdLine, int nCmdShow)
{
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        if (MultiByteToWideChar(CP_ACP, 0,
                                lpszCmdLine, -1,
                                lpwszCmdLine, iLen))
        {
            SHHelpShortcuts_RunDLL_Common( hwndStub,
                                           hAppInstance,
                                           lpwszCmdLine,
                                           nCmdShow );
        }
        LocalFree(lpwszCmdLine);
    }
}

VOID WINAPI SHHelpShortcuts_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPCWSTR lpwszCmdLine, int nCmdShow)
{
    SHHelpShortcuts_RunDLL_Common(hwndStub,hAppInstance,lpwszCmdLine,nCmdShow);
}

//
// SHObjectProperties is an easy way to call the verb "properties" on an object.
// It's easy because the caller doesn't have to deal with LPITEMIDLISTs.
// Note: SHExecuteEx(SEE_MASK_INVOKEIDLIST) works for the SHOP_FILEPATH case,
// but msshrui needs an easy way to do this for printers. Bummer.
//
STDAPI_(BOOL) SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCTSTR pszItem, LPCTSTR pszPage)
{
    LPITEMIDLIST pidl = NULL;

    switch (dwType & SHOP_TYPEMASK)
    {
    case SHOP_PRINTERNAME:
        ParsePrinterName(pszItem, &pidl);
        break;

    case SHOP_FILEPATH:
        //
        // NTRAID#NTBUG9-271529-2001/02/08-jeffreys
        //
        // Existing callers rely on ILCFP_FLAG_NO_MAP_ALIAS behavior.
        //
        ILCreateFromPathEx(pszItem, NULL, ILCFP_FLAG_NO_MAP_ALIAS, &pidl, NULL);
        break;

    case SHOP_VOLUMEGUID:
        return ShowMountedVolumeProperties(pszItem, hwndOwner);
    }

    if (pidl)
    {
        SHELLEXECUTEINFO sei =
        {
            sizeof(sei),
            SEE_MASK_INVOKEIDLIST,      // fMask
            hwndOwner,                  // hwnd
            c_szProperties,             // lpVerb
            NULL,                       // lpFile
            pszPage,                    // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            pidl,                       // lpIDList
            NULL,                       // lpClass
            0,                          // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        BOOL bRet = ShellExecuteEx(&sei);

        ILFree(pidl);

        return bRet;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hwctprmp.h ===
#ifndef HWCTPRMP_H
#define HWCTPRMP_H

#include "hwprompt.h"

#define MAX_DEVICENAME      50

class CHWContentPromptDlg : public CHWPromptDlg
{
public:
    CHWContentPromptDlg();

protected:
    virtual ~CHWContentPromptDlg();
    LRESULT OnOK(WORD wNotif);

    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings();

private:
    LPWSTR              _pszContentTypeHandler;
};

#endif //HWCTPRMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hwcmmn.h ===
#ifndef _HWCMMN_H
#define _HWCMMN_H

#define CT_AUTORUNINF                  0x00000001
#define CT_CDAUDIO                     0x00000002
#define CT_DVDMOVIE                    0x00000004
#define CT_UNKNOWNCONTENT              0x00000008
#define CT_BLANKCDR                    0x00000010
#define CT_BLANKCDRW                   0x00000020
#define CT_BLANKDVDR                   0x00000040
#define CT_BLANKDVDRW                  0x00000080
#define CT_AUTOPLAYMUSIC               0x00000100
#define CT_AUTOPLAYPIX                 0x00000200
#define CT_AUTOPLAYMOVIE               0x00000400

// Will not be returned by CMountPoint::GetContentType
#define CT_AUTOPLAYMIXEDCONTENT        0x00000800

#define CT_ANYCONTENT                  0x00000FFF

#define CT_ANYAUTOPLAYCONTENT          (   CT_AUTOPLAYMUSIC | \
                                                        CT_AUTOPLAYPIX | \
                                                        CT_AUTOPLAYMOVIE)

#define CT_BLANKCDWRITABLE             (   CT_BLANKCDR | \
                                                        CT_BLANKCDRW )

#define CT_BLANKDVDWRITABLE            (   CT_BLANKDVDR | \
                                                        CT_BLANKDVDRW )

BOOL IsShellServiceRunning();

HRESULT _GetAutoplayHandler(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszContentTypeHandler, IAutoplayHandler** ppiah);

HRESULT _GetAutoplayHandlerNoContent(LPCWSTR pszDeviceID, LPCWSTR pszEventType,
    IAutoplayHandler** ppiah);

HRESULT _GetHWDevice(LPCWSTR pszDeviceID, IHWDevice** ppihwdevice);

STDAPI GetDeviceProperties(LPCWSTR pszDeviceID, IHWDeviceCustomProperties** ppihwdevcp);

HICON _GetIconFromIconLocation(LPCWSTR pszIconLocation, BOOL fBigIcon);

HRESULT _GetDeviceEventFriendlyName(LPCWSTR pszDeviceID, LPWSTR* ppsz);

HRESULT _GetHardwareDevices(IHardwareDevices** ppihwdevices);

HRESULT _GetContentTypeInfo(DWORD dwContentType, LPWSTR pszContentTypeFriendlyName,
    DWORD cchContentTypeFriendlyName, LPWSTR pszContentTypeIconLocation,
    DWORD cchContentTypeIconLocation);

HRESULT _GetContentTypeHandler(DWORD dwContentType, LPWSTR pszContentTypeHandler,
    DWORD cchContentTypeHandler);

HRESULT _GetHandlerInvokeProgIDAndVerb(LPCWSTR pszHandler, LPWSTR pszInvokeProgID,
    DWORD cchInvokeProgID, LPWSTR pszInvokeVerb, DWORD cchInvokeVerb);

struct AUTOPLAYPROMPT
{
    WCHAR                       szDriveOrDeviceID[MAX_PATH];
    BOOL                        fDlgWillBeShown;
    HWND                        hwndDlg;
    class CCrossThreadFlag*     pDeviceGoneFlag;
};

HRESULT DoDeviceNotification(LPCTSTR pszDevice, LPCTSTR pszEventType, CCrossThreadFlag* pDeviceGoneFlag);

BOOL GetGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag** ppDeviceGoneFlag);
void AttachGoneFlagForDevice(LPCWSTR pszAltDeviceID, CCrossThreadFlag* pDeviceGoneFlag);

BOOL IsMixedContent(DWORD dwContentType);

class CRefCounted
{
public:
    CRefCounted() : _cRCRef(1) {}
    virtual ~CRefCounted() {}

    ULONG AddRef() { return ::InterlockedIncrement((LONG*)&_cRCRef); }
    ULONG Release()
    {
        ASSERT( 0 != _cRCRef );
        ULONG cRef = ::InterlockedDecrement((LONG*)&_cRCRef);

        if (!cRef)
        {
            delete this;
        }

        return cRef;
    }

private:
    ULONG _cRCRef; // RC: to avoid name colision
};

// The event is created in the NON-signaled state
// Since it's cross-thread it should always be created on the heap
class CCrossThreadFlag : public CRefCounted
{
public:
    BOOL Init();
    BOOL Signal();
    BOOL IsSignaled();

private:
    ~CCrossThreadFlag();

    HANDLE _hEvent;
#ifdef DEBUG
    BOOL _fInited;
#endif
};

#endif //_HWCMMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hwshlexc.cpp ===
#include "shellprv.h"
#include "clsobj.h"

#include "shobjidl.h"


HRESULT CoMarshallToCmdLine(REFIID riid, IUnknown *punk, LPTSTR pszCmdLine, UINT cch);
HRESULT CoUnmarshalFromCmdLine(LPCTSTR pszCmdLine, REFIID riid, void **ppv);

class CHWShellExecute : public IHWEventHandler
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IHWEventHandler methods
    STDMETHODIMP Initialize(LPCWSTR pszParams);
    STDMETHODIMP HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType);
    STDMETHODIMP HandleEventWithContent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

protected:
    CHWShellExecute();
    ~CHWShellExecute();

    friend HRESULT CHWShellExecute_CreateInstance(IUnknown* pUnkOuter,
        REFIID riid, void **ppv);

private:
    LONG            _cRef;
    LPWSTR          _pszParams;
};

CHWShellExecute::CHWShellExecute() : _cRef(1)
{
    DllAddRef();
}

CHWShellExecute::~CHWShellExecute()
{
    CoTaskMemFree(_pszParams);
    DllRelease();
}

STDAPI CHWShellExecute_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    
    // aggregation checking is handled in class factory
    CHWShellExecute* pHWShellExecute = new CHWShellExecute();

    if (pHWShellExecute)
    {
        hr = pHWShellExecute->QueryInterface(riid, ppv);
        pHWShellExecute->Release();
    }

    return hr;
}

// IUnknown
STDMETHODIMP CHWShellExecute::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CHWShellExecute, IHWEventHandler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CHWShellExecute::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CHWShellExecute::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IHWEventHandler
STDMETHODIMP CHWShellExecute::Initialize(LPCWSTR pszParams)
{
        ASSERT(NULL == _pszParams);
    return SHStrDup(pszParams, &_pszParams);
}

STDMETHODIMP CHWShellExecute::HandleEvent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    return HandleEventWithContent(pszDeviceID, pszAltDeviceID, pszEventType, NULL, NULL);
}

// pszDeviceID == \\?\STORAGE#RemoveableMedia#9&16...
// pszAltDeviceID == "F:\" (if the device is storage)

STDMETHODIMP CHWShellExecute::HandleEventWithContent(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, 
                                                     LPCWSTR pszEventType, LPCWSTR pszContentTypeHandler, 
                                                     IDataObject* pdtobj)
{
    HRESULT hr;

    if (_pszParams)
    {
        // make copy of _pszParams to make sure we don't mess up our state
        // when we parse the params into the parts

        TCHAR szApp[MAX_PATH + MAX_PATH], szArgs[INTERNET_MAX_URL_LENGTH];
        hr = StringCchCopy(szApp, ARRAYSIZE(szApp), _pszParams);

        if (SUCCEEDED(hr))
        {
            // this code is a generic dispatcher of the data object to apps
            // those that need to work over a potentially large set of file names

            hr = PathSeperateArgs(szApp, szArgs, ARRAYSIZE(szArgs), NULL);
            if (SUCCEEDED(hr))
            {
                if (pdtobj)
                {
#if DEBUG
                    TCHAR szText[1024];
                    if (SUCCEEDED(CoMarshallToCmdLine(IID_IDataObject, pdtobj, szText, ARRAYSIZE(szText))))
                    {
                        IDataObject *pdtobjNew;
                        if (SUCCEEDED(CoUnmarshalFromCmdLine(szText, IID_PPV_ARG(IDataObject, &pdtobjNew))))
                        {
                            pdtobjNew->Release();
                        }
                    }
#endif
                    // here we convert the data object into a cmd line form
                    // there are 2 ways we do that now...
                    //
                    //  %Files%         - gives all of the data object files expanded on the cmd line
                    //  %DataObject%    - marshaled data object on cmd line

                    LPTSTR pszFiles = StrStrI(szArgs, TEXT("%Files%"));
                    if (NULL == pszFiles)
                        pszFiles = StrStrI(szArgs, TEXT("%F:"));    // old syntax support

                    if (pszFiles)
                    {
                        *pszFiles = 0;  // start empty
                        UINT cch = (UINT)(ARRAYSIZE(szArgs) - (pszFiles - szArgs));

                        // this expands all of the file names into a cmd line
                        // lets hope we don't have too many files as this has a fixed
                        // length buffer

                        STGMEDIUM medium = {0};
                        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                        hr = pdtobj->GetData(&fmte, &medium);
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szPath[MAX_PATH];

                            for (int i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                            {
                                LPTSTR pszNext;
                                size_t cchLeft;

                                if (SUCCEEDED(StringCchCatEx(pszFiles, cch, TEXT("\""), &pszNext, &cchLeft, 0)))
                                {
                                    if (SUCCEEDED(StringCchCopyEx(pszNext, cchLeft, szPath, &pszNext, &cchLeft, 0)))
                                    {
                                        if (FAILED(StringCchCopy(pszNext, cchLeft, TEXT("\" "))))
                                        {
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                            ReleaseStgMedium(&medium);
                        }
                    }
                    else
                    {
                        // prefered way to do this, this convert the data object into a
                        // marshaled cmd line that we can pass all of the files through

                        pszFiles = StrStrI(szArgs, TEXT("%DataObject%"));
                        if (pszFiles)
                        {
                            CoMarshallToCmdLine(IID_IDataObject, pdtobj, pszFiles, (UINT)(ARRAYSIZE(szArgs) - (pszFiles - szArgs)));
                        }
                    }
                }

                // special case if app is empty and there is a "alt device" (file system root)
                // this must be "Open Folder" mode

                if ((0 == szApp[0]) && pszAltDeviceID)
                {
                    hr = StringCchCopy(szApp, ARRAYSIZE(szApp), pszAltDeviceID);  // "F:\"
                }

                if (SUCCEEDED(hr))
                {
                    if (szApp[0])
                    {
                        SHELLEXECUTEINFO ei = {0};
                        ei.cbSize = sizeof(ei);

                        ei.lpFile = szApp;          // we have an app name
                        ei.lpParameters = szArgs;   // and maybe some args
                        ei.nShow = SW_SHOW;
                        ei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;

                        hr = ShellExecuteEx(&ei) ? S_OK : E_FAIL;
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CoMarshallToCmdLine(REFIID riid, IUnknown *punk, LPTSTR pszCmdLine, UINT cch)
{
    *pszCmdLine = 0;

    IStream *pstm;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (SUCCEEDED(hr)) 
    {
        hr = CoMarshalInterface(pstm, riid, punk, MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        if (SUCCEEDED(hr))
        {
            IStream_Reset(pstm);

            char buf[255]; // big enough for a standard marshall record
            ULONG cb;
            hr = pstm->Read(buf, sizeof(buf), &cb);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(pszCmdLine, cch, TEXT("/DataObject:"));

                if (SUCCEEDED(hr))
                {
                    pszCmdLine += lstrlen(pszCmdLine);
                    // convert binary buffer to hex
                    for (ULONG i = 0; i < cb; i++)
                    {
                        *pszCmdLine++ = 'A' +  (0x0F & buf[i]);
                        *pszCmdLine++ = 'A' + ((0xF0 & buf[i]) >> 4);
                    }
                    *pszCmdLine = 0;
                }
            }
        }
        pstm->Release();
    }
    return hr;
}

HRESULT CoUnmarshalFromCmdLine(LPCTSTR pszCmdLine, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    pszCmdLine = StrStr(pszCmdLine, TEXT("/DataObject:"));
    if (pszCmdLine)
    {
        pszCmdLine += lstrlen(TEXT("/DataObject:"));

        char buf[255]; // big enough for standard marshall buffer (which is 68 bytes)
        for (ULONG cb = 0; *pszCmdLine && (cb < sizeof(buf)); cb++)
        {
            buf[cb] = (*pszCmdLine - 'A') + ((*(pszCmdLine + 1) - 'A') << 4);
            if (*(pszCmdLine + 1))
                pszCmdLine += 2;
            else
                break;  // odd # of chars in cmd line, error
        }

        if (cb < sizeof(buf))
        {
            IStream *pstm;
            hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
            if (SUCCEEDED(hr)) 
            {
                // fill the marshall stream
                pstm->Write(buf, cb, NULL);

                // move back to start of stream
                IStream_Reset(pstm);

                hr = CoUnmarshalInterface(pstm, riid, ppv);

                pstm->Release();
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\hwprompt.h ===
#ifndef HWPROMPT_H
#define HWPROMPT_H

#include "basedlg.h"

#define MAX_DEVICENAME      50

class CHWPromptDlg : public CBaseDlg
{
public:
    CHWPromptDlg();

    HRESULT Init(LPCWSTR pszDeviceID);

protected:
    virtual ~CHWPromptDlg();
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

protected:
    virtual HRESULT _FillListView() = 0;
    virtual HRESULT _InitStatics() = 0;
    virtual HRESULT _InitSelections() = 0;

protected:
    HRESULT _InitStaticsCommon();
    HRESULT _SelectListItem(int i);
    HRESULT _SelectRadio(int i);
    HRESULT _GetSelection(int* pi);

private:
    HRESULT _InitListView();
    HRESULT _SetDeviceName();
    HRESULT _SetTitle();
    HRESULT _OnListSelChange();
    HRESULT _OnRadio(int iButton);

protected:
    virtual LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

private:
    BOOL                _fTriedDeviceName;
    HICON               _hiconInfo;

protected:
    WCHAR               _szDeviceName[MAX_DEVICENAME];
    HICON               _hiconTop;

public:
    LPWSTR              _pszDeviceID;
    BOOL                _fOpenFolder;
    WCHAR               _szContentTypeHandler[256];
    BOOL                _fHandler;
};

#endif //HWPROMPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idldrop.h ===
#ifndef __IDLDROP_H__
#define __IDLDROP_H__


typedef struct {
    DWORD        dwDefEffect;
    IDataObject *pdtobj;
    POINTL       pt;
    DWORD *      pdwEffect;
    HKEY         hkeyProgID;
    HKEY         hkeyBase;
    UINT         idMenu;
    UINT         idCmd;
    DWORD        grfKeyState;
} DRAGDROPMENUPARAM;

class CIDLDropTarget: public IDropTarget
{
public:
    CIDLDropTarget(HWND hwnd);
    HRESULT _Init(LPCITEMIDLIST pidl);
    HWND _GetWindow();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget methods.
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    virtual ~CIDLDropTarget();
    HRESULT DragDropMenu(DWORD dwDefaultEffect, IDataObject *pdtobj, POINTL pt, DWORD *pdwEffect, HKEY hkeyProgID, HKEY hkeyBase, UINT idMenu, DWORD grfKeyState);
    HRESULT DragDropMenuEx(DRAGDROPMENUPARAM *pddm);

private:
    LONG m_cRef;

protected:
    HWND                m_hwnd;
    LPITEMIDLIST        m_pidl;                 // IDList to the target folder
    DWORD               m_grfKeyStateLast;      // for previous DragOver/Enter
    IDataObject        *m_pdtobj;
    DWORD               m_dwEffectLastReturned; // stashed effect that's returned by base class's dragover
    DWORD               m_dwData;               // DTID_*
    DWORD               m_dwEffectPreferred;    // if dwData & DTID_PREFERREDEFFECT
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idldata.h ===
#ifndef __IDLDATA_H__
#define __IDLDATA_H__

#include "idlcomm.h"

#define MAX_FORMATS     ICF_MAX

STDAPI CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj);

class CIDLDataObj : public IDataObject, public IAsyncOperation
{
friend HRESULT CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj);
protected:
    CIDLDataObj(IDataObject *pdtInner);
    CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]);
    CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner);
    virtual ~CIDLDataObj(void);

public:
    void InitIDLData1(IDataObject *pdtInner);
    void InitIDLData2(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP GetDataHere(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFmtEtcIn, FORMATETC *pFmtEtcOut);
    STDMETHODIMP SetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(FORMATETC *pFmtEtc, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);

    // IAsyncOperation
    STDMETHODIMP SetAsyncMode(BOOL fDoOpAsync);
    STDMETHODIMP GetAsyncMode(BOOL *pfIsOpAsync);
    STDMETHODIMP StartOperation(IBindCtx * pbc);
    STDMETHODIMP InOperation(BOOL * pfInAsyncOp);
    STDMETHODIMP EndOperation(HRESULT hResult, IBindCtx * pbc, DWORD dwEffects);

private:
    LONG _cRef;
    IDataObject *_pdtInner;
    IUnknown *_punkThread;
    BOOL _fEnumFormatCalled;    // TRUE once called.
    BOOL _fDidAsynchStart;
    FORMATETC _fmte[MAX_FORMATS];
    STGMEDIUM _medium[MAX_FORMATS];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idldata.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "bookmk.h"

#include "idldata.h"
#include "datautil.h"
#include <brfcasep.h>

// External prototypes

CLIPFORMAT g_acfIDLData[ICF_MAX] = { CF_HDROP, 0 };

#define RCF(x)  (CLIPFORMAT) RegisterClipboardFormat(x)

STDAPI_(void) IDLData_InitializeClipboardFormats(void)
{
    if (g_cfBriefObj == 0)
    {
        g_cfHIDA                       = RCF(CFSTR_SHELLIDLIST);
        g_cfOFFSETS                    = RCF(CFSTR_SHELLIDLISTOFFSET);
        g_cfNetResource                = RCF(CFSTR_NETRESOURCES);
        g_cfFileContents               = RCF(CFSTR_FILECONTENTS);         // "FileContents"
        g_cfFileGroupDescriptorA       = RCF(CFSTR_FILEDESCRIPTORA);      // "FileGroupDescriptor"
        g_cfFileGroupDescriptorW       = RCF(CFSTR_FILEDESCRIPTORW);      // "FileGroupDescriptor"
        g_cfPrivateShellData           = RCF(CFSTR_SHELLIDLISTP);
        g_cfFileNameA                  = RCF(CFSTR_FILENAMEA);            // "FileName"
        g_cfFileNameW                  = RCF(CFSTR_FILENAMEW);            // "FileNameW"
        g_cfFileNameMapA               = RCF(CFSTR_FILENAMEMAP);          // "FileNameMap"
        g_cfFileNameMapW               = RCF(CFSTR_FILENAMEMAPW);         // "FileNameMapW"
        g_cfPrinterFriendlyName        = RCF(CFSTR_PRINTERGROUP);
        g_cfHTML                       = RCF(TEXT("HTML Format"));
        g_cfPreferredDropEffect        = RCF(CFSTR_PREFERREDDROPEFFECT);  // "Preferred DropEffect"
        g_cfPerformedDropEffect        = RCF(CFSTR_PERFORMEDDROPEFFECT);  // "Performed DropEffect"
        g_cfLogicalPerformedDropEffect = RCF(CFSTR_LOGICALPERFORMEDDROPEFFECT); // "Logical Performed DropEffect"
        g_cfPasteSucceeded             = RCF(CFSTR_PASTESUCCEEDED);       // "Paste Succeeded"
        g_cfShellURL                   = RCF(CFSTR_SHELLURL);             // "Uniform Resource Locator"
        g_cfInDragLoop                 = RCF(CFSTR_INDRAGLOOP);           // "InShellDragLoop"
        g_cfDragContext                = RCF(CFSTR_DRAGCONTEXT);          // "DragContext"
        g_cfTargetCLSID                = RCF(CFSTR_TARGETCLSID);          // "TargetCLSID", who the drag drop went to
        g_cfEmbeddedObject             = RCF(TEXT("Embedded Object"));
        g_cfObjectDescriptor           = RCF(TEXT("Object Descriptor"));
        g_cfNotRecyclable              = RCF(TEXT("NotRecyclable"));      // This object is not recyclable in the recycle bin.
        g_cfBriefObj                   = RCF(CFSTR_BRIEFOBJECT);
        g_cfText                       = CF_TEXT;
        g_cfUnicodeText                = CF_UNICODETEXT;
        g_cfDropEffectFolderList       = RCF(CFSTR_DROPEFFECTFOLDERLIST);
        g_cfAutoPlayHIDA               = RCF(CFSTR_AUTOPLAY_SHELLIDLISTS);
    }
}

STDMETHODIMP CIDLDataObj::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CIDLDataObj, IDataObject),  
        QITABENT(CIDLDataObj, IAsyncOperation),     
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CIDLDataObj::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CIDLDataObj::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CIDLDataObj::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    pmedium->hGlobal = NULL;
    pmedium->pUnkForRelease = NULL;

    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if ((_fmte[i].cfFormat == pformatetcIn->cfFormat) &&
            (_fmte[i].tymed & pformatetcIn->tymed) &&
            (_fmte[i].dwAspect == pformatetcIn->dwAspect))
        {
            *pmedium = _medium[i];

            if (pmedium->hGlobal)
            {
                // Indicate that the caller should not release hmem.
                if (pmedium->tymed == TYMED_HGLOBAL)
                {
                    InterlockedIncrement(&_cRef);
                    pmedium->pUnkForRelease = SAFECAST(this, IDataObject *);
                    return S_OK;
                }

                // if the type is stream  then clone the stream.
                if (pmedium->tymed == TYMED_ISTREAM)
                {
                    hr = CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm);
                    if (SUCCEEDED(hr))
                    {
                        STATSTG stat;

                         // Get the Current Stream size
                         hr = _medium[i].pstm->Stat(&stat, STATFLAG_NONAME);
                         if (SUCCEEDED(hr))
                         {
                            // Seek the source stream to  the beginning.
                            _medium[i].pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // Copy the entire source into the destination. Since the destination stream is created using 
                            // CreateStreamOnHGlobal, it seek pointer is at the beginning.
                            hr = _medium[i].pstm->CopyTo(pmedium->pstm, stat.cbSize, NULL,NULL );
                            
                            // Before returning Set the destination seek pointer back at the beginning.
                            pmedium->pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // If this medium has a punk for release, make sure to add ref that...
                            pmedium->pUnkForRelease = _medium[i].pUnkForRelease;
                            if (pmedium->pUnkForRelease)
                                pmedium->pUnkForRelease->AddRef();

                            //Hoooh its done. 
                            return hr;

                         }
                         else
                         {
                             hr = E_OUTOFMEMORY;
                         }
                    }
                }
                
            }
        }
    }

    if (hr == E_INVALIDARG && _pdtInner) 
        hr = _pdtInner->GetData(pformatetcIn, pmedium);

    return hr;
}

STDMETHODIMP CIDLDataObj::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
#ifdef DEBUG
    if (pformatetc->cfFormat<CF_MAX) 
    {
        TraceMsg(TF_IDLIST, "CIDLDataObj::GetDataHere called with %x,%x,%x",
                 pformatetc->cfFormat, pformatetc->tymed, pmedium->tymed);
    }
    else 
    {
        TCHAR szName[256];

        GetClipboardFormatName(pformatetc->cfFormat, szName, ARRAYSIZE(szName));
        TraceMsg(TF_IDLIST, "CIDLDataObj::GetDataHere called with %s,%x,%x",
                 szName, pformatetc->tymed, pmedium->tymed);
    }
#endif

    return _pdtInner ? _pdtInner->GetDataHere(pformatetc, pmedium) : E_NOTIMPL;
}

STDMETHODIMP CIDLDataObj::QueryGetData(FORMATETC *pformatetcIn)
{
#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) 
    {
        TraceMsg(TF_IDLIST, "CIDLDataObj::QueryGetData called with %x,%x",
                             pformatetcIn->cfFormat, pformatetcIn->tymed);
    }
    else 
    {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        TraceMsg(TF_IDLIST, "CIDLDataObj::QueryGetData called with %s,%x",
                             szName, pformatetcIn->tymed);
    }
#endif

    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if ((_fmte[i].cfFormat == pformatetcIn->cfFormat) &&
            (_fmte[i].tymed & pformatetcIn->tymed) &&
            (_fmte[i].dwAspect == pformatetcIn->dwAspect))
            return S_OK;
    }

    HRESULT hr = S_FALSE;
    if (_pdtInner)
        hr = _pdtInner->QueryGetData(pformatetcIn);
    return hr;
}

STDMETHODIMP CIDLDataObj::GetCanonicalFormatEtc(FORMATETC *pformatetc, FORMATETC *pformatetcOut)
{
    // This is the simplest implemtation. It means we always return
    // the data in the format requested.
    return DATA_S_SAMEFORMATETC;
}

STDMETHODIMP CIDLDataObj::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr;

    ASSERT(pformatetc->tymed == pmedium->tymed);

    if (fRelease)
    {
        // first add it if that format is already present
        // on a NULL medium (render on demand)
        for (int i = 0; i < MAX_FORMATS; i++)
        {
            if ((_fmte[i].cfFormat == pformatetc->cfFormat) &&
                (_fmte[i].tymed    == pformatetc->tymed) &&
                (_fmte[i].dwAspect == pformatetc->dwAspect))
            {
                //
                // We are simply adding a format, ignore.
                //
                if (pmedium->hGlobal == NULL)
                    return S_OK;

                // if we are set twice on the same object
                if (_medium[i].hGlobal)
                    ReleaseStgMedium(&_medium[i]);

                _medium[i] = *pmedium;
                return S_OK;
            }
        }

        //
        //  This is a new clipboard format.  Give the inner a chance first.
        //  This is important for formats like "Performed DropEffect" and
        //  "TargetCLSID", which are used by us to communicate information
        //  into the data object.
        //
        if (_pdtInner == NULL ||
            FAILED(hr = _pdtInner->SetData(pformatetc, pmedium, fRelease)))
        {
            // Inner object doesn't want it; let's keep it ourselves
            // now look for a free slot
            for (i = 0; i < MAX_FORMATS; i++)
            {
                if (_fmte[i].cfFormat == 0)
                {
                    // found a free slot
                    _medium[i] = *pmedium;
                    _fmte[i] = *pformatetc;
                    return S_OK;
                }
            }
            // fixed size table
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        if (_pdtInner)
            hr = _pdtInner->SetData(pformatetc, pmedium, fRelease);
        else
            hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CIDLDataObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    // If this is the first time, build the format list by calling
    // QueryGetData with each clipboard format.
    if (!_fEnumFormatCalled)
    {
        UINT ifmt;
        FORMATETC fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
        for (ifmt = 0; ifmt < ICF_MAX; ifmt++)
        {
            fmte.cfFormat = g_acfIDLData[ifmt];
            if (QueryGetData(&fmte) == S_OK) 
            {
                SetData(&fmte, &medium, TRUE);
            }
        }
        _fEnumFormatCalled = TRUE;
    }

    // Get the number of formatetc
    for (UINT cfmt = 0; cfmt < MAX_FORMATS; cfmt++)
    {
        if (_fmte[cfmt].cfFormat == 0)
            break;
    }

    return SHCreateStdEnumFmtEtcEx(cfmt, _fmte, _pdtInner, ppenumFormatEtc);
}

STDMETHODIMP CIDLDataObj::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CIDLDataObj::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP CIDLDataObj::EnumDAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

// *** IAsyncOperation methods ***

HRESULT CIDLDataObj::SetAsyncMode(BOOL fDoOpAsync)
{ 
    return E_NOTIMPL;
}

HRESULT CIDLDataObj::GetAsyncMode(BOOL *pfIsOpAsync)
{
    if (_punkThread || IsMainShellProcess())
    {
        *pfIsOpAsync = TRUE;
    }
    else
    {
        *pfIsOpAsync = FALSE;
    }
    return S_OK;
}
  
HRESULT CIDLDataObj::StartOperation(IBindCtx * pbc)
{
    _fDidAsynchStart = TRUE;
    return S_OK;
}
  
HRESULT CIDLDataObj::InOperation(BOOL * pfInAsyncOp)
{
    if (_fDidAsynchStart)
    {
        *pfInAsyncOp = TRUE;
    }
    else
    {
        *pfInAsyncOp = FALSE;
    }
    return S_OK;
}
  
HRESULT CIDLDataObj::EndOperation(HRESULT hResult, IBindCtx * pbc, DWORD dwEffects)
{
    _fDidAsynchStart = FALSE;
    return S_OK;
}

void CIDLDataObj::InitIDLData1(IDataObject *pdtInner)
{
    _cRef = 1;
    _pdtInner = pdtInner;
    if (pdtInner)
        pdtInner->AddRef();
    SHGetThreadRef(&_punkThread);
}

void CIDLDataObj::InitIDLData2(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[])
{
    if (apidl)
    {
        HIDA hida = HIDA_Create(pidlFolder, cidl, apidl);
        if (hida)
        {
            IDLData_InitializeClipboardFormats(); // init our registerd formats

            DataObj_SetGlobal(this, g_cfHIDA, hida);
        }
    }
}

CIDLDataObj::CIDLDataObj(IDataObject *pdtInner)
{
    InitIDLData1(pdtInner);
}

CIDLDataObj::CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner)
{
    InitIDLData1(pdtInner);
    InitIDLData2(pidlFolder, cidl, apidl);
}

CIDLDataObj::CIDLDataObj(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[])
{
    InitIDLData1(NULL);
    InitIDLData2(pidlFolder, cidl, apidl);
}

CIDLDataObj::~CIDLDataObj()
{
    for (int i = 0; i < MAX_FORMATS; i++)
    {
        if (_medium[i].hGlobal)
            ReleaseStgMedium(&_medium[i]);
    }

    if (_pdtInner)
        _pdtInner->Release();

    if (_punkThread)
        _punkThread->Release();
}

//
// Create an instance of CIDLDataObj with default Vtable pointer.
//
STDAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject **ppdtobj)
{
    return CIDLData_CreateInstance(pidlFolder, cidl, apidl, NULL, ppdtobj);
}

HRESULT CIDLData_CreateInstance(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject *pdtInner, IDataObject **ppdtobj)
{
    *ppdtobj = new CIDLDataObj(pidlFolder, cidl, apidl, pdtInner);
    return *ppdtobj ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idlist.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "idlcomm.h"
#include "datautil.h"

#ifdef DEBUG
// Dugging aids for making sure we dont use free pidls
#define VALIDATE_PIDL(pidl) ASSERT(IS_VALID_PIDL(pidl))
#else
#define VALIDATE_PIDL(pidl)
#endif

STDAPI_(LPITEMIDLIST) ILGetNext(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    if (pidl && pidl->mkid.cb)
    {
        VALIDATE_PIDL(pidl);
        pidlRet = _ILNext(pidl);
    }

    return pidlRet;
}

STDAPI_(UINT) ILGetSizeAndDepth(LPCITEMIDLIST pidl, DWORD *pdwDepth)
{
    DWORD dwDepth = 0;
    UINT cbTotal = 0;
    if (pidl)
    {
        VALIDATE_PIDL(pidl);
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
            dwDepth++;
        }
    }

    if (pdwDepth)
        *pdwDepth = dwDepth;
        
    return cbTotal;
}

STDAPI_(UINT) ILGetSize(LPCITEMIDLIST pidl)
{
    return ILGetSizeAndDepth(pidl, NULL);
}

#define CBIDL_MIN       256
#define CBIDL_INCL      256

STDAPI_(LPITEMIDLIST) ILCreate()
{
    return _ILCreate(CBIDL_MIN);
}

// cbExtra is the amount to add to cbRequired if the block needs to grow,
// or it is 0 if we want to resize to the exact size

STDAPI_(LPITEMIDLIST) ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra)
{
    if (pidl == NULL)
    {
        pidl = _ILCreate(cbRequired + cbExtra);
    }
    else if (!cbExtra || SHGetSize(pidl) < cbRequired)
    {
        pidl = (LPITEMIDLIST)SHRealloc(pidl, cbRequired + cbExtra);
    }
    return pidl;
}

STDAPI_(LPITEMIDLIST) ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend)
{
    // Create the ID list, if it is not given.
    if (!pidl)
    {
        pidl = ILCreate();
        if (!pidl)
            return NULL;        // memory overflow
    }

    UINT cbUsed = ILGetSize(pidl);
    UINT cbRequired = cbUsed + pmkid->cb;

    pidl = ILResize(pidl, cbRequired, CBIDL_INCL);
    if (!pidl)
        return NULL;    // memory overflow

    if (fAppend)
    {
        // Append it.
        MoveMemory(_ILSkip(pidl, cbUsed - sizeof(pidl->mkid.cb)), pmkid, pmkid->cb);
    }
    else
    {
        // Put it at the top
        MoveMemory(_ILSkip(pidl, pmkid->cb), pidl, cbUsed);
        MoveMemory(pidl, pmkid, pmkid->cb);

        ASSERT((ILGetSize(_ILNext(pidl))==cbUsed) ||
               (pmkid->cb == 0)); // if we're prepending the empty pidl, nothing changed
    }

    // We must put zero-terminator because of LMEM_ZEROINIT.
    _ILSkip(pidl, cbRequired - sizeof(pidl->mkid.cb))->mkid.cb = 0;
    ASSERT(ILGetSize(pidl) == cbRequired);

    return pidl;
}


STDAPI_(LPITEMIDLIST) ILFindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (pidl == NULL)
        return NULL;

    VALIDATE_PIDL(pidl);

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = _ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}


STDAPI_(BOOL) ILRemoveLastID(LPITEMIDLIST pidl)
{
    BOOL fRemoved = FALSE;

    if (pidl == NULL)
        return FALSE;

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastID(pidl);

        ASSERT(pidlLast->mkid.cb);
        ASSERT(_ILNext(pidlLast)->mkid.cb==0);

        // Remove the last one
        pidlLast->mkid.cb = 0; // null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

STDAPI_(LPITEMIDLIST) ILClone(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        UINT cb = ILGetSize(pidl);
        LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);
        if (pidlRet)
            memcpy(pidlRet, pidl, cb);

        return pidlRet;
    }
    return NULL;
}


STDAPI_(LPITEMIDLIST) ILCloneCB(LPCITEMIDLIST pidl, UINT cbPidl)
{
    UINT cb = cbPidl + sizeof(pidl->mkid.cb);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);
    if (pidlRet)
    {
        memcpy(pidlRet, pidl, cbPidl);
        // cbPidl can be odd, must use UNALIGNED
        *((UNALIGNED WORD *)((BYTE *)pidlRet + cbPidl)) = 0;  // NULL terminate
    }
    return pidlRet;
}

STDAPI_(LPITEMIDLIST) ILCloneUpTo(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlUpTo)
{
    return ILCloneCB(pidl, (UINT)((BYTE *)pidlUpTo - (BYTE *)pidl));
}

STDAPI_(LPITEMIDLIST) ILCloneFirst(LPCITEMIDLIST pidl)
{
    return ILCloneCB(pidl, pidl->mkid.cb);
}

STDAPI_(BOOL) ILIsEqualEx(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMatchDepth, LPARAM lParam)
{
    BOOL fRet = FALSE;
    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);

    if (pidl1 == pidl2)
        fRet = TRUE;
    else
    {
        DWORD dw1;
        UINT cb1 = ILGetSizeAndDepth(pidl1, &dw1);
        DWORD dw2;
        UINT cb2 = ILGetSizeAndDepth(pidl2, &dw2);
        if (!fMatchDepth || dw1 == dw2)
        {
            if (cb1 == cb2 && memcmp(pidl1, pidl2, cb1) == 0)
                fRet = TRUE;
            else
            {
                IShellFolder *psfDesktop;
                if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
                {
                    if (psfDesktop->CompareIDs(lParam, pidl1, pidl2) == 0)
                        fRet = TRUE;
                    psfDesktop->Release();
                }
            }
        }
    }
    return fRet;
}

//  the only case where this wouldnt be effective is if we were using 
//  an old Simple pidl of a UNC and trying to compare with the actual
//  pidl.  because the depth wasnt maintained correctly before.
//  ILIsParent() has always had this problem.
STDAPI_(BOOL) ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return ILIsEqualEx(pidl1, pidl2, TRUE, SHCIDS_CANONICALONLY);
}

// test if
//      pidlParent is a parent of pidlBelow
//      fImmediate requires that pidlBelow be a direct child of pidlParent.
//      Otherwise, self and grandchildren are okay too.
//
// example:
//      pidlParent: [my comp] [c:\] [windows]
//      pidlBelow:  [my comp] [c:\] [windows] [system32] [vmm.vxd]
//      fImmediate == FALSE result: TRUE
//      fImmediate == TRUE  result: FALSE

STDAPI_(BOOL) ILIsParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlBelow, BOOL fImmediate)
{
    LPCITEMIDLIST pidlParentT;
    LPCITEMIDLIST pidlBelowT;

    VALIDATE_PIDL(pidlParent);
    VALIDATE_PIDL(pidlBelow);

    if (!pidlParent || !pidlBelow)
        return FALSE;

    /* This code will not work correctly when comparing simple NET id lists
    /  against, real net ID lists.  Simple ID lists DO NOT contain network provider
    /  information therefore cannot pass the initial check of is pidlBelow longer than pidlParent.
    /  daviddv (2/19/1996) */

    for (pidlParentT = pidlParent, pidlBelowT = pidlBelow; !ILIsEmpty(pidlParentT);
         pidlParentT = _ILNext(pidlParentT), pidlBelowT = _ILNext(pidlBelowT))
    {
        // if pidlBelow is shorter than pidlParent, pidlParent can't be its parent.
        if (ILIsEmpty(pidlBelowT))
            return FALSE;
    }

    if (fImmediate)
    {
        // If fImmediate is TRUE, pidlBelowT should contain exactly one ID.
        if (ILIsEmpty(pidlBelowT) || !ILIsEmpty(_ILNext(pidlBelowT)))
            return FALSE;
    }

    //
    // Create a new IDList from a portion of pidlBelow, which contains the
    // same number of IDs as pidlParent.
    //
    BOOL fRet = FALSE;
    UINT cb = (UINT)((UINT_PTR)pidlBelowT - (UINT_PTR)pidlBelow);
    LPITEMIDLIST pidlBelowPrefix = _ILCreate(cb + sizeof(pidlBelow->mkid.cb));
    if (pidlBelowPrefix)
    {
        IShellFolder *psfDesktop;
        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            CopyMemory(pidlBelowPrefix, pidlBelow, cb);

            ASSERT(ILGetSize(pidlBelowPrefix) == cb + sizeof(pidlBelow->mkid.cb));

            fRet = psfDesktop->CompareIDs(SHCIDS_CANONICALONLY, pidlParent, pidlBelowPrefix) == ResultFromShort(0);
            psfDesktop->Release();
        }
        ILFree(pidlBelowPrefix);
    }
    return fRet;
}

// this returns a pointer to the child id ie:
// given 
//  pidlParent = [my comp] [c] [windows] [desktop]
//  pidlChild  = [my comp] [c] [windows] [desktop] [dir] [bar.txt]
// return pointer to:
//  [dir] [bar.txt]
// NULL is returned if pidlParent is not a parent of pidlChild
STDAPI_(LPITEMIDLIST) ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    if (ILIsParent(pidlParent, pidlChild, FALSE))
    {
        while (!ILIsEmpty(pidlParent))
        {
            pidlChild = _ILNext(pidlChild);
            pidlParent = _ILNext(pidlParent);
        }
        return (LPITEMIDLIST)pidlChild;
    }
    return NULL;
}

STDAPI_(LPITEMIDLIST) ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Let me pass in NULL pointers
    if (!pidl1)
    {
        if (!pidl2)
        {
            return NULL;
        }
        return ILClone(pidl2);
    }
    else if (!pidl2)
    {
        return ILClone(pidl1);
    }

    UINT cb1 = ILGetSize(pidl1) - sizeof(pidl1->mkid.cb);
    UINT cb2 = ILGetSize(pidl2);

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);
    LPITEMIDLIST pidlNew = _ILCreate(cb1 + cb2);
    if (pidlNew)
    {
        CopyMemory(pidlNew, pidl1, cb1);
        CopyMemory((LPTSTR)(((LPBYTE)pidlNew) + cb1), pidl2, cb2);
        ASSERT(ILGetSize(pidlNew) == cb1+cb2);
    }

    return pidlNew;
}

STDAPI_(void) ILFree(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        ASSERT(IS_VALID_PIDL(pidl));
        SHFree(pidl);
    }
}

// back on Win9x this did global global data, no longer
STDAPI_(LPITEMIDLIST) ILGlobalClone(LPCITEMIDLIST pidl)
{
    return ILClone(pidl);
}

STDAPI_(void) ILGlobalFree(LPITEMIDLIST pidl)
{
    ILFree(pidl);
}

SHSTDAPI SHParseDisplayName(PCWSTR pszName, IBindCtx *pbc, LPITEMIDLIST *ppidl, SFGAOF sfgaoIn, SFGAOF *psfgaoOut)
{
    *ppidl = 0;
    if (psfgaoOut)
        *psfgaoOut = 0;
    
    // since ISF::PDN() takes a non-const pointer
    PWSTR pszParse = StrDupW(pszName);
    HRESULT hr = pszParse ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        CComPtr<IShellFolder> spsfDesktop;
        hr = SHGetDesktopFolder(&spsfDesktop);
        if (SUCCEEDED(hr))
        {
            CComPtr<IBindCtx> spbcLocal;
            //  if they pass their own pbc, then they are responsible for
            //  adding in the translate param, else we default to using it
            if (!pbc)
            {
                hr = BindCtx_RegisterObjectParam(NULL, STR_PARSE_TRANSLATE_ALIASES, NULL, &spbcLocal);
                pbc = spbcLocal;
            }
            
            if (SUCCEEDED(hr))
            {
                ULONG cchEaten;
                SFGAOF sfgaoInOut = sfgaoIn;
                hr = spsfDesktop->ParseDisplayName(BindCtx_GetUIWindow(pbc), pbc, pszParse, &cchEaten, ppidl, psfgaoOut ? &sfgaoInOut : NULL);
                
                if (SUCCEEDED(hr) && psfgaoOut)
                {
                    *psfgaoOut = (sfgaoInOut & sfgaoIn);  // only return attributes passed in
                }
            }
        }
        LocalFree(pszParse);
    }
    
    return hr;
}

HRESULT _CFPBindCtx(IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, IBindCtx **ppbc)
{
    HRESULT hr = S_FALSE;
    if (punkToSkip || (dwFlags & ILCFP_FLAG_SKIPJUNCTIONS))
        hr = SHCreateSkipBindCtx(punkToSkip, ppbc);
    else if (dwFlags & ILCFP_FLAG_NO_MAP_ALIAS)
    {
        //  we need to create a bindctx to block alias mapping.
        //  this will keep SHParseDisplayName() from adding the STR_PARSE_TRANSLATE_ALIASES
        hr = CreateBindCtx(0, ppbc);
    }
    return hr;
}

STDAPI ILCreateFromPathEx(LPCTSTR pszPath, IUnknown *punkToSkip, ILCFP_FLAGS dwFlags, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    CComPtr<IBindCtx> spbc;
    HRESULT hr = _CFPBindCtx(punkToSkip, dwFlags, &spbc);
    if (SUCCEEDED(hr))
    {
        hr = SHParseDisplayName(pszPath, spbc, ppidl, rgfInOut ? *rgfInOut : 0, rgfInOut);
    }
    return hr;
}

STDAPI ILCreateFromCLSID(REFCLSID clsid, LPITEMIDLIST *ppidl)
{
    TCHAR szCLSID[GUIDSTR_MAX + 3];
    szCLSID[0] = TEXT(':');
    szCLSID[1] = TEXT(':');
    SHStringFromGUID(clsid, szCLSID + 2, ARRAYSIZE(szCLSID) - 2);

    return SHILCreateFromPath(szCLSID, ppidl, NULL);
}

STDAPI SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    return ILCreateFromPathEx(pszPath, NULL, ILCFP_FLAG_NO_MAP_ALIAS, ppidl, rgfInOut);
}

STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hr = SHILCreateFromPath(pszPath, &pidl, NULL);

    ASSERT(SUCCEEDED(hr) ? pidl != NULL : pidl == NULL);

    return pidl;
}


LPITEMIDLIST ILCreateFromPathA(IN LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];

    SHAnsiToUnicode(pszPath, szPath, SIZECHARS(szPath));
    return ILCreateFromPath(szPath);
}

STDAPI_(BOOL) ILGetDisplayNameEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszName, int fType)
{
    TraceMsg(TF_WARNING, "WARNING: ILGetDisplayNameEx() has been deprecated, should use SHGetNameAndFlags() instead!!!");

    RIPMSG(pszName && IS_VALID_WRITE_BUFFER(pszName, TCHAR, MAX_PATH), "ILGetDisplayNameEx: caller passed bad pszName");

    if (!pszName)
        return FALSE;

    DEBUGWhackPathBuffer(pszName, MAX_PATH);
    *pszName = 0;

    if (!pidl)
        return FALSE;

    HRESULT hr;
    if (psf)
    {
        hr = S_OK;
        psf->AddRef();
    }
    else
    {
        hr = SHGetDesktopFolder(&psf);
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwGDNFlags;

        switch (fType)
        {
        case ILGDN_FULLNAME:
            dwGDNFlags = SHGDN_FORPARSING | SHGDN_FORADDRESSBAR;
            hr = DisplayNameOf(psf, pidl, dwGDNFlags, pszName, MAX_PATH);
            break;

        case ILGDN_INFOLDER:
        case ILGDN_ITEMONLY:
            dwGDNFlags = fType == ILGDN_INFOLDER ? SHGDN_INFOLDER : SHGDN_NORMAL;

            if (!ILIsEmpty(pidl))
            {
                hr = SHGetNameAndFlags(pidl, dwGDNFlags, pszName, MAX_PATH, NULL);
            }
            else
            {
                hr = DisplayNameOf(psf, pidl, dwGDNFlags, pszName, MAX_PATH);
            }
            break;
        }
        psf->Release();
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

STDAPI_(BOOL) ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    return ILGetDisplayNameEx(NULL, pidl, pszPath, ILGDN_FULLNAME);
}

//***   ILGetPseudoName -- encode pidl relative to base
// Not used any more
//
STDAPI_(BOOL) ILGetPseudoNameW(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlSpec, WCHAR *pszBuf, int fType)
{
    *pszBuf = TEXT('\0');
    return FALSE;
}


STDAPI ILLoadFromStream(IStream *pstm, LPITEMIDLIST * ppidl)
{
    ASSERT(ppidl);

    // Delete the old one if any.
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    ULONG cb = 0;             // WARNING: We need to fill its HIWORD!
    HRESULT hr = pstm->Read(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hr) && cb)
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = _ILCreate(cb);
        if (pidl)
        {
            // Read its contents
            hr = pstm->Read(pidl, cb, NULL);
            if (SUCCEEDED(hr))
            {
                // Some pidls may be invalid.  We know they are invalid
                // if their size claims to be larger than the memory we
                // allocated.
                if (SHIsConsistentPidl(pidl, cb))
                {
                    *ppidl = pidl;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            
            if (FAILED(hr))
            {
                ILFree(pidl);
            }
        }
        else
        {
           hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDAPI ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl)
{
    ULONG cb = ILGetSize(pidl);
    ASSERT(HIWORD(cb) == 0);
    HRESULT hr = pstm->Write(&cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hr) && cb)
    {
        hr = pstm->Write(pidl, cb, NULL);
    }

    return hr;
}

//
// This one reallocated pidl if necessary. NULL is valid to pass in as pidl.
//
STDAPI_(LPITEMIDLIST) HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl)
{
    UINT cbRequired = HIDA_GetIDList(hida, i, NULL, 0);
    pidl = ILResize(pidl, cbRequired, 32); // extra 32-byte if we realloc
    if (pidl)
    {
        HIDA_GetIDList(hida, i, pidl, cbRequired);
    }

    return pidl;
}


STDAPI_(LPITEMIDLIST) IDA_FullIDList(LPIDA pida, UINT i)
{
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlParent = IDA_GetIDListPtr(pida, (UINT)-1);
    if (pidlParent)
    {
        LPCITEMIDLIST pidlRel = IDA_GetIDListPtr(pida, i);
        if (pidlRel)
        {
            pidl = ILCombine(pidlParent, pidlRel);
        }
    }
    return pidl;
}

LPITEMIDLIST HIDA_ILClone(HIDA hida, UINT i)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, i);
        GlobalUnlock(hida);
        return pidl;
    }
    return NULL;
}

//
//  This is a helper function to be called from within IShellFolder::CompareIDs.
// When the first IDs of pidl1 and pidl2 are the (logically) same.
//
// Required:
//  psf && pidl1 && pidl2 && !ILEmpty(pidl1) && !ILEmpty(pidl2)
//
HRESULT ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPARAM lParam)
{
    HRESULT hr;
    LPCITEMIDLIST pidlRel1 = _ILNext(pidl1);
    LPCITEMIDLIST pidlRel2 = _ILNext(pidl2);
    if (ILIsEmpty(pidlRel1))
    {
        if (ILIsEmpty(pidlRel2))
            hr = ResultFromShort(0);
        else
            hr = ResultFromShort(-1);
    }
    else
    {
        if (ILIsEmpty(pidlRel2))
        {
            hr = ResultFromShort(1);
        }
        else
        {
            //
            // pidlRel1 and pidlRel2 point to something
            //  (1) Bind to the next level of the IShellFolder
            //  (2) Call its CompareIDs to let it compare the rest of IDs.
            //
            LPITEMIDLIST pidlNext = ILCloneFirst(pidl1);    // pidl2 would work as well
            if (pidlNext)
            {
                IShellFolder *psfNext;
                hr = psfParent->BindToObject(pidlNext, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
                if (SUCCEEDED(hr))
                {
                    IShellFolder2 *psf2;
                    if (SUCCEEDED(psfNext->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
                    {
                        //  we can use the lParam
                        psf2->Release();
                    }
                    else    //  cant use the lParam
                        lParam = 0;

                    //  columns arent valid to pass down
                    //  we just care about the flags param
                    hr = psfNext->CompareIDs((lParam & ~SHCIDS_COLUMNMASK), pidlRel1, pidlRel2);
                    psfNext->Release();
                }
                ILFree(pidlNext);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

// in:
//      pszLeft
//      pidl
//
// in/out:
//      psr

STDAPI StrRetCatLeft(LPCTSTR pszLeft, STRRET *psr, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    TCHAR szRight[MAX_PATH];
    UINT cchRight, cchLeft = ualstrlen(pszLeft);

    switch (psr->uType)
    {
    case STRRET_CSTR:
        cchRight = lstrlenA(psr->cStr);
        break;
    case STRRET_OFFSET:
        cchRight = lstrlenA(STRRET_OFFPTR(pidl, psr));
        break;
    case STRRET_WSTR:
        cchRight = lstrlenW(psr->pOleStr);
        break;
    }

    if (cchLeft + cchRight < MAX_PATH) 
    {
        hr = StrRetToBuf(psr, pidl, szRight, ARRAYSIZE(szRight)); // will free psr for us
        if (SUCCEEDED(hr))
        {
            size_t cchTotal = (lstrlen(pszLeft) + 1 + cchRight);
            psr->pOleStr = (LPOLESTR)SHAlloc(cchTotal * sizeof(TCHAR));
            if (psr->pOleStr == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                psr->uType = STRRET_WSTR;
                StringCchCopy(psr->pOleStr, cchTotal, pszLeft);
                StringCchCat(psr->pOleStr, cchTotal, szRight);
                hr = S_OK;
            }
        }
    } 
    else 
    {
        hr = E_NOTIMPL;
    }
    return hr;
}

STDAPI_(void) StrRetFormat(STRRET *psr, LPCITEMIDLIST pidlRel, LPCTSTR pszTemplate, LPCTSTR pszAppend)
{
     TCHAR szT[MAX_PATH];

     StrRetToBuf(psr, pidlRel, szT, ARRAYSIZE(szT));
     LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL, pszTemplate, pszAppend, szT);
     if (pszRet)
     {
         StringToStrRet(pszRet, psr);
         LocalFree(pszRet);
     }
}

//
// Notes: This one passes SHGDN_FORPARSING to ISF::GetDisplayNameOf.
//
HRESULT ILGetRelDisplayName(IShellFolder *psf, STRRET *psr,
    LPCITEMIDLIST pidlRel, LPCTSTR pszName, LPCTSTR pszTemplate, DWORD dwFlags)
{
    HRESULT hr;
    LPITEMIDLIST pidlLeft = ILCloneFirst(pidlRel);
    if (pidlLeft)
    {
        IShellFolder *psfNext;
        hr = psf->BindToObject(pidlLeft, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlRight = _ILNext(pidlRel);
            hr = psfNext->GetDisplayNameOf(pidlRight, dwFlags, psr);
            if (SUCCEEDED(hr))
            {
                if (pszTemplate)
                {
                    StrRetFormat(psr, pidlRight, pszTemplate, pszName);
                }
                else
                {
                    hr = StrRetCatLeft(pszName, psr, pidlRight);
                }
            }
            psfNext->Release();
        }

        ILFree(pidlLeft);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#undef ILCreateFromPath
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath)
{
    return ILCreateFromPathW(pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idldrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "datautil.h"
#include "idlcomm.h"
#include "idldrop.h"

STDAPI_(BOOL) DoesDropTargetSupportDAD(IDropTarget *pdtgt)
{
    IDropTargetWithDADSupport* pdt;
    if (pdtgt && SUCCEEDED(pdtgt->QueryInterface(IID_IDropTargetWithDADSupport, (void**)&pdt)))
    {
        pdt->Release();
        return TRUE;
    }
    return FALSE;
}

CIDLDropTarget::CIDLDropTarget(HWND hwnd) : m_cRef(1), m_hwnd(hwnd)
{
}

CIDLDropTarget::~CIDLDropTarget()
{
    // if we hit this a lot maybe we should just release it
    AssertMsg(m_pdtobj == NULL, TEXT("didn't get matching DragLeave."));

    if (m_pidl)
        ILFree(m_pidl);
}

HRESULT CIDLDropTarget::_Init(LPCITEMIDLIST pidl)
{
    ASSERT(m_pidl == NULL);
    return pidl ? SHILClone(pidl, &m_pidl) : S_OK;
}

HWND CIDLDropTarget::_GetWindow()
{
    return m_hwnd;
}

STDMETHODIMP CIDLDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CIDLDropTarget, IUnknown),  
        QITABENT(CIDLDropTarget, IDropTarget),  
        QITABENT(CIDLDropTarget, IDropTargetWithDADSupport),     
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CIDLDropTarget::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CIDLDropTarget::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI GetClipFormatFlags(IDataObject *pdtobj, DWORD *pdwData, DWORD *pdwEffectPreferred);

STDMETHODIMP CIDLDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(m_pdtobj == NULL);               // DragDrop protocol requires DragLeave, this should be empty

    // init our registerd data formats
    IDLData_InitializeClipboardFormats();

    m_grfKeyStateLast = grfKeyState;
    m_dwEffectLastReturned = *pdwEffect;

    IUnknown_Set((IUnknown **)&m_pdtobj, (IUnknown *)pDataObj);

    GetClipFormatFlags(m_pdtobj, &m_dwData, &m_dwEffectPreferred);

    return S_OK;
}

// subclasses can prevetn us from assigning in the dwEffect by not passing in pdwEffect
STDMETHODIMP CIDLDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    m_grfKeyStateLast = grfKeyState;
    if (pdwEffect)
        *pdwEffect = m_dwEffectLastReturned;
    return S_OK;
}

STDMETHODIMP CIDLDropTarget::DragLeave()
{
    IUnknown_Set((IUnknown **)&m_pdtobj, NULL);
    return S_OK;
}

STDMETHODIMP CIDLDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return E_NOTIMPL;
}

struct {
    UINT uID;
    DWORD dwEffect;
} const c_IDEffects[] = {
    DDIDM_COPY,         DROPEFFECT_COPY,
    DDIDM_MOVE,         DROPEFFECT_MOVE,
    DDIDM_CONTENTS_DESKCOMP,     DROPEFFECT_LINK,
    DDIDM_LINK,         DROPEFFECT_LINK,
    DDIDM_SCRAP_COPY,   DROPEFFECT_COPY,
    DDIDM_SCRAP_MOVE,   DROPEFFECT_MOVE,
    DDIDM_DOCLINK,      DROPEFFECT_LINK,
    DDIDM_CONTENTS_COPY, DROPEFFECT_COPY,
    DDIDM_CONTENTS_MOVE, DROPEFFECT_MOVE,
    DDIDM_CONTENTS_LINK, DROPEFFECT_LINK,
    DDIDM_CONTENTS_DESKIMG,     DROPEFFECT_LINK,
    DDIDM_SYNCCOPYTYPE, DROPEFFECT_COPY,        // (order is important)
    DDIDM_SYNCCOPY,     DROPEFFECT_COPY,
    DDIDM_OBJECT_COPY,  DROPEFFECT_COPY,
    DDIDM_OBJECT_MOVE,  DROPEFFECT_MOVE,
};

//
// Pops up the "Copy, Link, Move" context menu, so that the user can
// choose one of them.
//
// in:
//      pdwEffect               drop effects allowed
//      dwDefaultEffect         default drop effect
//      hkeyBase/hkeyProgID     extension hkeys
//      hmenuReplace            replaces POPUP_NONDEFAULTDD.  Can only contain:
//                                  DDIDM_MOVE, DDIDM_COPY, DDIDM_LINK menu ids
//      pt                      in screen
// Returns:
//      S_OK    -- Menu item is processed by one of extensions or canceled
//      S_FALSE -- Menu item is selected
//
HRESULT CIDLDropTarget::DragDropMenu(DWORD dwDefaultEffect,
                                    IDataObject *pdtobj,
                                    POINTL pt, DWORD *pdwEffect,
                                    HKEY hkeyProgID, HKEY hkeyBase,
                                    UINT idMenu, DWORD grfKeyState)
{
    DRAGDROPMENUPARAM ddm = { dwDefaultEffect, pdtobj, { pt.x, pt.y},
                              pdwEffect,
                              hkeyProgID, hkeyBase, idMenu, 0, grfKeyState };
    return DragDropMenuEx(&ddm);
}

HRESULT CIDLDropTarget::DragDropMenuEx(DRAGDROPMENUPARAM *pddm)
{
    HRESULT hr = E_OUTOFMEMORY;       // assume error
    DWORD dwEffectOut = 0;                              // assume no-ope.
    HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, pddm->idMenu);
    if (hmenu)
    {
        UINT idCmd;
        UINT idCmdFirst = DDIDM_EXTFIRST;
        HDXA hdxa = HDXA_Create();
        HDCA hdca = DCA_Create();
        if (hdxa && hdca)
        {
            // PERF (toddb): Even though pddm->hkeyBase does not have the same value as
            // pddm->hkeyProgID they can both be the same registry key (HKCR\FOLDER, for example).
            // As a result we sometimes enumerate this key twice looking for the same data.  As
            // this is sometimes a slow operation we should avoid this.  The comparision
            // done below was never valid on NT and might not be valid on win9x.

            //
            // Add extended menu for "Base" class.
            //
            if (pddm->hkeyBase && pddm->hkeyBase != pddm->hkeyProgID)
                DCA_AddItemsFromKey(hdca, pddm->hkeyBase, STRREG_SHEX_DDHANDLER);

            //
            // Enumerate the DD handlers and let them append menu items.
            //
            if (pddm->hkeyProgID)
                DCA_AddItemsFromKey(hdca, pddm->hkeyProgID, STRREG_SHEX_DDHANDLER);

            idCmdFirst = HDXA_AppendMenuItems(hdxa, pddm->pdtobj, 1,
                &pddm->hkeyProgID, m_pidl, hmenu, 0,
                DDIDM_EXTFIRST, DDIDM_EXTLAST, 0, hdca);
        }

        // eliminate menu options that are not allowed by dwEffect

        for (int nItem = 0; nItem < ARRAYSIZE(c_IDEffects); ++nItem)
        {
            if (GetMenuState(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND)!=(UINT)-1)
            {
                if (!(c_IDEffects[nItem].dwEffect & *(pddm->pdwEffect)))
                {
                    RemoveMenu(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND);
                }
                else if (c_IDEffects[nItem].dwEffect == pddm->dwDefEffect)
                {
                    SetMenuDefaultItem(hmenu, c_IDEffects[nItem].uID, MF_BYCOMMAND);
                }
            }
        }

        //
        // If this dragging is caused by the left button, simply choose
        // the default one, otherwise, pop up the context menu.  If there
        // is no key state info and the original effect is the same as the
        // current effect, choose the default one, otherwise pop up the
        // context menu.  
        //
        if ((m_grfKeyStateLast & MK_LBUTTON) ||
            (!m_grfKeyStateLast && (*(pddm->pdwEffect) == pddm->dwDefEffect)) )
        {
            idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
            // This one MUST be called here. Please read its comment block.
            DAD_DragLeave();

            if (m_hwnd)
                SetForegroundWindow(m_hwnd);
        }
        else
        {
            // Note that SHTrackPopupMenu calls DAD_DragLeave().
            idCmd = SHTrackPopupMenu(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pddm->pt.x, pddm->pt.y, 0, m_hwnd, NULL);
        }

        // We also need to call this here to release the dragged image.
        DAD_SetDragImage(NULL, NULL);

        // Check if the user selected one of add-in menu items.
        if (idCmd == 0)
        {
            hr = S_OK;        // Canceled by the user, return S_OK
        }
        else if (InRange(idCmd, DDIDM_EXTFIRST, DDIDM_EXTLAST))
        {
            // Yes. Let the context menu handler process it.
            CMINVOKECOMMANDINFOEX ici = {
                SIZEOF(CMINVOKECOMMANDINFOEX),
                0L,
                m_hwnd,
                (LPSTR)MAKEINTRESOURCE(idCmd - DDIDM_EXTFIRST),
                NULL, NULL,
                SW_NORMAL,
            };

            // record if shift or control was being held down
            SetICIKeyModifiers(&ici.fMask);

            // We may not want to ignore the error code. (Can happen when you use the context menu
            // to create new folders, but I don't know if that can happen here.).
            HDXA_LetHandlerProcessCommandEx(hdxa, &ici, NULL);
            hr = S_OK;
        }
        else
        {
            for (nItem = 0; nItem < ARRAYSIZE(c_IDEffects); ++nItem)
            {
                if (idCmd == c_IDEffects[nItem].uID)
                {
                    dwEffectOut = c_IDEffects[nItem].dwEffect;
                    break;
                }
            }

            // if hmenuReplace had menu commands other than DDIDM_COPY,
            // DDIDM_MOVE, DDIDM_LINK, and that item was selected,
            // this assert will catch it.  (dwEffectOut is 0 in this case)
            ASSERT(nItem < ARRAYSIZE(c_IDEffects));

            hr = S_FALSE;
        }

        if (hdca)
            DCA_Destroy(hdca);

        if (hdxa)
            HDXA_Destroy(hdxa);

        DestroyMenu(hmenu);
        pddm->idCmd = idCmd;
    }

    *(pddm->pdwEffect) = dwEffectOut;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idlcomm.h ===
#ifndef _IDLCOMM_H_
#define _IDLCOMM_H_

#ifndef _SHELLP_H_
#include <shellp.h>
#endif

//===========================================================================
// HIDA -- IDList Array handle
//===========================================================================

STDAPI_(void) IDLData_InitializeClipboardFormats(void);

STDAPI_(LPITEMIDLIST) HIDA_ILClone(HIDA hida, UINT i);
STDAPI_(LPITEMIDLIST) HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl);

#define DTID_HDROP              0x00000001L
#define DTID_HIDA               0x00000002L
#define DTID_NETRES             0x00000004L
#define DTID_CONTENTS           0x00000008L
#define DTID_FDESCA             0x00000010L
#define DTID_OLEOBJ             0x00000020L
#define DTID_OLELINK            0x00000040L
#define DTID_FD_LINKUI          0x00000080L
#define DTID_FDESCW             0x00000100L
#define DTID_PREFERREDEFFECT    0x00000200L
#define DTID_EMBEDDEDOBJECT     0x00000400L

//
// This macro checks if pdtgt is a subclass of CIDLDropTarget.
// (HACK: We assume nobody overrides QueryInterface).
//
STDAPI_(BOOL) DoesDropTargetSupportDAD(IDropTarget *pdtgt);

//
// IDs for non-default drag & drop menu
//
#define DDIDM_COPY              1
#define DDIDM_MOVE              2
#define DDIDM_LINK              3
#define DDIDM_SCRAP_COPY        4
#define DDIDM_SCRAP_MOVE        5
#define DDIDM_DOCLINK           6
#define DDIDM_CONTENTS_COPY     7
#define DDIDM_CONTENTS_MOVE     8
#define DDIDM_SYNCCOPY          9
#define DDIDM_SYNCCOPYTYPE      10
#define DDIDM_CONTENTS_LINK     11
#define DDIDM_CONTENTS_DESKCOMP 12
#define DDIDM_CONTENTS_DESKIMG  13
#define DDIDM_OBJECT_COPY       14
#define DDIDM_OBJECT_MOVE       15
#define DDIDM_CONTENTS_DESKURL  16
#define DDIDM_EXTFIRST          0x1000
#define DDIDM_EXTLAST           0x7fff

#define MK_FAKEDROP 0x8000      // Real keys being held down?

//===========================================================================
// HDKA
//===========================================================================
//
// Struct:  ContextMenuInfo:
//
//  This data structure is used by FileView_DoContextMenu (and its private
// function, _AppendMenuItems) to handler multiple context menu handlers.
//
// History:
//  02-25-93 SatoNa     Created
//
typedef struct { // cmi
    IContextMenu  *pcm;
    UINT        idCmdFirst;
    UINT        idCmdMax;
    DWORD       dwCompat;
    CLSID       clsid;
} ContextMenuInfo;


//------------------------------------------------------------------------
// Dynamic class array
//

STDAPI_(int) DCA_AppendClassSheetInfo(HDCA hdca, HKEY hkeyProgID, LPPROPSHEETHEADER ppsh, IDataObject * pdtobj);

//===========================================================================
// HDXA
//===========================================================================
typedef HDSA    HDXA;   // hdma

#define HDXA_Create()   ((HDXA)DSA_Create(SIZEOF(ContextMenuInfo), 4))

STDAPI_(UINT) HDXA_AppendMenuItems(
                        HDXA hdxa, IDataObject * pdtobj,
                        UINT nKeys, HKEY *ahkeyClsKeys,
                        LPCITEMIDLIST pidlFolder,
                        HMENU hmenu, UINT uInsert,
                        UINT idCmdFirst,  UINT idCmdLast,
                        UINT fFlags,
                        HDCA hdca);
STDAPI_(UINT) HDXA_AppendMenuItems2(HDXA hdxa, IDataObject *pdtobj,
                        UINT nKeys, HKEY *ahkeyClsKeys,
                        LPCITEMIDLIST pidlFolder,
                        QCMINFO* pqcm,
                        UINT fFlags,
                        HDCA hdca,
                        IUnknown* pSite);

STDAPI HDXA_LetHandlerProcessCommandEx(HDXA hdxa, LPCMINVOKECOMMANDINFOEX pici, UINT_PTR * pidCmd);
STDAPI HDXA_GetCommandString(HDXA hdxa, UINT_PTR idCmd, UINT wFlags, UINT * pwReserved, LPSTR pszName, UINT cchMax);
STDAPI_(void) HDXA_DeleteAll(HDXA hdxa);
STDAPI_(void) HDXA_Destroy(HDXA hdxa);

//
// Clipboard Format for IDLData object.
//
#define ICFHDROP                         0
#define ICFFILENAME                      1
#define ICFNETRESOURCE                   2
#define ICFFILECONTENTS                  3
#define ICFFILEGROUPDESCRIPTORA          4
#define ICFFILENAMEMAPW                  5
#define ICFFILENAMEMAP                   6
#define ICFHIDA                          7
#define ICFOFFSETS                       8
#define ICFPRINTERFRIENDLYNAME           9
#define ICFPRIVATESHELLDATA             10
#define ICFHTML                         11
#define ICFFILENAMEW                    12
#define ICFFILEGROUPDESCRIPTORW         13
#define ICFPREFERREDDROPEFFECT          14
#define ICFPERFORMEDDROPEFFECT          15
#define ICFPASTESUCCEEDED               16
#define ICFSHELLURL                     17
#define ICFINDRAGLOOP                   18
#define ICF_DRAGCONTEXT                 19
#define ICF_TARGETCLSID                 20
#define ICF_EMBEDDEDOBJECT              21
#define ICF_OBJECTDESCRIPTOR            22
#define ICF_NOTRECYCLABLE               23
#define ICFLOGICALPERFORMEDDROPEFFECT   24
#define ICF_BRIEFCASE                   25
#define ICF_UNICODETEXT                 26
#define ICF_TEXT                        27
#define ICF_DROPEFFECTFOLDERLIST        28
#define ICF_AUTOPLAYHIDA                29
#define ICF_MAX                         30

EXTERN_C CLIPFORMAT g_acfIDLData[];

#define g_cfNetResource                 g_acfIDLData[ICFNETRESOURCE]
#define g_cfHIDA                        g_acfIDLData[ICFHIDA]
#define g_cfOFFSETS                     g_acfIDLData[ICFOFFSETS]
#define g_cfPrinterFriendlyName         g_acfIDLData[ICFPRINTERFRIENDLYNAME]
#define g_cfFileNameA                   g_acfIDLData[ICFFILENAME]
#define g_cfFileContents                g_acfIDLData[ICFFILECONTENTS]
#define g_cfFileGroupDescriptorA        g_acfIDLData[ICFFILEGROUPDESCRIPTORA]
#define g_cfFileGroupDescriptorW        g_acfIDLData[ICFFILEGROUPDESCRIPTORW]
#define g_cfFileNameMapW                g_acfIDLData[ICFFILENAMEMAPW]
#define g_cfFileNameMapA                g_acfIDLData[ICFFILENAMEMAP]
#define g_cfPrivateShellData            g_acfIDLData[ICFPRIVATESHELLDATA]
#define g_cfHTML                        g_acfIDLData[ICFHTML]
#define g_cfFileNameW                   g_acfIDLData[ICFFILENAMEW]
#define g_cfPreferredDropEffect         g_acfIDLData[ICFPREFERREDDROPEFFECT]
#define g_cfPerformedDropEffect         g_acfIDLData[ICFPERFORMEDDROPEFFECT]
#define g_cfLogicalPerformedDropEffect  g_acfIDLData[ICFLOGICALPERFORMEDDROPEFFECT]
#define g_cfPasteSucceeded              g_acfIDLData[ICFPASTESUCCEEDED]
#define g_cfShellURL                    g_acfIDLData[ICFSHELLURL]
#define g_cfInDragLoop                  g_acfIDLData[ICFINDRAGLOOP]
#define g_cfDragContext                 g_acfIDLData[ICF_DRAGCONTEXT]
#define g_cfTargetCLSID                 g_acfIDLData[ICF_TARGETCLSID]
#define g_cfEmbeddedObject              g_acfIDLData[ICF_EMBEDDEDOBJECT]
#define g_cfObjectDescriptor            g_acfIDLData[ICF_OBJECTDESCRIPTOR]
#define g_cfNotRecyclable               g_acfIDLData[ICF_NOTRECYCLABLE]
#define g_cfBriefObj                    g_acfIDLData[ICF_BRIEFCASE]    
#define g_cfText                        g_acfIDLData[ICF_TEXT]
#define g_cfUnicodeText                 g_acfIDLData[ICF_UNICODETEXT]
#define g_cfDropEffectFolderList        g_acfIDLData[ICF_DROPEFFECTFOLDERLIST]
#define g_cfAutoPlayHIDA                g_acfIDLData[ICF_AUTOPLAYHIDA]

EXTERN_C CLIPFORMAT g_cfMountedVolume;

// Most places will only generate one so minimize the number of changes in the code (bad idea!)
#ifdef UNICODE
#define g_cfFileNameMap         g_cfFileNameMapW
#define g_cfFileName            g_cfFileNameW
#else
#define g_cfFileNameMap         g_cfFileNameMapA
#define g_cfFileName            g_cfFileNameA
#endif

STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i);
STDAPI_(LPITEMIDLIST)  IDA_FullIDList(LPIDA pida, UINT i);

#endif // _IDLCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idltree.h ===
#include <linklistt.h>

//  put some notes here about how we do things for perf reasons.
//  so our behavior is pathological to our client usage
//  and is not totall generic.

enum 
{
    IDLDATAF_MATCH_EXACT            = 0x00000001,    //  self only
    IDLDATAF_MATCH_IMMEDIATE        = 0x00000003,    //  includes self and immediate children
    IDLDATAF_MATCH_RECURSIVE        = 0x00000007,    //  includes self and all children
//    IDLDATAF_IUNKNOWN               = 0x80000000,
//    IDLDATAF_SINGLETON              = 0x10000000,
};
typedef DWORD IDLDATAF;

class CIDLData
{
public: // basically a struct
    BOOL Init(IDLDATAF flags, INT_PTR data);
//    ~CIDLData()  { if (_flags & IDLDATAF_IUNKNOWN) ((IUnknown *)_data)->Release(); }
    HRESULT GetData(IDLDATAF flags, INT_PTR *pdata);

    IDLDATAF _flags;
    INT_PTR _data;
};

class CIDLMatchMany;
class CIDLTree;
class CIDLNode
{
public: // methods
    ~CIDLNode();

protected:  // methods
    HRESULT GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CIDLNode **ppin, IDLDATAF *pflagsFound = NULL);
    HRESULT IDList(LPITEMIDLIST *ppidl);
    BOOL Init(LPCITEMIDLIST pidl, CIDLNode *pinParent);

    BOOL _InitSF();
    HRESULT _BindToFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf);
    BOOL _IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    CLinkedNode<CIDLNode> *_GetKid(LPCITEMIDLIST pidl);
    HRESULT _AddData(IDLDATAF flags, INT_PTR data);
    HRESULT _RemoveData(INT_PTR data);
    void _FreshenKids(void);
    BOOL _IsEmpty(void) { return _listKids.IsEmpty() && _listDatas.IsEmpty();}

protected:  // members
    LONG _cUsage;
    LPITEMIDLIST _pidl;
    IShellFolder *_psf;
    CIDLNode *_pinParent;

    //  lists
    CLinkedList<CIDLNode> _listKids;
    CLinkedList<CIDLData> _listDatas;

    friend class CIDLTree;
    friend class CIDLMatchMany;
};

typedef DWORD IDLMATCHF;

class CIDLMatchMany 
{
public:
    HRESULT Next(INT_PTR *pdata, LPITEMIDLIST *ppidl);
    CIDLMatchMany(IDLDATAF flags, CIDLNode *pin) 
        : _flags(flags), _pin(pin) { if (pin) _lw.Init(&pin->_listDatas);}
        
protected:  // members
    IDLDATAF _flags;
    CIDLNode *_pin;
    CLinkedWalk<CIDLData> _lw;
};

class CIDLTree : CIDLNode
{
public:
    HRESULT AddData(IDLDATAF flags, LPCITEMIDLIST pidlIndex, INT_PTR data);
    HRESULT RemoveData(LPCITEMIDLIST pidlIndex, INT_PTR data);
    HRESULT MatchOne(IDLDATAF flags, LPCITEMIDLIST pidlMatch, INT_PTR *pdata, LPITEMIDLIST *ppidl);
    HRESULT MatchMany(IDLDATAF flags, LPCITEMIDLIST pidlMatch, CIDLMatchMany **ppmatch);
    HRESULT Freshen(void);
    
    static HRESULT Create(CIDLTree **pptree);
protected:  // methods
    CIDLNode *_MatchNode(LPCITEMIDLIST pidlMatch, IDLMATCHF *pflags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\idltree.cpp ===
#include "shellprv.h"
#include "idltree.h"

BOOL CIDLData::Init(IDLDATAF flags, INT_PTR data) 
{ 
    _flags = flags;
    _data = data;

    return TRUE;
}

HRESULT CIDLData::GetData(IDLDATAF flags, INT_PTR *pdata)
{
    if (flags & _flags)
    {
        //  we have a match
        *pdata = _data;
        return S_OK;
    }
    return E_FAIL;
}

BOOL CIDLNode::Init(LPCITEMIDLIST pidl, CIDLNode *pinParent) 
{ 
    _pidl = ILCloneFirst(pidl);
    _pinParent = pinParent;
    return _pidl != NULL;
}

CIDLNode::~CIDLNode()
{
    ILFree(_pidl);
        
    if (_psf)
        _psf->Release();
}

BOOL CIDLNode::_InitSF()
{
    //  TODO MAYBE LATER - add per thread cacheing instead.
    //  this way we can insure nonviolation of apartments
    if (!_psf)
    {
        if (_pinParent)
            _pinParent->_BindToFolder(_pidl, &_psf);
        else
            SHGetDesktopFolder(&_psf);

        _cUsage++;
    }

    return (_psf != NULL);
}

HRESULT CIDLNode::_BindToFolder(LPCITEMIDLIST pidl, IShellFolder **ppsf)
{
    if (_InitSF())
    {
        _cUsage++;
        return _psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, ppsf));
    }
    return E_UNEXPECTED;
}

BOOL CIDLNode::_IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = ShortFromResult(IShellFolder_CompareIDs(_psf, SHCIDS_CANONICALONLY, pidl1, pidl2));
    return (iRet == 0);
}

CLinkedNode<CIDLNode> *CIDLNode::_GetKid(LPCITEMIDLIST pidl)
{
    CLinkedWalk<CIDLNode> lw(&_listKids);
    //  WARNING - need to avoid a real allocation - ZekeL - 27-SEP-2000
    //  when we are just doing a seek
    //  it creates weird state problems
    LPITEMIDLIST pidlStack = (LPITEMIDLIST)alloca(pidl->mkid.cb + sizeof(pidl->mkid.cb));
    memcpy(pidlStack, pidl, pidl->mkid.cb);
    (_ILNext(pidlStack))->mkid.cb = 0;

    while (lw.Step())
    {
        if (_IsEqual(lw.That()->_pidl, pidlStack))
        {
            return lw.Node();
        }
    }
    return NULL;
}

#define IsValidIDLNODE(pin) IS_VALID_WRITE_BUFFER(pin, BYTE, SIZEOF(CIDLNode))

#define _IsEmptyNode(pin)       (!(pin)->_pinKids && !(pin)->_pidDatas)

void CIDLNode::_FreshenKids(void)
{
    CLinkedWalk<CIDLNode> lw(&_listKids);
    LONG cMostUsage = 0;

    while (lw.Step())
    {
        CIDLNode *pin = lw.That();
        LONG cUsage = pin->_cUsage;
        pin->_cUsage = 0;

        ASSERT(IsValidIDLNODE(pin));
        pin->_FreshenKids();
        ASSERT(IsValidIDLNODE(pin));

        if (!cUsage && pin->_IsEmpty())
        {
            lw.Delete();
        }
        if (cUsage > cMostUsage && !lw.IsFirst())
        {
            // simple sorting algorithm
            // we just want most used at the top
            //  move it from its current spot
            //  to the beginning of the list
            CLinkedNode<CIDLNode> *p = lw.Remove();
            _listKids.Insert(p);
        }

        cMostUsage = max(cUsage, cMostUsage);
    }
}

HRESULT CIDLNode::GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CIDLNode **ppin, IDLDATAF *pflagsFound)
{
    HRESULT hr = E_FAIL;
    if (ILIsEmpty(pidlChild))
    {
        //  this is just a request for self
        *ppin = this;
        if (pflagsFound)
            *pflagsFound = IDLDATAF_MATCH_RECURSIVE;
        hr = S_OK;
    }
    else
    {
        //  search through kids looking for this child
        *ppin = NULL;
        CLinkedNode<CIDLNode> *pKid = _GetKid(pidlChild);

        if (!pKid && fCreate)
        {
            //  we need to allocations during fCreate
            //  so that memory failures dont affect Remove
            if (_InitSF())
            {
                //  we dont have it, and they want it anyway
                pKid = new CLinkedNode<CIDLNode>;

                //  we give our pidl ref away to avoid allocations
                if (pKid)
                {
                    if (pKid->that.Init(pidlChild, this))
                        _listKids.Insert(pKid);
                    else
                    {
                        delete pKid;
                        pKid = NULL;
                    }
                }
            }
        }

        //  let the child take care of setting
        if (pKid)
        {
            pKid->that._cUsage++;
            pidlChild = _ILNext(pidlChild);
            hr = pKid->that.GetNode(fCreate, pidlChild, ppin, pflagsFound);
        }

        if (FAILED(hr) && !fCreate && pflagsFound)
        {
            //  just return this as second best
            *ppin = this;
            ASSERT(!ILIsEmpty(pidlChild));

            if (ILIsEmpty(_ILNext(pidlChild)))
                *pflagsFound = IDLDATAF_MATCH_RECURSIVE & ~IDLDATAF_MATCH_EXACT;
            else
                *pflagsFound = IDLDATAF_MATCH_RECURSIVE & ~IDLDATAF_MATCH_IMMEDIATE;
            
            hr = S_FALSE;
        }
    }
    
    return hr;
}

HRESULT CIDLNode::IDList(LPITEMIDLIST *ppidl)
{
    CIDLNode *pin = this;
    *ppidl = NULL;
    while (pin && pin->_pidl)
    {
        *ppidl = ILAppendID(*ppidl, &pin->_pidl->mkid, FALSE);
        pin = pin->_pinParent;
    }

    return *ppidl ? S_OK : E_FAIL;
}

HRESULT CIDLNode::_AddData(IDLDATAF flags, INT_PTR data)
{
    //  assuming unique/no collisions of Datas
    CLinkedNode<CIDLData> *p = new CLinkedNode<CIDLData>;

    if (p)
    {
        p->that.Init(flags, data);
        _listDatas.Insert(p);
    }

    return p ? S_OK : E_FAIL;
}
    
HRESULT CIDLNode::_RemoveData(INT_PTR data)
{
    HRESULT hr = E_FAIL;
    CLinkedWalk<CIDLData> lw(&_listDatas);

    while (lw.Step())
    {
        if (lw.That()->_data == data)
        {
            lw.Delete();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

HRESULT CIDLTree::Create(CIDLTree **pptree)
{
    HRESULT hr = E_OUTOFMEMORY;
    *pptree = new CIDLTree();
    if (*pptree)
    {
         hr = SHILClone(&c_idlDesktop, &((*pptree)->_pidl));

         if (FAILED(hr))
         {
            delete *pptree;
            *pptree = NULL;
        }
    }
    return hr;
}

HRESULT CIDLTree::AddData(IDLDATAF flags, LPCITEMIDLIST pidlIndex, INT_PTR data)
{
    CIDLNode *pin;
    if (SUCCEEDED(GetNode(TRUE, pidlIndex, &pin)))
    {
        return pin->_AddData(flags, data);
    }
    return E_UNEXPECTED;
}

HRESULT CIDLTree::RemoveData(LPCITEMIDLIST pidlIndex, INT_PTR data)
{
    CIDLNode *pin;
    if (SUCCEEDED(GetNode(FALSE, pidlIndex, &pin)))
    {
        return pin->_RemoveData(data);
    }
    return E_UNEXPECTED;
}

CIDLNode *CIDLTree::_MatchNode(LPCITEMIDLIST pidlMatch, IDLMATCHF *pflags)
{
    CIDLNode *pin;
    IDLMATCHF flagsFound;
    HRESULT hr = GetNode(FALSE, pidlMatch, &pin, &flagsFound);

    if (SUCCEEDED(hr) && (flagsFound & (*pflags)))
    {
        *pflags &= flagsFound;
    }
    else
        pin = NULL;

    return pin;
}

HRESULT CIDLTree::MatchOne(IDLMATCHF flags, LPCITEMIDLIST pidlMatch, INT_PTR *pdata, LPITEMIDLIST *ppidl)
{
    CIDLNode *pin = _MatchNode(pidlMatch, &flags);

    if (pin)
    {
        CIDLMatchMany mm(flags, pin);

        return mm.Next(pdata, ppidl);
    }
    return E_FAIL;
}
                
HRESULT CIDLTree::MatchMany(IDLMATCHF flags, LPCITEMIDLIST pidlMatch, CIDLMatchMany **ppmatch)
{
    CIDLNode *pin = _MatchNode(pidlMatch, &flags);
    if (pin)
    {
        *ppmatch = new CIDLMatchMany(flags, pin);

        return *ppmatch ? S_OK : E_FAIL;
    }

    *ppmatch = NULL;
    return E_FAIL;
}

HRESULT CIDLTree::Freshen(void)
{
    _FreshenKids();
    return S_OK;
}

HRESULT CIDLMatchMany::Next(INT_PTR *pdata, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    while (_pin && (_flags & IDLDATAF_MATCH_RECURSIVE))
    {
        if (_lw.Step())
        {
            hr = _lw.That()->GetData(_flags, pdata);
            if (SUCCEEDED(hr) && ppidl)
            {
                hr = _pin->IDList(ppidl);
            }
            if (SUCCEEDED(hr))
                break;
        }
        else
        {
            _pin = _pin->_pinParent;
            if (_pin)
            {
                _lw.Init(&_pin->_listDatas);
                // adjust the flags as you go up the parent chain.
                if (_flags & IDLDATAF_MATCH_EXACT)
                    _flags &= ~IDLDATAF_MATCH_EXACT;
                else if (_flags & IDLDATAF_MATCH_IMMEDIATE)
                    _flags &= ~IDLDATAF_MATCH_IMMEDIATE;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\ids.h ===
#ifndef _IDS_H_
#define _IDS_H_
// IDs for common UI resources (note that these MUST BE decimal numbers)
// More IDs are in unicpp\resource.h

// Folder Display Name IDs
#include <winfoldr.h>

// menuband ids
#include "menuband\mnbandid.h"

// Cursor resources
#define IDC_HELPCOLD    1001
#define IDC_HELPHOT     1002
#define IDC_SCOPY       1003
#define IDC_MCOPY       1004
#define IDC_NULL        1005

// IDs of Overlay Images
// These are here for compatibility reasons only, so don't change and add
// new values!!! (dli)
#define IDOI_SHARE      1
#define IDOI_LINK       2

#define ACCEL_DEFVIEW   1
#define ACCEL_PRN_QUEUE 2

// matches stuff in winuser.h
#define IDIGNOREALL             10


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE: If you are adding new icons, give them #defines at the END, do not use "unused"
// slots in the middle or you will mess up all of the shell32.dll icon indexes that
// are hardcoded and persisted in vaious places.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Icon id's
#define IDI_DOCUMENT            1      // generic document (blank page)
#define IDI_DOCASSOC            2      // generic associated document (with stuff on the page)
#define IDI_APP                 3      // application (exe)
#define IDI_FOLDER              4      // folder
#define IDI_FOLDEROPEN          5      // open folder
#define IDI_DRIVE525            6      // 5.25 floppy
#define IDI_DRIVE35             7      // 3.5  floppy
#define IDI_DRIVEREMOVE         8      // Removeable drive
#define IDI_DRIVEFIXED          9      // fix disk, regular hard drive
#define IDI_DRIVENET            10     // Remote drive
#define IDI_DRIVENETDISABLED    11     // Remote drive icon (disconnected)
#define IDI_DRIVECD             12     // CD-ROM drive
#define IDI_DRIVERAM            13     // RAM drive
#define IDI_WORLD               14     // World
#define IDI_NETWORK             15     // Network
#define IDI_SERVER              16     // Server
#define IDI_PRINTER             17     // Printer
#define IDI_MYNETWORK           18     // The My Network icon
#define IDI_GROUP               19     // Group
#define IDI_STPROGS             20     // Startmenu images.
#define IDI_STDOCS              21
#define IDI_STSETNGS            22
#define IDI_STFIND              23
#define IDI_STHELP              24
#define IDI_STRUN               25
#define IDI_STSUSPEND           26
#define IDI_STEJECT             27
#define IDI_STSHUTD             28     // Overlays.
#define IDI_SHARE               29     // shared thing (overlap)
#define IDI_LINK                30     // link icon (overlap)
#define IDI_SLOWFILE            31     // slow file icon (overlap)
#define IDI_RECYCLER            32
#define IDI_RECYCLERFULL        33
#define IDI_RNA                 34     // Remote Network Services
#define IDI_DESKTOP             35     // Desktop icon
#define IDI_STCPANEL            36     // More Startmenu images.
#define IDI_STSPROGS            37
#define IDI_STPRNTRS            38
#define IDI_STFONTS             39
#define IDI_STTASKBR            40      // WARNING! Explorer.exe hard-codes this value
#define IDI_CDAUDIO             41      // CD Audio Disc
#define IDI_TREE                42      // Network Directory Tree
#define IDI_STCPROGS            43
#define IDI_STFAV               44      // Start menu's favorite icon
#define IDI_STLOGOFF            45
#define IDI_STFLDRPROP          46
#define IDI_WINUPDATE           47
#define IDI_MU_SECURITY         48
#define IDI_MU_DISCONN          49
#define IDI_TB_DOCFIND_CLR      50
#define IDI_TB_DOCFIND_GRAY     51
#define IDI_TB_COMPFIND_CLR     52
#define IDI_TB_COMPFIND_GRAY    53
#define IDI_DRIVEUNKNOWN        54
#define IDI_MULDOC              133     // multiple documents
#define IDI_DOCFIND             134     // Used for document find window...
#define IDI_COMPFIND            135     // Used For find Computer window...
#define IDI_CPLFLD              137      // Control panel folder icon
#define IDI_PRNFLD              138      // Printers folder icon
#define IDI_NEWPRN              139      // New printer icon
#define IDI_PRINTER_NET         140      // Network printer icon
#define IDI_PRINTER_FILE        141      // File printer icon
#define IDI_DELETE_FILE         142      // delete file confirm icon
#define IDI_DELETE_FOLDER       143      // delete folder confirm icon
#define IDI_DELETE_MULTIPLE     144      // delete files and folders
#define IDI_REPLACE_FILE        145      // replace file icon
#define IDI_REPLACE_FOLDER      146      // replace folder
#define IDI_RENAME              147      // rename file/folder
#define IDI_MOVE                148      // move file/folder
#define IDI_INIFILE             151      // .ini file
#define IDI_TXTFILE             152      // .txt file
#define IDI_BATFILE             153      // .bat file
#define IDI_SYSFILE             154      // system file (.54, .vxd, ...)
#define IDI_FONFILE             155      // .fon
#define IDI_TTFFILE             156      // .ttf
#define IDI_PFMFILE             157      // .pfm (Type 1 font)
#define IDI_RUNDLG              160      // Icon in the Run dialog
#define IDI_NUKEFILE            161
#define IDI_BACKUP              165
#define IDI_CHKDSK              166
#define IDI_DEFRAG              167
#define IDI_DEF_PRINTER         168
#define IDI_DEF_PRINTER_NET     169
#define IDI_DEF_PRINTER_FILE    170
#define IDI_NDSCONTAINER        171      // Novell NDS Container
#define IDI_SERVERSHARE         172      // \\server\share icon
#define IDI_FAVORITES           173
#define IDI_ATTRIBS             174      // "Advanced" file/folder attribs icon
#define IDI_NETCONNECT          175
#define IDI_ADDNETPLACE         176      // Network Places Wizard
#define IDI_FOLDERVIEW          177
#define IDI_HTTFILE             178
#define IDI_CSC                 179     // ClientSideCaching
#define IDI_ACTIVEDESK_ON       180     // Warning: Do not change the order and sequence of the following IDI_* values.
#define IDI_ACTIVEDESK_OFF      181     // The code assumes and asserts if the order changes.
#define IDI_WEBVIEW_ON          182     
#define IDI_WEBVIEW_OFF         183     
#define IDI_SAME_WINDOW         184
#define IDI_SEPARATE_WINDOW     185
#define IDI_SINGLE_CLICK        186
#define IDI_DOUBLE_CLICK        187     // End of warning: Do not change the order of the above IDI_ values.
#define IDI_OLD_RECYCLER        191
#define IDI_OLD_RECYCLER_FULL   192
#define IDI_OLD_MYNETWORK       193
#define IDI_PASSWORD            194
#define IDI_PSEARCH             195     // Printers search icon
#define IDI_FAX_PRINTER         196     // new icons for the fax printer
#define IDI_FAX_PRINTER_DEF     197
#define IDI_FAX_PRINTER_DEF_NET 198
#define IDI_FAX_PRINTER_NET     199
#define IDI_STFRIENDLYLOGOFF    220
#define IDI_STFRIENDLYPOWEROFF  221
#define IDI_AP_VIDEO            222
#define IDI_AP_ITEM             223
#define IDI_AP_FILMSTRP         224
#define IDI_AP_DMIDI            225
#define IDI_AP_PICS             226
#define IDI_AP_MULTI            227
#define IDI_AP_CDAUDIO          228
#define IDI_AP_SANDISK          229
#define IDI_AP_ZIPDRIVE         230
#define IDI_CDSTAGED            231      // cd burn
#define IDI_CDWILLOVERWRITE     232
#define IDI_AP_MEMSTICKW        233
#define IDI_AP_ZIPNOMEDIA       234
#define IDI_MYDOCS              235
#define IDI_MYPICS              236
#define IDI_MYMUSIC             237
#define IDI_MYVIDEOS            238
#define IDI_MSN                 239
#define IDI_TASK_DELETE             240
#define IDI_TASK_MOVE               241
#define IDI_TASK_RENAME             242
#define IDI_TASK_COPY               243
#define IDI_TASK_PUBLISH            244
#define IDI_TASK_PRINT              245
#define IDI_TASK_PLAY_MUSIC         246
#define IDI_TASK_BUY_MUSIC          247
#define IDI_TASK_GETFROMCAMERA      248
#define IDI_TASK_SLIDESHOW          249
#define IDI_TASK_SETASWALLPAPER     250
#define IDI_TASK_ORDERPRINTS        251
#define IDI_TASK_PRINTPICTURES      252
#define IDI_TASK_PROPERTIES         253
#define IDI_TASK_EMPTYRECYCLEBIN    254
#define IDI_TASK_RESTOREITEMS       255
#define IDI_TASK_UPDATEITEMS        256
#define IDI_TASK_VIEWNETCONNECTIONS 257
#define IDI_TASK_ADDNETWORKPLACE    258
#define IDI_TASK_HOMENETWORKWIZARD  259
#define IDI_TASK_BURNCD             260
#define IDI_TASK_CLEARBURNAREA      261
#define IDI_TASK_ERASECDFILES       262
#define IDI_TASK_CDBURN_HELP        263
#define IDI_TASK_OPENCONTAININGFOLDER 264
#define IDI_TASK_EMAILFILE          265
#define IDI_TASK_SENDTOAUDIOCD      266
#define IDI_TASK_SHARE              267
#define IDI_TASK_HELP               IDI_STHELP
//
// Control Panel view icons
//
#define IDI_CPCAT_ACCESSIBILITY     268  // Category icons
#define IDI_CPCAT_ACCOUNTS          269  //      .
#define IDI_CPCAT_APPEARANCE        270  //      .
#define IDI_CPCAT_ARP               271  //      .
#define IDI_CPCAT_HARDWARE          272  //      .
#define IDI_CPCAT_NETWORK           273  //      .
#define IDI_CPCAT_OTHERCPLS         274  //      .
#define IDI_CPCAT_PERFMAINT         275  //      .
#define IDI_CPCAT_REGIONAL          276  //      .
#define IDI_CPCAT_SOUNDS            277  // Category icons
#define IDI_CPTASK_ACCESSUTILITYMGR 278
#define IDI_CPTASK_ACCOUNTSPICT     279
#define IDI_CPTASK_DISPLAYCPL       280
#define IDI_CPTASK_MAGNIFIER        281
#define IDI_CPTASK_NARRATOR         282
#define IDI_CPTASK_ONSCREENKBD      283
#define IDI_CPTASK_HIGHCONTRAST     284
// unused                           285
// unused                           286
// unused                           287
// unused                           288
#define IDI_CPTASK_ASSISTANCE       289
#define IDI_CP_CATEGORYTASK         290  // Category task.

#define IDI_DVDDRIVE                291
#define IDI_MEDIACDAUDIOPLUS        292
#define IDI_MEDIACDEMPTY            293
#define IDI_MEDIACDROM              294
#define IDI_MEDIACDR                295
#define IDI_MEDIACDRW               296
#define IDI_MEDIADVDRAM             297
#define IDI_MEDIADVDR               298
#define IDI_AUDIOPLAYER             299
#define IDI_DEVICETAPEDRIVE         300
#define IDI_DEVICEOPTICALDRIVE      301
#define IDI_MEDIABLANKCD            302
#define IDI_MEDIACOMPFLASH          303
#define IDI_MEDIADVDROM             304
#define IDI_MEDIAMEMSTICK           305
#define IDI_MEDIAPCMCIA             306
#define IDI_MEDIASECUREDIGITALMEDIA 307
#define IDI_MEDIASMARTMEDIA         308
#define IDI_DEVICECAMERA            309
#define IDI_DEVICECELLPHONE         310
#define IDI_DEVICEHTTPPRINT         311
#define IDI_DEVICEJAZDRIVE          312
#define IDI_DEVICEZIPDRIVE          313
#define IDI_DEVICEPOCKETPC          314
#define IDI_DEVICESCANNER           315
#define IDI_DEVICESTI               316
#define IDI_DEVICEVIDEOCAM          317
#define IDI_MEDIADVDRW              318
#define IDI_TASK_NEWFOLDER          319
#define IDI_TASK_SENDTOCD           320
#define IDI_CPTASK_32CPLS           321
#define IDI_CLASSICSM_FAVORITES     322
#define IDI_CLASSICSM_FIND          323
#define IDI_CLASSICSM_HELP          324
#define IDI_CLASSICSM_LOGOFF        325
#define IDI_CLASSICSM_PROGS         326
#define IDI_CLASSICSM_RECENTDOCS    327
#define IDI_CLASSICSM_RUN           328
#define IDI_CLASSICSM_SHUTDOWN      329
#define IDI_CLASSICSM_SETTINGS      330
#define IDI_CLASSICSM_UNDOCK        331
#define IDI_TASK_SEARCHDS           337
#define IDI_NONE                    338
#define IDI_TASK_SHADOW             339

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// ADD NEW ICONS ABOVE THIS LINE 
// (see comment at the top of of the list of IDI_xxx defines)
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// unicpp\resource.h defines more icons starting at 200

// Add new icons here, and update ..\inc\shellp.h with the image index


// Bitmap id's
// Note: These bitmaps have been moved to moricons.dll (base\ntsetup\moricons) to save space in shell32.dll

#define IDB_ABOUT16             130
#define IDB_ABOUT256            131

#define IDB_SORT_UP             133
#define IDB_SORT_DN             134

#define IDB_FSEARCHTB_HOT       135
#define IDB_FSEARCHTB_DEFAULT   136

#define IDB_ABOUTBAND16         137
#define IDB_ABOUTBAND256        138

#define IDB_BRF_TB_SMALL        140
#define IDB_BRF_TB_LARGE        141
#define IDB_LINK_MERGE          142
#define IDB_PLUS_MERGE          143
#define IDB_TTBITMAP            145

#define IDB_ABOUTPERSONAL16     146
#define IDB_ABOUTPERSONAL256    147

#define IDB_ABOUTEMBEDDED16     148
#define IDB_ABOUTEMBEDDED256    149

#define IDB_ABOUTBLADE16        150
#define IDB_ABOUTBLADE256       151

#define IDB_ABOUTSBS16          152
#define IDB_ABOUTSBS256         153

#define IDB_ABOUTSRV16          154
#define IDB_ABOUTSRV256         155

#define IDB_ABOUTENT16          156
#define IDB_ABOUTENT256         157

#define IDB_ABOUTDCS16          158
#define IDB_ABOUTDCS256         159

// The toolbar ids are shared with browseui and shdocvw.  The defines
// can be found in shell\inc\tb_ids.h.  200 - 250 is reserved for toolbar
// bitmap strips.

#include <tb_ids.h>

#define IDB_BURNWIZ_WATERMARK   369

#define IDB_BURNWIZ_HEADER      390

// unicpp\resource.h defines more values starting at 256

#define IDA_SEARCH              150     // animation
#define IDA_FINDFILE            151     // animation
#define IDA_FINDCOMP            152     // animation for finding computers..

#define IDA_FILEMOVE            160     // animation file mode
#define IDA_FILECOPY            161     // animation file copy
#define IDA_FILEDEL             162     // animation move to waste basket
#define IDA_FILENUKE            163     // animation empty waste basket.
#define IDA_FILEDELREAL         164     // animation true delete bypass recycle bin
#define IDA_APPLYATTRIBS        165     // animation for applying file attributes
#define IDA_ISEARCH             166     // animation for finding URLs on the internet
#define IDA_CDBURN_TOSTAGING    167     // animation for adding files to the cdburn staging area
#define IDA_CDBURN_TOCD         168     // animation for burning files from the staging area to the cd
#define IDA_CDBURN_ERASE        169     // animation for erasing files from a CD-RW
#define IDA_DOWNLOAD            170     // animation: downloading files from the Internet (for web wizard host)

// RCDATA IDs

#define RCDATA_FONTSHORTCUT      0x4000
#define RCDATA_ADMINTOOLSHORTCUT 0x4001
// Dialog box IDs (note that these MUST BE decimal numbers)

#define DLG_BROWSE              1001
#define DLG_RESTART             1002
#define DLG_RUN                 1003
#define DLG_LINK_SEARCH         1004

#define DLG_RUNUSERLOGON        1007
#define DLG_DEADSHORTCUT_MATCH  1008
#define DLG_DEADSHORTCUT        1009

#define DLG_LFNTOFAT            1010
#define DLG_DELETE_FILE         1011
#define DLG_DELETE_FOLDER       1012
#define DLG_DELETE_MULTIPLE     1013
#define DLG_REPLACE_FILE        1014
#define DLG_REPLACE_FOLDER      1015
#define DLG_MOVE_FILE           1016
#define DLG_MOVE_FOLDER         1017
#define DLG_RENAME_FILE         1018
#define DLG_RENAME_FOLDER       1019
#define DLG_MOVECOPYPROGRESS    1020
#define DLG_WONT_RECYCLE_FOLDER 1021
#define DLG_WONT_RECYCLE_FILE   1022
#define DLG_STREAMLOSS_ON_COPY  1023
#define DLG_RETRYFOLDERENUM     1024
#define DLG_DELETE_FILE_ARP     1025
#define DLG_PATH_TOO_LONG       1026
#define DLG_FAILED_ENCRYPT      1027
#define DLG_WONT_RECYCLE_OFFLINE 1028
#define DLG_DELETE_STAGING      1029
#define DLG_LOST_ENCRYPT_FILE   1030
#define DLG_LOST_ENCRYPT_FOLDER 1031

#define DLG_LINKPROP            1040
#define DLG_FILEPROP            1041
#define DLG_FILEMULTPROP        1042
#define DLG_VERSION             1043
#define DLG_FOLDERPROP          1044
#define DLG_BITBUCKET_GENCONFIG 1045
#define DLG_BITBUCKET_CONFIG    1046
#define DLG_DELETEDFILEPROP     1047
#define DLG_FOLDERSHORTCUTPROP  1048
#define DLG_LINKPROP_ADVANCED   1049

#define DLG_BROWSEFORDIR        1050
#define DLG_FINDEXE             1051
// these are still in shell.dll
// #define DLG_ABOUT            1052

#define DLG_RUNSETUPLOGON       1053
#define DLG_FILEATTRIBS         1054
#define DLG_FOLDERATTRIBS       1055
#define DLG_ATTRIBS_RECURSIVE   1056
#define DLG_APPLYATTRIBSPROGRESS 1057
#define DLG_ATTRIBS_ERROR       1058

#define DLG_PICKICON            1060
#define DLG_ASSOCIATE           1061
#define DLG_FIND                1062
#define DLG_OPENAS              1063
#define DLG_TSINSTALLFAILURE    1064
#define DLG_FIND_BROWSE         1065
#define DLG_DFNAMELOC           1066
#define DLG_DFDETAILS           1067
#define DLG_DFDATE              1068
#define DLG_NFNAMELOC           1069
#define DLG_OPENAS_NOTYPE       1070
#define DLG_LOGOFFWINDOWS       1071

#define DLG_BROWSEFORFOLDER     1079  // Browse for folders for doc and net finds

#define DLG_DRV_GENERAL         1080
#define DLG_DISKTOOLS           1081

// ------- UNUSED ------------- 1082

#ifdef MEMMON
#define DLG_MEMMON              1083
#endif

#define DLG_CPL_FILLCACHE       1084

// ------- UNUSED ------------- 1085
#define DLG_DISKCOPYPROGRESS    1086

#define DLG_BROWSEFORFOLDER2    1087  // New UI

#define DLG_DRV_HWTAB           1088

#define DLG_SWITCHUSER          1089
#define DLG_DISCONNECTWINDOWS   1090
#define DLG_OPENAS_DOWNALOAD    1091

#define DLG_DISKERR             1095
#define DLG_COLUMN_SETTINGS     1096
#define DLG_MOUNTEDDRV_GENERAL  1098

#define DLG_FILETYPEOPTIONS     1099
#define DLG_FILETYPEOPTIONSEDIT 1100
#define DLG_FILETYPEOPTIONSCMD  1101

#define DLG_NOOPEN              1103

#define DLG_ENCRYPTWARNING      1104

#define DLG_FSEARCH_MAIN        1105
#define DLG_FSEARCH_DATE        1106
#define DLG_FSEARCH_TYPE        1107
#define DLG_FSEARCH_SIZE        1108
#define DLG_FSEARCH_ADVANCED    1109

#define DLG_INDEXSERVER         1110

#define DLG_FILETYPEOPTIONSEDITNEW          1111

#define DLG_PSEARCH             1112
#define DLG_CSEARCH             1113
#define DLG_FSEARCH_OPTIONS     1114

#define DLG_RENAME_MESSAGEBOXCHECK  1115
#define IDC_MBC_TEXT                0x2000
#define IDC_MBC_ICON                0x2001

#define DLG_FSEARCH_SCOPEMISMATCH    1116
#define DLG_FSEARCH_INDEXNOTCOMPLETE 1117

#define DLG_DRV_RECORDINGTAB         1118

#define DLG_AUTOPLAY                 1119
#define DLG_APMIXEDCONTENT           1120
#define DLG_APPROMPTUSER             1121
#define DLG_APNOCONTENT              1122

#define DLG_FOLDER_CUSTOMIZE         1124

#define DLG_WEBWIZARD                1125

#define DLG_BURNWIZ_WELCOME          1126
#define DLG_BURNWIZ_BURN_SUCCESS     1127
#define DLG_BURNWIZ_MUSIC            1128
#define DLG_BURNWIZ_EJECT            1129
#define DLG_BURNWIZ_PROGRESS         1130
#define DLG_BURNWIZ_BURN_FAILURE     1131
#define DLG_BURNWIZ_WAITFORMEDIA     1132
#define DLG_BURNWIZ_STARTERASE       1133
#define DLG_BURNWIZ_ERASE_SUCCESS    1134
#define DLG_BURNWIZ_ERASE_FAILURE    1135
#define DLG_BURNWIZ_DISCFULL         1136
#define DLG_BURNWIZ_HDFULL           1137
#define DLG_BURNWIZ_NOFILES          1138

// for Dead shortcut dialogs
#define IDC_DEADTEXT1 0x100
#define IDC_DEADTEXT2 0x101
#define IDC_DELETE    0x105

// menuband\mnbandid.h defines more DLG_ values starting at 0x2000
// unicpp\resource.h defines more DLG_ values starting at 0x7500

// String IDs (these are hex so that groups of 16 are easily distinguished)

#define IDS_VERSIONMSG        60
#define IDS_DEBUG             61
#define IDS_LDK               62
#define IDS_DATESIZELINE      64
#define IDS_FILEDELETEWARNING 65
#define IDS_FOLDERDELETEWARNING 66
#define IDS_FILERECYCLEWARNING 67
#define IDS_FOLDERRECYCLEWARNING 68
#define IDS_LICENCEINFOKEY      69
#define IDS_REGUSER             70
#define IDS_REGORGANIZATION     71
#define IDS_CURRENTVERSION      72
#define IDS_PRODUCTID           73
#define IDS_OEMID               74
#define IDS_PROCESSORINFOKEY    75
#define IDS_PROCESSORIDENTIFIER 76

// all commands that can have help in the status bar or tool tips
// need to be put before IDS_LAST_COMMAND
#define IDS_LAST_COMMAND        0x2FFF

#define IDS_FIRST               0x1000

#define IDS_REPLACING           0x1000
#define IDS_UNFORMATTED         0x1001
#define IDS_LOCATION            0x1002
#define IDS_DESTFULL            0x1003
#define IDS_WRITEPROTECTFILE    0x1004
#define IDS_NETERR              0x1005
#define IDS_DRIVENOTREADY       0x1006
#define IDS_CREATELONGDIR       0x1007
#define IDS_CREATELONGDIRTITLE  0x1008
#define IDS_FMTERROR            0x1009
#define IDS_NOFMT               0x100a
#define IDS_CANTSHUTDOWN        0x100b
#define IDS_INVALIDFN           0x100d
#define IDS_INVALIDFNFAT        0x100e
#define IDS_ENUMABORTED         0x100f
#define IDS_WARNCHANGEEXT       0x1010

#define IDS_BYTES               0x1011
#define IDS_FORMAT_TITLE        0x1012
#define IDS_MVUNFORMATTED       0x1013
#define IDS_UNFORMATTABLE_DISK  0x1014
#define IDS_UNRECOGNIZED_DISK   0x1015
#define IDS_SIZEANDBYTES        0x1016
#define IDS_SIZE                0x1017

#define IDS_NOWINDISK           0x1018
#define IDS_VERBHELP            0x1019

#define IDS_DRIVELETTER         0x101A
#define IDS_NONULLNAME          0x101B

#define IDS_FINDNOTFINDABLE     0x101C
#define IDS_FINDMAXFILESFOUND   0x101D
#define IDS_FINDMONITORNEWITEMS 0x101E
#define IDS_FINDNOTHINGFOUND    0x101F
#define IDS_PATHNOTTHERE        0x1020
#define IDS_FINDVIEWEMPTY       0x1021
#define IDS_FILETYPENAME        0x1022
#define IDS_FOLDERTYPENAME      0x1023
#define IDS_FILEWONTFIT         0x1024
#define IDS_FILE                0x1025
#define IDS_FINDFILES           0x1026
#define IDS_FINDWRONGPATH       0x1027
#define IDS_FINDDATAREQUIRED    0x1028
#define IDS_FINDINVALIDNUMBER   0x1029
#define IDS_FINDINVALIDDATE     0x102a
#define IDS_FINDGT              0x102b
#define IDS_FINDLT              0x102c
#define IDS_FINDRESET           0x102d
#define IDS_FINDALLFILETYPES    0x102e
#define IDS_FINDOUTOFMEM        0x102f

#define IDS_UNDO_FILEOP         0x102f
#define IDS_MOVE                (IDS_UNDO_FILEOP + FO_MOVE)
#define IDS_COPY                (IDS_UNDO_FILEOP + FO_COPY)
#define IDS_DELETE              (IDS_UNDO_FILEOP + FO_DELETE)
#define IDS_RENAME              (IDS_UNDO_FILEOP + FO_RENAME)

#define IDS_RUN_NORMAL          0x1034
#define IDS_RUN_MINIMIZED       0x1035
#define IDS_RUN_MAXIMIZED       0x1036

#define IDS_LINKTITLE           0x1037
#define IDS_LINKTO              0x1038
#define IDS_MULTIINVOKEPROMPT_TITLE     0x1039
#define IDS_MULTIINVOKEPROMPT_MESSAGE   0x103a
#define IDS_NONE                0x103b
#define IDS_NEW                 0x103c
#define IDS_CLOSE               0x103d
#define IDS_LINKEXTENSION       0x103e
#define IDS_ANOTHER             0x103f
#define IDS_YETANOTHER          0x1040

// This definition is hard coded in \nt\private\windows\shell\cpls\powercfg,
// if you change it here, change it there.
#define IDS_CONTROLPANEL        0x1041
#define IDS_DESKTOP             0x1042
#define IDS_UNDO                0x1043
#define IDS_UNDOACCEL           0x1044
#define IDS_UNDOMENU            0x1045
#define IDS_DOCUMENTFOLDERS     0x1046

#define IDS_SELECTALLBUTHIDDEN  0x104a
#define IDS_SELECTALL           0x104b
#define IDS_ACTIVEDESKTOP       0x104d
#define IDS_COMPSETTINGS        0x104e
#define IDS_BACKSETTINGS        0x104f
#define IDS_APPEARANCESETTINGS  0x1050
// unused
#define IDS_COPYLONGPLATE       0x1052
#define IDS_BRIEFTEMPLATE       0x1053
#define IDS_BRIEFEXT            0x1054
#define IDS_BRIEFLONGPLATE      0x1055
#define IDS_BOOKMARK_S          0x1056
#define IDS_BOOKMARK_L          0x1057
#define IDS_FINDINVALIDFILENAME 0x1058
#define IDS_SCRAP_S             0x105a
#define IDS_SCRAP_L             0x105b
//reuse aaah theres no space around here    0x105c
#define IDS_TURNOFFSTARTPAGE    0x105d
#define IDS_TURNONSTARTPAGE     0x105e

#define IDS_UNDO_FILEOPHELP     0x105f
#define IDS_MOVEHELP            (IDS_UNDO_FILEOPHELP + FO_MOVE)
#define IDS_COPYHELP            (IDS_UNDO_FILEOPHELP + FO_COPY)
#define IDS_DELETEHELP          (IDS_UNDO_FILEOPHELP + FO_DELETE)
#define IDS_RENAMEHELP          (IDS_UNDO_FILEOPHELP + FO_RENAME)

#define IDS_HTML_FILE_RENAME    0x1068
#define IDS_HTML_FOLDER_RENAME  0x1069

#define IDS_THUMBNAILVIEW       0x106d
#define IDS_THUMBHELPTEXT       0x106e
//#define IDS_CANNOTENABLETHUMBS  0x106f

#define IDS_LINKERROR           0x1070
#define IDS_LINKBADWORKDIR      0x1071
#define IDS_LINKBADPATH         0x1072
#define IDS_LINKNOTFOUND        0x1073
#define IDS_LINKCHANGED         0x1074
#define IDS_SPACEANDSPACE       0x1075
#define IDS_COMMASPACE          0x1076
#define IDS_LINKUNAVAILABLE     0x1077
#define IDS_LINKNOTLINK         0x1078
#define IDS_LINKCANTSAVE        0x1079
#define IDS_LINKTOLINK          0x107A

//#define IDS_CANNOTDISABLETHUMBS 0x107B

#define IDS_VOLUMELABEL                 0x107C
#define IDS_MOUNTEDVOLUME               0x107D
#define IDS_UNLABELEDVOLUME             0x107E
#define IDS_WALK_PROGRESS_TITLE         0x107F

#define IDS_ENUMERR_NETTEMPLATE1        0x1080
#define IDS_ENUMERR_NETTEMPLATE2        0x1081
#define IDS_ENUMERR_FSTEMPLATE          0x1082
#define IDS_ENUMERR_NETGENERIC          0x1083
#define IDS_ENUMERR_FSGENERIC           0x1084
#define IDS_ENUMERR_PATHNOTFOUND        0x1085
#define IDS_SHLEXEC_ERROR               0x1086
#define IDS_SHLEXEC_ERROR2              0x1087
#define IDS_ENUMERR_PATHTOOLONG         0x1088

#define IDS_APP_FAULTED_IN              0x1089
#define IDS_APP_NOT_FAULTED_IN          0x108a

#define IDS_CSC_STATUS                  0x108b
#define IDS_CSC_STATUS_ONLINE           0x108c
#define IDS_CSC_STATUS_OFFLINE          0x108d

#define IDS_ERR_VOLUMELABELBAD          0x1091
#define IDS_TITLE_VOLUMELABELBAD        0x1092
#define IDS_ERR_VOLUMEUNFORMATTED       0x1093

#define IDS_CANT_FIND_MYDOCS_NET        0x1094
#define IDS_CANT_FIND_MYDOCS            0x1095

#define IDS_COL_CM_MORE                 0x1099

#define IDS_DSPTEMPLATE_WITH_BACKSLASH  0x10a0
#define IDS_DSPTEMPLATE_WITH_ON         0x10a1

#define IDS_ARRANGEBY_HELPTEXT          0x10a3
#define IDS_GROUPBY_HELPTEXT            0x10a4
#define IDS_GROUPBYITEM_HELPTEXT        0x10a5

// Network Location possible value
#define IDS_NETLOC_INTERNET             0x10a6
#define IDS_NETLOC_LOCALNETWORK         0x10a7


//
// RestartDialog Text Strings
//
#define IDS_RSDLG_TITLE             0x10b0
#define IDS_RSDLG_SHUTDOWN          0x10b1
#define IDS_RSDLG_RESTART           0x10b2
#define IDS_RSDLG_PIFFILENAME       0x10b3
#define IDS_RSDLG_PIFSHORTFILENAME  0x10b4

// CopyDisk text strings
#define IDS_INSERTDEST                  0x10C0
#define IDS_INSERTSRC                   0x10C1
#define IDS_INSERTSRCDEST               0x10C2
#define IDS_FORMATTINGDEST              0x10C3
#define IDS_COPYSRCDESTINCOMPAT         0x10C4


//
// Reserve a range for DefView MenuHelp
//
#define IDS_MH_SFVIDM_FIRST     0x1100
#define IDS_MH_SFVIDM_LAST      0x11ff

//
// Reserve a range for DefView client MenuHelp
//
#define IDS_MH_FSIDM_FIRST      0x1200
#define IDS_MH_FSIDM_LAST       0x12ff

//
// Reserve a range for DefView ToolTips
//
#define IDS_TT_SFVIDM_FIRST     0x1300
#define IDS_TT_SFVIDM_LAST      0x13ff

//
// Reserve a range for DefView client ToolTips
//
#define IDS_TT_FSIDM_FIRST      0x1400
#define IDS_TT_FSIDM_LAST       0x14ff

//
// IDS for Open With Context Menu
//
#define IDS_OPENWITH            0x1500
#define IDS_OPENWITHNEW         0x1501
#define IDS_OPENWITHBROWSE      0x1502
#define IDS_OPENWITHHELP        0x1503
#define IDS_OPENWITHAPPHELP     0x1504


//
// IDS for CStartMenuPin
//
#define IDS_STARTPIN_PINME              0x1505
#define IDS_STARTPIN_UNPINME            0x1506
#define IDS_STARTPIN_PINME_HELP         0x1507
#define IDS_STARTPIN_UNPINME_HELP       0x1508

// IDS for stream loss copy information

#define IDS_DOCSUMINFOSTREAM    0x1510
#define IDS_SUMINFOSTREAM       0x1511
#define IDS_MACINFOSTREAM       0x1512
#define IDS_MACRESSTREAM        0x1513
#define IDS_UNKNOWNPROPSET      0x1514
#define IDS_GLOBALINFOSTREAM    0x1516
#define IDS_IMAGECONTENTS       0x1517
#define IDS_IMAGEINFO           0x1518
#define IDS_USERDEFPROP         0x1519
#define IDC_STREAMSLOST         0x151a
#define IDS_AUDIOSUMINFO        0x151b
#define IDS_VIDEOSUMINFO        0x151c
#define IDS_MEDIASUMINFO        0x151d

#define IDS_FILEERROR           0x1700
#define IDS_FILEERRORCOPY       (IDS_FILEERROR + FO_COPY)
#define IDS_FILEERRORMOVE       (IDS_FILEERROR + FO_MOVE)
#define IDS_FILEERRORDEL        (IDS_FILEERROR + FO_DELETE)
#define IDS_FILEERRORREN        (IDS_FILEERROR + FO_RENAME)
// space needed

#define IDS_ACTIONTITLE         0x1740
#define IDS_ACTIONTITLECOPY     (IDS_ACTIONTITLE + FO_COPY)
#define IDS_ACTIONTITLEMOVE     (IDS_ACTIONTITLE + FO_MOVE)
#define IDS_ACTIONTITLEDEL      (IDS_ACTIONTITLE + FO_DELETE)
#define IDS_ACTIONTITLEREN      (IDS_ACTIONTITLE + FO_RENAME)

#define IDS_FROMTO              0x1750
#define IDS_FROM                0x1751
#define IDS_PREPARINGTO         0x1752
#define IDS_COPYTO              0x1753
#define IDS_COPYERROR           0x1754

#define IDS_COPYING             0x1756
#define IDS_MOVEERROR           0x1757
#define IDS_MOVING              0x1758
#define IDS_CALCMOVETIME        0x1759
#define IDS_CALCCOPYTIME        0x175A

// space needed

#define IDS_VERBS               0x1780
#define IDS_VERBSCOPY           (IDS_VERBS + FO_COPY)
#define IDS_VERBSMOVE           (IDS_VERBS + FO_MOVE)
#define IDS_VERBSDEL            (IDS_VERBS + FO_DELETE)
#define IDS_VERBSREN            (IDS_VERBS + FO_RENAME)
// space needed

#define IDS_ACTIONS             0x17c0
#define IDS_ACTIONS1            (IDS_ACTIONS + 1)
#define IDS_ACTIONS2            (IDS_ACTIONS + 2)
// space needed

#define IDS_REASONS             0x1800

#define IDS_REASONS_INVFUNCTION (IDS_REASONS + ERROR_INVALID_FUNCTION)
#define IDS_REASONS_INVHANDLE   (IDS_REASONS + ERROR_INVALID_HANDLE)
#define IDS_REASONS_INVFILEACC  (IDS_REASONS + ERROR_INVALID_ACCESS)
#define IDS_REASONS_NOTSAMEDEV  (IDS_REASONS + ERROR_NOT_SAME_DEVICE)
#define IDS_REASONS_DELCURDIR   (IDS_REASONS + ERROR_CURRENT_DIRECTORY)
#define IDS_REASONS_NOHANDLES   (IDS_REASONS + ERROR_TOO_MANY_OPEN_FILES)
#define IDS_REASONS_FILENOFOUND (IDS_REASONS + ERROR_FILE_NOT_FOUND)
#define IDS_REASONS_PATHNOFOUND (IDS_REASONS + ERROR_PATH_NOT_FOUND)
#define IDS_REASONS_ACCDENIED   (IDS_REASONS + ERROR_ACCESS_DENIED)
#define IDS_REASONS_INSMEM      (IDS_REASONS + ERROR_NOT_ENOUGH_MEMORY)
#define IDS_REASONS_NODIRENTRY  (IDS_REASONS + ERROR_NO_MORE_FILES)
#define IDS_REASONS_WRITEPROT   (IDS_REASONS + ERROR_WRITE_PROTECT)
#define IDS_REASONS_NETACCDEN   (IDS_REASONS + ERROR_NETWORK_ACCESS_DENIED)
#define IDS_REASONS_BADNETNAME  (IDS_REASONS + ERROR_BAD_NET_NAME)
#define IDS_REASONS_SHAREVIOLA  (IDS_REASONS + ERROR_SHARING_VIOLATION)
#define IDS_REASONS_WRITEFAULT  (IDS_REASONS + ERROR_WRITE_FAULT)
#define IDS_REASONS_GENFAILURE  (IDS_REASONS + ERROR_GEN_FAILURE)
#define IDS_REASONS_NODISKSPACE (IDS_REASONS + ERROR_DISK_FULL)
#define IDS_REASONS_RENREPLACE  (IDS_REASONS + ERROR_ALREADY_EXISTS)
// our internal errors
#define IDS_REASONS_PATHTODEEP       (IDS_REASONS + DE_PATHTODEEP)
#define IDS_REASONS_SAMEFILE         (IDS_REASONS + DE_SAMEFILE)
#define IDS_REASONS_MANYSRC1DST      (IDS_REASONS + DE_MANYSRC1DEST)
#define IDS_REASONS_DIFFDIR          (IDS_REASONS + DE_DIFFDIR)
#define IDS_REASONS_ROOTDIR          (IDS_REASONS + DE_ROOTDIR)
#define IDS_REASONS_DESTSUBTREE      (IDS_REASONS + DE_DESTSUBTREE)
#define IDS_REASONS_WINDOWSFILE      (IDS_REASONS + DE_WINDOWSFILE)
#define IDS_REASONS_ACCDENYSRC       (IDS_REASONS + DE_ACCESSDENIEDSRC)
#define IDS_REASONS_MANYDEST         (IDS_REASONS + DE_MANYDEST)
#define IDS_REASONS_INVFILES         (IDS_REASONS + DE_INVALIDFILES)
#define IDS_REASONS_DESTSAMETREE     (IDS_REASONS + DE_DESTSAMETREE)
#define IDS_REASONS_FLDDESTISFILE    (IDS_REASONS + DE_FLDDESTISFILE)
#define IDS_REASONS_COMPRESSEDVOLUME (IDS_REASONS + DE_COMPRESSEDVOLUME)
#define IDS_REASONS_FILEDESTISFLD    (IDS_REASONS + DE_FILEDESTISFLD)
#define IDS_REASONS_FILENAMETOOLONG  (IDS_REASONS + DE_FILENAMETOOLONG)
#define IDS_REASONS_DEST_IS_CDROM    (IDS_REASONS + DE_DEST_IS_CDROM)
#define IDS_REASONS_DEST_IS_DVD      (IDS_REASONS + DE_DEST_IS_DVD)
#define IDS_REASONS_DEST_IS_CDRECORD (IDS_REASONS + DE_DEST_IS_CDRECORD)

// space needed

#define IDS_STILLNOTFOUND       0x191d
#define IDS_PROGFOUND           0x191e
#define IDS_PROGNOTFOUND        0x191f
#define IDS_NOCOMMDLG           0x1920

#define IDS_CANTDELETESPECIALDIR   0x1922
#define IDS_CANTMOVESPECIALDIRHERE 0x1923
#define IDS_WNETOPENENUMERR     0x1924
#define IDS_NEWFOLDER_NOT_HERE  0x1925
#define IDS_NEWFOLDER_NOT_HERE_TITLE 0x1926
#define IDS_SHAREVIOLATION_HINT 0x1927

#define IDS_CANTLOGON           0x192A

#define IDS_AD_NAME             0x1930

#define IDS_SHARINGERROR        0x1933
#define IDS_COULDNOTSHARE       0x1934

#define IDS_CREATIONERROR       0x1935
#define IDS_COULDNOTCREATE      0x1936
#define IDS_ALLUSER_WARNING     0x1937
#define IDS_CANTFINDORIGINAL    0x1938
// #define 0x1939

#define IDS_FOLDERDOESNTEXIST  0x193A
#define IDS_CREATEFOLDERPROMPT 0x193B
#define IDS_CREATEFOLDERFAILED 0x193C
#define IDS_DIRCREATEFAILED_TITLE 0x193D
#define IDS_FOLDER_NOT_ALLOWED_TITLE 0x193E
#define IDS_FOLDER_NOT_ALLOWED 0x193F

#define IDS_FINDORIGINAL       0x1940


// WARNING!  These must be in exactly the order below because the message
// number is computed.
#define DIDS_FSHIDDEN          1
#define DIDS_FSSPACE           2
#define IDS_FSSTATUSBASE        0x1942
#define IDS_FSSTATUSHIDDEN      0x1943  // IDS_FSSTATUSBASE + DIDS_FSHIDDEN
#define IDS_FSSTATUSSPACE       0x1944  // IDS_FSSTATUSBASE + DIDS_FSSPACE
#define IDS_FSSTATUSHIDDENSPACE 0x1945  // IDS_FSSTATUSBASE + DIDS_FSHIDDEN + DIDS_FSSPACE

// #define IDS_DRIVESSTATUSTEMPLATE     0x1946 (unused)
#define IDS_DETAILSUNKNOWN              0x1947
#define IDS_MOVEBRIEFCASE               0x1948
#define IDS_DELETEBRIEFCASE             0x1949
#define IDS_NOTCUSTOMIZABLE             0x194A
#define IDS_HTMLFILE_NOTFOUND           0x194B
#define IDS_CUSTOMIZE_THIS_FOLDER       0x194C

#define IDS_FSSTATUSSELECTED    0x194D
#define IDS_FSSTATUSSEARCHING   0x194E

#define IDS_FILECREATEFAILED_TITLE 0x194F

/* These defines are used by setup to modify the user and company name which
   the about box will display.  The location of the user and company name
   are determined by looking for a search tag in the string resource table
   just before the user and company name.  This is why it is very important
   that the following 3 IDS's always be consecutive and within the same
   resource segment.  The same resource segment can be guaranteed by ensuring
   that the IDS's all be within a 16-aligned page (i.e. (n*16) to (n*16 + 15).
 */
#define IDS_SEARCH_TAG          0x1980
#define IDS_USER_NAME           0x1981
#define IDS_ORG_NAME            0x1982


// shutdown dialog #defines - 0x2000 - 0x20FF
// strings
#define IDS_SHUTDOWN_NAME       0x2000
#define IDS_SHUTDOWN_DESC       0x2001
#define IDS_RESTART_NAME        0x2002
#define IDS_RESTART_DESC        0x2003
#define IDS_SLEEP_NAME          0x2004
#define IDS_SLEEP_DESC          0x2005
#define IDS_SLEEP2_NAME         0x2006
#define IDS_SLEEP2_DESC         0x2007
#define IDS_HIBERNATE_NAME      0x2008
#define IDS_HIBERNATE_DESC      0x2009
#define IDS_LOGOFF_NAME         0x200A
#define IDS_LOGOFF_DESC         0x200B
#define IDS_RESTARTDOS_NAME     0x200C
#define IDS_RESTARTDOS_DESC     0x200D

// dialog and controls
#define IDC_EXITOPTIONS_COMBO   0x2020
#define IDC_EXITOPTIONS_DESCRIPTION 0x2021
#define IDD_EXITWINDOWS_DIALOG  0x2022

// icon
#define IDI_SHUTDOWN            0x2030


#ifdef UNICODE
#define IDS_PathNotFound         IDS_PathNotFoundW
#else // UNICODE
#define IDS_PathNotFound         IDS_PathNotFoundA
#endif // UNICODE

// these are bogus

#define IDS_LowMemError          0x2100
#define IDS_RunFileNotFound      0x2101
#define IDS_PathNotFoundA        0x2102
#define IDS_TooManyOpenFiles     0x2103
#define IDS_RunAccessDenied      0x2104
#define IDS_OldWindowsVer        0x2105
#define IDS_OS2AppError          0x2106
#define IDS_MultipleDS           0x2107
#define IDS_InvalidDLL           0x2108
#define IDS_ShareError           0x2109
#define IDS_AssocIncomplete      0x210a
#define IDS_DDEFailError         0x210b
#define IDS_NoAssocError         0x210c
#define IDS_BadFormat            0x210d
#define IDS_RModeApp             0x210e
#define IDS_PathNotFoundW        0x210f

#define IDS_MENUOPEN            0x2130
#define IDS_MENUPRINT           0x2131
#define IDS_MENUEXPLORE         0x2136
#define IDS_MENUFIND            0x2137
#define IDS_MENUAUTORUN         0x2138
#define IDS_MENURUNAS           0x2139
#define IDS_HELPOPEN            0x2140
#define IDS_HELPPRINT           0x2141
#define IDS_HELPPRINTTO         0x2142
#define IDS_HELPOPENAS          0x2143
#define IDS_MENUEDIT            0x2144

#define IDS_EXITHELP                    0x2150
#define IDS_WINDOWS_HLP                 0x2151
#define IDS_WINDOWS                     0x2152
#define IDS_MNEMONIC_EXCOL_FORMAT       0x2153
#define IDS_MNEMONIC_EXCOL_DATARATE     0x2154
#define IDS_MNEMONIC_EXCOL_FRAMERATE    0x2155
#define IDS_MNEMONIC_EXCOL_VSAMPLESIZE  0x2156
#define IDS_EXCOL_VCOMPRESSION          0x2157
#define IDS_MNEMONIC_EXCOL_VCOMPRESSION 0x2158
#define IDS_EXCOL_STREAMNAME            0x2159
#define IDS_MNEMONIC_EXCOL_STREAMNAME   0x215A
#define IDS_MNEMONIC_EXCOL_GENRE        0x215B
#define IDS_EXCOL_FAXENDTIME            0x215C
#define IDS_MNEMONIC_EXCOL_FAXENDTIME   0x215D
#define IDS_EXCOL_FAXSENDERNAME         0x215F

#define IDS_MNEMONIC_EXCOL_FAXSENDERNAME    0x2160
#define IDS_EXCOL_FAXTSID                   0x2161
#define IDS_MNEMONIC_EXCOL_FAXTSID          0x2162
#define IDS_EXCOL_FAXCALLERID               0x2163
#define IDS_MNEMONIC_EXCOL_FAXCALLERID      0x2164
#define IDS_EXCOL_FAXRECIPNAME              0x2165
#define IDS_MNEMONIC_EXCOL_FAXRECIPNAME     0x2166
#define IDS_EXCOL_FAXRECIPNUMBER            0x2167
#define IDS_MNEMONIC_EXCOL_FAXRECIPNUMBER   0x2168
#define IDS_EXCOL_FAXCSID                   0x2169
#define IDS_MNEMONIC_EXCOL_FAXCSID          0x216A
#define IDS_EXCOL_FAXROUTING                0x216B
#define IDS_MNEMONIC_EXCOL_FAXROUTING       0x216C
#define IDS_EXCOL_TAGEQUIPMAKE              0x216D
#define IDS_MNEMONIC_EXCOL_TAGEQUIPMAKE     0x216E
#define IDS_EXCOL_SEQUENCENUMBER            0x216F

#define IDS_MNEMONIC_EXCOL_SEQUENCENUMBER   0x2170
#define IDS_EXCOL_EDITOR                    0x2171
#define IDS_MNEMONIC_EXCOL_EDITOR           0x2172
#define IDS_EXCOL_SUPPLIER                  0x2173
#define IDS_MNEMONIC_EXCOL_SUPPLIER         0x2174
#define IDS_EXCOL_SOURCE                    0x2175
#define IDS_MNEMONIC_EXCOL_SOURCE           0x2176
#define IDS_EXCOL_PROJECT                   0x2177
#define IDS_MNEMONIC_EXCOL_PROJECT          0x2178
#define IDS_EXCOL_STATUS                    0x2179
#define IDS_MNEMONIC_EXCOL_STATUS           0x217A
#define IDS_EXCOL_PRODUCTION                0x217B
#define IDS_MNEMONIC_EXCOL_PRODUCTION       0x217C
#define IDS_EXCOL_MANAGER                   0x217D
#define IDS_MNEMONIC_EXCOL_MANAGER          0x217E
#define IDS_EXCOL_PRESFORMAT                0x217F

#define IDS_MNEMONIC_EXCOL_PRESFORMAT       0x2180
#define IDS_EXCOL_RESOLUTIONX               0x2181
#define IDS_EXCOL_RESOLUTIONY               0x2182
#define IDS_EXCOL_BITDEPTH                  0x2183
#define IDS_EXCOL_TRANSPARENCY              0x2184
#define IDS_MNEMONIC_EXCOL_RESOLUTIONX      0x2185
#define IDS_MNEMONIC_EXCOL_RESOLUTIONY      0x2186
#define IDS_MNEMONIC_EXCOL_BITDEPTH         0x2187
#define IDS_MNEMONIC_EXCOL_TRANSPARENCY     0x2188
#define IDS_BOOLVAL_YES                     0x2189
#define IDS_BOOLVAL_NO                      0x218A
#define IDS_STATUSVAL_NEW                   0x218B
#define IDS_STATUSVAL_PRELIM                0x218C
#define IDS_STATUSVAL_DRAFT                 0x218D
#define IDS_STATUSVAL_INPROGRESS            0x218E
#define IDS_STATUSVAL_EDIT                  0x218F

#define IDS_STATUSVAL_REVIEW                0x2190
#define IDS_STATUSVAL_PROOF                 0x2191
#define IDS_STATUSVAL_FINAL                 0x2192
#define IDS_STATUSVAL_NORMAL                0x2193
#define IDS_STATUSVAL_OTHER                 0x2194
#define IDS_EXCOL_BRIGHTNESS                0x2195

// string ids for shpsht.c
#define IDS_NOPAGE              0x21f0

// string ids for mulprsht.c
#define IDS_MULTIPLEFILES       0x2200
#define IDS_MULTIPLETYPES       0x2201
#define IDS_ALLIN               0x2202
#define IDS_ALLOFTYPE           0x2203
#define IDS_MULTIPLEOBJECTS     0x2204
#define IDS_VARFOLDERS          0x2205
#define IDS_FOLDERSIZE          0x2206
#define IDS_NUMFILES            0x2207
#define IDS_ONEFILEPROP         0x2208
#define IDS_MANYFILEPROP        0x2209

// string ids for pickicon.c
#define IDS_BADPATHMSG          0x2210
#define IDS_NOICONSMSG1         0x2211
#define IDS_NOICONSMSG          0x2212

//#define IDS_CANNOTSETATTRIBUTES 0x2213
#define IDS_MAKINGDESKTOPLINK   0x2214
#define IDS_TRYDESKTOPLINK      0x2215
#define IDS_CANNOTCREATEFILE    0x2218
#define IDS_CANNOTCREATELINK    0x2219
#define IDS_CANNOTCREATEFOLDER  0x221A

#define IDS_NFILES              0x2220
#define IDS_SELECTEDFILES       0x2221

// string ids for copy.c
// #define unused               0x2222
#define IDS_TIMEEST_MINUTES     0x2223
#define IDS_TIMEEST_SECONDS     0x2224

// string ids for version.c

#define IDS_VN_COMMENTS         0x2230
#define IDS_VN_COMPANYNAME      0x2231
#define IDS_VN_FILEDESCRIPTION  0x2232
#define IDS_VN_INTERNALNAME     0x2233
#define IDS_VN_LEGALTRADEMARKS  0x2234
#define IDS_VN_ORIGINALFILENAME 0x2235
#define IDS_VN_PRIVATEBUILD     0x2236
#define IDS_VN_PRODUCTNAME      0x2237
#define IDS_VN_PRODUCTVERSION   0x2238
#define IDS_VN_SPECIALBUILD     0x2239
#define IDS_VN_FILEVERSIONKEY   0x223A
#define IDS_VN_LANGUAGE         0x223B
#define IDS_VN_LANGUAGES        0x223C
#define IDS_VN_FILEVERSION      0x223D

// string ids for attribute descriptions
#define IDS_ATTRIBUTE_READONLY      0x2240
#define IDS_ATTRIBUTE_HIDDEN        0x2241
#define IDS_ATTRIBUTE_SYSTEM        0x2242
#define IDS_ATTRIBUTE_COMPRESSED    0x2243
#define IDS_ATTRIBUTE_ENCRYPTED     0x2244
#define IDS_ATTRIBUTE_OFFLINE       0x2245

// String ids for Associate dialog
//#define IDS_ASSOCIATE           0x2300
//#define IDS_ASSOCNONE           0x2301
//#define IDS_ASSOCNOTEXE         0x2302
//#define IDS_NOEXEASSOC          0x2303
#define IDS_WASTEBASKET         0x2304

#define IDS_NOFILESTOEMAIL          0x2305
#define IDS_PLAYABLEFILENOTFOUND    0x2306
#define IDS_RENAMEFILESINREG        0x2307
#define IDS_RECYCLEBININVALIDFORMAT 0x2308

#define IDS_BUILTIN_DOMAIN      0x230D

// column headers for various listviews
#define IDS_EXCOL_LASTAUTHOR    0x230E
#define IDS_EXCOL_REVNUMBER     0x230F

#define IDS_NAME_COL            0x2310
#define IDS_PATH_COL            0x2311
#define IDS_SIZE_COL            0x2312
#define IDS_TYPE_COL            0x2313
#define IDS_MODIFIED_COL        0x2314
#define IDS_STATUS_COL          0x2315
#define IDS_SYNCCOPYIN_COL      0x2316

#define IDS_WORKGROUP_COL       0x2318
#define IDS_DELETEDFROM_COL     0x2319
#define IDS_DATEDELETED_COL     0x231A
#define IDS_ATTRIB_COL          0x231B
#define IDS_ATTRIB_CHARS        0x231C
#define IDS_RANK_COL            0x231D
#define IDS_DESCRIPTION_COL     0x231E
#define IDS_WHICHFOLDER_COL     0x231F       

#define IDS_EXCOL_TITLE         0x2320
#define IDS_EXCOL_AUTHOR        0x2321
#define IDS_EXCOL_PAGECOUNT     0x2322
#define IDS_EXCOL_COMMENT       0x2323
#define IDS_EXCOL_CREATE        0x2324
#define IDS_EXCOL_ACCESSTIME    0x2325
#define IDS_EXCOL_OWNER         0x2326
#define IDS_EXCOL_SUBJECT       0x2327
#define IDS_EXCOL_TEMPLATE      0x2328
#define IDS_EXCOL_CAMERAMODEL   0x2329
#define IDS_EXCOL_HIDDENCOUNT   0x232A
#define IDS_EXCOL_MMCLIPCOUNT   0x232B
#define IDS_EXCOL_WHENTAKEN     0x232C
#define IDS_EXCOL_DIMENSIONS    0x232D
#define IDS_IMAGES              0x232E
#define IDS_IMAGESFILTER        0x232F

#define IDS_FILEFOUND           0x2330
#define IDS_FILENOTFOUND        0x2331
#define IDS_FINDASSEXEBROWSETITLE 0x2332
#define IDS_DRIVETSHOOT         0x2333
#define IDS_SYSDMCPL            0x2334
#define IDS_EXE                 0x2335
#define IDS_PROGRAMSFILTER      0x2336
#define IDS_BROWSE              0x2337
#define IDS_OPENAS              0x2338
#define IDS_CLP                 0x2339
#define IDS_SEPARATORFILTER     0x233A
#define IDS_ICO                 0x233B
#define IDS_ICONSFILTER         0x233C
#define IDS_ALLFILESFILTER      0x233D
#define IDS_SAVEAS              0x233E
#define IDS_REASONS_URLINTEMPDIR 0x233F

// wastebasket strings
#define IDS_BB_RESTORINGFILES               0x2340
#define IDS_BB_EMPTYINGWASTEBASKET          0x2341
#define IDS_BB_DELETINGWASTEBASKETFILES     0x2342
#define IDS_BB_CANNOTCHANGESETTINGS         0x2343

#define IDS_APPWIZCPL           0x2344

#define IDS_NO_BACKUP_APP                   0x2350
#define IDS_NO_OPTIMISE_APP                 0x2351
#define IDS_NO_DISKCHECK_APP                0x2352
#define IDS_NO_CLEANMGR_APP                 0x2353

// Drives Hardware tab string
#define IDS_THESEDRIVES         0x2354

//  Some more extended columns:
#define IDS_EXCOL_CATEGORY      0x2355
#define IDS_EXCOL_COPYRIGHT     0x2356
#define IDS_EXCOL_ARTIST        0x2357
#define IDS_EXCOL_ALBUM         0x2358
#define IDS_EXCOL_YEAR          0x2359
#define IDS_EXCOL_TRACK         0x235A
#define IDS_EXCOL_DURATION      0x235B
#define IDS_EXCOL_BITRATE       0x235C
#define IDS_EXCOL_PROTECTED     0x235D
#define IDS_EXCOL_LYRICS        0x235F

#define IDS_EXCOL_KEYWORDS      0x2360
#define IDS_EXCOL_RATING        0x2361
#define IDS_EXCOL_WORDCOUNT     0x2363
#define IDS_EXCOL_APPNAME       0x2364
#define IDS_EXCOL_SCALE         0x2365
#define IDS_EXCOL_TEMPLATEPROP  0x2366
#define IDS_EXCOL_CHARCOUNT     0x2367
#define IDS_EXCOL_LASTSAVEDTM   0x2368
#define IDS_EXCOL_LASTPRINTED   0x2369
#define IDS_EXCOL_EDITTIME      0x236A
#define IDS_EXCOL_BYTECOUNT     0x236B
#define IDS_EXCOL_LINECOUNT     0x236C
#define IDS_EXCOL_PARCOUNT      0x236D
#define IDS_EXCOL_SLIDECOUNT    0x236E
#define IDS_EXCOL_NOTECOUNT     0x236F


// String ids for names of special ID Lists
#define IDS_CSIDL_HISTORY                   0x2370
#define IDS_CSIDL_COOKIES                   0x2371
#define IDS_CSIDL_CACHE                     0x2372
#define IDS_CSIDL_PRINTHOOD                 0x2373
#define IDS_CSIDL_MYPICTURES                0x2374
#define IDS_CSIDL_TEMPLATES                 0x2376
#define IDS_CSIDL_PROGRAM_FILES             0x2378
#define IDS_CSIDL_ALLUSERS_OEM_LINKS        0x2379
#define IDS_EXCOL_LINKSDIRTY                0x237A
#define IDS_EXCOL_SAMPLERATE                0x237B
#define IDS_EXCOL_ASAMPLESIZE               0x237C
#define IDS_EXCOL_CHANNELS                  0x237D
#define IDS_EXCOL_FORMAT                    0x237E
#define IDS_EXCOL_DATARATE                  0x237F

#define IDS_CSIDL_ALTSTARTUP                0x2380
#define IDS_LOCALSETTINGS                   0x2381
#define IDS_CSIDL_APPDATA                   0x2382
#define IDS_ALL_USERS                       0x2383
#define IDS_CSIDL_DESKTOPDIRECTORY          0x2384
#define IDS_CSIDL_CDBURN_AREA               0x2385
#define IDS_CSIDL_PROGRAMS                  0x2386
#define IDS_EXCOL_FRAMERATE                 0x2387
#define IDS_CSIDL_RECENT                    0x2388
#define IDS_EXCOL_VSAMPLESIZE               0x2389
#define IDS_CSIDL_SENDTO                    0x238a
#define IDS_EXCOL_GENRE                     0x238b
#define IDS_CSIDL_PERSONAL                  0x238c
#define IDS_EXCOL_SOFTWARE                  0x238d
#define IDS_CSIDL_STARTUP                   0x238e
#define IDS_EXCOL_IMAGECX                   0x238f

#define IDS_CSIDL_STARTMENU                 0x2390
#define IDS_CSIDL_MYMUSIC                   0x2391
#define IDS_CSIDL_FAVORITES                 0x2392
#define IDS_CSIDL_MYVIDEO                   0x2393
#define IDS_CSIDL_NETHOOD                   0x2394
#define IDS_EXCOL_IMAGECY                   0x2395
#define IDS_EXCOL_FLASH                     0x2396
#define IDS_EXCOL_COLORSPACE                0x2397
#define IDS_CSIDL_ALLUSERS_DOCUMENTS        0x2398
#define IDS_EXCOL_SHUTTERSPEED              0x2399
#define IDS_EXCOL_APERTURE                  0x239A
#define IDS_WINHELPERROR                    0x239B
#define IDS_WINHELPTITLE                    0x239C
#define IDS_CSIDL_ADMINTOOLS                0x239D
#define IDS_CSIDL_COMMON_ADMINTOOLS         0x239E
#define IDS_QUICKLAUNCH                     0x239F

#define IDS_EXCOL_DISTANCE                  0x23A0
#define IDS_CSIDL_ALLUSERS_MUSIC            0x23A1
#define IDS_CSIDL_ALLUSERS_VIDEO            0x23A2
#define IDS_CSIDL_ALLUSERS_PICTURES         0x23A3
#define IDS_MNEMONIC_NAME_COL               0x23A4
#define IDS_MNEMONIC_SIZE_COL               0x23A5
#define IDS_MNEMONIC_TYPE_COL               0x23A6
#define IDS_MNEMONIC_MODIFIED_COL           0x23A7
#define IDS_MNEMONIC_ATTRIB_COL             0x23A8
#define IDS_MNEMONIC_EXCOL_OWNER            0x23A9
#define IDS_MNEMONIC_EXCOL_CREATE           0x23AA
#define IDS_MNEMONIC_EXCOL_ACCESSTIME       0x23AB
#define IDS_MNEMONIC_CSC_STATUS             0x23AC
#define IDS_EXCOL_FILETYPE                  0x23AD
#define IDS_EXCOL_FOCALLENGTH               0x23AE
#define IDS_MNEMONIC_EXCOL_SCALE            0x23AF

#define IDS_MNEMONIC_EXCOL_TITLE            0x23B0
#define IDS_MNEMONIC_EXCOL_SUBJECT          0x23B1
#define IDS_MNEMONIC_EXCOL_AUTHOR           0x23B2
#define IDS_MNEMONIC_EXCOL_PAGECOUNT        0x23B3
#define IDS_MNEMONIC_EXCOL_COMMENT          0x23B4
#define IDS_MNEMONIC_EXCOL_COPYRIGHT        0x23B5
#define IDS_MNEMONIC_EXCOL_CATEGORY         0x23B6
#define IDS_MNEMONIC_EXCOL_KEYWORDS         0x23B7
#define IDS_MNEMONIC_EXCOL_LINKSDIRTY       0x23B8
#define IDS_MNEMONIC_EXCOL_SOFTWARE         0x23B9
#define IDS_MNEMONIC_EXCOL_CAMERAMODEL      0x23BA
#define IDS_MNEMONIC_EXCOL_WHENTAKEN        0x23BB
#define IDS_MNEMONIC_EXCOL_DIMENSIONS       0x23BC
#define IDS_EXCOL_GAMMAVALUE                0x23BD
#define IDS_MNEMONIC_EXCOL_GAMMAVALUE       0x23BE
#define IDS_EXCOL_FRAMECOUNT                0x23BF

#define IDS_MNEMONIC_EXCOL_ARTIST           0x23C0
#define IDS_MNEMONIC_EXCOL_ALBUM            0x23C1
#define IDS_MNEMONIC_EXCOL_YEAR             0x23C2
#define IDS_MNEMONIC_EXCOL_TRACK            0x23C3
#define IDS_MNEMONIC_EXCOL_DURATION         0x23C4
#define IDS_MNEMONIC_EXCOL_BITRATE          0x23C5
#define IDS_MNEMONIC_EXCOL_PROTECTED        0x23C6
#define IDS_MNEMONIC_EXCOL_FRAMECOUNT       0x23C7
#define IDS_EXCOL_ACOMPRESSION              0x23C8
#define IDS_MNEMONIC_EXCOL_ACOMPRESSION     0x23C9
#define IDS_MNEMONIC_VN_COMPANYNAME         0x23CA
#define IDS_MNEMONIC_VN_FILEDESCRIPTION     0x23CB
#define IDS_MNEMONIC_VN_FILEVERSION         0x23CC
#define IDS_MNEMONIC_VN_PRODUCTNAME         0x23CD
#define IDS_MNEMONIC_VN_PRODUCTVERSION      0x23CE
#define IDS_MNEMONIC_EXCOL_IMAGECX          0x23CF

#define IDS_MNEMONIC_PSD_QUEUESIZE          0x23D0
#define IDS_MNEMONIC_PSD_LOCATION           0x23D1
#define IDS_MNEMONIC_PSD_MODEL              0x23D2
#define IDS_MNEMONIC_PRQ_STATUS             0x23D3
#define IDS_MNEMONIC_EXCOL_IMAGECY          0x23D4
#define IDS_MNEMONIC_EXCOL_FLASH            0x23D5
#define IDS_MNEMONIC_EXCOL_COLORSPACE       0x23D6
#define IDS_NMEMONIC_EXCOL_SHUTTERSPEED     0x23D7
#define IDS_NMEMONIC_EXCOL_APERTURE         0x23D8
#define IDS_NMEMONIC_EXCOL_BRIGHTNESS       0x23D9
#define IDS_MNEMONIC_DELETEDFROM_COL        0x23DA
#define IDS_MNEMONIC_DATEDELETED_COL        0x23DB
#define IDS_NMEMONIC_EXCOL_DISTANCE         0x23DC
#define IDS_MNEMONIC_EXCOL_FILETYPE         0x23DD
#define IDS_MNEMONIC_EXCOL_FOCALLENGTH      0x23DE
#define IDS_EXCOL_FNUMBER                   0x23DF

#define IDS_MNEMONIC_SYNCCOPYIN_COL         0x23E0
#define IDS_MNEMONIC_STATUS_COL             0x23E1
#define IDS_MNEMONIC_EXCOL_FNUMBER          0x23E2
#define IDS_EXCOL_EXPOSURETIME              0x23E3
#define IDS_MNEMONIC_EXCOL_EXPOSURETIME     0x23E4
#define IDS_MNEMONIC_DRIVES_FREE            0x23E5
#define IDS_MNEMONIC_DRIVES_CAPACITY        0x23E6
#define IDS_MNEMONIC_DRIVES_FILESYSTEM      0x23E7
#define IDS_MNEMONIC_EXCOL_SAMPLERATE       0x23E8
#define IDS_MNEMONIC_EXCOL_ASAMPLESIZE      0x23E9
#define IDS_MNEMONIC_PATH_COL               0x23EA
#define IDS_MNEMONIC_RANK_COL               0x23EB
#define IDS_MNEMONIC_EXCOL_TEMPLATE         0x23EC
#define IDS_MNEMONIC_EXCOL_LASTAUTHOR       0x23ED
#define IDS_MNEMONIC_EXCOL_REVNUMBER        0x23EE
#define IDS_MNEMONIC_EXCOL_APPNAME          0x23EF

#define IDS_MNEMONIC_WHICHFOLDER_COL        0x23F0
#define IDS_MNEMONIC_EXCOL_WORDCOUNT        0x23F1
#define IDS_MNEMONIC_EXCOL_CHARCOUNT        0x23F2
#define IDS_MNEMONIC_EXCOL_LASTSAVEDTM      0x23F3
#define IDS_MNEMONIC_EXCOL_LASTPRINTED      0x23F4
#define IDS_MNEMONIC_EXCOL_EDITTIME         0x23F5
#define IDS_MNEMONIC_EXCOL_BYTECOUNT        0x23F6
#define IDS_MNEMONIC_EXCOL_LINECOUNT        0x23F7
#define IDS_MNEMONIC_EXCOL_PARCOUNT         0x23F9
#define IDS_MNEMONIC_EXCOL_SLIDECOUNT       0x23FA
#define IDS_MNEMONIC_EXCOL_NOTECOUNT        0x23FB
#define IDS_MNEMONIC_EXCOL_HIDDENCOUNT      0x23FC
#define IDS_MNEMONIC_EXCOL_MMCLIPCOUNT      0x23FD
#define IDS_MNEMONIC_EXCOL_RATING           0x23FE
#define IDS_MNEMONIC_EXCOL_CHANNELS         0x23FF

// String ids for the Root of All Evil (ultroot.c)
#define IDS_ROOTNAMES                   0x2400
#define IDS_DRIVEROOT                   (IDS_ROOTNAMES+0x00)
#define IDS_NETWORKROOT                 (IDS_ROOTNAMES+0x01)
#define IDS_RESTOFNET                   (IDS_ROOTNAMES+0x02)

// These are not roots, but save number of string tables...
#define IDS_525_FLOPPY_DRIVE            (IDS_ROOTNAMES+0x03)
#define IDS_35_FLOPPY_DRIVE             (IDS_ROOTNAMES+0x04)
#define IDS_UNK_FLOPPY_DRIVE            (IDS_ROOTNAMES+0x05)

// Okay, so this is a root...
#define IDS_INETROOT                    (IDS_ROOTNAMES+0x06)

// More that are not roots...
#define IDS_UNC_FORMAT                  (IDS_ROOTNAMES+0x07)
#define IDS_VOL_FORMAT                  (IDS_ROOTNAMES+0x08)

#define IDS_525_FLOPPY_DRIVE_UGLY       (IDS_ROOTNAMES+0x09)
#define IDS_35_FLOPPY_DRIVE_UGLY        (IDS_ROOTNAMES+0x0a)

#define IDS_MYDOCUMENTS                 (IDS_ROOTNAMES+0x0b)

#define IDS_VOL_FORMAT_LETTER_1ST       (IDS_ROOTNAMES+0x0c)

#define IDS_NECUNK_FLOPPY_DRIVE         (IDS_ROOTNAMES+0x0f)

// String ids for the Find dialog
#define IDS_FINDDLG                 0x2410
#define IDS_FILESFOUND                  (IDS_FINDDLG + 0x00)
#define IDS_COMPUTERSFOUND              (IDS_FINDDLG + 0x01)
#define IDS_SEARCHING                   (IDS_FINDDLG + 0x02)
#define IDS_FIND_SELECT_PATH            (IDS_FINDDLG + 0x03)
#define IDS_FIND_TITLE_NAME             (IDS_FINDDLG + 0x04)
#define IDS_FIND_TITLE_TYPE             (IDS_FINDDLG + 0x05)
#define IDS_FIND_TITLE_TYPE_NAME        (IDS_FINDDLG + 0x06)
#define IDS_FIND_TITLE_TEXT             (IDS_FINDDLG + 0x07)
#define IDS_FIND_TITLE_NAME_TEXT        (IDS_FINDDLG + 0x08)
#define IDS_FIND_TITLE_TYPE_TEXT        (IDS_FINDDLG + 0x09)
#define IDS_FIND_TITLE_TYPE_NAME_TEXT   (IDS_FINDDLG + 0x0a)
#define IDS_FIND_TITLE_ALL              (IDS_FINDDLG + 0x0b)
#define IDS_FIND_TITLE_COMPUTER         (IDS_FINDDLG + 0x0c)
#define IDS_FIND_SHORT_NAME             (IDS_FINDDLG + 0x0d)
#define IDS_FIND_TITLE_FIND             (IDS_FINDDLG + 0x0e)
#define IDS_FINDSEARCHTITLE             (IDS_FINDDLG + 0x0f)
#define IDS_FINDSEARCH_COMPUTER         (IDS_FINDDLG + 0x10)
#define IDS_FINDSEARCH_PRINTER          (IDS_FINDDLG + 0x11)
#define IDS_FINDSEARCH_ALLDRIVES        (IDS_FINDDLG + 0x12)
#define IDS_FINDFILESFILTER             (IDS_FINDDLG + 0x13)
#define IDS_FINDSAVERESULTSTITLE        (IDS_FINDDLG + 0x14)
#define IDS_SEARCHINGASYNC              (IDS_FINDDLG + 0x15)
#define IDS_FIND_CUEBANNER_FILE         (IDS_FINDDLG + 0x16)
#define IDS_FIND_CUEBANNER_GREP         (IDS_FINDDLG + 0x17)
#define IDS_FIND_AND                    (IDS_FINDDLG + 0x18)
#define IDS_FIND_OR                     (IDS_FINDDLG + 0x19)

// For menu help, must match IDM_xxx numbers
#define IDS_FIND_STATUS_FIRST       0x2430
#define IDS_FIND_STATUS_OPENCONT        (IDS_FIND_STATUS_FIRST + 0)
#define IDS_FIND_STATUS_CASESENSITIVE   (IDS_FIND_STATUS_FIRST + 1)
#define IDS_FIND_STATUS_SAVESRCH        (IDS_FIND_STATUS_FIRST + 3)
#define IDS_FIND_STATUS_CLOSE           (IDS_FIND_STATUS_FIRST + 4)
#define IDS_FIND_STATUS_SAVERESULTS     (IDS_FIND_STATUS_FIRST + 5)
#define IDS_FIND_STATUS_WHATSTHIS       (IDS_FIND_STATUS_FIRST + 7)


// Control Panel stuff
#define IDS_CONTROL_START           0x2450
//#define IDS_LOADING                     (IDS_CONTROL_START+0x00)
//#define IDS_NAME                        (IDS_CONTROL_START+0x01)
#define IDS_CPL_EXCEPTION               (IDS_CONTROL_START+0x02)
//#define IDS_CPLINFO                     (IDS_CONTROL_START+0x03)

// Printer stuff
#define IDS_PRINTER_START           (IDS_CPL_EXCEPTION+2)
#define IDS_NEWPRN                      (IDS_PRINTER_START+0x00)
#define IDS_PRINTERS                    (IDS_PRINTER_START+0x01)
#define IDS_CHANGEDEFAULTPRINTER        (IDS_PRINTER_START+0x02)
//#define IDS_CHANGEPRINTPROCESSOR        (IDS_PRINTER_START+0x03)
//#define IDS_NETAVAIL_ALWAYS             (IDS_PRINTER_START+0x04)
//#define IDS_NETAVAIL_FMT                (IDS_PRINTER_START+0x05)
#define IDS_CANTVIEW_FILEPRN            (IDS_PRINTER_START+0x06)
#define IDS_PRINTERNAME_CHANGED         (IDS_PRINTER_START+0x07)
//#define IDS_PRINTERSINFOLDER            (IDS_PRINTER_START+0x08)
#define IDS_PRINTER_NOTCONNECTED        (IDS_PRINTER_START+0x0b)
#define IDS_MULTIPLEPRINTFILE           (IDS_PRINTER_START+0x0d)
#define IDS_CANTOPENMODALPROP           (IDS_PRINTER_START+0x0f)
#define IDS_CANTOPENDRIVERPROP          (IDS_PRINTER_START+0x10)
#define IDS_CANTPRINT                   (IDS_PRINTER_START+0x11)
#define IDS_ADDPRINTERTRYRUNAS          (IDS_PRINTER_START+0x12)
#define IDS_PRNANDFAXFOLDER             (IDS_PRINTER_START+0x13)
#define IDS_WORKONLINE                  (IDS_PRINTER_START+0x14)
#define IDS_RESUMEPRINTER               (IDS_PRINTER_START+0x15)

#define IDS_MUSTCOMPLETE                (IDS_PRINTER_START+0x17)
#define IDS_NETPRN_START                (IDS_MUSTCOMPLETE+1)
#define IDS_CANTINSTALLRESOURCE         (IDS_NETPRN_START+0x02)

#define IDS_PSD_START                   (IDS_CANTINSTALLRESOURCE+1)
#define IDS_PSD_QUEUESIZE               (IDS_PSD_START+0x01)

#define IDS_PRQ_START                   (IDS_PSD_QUEUESIZE+0x02)
#define IDS_PRQ_STATUS                  (IDS_PRQ_START+0x00)
#define IDS_PRQ_DOCNAME                 (IDS_PRQ_START+0x01)
#define IDS_PRQ_OWNER                   (IDS_PRQ_START+0x02)
#define IDS_PRQ_TIME                    (IDS_PRQ_START+0x03)
#define IDS_PRQ_PROGRESS                (IDS_PRQ_START+0x04)
#define IDS_PRQ_PAGES                   (IDS_PRQ_START+0x05)
#define IDS_PRQ_PAGESPRINTED            (IDS_PRQ_START+0x06)
#define IDS_PRQ_BYTESPRINTED            (IDS_PRQ_START+0x07)
#define IDS_PRQ_JOBSINQUEUE             (IDS_PRQ_START+0x08)

#define IDS_PRQSTATUS_START             (IDS_PRQ_JOBSINQUEUE+1)
#define IDS_PRQSTATUS_SEPARATOR         (IDS_PRQSTATUS_START+0x00)
#define IDS_PRQSTATUS_PAUSED            (IDS_PRQSTATUS_START+0x01)
#define IDS_PRQSTATUS_ERROR             (IDS_PRQSTATUS_START+0x02)
#define IDS_PRQSTATUS_PENDING_DELETION  (IDS_PRQSTATUS_START+0x03)
#define IDS_PRQSTATUS_PAPER_JAM         (IDS_PRQSTATUS_START+0x04)
#define IDS_PRQSTATUS_PAPER_OUT         (IDS_PRQSTATUS_START+0x05)
#define IDS_PRQSTATUS_MANUAL_FEED       (IDS_PRQSTATUS_START+0x06)
#define IDS_PRQSTATUS_PAPER_PROBLEM     (IDS_PRQSTATUS_START+0x07)
#define IDS_PRQSTATUS_OFFLINE           (IDS_PRQSTATUS_START+0x08)
#define IDS_PRQSTATUS_IO_ACTIVE         (IDS_PRQSTATUS_START+0x09)
#define IDS_PRQSTATUS_BUSY              (IDS_PRQSTATUS_START+0x0a)
#define IDS_PRQSTATUS_PRINTING          (IDS_PRQSTATUS_START+0x0b)
#define IDS_PRQSTATUS_OUTPUT_BIN_FULL   (IDS_PRQSTATUS_START+0x0c)
#define IDS_PRQSTATUS_NOT_AVAILABLE     (IDS_PRQSTATUS_START+0x0d)
#define IDS_PRQSTATUS_WAITING           (IDS_PRQSTATUS_START+0x0e)
#define IDS_PRQSTATUS_PROCESSING        (IDS_PRQSTATUS_START+0x0f)
#define IDS_PRQSTATUS_INITIALIZING      (IDS_PRQSTATUS_START+0x10)
#define IDS_PRQSTATUS_WARMING_UP        (IDS_PRQSTATUS_START+0x11)
#define IDS_PRQSTATUS_TONER_LOW         (IDS_PRQSTATUS_START+0x12)
#define IDS_PRQSTATUS_NO_TONER          (IDS_PRQSTATUS_START+0x13)
#define IDS_PRQSTATUS_PAGE_PUNT         (IDS_PRQSTATUS_START+0x14)
#define IDS_PRQSTATUS_USER_INTERVENTION (IDS_PRQSTATUS_START+0x15)
#define IDS_PRQSTATUS_OUT_OF_MEMORY     (IDS_PRQSTATUS_START+0x16)
#define IDS_PRQSTATUS_DOOR_OPEN         (IDS_PRQSTATUS_START+0x17)
#define IDS_PRQSTATUS_UNAVAILABLE       (IDS_PRQSTATUS_START+0x18)
#define IDS_PRQSTATUS_PRINTED           (IDS_PRQSTATUS_START+0x19)
#define IDS_PRQSTATUS_SPOOLING          (IDS_PRQSTATUS_START+0x1a)
#define IDS_PRQSTATUS_WORK_OFFLINE      (IDS_PRQSTATUS_START+0x1b)

#define IDS_PRTPROP_START           (IDS_PRQSTATUS_WORK_OFFLINE+1)
#define IDS_PRTPROP_DRIVER_WARN         (IDS_PRTPROP_START+0x00)
#define IDS_PRTPROP_RENAME_ERROR        (IDS_PRTPROP_START+0x01)
#define IDS_PRTPROP_RENAME_NULL         (IDS_PRTPROP_START+0x02)
#define IDS_PRTPROP_RENAME_BADCHARS     (IDS_PRTPROP_START+0x03)
#define IDS_PRTPROP_RENAME_TOO_LONG     (IDS_PRTPROP_START+0x04)
#define IDS_PRTPROP_PORT_ERROR          (IDS_PRTPROP_START+0x05)
#define IDS_PRTPROP_SEP_ERROR           (IDS_PRTPROP_START+0x06)
#define IDS_PRTPROP_UNKNOWN_ERROR       (IDS_PRTPROP_START+0x07)
#define IDS_PRTPROP_CANNOT_OPEN         (IDS_PRTPROP_START+0x08)
#define IDS_PRTPROP_PORT_FORMAT         (IDS_PRTPROP_START+0x09)
#define IDS_PRTPROP_TESTPAGE_WARN       (IDS_PRTPROP_START+0x0A)
#define IDS_PRTPROP_ADDPORT_CANTDEL_BUSY  (IDS_PRTPROP_START+0x0B)
#define IDS_PRTPROP_ADDPORT_CANTDEL_LOCAL (IDS_PRTPROP_START+0x0C)
#define IDS_PRTPROP_UNIQUE_FORMAT       (IDS_PRTPROP_START+0x0D)
#define IDS_PRTPROP_UNKNOWNERROR        (IDS_PRTPROP_START+0x0E)

#define IDS_PRNSEP_START            (IDS_PRTPROP_UNKNOWNERROR+1)
#define IDS_PRNSEP_NONE                 (IDS_PRNSEP_START+0x00)
#define IDS_PRNSEP_SIMPLE               (IDS_PRNSEP_START+0x01)
#define IDS_PRNSEP_FULL                 (IDS_PRNSEP_START+0x02)

#define IDS_DELETE_START            (IDS_PRNSEP_FULL+1)
#define IDS_SUREDELETE                  (IDS_DELETE_START+0x00)
#define IDS_SUREDELETEREMOTE            (IDS_DELETE_START+0x01)
#define IDS_SUREDELETECONNECTION        (IDS_DELETE_START+0x02)
#define IDS_DELNEWDEFAULT               (IDS_DELETE_START+0x03)
#define IDS_DELNODEFAULT                (IDS_DELETE_START+0x04)
#define IDS_SUREDELETEMULTIPLE          (IDS_DELETE_START+0x05)
#define IDS_DELETE_END              IDS_SUREDELETEMULTIPLE

#define IDS_DRIVES_START            (IDS_DELETE_END+1)
#define IDS_DRIVES_CAPACITY             (IDS_DRIVES_START+0x02)
#define IDS_DRIVES_FREE                 (IDS_DRIVES_START+0x03)

#define IDS_DRIVES_NETUNAVAIL           (IDS_DRIVES_START+0x04)
#define IDS_DRIVES_REMOVABLE            (IDS_DRIVES_START+0x05)
#define IDS_DRIVES_DRIVE525             (IDS_DRIVES_START+0x06)
#define IDS_DRIVES_DRIVE35              (IDS_DRIVES_START+0x07)
#define IDS_DRIVES_DRIVE525_UGLY        (IDS_DRIVES_START+0x08)
#define IDS_DRIVES_DRIVE35_UGLY         (IDS_DRIVES_START+0x09)
#define IDS_DRIVES_UGLY_TEST            (IDS_DRIVES_START+0x0a)

#define IDS_DRIVES_FIXED                (IDS_DRIVES_START+0x0b)
#define IDS_DRIVES_DVD                  (IDS_DRIVES_START+0x0c)
#define IDS_DRIVES_CDROM                (IDS_DRIVES_START+0x0d)
#define IDS_DRIVES_RAMDISK              (IDS_DRIVES_START+0x0e)
#define IDS_DRIVES_NETDRIVE             (IDS_DRIVES_START+0x0f)
#define IDS_DRIVES_REGITEM              (IDS_DRIVES_START+0x10)

//#define IDS_DRIVES_COMPRESS             (IDS_DRIVES_START+0x11)
#define IDS_DRIVES_NOOPTINSTALLED       (IDS_DRIVES_START+0x12)
//#define IDS_DRIVES_ENCRYPT              (IDS_DRIVES_START+0x13)

#define IDS_DRIVES_LASTCHECKDAYS        (IDS_DRIVES_START+0x16)
#define IDS_DRIVES_LASTBACKUPDAYS       (IDS_DRIVES_START+0x17)
#define IDS_DRIVES_LASTOPTIMIZEDAYS     (IDS_DRIVES_START+0x18)

#define IDS_DRIVES_LASTCHECKUNK         (IDS_DRIVES_START+0x19)
#define IDS_DRIVES_LASTBACKUPUNK        (IDS_DRIVES_START+0x20)
#define IDS_DRIVES_LASTOPTIMIZEUNK      (IDS_DRIVES_START+0x21)

#define IDS_DRIVES_SHAREDDOCS_GROUP     (IDS_DRIVES_START+0x22)
#define IDS_DRIVES_FIXED_GROUP          (IDS_DRIVES_START+0x23)
#define IDS_DRIVES_REMOVABLE_GROUP      (IDS_DRIVES_START+0x24)
#define IDS_DRIVES_NETDRIVE_GROUP       (IDS_DRIVES_START+0x25)
#define IDS_DRIVES_OTHER_GROUP          (IDS_DRIVES_START+0x26)
#define IDS_DRIVES_IMAGING_GROUP        (IDS_DRIVES_START+0x27)
#define IDS_DRIVES_AUDIO_GROUP          (IDS_DRIVES_START+0x28)

#define IDS_DRIVES_DVDRAM               (IDS_DRIVES_START+0x29)
#define IDS_DRIVES_DVDR                 (IDS_DRIVES_START+0x2a)
#define IDS_DRIVES_DVDRW                (IDS_DRIVES_START+0x2b)
#define IDS_DRIVES_DVDCDRW              (IDS_DRIVES_START+0x2c)
#define IDS_DRIVES_DVDCDR               (IDS_DRIVES_START+0x2d)
#define IDS_DRIVES_CDRW                 (IDS_DRIVES_START+0x2e)
#define IDS_DRIVES_CDR                  (IDS_DRIVES_START+0x2f)

#define IDS_DRIVES_FILESYSTEM           (IDS_DRIVES_START+0x30)

#define IDS_DRIVES_END                  IDS_DRIVES_FILESYSTEM

//#define IDS_LOADERR                     0x2500
//#define IDS_LOADERROR_UNKNOWN           (IDS_LOADERR-1)
//#define IDS_LOADERROR_MEMORY            (IDS_LOADERR+0)
//#define IDS_LOADERROR_CANTOPEN          (IDS_LOADERR+2)
//#define IDS_LOADERROR_CANTRUN           (IDS_LOADERR+6)
//#define IDS_LOADERROR_VERPROB           (IDS_LOADERR+10)
//#define IDS_LOADERROR_RMODE             (IDS_LOADERR+15)
//#define IDS_LOADERROR_SINGLEINST        (IDS_LOADERR+16)
//#define IDS_LOADERROR_SHARE             (IDS_LOADERR+SE_ERR_SHARE)
//#define IDS_LOADERROR_ASSOC             (IDS_LOADERR+SE_ERR_ASSOCINCOMPLETE)
//#define IDS_LOADERROR_DDETIMEOUT        (IDS_LOADERR+SE_ERR_DDETIMEOUT)
//#define IDS_LOADERROR_NOASSOC           (IDS_LOADERR+SE_ERR_NOASSOC)

#define IDS_APPCOMPATMSG                0x25A0
#define IDS_APPCOMPATWIN95              0x25A0
#define IDS_APPCOMPATWIN95L             0x25A1
#define IDS_APPCOMPATWIN95H             0x25A2
//#define IDS_APPCOMPATMEMPHIS            0x25A2
//#define IDS_APPCOMPATMEMPHISL           0x25A3
//#define IDS_APPCOMPATIE4                0x25A4
//#define IDS_APPCOMPATIE4L               0x25A5

#define IDS_PSD_LOCATION                0x25A6
#define IDS_PSD_MODEL                   0x25A7
#define IDS_PRN_INFOTIP_START           0x25A8
#define IDS_PRN_INFOTIP_NAME_FMT        0x25A9
#define IDS_PRN_INFOTIP_STATUS_FMT      0x25AA
#define IDS_PRN_INFOTIP_QUEUESIZE_FMT   0x25AB
#define IDS_PRN_INFOTIP_COMMENT_FMT     0x25AC
#define IDS_PRN_INFOTIP_LOCATION_FMT    0x25AD
#define IDS_PRN_INFOTIP_READY           0x25AE
#define IDS_SUREPURGE                   0x25B0
#define IDS_SUREDELETECONNECTIONNOSERVERNAME 0x25B1
#define IDS_SUREPURGEMULTIPLE           0x25B2
#define IDS_ERRORPRINTING               0x25B3

#define IDS_RESTRICTIONSTITLE           0x2600
#define IDS_RESTRICTIONS                0x2601

#define IDS_RESTOFNETTIP                0x2602

#define IDS_DISK_FULL_TEXT              0x2603
#define IDS_DISK_FULL_TITLE             0x2604
#define IDS_DISK_FULL_TEXT_SERIOUS      0x2605

// Strings for pifmgr code

#define IDS_PIFPAGE_FIRST       0x2650
#define IDS_PIF_NONE            (IDS_PIFPAGE_FIRST+0x00)
//#define IDS_NONE_ABOVE          (IDS_PIFPAGE_FIRST+0x01)
#define IDS_AUTO                (IDS_PIFPAGE_FIRST+0x02)
#define IDS_AUTONORMAL          (IDS_PIFPAGE_FIRST+0x03)
#define IDS_PREVIEWTEXT         (IDS_PIFPAGE_FIRST+0x04)
#define IDS_NO_ICONS            (IDS_PIFPAGE_FIRST+0x05)
#define IDS_QUERY_ERROR         (IDS_PIFPAGE_FIRST+0x06)
#define IDS_UPDATE_ERROR        (IDS_PIFPAGE_FIRST+0x07)
#define IDS_PREVIEWTEXT_BILNG   (IDS_PIFPAGE_FIRST+0x08)

#define IDS_BAD_HOTKEY          (IDS_PIFPAGE_FIRST+0x0A)
#define IDS_BAD_MEMLOW          (IDS_PIFPAGE_FIRST+0x0B)
#define IDS_BAD_MEMEMS          (IDS_PIFPAGE_FIRST+0x0C)
#define IDS_BAD_MEMXMS          (IDS_PIFPAGE_FIRST+0x0D)
#define IDS_BAD_ENVIRONMENT     (IDS_PIFPAGE_FIRST+0x0E)
#define IDS_BAD_MEMDPMI         (IDS_PIFPAGE_FIRST+0x0F)
#define IDS_MEMORY_RELAUNCH     (IDS_PIFPAGE_FIRST+0x10)
#define IDS_ADVANCED_RELAUNCH   (IDS_PIFPAGE_FIRST+0x11)

#define IDS_PROGRAMDEFEXT       (IDS_PIFPAGE_FIRST+0x12)
#define IDS_PROGRAMFILTER       (IDS_PIFPAGE_FIRST+0x13)
#define IDS_PROGRAMBROWSE       (IDS_PIFPAGE_FIRST+0x14)

/*
 *  Careful!  pifvid.c assumes that these are in order.
 */
#define IDS_PIFVID_FIRST        0x2665
#define IDS_DEFAULTLINES        (IDS_PIFVID_FIRST+0x00)
#define IDS_25LINES             (IDS_PIFVID_FIRST+0x01)
#define IDS_43LINES             (IDS_PIFVID_FIRST+0x02)
#define IDS_50LINES             (IDS_PIFVID_FIRST+0x03)

#define IDS_PIFCONVERT          (IDS_PIFVID_FIRST+0x04)
#define IDS_PIFCONVERTEXE       (IDS_PIFVID_FIRST+0x05)
#define IDS_AUTOEXECTOP         (IDS_PIFVID_FIRST+0x06)
#define IDS_AUTOEXECBOTTOM      (IDS_PIFVID_FIRST+0x07)
#define IDS_DISKINSERT          (IDS_PIFVID_FIRST+0x08)
#define IDS_DISKREMOVE          (IDS_PIFVID_FIRST+0x09)

#define IDS_NORMALWINDOW        (IDS_PIFVID_FIRST+0x0A)
#define IDS_MINIMIZED           (IDS_PIFVID_FIRST+0x0B)
#define IDS_MAXIMIZED           (IDS_PIFVID_FIRST+0x0C)

#define IDS_APPSINF             (IDS_PIFVID_FIRST+0x0D)
#define IDS_NOAPPSINF           (IDS_PIFVID_FIRST+0x0E)
#define IDS_CANTOPENAPPSINF     (IDS_PIFVID_FIRST+0x0F)
#define IDS_APPSINFERROR        (IDS_PIFVID_FIRST+0x10)
#define IDS_CREATEPIF           (IDS_PIFVID_FIRST+0x11)
#define IDS_UNKNOWNAPP          (IDS_PIFVID_FIRST+0x12)
#define IDS_UNKNOWNAPPDEF       (IDS_PIFVID_FIRST+0x13)

#define IDS_EMM386_NOEMS        (IDS_PIFVID_FIRST+0x15)
//      IDS_EMM386_NOEMS+1      (IDS_PIFVID_FIRST+0x16)
#define IDS_QEMM_NOEMS          (IDS_PIFVID_FIRST+0x17)
//      IDS_QEMM_NOEMS+1        (IDS_PIFVID_FIRST+0x18)
#define IDS_RING0_NOEMS         (IDS_PIFVID_FIRST+0x19)
//      IDS_RING0_NOEMS+1       (IDS_PIFVID_FIRST+0x1A)
#define IDS_SYSINI_NOEMS        (IDS_PIFVID_FIRST+0x1B)
//      IDS_SYSINI_NOEMS+1      (IDS_PIFVID_FIRST+0x1C)

#define IDS_NUKECONFIGMSG       (IDS_PIFVID_FIRST+0x1E)


#define IDS_ERROR               (IDS_PIFVID_FIRST+0x1F)  /* Not a string ID */
        /* Error messages go at IDS_ERROR + ERROR_WHATEVER */
    /* Right now, there is only one error string */


#define IDS_PIFFONT_FIRST       0x26a0
#define IDS_TTFACENAME_SBCS     (IDS_PIFFONT_FIRST+0x01)
#define IDS_TTFACENAME_DBCS     (IDS_PIFFONT_FIRST+0x02)
#define IDS_TTCACHESEC_SBCS     (IDS_PIFFONT_FIRST+0x03)
#define IDS_TTCACHESEC_DBCS     (IDS_PIFFONT_FIRST+0x04)


#define IDS_CANTRECYCLEREGITEMS_NAME        0x2700
#define IDS_CANTRECYCLEREGITEMS_INCL_NAME   0x2701
#define IDS_CANTRECYCLEREGITEMS_ALL         0x2702
#define IDS_CANTRECYCLEREGITEMS_SOME        0x2703
#define IDS_CONFIRMDELETEDESKTOPREGITEM     0x2704
#define IDS_CONFIRMDELETEDESKTOPREGITEMS    0x2705
#define IDS_CONFIRMDELETE_CAPTION           0x2706
#define IDS_CONFIRMNOTRECYCLABLE            0x2707
#define IDS_CONFIRMDELETEREGITEM            0x2708
#define IDS_CONFIRMDELETEREGITEMS           0x2709

#define IDS_CANTRECYLE_FOLDER               0x2720
// ---- UNUSED ---------------------------- 0x2721
#define IDS_CANTRECYLE_GENERAL              0x2722

#define IDS_EXCOL_DRMDESCRIPTION            0x2723
#define IDS_EXCOL_PLAYCOUNT                 0x2724
#define IDS_EXCOL_PLAYSTARTS                0x2725
#define IDS_EXCOL_PLAYEXPIRES               0x2726
#define IDS_MNEMONIC_EXCOL_DRMDESCRIPTION   0x2727
#define IDS_MNEMONIC_EXCOL_PLAYCOUNT        0x2728
#define IDS_MNEMONIC_EXCOL_PLAYSTARTS       0x2729
#define IDS_MNEMONIC_EXCOL_PLAYEXPIRES      0x272A
#define IDS_NETWORKLOCATION                 0x272B
#define IDS_MNEMONIC_NETWORKLOCATION        0x272C
#define IDS_EXCOL_COMPUTER                  0x272D
#define IDS_MNEMONIC_COMPUTER               0x272E

#define IDS_EXCOL_ISOSPEED                  0x272F
#define IDS_EXCOL_METERINGMODE              0x2730
#define IDS_EXCOL_LIGHTSOURCE               0x2731
#define IDS_EXCOL_EXPOSUREPROG              0x2732
#define IDS_EXCOL_FLASHENERGY               0x2733
#define IDS_EXCOL_EXPOSUREBIAS              0x2734
#define IDS_MNEMONIC_EXCOL_ISOSPEED         0x2735
#define IDS_MNEMONIC_EXCOL_METERINGMODE     0x2736
#define IDS_MNEMONIC_EXCOL_LIGHTSOURCE      0x2737
#define IDS_MNEMONIC_EXCOL_EXPOSUREPROG     0x2738
#define IDS_MNEMONIC_EXCOL_FLASHENERGY      0x2739
#define IDS_MNEMONIC_EXCOL_EXPOSUREBIAS     0x273A

// File Type strings
#define IDS_FT                              0x2760
#define IDS_ADDNEWFILETYPE                  0x2761
#define IDS_FT_EDITTITLE                    0x2762
#define IDS_FT_CLOSE                        0x2763
#define IDS_FT_EXEFILE                      0x2764
#define IDS_FT_MB_EXTTEXT                   0x2765
#define IDS_FT_MB_NOEXT                     0x2766
#define IDS_FT_MB_NOACTION                  0x2767
#define IDS_FT_MB_EXETEXT                   0x2768
#define IDS_FT_MB_REMOVETYPE                0x2769
#define IDS_FT_MB_REMOVEACTION              0x276A
#define IDS_CAP_OPENAS                      0x276B
#define IDS_FT_EXE                          0x276C
#define IDS_PROGRAMSFILTER_NT               0x276D
#define IDS_PROGRAMSFILTER_WIN95            0x276E
#define IDS_FT_NA                           0x276F
#define IDS_FT_MB_REPLEXTTEXT               0x2770
#define IDS_FT_PROP_ADVANCED                0x2771
#define IDS_FT_PROP_EXTENSIONS              0x2772
#define IDS_FT_PROP_DETAILSFOR              0x2773
#define IDS_FT_EDIT_ALREADYASSOC            0x2774
#define IDS_FT_EDIT_ALRASSOCTITLE           0x2775
#define IDS_FT_EDIT_STATIC2A                0x2776
#define IDS_FT_EDIT_STATIC2B                0x2777
#define IDS_FT_EDIT_STATIC2C                0x2778

#define IDS_FT_NEW                          0x2779
#define IDS_FT_NODESCR                      0x277A
#define IDS_FT_FTTEMPLATE                   0x277B
#define IDS_FT_MB_NOSPACEINEXT              0x277C

#define IDS_FT_ADVBTNTEXTEXPAND             0x277D
#define IDS_FT_ADVBTNTEXTCOLLAPS            0x277E
#define IDS_FT_EXTALREADYUSE                0x277F

#define IDS_EXTTYPETEMPLATE                 0x2780
// unused                                   0x2781
// unused                                   0x2782
#define IDS_FT_PROP_DETAILSFORPROGID        0x2783
#define IDS_FT_PROP_ADVANCED_PROGID         0x2784

#define IDS_FT_PROP_BTN_ADVANCED            0x279a
#define IDS_FT_PROP_BTN_RESTORE             0x279b
#define IDS_FT_PROP_RESTORE                 0x279c

#define IDS_FT_MB_EXISTINGACTION            0x279d

// Items in the "Search Name Space"
#define IDS_SNS_DOCUMENTFOLDERS             0x2800
#define IDS_SNS_LOCALHARDDRIVES             0x2801
#define IDS_SNS_MYNETWORKPLACES             0x2802
#define IDS_SNS_ALL_FILE_TYPES              0x2803
#define IDS_SNS_BROWSER_FOR_DIR             0x2804
#define IDS_SNS_BROWSERFORDIR_TITLE         0x2805

//String id used in mdprsht.c
#define IDS_CONTENTS                        0x2830

#define IDS_ACCESSINGMONIKER                0x2832

// used in recclean.c:
#define IDS_RECCLEAN_NAMETEXT               0x2833
#define IDS_RECCLEAN_DESCTEXT               0x2834
#define IDS_RECCLEAN_BTNTEXT                0x2835

#define IDS_FIT_Delimeter                   0x2921
#define IDS_FIT_ExtraItems                  0x2922
#define IDS_FIT_TipFormat                   0x2923
#define IDS_FIT_Size                        0x2924
#define IDS_FIT_Size_LT                     0x2925
#define IDS_FIT_Size_Empty                  0x2926
#define IDS_FIT_Files                       0x2927
#define IDS_FIT_Folders                     0x2928

#define IDS_WARNING                         0x2955

// Encryption context menu
#define IDS_ECM_ENCRYPT                     0x2951
#define IDS_ECM_DECRYPT                     0x2952
#define IDS_ECM_ENCRYPT_HELP                0x2953
#define IDS_ECM_DECRYPT_HELP                0x2954

// Folder shortcut
#define IDS_BROWSEFORFS                     0x2929
#define IDS_FOLDERSHORTCUT_ERR_TITLE        0x292A
#define IDS_FOLDERSHORTCUT_ERR              0x292B

// Time Categorizer
#define IDS_BEGIN_TIME                      0x3000
#define IDS_TODAY                           0x3000
#define IDS_YESTERDAY                       0x3001
#define IDS_EARLIERTHISWEEK                 0x3002
#define IDS_LASTWEEK                        0x3003
#define IDS_TWOWEEKSAGO                     0x3004
#define IDS_EARLIERTHISMONTH                0x3005
#define IDS_LASTMONTH                       0x3006
#define IDS_TWOMONTHSAGO                    0x3007
#define IDS_EARLIERTHISYEAR                 0x3008
#define IDS_LASTYEAR                        0x3009
#define IDS_TWOYEARSAGO                     0x300A
#define IDS_LONGTIMEAGO                     0x300B
#define IDS_TOMORROW                        0x300C
#define IDS_TWODAYSFROMNOW                  0x300D
#define IDS_LATERTHISWEEK                   0x300E
#define IDS_NEXTWEEK                        0x300F
#define IDS_LATERTHISMONTH                  0x3010
#define IDS_NEXTMONTH                       0x3011
#define IDS_LATERTHISYEAR                   0x3012
#define IDS_NEXTYEAR                        0x3013
#define IDS_SOMETIMETHISMILLENNIA           0x3014
#define IDS_SOMEFUTUREDATE                  0x3015
#define IDS_END_TIME                        0x301F

// Size Categorizer
#define IDS_BEGIN_SIZE                      0x3020
#define IDS_ZERO                            0x3020
#define IDS_TINY                            0x3021
#define IDS_SMALL                           0x3022
#define IDS_MEDIUM                          0x3023
#define IDS_LARGE                           0x3024
#define IDS_HUGE                            0x3025
#define IDS_GIGANTIC                        0x3026
#define IDS_UNSPECIFIED                     0x3027
#define IDS_FOLDERS                         0x3028
#define IDS_END_SIZE                        0x302F

// FreeSpace categorizer
#define IDS_FREESPACEPERCENT                0x3030

// Groups
#define IDS_GROUPBYTIME                     0x3100
#define IDS_GROUPBYSIZE                     0x3101
#define IDS_GROUPALPHABETICALLY             0x3102
#define IDS_GROUPOTHERCHAR                  0x3103
#define IDS_GROUPBYFREESPACE                0x3104
#define IDS_GROUPBYDRIVETYPE                0x3105
#define IDS_GROUPFOLDERS                    0x3106
#define IDS_UNKNOWNGROUP                    0x3107
#define IDS_THISCOMPUTERGROUP               0x3108


// CD Burn
#define IDS_BURN                            0x3110
#define IDS_BURN_PREPARINGBURN              0x3111
#define IDS_BURN_CLOSINGDISC                0x3112
#define IDS_BURN_COMPLETE                   0x3113
#define IDS_BURN_INITIALIZESTASH            0x3114
#define IDS_BURN_ADDDATA                    0x3115
#define IDS_BURN_RECORDING                  0x3116
#define IDS_BURN_WIZTITLE                   0x3117
#define IDS_BURN_CANTWRITEMEDIACDRW         0x3118
#define IDS_BURN_NOTIFY                     0x3119
#define IDS_TIMEEST_SECONDS2                0x311A
#define IDS_TIMEEST_MINUTES2                0x311B
#define IDS_BURN_INSERTDISC                 0x311C
#define IDS_BURN_NOTIFY_TITLE               0x311D
#define IDS_BURN_CANTSHUTDOWN               0x311E
#define IDS_BURN_DISCFULL                   0x311F
#define IDS_BURN_CANTBURN                   0x3120
#define IDS_BURN_HDFULL1                    0x3121
#define IDS_BURN_HDFULL2                    0x3122
#define IDS_BURN_ERASEDISC                  0x3123
#define IDS_BURN_FAILURE_MEDIUM_NOTPRESENT  0x3124
#define IDS_BURN_FAILURE_MEDIUM_INVALIDTYPE 0x3125
#define IDS_BURN_USERBLOCK                  0x3126
#define IDS_BURN_CONFIRM_DISABLE            0x3127
#define IDS_BURN_CANTWRITEMEDIACDR          0x3128
#define IDS_BURN_INSERTDISCFULL             0x3129
#define IDS_BURN_CANTWRITETOMEDIA           0x312A
// reuse                0x312B
// reuse                0x312C
#define IDS_BURN_LOCATION_CD                0x312D
#define IDS_BURN_LOCATION_STAGED            0x312E
// reuse           0x312F
// reuse     0x3130
#define IDS_BURN_CONFIRM_ERASE              0x3131
// reuse  0x3132
#define IDS_BURNWIZ_MUSIC_HEAD              0x3133
#define IDS_BURNWIZ_MUSIC_SUB               0x3134
#define IDS_BURNWIZ_TITLEFONTNAME           0x3135
#define IDS_BURNWIZ_TITLEFONTSIZE           0x3136
#define IDS_BURNWIZ_PROGRESS_BURN_HEAD      0x3137
#define IDS_BURNWIZ_PROGRESS_BURN_SUB       0x3138
#define IDS_BURN_FORMAT_DISCLABEL           0x3139
#define IDS_BURN_CONFIRM_CANCEL             0x313A
#define IDS_BURNWIZ_WAIT_HEAD               0x313B
#define IDS_BURNWIZ_WAIT_SUB                0x313C
#define IDS_BURNWIZ_PROGRESS_ERASE_HEAD     0x313D
#define IDS_BURNWIZ_PROGRESS_ERASE_SUB      0x313E
#define IDS_BURN_DISCFULLTEXT               0x313F
#define IDS_BURN_WRITESPEED_NX              0x3140
#define IDS_BURN_WRITESPEED_FASTEST         0x3141

#define IDS_CHARSINVALID                    0x3170
#define IDS_CHARSVALID                      0x3171

// My Pictures
#define IDS_FOLDER_MYPICS_TT                0x3190
#define IDS_FOLDER_MYMUSIC_TT               0x3191
#define IDS_FOLDER_MYVIDEOS_TT              0x3192
#define IDS_FOLDER_RECENTDOCS               0x3193
#define IDS_FOLDER_RECENTDOCS_TT            0x3194
#define IDS_FOLDER_FAVORITES                0x3195
#define IDS_FOLDER_DESKTOP_TT               0x3196
#define IDS_FOLDER_SHAREDDOCS_TT            0x3197
#define IDS_FOLDER_PRINTERS_TT              0x3198

// Personal Start Menu
#define IDS_AUTOCM_PROPERTIESMENU           0x31A0
#define IDS_AUTOCM_BROWSEINTERNET           0x31A1
#define IDS_AUTOCM_READEMAIL                0x31A2
#define IDS_AUTOCM_WINSECURITY              0x31A3
#define IDS_AUTOCM_SEARCH                   0x31A4
#define IDS_AUTOCM_HELP                     0x31A5
#define IDS_AUTOCM_FILERUN                  0x31A6


// Thumbview
#define IDS_THUMBNAILVIEW_DESC              0x4000
#define IDS_RENAME_TITLE                    0x4001
#define IDS_CREATETHUMBNAIL                 0x4002
#define IDS_CREATETHUMBNAILHELP             0x4003
#define IDS_HTMLTHUMBEXTRACT_DESC           0x4004
#define IDS_BMPTHUMBEXTRACT_DESC            0x4005
#define IDS_OFCTHUMBEXTRACT_DESC            0x4006
#define IDS_DOCTHUMBEXTRACT_DESC            0x4007
#define IDS_TASKSCHEDULER_DESC              0x4008
#define IDS_LNKTHUMBEXTRACT_DESC            0x4009
#define IDS_EXTRACTING                      0x400A
#define IDS_THUMBNAILGEN_DESC               0x400B
#define IDS_GDITHUMBEXTRACT_DESC            0x400D

// Storage Processor
#define ID_CONFIRM_SINGLE_ICON          0x4101
#define ID_CONFIRM_SINGLE_MAIN_TEXT     0x4104
#define IDS_PROJNAME                    0x4100
#define IDS_STORAGEPROCESSOR_DESC       0x4101
#define IDR_StorageProcessor            0x4102
#define IDS_PREPARINGTOCOPY             0x4102
#define IDS_PREPARINGTOMOVE             0x4103
#define IDS_PREPARINGTOREMOVE           0x4104
#define IDS_PREPARINGTOSYNC             0x4105
#define IDS_SCANNING                    0x4108
#define IDS_GATHERINGSTATS              0x4109
#define IDS_DEFAULTTITLE                0x4112
#define IDR_VIRTUALSTORAGE              0x4113
#define IDR_VIRTUALSTORAGEENUM          0x4114
#define IDC_CHECK1                      0x4116
#define IDD_REPEAT                      0x4117
#define IDS_CONFIRM_FILE_DELETE         0x4118
#define ID_IMAGE_ITEM_1                 0x411A
#define IDS_CONFIRM_FILE_RENAME         0x411B
#define ID_IMAGE_ITEM_2                 0x411D
#define IDS_CONFIRM_FILE_MOVE           0x411E
#define DLG_CONFIRM_SINGLE              0x411F
#define IDS_CONFIRM_FOLDER_DELETE       0x4122
#define IDC_BUTTON4                     0x4123
#define IDS_CONFIRM_FOLDER_RENAME       0x4125
#define IDC_BUTTON3                     0x4126
#define IDS_CONFIRM_FOLDER_MOVE         0x4128
#define IDC_BUTTON2                     0x4129
#define IDS_CONFIRM_COMPRESSION_LOSS    0x4130
#define IDS_CONFIRM_STREAM_LOSS         0x4132
#define IDC_BUTTON1                     0x4133
#define IDS_CONFIRM_ENCRYPTION_LOSS     0x4135
#define IDS_CONFIRM_METADATA_LOSS       0x4137
#define IDS_CONFIRM_ACL_LOSS            0x4139
#define IDS_SELECT_FILE_NAME            0x413B
#define IDS_SELECT_FOLDER_NAME          0x413D
#define IDS_CONFIRM_FILE_REPLACE        0x413F
#define IDS_CONFIRM_FOLDER_REPLACE      0x4141
#define IDI_NUKE                        0x4146
#define IDI_NUKE_FILE                   0x4148
#define IDI_NUKE_FOLDER                 0x414B
#define IDI_ATTRIBS_FOLDER              0x414D
#define IDI_ATTRIBS_FILE                0x414E
#define IDI_DEFAULTICON                 0x4151
#define IDS_DELETE_FILE                 0x4152
#define IDS_DELETE_FOLDER               0x4153
#define IDS_NUKE_FILE                   0x4154
#define IDS_NUKE_FOLDER                 0x4155
#define IDS_DELETE_READONLY_FILE        0x4156
#define IDS_DELETE_READONLY_FOLDER      0x4157
#define IDS_DELETE_SYSTEM_FILE          0x4158
#define IDS_DELETE_SYSTEM_FOLDER        0x4159
#define IDS_DELETE_TOOBIG_FILE          0x4160
#define IDS_DELETE_TOOBIG_FOLDER        0x4161
#define IDS_DELETE_PROGRAM_FILE         0x4162
#define IDS_MOVE_READONLY_FILE          0x4163
#define IDS_MOVE_READONLY_FOLDER        0x4164
#define IDS_MOVE_SYSTEM_FILE            0x4165
#define IDS_MOVE_SYSTEM_FOLDER          0x4166
#define IDS_RENAME_READONLY_FILE        0x4167
#define IDS_RENAME_READONLY_FOLDER      0x4168
#define IDS_RENAME_SYSTEM_FILE          0x4169
#define IDS_RENAME_SYSTEM_FOLDER        0x416A
#define IDS_STREAM_LOSS_COPY_FILE       0x416B
#define IDS_STREAM_LOSS_COPY_FOLDER     0x416C
#define IDS_STREAM_LOSS_MOVE_FILE       0x416D
#define IDS_STREAM_LOSS_MOVE_FOLDER     0x416E
#define IDS_METADATA_LOSS_COPY_FILE     0x416F
#define IDS_METADATA_LOSS_COPY_FOLDER   0x4170
#define IDS_METADATA_LOSS_MOVE_FILE     0x4171
#define IDS_METADATA_LOSS_MOVE_FOLDER   0x4172
#define IDS_COMPRESSION_LOSS_COPY_FILE  0x4173
#define IDS_COMPRESSION_LOSS_COPY_FOLDER 0x4174
#define IDS_COMPRESSION_LOSS_MOVE_FILE  0x4175
#define IDS_COMPRESSION_LOSS_MOVE_FOLDER 0x4176
#define IDS_SPARSE_LOSS_COPY_FILE       0x4177
#define IDS_SPARSE_LOSS_MOVE_FILE       0x4178
#define IDS_ENCRYPTION_LOSS_COPY_FILE   0x4179
#define IDS_ENCRYPTION_LOSS_COPY_FOLDER 0x4180
#define IDS_ENCRYPTION_LOSS_MOVE_FILE   0x4181
#define IDS_ENCRYPTION_LOSS_MOVE_FOLDER 0x4182
#define IDS_DEFAULTDESC                 0x4183
#define IDS_REPLACE_FILE                0x4184
#define IDS_REPLACEEXISTING_FILE        0x4185
#define IDS_WITHTHIS                    0x4186
#define IDS_REPLACE_FOLDER              0x4187
#define IDS_REPLACEEXISTING_FOLDER      0x4188
#define IDS_INTOTHIS                    0x4189
#define ID_CONDITION_TEXT               0x418B
#define ID_DETAILS_ITEM_1               0x418C
#define ID_DETAILS_ITEM_2               0x418D
#define IDD_CONFIRM_TEXT                0x418E
#define IDS_PROPFORMAT                  0x418F
#define IDS_UNKNOWN_COPY_FILE           0x4190
#define IDS_UNKNOWN_COPY_FOLDER         0x4191
#define IDS_UNKNOWN_MOVE_FILE           0x4192
#define IDS_UNKNOWN_MOVE_FOLDER         0x4193
#define IDS_UNKNOWN_COPY_TITLE          0x4194
#define IDS_UNKNOWN_MOVE_TITLE          0x4195
#define IDS_NO_STORAGE_MOVE             0x4196
#define IDS_NO_STORAGE_COPY             0x4197

#define IDD_CONFIRM_RETRYSKIPCANCEL     0x4200
#define IDD_CONFIRM_RETRYCANCEL         0x4201
#define IDD_CONFIRM_YESSKIPCANCEL       0x4202
#define IDD_CONFIRM_YESCANCEL           0x4203
#define IDD_CONFIRM_RENAMESKIPCANCEL    0x4204
#define IDD_CONFIRM_RENAMECANCEL        0x4205
#define IDD_CONFIRM_YESSKIPRENAMECANCEL 0x4206
#define IDD_CONFIRM_YESRENAMECANCEL     0x4207
#define IDD_CONFIRM_SKIPCANCEL          0x4208
#define IDD_CONFIRM_CANCEL              0x4209
#define IDD_CONFIRM_OK                  0x420A

// more string ids for pickicon.c
#define IDS_FILETYPE_PICKICONDLG_CAPTION    0x4300
#define IDS_FOLDER_PICKICONDLG_CAPTION      0x4301

// Autoplay dialogs strings
#define IDS_AP_OPENFOLDER                 0x4302
#define IDS_AP_OPENFOLDER_PROVIDER        0x4303
#define IDS_AP_SLIDESHOW                  0x4304
#define IDS_AP_SLIDESHOW_PROVIDER         0x4305
#define IDS_AP_PRINTPICTURE               0x4306
#define IDS_AP_PRINTPICTURE_PROVIDER      0x4307
#define IDS_AP_USING                      0x4308
#define IDS_AP_PICTURESCONTENTHANDLER     0x4309
#define IDS_AP_MUSICFILESCONTENTHANDLER   0x430A
#define IDS_AP_VIDEOFILESCONTENTHANDLER   0x430B
#define IDS_AP_CDAUDIOCONTENTHANDLER      0x430C
#define IDS_AP_DVDMOVIECONTENTHANDLER     0x430D
#define IDS_AP_BLANKCDCONTENTHANDLER      0x430E
#define IDS_AP_MIXEDCONTENTCONTENTHANDLER 0x430F
#define IDS_AP_TAKENOACTION               0x4310
#define IDS_AP_CDBURNING                  0x4311
#define IDS_AP_CDBURNING_PROVIDER         0x4312
#define IDS_AP_PLAYAUDIOCD_LEGACY         0x4313
#define IDS_AP_PLAYDVDMOVIE_LEGACY        0x4314
#define IDS_AP_SNIFFPROGRESSDIALOG        0x4315

// string ids for IPropertyUI::FormatForDisplay

#define IDS_PROPERTYUI_MUSIC_BITRATE        0x4331
#define IDS_PROPERTYUI_IMAGE_FLASHFIRED     0x4332
#define IDS_PROPERTYUI_IMAGE_NOFLASH        0x4333
#define IDS_PROPERTYUI_IMAGE_NOSTROBERETURN 0x4334
#define IDS_PROPERTYUI_IMAGE_STROBERETURN   0x4335
#define IDS_PROPERTYUI_IMAGE_SRGB           0x4336
#define IDS_PROPERTYUI_IMAGE_UNCALIBRATED   0x4337
#define IDS_PROPERTYUI_YES                  0x4338
#define IDS_PROPERTYUI_NO                   0x4339
#define IDS_PROPERTYUI_AUDIO_SAMPLERATE     0x433A
#define IDS_PROPERTYUI_AUDIO_CHANNELCOUNT1  0x433B
#define IDS_PROPERTYUI_AUDIO_CHANNELCOUNT2  0x433C
#define IDS_PROPERTYUI_VIDEO_FRAMERATE      0x433D
#define IDS_PROPERTYUI_AV_SAMPLESIZE        0x433E
#define IDS_PROPERTYUI_IMAGE_PIXELS         0x433F

#define IDS_PROPERTYUI_IMAGE_UNKNOWN        0x4340
#define IDS_PROPERTYUI_IMAGE_AVERAGE        0x4341
#define IDS_PROPERTYUI_IMAGE_CWA            0x4342
#define IDS_PROPERTYUI_IMAGE_SPOT           0x4343
#define IDS_PROPERTYUI_IMAGE_MULTISPOT      0x4344
#define IDS_PROPERTYUI_IMAGE_PATTERN        0x4345
#define IDS_PROPERTYUI_IMAGE_PARTIAL        0x4346
#define IDS_PROPERTYUI_IMAGE_DAYLIGHT       0x4347
#define IDS_PROPERTYUI_IMAGE_FLOURESCENT    0x4348
#define IDS_PROPERTYUI_IMAGE_TUNGSTEN       0x4349
#define IDS_PROPERTYUI_IMAGE_STANDARDA      0x434A
#define IDS_PROPERTYUI_IMAGE_STANDARDB      0x434B
#define IDS_PROPERTYUI_IMAGE_STANDARDC      0x434c
#define IDS_PROPERTYUI_IMAGE_D55            0x434D
#define IDS_PROPERTYUI_IMAGE_D65            0x434E
#define IDS_PROPERTYUI_IMAGE_D75            0x434F
#define IDS_PROPERTYUI_IMAGE_MANUAL         0x4350
#define IDS_PROPERTYUI_IMAGE_NORMAL         0x4351
#define IDS_PROPERTYUI_IMAGE_APERTUREPRI    0x4352
#define IDS_PROPERTYUI_IMAGE_SHUTTERPRI     0x4353
#define IDS_PROPERTYUI_IMAGE_CREATIVE       0x4354
#define IDS_PROPERTYUI_IMAGE_ACTION         0x4355
#define IDS_PROPERTYUI_IMAGE_PORTRAIT       0x4356
#define IDS_PROPERTYUI_IMAGE_LANDSCAPE      0x4357
// string ids dor DUI tasks (below) fit here
#define IDS_PROPERTYUI_IMAGE_DPI            0x435A
#define IDS_PROPERTYUI_IMAGE_SEC            0x435B
#define IDS_PROPERTYUI_IMAGE_SEC_FRAC       0x435C
#define IDS_PROPERTYUI_IMAGE_F              0x435D
#define IDS_PROPERTYUI_IMAGE_M              0x435E
#define IDS_PROPERTYUI_IMAGE_MM             0x435F
#define IDS_PROPERTYUI_IMAGE_ISO            0x4360
#define IDS_PROPERTYUI_IMAGE_BCPS           0x4361
#define IDS_PROPERTYUI_IMAGE_STEP           0x4362

// string ids for DUI tasks
#define IDS_BLOCKADETITLE                   0x4358
#define IDS_BLOCKADEMESSAGE                 0x4359

// ids for sdspatch
#define IDR_MIGWIZAUTO                      0x4400

#define IDS_EXPLORERMANIFEST                0x5000

// printer's folder DUI webview strings

// unused                                       0x5100

// bkgnd menu (common) commands
#define IDS_PRINTERS_WV_ADDPRINTER              0x5101
#define IDS_PRINTERS_WV_ADDPRINTER_TT           0x5102
#define IDS_PRINTERS_WV_SRVPROPS                0x5103
#define IDS_PRINTERS_WV_SRVPROPS_TT             0x5104
#define IDS_PRINTERS_WV_SENDFAX                 0x5105
#define IDS_PRINTERS_WV_SENDFAX_TT              0x5106
#define IDS_PRINTERS_WV_TROUBLESHOOTER          0x5107
#define IDS_PRINTERS_WV_TROUBLESHOOTER_TT       0x5108
#define IDS_PRINTERS_WV_GOTOSUPPORT             0x5109
#define IDS_PRINTERS_WV_GOTOSUPPORT_TT          0x510a
#define IDS_PRINTERS_WV_SETUPFAXING             0x510b
#define IDS_PRINTERS_WV_CREATEFAXPRN_TT         0x510c
#define IDS_PRINTERS_WV_CREATEFAXPRN            0x510d
#define IDS_PRINTERS_WV_SETUPFAXING_TT          0x510e

// commands single selection
#define IDS_PRINTERS_WV_FLD_RENAME              0x511a
#define IDS_PRINTERS_WV_FLD_RENAME_TT           0x511b
#define IDS_PRINTERS_WV_FLD_DELETE              0x511c
#define IDS_PRINTERS_WV_FLD_DELETE_TT           0x511d
#define IDS_PRINTERS_WV_FLD_PROPERTIES          0x511e
#define IDS_PRINTERS_WV_FLD_PROPERTIES_TT       0x511f

#define IDS_PRINTERS_WV_PRN_RENAME              0x512c
#define IDS_PRINTERS_WV_PRN_RENAME_TT           0x512d
#define IDS_PRINTERS_WV_PRN_DELETE              0x512e
#define IDS_PRINTERS_WV_PRN_DELETE_TT           0x512f
#define IDS_PRINTERS_WV_PRN_PROPERTIES          0x5130
#define IDS_PRINTERS_WV_PRN_PROPERTIES_TT       0x5131

#define IDS_PRINTERS_WV_PRN_OPENQUEUE           0x513e
#define IDS_PRINTERS_WV_PRN_OPENQUEUE_TT        0x513f
#define IDS_PRINTERS_WV_PRN_PREFERENCES         0x5140
#define IDS_PRINTERS_WV_PRN_PREFERENCES_TT      0x5141
#define IDS_PRINTERS_WV_PRN_PAUSE               0x5142
#define IDS_PRINTERS_WV_PRN_PAUSE_TT            0x5143
#define IDS_PRINTERS_WV_PRN_RESUME              0x5144
#define IDS_PRINTERS_WV_PRN_RESUME_TT           0x5145
#define IDS_PRINTERS_WV_PRN_SHARE               0x5146
#define IDS_PRINTERS_WV_PRN_SHARE_TT            0x5147
#define IDS_PRINTERS_WV_PRN_VENDORURL           0x5148
#define IDS_PRINTERS_WV_PRN_VENDORURL_TT        0x5149
#define IDS_PRINTERS_WV_PRN_PRINTERURL          0x514a
#define IDS_PRINTERS_WV_PRN_PRINTERURL_TT       0x514b

// commands for multiple selection 
#define IDS_PRINTERS_WV_ANYMUL_DELETE           0x515a
#define IDS_PRINTERS_WV_ANYMUL_DELETE_TT        0x515b
#define IDS_PRINTERS_WV_ANYMUL_PROPERTIES       0x515c
#define IDS_PRINTERS_WV_ANYMUL_PROPERTIES_TT    0x515d

#define IDS_PRINTERS_WV_FLDMUL_DELETE           0x515e
#define IDS_PRINTERS_WV_FLDMUL_DELETE_TT        0x515f
#define IDS_PRINTERS_WV_FLDMUL_PROPERTIES       0x5160
#define IDS_PRINTERS_WV_FLDMUL_PROPERTIES_TT    0x5161

#define IDS_PRINTERS_WV_MUL_DELETE              0x5165
#define IDS_PRINTERS_WV_MUL_DELETE_TT           0x5166
#define IDS_PRINTERS_WV_MUL_PROPERTIES          0x5167
#define IDS_PRINTERS_WV_MUL_PROPERTIES_TT       0x5168

// headers
#define IDS_PRINTERS_WV_HEADER_TASKS            0x5182
#define IDS_PRINTERS_WV_HEADER_TASKS_TT         0x5183
#define IDS_PRINTERS_WV_HEADER_SEEALSO          0x5184
#define IDS_PRINTERS_WV_HEADER_SEEALSO_TT       0x5185

///////////////////////////////////////////////////////////////////////
// printer's web view ICONS:
//
// (alias the icon IDs to IDI_PRINTERS_WV_DEFAULT 
//  until we get real ones)
//
#define IDI_PRINTERS_WV_DEFAULT                 IDI_TASK_COPY
#define IDI_PRINTERS_WV_URLLIKE                 IDI_TASK_PUBLISH
#define IDI_PRINTERS_WV_FIRST                   1000

#define IDI_PRINTERS_WV_INFO                    1001 // IDI_PRINTERS_WV_FIRST+1
#define IDI_PRINTERS_WV_PROPERTIES              1002 // IDI_PRINTERS_WV_FIRST+2
#define IDI_PRINTERS_WV_SRVPROPS                1003 // IDI_PRINTERS_WV_FIRST+3
#define IDI_PRINTERS_WV_TROUBLESHOOTER          1004 // IDI_PRINTERS_WV_FIRST+4
#define IDI_PRINTERS_WV_SENDFAX                 1005 // IDI_PRINTERS_WV_FIRST+5
#define IDI_PRINTERS_WV_OPENQUEUE               1006 // IDI_PRINTERS_WV_FIRST+6
#define IDI_PRINTERS_WV_PREFERENCES             1007 // IDI_PRINTERS_WV_FIRST+7
#define IDI_PRINTERS_WV_PAUSE                   1008 // IDI_PRINTERS_WV_FIRST+8
#define IDI_PRINTERS_WV_RESUME                  1009 // IDI_PRINTERS_WV_FIRST+9
#define IDI_PRINTERS_WV_SHARE                   1010 // IDI_PRINTERS_WV_FIRST+10
#define IDI_PRINTERS_WV_FAXING                  1011 // IDI_PRINTERS_WV_FIRST+11

// borrowed icons (remaped)
#define IDI_PRINTERS_WV_ADDPRINTER              IDI_NEWPRN
#define IDI_PRINTERS_WV_RENAME                  IDI_TASK_RENAME
#define IDI_PRINTERS_WV_DELETE                  IDI_TASK_DELETE
#define IDI_PRINTERS_WV_GOTOSUPPORT             IDI_STHELP
#define IDI_PRINTERS_WV_VENDORURL               IDI_PRINTERS_WV_URLLIKE
#define IDI_PRINTERS_WV_PRINTERURL              IDI_PRINTERS_WV_URLLIKE

// dialog IDs of caller's dialog if FILEOP_CREATEPROGRESSDLG is not set

#define IDD_STATUS          100
#define IDD_TOSTATUS        101
#define IDD_NAME            102
#define IDD_TONAME          103
#define IDD_PROBAR          104
#define IDD_TIMEEST         105
#define IDD_ANIMATE         106

// numbers 0x3000 - 0x3FFF are taken up in Control IDs (buttons, etc)
// maybe?

#define IDD_BROWSE              0x3000
#define IDD_PROMPT              0x3001
#define IDD_PATH                0x3002
#define IDD_TEXT                0x3003
#define IDD_TEXT1               0x3004
#define IDD_TEXT2               0x3005
#define IDD_TEXT3               0x3006
#define IDD_TEXT4               0x3007
#define IDD_ARPWARNINGTEXT      0x3008 // NOTE: This is only supposed to be used by DLG_DELETE_FILE_ARP
#define IDD_ICON                0x3009
#define IDD_COMMAND             0x300A
#// --- UNUSED ---------------  0x300B
#define IDD_ICON_OLD            0x300C
#define IDD_ICON_NEW            0x300D
#define IDD_FILEINFO_OLD        0x300E
#define IDD_FILEINFO_NEW        0x300F
#define IDD_ICON_WASTEBASKET    0x3010
#define IDD_RUNDLGOPENPROMPT    0x3011
#define IDD_RUNINSEPARATE       0x3012
#define IDD_RUNWITHSHIMLAYER    0x3013

#define IDD_PAGELIST            0x3020
#define IDD_APPLYNOW            0x3021
#define IDD_DLGFRAME            0x3022

#define IDD_RESTORE             0x3023
#define IDD_SPOOL_TXT           0x3024
#define IDD_ARPLINKWINDOW       0x3025
// #define unused, use me!      0x3026

// Leave some room here just in case.

#define IDD_REFERENCE           0x3100
#define IDD_WORKDIR             0x3101

// these are for the confirmation dialogs
#define IDD_DIR                 0x3201
#define IDD_FROM                0x3202
#define IDD_TO                  0x3203
#define IDD_DATE1               0x3205
#define IDD_DATE2               0x3206
#define IDD_YESTOALL            0x3207
#define IDD_NOTOALL             0x3208
#define IDD_FLAGS               0x3209
#define IDD_STATIC              0x320a


// userlogon dialog
// needs only to be unique within itself
#define IDD_CURRENTUSER         0x100
#define IDC_USERNAME            0x101
#define IDC_PASSWORD            0x102
#define IDC_USECURRENTACCOUNT   0x103
#define IDC_USEOTHERACCOUNT     0x104
#define IDC_CREDCTL             0x105
#define IDC_SANDBOX             0x106

#define IDD_OPEN                0x3210
#define IDD_EMPTY               0x3211

// for general file dialog page
#define IDD_ITEMICON            0x3301
#define IDD_FILENAME            0x3302
#define IDD_FILETYPE            0x3303
#define IDD_NUMFILES            0x3304
#define IDD_ACTNAMES            0x3305
#define IDD_ACTKEYS             0x3306
#define IDD_FILESIZE            0x3308
#define IDD_LOCATION            0x3309
#define IDD_CREATED             0x3310
#define IDD_LASTMODIFIED        0x3311
#define IDD_LASTACCESSED        0x3312
#define IDD_READONLY            0x3313
#define IDD_HIDDEN              0x3314
#define IDD_ARCHIVE             0x3315
#define IDD_DELETED             0x3317
#define IDD_FILETYPE_TXT        0x3318
#define IDD_FILESIZE_TXT        0x3319
#define IDD_CONTAINS_TXT        0x3320
#define IDD_LOCATION_TXT        0x3321
#define IDD_FILENAME_TXT        0x3322
#define IDD_ATTR_GROUPBOX       0x3323
#define IDD_CREATED_TXT         0x3324
#define IDD_LASTMODIFIED_TXT    0x3325
#define IDD_LASTACCESSED_TXT    0x3326
#define IDD_LINE_1              0x3327
#define IDD_LINE_2              0x3328
#define IDD_LINE_3              0x3329
#define IDD_DELETED_TXT         0x3330

#define IDD_COMPRESS                0x3331 // "Compress" check box.
#define IDD_FILESIZE_COMPRESSED     0x3332 // Compressed size value text.
#define IDD_FILESIZE_COMPRESSED_TXT 0x3333 // "Compressed Size" text.
#define IDD_TYPEICON            0x3334

#define IDD_LINE_4              0x3335
#define IDD_OPENSWITH_NOCHANGE  0x3336

#define IDD_FILETYPE_TARGET     0x3337  // "Target:" text on mounted volume page

// for version dialog page

#define IDD_VERSION_FRAME           0x3350
#define IDD_VERSION_KEY             0x3351
#define IDD_VERSION_VALUE           0x3352
#define IDD_VERSION_FILEVERSION     0x3353
#define IDD_VERSION_DESCRIPTION     0x3354
#define IDD_VERSION_COPYRIGHT       0x3355

// new stuff on the file/folder properties
#define IDD_OPENSWITH_TXT       0x3360
#define IDD_OPENSWITH           0x3361
#define IDC_ADVANCED            0x3362
#define IDC_CHANGEFILETYPE      0x3363
#define IDD_NAMEEDIT            0x3364
#define IDC_MANAGEFILES_TXT     0x3365
#define IDD_INDEX               0x3366
#define IDD_ENCRYPT             0x3367
#define IDC_ENCRYPTDETAILS      0x3368
#define IDC_MANAGEFOLDERS_TXT   0x3369
#define IDD_ATTRIBSTOAPPLY      0x336a
#define IDD_NOTRECURSIVE        0x336b
#define IDD_RECURSIVE_TXT       0x336c
#define IDD_RECURSIVE           0x336d
#define IDD_MANAGEFOLDERS_TXT   0x336e
#define IDD_EJECT               0x336f
#define IDD_ERROR_TXT           0x3370

#define IDD_OPENWITH            0x3371

// Folder shortcut general dialog
#define IDD_TARGET              0x3380
#define IDD_TARGET_TXT          0x3381
#define IDD_COMMENT_TXT         0x3382


// unicpp\resource.h defines more values starting at 0x8500

////////////////////////////////
// fileview stuff

//------------------------------
// Menu IDs

#define POPUP_NONDEFAULTDD              200
#define POPUP_MOVEONLYDD                201
#define POPUP_BRIEFCASE_NONDEFAULTDD    202
#define POPUP_DRIVES_NONDEFAULTDD       203
#define POPUP_BOOKMARK_NONDEFAULTDD     204
#define POPUP_SCRAP                     205
#define POPUP_FILECONTENTS              206
#define POPUP_BRIEFCASE_FOLDER_NONDEFAULTDD 207
#define POPUP_DROPONEXE                 208
#define POPUP_BRIEFCASE_FILECONTENTS    209
#define POPUP_DESKTOPCONTENTS           199
#define POPUP_DESKTOPCONTENTS_IMG       198
#define POPUP_EMBEDDEDOBJECT            197
#define POPUP_TEMPLATEDD                196
//--------------------------------------------------------------------------
// Menu items for views (210-299 are reserved)
//

#define POPUP_DCM_ITEM          210
#define POPUP_DCM_ITEM2         211

#define POPUP_SFV_BACKGROUND    215
#define POPUP_SFV_MAINMERGE     216
#define POPUP_SFV_MAINMERGENF   217
#define POPUP_SFV_BACKGROUND_AD 218

#define POPUP_PROPERTIES_BG     220
#define POPUP_FSVIEW_ITEM_COREL7_HACK 223 //win95 send to menu for corel suite 7

#define POPUP_DESKTOP_ITEM      225
#define POPUP_BITBUCKET_ITEM    226
#define POPUP_BITBUCKET_POPUPMERGE  227

#define POPUP_FINDEXT_POPUPMERGE   229

#define POPUP_NETWORK_ITEM      232
#define POPUP_NETWORK_PRINTER   233

#define POPUP_CONTROLS_POPUPMERGE 240

#define POPUP_DRIVES_ITEM       247
#define POPUP_DRIVES_PRINTERS   248

#define POPUP_BRIEFCASE         250

#define POPUP_FIND              255
#define POPUP_DOCFIND_MERGE        258
#define POPUP_DOCFIND_ITEM_MERGE   259

#define POPUP_COMMDLG_POPUPMERGE   260

#define POPUP_BURN_POPUPMERGE      261

#define MENU_FINDDLG                303
#define MENU_FINDCOMPDLG            304

#define MENU_SM_CONTEXTMENU         305

#define MENU_GENERIC_OPEN_VERBS     351

#define MENU_PRINTOBJ_NEWPRN        352
#define MENU_PRINTOBJ_VERBS         353

#define MENU_PRINTOBJ_NEWPRN_DD     355
#define MENU_PRINTOBJ_DD            356

#define MENU_PRINTERQUEUE           357
#define MENU_FAV_ITEMCONTEXT        358
#define MENU_STARTMENUSTATICITEMS   359

#define MENU_GENERIC_CONTROLPANEL_VERBS 360

#ifdef NEPTUNE
#define MENU_SHUTDOWNMENUITEMS      361
#endif

#define MENU_ADDPRINTER_OPEN_VERBS  362

// unicpp\resource.h defines more IDs starting at 400
// menuband\mnbandid.h defines more IDs starting at 500

//------------------------------
#define IDM_NOOP                    855

#define IDM_OPENCONTAINING          0xa000
#define IDM_CASESENSITIVE           0xa001
#define IDM_REGULAREXP              0xa002
#define IDM_SAVESEARCH              0xa003
#define IDM_CLOSE                   0xa004
#define IDM_SAVERESULTS             0xa005
#define IDM_HELP_FIND               0xa006
#define IDM_HELP_WHATSTHIS          0xa007
#define IDM_MENU_OPTIONS            0xa010
#define IDM_FIND_MENU_FIRST         IDM_OPENCONTAINING
#define IDM_FIND_MENU_LAST          IDM_HELP_WHATSTHIS

// more menu item IDs in unicpp\resource.h starting at 0xa100

// for link dialog pages
#define IDD_LINK_DESCRIPTION        0X3401
#define IDD_LINK_COMMAND            0X3402
#define IDD_LINK_WORKINGDIR         0X3403
#define IDD_LINK_HOTKEY             0X3404
#define IDD_LINK_HELP               0X3405
#define IDD_FINDORIGINAL            0X3406
#define IDD_LINKDETAILS             0X3407
#define IDD_LINK_SHOWCMD            0x3408
#define IDD_LINK_RUNASUSER          0x3409

// Old SHELL.DLL control IDs (oldshell.dlg)
#define IDD_APPNAME                 0x3500
#define IDD_CONFIG                  0x3501
#define IDD_CONVTITLE               0x3502
#define IDD_CONVENTIONAL            0x3503
#define IDD_EMSFREE                 0x3504
#define IDD_SDTEXT                  0x3505
#define IDD_SDUSING                 0x3506
#define IDD_USERNAME                0x3507
#define IDD_COMPANYNAME             0x3508
#define IDD_SERIALNUM               0x3509
#define IDD_COPYRIGHTSTRING         0x350a
#define IDD_VERSION                 0x350b
#define IDD_EMSTEXT                 0x350c
#define IDD_OTHERSTUFF              0x350d
#define IDD_DOSVER                  0x350e
#define IDD_PROCESSOR               0x350f
#define IDD_PRODUCTID               0x3510
#define IDD_OEMID                   0x3511
#define IDD_EULA                    0x3512

#define IDD_APPLIST             0x3605
#define IDD_DESCRIPTION         0x3506
#define IDD_OTHER               0x3507
#define IDD_DESCRIPTIONTEXT     0x3508
#define IDD_MAKEASSOC           0x3509

#define IDD_WEBAUTOLOOKUP       0x350a
#define IDD_OPENWITHLIST        0x350b

#define IDD_DOWNLOADLINK        0x350c
#define IDD_OPENWITH_BROWSE     0x350d
#define IDD_FILE_TEXT           0x350e
#define IDD_OPENWITH_WEBSITE    0x3511

// For find dialog
#define IDD_START                   0x3700
#define IDD_STOP                    0x3701
#define IDD_FILELIST                0x3702
#define IDD_NEWSEARCH               0x3703

//#define IDD_PATH                  (already defined)
//#define IDD_BROWSE                (already defined)
#define IDD_FILESPEC                0x3710
#define IDD_TOPLEVELONLY            0x3711
#define IDD_TEXTCASESEN             0x3712
#define IDD_TEXTREG                 0x3713
#define IDD_SEARCHSLOWFILES         0x3714
#define IDD_SEARCHSYSTEMDIRS        0x3715
#define IDD_SEARCHHIDDEN            0x3716

#define IDD_TYPECOMBO               0x3720
#define IDD_CONTAINS                0x3721
#define IDD_SIZECOMP                0x3722
#define IDD_SIZEVALUE               0x3723
#define IDD_SIZEUPDOWN              0x3724
#define IDD_SIZELBL                 0x3725

#define IDD_MDATE_ALL               0x3730
#define IDD_MDATE_PARTIAL           0x3731
#define IDD_MDATE_DAYS              0x3732
#define IDD_MDATE_MONTHS            0x3733
#define IDD_MDATE_BETWEEN           0x3734
#define IDD_MDATE_NUMDAYS           0x3735
#define IDD_MDATE_DAYSUPDOWN        0x3736
#define IDD_MDATE_NUMMONTHS         0x3737
#define IDD_MDATE_MONTHSUPDOWN      0x3738
#define IDD_MDATE_FROM              0x3739
#define IDD_MDATE_TO                0x373a
#define IDD_MDATE_TYPE              0x373b
#define IDD_MDATE_AND               0x373c
#define IDD_MDATE_MONTHLBL          0x373d
#define IDD_MDATE_DAYLBL            0x373e

#define IDD_COMMENT                 0x3740
#define IDD_FOLDERLIST              0x3741
#define IDD_BROWSETITLE             0x3742
#define IDD_BROWSESTATUS            0x3743
#define IDD_BROWSEEDIT              0x3744
#define IDD_SAVERESULTS             0x3745
#define IDD_NEWFOLDER_BUTTON        0x3746
#define IDD_BFF_RESIZE_TAB          0x3747
#define IDD_FOLDERLABLE             0x3748
#define IDD_BROWSEINSTRUCTION       0x3749

// for encryption warning dialog
#define IDC_ENCRYPT_FILE            0x3750
#define IDC_ENCRYPT_PARENTFOLDER    0x3751

// for folder customization tab
#define IDC_FOLDER_TEMPLATES        0x3760
#define IDC_FOLDER_RECURSE          0x3761
#define IDC_FOLDER_DEFAULT          0x3763
#define IDC_FOLDER_PREVIEW_ICON     0x3764
#define IDC_FOLDER_PREVIEW_BITMAP   0x3765
#define IDC_FOLDER_PICKBROWSE       0x3766
#define IDC_FOLDER_CHANGEICON       0x3767
#define IDC_FOLDER_ICON             0x3768
#define IDC_FOLDER_PREVIEW_TEXT     0x3769
#define IDC_FOLDER_CHANGEICONGROUP  0x376A
#define IDC_FOLDER_CHANGEICONTEXT   0x376B

#define IDC_TITLE_FLAG                          0x3800
#define IDC_TITLE_SWITCHUSER                    0x3801
#define IDC_BUTTON_SWITCHUSER                   0x3802
#define IDC_BUTTON_LOGOFF                       0x3803
#define IDC_TEXT_SWITCHUSER                     0x3804
#define IDC_TEXT_LOGOFF                         0x3805

#define IDS_SWITCHUSER_TITLE_FACENAME           0x3806
#define IDS_SWITCHUSER_TITLE_FACESIZE           0x3807
//  0x3808 used below
#define IDS_SWITCHUSER_BUTTON_FACENAME          0x3809
//  0x380a/0x380b used below
#define IDS_SWITCHUSER_BUTTON_FACESIZE          0x380c

#define IDS_SWITCHUSER_TOOLTIP_TEXT_SWITCHUSER  0x380d
#define IDS_SWITCHUSER_TOOLTIP_TEXT_LOGOFF      0x380e

#define IDB_BACKGROUND_8                        0x380f
//  0x3810 used below
#define IDB_FLAG_8                              0x3811
#define IDB_BACKGROUND_24                       0x3812
#define IDB_FLAG_24                             0x3813

#define IDB_BUTTONS                             0x3814
//  0x3815 to 0x381f free

// for logoff dialog
#define IDD_LOGOFFICON              0x3808
// for disconnect dialog
#define IDD_DISCONNECTICON          0x380a

// for legacy scandisk (app compat shim)
#define IDD_SCANDSKW                0x380b

    #define IDC_SCANDSKICON         100
    #define IDC_SCANDSKLV           101

#define DLG_ABOUT                   0x3810

// global ids
#define IDC_STATIC                  -1
#define IDC_GROUPBOX                300
#define IDC_GROUPBOX_2              301
#define IDC_GROUPBOX_3              302

//
// ids to disable context Help
//
#define IDC_NO_HELP_1               650
#define IDC_NO_HELP_2               651
#define IDC_NO_HELP_3               652
#define IDC_NO_HELP_4               653

// for pifmgr pages
#define IDD_PROGRAM                 0x3820
#define IDD_PIFNTTEMPLT             0x3821
#define IDD_MEMORY                  0x3822
#define IDD_SCREEN                  0x3823
#define IDD_FONT                    0x3824
#define IDD_ADVFONT                 0x3825
#define IDD_MISC                    0x3826

// cd recording page
#define IDC_RECORD_FIRST                0x3830
#define IDC_RECORD_ICON                 (IDC_RECORD_FIRST+0x00)
#define IDC_RECORD_ENABLE               (IDC_RECORD_FIRST+0x01)
#define IDC_RECORD_IMAGELOC             (IDC_RECORD_FIRST+0x02)
#define IDC_RECORD_WRITESPEED           (IDC_RECORD_FIRST+0x03)
#define IDC_RECORD_TEXTIMAGE            (IDC_RECORD_FIRST+0x04)
#define IDC_RECORD_TEXTWRITE            (IDC_RECORD_FIRST+0x05)
#define IDC_RECORD_EJECT                (IDC_RECORD_FIRST+0x06)

// disk general page
#define IDC_DRV_FIRST                   0x3840
#define IDC_DRV_ICON                    (IDC_DRV_FIRST+0x00)
#define IDC_DRV_LABEL                   (IDC_DRV_FIRST+0x01)
#define IDC_DRV_TYPE                    (IDC_DRV_FIRST+0x02)
#define IDC_DRV_USEDCOLOR               (IDC_DRV_FIRST+0x03)
#define IDC_DRV_FREECOLOR               (IDC_DRV_FIRST+0x04)
#define IDC_DRV_USEDMB                  (IDC_DRV_FIRST+0x05)
#define IDC_DRV_USEDBYTES               (IDC_DRV_FIRST+0x06)
#define IDC_DRV_FREEBYTES               (IDC_DRV_FIRST+0x07)
#define IDC_DRV_FREEMB                  (IDC_DRV_FIRST+0x08)
#define IDC_DRV_TOTBYTES                (IDC_DRV_FIRST+0x09)
#define IDC_DRV_TOTMB                   (IDC_DRV_FIRST+0x0a)
#define IDC_DRV_PIE                     (IDC_DRV_FIRST+0x0b)
#define IDC_DRV_LETTER                  (IDC_DRV_FIRST+0x0c)
#define IDC_DRV_TOTSEP                  (IDC_DRV_FIRST+0x0d)
#define IDC_DRV_TYPE_TXT                (IDC_DRV_FIRST+0x0e)
#define IDC_DRV_TOTBYTES_TXT            (IDC_DRV_FIRST+0x0f)
#define IDC_DRV_USEDBYTES_TXT           (IDC_DRV_FIRST+0x10)
#define IDC_DRV_FREEBYTES_TXT           (IDC_DRV_FIRST+0x11)

//These ids are used in the mounted drive general page for the
//new controls not defined in the general drive page
#define IDC_DRV_LOCATION                (IDC_DRV_FIRST+0x16)
#define IDC_DRV_TARGET                  (IDC_DRV_FIRST+0x17)
#define IDC_DRV_CREATED                 (IDC_DRV_FIRST+0x18)
#define IDC_DRV_PROPERTIES              (IDC_DRV_FIRST+0x19)
#define IDC_DRV_FS_TXT                  (IDC_DRV_FIRST+0x1a)
#define IDC_DRV_FS                      (IDC_DRV_FIRST+0x1b)
#define IDC_DRV_CLEANUP                 (IDC_DRV_FIRST+0x1c)
#define IDC_DRV_TOTSEP2                 (IDC_DRV_FIRST+0x1d)

#define IDC_DISKTOOLS_FIRST             0x3850
#define IDC_DISKTOOLS_CHKNOW            (IDC_DISKTOOLS_FIRST+0x00)
#define IDC_DISKTOOLS_TRLIGHT           (IDC_DISKTOOLS_FIRST+0x01)
#define IDC_DISKTOOLS_BKPNOW            (IDC_DISKTOOLS_FIRST+0x02)
#define IDC_DISKTOOLS_CHKDAYS           (IDC_DISKTOOLS_FIRST+0x03)
#define IDC_DISKTOOLS_OPTNOW            (IDC_DISKTOOLS_FIRST+0x04)
#define IDC_DISKTOOLS_BKPDAYS           (IDC_DISKTOOLS_FIRST+0x05)
#define IDC_DISKTOOLS_OPTDAYS           (IDC_DISKTOOLS_FIRST+0x06)
#define IDC_DISKTOOLS_BKPTXT            (IDC_DISKTOOLS_FIRST+0x07)
#define IDC_DISKTOOLS_BKPICON           (IDC_DISKTOOLS_FIRST+0x08)

// The order of these is significant (see pifsub.c:EnableEnumProc),
// The range points are IDC_ICONBMP, IDC_PIF_STATIC and
// IDC_REALMODEDISABLE.  The "safe" range (no enable/disable funny
// stuff is IDC_PIF_STATIC to IDC_REALMODE_DISABLE
#define IDC_PIFPAGES_FIRST              0x3860
#define IDC_CONVMEMGRP                  (IDC_PIFPAGES_FIRST+0x00)
#define IDC_LOCALENVLBL                 (IDC_PIFPAGES_FIRST+0x01)
#define IDC_ENVMEM                      (IDC_PIFPAGES_FIRST+0x02)
#define IDC_CONVMEMLBL                  (IDC_PIFPAGES_FIRST+0x03)
#define IDC_LOWMEM                      (IDC_PIFPAGES_FIRST+0x04)
#define IDC_LOWLOCKED                   (IDC_PIFPAGES_FIRST+0x05)
#define IDC_LOCALUMBS                   (IDC_PIFPAGES_FIRST+0x06)
#define IDC_GLOBALPROTECT               (IDC_PIFPAGES_FIRST+0x07)
#define IDC_EXPMEMGRP                   (IDC_PIFPAGES_FIRST+0x08)
#define IDC_EXPMEMLBL                   (IDC_PIFPAGES_FIRST+0x09)
#define IDC_EMSMEM                      (IDC_PIFPAGES_FIRST+0x0A)
#define IDC_EXTMEMGRP                   (IDC_PIFPAGES_FIRST+0x0C)
#define IDC_EXTMEMLBL                   (IDC_PIFPAGES_FIRST+0x0D)
#define IDC_XMSMEM                      (IDC_PIFPAGES_FIRST+0x0E)
#define IDC_HMA                         (IDC_PIFPAGES_FIRST+0x10)
#define IDC_FGNDGRP                     (IDC_PIFPAGES_FIRST+0x11)
#define IDC_FGNDEXCLUSIVE               (IDC_PIFPAGES_FIRST+0x12)
#define IDC_FGNDSCRNSAVER               (IDC_PIFPAGES_FIRST+0x13)
#define IDC_BGNDGRP                     (IDC_PIFPAGES_FIRST+0x14)
#define IDC_BGNDSUSPEND                 (IDC_PIFPAGES_FIRST+0x15)
#define IDC_IDLEGRP                     (IDC_PIFPAGES_FIRST+0x16)
#define IDC_IDLELOWLBL                  (IDC_PIFPAGES_FIRST+0x17)
#define IDC_IDLEHIGHLBL                 (IDC_PIFPAGES_FIRST+0x18)
#define IDC_IDLESENSE                   (IDC_PIFPAGES_FIRST+0x19)
#define IDC_TERMGRP                     (IDC_PIFPAGES_FIRST+0x1A)
#define IDC_WARNTERMINATE               (IDC_PIFPAGES_FIRST+0x1B)
#define IDC_TERMINATE                   (IDC_PIFPAGES_FIRST+0x1C)
#define IDC_SCREENUSAGEGRP              (IDC_PIFPAGES_FIRST+0x1D)
#define IDC_WINDOWED                    (IDC_PIFPAGES_FIRST+0x1E)
#define IDC_FULLSCREEN                  (IDC_PIFPAGES_FIRST+0x1F)
#define IDC_AUTOCONVERTFS               (IDC_PIFPAGES_FIRST+0x20)
#define IDC_SCREENLINESLBL              (IDC_PIFPAGES_FIRST+0x21)
#define IDC_SCREENLINES                 (IDC_PIFPAGES_FIRST+0x22)
#define IDC_WINDOWUSAGEGRP              (IDC_PIFPAGES_FIRST+0x23)
#define IDC_TOOLBAR                     (IDC_PIFPAGES_FIRST+0x24)
#define IDC_WINRESTORE                  (IDC_PIFPAGES_FIRST+0x25)
#define IDC_SCREENPERFGRP               (IDC_PIFPAGES_FIRST+0x26)
#define IDC_TEXTEMULATE                 (IDC_PIFPAGES_FIRST+0x27)
#define IDC_DYNAMICVIDMEM               (IDC_PIFPAGES_FIRST+0x28)
#define IDC_FONTSIZELBL                 (IDC_PIFPAGES_FIRST+0x29)
#define IDC_FONTSIZE                    (IDC_PIFPAGES_FIRST+0x2A)
#define IDC_FONTGRP                     (IDC_PIFPAGES_FIRST+0x2B)
#define IDC_RASTERFONTS                 (IDC_PIFPAGES_FIRST+0x2C)
#define IDC_TTFONTS                     (IDC_PIFPAGES_FIRST+0x2D)
#define IDC_BOTHFONTS                   (IDC_PIFPAGES_FIRST+0x2E)
#define IDC_WNDPREVIEWLBL               (IDC_PIFPAGES_FIRST+0x2F)
#define IDC_FONTPREVIEWLBL              (IDC_PIFPAGES_FIRST+0x30)
#define IDC_WNDPREVIEW                  (IDC_PIFPAGES_FIRST+0x31)
#define IDC_FONTPREVIEW                 (IDC_PIFPAGES_FIRST+0x32)
#define IDC_Unused1064                  (IDC_PIFPAGES_FIRST+0x33)
#define IDC_Unused1065                  (IDC_PIFPAGES_FIRST+0x34)
#define IDC_Unused1066                  (IDC_PIFPAGES_FIRST+0x35)
#define IDC_Unused1067                  (IDC_PIFPAGES_FIRST+0x36)
#define IDC_Unused1068                  (IDC_PIFPAGES_FIRST+0x37)
#define IDC_MISCKBDGRP                  (IDC_PIFPAGES_FIRST+0x38)
#define IDC_ALTESC                      (IDC_PIFPAGES_FIRST+0x39)
#define IDC_ALTTAB                      (IDC_PIFPAGES_FIRST+0x3A)
#define IDC_CTRLESC                     (IDC_PIFPAGES_FIRST+0x3B)
#define IDC_PRTSC                       (IDC_PIFPAGES_FIRST+0x3C)
#define IDC_ALTPRTSC                    (IDC_PIFPAGES_FIRST+0x3D)
#define IDC_ALTSPACE                    (IDC_PIFPAGES_FIRST+0x3E)
#define IDC_ALTENTER                    (IDC_PIFPAGES_FIRST+0x3F)
#define IDC_MISCMOUSEGRP                (IDC_PIFPAGES_FIRST+0x40)
#define IDC_QUICKEDIT                   (IDC_PIFPAGES_FIRST+0x41)
#define IDC_EXCLMOUSE                   (IDC_PIFPAGES_FIRST+0x42)
#define IDC_MISCOTHERGRP                (IDC_PIFPAGES_FIRST+0x43)
#define IDC_FASTPASTE                   (IDC_PIFPAGES_FIRST+0x44)
#define IDC_INSTRUCTIONS                (IDC_PIFPAGES_FIRST+0x45)
#define IDC_NOEMS                       (IDC_PIFPAGES_FIRST+0x47)
#define IDC_NOEMSDETAILS                (IDC_PIFPAGES_FIRST+0x48)
#define IDC_DPMIMEMGRP                  (IDC_PIFPAGES_FIRST+0x49)
#define IDC_DPMIMEMLBL                  (IDC_PIFPAGES_FIRST+0x4A)
#define IDC_DPMIMEM                     (IDC_PIFPAGES_FIRST+0x4B)
#define IDC_ICONBMP                     (IDC_PIFPAGES_FIRST+0x4C)
#define IDC_HOTKEYLBL                   (IDC_PIFPAGES_FIRST+0x4D)
#define IDC_HOTKEY                      (IDC_PIFPAGES_FIRST+0x4E)
#define IDC_WINDOWSTATELBL              (IDC_PIFPAGES_FIRST+0x4F)
#define IDC_WINDOWSTATE                 (IDC_PIFPAGES_FIRST+0x50)
#define IDC_WINLIE                      (IDC_PIFPAGES_FIRST+0x51)
#define IDC_SUGGESTMSDOS                (IDC_PIFPAGES_FIRST+0x52)
#define IDC_PIF_STATIC                  (IDC_PIFPAGES_FIRST+0x53)
#define IDC_TITLE                       (IDC_PIFPAGES_FIRST+0x54)
#define IDC_CMDLINE                     (IDC_PIFPAGES_FIRST+0x55)
#define IDC_CMDLINELBL                  (IDC_PIFPAGES_FIRST+0x56)
#define IDC_WORKDIRLBL                  (IDC_PIFPAGES_FIRST+0x57)
#define IDC_WORKDIR                     (IDC_PIFPAGES_FIRST+0x58)
#define IDC_BATCHFILELBL                (IDC_PIFPAGES_FIRST+0x59)
#define IDC_BATCHFILE                   (IDC_PIFPAGES_FIRST+0x5A)
#define IDC_ADVPROG                     (IDC_PIFPAGES_FIRST+0x5B)
#define IDC_REALMODE                    (IDC_PIFPAGES_FIRST+0x5C)
#define IDC_OK                          (IDC_PIFPAGES_FIRST+0x5D)
#define IDC_PIFNAMELBL                  (IDC_PIFPAGES_FIRST+0x5E)
#define IDC_PIFNAME                     (IDC_PIFPAGES_FIRST+0x5F)
#define IDC_CHANGEICON                  (IDC_PIFPAGES_FIRST+0x60)
#define IDC_CANCEL                      (IDC_PIFPAGES_FIRST+0x61)
#define IDC_CLOSEONEXIT                 (IDC_PIFPAGES_FIRST+0x62)
#ifdef NEW_UNICODE
#define IDC_SCREENXBUFLBL               (IDC_PIFPAGES_FIRST+0x63)
#define IDC_SCREENXBUF                  (IDC_PIFPAGES_FIRST+0x64)
#define IDC_SCREENYBUFLBL               (IDC_PIFPAGES_FIRST+0x65)
#define IDC_SCREENYBUF                  (IDC_PIFPAGES_FIRST+0x66)
#define IDC_WINXSIZELBL                 (IDC_PIFPAGES_FIRST+0x67)
#define IDC_WINXSIZE                    (IDC_PIFPAGES_FIRST+0x68)
#define IDC_WINYSIZELBL                 (IDC_PIFPAGES_FIRST+0x69)
#define IDC_WINYSIZE                    (IDC_PIFPAGES_FIRST+0x6A)
#else
#define IDC_Unused38CD                  (IDC_PIFPAGES_FIRST+0x63)
#define IDC_Unused38CE                  (IDC_PIFPAGES_FIRST+0x64)
#define IDC_Unused38CF                  (IDC_PIFPAGES_FIRST+0x65)
#define IDC_Unused38D0                  (IDC_PIFPAGES_FIRST+0x66)
#define IDC_Unused38D1                  (IDC_PIFPAGES_FIRST+0x67)
#define IDC_Unused38D2                  (IDC_PIFPAGES_FIRST+0x68)
#define IDC_Unused38D3                  (IDC_PIFPAGES_FIRST+0x69)
#define IDC_Unused38D4                  (IDC_PIFPAGES_FIRST+0x6A)
#endif
#define IDC_REALMODEDISABLE             (IDC_PIFPAGES_FIRST+0x80)
#define IDC_CONFIGLBL                   (IDC_PIFPAGES_FIRST+0x81)
#define IDC_CONFIG                      (IDC_PIFPAGES_FIRST+0x82)
#define IDC_AUTOEXECLBL                 (IDC_PIFPAGES_FIRST+0x83)
#define IDC_AUTOEXEC                    (IDC_PIFPAGES_FIRST+0x84)
#define IDC_REALMODEWIZARD              (IDC_PIFPAGES_FIRST+0x86)
#define IDC_WARNMSDOS                   (IDC_PIFPAGES_FIRST+0x87)
#define IDC_CURCONFIG                   (IDC_PIFPAGES_FIRST+0x88)
#define IDC_CLEANCONFIG                 (IDC_PIFPAGES_FIRST+0x89)
#define IDC_DOS                         (IDC_PIFPAGES_FIRST+0x8A)
#define IDC_AUTOEXECNT                  (IDC_PIFPAGES_FIRST+0x8B)
#define IDC_CONFIGNT                    (IDC_PIFPAGES_FIRST+0x8C)
#define IDC_NTTIMER                     (IDC_PIFPAGES_FIRST+0x8D)

// cd burning wizard
#define IDC_BURNWIZ_FIRST               0x3950
#define IDC_BURNWIZ_DISCLABEL           (IDC_BURNWIZ_FIRST+0x00)
#define IDC_BURNWIZ_BURNAGAIN           (IDC_BURNWIZ_FIRST+0x01)
#define IDC_BURNWIZ_AUTOCLOSEWIZ        (IDC_BURNWIZ_FIRST+0x02)
#define IDC_BURNWIZ_BURNAUDIO           (IDC_BURNWIZ_FIRST+0x03)
#define IDC_BURNWIZ_BURNDATA            (IDC_BURNWIZ_FIRST+0x04)
#define IDC_BURNWIZ_TITLE               (IDC_BURNWIZ_FIRST+0x05)
#define IDC_BURNWIZ_EJECT               (IDC_BURNWIZ_FIRST+0x06)
#define IDC_BURNWIZ_CLEAR               (IDC_BURNWIZ_FIRST+0x07)
#define IDC_BURNWIZ_STATUSTEXT          (IDC_BURNWIZ_FIRST+0x08)
#define IDC_BURNWIZ_ESTTIME             (IDC_BURNWIZ_FIRST+0x09)
#define IDC_BURNWIZ_EXIT                (IDC_BURNWIZ_FIRST+0x0A)
#define IDC_BURNWIZ_PROGRESS            (IDC_BURNWIZ_FIRST+0x0B)
#define IDC_BURNWIZ_PLEASEINSERT        (IDC_BURNWIZ_FIRST+0x0C)
#define IDC_BURNWIZ_LOWERED             (IDC_BURNWIZ_FIRST+0x0D)
#define IDC_BURNWIZ_STATUSTEXT2         (IDC_BURNWIZ_FIRST+0x0E)
#define IDC_BURNWIZ_ATTRIB              (IDC_BURNWIZ_FIRST+0x0F)

//--------------------------------------------------------------------------
// For Defview options page
#define IDC_SHOWALL          0x3720
#define IDC_SHOWEXTENSIONS   0x3721

#define IDC_STATIC              -1

//--------------------------------------------------------------------------
//  for DLG_FSEARCH_xxx dialogs
#define IDC_NOSCOPEWARNING          1001
#define IDC_FILESPEC                1001
#define IDC_GREPTEXT                1002
#define IDC_NAMESPACE               1003
#define IDC_SEARCH_START            1004
#define IDC_SEARCH_STOP             1005
#define IDC_USE_DATE                1007
#define IDC_USE_TYPE                1008
#define IDC_USE_SIZE                1009
#define IDC_USE_ADVANCED            1010
#define IDC_WHICH_DATE              1011
#define IDC_USE_RECENT_MONTHS       1012
#define IDC_RECENT_MONTHS           1013
#define IDC_RECENT_MONTHS_SPIN      1014
#define IDC_USE_RECENT_DAYS         1015
#define IDC_RECENT_DAYS             1016
#define IDC_RECENT_DAYS_SPIN        1017
#define IDC_USE_DATE_RANGE          1018
#define IDC_DATERANGE_BEGIN         1019
#define IDC_DATERANGE_END           1020
#define IDC_FILE_TYPE               1021
#define IDC_WHICH_SIZE              1022
#define IDC_FILESIZE                1023
#define IDC_FILESIZE_SPIN           1024
#define IDC_USE_SUBFOLDERS          1025
#define IDC_USE_CASE                1026
#define IDC_USE_SLOW_FILES          1028
#define IDC_FSEARCH_CAPTION         1029
#define IDC_FSEARCH_ICON            1030
#define IDC_INDEX_SERVER            1031
#define IDC_SEARCHLINK_FILES        1032
#define IDC_SEARCHLINK_COMPUTERS    1033
#define IDC_SEARCHLINK_PRINTERS     1034
#define IDC_SEARCHLINK_PEOPLE       1035
#define IDC_SEARCHLINK_INTERNET     1036
#define IDC_PSEARCH_ICON            1037
#define IDC_PSEARCH_CAPTION         1039
#define IDC_PSEARCH_NAME            1040
#define IDC_PSEARCH_LOCATION        1041
#define IDC_PSEARCH_MODEL           1042
#define IDC_CSEARCH_ICON            1043
#define IDC_CSEARCH_CAPTION         1044
#define IDC_CSEARCH_NAME            1045
#define IDC_SEARCHLINK_OPTIONS      1046
#define IDC_SEARCHLINK_PREVIOUS     1047
#define IDC_SEARCHLINK_CAPTION      1048
#define IDC_GROUPBTN_OPTIONS        1049
#define IDC_FSEARCH_DIV1            1050
#define IDC_FSEARCH_DIV2            1051
#define IDC_FSEARCH_DIV3            1052
#define IDC_USE_SYSTEMDIRS          1053
#define IDC_SEARCH_HIDDEN           1054

//  for DLG_INDEXSERVER
#define IDC_CI_STATUS               1000
#define IDC_CI_PROMPT               1001
#define IDC_CI_HELP                 1002
#define IDC_ENABLE_CI               1003
#define IDC_BLOWOFF_CI              1004
#define IDC_CI_ADVANCED             1005

// for bitbucket prop pages
#define IDC_DISKSIZE            1000
#define IDC_BYTESIZE            1001
#define IDC_USEDSIZE            1002
#define IDC_DISKSIZEDATA        1003
#define IDC_BYTESIZEDATA        1004
#define IDC_USEDSIZEDATA        1005
#define IDC_NUKEONDELETE        1006
#define IDC_BBSIZE              1007
#define IDC_BBSIZETEXT          1008
#define IDC_INDEPENDENT         1009
#define IDC_GLOBAL              1010
#define IDC_TEXT                1011
#define IDC_CONFIRMDELETE       1012

// for cdburn eject confirmation
#define IDC_EJECT_ICON          1000
#define IDC_EJECT_BURN          1001
#define IDC_EJECT_DISCARD       1002

// unicpp\resource.h defines more IDs starting at 0x8500

// Autoplay Dialog
#define IDC_AP_TOPTEXT                  1000
#define IDC_AP_LIST                     1001
#define IDC_AP_LIST_ACTIONS             1002
#define IDC_AP_SEL_ICON                 1003
#define IDC_AP_SEL_TEXT                 1004

#define IDC_AP_DEFAULTHANDLER           1005
#define IDC_AP_PROMPTEACHTIME           1006
#define IDC_AP_NOACTION                 1007

#define IDC_AP_RESTOREDEFAULTS          1008

// Autoplay Mixed Content Dialog
// Two following must remain in this order and have consecutive values
#define IDC_AP_MXCT_TOPICON             1000
#define IDC_AP_MXCT_TOPTEXT             1001
#define IDC_AP_MXCT_TOPTEXT2            1002
#define IDC_AP_MXCT_LIST                1003
#define IDC_AP_MXCT_CHECKBOX            1004
#define IDC_AP_MXCT_CONTENTICON         1005
#define IDC_AP_MXCT_CONTENTTYPE         1006

// File Type dialogs
// Note: Don't duplicate IDS between these dialogs
// as code is in place to know which help file is
// used...
#define IDC_FT_PROP_LV_FILETYPES        1000
#define IDC_FT_PROP_NEW                 1001
#define IDC_FT_PROP_REMOVE              1002
#define IDC_FT_PROP_EDIT                1003
#define IDC_FT_PROP_DOCICON             1004
#define IDC_FT_PROP_DOCEXTRO_TXT        1005
#define IDC_FT_PROP_DOCEXTRO            1006
#define IDC_FT_PROP_OPENICON            1007
#define IDC_FT_PROP_CONTTYPERO_TXT      1011
#define IDC_FT_PROP_CONTTYPERO          1012
#define IDC_FT_PROP_COMBO               1013
#define IDC_FT_PROP_FINDEXT_TXT         1014
#define IDC_FT_PROP_TYPEOFFILE          1015
#define IDC_FT_PROP_MODIFY              1016

#define IDC_FT_PROP_OPENEXE_TXT         1017
#define IDC_FT_PROP_OPENEXE             IDC_FT_PROP_OPENEXE_TXT + 1
#define IDC_FT_PROP_CHANGEOPENSWITH     IDC_FT_PROP_OPENEXE_TXT + 2
#define IDC_FT_PROP_TYPEOFFILE_TXT      IDC_FT_PROP_OPENEXE_TXT + 3
#define IDC_FT_PROP_EDITTYPEOFFILE      IDC_FT_PROP_OPENEXE_TXT + 4
#define IDC_FT_PROP_GROUPBOX            IDC_FT_PROP_OPENEXE_TXT + 5

#define IDC_FT_EDIT_EXT_EDIT            1023
#define IDC_FT_EDIT_ADVANCED            1024
#define IDC_FT_EDIT_PID_COMBO           1025
#define IDC_FT_EDIT_PID_COMBO_TEXT      1026
#define IDC_FT_EDIT_EXT_EDIT_TEXT       1027

#define IDC_FT_PROP_ANIM                1028

#define IDS_FOLDEROPTIONS               1030

#define IDC_FT_EDIT_DOCICON             1100
#define IDC_FT_EDIT_CHANGEICON          1101
#define IDC_FT_EDIT_DESC                1103
#define IDC_FT_EDIT_EXTTEXT             1104
#define IDC_FT_EDIT_EXT                 1105
#define IDC_FT_EDIT_LV_CMDSTEXT         1106
#define IDC_FT_EDIT_LV_CMDS             1107
#define IDC_FT_EDIT_NEW                 1108
#define IDC_FT_EDIT_EDIT                1109
#define IDC_FT_EDIT_REMOVE              1110
#define IDC_FT_EDIT_DEFAULT             1111
#define IDC_FT_EDIT_SHOWEXT             1113
#define IDC_FT_EDIT_DESCTEXT            1114
#define IDC_FT_COMBO_CONTTYPETEXT       1115
#define IDC_FT_COMBO_CONTTYPE           1116
#define IDC_FT_COMBO_DEFEXTTEXT         1117
#define IDC_FT_COMBO_DEFEXT             1118
#define IDC_FT_EDIT_CONFIRM_OPEN        1119
#define IDC_FT_EDIT_BROWSEINPLACE       1120

#define IDC_FT_CMD_ACTION               1200
#define IDC_FT_CMD_EXETEXT              1201
#define IDC_FT_CMD_EXE                  1202
#define IDC_FT_CMD_BROWSE               1203
#define IDC_FT_CMD_DDEGROUP             1204
#define IDC_FT_CMD_USEDDE               1205
#define IDC_FT_CMD_DDEMSG               1206
#define IDC_FT_CMD_DDEAPPNOT            1207
#define IDC_FT_CMD_DDETOPIC             1208
#define IDC_FT_CMD_DDEAPP               1209


//--------------------------------------------------------------------------
// For control panels & printer folder:

// RC IDs

#define IDC_PRINTER_ICON        1000
#define IDC_PRINTER_NAME        1001
#define IDDC_PRINTTO            1002
#define IDDB_ADD_PORT           1003
#define IDDB_DEL_PORT           1004
#define IDDC_DRIVER             1005
#define IDDB_NEWDRIVER          1006
#define IDC_TIMEOUTSETTING      1007
#define IDC_TIMEOUT_NOTSELECTED 1008
#define IDC_TIMEOUT_TRANSRETRY  1009
#define IDDB_SPOOL              1010
#define IDDB_PORT               1011
#define IDDB_SETUP              1012
#define IDGS_TYPE               1013
#define IDGS_LOCATION           1014
#define IDGE_COMMENT            1015
#define IDDB_TESTPAGE           1017
#define IDDC_SEPARATOR          1018
#define IDDB_CHANGESEPARATOR    1019
#define IDGS_TYPE_TXT           1020
#define IDGS_LOCATION_TXT       1021
#define IDGE_COMMENT_TXT        1022
#define IDGE_WHERE_TXT          1023
#define IDDC_SEPARATOR_TXT      1024
#define IDD_ADDPORT_NETWORK     1025
#define IDD_ADDPORT_PORTMON     1026
#define IDD_ADDPORT_NETPATH     1027
#define IDD_ADDPORT_BROWSE      1028
#define IDD_ADDPORT_LB          1029
#define IDD_DELPORT_LB          1030
#define IDD_DELPORT_TEXT_1      1031
#define IDC_TIMEOUTTEXT_1       1032
#define IDC_TIMEOUTTEXT_2       1033
#define IDC_TIMEOUTTEXT_3       1034
#define IDC_TIMEOUTTEXT_4       1035
#define IDDB_CAPTURE_PORT       1036
#define IDDB_RELEASE_PORT       1037
#define IDD_ENABLE_BIDI         1038
#define IDD_DISABLE_BIDI        1039

// Control IDs
//#define ID_LISTVIEW           200
#define ID_SETUP                210

// Commands for top level menu
#define ID_PRINTER_NEW                 111

// Menu items in the view queue dialog
#define ID_PRINTER_START               120
// DFM_CMD_PROPERTIES is -5
#define ID_PRINTER_PROPERTIES          (ID_PRINTER_START-5)

#define ID_DOCUMENT_PAUSE              130
#define ID_DOCUMENT_RESUME             131
#define ID_DOCUMENT_DELETE             132

#define ID_VIEW_STATUSBAR              140
#define ID_VIEW_TOOLBAR                141
#define ID_VIEW_REFRESH                142

#define ID_HELP_CONTENTS               150
#define ID_HELP_ABOUT                  151

// Help string ID's for printer/control folder
#define IDS_MH_PRINTOBJ_OPEN            (IDS_MH_PRINTFIRST+ID_PRINTOBJ_OPEN)
#define IDS_MH_PRINTOBJ_RESUME          (IDS_MH_PRINTFIRST+ID_PRINTOBJ_RESUME)
#define IDS_MH_PRINTOBJ_PAUSE           (IDS_MH_PRINTFIRST+ID_PRINTOBJ_PAUSE)
#define IDS_MH_PRINTOBJ_PURGE           (IDS_MH_PRINTFIRST+ID_PRINTOBJ_PURGE)
#define IDS_MH_PRINTOBJ_SETDEFAULT      (IDS_MH_PRINTFIRST+ID_PRINTOBJ_SETDEFAULT)

// Resources for the WinNT Format & Chkdsk Dialogs

#define IDC_GROUPBOX_1                  0x1202

#define DLG_FORMATDISK                  0x7000

#define IDC_CAPCOMBO                    (DLG_FORMATDISK + 1)
#define IDC_QFCHECK                     (DLG_FORMATDISK + 2)
#define IDC_ECCHECK                     (DLG_FORMATDISK + 3)
#define IDC_BLOCKSIZE                   (DLG_FORMATDISK + 4)
#define IDC_FSCOMBO                     (DLG_FORMATDISK + 5)
#define IDC_FMTPROGRESS                 (DLG_FORMATDISK + 6)
#define IDC_VLABEL                      (DLG_FORMATDISK + 7)
#define IDC_ASCOMBO                     (DLG_FORMATDISK + 8)
#define IDC_BTCHECK                     (DLG_FORMATDISK + 9)

#define DLG_FORMATDISK_FIRSTCONTROL     (DLG_FORMATDISK + 1)
#define DLG_FORMATDISK_NUMCONTROLS      (9)

#define IDS_FORMATFAILED                (DLG_FORMATDISK + 10)
#define IDS_INCOMPATIBLEFS              (DLG_FORMATDISK + 11)
#define IDS_ACCESSDENIED                (DLG_FORMATDISK + 12)
#define IDS_WRITEPROTECTED              (DLG_FORMATDISK + 13)
#define IDS_CANTLOCK                    (DLG_FORMATDISK + 14)
#define IDS_CANTQUICKFORMAT             (DLG_FORMATDISK + 15)
#define IDS_IOERROR                     (DLG_FORMATDISK + 16)
#define IDS_BADLABEL                    (DLG_FORMATDISK + 17)
#define IDS_INCOMPATIBLEMEDIA           (DLG_FORMATDISK + 18)
#define IDS_FORMATCOMPLETE              (DLG_FORMATDISK + 19)
#define IDS_CANTCANCELFMT               (DLG_FORMATDISK + 20)
#define IDS_FORMATCANCELLED             (DLG_FORMATDISK + 21)
#define IDS_OKTOFORMAT                  (DLG_FORMATDISK + 22)
#define IDS_CANTENABLECOMP              (DLG_FORMATDISK + 23)
#define IDS_NEEDFORMAT                  (DLG_FORMATDISK + 24)

// these are required for uncode\format.c

// These must be in sequence
#define IDS_FMT_MEDIA0                  (DLG_FORMATDISK + 32)
#define IDS_FMT_MEDIA1                  (DLG_FORMATDISK + 33)
#define IDS_FMT_MEDIA2                  (DLG_FORMATDISK + 34)
#define IDS_FMT_MEDIA3                  (DLG_FORMATDISK + 35)
#define IDS_FMT_MEDIA4                  (DLG_FORMATDISK + 36)
#define IDS_FMT_MEDIA5                  (DLG_FORMATDISK + 37)
#define IDS_FMT_MEDIA6                  (DLG_FORMATDISK + 38)
#define IDS_FMT_MEDIA7                  (DLG_FORMATDISK + 39)
#define IDS_FMT_MEDIA8                  (DLG_FORMATDISK + 40)
#define IDS_FMT_MEDIA9                  (DLG_FORMATDISK + 41)
#define IDS_FMT_MEDIA10                 (DLG_FORMATDISK + 42)
#define IDS_FMT_MEDIA11                 (DLG_FORMATDISK + 43)
#define IDS_FMT_UNUSED                  (DLG_FORMATDISK + 44)
#define IDS_FMT_MEDIA13                 (DLG_FORMATDISK + 45)
#define IDS_FMT_MEDIA14                 (DLG_FORMATDISK + 46)
#define IDS_FMT_MEDIA15                 (DLG_FORMATDISK + 47)
#define IDS_FMT_MEDIA16                 (DLG_FORMATDISK + 48)
#define IDS_FMT_MEDIA17                 (DLG_FORMATDISK + 49)
#define IDS_FMT_MEDIA18                 (DLG_FORMATDISK + 50)
#define IDS_FMT_MEDIA19                 (DLG_FORMATDISK + 51)
#define IDS_FMT_MEDIA20                 (DLG_FORMATDISK + 52)
#define IDS_FMT_MEDIA21                 (DLG_FORMATDISK + 53)
#define IDS_FMT_MEDIA22                 (DLG_FORMATDISK + 54)

// Japanese specific device types. These also must be in sequence.
#define IDS_FMT_MEDIA_J0                (DLG_FORMATDISK + 80)
#define IDS_FMT_MEDIA_J1                (DLG_FORMATDISK + 81)
#define IDS_FMT_MEDIA_J2                (DLG_FORMATDISK + 82)
#define IDS_FMT_MEDIA_J3                (DLG_FORMATDISK + 83)
#define IDS_FMT_MEDIA_J4                (DLG_FORMATDISK + 84)
#define IDS_FMT_MEDIA_J5                (DLG_FORMATDISK + 85)
#define IDS_FMT_MEDIA_J6                (DLG_FORMATDISK + 86)
#define IDS_FMT_MEDIA_J7                (DLG_FORMATDISK + 87)
#define IDS_FMT_MEDIA_J8                (DLG_FORMATDISK + 88)
#define IDS_FMT_MEDIA_J9                (DLG_FORMATDISK + 89)
#define IDS_FMT_MEDIA_J10               (DLG_FORMATDISK + 90)
#define IDS_FMT_MEDIA_J11               (DLG_FORMATDISK + 91)
#define IDS_FMT_UNUSED_J                (DLG_FORMATDISK + 92)
#define IDS_FMT_MEDIA_J13               (DLG_FORMATDISK + 93)
#define IDS_FMT_MEDIA_J14               (DLG_FORMATDISK + 94)
#define IDS_FMT_MEDIA_J15               (DLG_FORMATDISK + 95)
#define IDS_FMT_MEDIA_J16               (DLG_FORMATDISK + 96)
#define IDS_FMT_MEDIA_J17               (DLG_FORMATDISK + 97)
#define IDS_FMT_MEDIA_J18               (DLG_FORMATDISK + 98)
#define IDS_FMT_MEDIA_J19               (DLG_FORMATDISK + 99)
#define IDS_FMT_MEDIA_J20               (DLG_FORMATDISK + 100)
#define IDS_FMT_MEDIA_J21               (DLG_FORMATDISK + 101)
#define IDS_FMT_MEDIA_J22               (DLG_FORMATDISK + 102)

#ifdef DBCS
// Following definitions were just re-defined,
// because some media types were added. See above IDS_FMT_MEDIA*.
#define IDS_FMT_ALLOC0                  (DLG_FORMATDISK + 60)
#define IDS_FMT_ALLOC1                  (DLG_FORMATDISK + 61)
#define IDS_FMT_ALLOC2                  (DLG_FORMATDISK + 62)
#define IDS_FMT_ALLOC3                  (DLG_FORMATDISK + 63)
#define IDS_FMT_ALLOC4                  (DLG_FORMATDISK + 64)

#define IDS_FMT_CAPUNKNOWN              (DLG_FORMATDISK + 65)
#define IDS_FMT_KB                      (DLG_FORMATDISK + 66)
#define IDS_FMT_MB                      (DLG_FORMATDISK + 67)
#define IDS_FMT_GB                      (DLG_FORMATDISK + 68)
#define IDS_FMT_FORMATTING              (DLG_FORMATDISK + 69)
#define IDS_FMT_FORMAT                  (DLG_FORMATDISK + 70)
#define IDS_FMT_CANCEL                  (DLG_FORMATDISK + 71)
#define IDS_FMT_CLOSE                   (DLG_FORMATDISK + 72)
#else // DBCS
#define IDS_FMT_ALLOC0                  (DLG_FORMATDISK + 60)
#define IDS_FMT_ALLOC1                  (DLG_FORMATDISK + 61)
#define IDS_FMT_ALLOC2                  (DLG_FORMATDISK + 62)
#define IDS_FMT_ALLOC3                  (DLG_FORMATDISK + 63)
#define IDS_FMT_ALLOC4                  (DLG_FORMATDISK + 64)

#define IDS_FMT_CAPUNKNOWN              (DLG_FORMATDISK + 65)
#define IDS_FMT_KB                      (DLG_FORMATDISK + 66)
#define IDS_FMT_MB                      (DLG_FORMATDISK + 67)
#define IDS_FMT_GB                      (DLG_FORMATDISK + 68)
#define IDS_FMT_FORMATTING              (DLG_FORMATDISK + 69)
#define IDS_FMT_FORMAT                  (DLG_FORMATDISK + 70)
#define IDS_FMT_CANCEL                  (DLG_FORMATDISK + 71)
#define IDS_FMT_CLOSE                   (DLG_FORMATDISK + 72)
#endif // DBCS

#define DLG_CHKDSK                      0x7080

#define IDC_FIXERRORS                   (DLG_CHKDSK + 1)
#define IDC_RECOVERY                    (DLG_CHKDSK + 2)
#define IDC_CHKDSKPROGRESS              (DLG_CHKDSK + 3)

#define IDS_CHKDSKCOMPLETE              (DLG_CHKDSK + 4)
#define IDS_CHKDSKFAILED                (DLG_CHKDSK + 5)
#define IDS_CHKDSKCANCELLED             (DLG_CHKDSK + 6)
#define IDS_CANTCANCELCHKDSK            (DLG_CHKDSK + 7)

#define IDC_PHASE                       (DLG_CHKDSK + 8)

#define IDS_CHKACCESSDENIED             (DLG_CHKDSK + 9)
#define IDS_CHKONREBOOT                 (DLG_CHKDSK + 10)

#define IDS_CHKINPROGRESS               (DLG_CHKDSK + 11)
#define IDS_CHKDISK                     (DLG_CHKDSK + 12)
#define IDS_CHKPHASE                    (DLG_CHKDSK + 13)

// Resources for common program groups/items
#define IDS_CSIDL_CSTARTMENU_L          0x7100
#define IDS_CSIDL_CSTARTMENU_S          0x7101
#define IDS_CSIDL_CPROGRAMS_L           0x7102
#define IDS_CSIDL_CPROGRAMS_S           0x7103
#define IDS_CSIDL_CSTARTUP_L            0x7104
#define IDS_CSIDL_CSTARTUP_S            0x7105
#define IDS_CSIDL_CDESKTOPDIRECTORY_L   0x7106
#define IDS_CSIDL_CDESKTOPDIRECTORY_S   0x7107
#define IDS_CSIDL_CFAVORITES_L          0x7108
#define IDS_CSIDL_CFAVORITES_S          0x7109
#define IDS_CSIDL_CAPPDATA_L            0x710a
#define IDS_CSIDL_CAPPDATA_S            0x710b

// strings for file/folder property sheet
#define IDS_READONLY                    0x7110
#define IDS_NOTREADONLY                 0x7111
#define IDS_HIDE                        0x7112
#define IDS_UNHIDE                      0x7113
#define IDS_ARCHIVE                     0x7114
#define IDS_UNARCHIVE                   0x7115
#define IDS_INDEX                       0x7116
#define IDS_DISABLEINDEX                0x7117
#define IDS_COMPRESS                    0x7118
#define IDS_UNCOMPRESS                  0x7119
#define IDS_ENCRYPT                     0x711a
#define IDS_DECRYPT                     0x711b

#define IDS_UNKNOWNAPPLICATION          0x711c
#define IDS_DESCRIPTION                 0x711d

#define IDS_APPLYINGATTRIBS             0x711e
#define IDS_CALCULATINGSIZE             0x711f
#define IDS_APPLYINGATTRIBSTO           0x7120
#define IDS_THISFOLDER                  0x7121
#define IDS_THESELECTEDITEMS            0x7122
#define IDS_OPENSWITH                   0x7123
#define IDS_SUPERHIDDENWARNING          0x7124
#define IDS_THISVOLUME                  0x7125

// shared documents
#define IDS_SHAREDMUSIC                 0x7143
#define IDS_SHAREDVIDEO                 0x7144
#define IDS_SHAREDPICTURES              0x7145

#define IDS_USERSPICTURES               0x7146
#define IDS_USERSMUSIC                  0x7147
#define IDS_USERSVIDEO                  0x7148
#define IDS_USERSDOCUMENTS              0x7149

#define IDS_SAMPLEPICTURES              0x714A
#define IDS_SAMPLEMUSIC                 0x714B

#define IDS_MYWEBDOCUMENTS              0x7150

#define IDS_NETCONNECTFAILED_TITLE      0x7200
#define IDS_NETCONNECTFAILED_MESSAGE    0x7201

// string for find computer stuff (used by netviewx.c)
#define IDS_FC_NAME                     0x7203

// string for find computer (from my net places context menu)
#define IDS_NETWORKROOT_FIND            0x7204

#define IDS_LINEBREAK_REMOVE            0x72A0
#define IDS_LINEBREAK_PRESERVE          0x72A1

//  Strings used in DLG_FSEARCH_xxx, DLG_PSEARCH and DLG_CSEARCH dialogs
#define IDS_FSEARCH_FIRST               0x7300
#define IDS_FSEARCH_CAPTION             (IDS_FSEARCH_FIRST+0)
#define IDS_FSEARCH_TBLABELS            (IDS_FSEARCH_FIRST+1)
#define IDS_FSEARCH_MODIFIED_DATE       (IDS_FSEARCH_FIRST+2)
#define IDS_FSEARCH_CREATION_DATE       (IDS_FSEARCH_FIRST+3)
#define IDS_FSEARCH_ACCESSED_DATE       (IDS_FSEARCH_FIRST+4)
#define IDS_FSEARCH_SIZE_EQUAL          (IDS_FSEARCH_FIRST+5)
#define IDS_FSEARCH_SIZE_GREATEREQUAL   (IDS_FSEARCH_FIRST+6)
#define IDS_FSEARCH_SIZE_LESSEREQUAL    (IDS_FSEARCH_FIRST+7)

#define IDS_FSEARCH_CI_READY            (IDS_FSEARCH_FIRST+12)  // CI status text
#define IDS_FSEARCH_CI_READY_LINK       (IDS_FSEARCH_FIRST+13)  // CI link caption
#define IDS_FSEARCH_CI_BUSY             (IDS_FSEARCH_FIRST+14)  // CI status text
#define IDS_FSEARCH_CI_BUSY_LINK        (IDS_FSEARCH_FIRST+15)  // CI link caption
#define IDS_FSEARCH_CI_DISABLED         (IDS_FSEARCH_FIRST+16)  // status text
#define IDS_FSEARCH_CI_DISABLED_LINK    (IDS_FSEARCH_FIRST+17)  // link caption
#define IDS_FSEARCH_CI_STATUSFMT        (IDS_FSEARCH_FIRST+18)  // CI status formatting template
#define IDS_FSEARCH_INVALIDFOLDER_FMT   (IDS_FSEARCH_FIRST+19)  // '%s' is an invalid folder name
#define IDS_FSEARCH_EMPTYFOLDER         (IDS_FSEARCH_FIRST+20)  // You must enter a valid folder name.
#define IDS_FSEARCH_CI_DISABLED_WARNING (IDS_FSEARCH_FIRST+21)  // Can't do the query; CI is disabled.
#define IDS_FSEARCH_SEARCHLINK_FILES    (IDS_FSEARCH_FIRST+22)
#define IDS_FSEARCH_SEARCHLINK_COMPUTERS (IDS_FSEARCH_FIRST+23)
#define IDS_FSEARCH_SEARCHLINK_PRINTERS (IDS_FSEARCH_FIRST+24)
#define IDS_FSEARCH_SEARCHLINK_PEOPLE   (IDS_FSEARCH_FIRST+25)
#define IDS_FSEARCH_SEARCHLINK_INTERNET (IDS_FSEARCH_FIRST+26)
#define IDS_FSEARCH_SEARCHLINK_OPTIONS  (IDS_FSEARCH_FIRST+27)
#define IDS_FSEARCH_SEARCHLINK_PREVIOUS (IDS_FSEARCH_FIRST+28)
#define IDS_FSEARCH_GROUPBTN_OPTIONS    (IDS_FSEARCH_FIRST+29)
#define IDS_FINDVIEWEMPTYINIT           (IDS_FSEARCH_FIRST+30)
#define IDS_FINDVIEWEMPTYBUSY           (IDS_FSEARCH_FIRST+31)
#define IDS_FSEARCH_NEWINFOTIP          (IDS_FSEARCH_FIRST+32)
#define IDS_FSEARCH_HELPINFOTIP         (IDS_FSEARCH_FIRST+33)
#define IDS_CSEARCH_NEWINFOTIP          (IDS_FSEARCH_FIRST+34)
#define IDS_CSEARCH_HELPINFOTIP         (IDS_FSEARCH_FIRST+35)
#define IDS_FSEARCH_BANDCAPTION         (IDS_FSEARCH_FIRST+36)
#define IDS_FSEARCH_BANDWIDTH           (IDS_FSEARCH_FIRST+37)
#define IDS_DOCFIND_CONSTRAINT          (IDS_FSEARCH_FIRST+38)
#define IDS_DOCFIND_SCOPEERROR          (IDS_FSEARCH_FIRST+39)
#define IDS_DOCFIND_PATHNOTFOUND        (IDS_FSEARCH_FIRST+41)
#define IDS_FSEARCH_CI_ENABLED          (IDS_FSEARCH_FIRST+42)  // status text
#define IDS_FSEARCH_CI_ENABLED_LINK     (IDS_FSEARCH_FIRST+43)  // link caption
#define IDS_FSEARCH_STARTSTOPWIDTH      (IDS_FSEARCH_FIRST+44)  // width, in DBU, of start, stop buttons.
#define IDS_DOCFIND_CI_NOT_CASE_SEN     (IDS_FSEARCH_FIRST+45)  // ci is not case sensitive

#define IDS_LINKWINDOW_DEFAULTACTION    0x73FE
#define IDS_GROUPBTN_DEFAULTACTION      0x73FF

#define IDS_DD_FIRST                    0x7400
#define IDS_DD_COPY                     (IDS_DD_FIRST + DDIDM_COPY)
#define IDS_DD_MOVE                     (IDS_DD_FIRST + DDIDM_MOVE)
#define IDS_DD_LINK                     (IDS_DD_FIRST + DDIDM_LINK)
#define IDS_DD_SCRAP_COPY               (IDS_DD_FIRST + DDIDM_SCRAP_COPY)
#define IDS_DD_SCRAP_MOVE               (IDS_DD_FIRST + DDIDM_SCRAP_MOVE)
#define IDS_DD_DOCLINK                  (IDS_DD_FIRST + DDIDM_DOCLINK)
#define IDS_DD_CONTENTS_COPY            (IDS_DD_FIRST + DDIDM_CONTENTS_COPY)
#define IDS_DD_CONTENTS_MOVE            (IDS_DD_FIRST + DDIDM_CONTENTS_MOVE)
#define IDS_DD_SYNCCOPY                 (IDS_DD_FIRST + DDIDM_SYNCCOPY)
#define IDS_DD_SYNCCOPYTYPE             (IDS_DD_FIRST + DDIDM_SYNCCOPYTYPE)
#define IDS_DD_CONTENTS_LINK            (IDS_DD_FIRST + DDIDM_CONTENTS_LINK)
#define IDS_DD_CONTENTS_DESKCOMP        (IDS_DD_FIRST + DDIDM_CONTENTS_DESKCOMP)
#define IDS_DD_CONTENTS_DESKIMG         (IDS_DD_FIRST + DDIDM_CONTENTS_DESKIMG)
#define IDS_DD_OBJECT_COPY              (IDS_DD_FIRST + DDIDM_OBJECT_COPY)
#define IDS_DD_OBJECT_MOVE              (IDS_DD_FIRST + DDIDM_OBJECT_MOVE)
#define IDS_DD_CONTENTS_DESKURL         (IDS_DD_FIRST + DDIDM_CONTENTS_DESKURL)

// Strings for openwith dialog
#define IDS_OPENWITH_RECOMMENDED        0x7500
#define IDS_OPENWITH_OTHERS             0x7501

// strings for folder customization tab
#define IDS_CUSTOMIZE_DOCUMENTS         0x7520
#define IDS_CUSTOMIZE_PICTURES          0x7521
#define IDS_CUSTOMIZE_PHOTOALBUM        0x7522
#define IDS_CUSTOMIZE_MUSIC             0x7523
#define IDS_CUSTOMIZE_MUSICARTIST       0x7524
#define IDS_CUSTOMIZE_MUSICALBUM        0x7525
#define IDS_CUSTOMIZE_VIDEOS            0x7526
#define IDS_CUSTOMIZE_VIDEOALBUM        0x7527
#define IDS_CUSTOMIZE_BOOKS             0x7528
#define IDS_CUSTOMIZE                   0x7529
#define IDS_CUSTOMIZE_GENERATING        0x752A
#define IDS_CUSTOMIZE_USELEGACYHTT      0x752B
#define IDS_CUSTOMIZE_TURNONWEBVIEW     0x752C

// IDS_ strings defined in unicpp\resource.h use range 0x7600-0x76FF

// Strings for StartMenu.Settings.TaskbarAndStartMenu.Advanced options
#define IDS_ADV_STARTMENU_StartMenuSettings     30464 // 0x7700
#define IDS_ADV_STARTMENU_StartMenuIntelli      30465
#define IDS_ADV_STARTMENU_StartMenuFavorites    30466
#define IDS_ADV_STARTMENU_StartMenuLogoff       30467
#define IDS_ADV_STARTMENU_CascadeControlPanel   30468
#define IDS_ADV_STARTMENU_CascadeMyDocuments    30469
#define IDS_ADV_STARTMENU_CascadePrinters       30470
#define IDS_ADV_STARTMENU_StartMenuScrollPrograms 30471
#define IDS_ADV_STARTMENU_CascadeMyPictures     30472
#define IDS_ADV_STARTMENU_CascadeNetConnect     30473
#define IDS_ADV_STARTMENU_StartMenuRun          30474
#define IDS_ADV_STARTMENU_StartMenuChange       30475
#define IDS_ADV_STARTMENU_StartMenuAdminTools   30476 // 0x770C
#define IDS_ADV_STARTMENU_StartMenuSmallIcons   30477 // 0x770D
#define IDS_ADV_STARTMENU_StartPanelATBoth      30478
#define IDS_ADV_STARTMENU_StartPanelATMenu      30479
#define IDS_ADV_STARTMENU_StartPanelShowMyComp  30480 
#define IDS_ADV_STARTMENU_StartPanelShowNetPlaces 30481
#define IDS_ADV_STARTMENU_StartPanelShowNetConn 30482
#define IDS_ADV_STARTMENU_StartPanelShowRun     30483
#define IDS_ADV_STARTMENU_StartPanelFavorites   30484
#define IDS_ADV_STARTMENU_StartPanelShowMyDocs  30485
#define IDS_ADV_STARTMENU_StartPanelShowMyPics  30486  
#define IDS_ADV_STARTMENU_StartPanelShowMyMusic 30487
#define IDS_ADV_STARTMENU_StartPanelShowControlPanel 30488
#define IDS_ADV_STARTMENU_StartPanelShowHelp    30489
#define IDS_ADV_STARTMENU_StartPanelOpen        30490
#define IDS_ADV_STARTMENU_StartPanelMenu        30491    
#define IDS_ADV_STARTMENU_StartPanelHide        30492 // 0x771C
#define IDS_ADV_STARTMENU_StartPanelShowPrinters 30493 // 0x771D
#define IDS_ADV_STARTMENU_StartPanelNetConOpen  30494
#define IDS_ADV_STARTMENU_StartPanelNetConMenu  30495
#define IDS_ADV_STARTMENU_StartPanelShowSearch  30496

// Strings for Folder.Options.Advanced options
#define IDS_ADV_FOLDER_SHOWCONTROLPANEL         30497
#define IDS_ADV_FOLDER_FileFolder               30498
#define IDS_ADV_FOLDER_HiddenFiles              30499
#define IDS_ADV_FOLDER_ShowAll                  30500
#define IDS_ADV_FOLDER_NoHidden                 30501
#define IDS_ADV_FOLDER_ShowInfoTip              30502
#define IDS_ADV_FOLDER_HideFileExt              30503
#define IDS_ADV_FOLDER_DESC_ShowFullPath        30504
#define IDS_ADV_FOLDER_ShowFullPathAddress      30505
#define IDS_ADV_FOLDER_ClassicViewState         30506
#define IDS_ADV_FOLDER_DesktopProcess           30507
#define IDS_ADV_FOLDER_SuperHidden              30508
#define IDS_ADV_FOLDER_NetCrawl                 30509
#define IDS_ADV_FOLDER_WebViewBarricade         30510
#define IDS_ADV_FOLDER_FriendlyTree             30511
#define IDS_ADV_FOLDER_ShowCompColor            30512 // 0x7730
#define IDS_ADV_FOLDER_PersistBrowsers          30513
#define IDS_ADV_FOLDER_FolderSizeTip            30514

#define IDS_ADV_STARTMENU_StartPanelAdminTools  30515
#define IDS_ADV_STARTMENU_StartPanelOEMLink     30516
#define IDS_ADV_FOLDER_ThumbnailCache           30517
#define IDS_ADV_FOLDER_SimpleSharing            30518

#define IDS_SEARCH_RESULTS                      30520
#define IDS_SEARCH_RESULTS_COMPTUER             30521
//#define unused                                30522
//#define unused                                30523
//#define unused                                30524

#define IDS_VFX_TaskbarAnimations               30530
#define IDS_VFX_CursorShadow                    30531
#define IDS_VFX_DropShadow                      30532
#define IDS_VFX_DragFullWindows                 30533
#define IDS_VFX_AnimateMinMax                   30534
#define IDS_VFX_FontSmoothing                   30535
#define IDS_VFX_MenuAnimation                   30536
#define IDS_VFX_WebView                         30537
#define IDS_VFX_Themes                          30538
#define IDS_VFX_ComboBoxAnimation               30539
#define IDS_VFX_ListviewAlphaSelect             30540
#define IDS_VFX_ListviewShadowText              30541
//#define unused                                30542
#define IDS_VFX_ListviewFolderwatermarks        30543
#define IDS_VFX_ListBoxSmoothScrolling          30544

#define IDS_VFX_SelectionFade                   30546
#define IDS_VFX_TooltipAnimation                30547
//#define unused                                30548
//#define unused                                30549
#define IDS_VFX_TaskbarFade                     30550

//
//  These are the default pin list in ServerAdminUI mode
//
#define IDS_MSFT_SRVPIN_0                       31168
#define IDS_MSFT_SRVPIN_1                       31169
#define IDS_MSFT_SRVPIN_2                       31170
#define IDS_MSFT_SRVPIN_3                       31171

// Web View sizing string.  This allows the task area to be sized larger
// by 0 to 30%

#define IDS_SIZE_INCREASE_PERCENTAGE            31227

// Web View default action strings

#define IDS_EXPANDO_DEFAULT_ACTION_COLLAPSE     31228
#define IDS_EXPANDO_DEFAULT_ACTION_EXPAND       31229

// Web View Task strings

#define IDS_HEADER_MYCOMPUTER           0x7a00
#define IDS_HEADER_FILEFOLDER           0x7a01
#define IDS_HEADER_FILEFOLDER_TT        0x7a02
#define IDS_HEADER_ITEMFOLDER           0x7a03
#define IDS_TASK_CURFOLDER_NEWFOLDER    0x7A04
#define IDS_TASK_CURFOLDER_NEWFOLDER_TT 0x7A05
//#define IDS_TASK_CURFOLDER_COPY         0x7A06
#define IDS_TASK_CURFOLDER_COPY_TT      0x7A07
//#define IDS_TASK_CURFOLDER_PUBLISH      0x7A08
#define IDS_TASK_CURFOLDER_PUBLISH_TT   0x7A09
#define IDS_TASK_RENAME_FILE            0x7A0a
#define IDS_TASK_RENAME_FILE_TT         0x7A0b
#define IDS_TASK_MOVE_FILE              0x7A0c
#define IDS_TASK_MOVE_TT                0x7A0d
#define IDS_TASK_COPY_FILE              0x7A0e
#define IDS_TASK_COPY_TT                0x7A0f
#define IDS_TASK_PUBLISH_FILE           0x7A10
#define IDS_TASK_PUBLISH_TT             0x7A11
#define IDS_TASK_PRINT_FILE             0x7A12
#define IDS_TASK_PRINT_TT               0x7A13
#define IDS_TASK_DELETE_FILE            0x7A14
#define IDS_TASK_DELETE_TT              0x7A15
#define IDS_TASK_RENAME_FOLDER          0x7A16
#define IDS_TASK_MOVE_FOLDER            0x7A18
#define IDS_TASK_COPY_FOLDER            0x7A1a
#define IDS_TASK_PUBLISH_FOLDER         0x7A1c
#define IDS_TASK_DELETE_FOLDER          0x7A1e
#define IDS_TASK_MOVE_ITEMS             0x7A20
#define IDS_TASK_COPY_ITEMS             0x7A22
#define IDS_TASK_PUBLISH_ITEMS          0x7A24
#define IDS_TASK_DELETE_ITEMS           0x7A26
#define IDS_HEADER_OTHER_PLACES         0x7A28
#define IDS_HEADER_OTHER_PLACES_TT      0x7A29
#define IDS_HEADER_DETAILS              0x7A2a
#define IDS_HEADER_DETAILS_TT           0x7A2b
#define IDS_HEADER_MUSIC                0x7A2c
#define IDS_HEADER_MUSIC_TT             0x7A2d
#define IDS_TASK_PLAYALL                0x7A2e
#define IDS_TASK_PLAY                   0x7A2f
#define IDS_TASK_PLAY_TT                0x7A30
#define IDS_TASK_SHOPFORMUSICONLINE     0x7A31
#define IDS_TASK_SHOPFORMUSICONLINE_TT  0x7A32
#define IDS_HEADER_PICTURES             0x7A33
#define IDS_HEADER_PICTURES_TT          0x7A34
#define IDS_TASK_GETFROMCAMERA          0x7A35
#define IDS_TASK_GETFROMCAMERA_TT       0x7A36
#define IDS_TASK_SLIDESHOW              0x7A37
#define IDS_TASK_SLIDESHOW_TT           0x7A38
#define IDS_TASK_SETASWALLPAPER         0x7A39
#define IDS_TASK_SETASWALLPAPER_TT      0x7A3a
#define IDS_HEADER_MYCOMPUTER_TT        0x7A3b
#define IDS_TASK_SEARCHFORFILES         0x7A3c
#define IDS_TASK_SEARCHFORFILES_TT      0x7A3d
#define IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES    0x7A3e
#define IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES_TT 0x7A3f

// Web wizard host strings - really shouldn't have been here but went in while the above and below went in. oops
#define IDS_WEBDLG_TITLE                0x7A40
#define IDS_WEBDLG_SUBTITLE             0x7A41
#define IDS_WEBDLG_ERRTITLE             0x7A42
#define IDS_WEBDLG_ERRSUBTITLE          0x7A43

// Web View Task Strings
#define IDS_TASK_CHANGESETTINGS         0x7A50
#define IDS_TASK_ORDERPRINTS            0x7A51
#define IDS_TASK_ORDERPRINTS_TT         0x7A52
#define IDS_TASK_PRINT_PICTURES         0x7A53
#define IDS_TASK_PRINT_PICTURES_TT      0x7A54
#define IDS_HEADER_DEFVIEW_BLOCKADE     0x7A55
#define IDS_HEADER_DEFVIEW_BLOCKADE_TT  0x7A56
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE     0x7A57
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE_TT  0x7A58
#define IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE     0x7A59
#define IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE_TT  0x7A5a
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER    0x7A5b
#define IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER_TT 0x7A5c
#define IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER    0x7A5d
#define IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER_TT 0x7A5e
#define IDS_TASK_ARP                    0x7A5f
#define IDS_TASK_ARP_TT                 0x7A60
#define IDS_HEADER_BITBUCKET            0x7A61
#define IDS_HEADER_BITBUCKET_TT         0x7A62
#define IDS_TASK_EMPTYRECYCLEBIN        0x7A63
#define IDS_TASK_EMPTYRECYCLEBIN_TT     0x7A64
#define IDS_TASK_RESTORE_ALL            0x7A65
#define IDS_TASK_RESTORE_ITEM           0x7A66
#define IDS_TASK_RESTORE_ITEMS          0x7A67
#define IDS_TASK_RESTORE_TT             0x7A68
#define IDS_HEADER_BRIEFCASE            0x7A69
#define IDS_HEADER_BRIEFCASE_TT         0x7A6a
#define IDS_TASK_UPDATE_ALL             0x7A6b
#define IDS_TASK_UPDATE_ITEM            0x7A6c
#define IDS_TASK_UPDATE_ITEMS           0x7A6d
#define IDS_TASK_UPDATE_ITEM_TT         0x7A6e
#define IDS_HEADER_MYNETPLACES          0x7A6f
#define IDS_HEADER_MYNETPLACES_TT       0x7A70
#define IDS_TASK_VIEWNETCONNECTIONS     0x7A71
#define IDS_TASK_VIEWNETCONNECTIONS_TT  0x7A72
#define IDS_TASK_ADDNETWORKPLACE        0x7A73
#define IDS_TASK_ADDNETWORKPLACE_TT     0x7A74
#define IDS_TASK_HOMENETWORKWIZARD      0x7A75
#define IDS_TASK_HOMENETWORKWIZARD_TT   0x7A76
#define IDS_TASK_COMPUTERSNEARME        0x7A77
#define IDS_TASK_COPYTOCD               0x7A78
#define IDS_HEADER_CDBURN               0x7A79
#define IDS_HEADER_CDBURN_TT            0x7A7a
#define IDS_TASK_BURNCD                 0x7A7b
#define IDS_TASK_BURNCD_TT              0x7A7c
#define IDS_TASK_CLEARBURNAREA          0x7A7d
#define IDS_TASK_CLEARBURNAREA_TT       0x7A7e
#define IDS_TASK_ERASECDFILES           0x7A7f
#define IDS_TASK_ERASECDFILES_TT        0x7A80
#define IDS_TASK_CHANGESETTINGS_TT      0x7A81
#define IDS_TASK_EMAIL_ITEMS            0x7A82
#define IDS_COLONSEPERATED              0x7A83
#define IDS_NSELECTED                   0x7A84
#define IDS_TOTALFILESIZE               0x7A85
#define IDS_HEADER_SEARCH               0x7A86
#define IDS_HEADER_FIND_TT              0x7A87
#define IDS_TASK_OPENCONTAININGFOLDER   0x7A88
#define IDS_TASK_OPENCONTAININGFOLDER_TT 0x7A89
#define IDS_TASK_EMAIL_FILE             0x7A8a
#define IDS_TASK_EMAIL_TT               0x7A8b
#define IDS_TASK_COPYTOAUDIOCD          0x7A8c
#define IDS_TASK_COPYTOAUDIOCD_TT       0x7A8d
#define IDS_TASK_SHARE_FOLDER           0x7A8e
#define IDS_TASK_SHARE_TT               0x7A8f
#define IDS_TASK_EJECTDISK_TT           0x7A90
#define IDS_TASK_COMPUTERSNEARME_TT     0x7A91
#define IDS_TASK_COPYTOAUDIOCDALL       0x7A92
#define IDS_TASK_COPYTOCDALL            0x7A93
#define IDS_TASK_EMAIL_FOLDER           0x7A94
// unused                               0x7A95
#define IDS_TASK_EJECTDISK              0x7A96
#define IDS_TASK_COPYTOCD_TT            0x7A97
#define IDS_TASK_RENAME_ITEM            0x7A98
#define IDS_TASK_MOVE_ITEM              0x7A99
#define IDS_TASK_COPY_ITEM              0x7A9A
#define IDS_TASK_DELETE_ITEM            0x7A9B
#define IDS_TASK_RENAME_ITEM_TT         0x7A9C
#define IDS_HEADER_ITEMFOLDER_TT        0x7A9D
#define IDS_TASK_PRINT_PICTURE          0x7A9E
#define IDS_TASK_PRINT_PICTURE_FOLDER   0x7A9F
#define IDS_HEADER_COMMONDOCUMENTS      0x7AA0
#define IDS_HEADER_COMMONDOCUMENTS_TT   0x7AA1
#define IDS_TASK_COMMONDOCUMENTSHELP    0x7AA2
#define IDS_TASK_COMMONDOCUMENTSHELP_TT 0x7AA3
#define IDS_HEADER_VIDEOS               0x7AA4
#define IDS_HEADER_VIDEOS_TT            0x7AA5
#define IDS_TASK_PLAY_VIDEOS_TT         0x7AA6
#define IDS_TASK_SHOPFORPICTURESONLINE  0x7AA7
#define IDS_TASK_SHOPFORPICTURESONLINE_TT 0x7AA8
#define IDS_TASK_SEARCHDS               0x7AA9
#define IDS_TASK_SEARCHDS_TT            0x7AAA
#define IDS_TASK_SHADOW                 0x7AAB
#define IDS_TASK_SHADOW_TT              0x7AAC
#define IDS_TASK_SHADOW_PAGE            0x7AAD

// Put more Web View Task Strings above - please reserve space out to 0x7C00


// WebView static intro strings
#define IDS_INTRO_SHAREDDOCS            0x7C00
#define IDS_INTRO_SHAREDPICTURES        0x7C01
#define IDS_INTRO_SHAREDMUSIC           0x7C02
// unused                               0x7C03
// unused                               0x7C04
// unused                               0x7C05
// unused                               0x7C06
// unused                               0x7C07
#define IDS_INTRO_BARRICADED            0x7C08
// unused                               0x7C09
// unused                               0x7C0a
// unused                               0x7C0b
// unused                               0x7C0c
// unused                               0x7C0d
#define IDS_INTRO_STARTMENU             0x7C0e


#define IDS_CPCAT_ACCESSIBILITY_TITLE           0x7D00
#define IDS_CPCAT_ACCESSIBILITY_INFOTIP         0x7D01
#define IDS_CPCAT_ACCOUNTS_TITLE                0x7D02
#define IDS_CPCAT_ACCOUNTS_INFOTIP              0x7D03
#define IDS_CPCAT_APPEARANCE_TITLE              0x7D04
#define IDS_CPCAT_APPEARANCE_INFOTIP            0x7D05
#define IDS_CPCAT_ARP_TITLE                     0x7D06
#define IDS_CPCAT_ARP_INFOTIP                   0x7D07
#define IDS_CPCAT_HARDWARE_TITLE                0x7D08
#define IDS_CPCAT_HARDWARE_INFOTIP              0x7D09
#define IDS_CPCAT_NETWORK_TITLE                 0x7D0A
#define IDS_CPCAT_NETWORK_INFOTIP               0x7D0B
#define IDS_CPCAT_OTHERCPLS_TITLE               0x7D0C
#define IDS_CPCAT_OTHERCPLS_INFOTIP             0x7D0D
#define IDS_CPCAT_PERFMAINT_TITLE               0x7D0E
#define IDS_CPCAT_PERFMAINT_INFOTIP             0x7D0F
#define IDS_CPCAT_REGIONAL_TITLE                0x7D10
#define IDS_CPCAT_REGIONAL_INFOTIP              0x7D11
#define IDS_CPCAT_SOUNDS_TITLE                  0x7D12
#define IDS_CPCAT_SOUNDS_INFOTIP                0x7D13
#define IDS_CPCAT_ACCOUNTS_INFOTIP2             0x7D14

//
// Reserved for future categories   0x7D14 - 0x7D1F
//
#define IDS_CPTASK_SEEALSO_TITLE                0x7D20
#define IDS_CPTASK_SEEALSO_INFOTIP              0x7D21
#define IDS_CPTASK_TROUBLESHOOTER_TITLE         0x7D22
#define IDS_CPTASK_TROUBLESHOOTER_INFOTIP       0x7D23
#define IDS_CPTASK_HELPANDSUPPORT_TITLE         0x7D24
#define IDS_CPTASK_HELPANDSUPPORT_INFOTIP       0x7D25
#define IDS_CPTASK_WINDOWSUPDATE_TITLE          0x7D26
#define IDS_CPTASK_WINDOWSUPDATE_INFOTIP        0x7D27
#define IDS_CPTASK_THEME_TITLE                  0X7D28
#define IDS_CPTASK_THEME_INFOTIP                0X7D29
#define IDS_CPTASK_SCREENSAVER_TITLE            0X7D2A
#define IDS_CPTASK_SCREENSAVER_INFOTIP          0X7D2B
#define IDS_CPTASK_WALLPAPER_TITLE              0X7D2C
#define IDS_CPTASK_WALLPAPER_INFOTIP            0X7D2D
#define IDS_CPTASK_RESOLUTION_TITLE             0X7D2E
#define IDS_CPTASK_RESOLUTION_INFOTIP           0X7D2F
#define IDS_CPTASK_FONTS_TITLE                  0X7D30
#define IDS_CPTASK_FONTS_INFOTIP                0X7D31
#define IDS_CPTASK_FOLDEROPTIONS_TITLE          0X7D32
#define IDS_CPTASK_FOLDEROPTIONS_INFOTIP        0X7D33
#define IDS_CPTASK_MOUSEPOINTERS_TITLE          0X7D34
#define IDS_CPTASK_MOUSEPOINTERS_INFOTIP        0X7D35
#define IDS_CPTASK_HIGHCONTRAST_TITLE           0X7D36
#define IDS_CPTASK_HIGHCONTRAST_INFOTIP         0X7D37
#define IDS_CPTASK_ACCOUNTSPICT_TITLE           0X7D38
#define IDS_CPTASK_ACCOUNTSPICT_INFOTIP         0X7D39
#define IDS_CPTASK_TSDISPLAY_TITLE              0X7D3A
#define IDS_CPTASK_TSDISPLAY_INFOTIP            0X7D3B
#define IDS_CPTASK_ADDPRINTER_TITLE             0X7D3C
#define IDS_CPTASK_ADDPRINTER_INFOTIP           0X7D3D
#define IDS_CPTASK_HARDWAREWIZ_TITLE            0X7D3E
#define IDS_CPTASK_HARDWAREWIZ_INFOTIP          0X7D3F
#define IDS_CPTASK_DISPLAYCPL_TITLE             0X7D40
#define IDS_CPTASK_DISPLAYCPL_INFOTIP           0X7D41
#define IDS_CPTASK_SOUNDSCPL_TITLE              0X7D42
#define IDS_CPTASK_SOUNDSCPL_INFOTIP            0X7D43
#define IDS_CPTASK_POWERCPL_TITLE               0X7D44
#define IDS_CPTASK_POWERCPL_INFOTIP             0X7D45
#define IDS_CPTASK_MYCOMPUTER_INFOTIP           0X7D46
#define IDS_CPTASK_MYCOMPUTER_TITLE             0X7D47
#define IDS_CPTASK_TSHARDWARE_TITLE             0X7D48
#define IDS_CPTASK_TSHARDWARE_INFOTIP           0X7D49
#define IDS_CPTASK_NETCONNECTION_TITLE          0X7D4A
#define IDS_CPTASK_NETCONNECTION_INFOTIP        0X7D4B
#define IDS_CPTASK_VPNCONNECTION_TITLE          0X7D4C
#define IDS_CPTASK_VPNCONNECTION_INFOTIP        0X7D4D
#define IDS_CPTASK_HOMENETWORK_TITLE            0X7D4E
#define IDS_CPTASK_HOMENETWORK_INFOTIP          0X7D4F
#define IDS_CPTASK_MYNETPLACES_TITLE            0X7D50
#define IDS_CPTASK_MYNETPLACES_INFOTIP          0X7D51
#define IDS_CPTASK_PRINTERSHARDWARE_TITLE       0X7D52
#define IDS_CPTASK_PRINTERSHARDWARE_INFOTIP     0X7D53
#define IDS_CPTASK_REMOTEDESKTOP_TITLE          0X7D54
#define IDS_CPTASK_REMOTEDESKTOP_INFOTIP        0X7D55
#define IDS_CPTASK_TSINETEXPLORER_TITLE         0X7D56
#define IDS_CPTASK_TSINETEXPLORER_INFOTIP       0X7D57
#define IDS_CPTASK_TSNETWORK_TITLE              0X7D58
#define IDS_CPTASK_TSNETWORK_INFOTIP            0X7D59
#define IDS_CPTASK_TSHOMENETWORKING_TITLE       0X7D5A
#define IDS_CPTASK_CONTROLPANEL_INFOTIP         0x7D5B
#define IDS_CPTASK_TSMODEM_TITLE                0X7D5C
#define IDS_CPTASK_TSMODEM_INFOTIP              0X7D5D
#define IDS_CPTASK_TSFILESHARING_TITLE          0X7D5E
#define IDS_CPTASK_TSFILESHARING_INFOTIP        0X7D5F
#define IDS_CPTASK_TSNETDIAGS_TITLE             0X7D60
#define IDS_CPTASK_TSNETDIAGS_INFOTIP           0X7D61
#define IDS_CPTASK_SOUNDVOLUME_TITLE            0X7D62
#define IDS_CPTASK_SOUNDVOLUME_INFOTIP          0X7D63
#define IDS_CPTASK_SPEAKERSETTINGS_TITLE        0X7D64
#define IDS_CPTASK_SPEAKERSETTINGS_INFOTIP      0X7D65
#define IDS_CPTASK_SOUNDSCHEMES_TITLE           0X7D66
#define IDS_CPTASK_SOUNDSCHEMES_INFOTIP         0X7D67
#define IDS_CPTASK_SOUNDACCESSIBILITY_TITLE     0X7D68
#define IDS_CPTASK_SOUNDACCESSIBILITY_INFOTIP   0X7D69
#define IDS_CPTASK_TSSOUND_TITLE                0X7D6A
#define IDS_CPTASK_TSSOUND_INFOTIP              0X7D6B
#define IDS_CPTASK_TSDVD_TITLE                  0X7D6C
#define IDS_CPTASK_TSDVD_INFOTIP                0X7D6D
#define IDS_CPTASK_CLEANUPDISK_TITLE            0X7D6E
#define IDS_CPTASK_CLEANUPDISK_INFOTIP          0X7D6F
#define IDS_CPTASK_BACKUPDATA_TITLE             0X7D70
#define IDS_CPTASK_BACKUPDATA_INFOTIP           0X7D71
#define IDS_CPTASK_DEFRAG_TITLE                 0X7D72
#define IDS_CPTASK_DEFRAG_INFOTIP               0X7D73
// unused                                         0X7D74
// unused                                         0X7D75
#define IDS_CPTASK_TSSTARTUP_TITLE              0X7D76
#define IDS_CPTASK_TSSTARTUP_INFOTIP            0X7D77
#define IDS_CPTASK_DATETIME_TITLE               0X7D78
#define IDS_CPTASK_DATETIME_INFOTIP             0X7D79
#define IDS_CPTASK_CHANGEREGION_TITLE           0X7D7A
#define IDS_CPTASK_CHANGEREGION_INFOTIP         0X7D7B
#define IDS_CPTASK_LANGUAGE_TITLE               0X7D7C
#define IDS_CPTASK_LANGUAGE_INFOTIP             0X7D7D
#define IDS_CPTASK_SCHEDULEDTASKS_TITLE         0X7D7E
#define IDS_CPTASK_SCHEDULEDTASKS_INFOTIP       0X7D7F
#define IDS_CPTASK_TURNONHIGHCONTRAST_TITLE     0X7D80
#define IDS_CPTASK_TURNONHIGHCONTRAST_INFOTIP   0X7D81
#define IDS_CPTASK_ACCESSWIZARD_TITLE           0X7D82
#define IDS_CPTASK_ACCESSWIZARD_INFOTIP         0X7D83
#define IDS_CPTASK_MAGNIFIER_TITLE              0X7D84
#define IDS_CPTASK_MAGNIFIER_INFOTIP            0X7D85
// unused                                         0X7D86
// unused                                         0X7D87
#define IDS_CPTASK_ONSCREENKBD_TITLE            0X7D88
#define IDS_CPTASK_ONSCREENKBD_INFOTIP          0X7D89
#define IDS_CPTASK_TSPRINTING_TITLE             0X7D8C
#define IDS_CPTASK_TSPRINTING_INFOTIP           0X7D8D
#define IDS_CPTASK_TSSAFEMODE_TITLE             0X7D8E
#define IDS_CPTASK_TSSAFEMODE_INFOTIP           0X7D8F
#define IDS_CPTASK_TSSYSTEMSETUP_TITLE          0X7D90
#define IDS_CPTASK_TSSYSTEMSETUP_INFOTIP        0X7D91
#define IDS_CPTASK_TSFIX_TITLE                  0X7D92
#define IDS_CPTASK_TSFIX_INFOTIP                0X7D93
#define IDS_CPTASK_VISUALPERF_TITLE             0X7D94
#define IDS_CPTASK_VISUALPERF_INFOTIP           0X7D95
#define IDS_CPTASK_SWITCHTOCLASSICVIEW_TITLE    0x7D96
#define IDS_CPTASK_SWITCHTOCLASSICVIEW_INFOTIP  0x7D97
#define IDS_CPTASK_SWITCHTOCATEGORYVIEW_TITLE   0x7D98
#define IDS_CPTASK_SWITCHTOCATEGORYVIEW_INFOTIP 0x7D99
#define IDS_CPTASK_SYSTEMRESTORE_TITLE          0x7D9A
#define IDS_CPTASK_SYSTEMRESTORE_INFOTIP        0x7D9B
#define IDS_CPTASK_ACCOUNTSMANAGE_TITLE         0x7D9C
#define IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP       0x7D9D
#define IDS_CPTASK_ACCOUNTSMANAGE_INFOTIP2      0x7D9E
#define IDS_CPTASK_ACCOUNTSCREATE_TITLE         0x7D9F
#define IDS_CPTASK_ACCOUNTSCREATE_INFOTIP       0x7DA0
#define IDS_CPTASK_ACCOUNTSPICT2_TITLE          0x7DA1
#define IDS_CPTASK_ACCOUNTSPICT2_INFOTIP        0x7DA2
#define IDS_CPTASK_LEARNABOUT_TITLE             0x7DA3
#define IDS_CPTASK_LEARNABOUT_INFOTIP           0x7DA4
#define IDS_CPTASK_AUTOUPDATE_TITLE             0x7DA5
#define IDS_CPTASK_AUTOUPDATE_INFOTIP           0x7DA6
#define IDS_CPTASK_ADDPROGRAM_TITLE             0x7DA7
#define IDS_CPTASK_ADDPROGRAM_INFOTIP           0x7DA8
#define IDS_CPTASK_REMOVEPROGRAM_TITLE          0x7DA9
#define IDS_CPTASK_REMOVEPROGRAM_INFOTIP        0x7DAA
#define IDS_CPTASK_SOUNDVOLUMEADV_TITLE         0x7DAB
#define IDS_CPTASK_SOUNDVOLUMEADV_INFOTIP       0x7DAC
#define IDS_CPTASK_SYSTEMCPL_TITLE              0x7DAD
#define IDS_CPTASK_SYSTEMCPL_INFOTIP            0x7DAE
#define IDS_CPTASK_PHONEMODEMCPL_TITLE          0x7DAF
#define IDS_CPTASK_PHONEMODEMCPL_INFOTIP        0x7DB0
#define IDS_CPTASK_SYSTEMCPL_TITLE2             0x7DB1
#define IDS_CPTASK_SYSTEMCPL_INFOTIP2           0x7DB2
#define IDS_CPTASK_FILETYPES_TITLE              0x7DB3
#define IDS_CPTASK_FILETYPES_INFOTIP            0x7DB4
#define IDS_CPTASK_VIEWPRINTERS_TITLE           0x7DB5
#define IDS_CPTASK_VIEWPRINTERS_INFOTIP         0x7DB6
#define IDS_CPTASK_LEARNACCOUNTS_TITLE          0x7DB7
#define IDS_CPTASK_LEARNACCOUNTSTYPES_TITLE     0x7DB8
#define IDS_CPTASK_LEARNACCOUNTSCHANGENAME_TITLE 0x7DB9
#define IDS_CPTASK_LEARNACCOUNTSCREATE_TITLE    0x7DBA
#define IDS_CPTASK_LEARNSWITCHUSERS_TITLE       0x7DBB
#define IDS_CPTASK_32CPLS_TITLE                 0x7DBC
#define IDS_CPTASK_32CPLS_INFOTIP               0x7DBD

//
// This range through 0x7F01 reserved for Control Panel.
//
#define IDS_CP_PICKCATEGORY                     0x7F01
#define IDS_CP_PICKTASK                         0x7F02
#define IDS_CP_PICKICON                         0x7F03
#define IDS_CP_ORPICKICON                       0x7F04
#define IDS_CP_TASKBARANDSTARTMENU              0x7F05
#define IDS_CP_LINK_ACCDEFACTION                0x7F06
#define IDS_CP_CATEGORY_BARRICADE_TITLE         0x7F07
#define IDS_CP_CATEGORY_BARRICADE_MSG           0x7F08
#define IDS_CPL_ACCESSIBILITYOPTIONS            0x7F09
#define IDS_CPL_DATETIME                        0x7F0A
#define IDS_CPL_ADDREMOVEPROGRAMS               0x7F0B
#define IDS_CPL_REGIONALOPTIONS                 0x7F0C
#define IDS_CPL_MOUSE                           0x7F0D
#define IDS_CPL_INTERNETOPTIONS                 0x7F0E
#define IDS_CPL_PHONEANDMODEMOPTIONS            0x7F0F
#define IDS_CPL_POWEROPTIONS                    0x7F10
#define IDS_CPL_SCANNERSANDCAMERAS              0x7F11
#define IDS_CPL_SYSTEM                          0x7F12
#define IDS_CPL_SOUNDSANDAUDIO                  0x7F13
#define IDS_CPL_USERACCOUNTS                    0x7F14
#define IDS_CPL_ADDHARDWARE                     0x7F15
#define IDS_CPL_DISPLAY                         0x7F16


// Resources for NT Console property sheets in links

#define IDD_CONSOLE_SETTINGS            0x8000
#define IDC_CNSL_WINDOWED               (IDD_CONSOLE_SETTINGS +  1)
#define IDC_CNSL_FULLSCREEN             (IDD_CONSOLE_SETTINGS +  2)
#define IDC_CNSL_QUICKEDIT              (IDD_CONSOLE_SETTINGS +  3)
#define IDC_CNSL_INSERT                 (IDD_CONSOLE_SETTINGS +  4)
#define IDC_CNSL_CURSOR_SMALL           (IDD_CONSOLE_SETTINGS +  5)
#define IDC_CNSL_CURSOR_MEDIUM          (IDD_CONSOLE_SETTINGS +  6)
#define IDC_CNSL_CURSOR_LARGE           (IDD_CONSOLE_SETTINGS +  7)
#define IDC_CNSL_HISTORY_SIZE_LBL       (IDD_CONSOLE_SETTINGS +  8)
#define IDC_CNSL_HISTORY_SIZE           (IDD_CONSOLE_SETTINGS +  9)
#define IDC_CNSL_HISTORY_SIZESCROLL     (IDD_CONSOLE_SETTINGS + 10)
#define IDC_CNSL_HISTORY_NUM_LBL        (IDD_CONSOLE_SETTINGS + 11)
#define IDC_CNSL_HISTORY_NUM            (IDD_CONSOLE_SETTINGS + 12)
#define IDC_CNSL_HISTORY_NUMSCROLL      (IDD_CONSOLE_SETTINGS + 13)
#define IDC_CNSL_HISTORY_NODUP          (IDD_CONSOLE_SETTINGS + 14)
#define IDC_CNSL_LANGUAGELIST           (IDD_CONSOLE_SETTINGS + 15)

#define IDD_CONSOLE_FONTDLG             0x8025
#define IDC_CNSL_STATIC                 (IDD_CONSOLE_FONTDLG +  1)
#define IDC_CNSL_FACENAME               (IDD_CONSOLE_FONTDLG +  2)
#define IDC_CNSL_BOLDFONT               (IDD_CONSOLE_FONTDLG +  3)
#define IDC_CNSL_STATIC2                (IDD_CONSOLE_FONTDLG +  4)
#define IDC_CNSL_TEXTDIMENSIONS         (IDD_CONSOLE_FONTDLG +  5)
#define IDC_CNSL_PREVIEWLABEL           (IDD_CONSOLE_FONTDLG +  6)
#define IDC_CNSL_GROUP                  (IDD_CONSOLE_FONTDLG +  7)
#define IDC_CNSL_STATIC3                (IDD_CONSOLE_FONTDLG +  8)
#define IDC_CNSL_STATIC4                (IDD_CONSOLE_FONTDLG +  9)
#define IDC_CNSL_FONTWIDTH              (IDD_CONSOLE_FONTDLG + 10)
#define IDC_CNSL_FONTHEIGHT             (IDD_CONSOLE_FONTDLG + 11)
#define IDC_CNSL_FONTSIZE               (IDD_CONSOLE_FONTDLG + 12)
#define IDC_CNSL_POINTSLIST             (IDD_CONSOLE_FONTDLG + 13)
#define IDC_CNSL_PIXELSLIST             (IDD_CONSOLE_FONTDLG + 14)
#define IDC_CNSL_PREVIEWWINDOW          (IDD_CONSOLE_FONTDLG + 15)
#define IDC_CNSL_FONTWINDOW             (IDD_CONSOLE_FONTDLG + 16)

#define IDD_CONSOLE_SCRBUFSIZE          0x8050
#define IDC_CNSL_SCRBUF_WIDTH_LBL       (IDD_CONSOLE_SCRBUFSIZE +  1)
#define IDC_CNSL_SCRBUF_WIDTH           (IDD_CONSOLE_SCRBUFSIZE +  2)
#define IDC_CNSL_SCRBUF_WIDTHSCROLL     (IDD_CONSOLE_SCRBUFSIZE +  3)
#define IDC_CNSL_SCRBUF_HEIGHT_LBL      (IDD_CONSOLE_SCRBUFSIZE +  4)
#define IDC_CNSL_SCRBUF_HEIGHT          (IDD_CONSOLE_SCRBUFSIZE +  5)
#define IDC_CNSL_SCRBUF_HEIGHTSCROLL    (IDD_CONSOLE_SCRBUFSIZE +  6)
#define IDC_CNSL_WINDOW_WIDTH_LBL       (IDD_CONSOLE_SCRBUFSIZE +  7)
#define IDC_CNSL_WINDOW_WIDTH           (IDD_CONSOLE_SCRBUFSIZE +  8)
#define IDC_CNSL_WINDOW_WIDTHSCROLL     (IDD_CONSOLE_SCRBUFSIZE +  9)
#define IDC_CNSL_WINDOW_HEIGHT_LBL      (IDD_CONSOLE_SCRBUFSIZE + 10)
#define IDC_CNSL_WINDOW_HEIGHT          (IDD_CONSOLE_SCRBUFSIZE + 11)
#define IDC_CNSL_WINDOW_HEIGHTSCROLL    (IDD_CONSOLE_SCRBUFSIZE + 12)
#define IDC_CNSL_WINDOW_POSX_LBL        (IDD_CONSOLE_SCRBUFSIZE + 13)
#define IDC_CNSL_WINDOW_POSX            (IDD_CONSOLE_SCRBUFSIZE + 14)
#define IDC_CNSL_WINDOW_POSXSCROLL      (IDD_CONSOLE_SCRBUFSIZE + 15)
#define IDC_CNSL_WINDOW_POSY_LBL        (IDD_CONSOLE_SCRBUFSIZE + 16)
#define IDC_CNSL_WINDOW_POSY            (IDD_CONSOLE_SCRBUFSIZE + 17)
#define IDC_CNSL_WINDOW_POSYSCROLL      (IDD_CONSOLE_SCRBUFSIZE + 18)
#define IDC_CNSL_AUTO_POSITION          (IDD_CONSOLE_SCRBUFSIZE + 19)

#define IDD_CONSOLE_COLOR               0x8075
#define IDC_CNSL_COLOR_SCREEN_TEXT      (IDD_CONSOLE_COLOR +  1)
#define IDC_CNSL_COLOR_SCREEN_BKGND     (IDD_CONSOLE_COLOR +  2)
#define IDC_CNSL_COLOR_POPUP_TEXT       (IDD_CONSOLE_COLOR +  3)
#define IDC_CNSL_COLOR_POPUP_BKGND      (IDD_CONSOLE_COLOR +  4)
#define IDC_CNSL_COLOR_1                (IDD_CONSOLE_COLOR +  5)
#define IDC_CNSL_COLOR_2                (IDD_CONSOLE_COLOR +  6)
#define IDC_CNSL_COLOR_3                (IDD_CONSOLE_COLOR +  7)
#define IDC_CNSL_COLOR_4                (IDD_CONSOLE_COLOR +  8)
#define IDC_CNSL_COLOR_5                (IDD_CONSOLE_COLOR +  9)
#define IDC_CNSL_COLOR_6                (IDD_CONSOLE_COLOR + 10)
#define IDC_CNSL_COLOR_7                (IDD_CONSOLE_COLOR + 11)
#define IDC_CNSL_COLOR_8                (IDD_CONSOLE_COLOR + 12)
#define IDC_CNSL_COLOR_9                (IDD_CONSOLE_COLOR + 13)
#define IDC_CNSL_COLOR_10               (IDD_CONSOLE_COLOR + 14)
#define IDC_CNSL_COLOR_11               (IDD_CONSOLE_COLOR + 15)
#define IDC_CNSL_COLOR_12               (IDD_CONSOLE_COLOR + 16)
#define IDC_CNSL_COLOR_13               (IDD_CONSOLE_COLOR + 17)
#define IDC_CNSL_COLOR_14               (IDD_CONSOLE_COLOR + 18)
#define IDC_CNSL_COLOR_15               (IDD_CONSOLE_COLOR + 19)
#define IDC_CNSL_COLOR_16               (IDD_CONSOLE_COLOR + 20)
#define IDC_CNSL_COLOR_SCREEN_COLORS_LBL (IDD_CONSOLE_COLOR+ 21)
#define IDC_CNSL_COLOR_SCREEN_COLORS    (IDD_CONSOLE_COLOR + 22)
#define IDC_CNSL_COLOR_POPUP_COLORS_LBL (IDD_CONSOLE_COLOR + 23)
#define IDC_CNSL_COLOR_POPUP_COLORS     (IDD_CONSOLE_COLOR + 24)
#define IDC_CNSL_COLOR_RED_LBL          (IDD_CONSOLE_COLOR + 25)
#define IDC_CNSL_COLOR_RED              (IDD_CONSOLE_COLOR + 26)
#define IDC_CNSL_COLOR_REDSCROLL        (IDD_CONSOLE_COLOR + 27)
#define IDC_CNSL_COLOR_GREEN_LBL        (IDD_CONSOLE_COLOR + 28)
#define IDC_CNSL_COLOR_GREEN            (IDD_CONSOLE_COLOR + 29)
#define IDC_CNSL_COLOR_GREENSCROLL      (IDD_CONSOLE_COLOR + 30)
#define IDC_CNSL_COLOR_BLUE_LBL         (IDD_CONSOLE_COLOR + 31)
#define IDC_CNSL_COLOR_BLUE             (IDD_CONSOLE_COLOR + 32)
#define IDC_CNSL_COLOR_BLUESCROLL       (IDD_CONSOLE_COLOR + 33)

#define IDD_CONSOLE_ADVANCED            0x8100
#define IDC_CNSL_ADVANCED_LABEL         (IDD_CONSOLE_ADVANCED +  1)
#define IDC_CNSL_ADVANCED_LISTVIEW      (IDD_CONSOLE_ADVANCED +  2)

#define IDC_CNSL_GROUP0                 0x8120
#define IDC_CNSL_GROUP1                 (IDC_CNSL_GROUP0 +  1)
#define IDC_CNSL_GROUP2                 (IDC_CNSL_GROUP0 +  2)
#define IDC_CNSL_GROUP3                 (IDC_CNSL_GROUP0 +  3)
#define IDC_CNSL_GROUP4                 (IDC_CNSL_GROUP0 +  4)
#define IDC_CNSL_GROUP5                 (IDC_CNSL_GROUP0 +  5)


// string table constants
#define IDS_CNSL_NAME            0x8125
#define IDS_CNSL_INFO            (IDS_CNSL_NAME+1)
#define IDS_CNSL_TITLE           (IDS_CNSL_NAME+2)
#define IDS_CNSL_RASTERFONT      (IDS_CNSL_NAME+3)
#define IDS_CNSL_FONTSIZE        (IDS_CNSL_NAME+4)
#define IDS_CNSL_SELECTEDFONT    (IDS_CNSL_NAME+5)
#define IDS_CNSL_SAVE            (IDS_CNSL_NAME+6)

#define IDS_SHUTDOWN                0x8200
#define IDS_RESTART                 (IDS_SHUTDOWN+1)
#define IDS_NO_PERMISSION_SHUTDOWN  (IDS_SHUTDOWN+2)
#define IDS_NO_PERMISSION_RESTART   (IDS_SHUTDOWN+3)

#define IDS_UNMOUNT_TITLE           0x8225
#define IDS_UNMOUNT_TEXT            (IDS_UNMOUNT_TITLE+1)
#define IDS_EJECT_TITLE             (IDS_UNMOUNT_TITLE+2)
#define IDS_EJECT_TEXT              (IDS_UNMOUNT_TITLE+3)
#define IDS_RETRY_UNMOUNT_TITLE     (IDS_UNMOUNT_TITLE+4)
#define IDS_RETRY_UNMOUNT_TEXT      (IDS_UNMOUNT_TITLE+5)

// unicpp\resource.h defines more IDs starting at 0x8600
// menuband\mnbandid.h defines more IDs starting at 0x8700

// Active desktop prop page
#define IDC_TICKERINTERVAL              1000
#define IDC_TICKERINTERVAL_SPIN         1001
#define IDC_NEWSINTERVAL                1002
#define IDC_NEWSINTERVAL_SPIN           1003
#define IDC_NEWSUPDATE                  1004
#define IDC_NEWSUPDATE_SPIN             1005
#define IDC_TICKERDISPLAY               1006
#define IDC_NEWSDISPLAY                 1007
#define IDC_NEWSSPEED                   1008
#define IDC_TICKERSPEED                 1009

// for column arrange dialog
#define IDC_COL_LVALL         1001
#define IDC_COL_WIDTH_TEXT    1002
#define IDC_COL_UP            1003
#define IDC_COL_DOWN          1004
#define IDC_COL_WIDTH         1005
#define IDC_COL_SHOW          1006
#define IDC_COL_HIDE          1007

// Column Specifiers dialog
#define IDC_DESKTOPINI        1008

// Disk space error dialog
#define IDC_DISKERR_EXPLAIN             1000
#define IDC_DISKERR_LAUNCHCLEANUP       1001
#define IDC_DISKERR_STOPICON            1002

// Web wizard host page (DLG_WEBWIZARD)
#define IDC_PROGRESS                    1000
#define IDC_PROGTEXT1                   1001
#define IDC_PROGTEXT2                   1002


#define CLASS_NSC           TEXT(CLASS_NSCA)
#define CLASS_NSCA          "SHBrowseForFolder ShellNameSpace Control"


#define SMCM_STARTMENU_FIRST        0x5000
#define SMCM_OPEN                   (SMCM_STARTMENU_FIRST + 0)
#define SMCM_EXPLORE                (SMCM_STARTMENU_FIRST + 1)
#define SMCM_OPEN_ALLUSERS          (SMCM_STARTMENU_FIRST + 2)
#define SMCM_EXPLORE_ALLUSERS       (SMCM_STARTMENU_FIRST + 3)

#ifdef NEPTUNE
#define SMCM_SHUTDOWNMENU_FIRST     0x5100
#define SMCM_POWEROFF               (SMCM_SHUTDOWNMENU_FIRST + 0)
#define SMCM_RESTART                (SMCM_SHUTDOWNMENU_FIRST + 1)
#define SMCM_STANDBY                (SMCM_SHUTDOWNMENU_FIRST + 2)
#endif


// start menu's merged context menu ids
#define SMIDM_OPEN               0x0001
#define SMIDM_EXPLORE            0x0002
#define SMIDM_OPENCOMMON         0x0003
#define SMIDM_EXPLORECOMMON      0x0004
#define SMIDM_DELETE             0x0005
#define SMIDM_RENAME             0x0006
#define SMIDM_PROPERTIES         0x0007


// UI file ids

#define IDR_DUI_FOLDER                3
#define IDR_DUI_CPVIEW                4

///////////////////////////////

#include "unicpp\resource.h"

#endif // _IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\infotip.cpp ===
#include "shellprv.h"
#include "infotip.h"
#include "ids.h"
#include "prop.h"

#include <mluisupp.h>

// generic info tip object

class CInfoTip : public IQueryInfo, public ICustomizeInfoTip, public IParentAndItem
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IQueryInfo methods.
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // ICustomizeInfoTip
    STDMETHODIMP SetPrefixText(LPCWSTR pszPrefix);
    STDMETHODIMP SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

    CInfoTip(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszProp);

private:
    ~CInfoTip();
    HRESULT _GetInfoTipFromItem(WCHAR **ppszText);
    BOOL _InExtraList(const SHCOLUMNID *pscid);

    LONG _cRef;

    IShellFolder2 *_psf;
    LPITEMIDLIST _pidl;
    TCHAR _szText[INFOTIPSIZE];
    LPWSTR _pszPrefix;
    SHCOLUMNID _rgcols[8];
    UINT _cscid;
};

#define PROP_PREFIX         TEXT("prop:")
#define PROP_PREFIX_LEN     (ARRAYSIZE(PROP_PREFIX) - 1)

CInfoTip::CInfoTip(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszText) : _cRef(1)
{
    if (IS_INTRESOURCE(pszText))
        LoadString(HINST_THISDLL, LOWORD((UINT_PTR)pszText), _szText, ARRAYSIZE(_szText));
    else
        SHUnicodeToTChar(pszText, _szText, ARRAYSIZE(_szText));

    if (psf && pidl && (StrCmpNI(_szText, PROP_PREFIX, PROP_PREFIX_LEN) == 0))
    {
        // list of properties, we need the psf and pidl for this
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
        _pidl = ILClone(pidl);
    }
}

CInfoTip::~CInfoTip()
{
    if (_psf)
        _psf->Release();

    ILFree(_pidl);

    Str_SetPtr(&_pszPrefix, NULL);
}

HRESULT CInfoTip::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CInfoTip, IQueryInfo),
        QITABENT(CInfoTip, ICustomizeInfoTip),
        QITABENT(CInfoTip, IParentAndItem),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CInfoTip::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInfoTip::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

BOOL CInfoTip::_InExtraList(const SHCOLUMNID *pscid)
{
    for (UINT i = 0; i < _cscid; i++)
    {
        if (IsEqualSCID(*pscid, _rgcols[i]))
            return TRUE;
    }
    return FALSE;
}

void _AppendTipText(LPTSTR pszBuf, int cch, LPCTSTR pszCRLF, LPCTSTR pszPropName, LPCTSTR pszValue)
{
    TCHAR szFmt[64], szProp[128];

    if (*pszPropName)
        LoadString(g_hinst, IDS_EXCOL_TEMPLATE, szFmt, SIZECHARS(szFmt));
    else
        lstrcpyn(szFmt, TEXT("%s%s%s"), ARRAYSIZE(szFmt));

    wnsprintf(szProp, ARRAYSIZE(szProp), szFmt, pszCRLF, pszPropName, pszValue);
    StrCatBuff(pszBuf, szProp, cch);
}

HRESULT CInfoTip::_GetInfoTipFromItem(WCHAR **ppszText)
{
    TCHAR szTip[INFOTIPSIZE];
    szTip[0] = 0;

    IPropertyUI *ppui;
    if (SUCCEEDED(CoCreateInstance(CLSID_PropertiesUI, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPropertyUI, &ppui))))
    {
        LPCTSTR pszCRLF = TEXT("");

        if (_pszPrefix)
        {
            _AppendTipText(szTip, ARRAYSIZE(szTip), pszCRLF, TEXT(""), _pszPrefix);
            pszCRLF = TEXT("\n");
        }

        UINT iCurrentExtra = 0;

        BOOL bContinue = TRUE;
        ULONG chEaten = 0;  // gets incremented by ParsePropertyName
        while (bContinue)
        {
            SHCOLUMNID scid;
            BOOL bDoThisOne = TRUE;

            if (iCurrentExtra < _cscid)
            {
                scid = _rgcols[iCurrentExtra++];
            }
            else
            {
                if (SUCCEEDED(ppui->ParsePropertyName(_szText, &scid.fmtid, &scid.pid, &chEaten)))
                {
                    bDoThisOne = !_InExtraList(&scid);
                }
                else
                {
                    bContinue = FALSE;
                }
            }

            if (bContinue)
            {
                VARIANT v = {0};

                if (bDoThisOne && (S_OK == _psf->GetDetailsEx(_pidl, &scid, &v)))
                {
                    TCHAR szPropName[128], szValue[128];

                    ppui->FormatForDisplay(scid.fmtid, scid.pid, (PROPVARIANT*)&v, PUIFFDF_DEFAULT, szValue, ARRAYSIZE(szValue));

                    if (IsEqualSCID(scid, SCID_Comment))
                    {
                        szPropName[0] = 0;  // comment property, don't use the label 
                    }
                    else
                    {
                        ppui->GetDisplayName(scid.fmtid, scid.pid, PUIFNF_DEFAULT, szPropName, ARRAYSIZE(szPropName));
                    }

                    // if we got a value, and that value is different from
                    // the prefix of the current tip string we append it.
                    // that is don't dupe the same string where the comment == name

                    if (szValue[0] && (0 != StrCmpNI(szTip, szValue, lstrlen(szValue))))
                    {
                        _AppendTipText(szTip, ARRAYSIZE(szTip), pszCRLF, szPropName, szValue);
                        pszCRLF = TEXT("\n");
                    }

                    VariantClear(&v);
                }
            }
        }
        ppui->Release();
    }
    return SHStrDup(szTip, ppszText);
}

STDMETHODIMP CInfoTip::GetInfoTip(DWORD dwFlags, WCHAR** ppszText)
{
    HRESULT hr;
    if (_psf && _pidl)
        hr = _GetInfoTipFromItem(ppszText);
    else if (_szText[0])
        hr = SHStrDup(_szText, ppszText);
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return E_NOTIMPL;
}

// ICustomizeInfoTip

STDMETHODIMP CInfoTip::SetPrefixText(LPCWSTR pszPrefix)
{
    Str_SetPtr(&_pszPrefix, pszPrefix);
    return S_OK;
}

// IParentAndItem

STDMETHODIMP CInfoTip::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf, LPCITEMIDLIST pidl) 
{
    if (psf)
    {
        ATOMICRELEASE(_psf);
        psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
    }

    if (pidl)
        Pidl_Set(&_pidl, pidl);
    return _psf && _pidl ? S_OK : E_FAIL;
}

STDMETHODIMP CInfoTip::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CInfoTip::SetExtraProperties(const SHCOLUMNID *pscid, UINT cscid)
{
    _cscid = min(cscid, ARRAYSIZE(_rgcols));
    CopyMemory(_rgcols, pscid, _cscid * sizeof(_rgcols[0]));
    return S_OK;
}

// in:
//      pszText - description of info tip. either
//          1) a semi separated list of property names, "Author;Size" or "{fmtid},pid;{fmtid},pid"
//          2) if no semis the tip to create
//          MAKEINTRESOURCE(id) of a resource ID

STDAPI CreateInfoTipFromItem(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszText, REFIID riid, void **ppv)
{
    HRESULT hr;
    CInfoTip* pit = new CInfoTip(psf, pidl, pszText);
    if (pit)
    {
        hr = pit->QueryInterface(riid, ppv);
        pit->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}

STDAPI CreateInfoTipFromText(LPCTSTR pszText, REFIID riid, void **ppv)
{
    if (IS_INTRESOURCE(pszText))
        return CreateInfoTipFromItem(NULL, NULL, (LPCWSTR)pszText, riid, ppv);
    else
    {
        WCHAR szBuf[INFOTIPSIZE];
        SHTCharToUnicode(pszText, szBuf, ARRAYSIZE(szBuf));
        return CreateInfoTipFromItem(NULL, NULL, szBuf, riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\infotip.h ===
#ifndef _INFOTIP_H_
#define _INFOTIP_H_

STDAPI CreateInfoTipFromText(LPCTSTR pszText, REFIID riid, void **ppv);
STDAPI CreateInfoTipFromItem(IShellFolder2 *psf, LPCITEMIDLIST pidl, LPCWSTR pszProps, REFIID riid, void **ppv);

#endif // _INFOTIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\isproc.cpp ===
#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"
#include "ConfirmationUI.h"
#include "clsobj.h"
#include "datautil.h"
#include "prop.h" // SCID_SIZE

BOOL _HasAttributes(IShellItem *psi, SFGAOF flags);

STDAPI CStorageProcessor_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CComObject<CStorageProcessor> *pObj = NULL;
    HRESULT hr = CComObject<CStorageProcessor>::CreateInstance(&pObj);
    if (SUCCEEDED(hr))
    {
        // ATL creates the object with no refcount, but this initial QI will give it one
        hr = pObj->QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
            return hr;
        else
            delete pObj;
    }

    *ppv = NULL;
    return hr;
}

//
// These operators allow me to mix int64 types with the old LARGE_INTEGER
// unions without messing with the QuadPart members in the code.
//

inline ULONGLONG operator + (const ULARGE_INTEGER i, const ULARGE_INTEGER j)
{
    return i.QuadPart + j.QuadPart;
}

inline ULONGLONG operator + (const ULONGLONG i, const ULARGE_INTEGER j)
{
    return i + j.QuadPart;
}

//
// Progress dialog text while gathering stats.  Unordered, unsorted lookup table.
//

#define OPDETAIL(op, title, prep, action)   {op, title, prep, action}
const STGOP_DETAIL s_opdetail[] = 
{
    OPDETAIL(STGOP_STATS,               IDS_GATHERINGSTATS,  IDS_SCANNING,        SPACTION_CALCULATING),
    OPDETAIL(STGOP_COPY,                IDS_ACTIONTITLECOPY, IDS_PREPARINGTOCOPY, SPACTION_COPYING),
    OPDETAIL(STGOP_COPY_PREFERHARDLINK, IDS_ACTIONTITLECOPY, IDS_PREPARINGTOCOPY, SPACTION_COPYING),
    OPDETAIL(STGOP_MOVE,                IDS_ACTIONTITLEMOVE, IDS_PREPARINGTOMOVE, SPACTION_MOVING),
};

CStorageProcessor::CStorageProcessor() : _clsidLinkFactory(CLSID_ShellLink)
{
    ASSERT(!_msTicksLast);
    ASSERT(!_msStarted);
    ASSERT(!_pstatSrc);
    ASSERT(!_ptc);
}

CStorageProcessor::~CStorageProcessor()
{
    ATOMICRELEASE(_ptc);
    if (_dsaConfirmationResponses)
        _dsaConfirmationResponses.Destroy();
}

HRESULT CStorageProcessor::GetWindow(HWND * phwnd)
{
    return IUnknown_GetWindow(_spProgress, phwnd);
}

// Placeholder.  If I move to an exception model, I'll add errorinfo support,
// but not in the current implementation

STDMETHODIMP CStorageProcessor::InterfaceSupportsErrorInfo(REFIID riid)
{
    return S_FALSE;
}

// Allows clients to register an advise sink

STDMETHODIMP CStorageProcessor::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    for (DWORD i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (!_aspSinks[i])    
        {
            _aspSinks[i] = pAdvise; // smart pointer, do not call pAdvise->AddRef();
            *pdwCookie = i+1;    // Make it 1-based so 0 is not valid
            return S_OK;
        }
    }
    
    return E_OUTOFMEMORY;       // No empty slots
}

// Allows clients to register an advise sink

STDMETHODIMP CStorageProcessor::Unadvise(DWORD dwCookie)
{
    // Remember dwCookie == slot + 1, to be 1-based

    if (!dwCookie || dwCookie > ARRAYSIZE(_aspSinks))
        return E_INVALIDARG;
                    
    if (!_aspSinks[dwCookie-1])
        return E_INVALIDARG;

    _aspSinks[dwCookie-1] = NULL; // smart pointer, no need to release

    return S_OK;
}

// Computes stats (if requested) and launches the actual storage operation

STDMETHODIMP CStorageProcessor::Run(IEnumShellItems *penum, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions)
{
    if (!penum || !psiDest)
        return E_INVALIDARG;

    ITransferDest *ptdDest;
    HRESULT hr = _BindToHandlerWithMode(psiDest, STGX_MODE_READWRITE, IID_PPV_ARG(ITransferDest, &ptdDest));
    if (SUCCEEDED(hr))
    {
        hr = _Run(penum, psiDest, ptdDest, dwOperation, dwOptions);
        ptdDest->Release();
    }

    return hr;
}

// defined in copy.c
EXTERN_C void DisplayFileOperationError(HWND hParent, int idVerb, int wFunc, int nError, LPCTSTR szReason, LPCTSTR szPath, LPCTSTR szDest); 

STDMETHODIMP CStorageProcessor::_Run(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest, STGOP dwOperation, DWORD dwOptions)
{
    switch (dwOperation)
    {
    case STGOP_MOVE:
    case STGOP_COPY:
    case STGOP_STATS:
    case STGOP_REMOVE:
    case STGOP_COPY_PREFERHARDLINK:
        // parameter validation done in ::Run
        break;

        // not yet implemented
    case STGOP_RENAME:
    case STGOP_DIFF:
    case STGOP_SYNC:
        return E_NOTIMPL;

        // any other value is an invalid operation
    default:
        return E_INVALIDARG;
    }

    const STGOP_DETAIL *popd = NULL;
    for (int i=0; i < ARRAYSIZE(s_opdetail); i++)
    {
        if (s_opdetail[i].stgop == dwOperation)
        {
            popd = &s_opdetail[i];
            break;
        }
    }

    if (!_dsaConfirmationResponses)
    {
        // If we don't have a confirmation array yet, make one
        _dsaConfirmationResponses.Create(4);
    }
    else
    {
        // well, no one currently reuses the engine for multiple operations
        // but, move operation reenters the engine (for recursive move)
        // so we need to preserve the answers, so comment this out
        
        // If we do have one then it's got left over confirmations from the previous call
        // to run so we should delete all those.
        //_dsaConfirmationResponses.DeleteAllItems();
    }

    if (popd)
    {
        PreOperation(dwOperation, NULL, NULL);

        HRESULT hr = S_FALSE;
        
        if (IsFlagClear(dwOptions, STOPT_NOSTATS))
        {
            if (IsFlagClear(dwOptions, STOPT_NOPROGRESSUI))
                _StartProgressDialog(popd);

            if (_spProgress)
            {
                // Put the "Preparing to Whatever" text in the dialog
                WCHAR szText[MAX_PATH];
                LoadStringW(_Module.GetModuleInstance(), popd->idPrep, szText, ARRAYSIZE(szText));
                _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, szText, TRUE);
            }
            
            // Compute the stats we need
            _dwOperation = STGOP_STATS;
            _dwOptions   = STOPT_NOCONFIRMATIONS;
            HRESULT hrProgressBegin;
            if (_spProgress)
                hrProgressBegin = _spProgress->Begin(SPACTION_SEARCHING_FILES, SPBEGINF_MARQUEEPROGRESS);

            penum->Reset();
            hr = _WalkStorage(penum, psiDest, ptdDest);
            if (_spProgress && SUCCEEDED(hrProgressBegin))
            {
                _spProgress->End();
                // Remove the "Preparing to Whatever" text from the dialog
                _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, L"", FALSE);
            }
        }

        if (SUCCEEDED(hr))
        {
            _dwOperation = (STGOP) dwOperation;
            _dwOptions   = dwOptions;

            HRESULT hrProgressBegin;
            if (_spProgress)
                hrProgressBegin = _spProgress->Begin(popd->spa, SPBEGINF_AUTOTIME);

            penum->Reset();
            hr = _WalkStorage(penum, psiDest, ptdDest);
            if (_spProgress && SUCCEEDED(hrProgressBegin))
                _spProgress->End();
        }

        if (IsFlagClear(dwOptions, STOPT_NOSTATS) && _spProgress)
        {
            // this should only be called if we called the matching FlagClear-NOSTATS above.
            //  smartpointers NULL on .Release();
            _spProgress.Release();
            if (_spShellProgress)
            {
                _spShellProgress->Stop();
                _spShellProgress.Release();
            }
        }

        SHChangeNotifyHandleEvents();

        PostOperation(dwOperation, NULL, NULL, hr);

        return hr;
    }
    else
    {
        AssertMsg(0, TEXT("A valid operation is missing from the s_opdetail array, was a new operation added? (%d)"), dwOperation);
    }
    
    return E_INVALIDARG;
}

// Does a depth-first walk of the storage performing the requested
// operation.

HRESULT CStorageProcessor::_WalkStorage(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = S_FALSE;
    
    if (_ShouldWalk(psi))
    {
        IEnumShellItems *penum;
        hr = psi->BindToHandler(NULL, BHID_StorageEnum, IID_PPV_ARG(IEnumShellItems, &penum));
        if (SUCCEEDED(hr))
        {
            hr = _WalkStorage(penum, psiDest, ptdDest);
            penum->Release();
        }
    }
    return hr;
}

HRESULT CStorageProcessor::_WalkStorage(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest)
{
    DWORD dwCookie;
    if (ptdDest)
        ptdDest->Advise(static_cast<ITransferAdviseSink*>(this), &dwCookie);

    HRESULT hr;
    IShellItem *psi;
    while (S_OK == (hr = penum->Next(1, &psi, NULL)))
    {
        // skip anything we can't work with
        if (_HasAttributes(psi, SFGAO_STORAGE | SFGAO_STREAM))
        {    
            if (_spProgress)
            {
                // We don't show filenames while collecting stats
                if (_dwOperation != STGOP_STATS)
                {
                    LPWSTR pszName;
                    if (SUCCEEDED(psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName)))
                    {
                        _spProgress->UpdateText(SPTEXT_ACTIONDETAIL, pszName, TRUE);
                        CoTaskMemFree(pszName);
                    }
                }
            }

            if (_dwOperation != STGOP_STATS)
                _UpdateProgress(0, 0);

            DWORD dwFlagsExtra = 0;
            switch (_dwOperation)
            {
                case STGOP_STATS:
                    hr = _DoStats(psi);
                    break;

                case STGOP_COPY_PREFERHARDLINK:
                    dwFlagsExtra = STGX_MOVE_PREFERHARDLINK;
                    // fall through
                case STGOP_COPY:
                    hr = _DoCopy(psi, psiDest, ptdDest, dwFlagsExtra);
                    break;

                case STGOP_MOVE:
                    hr = _DoMove(psi, psiDest, ptdDest);
                    break;

                case STGOP_REMOVE:
                    hr = _DoRemove(psi, psiDest, ptdDest);
                    break;

                case STGOP_RENAME:
                case STGOP_DIFF:
                case STGOP_SYNC:
                    hr = E_NOTIMPL;
                    break;

                default:
                    hr = E_UNEXPECTED;
                    break;
            }

            if (S_OK != QueryContinue())
                hr = STRESPONSE_CANCEL;
        }
        else if (STGOP_COPY_PREFERHARDLINK == _dwOperation || STGOP_COPY == _dwOperation || STGOP_MOVE == _dwOperation)
        {
            CUSTOMCONFIRMATION cc = {sizeof(cc)};
            cc.dwButtons = CCB_OK;
            cc.dwFlags = CCF_SHOW_SOURCE_INFO | CCF_USE_DEFAULT_ICON;
            UINT idDesc = (STGOP_MOVE == _dwOperation ? IDS_NO_STORAGE_MOVE : IDS_NO_STORAGE_COPY);
            cc.pwszDescription = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idDesc);
            if (cc.pwszDescription)
            {
                UINT idTitle = (STGOP_MOVE == _dwOperation ? IDS_UNKNOWN_MOVE_TITLE : IDS_UNKNOWN_COPY_TITLE);
                cc.pwszTitle = ResourceCStrToStr(g_hinst, (LPCWSTR)(UINT_PTR)idTitle);
                if (cc.pwszTitle)
                {
                    ConfirmOperation(psi, NULL, GUID_NULL, &cc);
                    LocalFree(cc.pwszTitle);
                }
                LocalFree(cc.pwszDescription);
            }
        }

        psi->Release();
        
        if (FAILED(hr) && STRESPONSE_SKIP != hr)
            break;
    }
    
    // We'll always get to the "no more Streams" stage, so this is meaningless

    if (S_FALSE == hr)
        hr = S_OK;

    if (ptdDest)
        ptdDest->Unadvise(dwCookie);

    return hr;
}

HRESULT CStorageProcessor::_DoConfirmations(STGTRANSCONFIRMATION stc, CUSTOMCONFIRMATION *pcc, IShellItem *psiItem, IShellItem *psiDest)
{
    CONFIRMATIONRESPONSE crResponse = (CONFIRMATIONRESPONSE)E_FAIL;
    HRESULT hr = _GetDefaultResponse(stc, &crResponse);
    if (FAILED(hr))
    {
        // If we don't have a default answer, then call the confirmation UI, it will return the repsonse
        hr = S_OK;
        // should be able to supply the CLSID of an alternate implementation and we should CoCreate the object.
        if (!_ptc)
            hr = CTransferConfirmation_CreateInstance(NULL, IID_PPV_ARG(ITransferConfirmation, &_ptc));
        
        if (SUCCEEDED(hr))
        {
            BOOL bAll;
            CONFIRMOP cop;
            cop.dwOperation = _dwOperation;
            cop.stc = stc;
            cop.pcc = pcc;
            cop.cRemaining = _StreamsToDo() + _StoragesToDo();
            cop.psiItem = psiItem;
            cop.psiDest = psiDest;
            cop.pwszRenameTo = NULL;
            cop.punkSite = SAFECAST(this, IStorageProcessor*);

            hr = _ptc->Confirm(&cop, &crResponse, &bAll);
            if (SUCCEEDED(hr))
            {
                if (bAll)
                {
                    // if the confirmation UI says "do for all" then add hrResponse to the default response map.
                    STC_CR_PAIR scp(stc, crResponse);
                    _dsaConfirmationResponses.AppendItem(&scp);
                }
            }
            else
            {
                // TODO: What do we do if we fail to ask for confirmation?
            }
        }
    }

    // TODO: Get rid of CONFIRMATIONRESPONSE and make these the same
    if (SUCCEEDED(hr))
    {
        switch (crResponse)
        {
        case CONFRES_CONTINUE:
            hr = STRESPONSE_CONTINUE;
            break;

        case CONFRES_SKIP:   
            hr = STRESPONSE_SKIP;
            break;

        case CONFRES_RETRY:
            hr = STRESPONSE_RETRY;
            break;

        case CONFRES_RENAME:
            hr = STRESPONSE_RENAME;
            break;

        case CONFRES_CANCEL:
        case CONFRES_UNDO:
            hr = STRESPONSE_CANCEL;
            break;
        }   
    }

    return hr;    
}

HRESULT CStorageProcessor::_GetDefaultResponse(STGTRANSCONFIRMATION stc,  LPCONFIRMATIONRESPONSE pcrResponse)
{
    // Look in our map to see if there's already been a default response
    // set for this condition

    for (int i=0; i<_dsaConfirmationResponses.GetItemCount(); i++)
    {
        STC_CR_PAIR *pscp = _dsaConfirmationResponses.GetItemPtr(i);
        if (*pscp == stc)
        {
            *pcrResponse = pscp->cr;
            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}

HRESULT CStorageProcessor::_BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IBindCtx *pbc = NULL;
    if (grfMode)
        hr = BindCtx_CreateWithMode(grfMode, &pbc); // need to translate mode flags?
        
    if (SUCCEEDED(hr))
    {
        GUID bhid;

        if (IsEqualGUID(riid, IID_IStorage))
            bhid = BHID_Storage;
        else if (IsEqualGUID(riid, IID_IStream))
            bhid = BHID_Stream;
        else
            bhid = BHID_SFObject;

        hr = psi->BindToHandler(pbc, bhid, riid, ppv);
        if (FAILED(hr) && IsEqualGUID(riid, IID_ITransferDest))
            hr = CreateStg2StgExWrapper(psi, this, (ITransferDest **)ppv);

        if (pbc)
            pbc->Release();
    }

    return hr;
}

BOOL _HasAttributes(IShellItem *psi, SFGAOF flags)
{
    BOOL fReturn = FALSE;
    SFGAOF flagsOut;
    if (SUCCEEDED(psi->GetAttributes(flags, &flagsOut)) && (flags & flagsOut))
        fReturn = TRUE;

    return fReturn;
}

BOOL CStorageProcessor::_IsStream(IShellItem *psi)
{
    return _HasAttributes(psi, SFGAO_STREAM);
}

BOOL CStorageProcessor::_ShouldWalk(IShellItem *psi)
{
    return _HasAttributes(psi, SFGAO_STORAGE);
}

ULONGLONG CStorageProcessor::_GetSize(IShellItem *psi)
{
    ULONGLONG ullReturn = 0;

    // first, try to get size from the pidl, so we don't hit the disk
    IParentAndItem *ppai;
    HRESULT hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPITEMIDLIST pidlChild;
        hr = ppai->GetParentAndItem(NULL, &psf, &pidlChild);
        if (SUCCEEDED(hr))
        {
            IShellFolder2 *psf2;
            hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
            if (SUCCEEDED(hr))
            {
                hr = GetLongProperty(psf2, pidlChild, &SCID_SIZE, &ullReturn);
                psf2->Release();
            }
            psf->Release();
            ILFree(pidlChild);
        }
        ppai->Release();
    }

    // if it failed, try the stream
    if (FAILED(hr))
    {   
        //this should ask for IPropertySetStorage instead of stream...
        IStream *pstrm;
        if (SUCCEEDED(_BindToHandlerWithMode(psi, STGX_MODE_READ, IID_PPV_ARG(IStream, &pstrm))))
        {
            STATSTG stat;
            if (SUCCEEDED(pstrm->Stat(&stat, STATFLAG_NONAME)))
                ullReturn = stat.cbSize.QuadPart;

            pstrm->Release();
        }
    }

    return ullReturn;
}

HRESULT CStorageProcessor::_DoStats(IShellItem *psi)
{
    HRESULT hr = PreOperation(STGOP_STATS, psi, NULL);
    if (FAILED(hr))
        return hr;

    if (!_IsStream(psi))
    {
        _statsTodo.AddStorage();
        hr = _WalkStorage(psi, NULL, NULL);
    }
    else
    {
        _statsTodo.AddStream(_GetSize(psi));
    }

    PostOperation(STGOP_STATS, psi, NULL, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoCopy(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest, DWORD dwStgXFlags)
{
    HRESULT hr = PreOperation(STGOP_COPY, psi, psiDest);
    if (FAILED(hr))
        return hr;

    LPWSTR pszNewName;
    hr = AutoCreateName(psiDest, psi, &pszNewName);
    if (SUCCEEDED(hr))
    {
        do
        {
            hr = ptdDest->MoveElement(psi, pszNewName, STGX_MOVE_COPY | STGX_MOVE_NORECURSION | dwStgXFlags);
        } 
        while (STRESPONSE_RETRY == hr);

        if (SUCCEEDED(hr))
        {
            if (!_IsStream(psi))
            {
                _statsDone.AddStorage();

                // Open the source
                IShellItem *psiNewDest;
                hr = SHCreateShellItemFromParent(psiDest, pszNewName, &psiNewDest);
                if (SUCCEEDED(hr))
                {
                    ITransferDest *ptdNewDest;
                    hr = _BindToHandlerWithMode(psiNewDest, STGX_MODE_READWRITE, IID_PPV_ARG(ITransferDest, &ptdNewDest));
                    if (SUCCEEDED(hr))
                    {
                        // And copy everything underneath
                        hr = _WalkStorage(psi, psiNewDest, ptdNewDest);
                        ptdNewDest->Release();
                    }
                    psiNewDest->Release();
                }
            }
            else
            {
                _statsDone.AddStream(_GetSize(psi));
            }
        }
        CoTaskMemFree(pszNewName);
    }
    
    PostOperation(STGOP_COPY, psi, psiDest, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoMove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = PreOperation(STGOP_MOVE, psi, psiDest);
    if (FAILED(hr))
        return hr;

    LPWSTR pszNewName;
    hr = AutoCreateName(psiDest, psi, &pszNewName);
    if (SUCCEEDED(hr))
    {
        do 
        {
            hr = ptdDest->MoveElement(psi, pszNewName, STGX_MOVE_MOVE);
        } 
        while (STRESPONSE_RETRY == hr);

        if (SUCCEEDED(hr))
        {
            if (!_IsStream(psi))
            {
                _statsDone.AddStorage();
            }
            else
            {
                _statsDone.AddStream(_GetSize(psi));
            }
        }
        CoTaskMemFree(pszNewName);
    }

    PostOperation(STGOP_MOVE, psi, psiDest, hr);

    return hr;
}

HRESULT CStorageProcessor::_DoRemove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest)
{
    HRESULT hr = PreOperation(STGOP_REMOVE, psi, NULL);
    if (FAILED(hr))
        return hr;

    LPWSTR pszName;
    hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName);
    if (SUCCEEDED(hr))
    {
        BOOL fStorage = !_IsStream(psi);
        ULONGLONG ullSize;

        if (!fStorage)
            ullSize = _GetSize(psi);
        
        // try to delete the entire storage in one operation
        do 
        {
            hr = ptdDest->DestroyElement(pszName, 0);
        } 
        while (STRESPONSE_RETRY == hr);

        if (FAILED(hr) && STRESPONSE_SKIP != hr && fStorage)
        {
            // if we fail then walk down deleting the contents
            hr = _WalkStorage(psi, psiDest, ptdDest);
            if (SUCCEEDED(hr))
            {
                // see if we can delete the storage now that it's empty
                do 
                {
                    hr = ptdDest->DestroyElement(pszName, 0);
                } 
                while (STRESPONSE_RETRY == hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            if (fStorage)
            {
                _statsDone.AddStorage();
            }
            else
            {
                _statsDone.AddStream(ullSize);
            }
        }
        CoTaskMemFree(pszName);
    }

    PostOperation(STGOP_REMOVE, psi, NULL, hr);

    return hr;
}

// Recomputes the amount of estimated time remaining, and if progress
// is being displayed, updates the dialog as well

// TODO: This doesn't take into account any items that are skipped.  Skipped items
// will still be considered undone which means the operation will finish before the
// progress bar reaches the end.  To accurately remove the skipped items we would need
// to either:
// 1.) Walk a storage if it is skipped, counting the bytes
// 2.) Remember the counts in a tree when we first walked the storage
//
// Of these options I like #1 better since its simpler and #2 would waste memory to hold
// a bunch of information we can recalculate (we're already doing a sloooow operation anyway).

#define MINIMUM_UPDATE_INTERVAL         1000
#define HISTORICAL_POINT_WEIGHTING      50
#define TIME_BEFORE_SHOWING_ESTIMATE    5000

void CStorageProcessor::_UpdateProgress(ULONGLONG ullCurrentComplete, ULONGLONG ullCurrentTotal)
{
    // Ensure at least N ms has elapsed since last update
    DWORD msNow = GetTickCount();
    if ((msNow - _msTicksLast) >= MINIMUM_UPDATE_INTERVAL)
    {
        // Calc the estimated total cost to finish and work done so far

        ULONGLONG ullTotal = _statsTodo.Cost(_dwOperation, 0);
        if (ullTotal)
        {
            ULONGLONG cbExtra = ullCurrentTotal ? (_cbCurrentSize / ullCurrentTotal) * ullCurrentComplete : 0;
            ULONGLONG ullDone = _statsDone.Cost(_dwOperation, cbExtra);

            // Regardless of whether we update the text, update the status bar
            if (_spProgress)
                _spProgress->UpdateProgress(ullDone, ullTotal);

            for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
            {
                if (_aspSinks[i])
                {
                    HRESULT hr = _aspSinks[i]->OperationProgress(_dwOperation, NULL, NULL, ullTotal, ullDone);
                    if (FAILED(hr))
                        break;
                }
            }
        }
        _msTicksLast = msNow;
    }
}

DWORD CStorageProcessor::CStgStatistics::AddStream(ULONGLONG cbSize)
{
    _cbSize += cbSize;
    return ++_cStreams;
}

DWORD CStorageProcessor::CStgStatistics::AddStorage()
{
    return ++_cStorages;
}

// Computes the total time cost of performing the storage operation
// after the stats have been collected

#define COST_PER_DELETE     1
#define COST_PER_CREATE     1

ULONGLONG CStorageProcessor::CStgStatistics::Cost(DWORD op, ULONGLONG cbExtra) const
{
    ULONGLONG ullTotalCost = 0;

    // Copy and Move both need to create the target and move the bits
    if (op == STGOP_COPY || op == STGOP_MOVE || op == STGOP_COPY_PREFERHARDLINK)
    {   
        ullTotalCost += Bytes() + cbExtra;
        ullTotalCost += (Streams() + Storages()) * COST_PER_CREATE;
    }

    // Move and Remove need to delete the originals
    if (op == STGOP_MOVE || op == STGOP_REMOVE)
    {
        ullTotalCost += (Streams() + Storages()) * COST_PER_DELETE;
    }

    return ullTotalCost;
}

// Figures out what animation and title text should be displayed in
// the progress UI, and starts it

HRESULT CStorageProcessor::_StartProgressDialog(const STGOP_DETAIL *popd)
{
    HRESULT hr = S_OK;

    if (!_spProgress)
    {
        hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgressDialog, &_spShellProgress));
        if (SUCCEEDED(hr))
        {
            //
            // Map the requested action to the appropriate strings (like "Preparing to Copy")
            //
            ASSERT(popd);
        
            WCHAR szText[MAX_PATH];
            LoadStringW(_Module.GetModuleInstance(), popd->idTitle, szText, ARRAYSIZE(szText));

            hr = _spShellProgress->Initialize(SPINITF_MODAL, szText, NULL);
            if (SUCCEEDED(hr))
                hr = _spShellProgress->QueryInterface(IID_PPV_ARG(IActionProgress, &_spProgress));
        }
    }

    return hr;
}

HRESULT CStorageProcessor::SetProgress(IActionProgress *pspaProgress)
{
    HRESULT hr = E_FAIL;

    if (!_spProgress)
    {
        hr = E_INVALIDARG;
        if (pspaProgress)
        {
            _spProgress = pspaProgress;
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CStorageProcessor::SetLinkFactory(REFCLSID clsid)
{
    _clsidLinkFactory = clsid;
    return S_OK;
}

// Runs through the list of registered sinks and gives each of them a shot
// at cancelling or skipping this operation

STDMETHODIMP CStorageProcessor::PreOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
{
    if (psiItem)
    {
        _cbCurrentSize = _IsStream(psiItem) ? _GetSize(psiItem) : 0;
    }
    
    for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            HRESULT hr = _aspSinks[i]->PreOperation(op, psiItem, psiDest);
            if (FAILED(hr))
                return hr;
        }
    }

    return S_OK;
}

// Allow each of the sinks to confirm the operation if they'd like

STDMETHODIMP CStorageProcessor::ConfirmOperation(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
{
    // TODO: map the confirmation (stc) based on _dwOperation memeber varaible

    HRESULT hr = STRESPONSE_CONTINUE;
    for (int i = 0; i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            hr = _aspSinks[i]->ConfirmOperation(psiSource, psiDest, stc, pcc);
            if (FAILED(hr) || hr == STRESPONSE_RENAME)
                break;
        }
    }

    // Question:  How do we know if one of the above handlers displayed UI already?  If the
    // hr is anything other than STRESPONSE_CONTINUE then obviously the confirmation has been
    // handled already, but one of the handlers might have diplayed UI and then returned
    // STRESPONSE_CONTINUE as the users response.

    if (STRESPONSE_CONTINUE == hr)
    {
        // show default UI
        hr = _DoConfirmations(stc, pcc, psiSource, psiDest);
    }

    return hr;
}

// Apprise each of the sinks as to our current progress

STDMETHODIMP CStorageProcessor::OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete)
{
    HRESULT hr = S_OK;
    for (int i = 0; SUCCEEDED(hr) && i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
        {
            hr = _aspSinks[i]->OperationProgress(op, psiItem, psiDest, ullTotal, ullComplete);
        }
    }

    // CShellItem2TransferDest::_CopyStreamBits doesn't call QueryContinue to check if it should stop copying
    // so we do it here (because it does call OperationProgress)
    if (SUCCEEDED(hr))
    {
        hr = QueryContinue();
        if (S_FALSE == hr)
            hr = STRESPONSE_CANCEL;
    }

    if (SUCCEEDED(hr))
        _UpdateProgress(ullComplete, ullTotal);

    return hr;
}

// When the operation is successfully complete, let the advises know

STDMETHODIMP CStorageProcessor::PostOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
{
    _cbCurrentSize = 0;
    
    HRESULT hr = S_OK;
    for (int i = 0; (S_OK == hr) && (i < ARRAYSIZE(_aspSinks)); i++)
    {
        if (_aspSinks[i])
        {
            hr = _aspSinks[i]->PostOperation(op, psiItem, psiDest, hrResult);
        }
    }
    return hr;
}

HRESULT CStorageProcessor::QueryContinue()
{
    HRESULT hr = S_OK;
    
    for (int i = 0; S_OK == hr && i < ARRAYSIZE(_aspSinks); i++)
    {
        if (_aspSinks[i])
            hr = _aspSinks[i]->QueryContinue();
    }

    if (S_OK == hr && _spProgress)
    {
        BOOL fCanceled;
        if (SUCCEEDED(_spProgress->QueryCancel(&fCanceled)) && fCanceled)
            hr = S_FALSE;
    }

    return hr;
}

HRESULT EnumShellItemsFromHIDADataObject(IDataObject *pdtobj, IEnumShellItems **ppenum)
{
    *ppenum = NULL;
    
    HRESULT hr = E_FAIL;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlSource = IDA_GetIDListPtr(pida, -1);
        if (pidlSource)
        {
            IDynamicStorage *pdstg;
            hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDynamicStorage, &pdstg));
            if (SUCCEEDED(hr))
            {
                LPCITEMIDLIST pidl;
                for (UINT i = 0; SUCCEEDED(hr) && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                {
                    LPITEMIDLIST pidlFull;
                    hr = SHILCombine(pidlSource, pidl, &pidlFull);
                    if (SUCCEEDED(hr))
                    {
                        hr = pdstg->AddIDList(1, &pidlFull, DSTGF_ALLOWDUP);
                        ILFree(pidlFull);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = pdstg->EnumItems(ppenum);
                }
                pdstg->Release();
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return hr;
}

HRESULT TransferDataObject(IDataObject *pdoSource, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions, ITransferAdviseSink *ptas)
{
    IEnumShellItems *penum;
    HRESULT hr = EnumShellItemsFromHIDADataObject(pdoSource, &penum);
    if (SUCCEEDED(hr))
    {
        IStorageProcessor *psp;
        hr = CStorageProcessor_CreateInstance(NULL, IID_PPV_ARG(IStorageProcessor, &psp));
        if (SUCCEEDED(hr))
        {
            DWORD dwCookie;
            HRESULT hrAdvise;
            if (ptas)
            {
                hrAdvise = psp->Advise(ptas, &dwCookie);
            }

            hr = psp->Run(penum, psiDest, dwOperation, dwOptions);

            if (ptas && SUCCEEDED(hrAdvise))
            {
                psp->Unadvise(dwCookie);
            }
            psp->Release();
        }
        penum->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\init.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "copy.h"
#include "filetbl.h"

#include "ovrlaymn.h"
#include "drives.h"

#include "mixctnt.h"

#include "unicpp\admovr2.h"

void FreeExtractIconInfo(int);
void DAD_ThreadDetach(void);
void DAD_ProcessDetach(void);
void TaskMem_MakeInvalid(void);
void UltRoot_Term(void);
void FlushRunDlgMRU(void);

STDAPI_(BOOL) ATL_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

// from mtpt.cpp
STDAPI_(void) CMtPt_FinalCleanUp();
STDAPI_(BOOL) CMtPt_Initialize();
STDAPI_(void) CMtPt_FakeVolatileKeys();

// Global data

BOOL g_bMirroredOS = FALSE;         // Is Mirroring enabled 
BOOL g_bBiDiPlatform = FALSE;       // Is DATE_LTRREADING flag supported by GetDateFormat() API?   
HINSTANCE g_hinst = NULL;
extern HANDLE g_hCounter;   // Global count of mods to Special Folder cache.
extern HANDLE g_hRestrictions ; // Global count of mods to restriction cache.
extern HANDLE g_hSettings;  // global count of mods to shellsettings cache
DWORD g_dwThreadBindCtx = (DWORD) -1;

#ifdef DEBUG
BOOL  g_bInDllEntry = FALSE;
#endif

CRITICAL_SECTION g_csDll = {0};
extern CRITICAL_SECTION g_csSCN;

extern CRITICAL_SECTION g_csDarwinAds;

// these will always be zero
const LARGE_INTEGER g_li0 = {0};
const ULARGE_INTEGER g_uli0 = {0};

#ifdef DEBUG
// Undefine what shlwapi.h defined so our ordinal asserts map correctly
#undef PathAddBackslash 
WINSHELLAPI LPTSTR WINAPI PathAddBackslash(LPTSTR lpszPath);
#undef PathMatchSpec
WINSHELLAPI BOOL  WINAPI PathMatchSpec(LPCTSTR pszFile, LPCTSTR pszSpec);
#endif

#ifdef DEBUG
void _ValidateExport(FARPROC fp, LPCSTR pszExport, MEMORY_BASIC_INFORMATION *pmbi)
{
    FARPROC fpExport;

    // If not yet computed, calculate the size of our code segment.
    if (pmbi->BaseAddress == NULL)
    {
        VirtualQuery(_ValidateExport, pmbi, sizeof(*pmbi));
    }

    fpExport = GetProcAddress(g_hinst, pszExport);

    // Sometimes our import table is patched.  So if fpExport does not
    // reside inside our DLL, then ignore it.
    // (But complain if fpExport==NULL.)
    if (fpExport == NULL ||
        ((SIZE_T)fpExport - (SIZE_T)pmbi->BaseAddress) < pmbi->RegionSize)
    {
        ASSERT(fp == fpExport);
    }
}
#endif


STDAPI_(BOOL) IsProcessWinlogon()
{
    return BOOLFROMPTR(GetModuleHandle(TEXT("winlogon.EXE")));
}


//
// This funcion is called when we fail _ProcessAttach, and it is the last thing we do in
// _ProcessDetach. It is used to cleanup anything allocated in _ProcessAttach().
//
BOOL _CleanupProcessAttachStuff()
{
    // !! NOTE !! - We go in reverse order from which things are allocated
    //              in _ProcessAttach() (duh!)

    if (g_dwThreadBindCtx != TLS_OUT_OF_INDEXES)
    {
        // free perthread BindCtx
        TlsFree(g_dwThreadBindCtx);
        g_dwThreadBindCtx = TLS_OUT_OF_INDEXES;
    }

    if (g_csAutoplayPrompt.DebugInfo)
    {
        DeleteCriticalSection(&g_csAutoplayPrompt);
    }

    // global resources that we need to free in all cases
    CMtPt_FinalCleanUp();

    if (g_csDarwinAds.DebugInfo)
    {
        DeleteCriticalSection(&g_csDarwinAds);
    }

    if (g_csSCN.DebugInfo)
    {
        DeleteCriticalSection(&g_csSCN);
    }
 
    if (g_csDll.DebugInfo)
    {
        DeleteCriticalSection(&g_csDll);
    }

    SHFusionUninitialize();

    return TRUE;
}


//
// NOTE: If you add something to process attach, please make sure that you fail for critical errors
//       and and add the corpsonding cleanup code in _CleanupProcessAttachStuff above.
//
// Also, anything you add here should use InitializeCriticalSectionAndSpinCount so we do not throw exceptions
// in low-memory conditions.
//
BOOL _ProcessAttach(HINSTANCE hDll)
{
    ASSERTMSG(g_hinst < ((HINSTANCE)1), "Shell32.dll DLL_POCESS_ATTACH is being called for the second time.");

    g_hinst = hDll;
    g_uCodePage = GetACP();


    // Do not initialize comctl32 right off the bat if this is a console app. Only load
    // it if we actually require it for an API.
    // Got Fusion?
    // 
    // not get fusion if (1) the current exe is winlogon.exe; (2) in GUI mode setup
    //

    if (!( IsGuimodeSetupRunning() && IsProcessWinlogon() ))
    {
        // If this is a console app, then we don't want to load comctl32 right off the bat, but
        // we do want to initialize fusion. If this isn't a console app, load it.
        SHFusionInitializeFromModuleID(hDll, 124);
    }

    if (!InitializeCriticalSectionAndSpinCount(&g_csDll, 0)         ||
        !InitializeCriticalSectionAndSpinCount(&g_csSCN, 0)         ||
        !InitializeCriticalSectionAndSpinCount(&g_csDarwinAds, 0))
    {
        TraceMsg(TF_WARNING, "SHELL32: _ProcessAttach failed -- InitializeCriticalSectionAndSpinCount returned %ld", GetLastError());
        return FALSE;
    }

    // Initialize the MountPoint stuff
    if (!CMtPt_Initialize())
    {
        TraceMsg(TF_WARNING, "SHELL32: _ProcessAttach failed -- CMtPt_Initialize returned FALSE");
        return FALSE;
    }

    // Initialize a Crit Sect for the Autoplay prompts
    if (!InitializeCriticalSectionAndSpinCount(&g_csAutoplayPrompt, 0))
    {
        TraceMsg(TF_WARNING, "SHELL32: _ProcessAttach failed -- InitializeCriticalSectionAndSpinCount returned %ld", GetLastError());
        return FALSE;
    }

    //  perthread BindCtx
    g_dwThreadBindCtx = TlsAlloc();

    // Check if the mirroring APIs exist on the current platform.
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    g_bBiDiPlatform = BOOLFROMPTR(GetModuleHandle(TEXT("LPK.DLL")));

#ifdef DEBUG
  {
      MEMORY_BASIC_INFORMATION mbi = {0};

#define DEREFMACRO(x) x
#define ValidateORD(_name) _ValidateExport((FARPROC)_name, (LPSTR)MAKEINTRESOURCE(DEREFMACRO(_name##ORD)), &mbi)
    ValidateORD(SHValidateUNC);
    ValidateORD(SHChangeNotifyRegister);
    ValidateORD(SHChangeNotifyDeregister);
    ValidateORD(OleStrToStrN);
    ValidateORD(SHCloneSpecialIDList);
    _ValidateExport((FARPROC)DllGetClassObject, (LPSTR)MAKEINTRESOURCE(SHDllGetClassObjectORD), &mbi);
    ValidateORD(SHLogILFromFSIL);
    ValidateORD(SHMapPIDLToSystemImageListIndex);
    ValidateORD(SHShellFolderView_Message);
    ValidateORD(Shell_GetImageLists);
    ValidateORD(SHGetSpecialFolderPath);
    ValidateORD(StrToOleStrN);

    ValidateORD(ILClone);
    ValidateORD(ILCloneFirst);
    ValidateORD(ILCombine);
    ValidateORD(ILFindChild);
    ValidateORD(ILFree);
    ValidateORD(ILGetNext);
    ValidateORD(ILGetSize);
    ValidateORD(ILIsEqual);
    ValidateORD(ILRemoveLastID);
    ValidateORD(PathAddBackslash);
    ValidateORD(PathIsExe);
    ValidateORD(PathMatchSpec);
    ValidateORD(SHGetSetSettings);
    ValidateORD(SHILCreateFromPath);
    ValidateORD(SHFree);

    ValidateORD(SHAddFromPropSheetExtArray);
    ValidateORD(SHCreatePropSheetExtArray);
    ValidateORD(SHDestroyPropSheetExtArray);
    ValidateORD(SHReplaceFromPropSheetExtArray);
    ValidateORD(SHCreateDefClassObject);
    ValidateORD(SHGetNetResource);
  }

#endif  // DEBUG

#ifdef DEBUG
    {
        extern LPMALLOC g_pmemTask;
        AssertMsg(g_pmemTask == NULL, TEXT("Somebody called SHAlloc in DllEntry!"));
    }

    // Make sure ShellDispatch has the right flags for shell settings
    {
        STDAPI_(void) _VerifyDispatchGetSetting();
        _VerifyDispatchGetSetting();
    }
#endif

    return TRUE;
}

//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//
extern const TCHAR c_szBackgroundPreview2[];
extern const TCHAR c_szComponentPreview[];
extern const TCHAR c_szUserEventWindow[];

const LPCTSTR c_rgszClasses[] = {
    TEXT("SHELLDLL_DefView"),               // defview.cpp
    TEXT("WOACnslWinPreview"),              // lnkcon.c
    TEXT("WOACnslFontPreview"),             // lnkcon.c
    TEXT("cpColor"),                        // lnkcon.c
    TEXT("cpShowColor"),                    // lnkcon.c
    c_szStubWindowClass,                    // rundll32.c
    c_szBackgroundPreview2,                 // unicpp\dbackp.cpp
    c_szComponentPreview,                   // unicpp\dcompp.cpp
    TEXT(STR_DESKTOPCLASS),                 // unicpp\desktop.cpp
    TEXT("MSGlobalFolderOptionsStub"),      // unicpp\options.cpp
    TEXT("DivWindow"),                      // fsrchdlg.h
    TEXT("ATL Shell Embedding"),            // unicpp\dvoc.h
    TEXT("ShellFileSearchControl"),         // fsearch.h
    TEXT("GroupButton"),                    // fsearch
    TEXT("ATL:STATIC"),                     // unicpp\deskmovr.cpp
    TEXT("DeskMover"),                      // unicpp\deskmovr.cpp
    TEXT("SysFader"),                       // menuband\fadetsk.cpp
    c_szUserEventWindow,                    // uevttmr.cpp
    LINKWINDOW_CLASS,                       // linkwnd.cpp
    TEXT("DUIViewWndClassName"),            // duiview.cpp
    TEXT("DUIMiniPreviewer"),               // duiinfo.cpp
};

void _ProcessDetach(BOOL bProcessShutdown)
{
#ifdef DEBUG
    if (bProcessShutdown)
    {
        // to catch bugs where people use the task allocator at process
        // detatch time (this is a problem becuase OLE32.DLL could be unloaded)
        TaskMem_MakeInvalid(); 
    }

    g_hinst = (HINSTANCE)1;
#endif

    FlushRunDlgMRU();

    FlushFileClass();

    if (!bProcessShutdown)
    {
        // some of these may use the task allocator. we can only do
        // this when we our DLL is being unloaded in a process, not
        // at process term since OLE32 might not be around to be called
        // at process shutdown time this memory will be freed as a result
        // of the process address space going away.

        SpecialFolderIDTerminate();
        BitBucket_Terminate();

        UltRoot_Term();
        RLTerminate();          // close our use of the Registry list...
        DAD_ProcessDetach();

        CopyHooksTerminate();
        IconOverlayManagerTerminate();

        // being unloaded via FreeLibrary, then do some more stuff.
        // Don't need to do this on process terminate.
        SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses));
        FreeExtractIconInfo(-1);

        FreeUndoList();
        DestroyHashItemTable(NULL);
        FileIconTerm();
    }

    SHChangeNotifyTerminate(TRUE, bProcessShutdown);

    if (!bProcessShutdown)
    {
        // this line was moved from the above !bProcessShutdown block because
        // it needs to happen after SHChangeNotifyTerminate b/c the SCHNE code has 
        // a thread running that uses the CDrivesFolder global psf. 

        // NOTE: this needs to be in a !bProcessShutdown block since it calls the 
        // task allocator and we blow this off at shutdown since OLE might already
        // be gone.
        CDrives_Terminate();
    }

    SHDestroyCachedGlobalCounter(&g_hCounter);
    SHDestroyCachedGlobalCounter(&g_hRestrictions);
    SHDestroyCachedGlobalCounter(&g_hSettings);

    if (g_hklmApprovedExt && (g_hklmApprovedExt != INVALID_HANDLE_VALUE))
    {
        RegCloseKey(g_hklmApprovedExt);
    }

    UnInitializeDirectUI();

    _CleanupProcessAttachStuff();
}

BOOL _ThreadDetach()
{
    ASSERTNONCRITICAL           // Thread shouldn't term while holding CS
    DAD_ThreadDetach();
    return TRUE;
}

STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRet = TRUE;
#ifdef DEBUG
    g_bInDllEntry = TRUE;
#endif

    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        CcshellGetDebugFlags();     // Don't put this line under #ifdef
        
#ifdef DEBUG
        __try
        {
#endif  // DEBUG

        fRet = _ProcessAttach(hDll);

#ifdef DEBUG
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TraceMsg(TF_ERROR, "_ProcessAttach threw an unhandled exception! This should NOT happen");
        }
#endif  // DEBUG

        if (!fRet)
        {
            // The ldr is lame and should call ProcessDetach on a process attach failure
            // but it dosent. We call _CleanupProcessAttachStuff to make sure we don't leak
            // anything we did manage to allocate.
            _CleanupProcessAttachStuff();
        }
        break;

    case DLL_PROCESS_DETACH:
        _ProcessDetach(lpReserved != NULL);
        break;

    case DLL_THREAD_DETACH:
        _ThreadDetach();
        break;

    default:
        break;
    }

    if (fRet)
    {
        // except in the case of a failed DLL_PROCESS_ATTACH, inform ATL
        ATL_DllMain(hDll, dwReason, lpReserved);
    }

#ifdef DEBUG
    g_bInDllEntry = FALSE;
#endif

    return fRet;
}

#ifdef DEBUG
LRESULT WINAPI SendMessageD( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
#ifdef UNICODE
    return SendMessageW(hWnd, Msg, wParam, lParam);
#else
    return SendMessageA(hWnd, Msg, wParam, lParam);
#endif
}

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
ATOM WINAPI RegisterClassD(CONST WNDCLASS *pwc)
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

ATOM WINAPI RegisterClassExD(CONST WNDCLASSEX *pwc)
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClassEx(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) 
    {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG

STDAPI DllCanUnloadNow()
{
    // shell32 won't be able to be unloaded since there are lots of APIs and
    // other non COM things that will need to keep it loaded
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\isproc.h ===
//  Contents: CStorageProcessor class def'n

#pragma once
#include "resource.h"       // main symbols
#include <dpa.h>

//
// Map of storage operations -> string resources
// 

typedef struct tagSTC_CR_PAIR
{ 
    STGTRANSCONFIRMATION stc; 
    CONFIRMATIONRESPONSE cr; 

    bool operator==(const STGTRANSCONFIRMATION & r_stc) const { return TRUE==IsEqualIID(stc, r_stc); }
    tagSTC_CR_PAIR(STGTRANSCONFIRMATION o_stc, CONFIRMATIONRESPONSE o_cr) { stc=o_stc; cr=o_cr; }
} STC_CR_PAIR;

typedef struct tagSTGOP_DETAIL
{
    STGOP stgop; 
    UINT  idTitle; 
    UINT  idPrep; 
    SPACTION spa;
} STGOP_DETAIL;


// Maximum number of advise sinks that can be registered with us at any one time

const DWORD MAX_SINK_COUNT = 32;

class CStorageProcessor : 
    public IStorageProcessor,
    public ITransferAdviseSink,
    public ISupportErrorInfo,
    public IOleWindow,
    public CComObjectRoot,
    public CComCoClass<CStorageProcessor,&CLSID_StorageProcessor>
{
public:
    CStorageProcessor();
    virtual ~CStorageProcessor();
    
    BEGIN_COM_MAP(CStorageProcessor)
        COM_INTERFACE_ENTRY(IStorageProcessor)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IOleWindow)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_StorageProcessor)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IStorageProcessor
    STDMETHOD(SetProgress)(IActionProgress *pap);
    STDMETHOD(Run)(IEnumShellItems *penum, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions);
    STDMETHOD(SetLinkFactory)(REFCLSID clsid);
    STDMETHOD(Advise)(ITransferAdviseSink *pAdvise, DWORD *dwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);

    // IStorageAdciseSink
    STDMETHOD(PreOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest);
    STDMETHOD(ConfirmOperation)(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc);
    STDMETHOD(OperationProgress)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete);
    STDMETHOD(PostOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult);
    STDMETHOD(QueryContinue)();

    // IOleWindow
    STDMETHOD(GetWindow) (HWND * lphwnd);
    STDMETHOD(ContextSensitiveHelp) (BOOL fEnterMode) {  return E_NOTIMPL; };

private:
    // The operation and options originally passed in

    STGOP _dwOperation;
    DWORD _dwOptions;

    CComPtr<ITransferAdviseSink> _aspSinks[MAX_SINK_COUNT];

    STDMETHOD(_Run)(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest, STGOP dwOperation, DWORD dwOptions);

    // Walks the storage(s) performing whatever main operation has been requested
    HRESULT _WalkStorage(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);
    HRESULT _WalkStorage(IEnumShellItems *penum, IShellItem *psiDest, ITransferDest *ptdDest);

    // Worker functions that perform the bulk of the actual storage work.  The
    // storage operations are recursive (ie: DoRemoveStorage will prune an entire branch).

    HRESULT _DoStats(IShellItem *psi);
    HRESULT _DoCopy(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest, DWORD dwStgXFlags);
    HRESULT _DoMove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);
    HRESULT _DoRemove(IShellItem *psi, IShellItem *psiDest, ITransferDest *ptdDest);

    HRESULT _GetDefaultResponse(STGTRANSCONFIRMATION    stc, LPCONFIRMATIONRESPONSE  pcrResponse);

    // Takes the current error code and massages it based on the result of
    // a current or previous user response to a confirmation dialog

    HRESULT _DoConfirmations(STGTRANSCONFIRMATION  stc, CUSTOMCONFIRMATION  *pcc, IShellItem *psiSource, IShellItem *psiDest);

    BOOL _IsStream(IShellItem *psi);
    BOOL _ShouldWalk(IShellItem *psi);
    ULONGLONG _GetSize(IShellItem *psi);
    HRESULT _BindToHandlerWithMode(IShellItem *psi, STGXMODE grfMode, REFIID riid, void **ppv);

    // Updates the time estimate, and if the dialog is being used, it as well
    void _UpdateProgress(ULONGLONG ullCurrentComplete, ULONGLONG ullCurrentTotal);

    // Starts the progress dialog

    HRESULT _StartProgressDialog(const STGOP_DETAIL *popid);

    // CStgStatistics
    //
    // Wrapper for STGSTATS that provides some accounting helper functions

    class CStgStatistics
    {
    public:                
        CStgStatistics()
        {
        }

        ULONGLONG Bytes()     const { return _cbSize; }
        DWORD     Streams()   const { return _cStreams; }
        DWORD     Storages()  const { return _cStorages; }
        ULONGLONG Cost(DWORD, ULONGLONG cbExtra) const;
        DWORD AddStream(ULONGLONG cbSize);
        DWORD AddStorage();

    private:
        ULONGLONG _cbSize;
        DWORD _cStreams;
        DWORD _cStorages;
    };

    CStgStatistics _statsTodo;
    CStgStatistics _statsDone;
    DWORD          _msTicksLast;       // Tick count at last point update
    DWORD          _msStarted;         // When we started tracking points
    ULONGLONG _cbCurrentSize;

    DWORD _StreamsToDo() const  { return _statsTodo.Streams();  }
    DWORD _StoragesToDo() const { return _statsTodo.Storages();  }

    // Progress dialog.  Pointer will be NULL if no progress is requrested.

    CComPtr<IActionProgress> _spProgress;    
    CComPtr<IActionProgressDialog> _spShellProgress;    

    CComPtr<ITransferDest>      _spSrc;
    CComPtr<ITransferDest>      _spDest;
    ITransferConfirmation    *_ptc;
    const STATSTG          *_pstatSrc;
    CLSID                    _clsidLinkFactory;
    // A tree (map) of responses given to various previous confirmations
    CDSA<STC_CR_PAIR> _dsaConfirmationResponses;
};


STDAPI CreateStg2StgExWrapper(IShellItem *psi, IStorageProcessor *pEngine, ITransferDest **pptd);
HRESULT AutoCreateName(IShellItem *psiDest, IShellItem *psi, LPWSTR *ppszName);
HRESULT TransferDataObject(IDataObject *pdoSource, IShellItem *psiDest, STGOP dwOperation, DWORD dwOptions, ITransferAdviseSink *ptas);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\item.cpp ===
#include "shellprv.h"
#include "cowsite.h"
#include "enumidlist.h"

typedef enum
{
    MAYBEBOOL_MAYBE = 0,
    MAYBEBOOL_TRUE,
    MAYBEBOOL_FALSE,
} MAYBEBOOL;

#define _GetBindWindow(p) NULL


class CShellItem    : public IShellItem 
                    , public IPersistIDList
                    , public IParentAndItem
{
public:
    CShellItem();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellItem
    STDMETHODIMP BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv);
    STDMETHODIMP GetParent(IShellItem **ppsi);
    STDMETHODIMP GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName);        
    STDMETHODIMP GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags);    
    STDMETHODIMP Compare(IShellItem *psi, SICHINTF hint, int *piOrder);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID) {*lpClassID = CLSID_ShellItem; return S_OK;}
    
    // IPersistIDList
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidlChild);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);

private:  // methods
    ~CShellItem();

    void _Reset(void);
    //  BindToHandler() helpers
    HRESULT _BindToParent(REFIID riid, void **ppv);
    HRESULT _BindToSelf(REFIID riid, void **ppv);
    //  GetAttributes() helpers
    inline BOOL _IsAttrib(SFGAOF sfgao);
    //  GetDisplayName() helpers
    BOOL _SupportedName(SIGDN sigdnName, SHGDNF *pflags);
    HRESULT _FixupName(SIGDN sigdnName, LPOLESTR *ppszName);
    void _FixupAttributes(IShellFolder *psf, SFGAOF sfgaoMask);

    LONG _cRef;
    LPITEMIDLIST _pidlSelf;
    LPCITEMIDLIST _pidlChild;
    LPITEMIDLIST _pidlParent;
    IShellFolder *_psfSelf;
    IShellFolder *_psfParent;
    BOOL _fInited;
    SFGAOF _sfgaoTried;
    SFGAOF _sfgaoKnown;
};

CShellItem::CShellItem() : _cRef(1)
{
    ASSERT(!_pidlSelf);
    ASSERT(!_pidlChild);
    ASSERT(!_pidlParent);
    ASSERT(!_psfSelf);
    ASSERT(!_psfParent);
}

CShellItem::~CShellItem()
{
    _Reset();
}

void CShellItem::_Reset(void)
{
    ATOMICRELEASE(_psfSelf);
    ATOMICRELEASE(_psfParent);

    ILFree(_pidlSelf);
    ILFree(_pidlParent);

    _pidlSelf = NULL;
    _pidlParent = NULL;
    _pidlChild = NULL;      // alias into _pidlParent
}
    
STDMETHODIMP CShellItem::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItem, IShellItem),
        QITABENT(CShellItem, IPersistIDList),
        QITABENT(CShellItem, IParentAndItem),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItem::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShellItem::SetIDList(LPCITEMIDLIST pidl)
{
    if (!pidl)
    {
        RIPMSG(0, "Tried to Call SetIDList with a NULL pidl");
        return E_INVALIDARG;
    }

    _Reset();

    HRESULT hr = SHILClone(pidl, &_pidlSelf);
    if (SUCCEEDED(hr))
    {
        // possible this item is the desktop in which case
        // there is no parent.
        if (ILIsEmpty(_pidlSelf))
        {
            _pidlParent = NULL;
            _pidlChild = _pidlSelf;
        }
        else
        {
            _pidlParent = ILCloneParent(_pidlSelf);
            _pidlChild = ILFindLastID(_pidlSelf);

            if (NULL == _pidlParent)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CShellItem::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (_pidlSelf)
    {
        hr = SHILClone(_pidlSelf, ppidl);
    }

    return hr;
}

HRESULT CShellItem::_BindToParent(REFIID riid, void **ppv)
{
    ASSERT(_pidlChild); // we should already have a child setup

    if (!_psfParent && _pidlParent && _pidlSelf) // check pidlParent to check in case the item is the desktop
    {
        HRESULT hr;
        LPCITEMIDLIST pidlChild;

        hr = SHBindToIDListParent(_pidlSelf, IID_PPV_ARG(IShellFolder, &_psfParent), &pidlChild);

#ifdef DEBUG
        if (SUCCEEDED(hr))
        {
            ASSERT(pidlChild == _pidlChild);
        }
#endif // DEBUG
    }

    if (_psfParent)
    {
        return _psfParent->QueryInterface(riid, ppv);
    }

    return E_FAIL;
}

HRESULT CShellItem::_BindToSelf(REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    if (!_psfSelf)
    {
        hr = BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &_psfSelf));
    }

    if (_psfSelf)
    {
        hr = _psfSelf->QueryInterface(riid, ppv);
    }

    return hr;
}

HRESULT _CreateLinkTargetItem(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    SFGAOF flags = SFGAO_LINK;
    if (SUCCEEDED(psi->GetAttributes(flags, &flags)) && (flags & SFGAO_LINK))
    {
        //  this is indeed a link
        //  get the target and 
        IShellLink *psl;
        HRESULT hr = psi->BindToHandler(pbc, BHID_SFUIObject, IID_PPV_ARG(IShellLink, &psl));

        if (SUCCEEDED(hr))
        {
            DWORD slr = 0;
            HWND hwnd = _GetBindWindow(pbc);
            
            if (pbc)
            {
                BIND_OPTS2 bo;  
                bo.cbStruct = sizeof(BIND_OPTS2); // Requires size filled in.
                if (SUCCEEDED(pbc->GetBindOptions(&bo)))
                {
                    //  these are the flags to pass to resolve
                    slr = bo.dwTrackFlags;
                }
            }

            hr = psl->Resolve(hwnd, slr);

            if (S_OK == hr)
            {
                LPITEMIDLIST pidl;
                hr = psl->GetIDList(&pidl);

                if (SUCCEEDED(hr))
                {
                    IShellItem *psiTarget;
                    hr = SHCreateShellItem(NULL, NULL, pidl, &psiTarget);

                    if (SUCCEEDED(hr))
                    {
                        hr = psiTarget->QueryInterface(riid, ppv);
                        psiTarget->Release();
                    }
                    ILFree(pidl);
                }
            }
            else if (SUCCEEDED(hr))
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            psl->Release();
        }

        return hr;
    }

    return E_INVALIDARG;
}

BOOL _IsWebfolders(IShellItem *psi);
HRESULT _CreateStorageHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);
HRESULT _CreateStream(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);
HRESULT _CreateEnumHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);

HRESULT _CreateHelperInstance(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    IItemHandler *pih;
    HRESULT hr = SHCoCreateInstance(NULL, &rbhid, NULL, IID_PPV_ARG(IItemHandler, &pih));

    if (SUCCEEDED(hr))
    {
        hr = pih->SetItem(psi);

        if (SUCCEEDED(hr))
        {
            hr = pih->QueryInterface(riid, ppv);
        }
        pih->Release();
    }

    return hr;
}
    
enum 
{
    BNF_OBJECT          = 0x0001,
    BNF_UIOBJECT        = 0x0002,
    BNF_VIEWOBJECT      = 0x0004,
    BNF_USE_RIID        = 0x0008,
    BNF_REFLEXIVE       = 0x0010,
};
typedef DWORD BNF;

typedef HRESULT (* PFNCREATEHELPER)(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv);

typedef struct
{
    const GUID *pbhid;
    BNF bnf;
    const IID *piid;
    PFNCREATEHELPER pfn;
} BINDNONSENSE;

#define BINDHANDLER(bhid, flags, piid, pfn) { &bhid, flags, piid, pfn},
#define SFBINDHANDLER(bhid, flags, piid)    BINDHANDLER(bhid, flags, piid, NULL)
#define BINDHELPER(bhid, flags, pfn)        BINDHANDLER(bhid, flags, NULL, pfn)

const BINDNONSENSE c_bnList[] = 
{
    SFBINDHANDLER(BHID_SFObject, BNF_OBJECT | BNF_USE_RIID, NULL)
    SFBINDHANDLER(BHID_SFUIObject, BNF_UIOBJECT | BNF_USE_RIID, NULL)
    SFBINDHANDLER(BHID_SFViewObject, BNF_VIEWOBJECT | BNF_USE_RIID, NULL)
    BINDHELPER(BHID_LinkTargetItem, 0, _CreateLinkTargetItem)
    BINDHELPER(BHID_LocalCopyHelper, 0, _CreateHelperInstance)
    BINDHELPER(BHID_Storage, BNF_OBJECT | BNF_USE_RIID, _CreateStorageHelper)
    BINDHELPER(BHID_Stream, BNF_OBJECT | BNF_USE_RIID, NULL)
    BINDHELPER(BHID_StorageEnum, 0, _CreateEnumHelper)
};
    
HRESULT _GetBindNonsense(const GUID *pbhid, const IID *piid, BINDNONSENSE *pbn)
{
    HRESULT hr = MK_E_NOOBJECT;
    for (int i = 0; i < ARRAYSIZE(c_bnList); i++)
    {
        if (IsEqualGUID(*pbhid, *(c_bnList[i].pbhid)))
        {
            *pbn = c_bnList[i];
            hr = S_OK;

            if (pbn->bnf & BNF_USE_RIID)
            {
                pbn->piid = piid;
            }

            if (pbn->piid && IsEqualGUID(*(pbn->piid), *piid))
                pbn->bnf |= BNF_REFLEXIVE;

            break;
        }
    }
    return hr;
}

STDMETHODIMP CShellItem::BindToHandler(IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{
    //  look up handler for bind flags
    //  use the flags to determine BTO GUIO BTS CVO
    BINDNONSENSE bn = {0};
    HRESULT hr = _GetBindNonsense(&rbhid, &riid, &bn);

    *ppv = NULL;
    
    if (SUCCEEDED(hr))
    {
        hr = E_NOINTERFACE;

        if (_pidlParent && (bn.bnf & (BNF_OBJECT | BNF_UIOBJECT)))
        {
            IShellFolder *psf;
            if (SUCCEEDED(_BindToParent(IID_PPV_ARG(IShellFolder, &psf))))
            {
                if (bn.bnf & BNF_OBJECT)
                {
                    hr = psf->BindToObject(_pidlChild, pbc, *(bn.piid), ppv);
                }
                
                if (FAILED(hr) && (bn.bnf & BNF_UIOBJECT))
                {
                    HWND hwnd = _GetBindWindow(pbc);
                    hr = psf->GetUIObjectOf(hwnd, 1, &_pidlChild, *(bn.piid), NULL, ppv);
                }
                psf->Release();
            }
        }

        // if don't have a parent pidl then we are the desktop.
        if (FAILED(hr) && (NULL == _pidlParent) && (bn.bnf & BNF_OBJECT))
        {
            IShellFolder *psf;
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                hr = psf->QueryInterface(riid,ppv);
                psf->Release();
            }
        }


        if (FAILED(hr) && (bn.bnf & BNF_VIEWOBJECT))
        {
            IShellFolder *psf;

            if (SUCCEEDED(_BindToSelf(IID_PPV_ARG(IShellFolder, &psf))))
            {
                HWND hwnd = _GetBindWindow(pbc);
                hr = psf->CreateViewObject(hwnd, *(bn.piid), ppv);
                
                psf->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            if (!(bn.bnf & BNF_REFLEXIVE))
            {
                IUnknown *punk = (IUnknown *)*ppv;
                hr = punk->QueryInterface(riid, ppv);
                punk->Release();
            }
            //  else riid is the same as bn.piid
        }
        else if (bn.pfn)
        {
            hr = bn.pfn(this, pbc, rbhid, riid, ppv);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem::GetParent(IShellItem **ppsi)
{
    HRESULT hr = MK_E_NOOBJECT;

    if (_pidlParent)
    {
        if (!ILIsEmpty(_pidlSelf))
        {
            CShellItem *psi = new CShellItem();
            if (psi)
            {
                // may already have the _psf Parent here so be nice
                // to have a way to do this in a set.
                hr = psi->SetIDList(_pidlParent);
                if (SUCCEEDED(hr))
                    hr = psi->QueryInterface(IID_PPV_ARG(IShellItem, ppsi));
                    
                psi->Release();
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

BOOL CShellItem::_IsAttrib(SFGAOF sfgao)
{
    HRESULT hr = GetAttributes(sfgao, &sfgao);
    return hr == S_OK;
}

#define SHGDNF_MASK     0xFFFF  //  bottom word

BOOL CShellItem::_SupportedName(SIGDN sigdn, SHGDNF *pflags)
{
    *pflags = (sigdn & SHGDNF_MASK);
    //  block this completely
    //  to avoid doing any binding at all 
    if (sigdn == SIGDN_FILESYSPATH && !_IsAttrib(SFGAO_FILESYSTEM))
        return FALSE;

    return TRUE;
}

HRESULT CShellItem::_FixupName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    HRESULT hr = S_OK;
    if (sigdnName == SIGDN_URL && !UrlIsW(*ppszName, URLIS_URL))
    {
        WCHAR sz[MAX_URL_STRING];
        DWORD cch = ARRAYSIZE(sz);
        if (SUCCEEDED(UrlCreateFromPathW(*ppszName, sz, &cch, 0)))
        {
            CoTaskMemFree(*ppszName);
            hr = SHStrDupW(sz, ppszName);
        }
    }

    return hr;
}

STDMETHODIMP CShellItem::GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    SHGDNF flags;
    if (_SupportedName(sigdnName, &flags))
    {
        IShellFolder *psf;
        HRESULT hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            STRRET str;
            hr = IShellFolder_GetDisplayNameOf(psf, _pidlChild, flags, &str, 0);

            if (SUCCEEDED(hr))
            {
                hr = StrRetToStrW(&str, _pidlChild, ppszName);

                if (SUCCEEDED(hr) && (int)flags != (int)sigdnName)
                {
                    hr = _FixupName(sigdnName, ppszName);
                }
            }
                
            psf->Release();
        }

        return hr;
    }
    
    return E_INVALIDARG;
}

void CShellItem::_FixupAttributes(IShellFolder *psf, SFGAOF sfgaoMask)
{
    // APPCOMPAT: The following if statement and its associated body is an APP HACK for pagis pro
    // folder. Which specifies SFGAO_FOLDER and SFGAO_FILESYSTEM but it doesn't specify SFGAO_STORAGEANCESTOR
    // This APP HACK basically checks for this condition and provides SFGAO_STORAGEANCESTOR bit.
    if (_sfgaoKnown & SFGAO_FOLDER)
    {
        if ((!(_sfgaoKnown & SFGAO_FILESYSANCESTOR) && (sfgaoMask & SFGAO_FILESYSANCESTOR))
        || ((_sfgaoKnown & SFGAO_CANMONIKER) && !(_sfgaoKnown & SFGAO_STORAGEANCESTOR) && (sfgaoMask & SFGAO_STORAGEANCESTOR)))
        {
            OBJCOMPATFLAGS ocf = SHGetObjectCompatFlags(psf, NULL);
            if (ocf & OBJCOMPATF_NEEDSFILESYSANCESTOR)
            {
                _sfgaoKnown |= SFGAO_FILESYSANCESTOR;
            }
            if (ocf & OBJCOMPATF_NEEDSSTORAGEANCESTOR)
            {
                //  switch SFGAO_CANMONIKER -> SFGAO_STORAGEANCESTOR
                _sfgaoKnown |= SFGAO_STORAGEANCESTOR;
                _sfgaoKnown &= ~SFGAO_CANMONIKER;
            }
        }
    }
}

STDMETHODIMP CShellItem::GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags)
{
    HRESULT hr = S_OK;

    //  see if we cached this bits before...
    if ((sfgaoMask & _sfgaoTried) != sfgaoMask)
    {
        IShellFolder *psf;
        hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            //  we cache all the bits except VALIDATE
            _sfgaoTried |= (sfgaoMask & ~SFGAO_VALIDATE);
            SFGAOF sfgao = sfgaoMask;

            hr = psf->GetAttributesOf(1, &_pidlChild, &sfgao);

            if (SUCCEEDED(hr))
            {
                //  we cache all the bits except VALIDATE
                _sfgaoKnown |= (sfgao & ~SFGAO_VALIDATE);
                _FixupAttributes(psf, sfgaoMask);
            }

            psf->Release();
        }
    }

    *psfgaoFlags = _sfgaoKnown & sfgaoMask;

    if (SUCCEEDED(hr))
    {
        //  we return S_OK 
        //  only if the bits set match
        //  exactly the bits requested
        if (*psfgaoFlags == sfgaoMask)
            hr = S_OK;
        else
            hr = S_FALSE;
    }
        
    return hr;
}

STDMETHODIMP CShellItem::Compare(IShellItem *psi, SICHINTF hint, int *piOrder)
{
    *piOrder = 0;
    HRESULT hr = IsSameObject(SAFECAST(this, IShellItem *), psi) ? S_OK : E_FAIL;
    if (FAILED(hr))
    {
        IShellFolder *psf;
        hr = _BindToParent(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            IParentAndItem *pfai;
            hr = psi->QueryInterface(IID_PPV_ARG(IParentAndItem, &pfai));
            if (SUCCEEDED(hr))
            {
                IShellFolder *psfOther;
                LPITEMIDLIST pidlParent, pidlChild;
                hr = pfai->GetParentAndItem(&pidlParent, &psfOther, &pidlChild);
                if (SUCCEEDED(hr))
                {
                    if (IsSameObject(psf, psfOther) || ILIsEqual(_pidlParent, pidlParent))
                    {
                        hr = psf->CompareIDs(hint & 0xf0000000, _pidlChild, pidlChild);
                    }
                    else
                    {
                        //  these items have a different parent
                        //  compare the absolute pidls
                        LPITEMIDLIST pidlOther;
                        hr = SHGetIDListFromUnk(psi, &pidlOther);
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psfDesktop;
                            hr = SHGetDesktopFolder(&psfDesktop);
                            if (SUCCEEDED(hr))
                            {
                                hr = psfDesktop->CompareIDs(hint & 0xf0000000, _pidlSelf, pidlOther);
                                psfDesktop->Release();
                            }
                            ILFree(pidlOther);
                        }
                    }
                        
                    if (SUCCEEDED(hr))
                    {
                        *piOrder = ShortFromResult(hr);
                        if (*piOrder)
                            hr = S_FALSE;
                        else
                            hr = S_OK;
                    }
                    
                    psfOther->Release();
                    ILFree(pidlParent);
                    ILFree(pidlChild);
                }
                pfai->Release();
            }
            psf->Release();
        }
    }

    return hr;
}

// IParentAndItem
STDMETHODIMP CShellItem::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild) 
{ 
    // require to have a Parent if making this call. If don't then use SetIDList
    if (!pidlParent && !psfParent)
    {
        RIPMSG(0, "Tried to Call SetParent without a parent");
        return E_INVALIDARG;
    }

    LPITEMIDLIST pidlFree = NULL;

    if ((NULL == pidlParent) && psfParent)
    {
        if (SUCCEEDED(SHGetIDListFromUnk(psfParent, &pidlFree)))
        {
            pidlParent = pidlFree;
        }
    }
 
    if (!ILIsEmpty(_ILNext(pidlChild))) 
    {
        // if more than on item in the child pidl don't use the parent IShellFolder*
        // could revist and bind from this parent to get a new parent so don't have
        // to BindObject through the entire pidl path.

        psfParent = NULL; 
    }

    HRESULT hr = E_FAIL;
    if (pidlParent)
    {
        _Reset();

        hr = SHILCombine(pidlParent, pidlChild, &_pidlSelf);
        if (SUCCEEDED(hr))
        {
            // setup pidls so _pidlChild is a single item.
            if (_pidlParent = ILCloneParent(_pidlSelf))
            {
                _pidlChild = ILFindLastID(_pidlSelf);

                PPUNK_SET(&_psfParent, psfParent);

#ifdef DEBUG
                if (psfParent)
                {
                    LPITEMIDLIST pidlD;
                    if (SUCCEEDED(SHGetIDListFromUnk(psfParent, &pidlD)))
                    {
                        ASSERT(ILIsEqual(pidlD, pidlParent));
                        ILFree(pidlD);
                    }
                }
#endif  //DEBUG
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    ILFree(pidlFree);   // maybe NULL

    return hr;
}

STDMETHODIMP CShellItem::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    if (ppsf)
    {
        _BindToParent(IID_PPV_ARG(IShellFolder, ppsf));
    }
    
    if (ppidlParent)
    {
        if (_pidlParent)
        {
            *ppidlParent = ILClone(_pidlParent);
        }
        else
        {
            *ppidlParent = NULL;
        }
    }
    
    if (ppidl)
        *ppidl = ILClone(_pidlChild);


    HRESULT hr = S_OK;
    if ((ppidlParent && !*ppidlParent)
    ||  (ppsf && !*ppsf)
    ||  (ppidl && !*ppidl))
    {
        //  this is failure
        //  but we dont know what failed
        if (ppsf && *ppsf)
        {
            (*ppsf)->Release();
            *ppsf = NULL;
        }

        if (ppidlParent)
        {
            ILFree(*ppidlParent);
            *ppidlParent = NULL;
        }

        if (ppidl)
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI CShellItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CShellItem *psi = new CShellItem();
    if (psi)
    {
        HRESULT hr = psi->QueryInterface(riid, ppv);
        psi->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}


class CShellItemEnum : IEnumShellItems, public CObjectWithSite
{
public:
    CShellItemEnum();
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder,IShellFolder *psf, DWORD dwFlags,UINT cidl,LPCITEMIDLIST *apidl);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumShellItems **ppenum);

private:

    virtual ~CShellItemEnum();
    HRESULT _EnsureEnum();

    LONG _cRef;
    DWORD _dwFlags;

    IShellFolder *_psf;
    IEnumIDList *_penum;
    LPITEMIDLIST _pidlFolder;
};



STDMETHODIMP CShellItemEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItemEnum, IEnumShellItems),
        QITABENT(CShellItemEnum, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItemEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItemEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShellItemEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    HRESULT hr = _EnsureEnum();
    if (FAILED(hr))
        return hr;

    ULONG uTemp;
    if (!pceltFetched)
        pceltFetched = &uTemp;
    
    *pceltFetched = 0;
    
    while (celt--)
    {
        LPITEMIDLIST pidl;
        ULONG cFetched;
        hr = _penum->Next(1, &pidl, &cFetched);
        if (S_OK == hr)
        {
            hr = SHCreateShellItem(_pidlFolder, _psf, pidl, &rgelt[*pceltFetched]);
            if (SUCCEEDED(hr))
                (*pceltFetched)++;
                
            ILFree(pidl);
        }

        if (S_OK != hr)
            break;
    }

    if (SUCCEEDED(hr))
    {
        hr = *pceltFetched ? S_OK : S_FALSE;
    }
    else
    {
        for (UINT i = 0; i < *pceltFetched; i++)
        {
            ATOMICRELEASE(rgelt[i]);
        }
        *pceltFetched = 0;
    }


    return hr;
}

STDMETHODIMP CShellItemEnum::Skip(ULONG celt)
{
    HRESULT hr = _EnsureEnum();
    if (SUCCEEDED(hr))
        hr = _penum->Skip(celt);

    return hr;
}

STDMETHODIMP CShellItemEnum::Reset()
{
    HRESULT hr = _EnsureEnum();
    if (SUCCEEDED(hr))
        hr = _penum->Reset();

    return hr;
}

STDMETHODIMP CShellItemEnum::Clone(IEnumShellItems **ppenum)
{
    return E_NOTIMPL;
}

HRESULT CShellItemEnum::_EnsureEnum()
{
    if (_penum)
        return S_OK;

    HRESULT hr = E_FAIL;

    if (_psf)
    {
        HWND hwnd = NULL;
        IUnknown_GetWindow(_punkSite, &hwnd);

        // if didn't get an enum in Initialize then enumerate the
        // entire folder.
        hr = _psf->EnumObjects(hwnd, _dwFlags, &_penum);
    }

    return hr;
}


CShellItemEnum::CShellItemEnum() 
        : _cRef(1)
{
    ASSERT(NULL == _psf);
    ASSERT(NULL == _penum);
    ASSERT(NULL == _pidlFolder);
}

STDMETHODIMP CShellItemEnum::Initialize(LPCITEMIDLIST pidlFolder, IShellFolder *psf, DWORD dwFlags, UINT cidl, LPCITEMIDLIST *apidl)
{
    HRESULT hr = E_FAIL;

    _dwFlags = dwFlags;

    _psf = psf;
    _psf->AddRef();

    if (NULL == _pidlFolder)
    {
        hr = SHGetIDListFromUnk(_psf, &_pidlFolder);
    }
    else
    {
        hr = SHILClone(pidlFolder, &_pidlFolder);
    }

    if (SUCCEEDED(hr) && cidl)
    {
        ASSERT(apidl);

        // if want to enum with other flags or combos need to implement the filter
        ASSERT(_dwFlags == (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN));

        hr = CreateIEnumIDListOnIDLists(apidl, cidl, &_penum);
    }

    // on error let our destructor do the cleanup
    
    return hr;
}

CShellItemEnum::~CShellItemEnum()
{
    ATOMICRELEASE(_penum);
    ATOMICRELEASE(_psf);
    ILFree(_pidlFolder);
}

HRESULT _CreateShellItemEnum(LPCITEMIDLIST pidlFolder,IShellFolder *psf,IBindCtx *pbc, REFGUID rbhid, 
                             UINT cidl, LPCITEMIDLIST *apidl,
                             REFIID riid, void **ppv)
{
    DWORD dwFlags;
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST *pidlEnum = NULL;

    UINT mycidl = 0;
    LPITEMIDLIST *myppidl = NULL;;

    if (IsEqualGUID(rbhid, BHID_StorageEnum))
        dwFlags = SHCONTF_STORAGE;
    else
        dwFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN;

    CShellItemEnum *psie = new CShellItemEnum();

    if (psie)
    {
        hr = psie->Initialize(pidlFolder, psf, dwFlags, cidl, apidl);

        if (SUCCEEDED(hr))
        {
            hr = psie->QueryInterface(riid, ppv);
        }

        psie->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT _CreateEnumHelper(IShellItem *psi, IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppv)
{   
    HRESULT hr = E_FAIL;
    IShellFolder *psf;

    ASSERT(psi);
    
    if (psi)
    {
        hr = psi->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));

        if (SUCCEEDED(hr))
        {
            hr =  _CreateShellItemEnum(NULL,psf,pbc,rbhid,0,NULL,riid,ppv);
            psf->Release();
        }
    }

    return hr;
}

class CShellItemArray : public IShellItemArray
{
public:
    CShellItemArray();
    ~CShellItemArray();
    HRESULT Initialize(LPCITEMIDLIST pidlParent,IShellFolder *psf,UINT cidl,LPCITEMIDLIST *ppidl);


    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellItemArray 
    STDMETHODIMP BindToHandler(
        IBindCtx *pbc, 
        REFGUID rbhid,
        REFIID riid, 
        void **ppvOut);

    STDMETHODIMP GetAttributes(
        SIATTRIBFLAGS dwAttribFlags,
        SFGAOF sfgaoMask, 
        SFGAOF *psfgaoAttribs);

    STDMETHODIMP GetCount(DWORD *pdwNumItems);
    STDMETHODIMP GetItemAt(DWORD dwIndex,IShellItem **ppsi);
    STDMETHODIMP EnumItems(IEnumShellItems **ppenumShellItems);

private:
    HRESULT _CloneIDListArray(UINT cidl, LPCITEMIDLIST *apidl, UINT *pcidl, LPITEMIDLIST **papidl);

    IShellFolder *_pshf;
    LPITEMIDLIST _pidlParent;
    LPITEMIDLIST *_ppidl;
    UINT _cidl;
    LONG _cRef;
    IDataObject *_pdo; // cached data object.
    DWORD _dwAttribAndCacheResults;
    DWORD _dwAttribAndCacheMask;
    DWORD _dwAttribCompatCacheResults;
    DWORD _dwAttribCompatCacheMask;
    BOOL _fItemPidlsRagged; // set to true if have any rugged pidls.
};
                

CShellItemArray::CShellItemArray()
{
    ASSERT(0 == _cidl);
    ASSERT(NULL == _ppidl);
    ASSERT(NULL == _pshf);
    ASSERT(NULL == _pdo);

    _fItemPidlsRagged = TRUE;
    _cRef = 1;
}

CShellItemArray::~CShellItemArray()
{
    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pshf);

    ILFree(_pidlParent); // may be null

    if (NULL != _ppidl)
    {
        FreeIDListArray(_ppidl,_cidl);
    }
}

HRESULT CShellItemArray::Initialize(LPCITEMIDLIST pidlParent, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *ppidl)
{
    if ((cidl > 1) && !ppidl || !psf)
    {
        return E_INVALIDARG;
    }

    if (pidlParent)
    {
        _pidlParent = ILClone(pidlParent);  // proceed on alloc failure, just won't use.
    }

    _pshf = psf;
    _pshf->AddRef();

    HRESULT hr = S_OK;
    if (cidl)
    {
        // if there are items then make a copy
        hr = _CloneIDListArray(cidl, ppidl, &_cidl, &_ppidl);
    }

    // on error rely on destructor to do the cleanup
    return hr;
}   

// IUnknown
STDMETHODIMP CShellItemArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CShellItemArray, IShellItemArray),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellItemArray::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellItemArray::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShellItemArray::BindToHandler(IBindCtx *pbc, REFGUID rbhid, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_FAIL;

    if (_pshf)
    {
        // currently only allow bind to IDataObject and
        // cache the result.        
        if (BHID_DataObject == rbhid)
        {
            if (NULL == _pdo)
            {
                _pshf->GetUIObjectOf(NULL, _cidl, (LPCITEMIDLIST *)_ppidl, IID_PPV_ARG_NULL(IDataObject, &_pdo));
            }

            if (_pdo)
            {
                hr = _pdo->QueryInterface(riid, ppvOut);
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

// This should probably take a flag that does an or'ing of attributes but this
// currrently isn't implemented. Do have comments on what the changes would be.
HRESULT CShellItemArray::GetAttributes(SIATTRIBFLAGS dwAttribFlags, SFGAOF sfgaoMask, SFGAOF *psfgaoAttribs)
{
    DWORD dwAttrib;
    HRESULT hr = E_FAIL;
    
    if (dwAttribFlags > (dwAttribFlags & SIATTRIBFLAGS_MASK))
    {
        ASSERT(dwAttribFlags <= (dwAttribFlags & SIATTRIBFLAGS_MASK));
        return E_INVALIDARG;
    }
    
    if (SIATTRIBFLAGS_OR == dwAttribFlags)
    {
        ASSERT(SIATTRIBFLAGS_OR != dwAttribFlags); // or'ing is currently not implemented.
        return E_INVALIDARG;
    }

    if (_pshf)
    {
        DWORD dwAttribMask = sfgaoMask;
        DWORD *pdwCacheMask = NULL;
        DWORD *pdwCacheResults = NULL;

        // setup to point to proper Cached values.
        switch(dwAttribFlags)
        {
        case SIATTRIBFLAGS_AND:
            pdwCacheMask = &_dwAttribAndCacheMask;
            pdwCacheResults = &_dwAttribAndCacheResults;
            break;
        case SIATTRIBFLAGS_APPCOMPAT:
            pdwCacheMask = &_dwAttribCompatCacheMask;
            pdwCacheResults = &_dwAttribCompatCacheResults;
            break;
        default:
            ASSERT(0); // i don't know how to handle this flag.
            break;
        }

        dwAttribMask &= ~(*pdwCacheMask); // only ask for the bits we don't already have.

        dwAttrib = dwAttribMask;

        if (dwAttrib) 
        {
            if (0 == _cidl)
            { 
                dwAttrib = 0;
            }
            else
            {
                // if know this is not a ragged pidl and calling with the APPCOMPAT flag
                // then calls GetAttributesOf for all the items in one call to the
                // shellFolder.
                    
                if (!_fItemPidlsRagged && (SIATTRIBFLAGS_APPCOMPAT == dwAttribFlags))
                {
                    hr = _pshf->GetAttributesOf(_cidl, (LPCITEMIDLIST *)_ppidl, &dwAttrib);
                }
                else
                {
                    LPITEMIDLIST *pCurItem = _ppidl;
                    UINT itemCount = _cidl;
                    DWORD dwAttribLoopResult = -1; // set all result bits for and, if going to or set to zero

                    while (itemCount--)
                    {
                        DWORD dwAttribTemp = dwAttrib;
                        IShellFolder *psfNew;
                        LPCITEMIDLIST pidlChild;

                        hr = SHBindToFolderIDListParent(_pshf, *pCurItem, IID_PPV_ARG(IShellFolder, &psfNew), &pidlChild);

                        if (SUCCEEDED(hr))
                        {
                            hr = psfNew->GetAttributesOf(1, &pidlChild, &dwAttribTemp);
                            psfNew->Release();
                        }

                        if (FAILED(hr))
                        {
                            break;
                        }

                        dwAttribLoopResult &= dwAttribTemp; // could also do an or'ing here
                        
                        if (0 == dwAttribLoopResult) // if no attribs set and doing an and we can stop.
                        {
                            break;
                        }

                        ++pCurItem;
                    }

                    dwAttrib = dwAttribLoopResult; // update the attrib
                }
            }
        }
        else
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // remember those bits that we just got + 
            // those that we computed before
            *pdwCacheResults = dwAttrib | (*pdwCacheResults & *pdwCacheMask);

            // we know these are now valid, keep track of those +
            // if they gave us more than we asked for, cache them too
            *pdwCacheMask |= dwAttribMask | dwAttrib;

            // don't return anything that wasn't asked for. defview code relies on this.
            *psfgaoAttribs = (*pdwCacheResults & sfgaoMask); 
        }
    }

    return hr;
}

STDMETHODIMP CShellItemArray::GetCount(DWORD *pdwNumItems)
{
    *pdwNumItems = _cidl;
    return S_OK;
}

// way to get zero based index ShellItem without having to
// go through enumerator overhead.
STDMETHODIMP CShellItemArray::GetItemAt(DWORD dwIndex, IShellItem **ppsi)
{
    *ppsi = NULL;

    if (dwIndex >= _cidl)
    {
        return E_FAIL;
    }
    
    ASSERT(_ppidl);

    LPITEMIDLIST pidl = *(_ppidl + dwIndex);

    // if GetItemAt is called a lot may want to
    // a) get the pshf pidl to pass to SHCreateshellItem so doesn't have to create each time
    // b) see if always asking for first item and is so maybe cache the shellItem
    return SHCreateShellItem(NULL, _pshf, pidl, ppsi);
}

STDMETHODIMP CShellItemArray::EnumItems(IEnumShellItems **ppenumShellItems)
{
    return _CreateShellItemEnum(_pidlParent, _pshf, NULL, GUID_NULL, _cidl, 
        (LPCITEMIDLIST *) _ppidl, IID_PPV_ARG(IEnumShellItems, ppenumShellItems));
}

HRESULT CShellItemArray::_CloneIDListArray(UINT cidl, LPCITEMIDLIST *apidl, UINT *pcidl, LPITEMIDLIST **papidl)
{
    HRESULT hr;
    LPITEMIDLIST *ppidl;

    *papidl = NULL;

    _fItemPidlsRagged = FALSE;

    if (cidl && apidl)
    {
        ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            LPITEMIDLIST *apidlFrom = (LPITEMIDLIST *) apidl;
            LPITEMIDLIST *apidlTo = ppidl;

            hr = S_OK;
            for (UINT i = 0; i < cidl ; i++)
            {
                hr = SHILClone(*apidlFrom, apidlTo);
                if (FAILED(hr))
                {
                    FreeIDListArray(ppidl, i);
                    ppidl = NULL;
                    break;
                }
                
                // if more than one item in list then set singeItemPidls to false
                if (!ILIsEmpty(_ILNext(*apidlTo)))
                {
                    _fItemPidlsRagged = TRUE;
                }

                ++apidlFrom;
                ++apidlTo;
            }   
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        ppidl = NULL;
        hr = S_FALSE;   // success by empty
    }

    if (SUCCEEDED(hr))
    {
        *papidl = ppidl;
        *pcidl = cidl;
    }
    else
    {
        _fItemPidlsRagged = TRUE;
    }
    return hr;
}

SHSTDAPI SHCreateShellItemArray(LPCITEMIDLIST pidlParent, IShellFolder *psf, UINT cidl,
                                LPCITEMIDLIST *ppidl, IShellItemArray **ppsiItemArray)
{
    HRESULT hr = E_OUTOFMEMORY;
    CShellItemArray *pItemArray = new CShellItemArray();
    if (pItemArray)
    {
        hr = pItemArray->Initialize(pidlParent, psf, cidl, ppidl);
        if (FAILED(hr))
        {
            pItemArray->Release();
            pItemArray = NULL;
        }
    }
    *ppsiItemArray = pItemArray;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\inistg.cpp ===
#include "shellprv.h"
#pragma  hdrstop

class CPropertySetStg;

class CPropertyStg : public IPropertyStorage
{
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IPropertyStorage
    STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgpropvar[]);
    STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgpropvar[], PROPID propidNameFirst);
    STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert(void);
    STDMETHODIMP Enum(IEnumSTATPROPSTG **ppenum);
    STDMETHODIMP SetTimes(const FILETIME *pctime, const FILETIME *patime,const FILETIME *pmtime);
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP Stat(STATPROPSETSTG *pstatpsstg);

    CPropertyStg(CPropertySetStg *ppss, REFFMTID fmtid, DWORD grfMode);
    void FMTIDPIDToSectionProp(REFFMTID fmtid, PROPID pid, LPTSTR pszSection, LPTSTR pszValueName);

private:
    ~CPropertyStg();
    BOOL _SectionValueName(const PROPSPEC *ppspec, 
                           LPTSTR pszSection, UINT cchSection, LPTSTR pszValueName, UINT cchValueName);
    HRESULT _ReadProp(const PROPSPEC *ppspec, PROPVARIANT *ppropvar);

    LONG            _cRef;
    CPropertySetStg *_ppss;     // back ptr to parent
    REFFMTID        _fmtid;
    DWORD           _grfMode;
};

class CPropertySetStg : public IPropertySetStorage
{
    friend CPropertyStg;
public:
    // IUnknown
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IPropertySetStorage
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    CPropertySetStg(LPCTSTR pszFolder, DWORD grfMode);

    LPCTSTR IniFile() { return _szIniFile; }

private:
    ~CPropertySetStg();
    HRESULT _LoadPropHandler();

    LONG        _cRef;
    DWORD       _grfMode;               // The mode that we opened the file in.
    TCHAR       _szIniFile[MAX_PATH];   // desktop.ini path
};


CPropertySetStg::CPropertySetStg(LPCTSTR pszFolder, DWORD grfMode) : _cRef(1), _grfMode(grfMode)
{
    PathCombine(_szIniFile, pszFolder, TEXT("desktop.ini"));
}

CPropertySetStg::~CPropertySetStg()
{
}

STDMETHODIMP CPropertySetStg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPropertySetStg, IPropertySetStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPropertySetStg::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropertySetStg::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPropertySetStg::_LoadPropHandler()
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertySetStg::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, 
                                     DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPropertySetStg::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = new CPropertyStg(this, fmtid, grfMode);
    return *pppropstg ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CPropertySetStg::Delete(REFFMTID fmtid)
{
    return STG_E_ACCESSDENIED;
}

STDMETHODIMP CPropertySetStg::Enum(IEnumSTATPROPSETSTG **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


CPropertyStg::CPropertyStg(CPropertySetStg *ppss, REFFMTID fmtid, DWORD grfMode) : _ppss(ppss), _fmtid(fmtid), _grfMode(grfMode)
{
    _ppss->AddRef();
}

CPropertyStg::~CPropertyStg()
{
    _ppss->Release();
}

STDMETHODIMP CPropertyStg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPropertyStg, IPropertyStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPropertyStg::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropertyStg::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

BOOL CPropertyStg::_SectionValueName(const PROPSPEC *ppspec, 
                                     LPTSTR pszSection, UINT cchSection,
                                     LPTSTR pszValueName, UINT cchValueName)
{
    *pszSection = *pszValueName = 0;

    if (_fmtid == FMTID_SummaryInformation)
    {
        if (PIDSI_COMMENTS == ppspec->propid)
        {
            lstrcpyn(pszSection, TEXT(".ShellClassInfo"), cchSection);
            lstrcpyn(pszValueName, TEXT("InfoTip"), cchValueName);
        }
    }

    if (!*pszSection || !*pszValueName)
    {
        if (PID_CODEPAGE < ppspec->propid)
        {
            SHStringFromGUID(_fmtid, pszSection, cchSection);
            if (PRSPEC_LPWSTR == ppspec->ulKind)
            {
                SHUnicodeToTChar(ppspec->lpwstr, pszValueName, cchValueName);
            }
            else if (PRSPEC_PROPID == ppspec->ulKind)
            {
                wnsprintf(pszValueName, cchValueName, TEXT("Prop%d"), ppspec->propid);
            }
        }
    }
    return (*pszSection && *pszValueName) ? TRUE : FALSE;
}

HRESULT CPropertyStg::_ReadProp(const PROPSPEC *ppspec, PROPVARIANT *ppropvar)
{
    PropVariantInit(ppropvar);  // init out param to VT_EMPTY
    HRESULT hr = S_FALSE;

    TCHAR szSection[128], szPropName[128];
    if (_SectionValueName(ppspec, szSection, ARRAYSIZE(szSection), szPropName, ARRAYSIZE(szPropName)))
    {
        TCHAR szValue[128];
        UINT cch = GetPrivateProfileString(szSection, szPropName, TEXT(""), szValue, ARRAYSIZE(szValue), _ppss->IniFile());
        if (cch)
        {
            hr = SHStrDup(szValue, &ppropvar->pwszVal);
            if (SUCCEEDED(hr))
                ppropvar->vt = VT_LPWSTR;
        }
    }
    return hr;
}

STDMETHODIMP CPropertyStg::ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgpropvar[])
{
    HRESULT hr = S_FALSE;
    UINT cRead = 0;
    for (UINT i = 0; i < cpspec; i++)
    {
        hr = _ReadProp(&rgpspec[i], &rgpropvar[i]);
        if (S_OK == hr)
        {
            cRead++;
        }

        if (FAILED(hr))
        {
            FreePropVariantArray(i, rgpropvar);
            cRead = 0;
            break;
        }
    }

    if (cRead)
        hr = S_OK;  // at least one non VT_EMPTY property read

    return hr;
}

STDMETHODIMP CPropertyStg::WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgpropvar[], PROPID propidNameFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Revert(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Enum(IEnumSTATPROPSTG **ppenum)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::SetTimes(const FILETIME *pctime, const FILETIME *patime,const FILETIME *pmtime)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyStg::Stat(STATPROPSETSTG *pstatpsstg)
{
    return E_NOTIMPL;
}

STDAPI SHCreatePropStgOnFolder(LPCTSTR pszFolder, DWORD grfMode, IPropertySetStorage **ppss)
{
    *ppss = (IPropertySetStorage *)new CPropertySetStg(pszFolder, grfMode);
    return *ppss ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\limitinput.cpp ===
/* ************************************************************** *\
   ToddB's Super Cool Balloon ToolTip InputLimiter

   Copyright Microsoft 1998
\* ************************************************************** */

#include "shellprv.h"
#include "ids.h"

#define IsTextPtr(pszText)      ((LPSTR_TEXTCALLBACK != pszText) && !IS_INTRESOURCE(pszText))
#define CHAR_IN_RANGE(ch,l,h)   ((ch >= l) && (ch <= h))

#define LIMITINPUTTIMERID       472

// ************************************************************************************************
// CInputLimiter class description
// ************************************************************************************************

class CInputLimiter : public tagLIMITINPUT
{
public:
    CInputLimiter();
    ~CInputLimiter();

    BOOL SubclassEditControl(HWND hwnd, const LIMITINPUT *pli);

protected:
    BOOL OnChar(HWND hwnd, WPARAM & wParam, LPARAM lParam);
    LRESULT OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void ShowToolTip();
    void HideToolTip();
    void CreateToolTipWindow();
    BOOL IsValidChar(TCHAR ch, BOOL bPaste);

    static LRESULT CALLBACK SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

    HWND        m_hwnd;             // the subclassed edit control hwnd
    HWND        m_hwndToolTip;      // the tooltip control
    UINT_PTR    m_uTimerID;         // the timer id
    BOOL        m_dwCallbacks;      // true if any data is callback data.
};

CInputLimiter::CInputLimiter()
{
    // our allocation function should have zeroed our memory.  Check to make sure:
    ASSERT(0==m_hwndToolTip);
    ASSERT(0==m_uTimerID);
}

CInputLimiter::~CInputLimiter()
{
    // we might have allocated some strings, if we did delete them
    if (IsTextPtr(pszFilter))
    {
        delete pszFilter;
    }
    if (IsTextPtr(pszTitle))
    {
        delete pszTitle;
    }
    if (IsTextPtr(pszMessage))
    {
        delete pszMessage;
    }
}

BOOL CInputLimiter::SubclassEditControl(HWND hwnd, const LIMITINPUT *pli)
{
    if (!IsWindow(hwnd))
    {
        // must have a valid hwnd
        TraceMsg(TF_WARNING, "Invalid HWND passed to CInputLimiter::SubclassEditControl");
        return FALSE;
    }

    m_hwnd = hwnd;

    // validate all the data passed in the pli structure.  Return false if
    // any of it is out of whack.
    dwMask = pli->dwMask;

    if (LIM_FLAGS & dwMask)
    {
        dwFlags = pli->dwFlags;

        if ((LIF_FORCEUPPERCASE|LIF_FORCELOWERCASE) == ((LIF_FORCEUPPERCASE|LIF_FORCELOWERCASE) & dwFlags))
        {
            // cannot use both ForceUpperCase and ForceLowerCase flags
            TraceMsg(TF_WARNING, "cannot use both ForceUpperCase and ForceLowerCase flags");
            return FALSE;
        }
    }
    else
    {
        ASSERT(0==dwFlags);
    }

    if (LIM_HINST & dwMask)
    {
        hinst = pli->hinst;
    }
    else
    {
        ASSERT(0==hinst);
    }

    // keep track of which fields require a valid hwndNotify
    ASSERT(0==m_dwCallbacks);

    if (LIM_FILTER & dwMask)
    {
        if (LIF_CATEGORYFILTER & dwFlags)
        {
            // category filters are not callbacks or int resources even though the data looks like it is.
            // The don't need any validation.
            pszFilter = pli->pszFilter;
        }
        else if (LPSTR_TEXTCALLBACK == pli->pszFilter)
        {
            pszFilter = pli->pszFilter;
            m_dwCallbacks |= LIM_FILTER;
        }
        else if (IS_INTRESOURCE(pli->pszFilter))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for filter");
                return FALSE;
            }

            // We need to load the target string upfront and store it in a buffer.
            DWORD cchSize = 64;
            DWORD cchLoaded;

            for (;;)
            {
                pszFilter = new TCHAR[cchSize];
                if (!pszFilter)
                {
                    // Out of memory
                    TraceMsg(TF_WARNING, "Out of memory in CInputLimiter::SubclassEditControl");
                    return FALSE;
                }

                cchLoaded = LoadString(hinst, PtrToUint(pli->pszFilter), pszFilter, cchSize);
                if (0 == cchLoaded)
                {
                    // Could not load filter resource, pszFilter will get deleted in our destructor
                    TraceMsg(TF_WARNING, "Could not load filter resource");
                    return FALSE;
                }
                else if (cchLoaded >= cchSize-1)
                {
                    // didn't fit in the given buffer, try a larger buffer
                    delete [] pszFilter;
                    cchSize *= 2;
                }
                else
                {
                    // the string loaded successfully
                    break;
                }
            }

            ASSERT(IS_VALID_STRING_PTR(pszFilter,-1));
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszFilter,-1));
            pszFilter = new TCHAR[lstrlen(pli->pszFilter)+1];
            if (!pszFilter)
            {
                // Out of memory
                TraceMsg(TF_WARNING, "CInputLimiter Out of memory");
                return FALSE;
            }
            // strcpy okay, we just allocated it
            StrCpy(pszFilter, pli->pszFilter);
        }
    }
    else
    {
        ASSERT(0==pszFilter);
    }

    if (!(LIF_WARNINGOFF & dwFlags) && !((LIM_TITLE|LIM_MESSAGE) & dwMask))
    {
        // if warnings are on then at least one of Title or Message is required.
        TraceMsg(TF_WARNING, "if warnings are on then at least one of Title or Message is required");
        return FALSE;
    }

    if (LIM_TITLE & dwMask)
    {
        if (LPSTR_TEXTCALLBACK == pli->pszTitle)
        {
            pszTitle = pli->pszTitle;
            m_dwCallbacks |= LIM_TITLE;
        }
        else if (IS_INTRESOURCE(pli->pszTitle))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for title");
                return FALSE;
            }
            // REVIEW: Does the title need to be laoded up fromt or will the ToolTip control do this
            // for us?
            pszTitle = pli->pszTitle;
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszTitle,-1));
            pszTitle = new TCHAR[lstrlen(pli->pszTitle)+1];
            if (!pszTitle)
            {
                return FALSE;
            }
            // strcpy okay, we just allocated it
            StrCpy(pszTitle, pli->pszTitle);
        }
    }
    else
    {
        ASSERT(0==pszTitle);
    }

    if (LIM_MESSAGE & dwMask)
    {
        if (LPSTR_TEXTCALLBACK == pli->pszMessage)
        {
            pszMessage = pli->pszMessage;
            m_dwCallbacks |= LIM_MESSAGE;
        }
        else if (IS_INTRESOURCE(pli->pszMessage))
        {
            if (!hinst)
            {
                // must have valid hinst in order to use int resources
                TraceMsg(TF_WARNING, "must have valid hinst in order to use int resources for message");
                return FALSE;
            }
            // We will let the ToolTip control load this string for us
            pszMessage = pli->pszMessage;
        }
        else
        {
            ASSERT(IS_VALID_STRING_PTR(pli->pszMessage,-1));
            pszMessage = new TCHAR[lstrlen(pli->pszMessage)+1];
            if (!pszMessage)
            {
                return FALSE;
            }
            // strcpy okay, we just allocated it
            StrCpy(pszMessage, pli->pszMessage);
        }
    }
    else
    {
        ASSERT(0==pszMessage);
    }

    if (LIM_ICON & dwMask)
    {
        hIcon = pli->hIcon;

        if (I_ICONCALLBACK == hIcon)
        {
            m_dwCallbacks |= LIM_ICON;
        }
    }

    if (LIM_NOTIFY & dwMask)
    {
        hwndNotify = pli->hwndNotify;
    }
    else
    {
        hwndNotify = GetParent(m_hwnd);
    }

    if (m_dwCallbacks && !IsWindow(hwndNotify))
    {
        // invalid notify window
        TraceMsg(TF_WARNING, "invalid notify window");
        return FALSE;
    }

    if (LIM_TIMEOUT & dwMask)
    {
        iTimeout = pli->iTimeout;
    }
    else
    {
        iTimeout = 10000;
    }

    if (LIM_TIPWIDTH & dwMask)
    {
        cxTipWidth = pli->cxTipWidth;
    }
    else
    {
        cxTipWidth = 500;
    }

    // everything in the *pli structure is valid
    TraceMsg(TF_GENERAL, "pli structure is valid");

    return SetWindowSubclass(hwnd, CInputLimiter::SubclassProc, 0, (LONG_PTR)this);
}

LRESULT CALLBACK CInputLimiter::SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    CInputLimiter * pthis = (CInputLimiter*)dwRefData;

    switch (uMsg)
    {
    case WM_CHAR:
        if (!pthis->OnChar(hwnd, wParam, lParam))
        {
            return 0;
        }
        break;

    case WM_KILLFOCUS:
        pthis->HideToolTip();
        break;

    case WM_TIMER:
        if (LIMITINPUTTIMERID == wParam)
        {
            pthis->HideToolTip();
            return 0;
        }
        break;

    case WM_PASTE:
        // Paste handler handles calling the super wnd proc when needed
        return pthis->OnPaste(hwnd, wParam, lParam);

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, CInputLimiter::SubclassProc, uID);
        delete pthis;
        break;

    default:
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL CInputLimiter::IsValidChar(TCHAR ch, BOOL bPaste)
{
    BOOL  bValidChar = FALSE;           // start by assuming the character is invalid

    if (LIF_CATEGORYFILTER & dwFlags)
    {
        TraceMsg(TF_GENERAL, "Processing LIF_CATEGORYFILTER: <0x%08x>", (WORD)pszFilter);
        // pszFilter is actually a bit field with valid character types
        WORD CharType = 0;
#define GETSTRINGTYPEEX_MASK    0x1FF

        // We only need to call GetStringTypeEx if some of the CT_TYPE1 values are being asked for
        if (((WORD)pszFilter) & GETSTRINGTYPEEX_MASK)
        {
            TraceMsg(TF_GENERAL, "Calling GetStringTypeEx");

            // We treat ch as a one character long string.
            // REVIEW: How are DBCS characters handled?  Is this fundamentally flawed for win9x?
            EVAL(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, (LPTSTR)&ch, 1, &CharType));
        }

        if (((WORD)pszFilter) & (WORD)CharType)
        {
            TraceMsg(TF_GENERAL, "GetStringTypeEx matched a character");
            // GetStringTypeEx found the string in one of the selected groups
            bValidChar = !(LIF_EXCLUDEFILTER & dwFlags);
        }
        else
        {
            TraceMsg(TF_GENERAL, "Checking the extra types not supported by GetStringTypeEx");
            // check for the string in our special groups.  We will temporarily use bValidChar
            // to indicate whether the character was found, not whether it's valid.
            if (LICF_BINARYDIGIT & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('0'), TEXT('1')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_OCTALDIGIT & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('0'), TEXT('7')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_ATOZUPPER & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('A'), TEXT('Z')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }
            if (LICF_ATOZLOWER & PtrToUint(pszFilter))
            {
                if (CHAR_IN_RANGE(ch, TEXT('a'), TEXT('z')))
                {
                    bValidChar = TRUE;
                    goto charWasFound;
                }
            }

charWasFound:
            // right now we have perverted the meaning of bValidChar to indicate if the
            // character was found or not.  We now convert the meaning from "was the
            // character found" to "is the character valid" by considering LIF_EXCLUDEFILTER.
            if (LIF_EXCLUDEFILTER & dwFlags)
            {
                bValidChar = !bValidChar;
            }
        }
    }
    else
    {
        TraceMsg(TF_GENERAL, "Processing string based filter");
        // pszFilter points to a NULL terminated string of characters
        LPTSTR psz = StrChr(pszFilter, ch);

        if (LIF_EXCLUDEFILTER & dwFlags)
        {
            bValidChar = (NULL == psz);
        }
        else
        {
            bValidChar = (NULL != psz);
        }
    }

    return bValidChar;
}

BOOL CInputLimiter::OnChar(HWND hwnd, WPARAM & wParam, LPARAM lParam)
{
    // if the char is a good one return TRUE, this will pass the char on to the
    // default window proc.  For a bad character do a beep and then display the
    // ballon tooltip pointing at the control.
    TCHAR ch = (TCHAR)wParam;

    if (LIM_FILTER & m_dwCallbacks)
    {
        // If we have callbacks then we need to update the filter and/or mask text.
        // Otherwise the filter and/or mask text is already correct.
        NMLIFILTERINFO lidi = {0};
        lidi.hdr.hwndFrom = m_hwnd;
        lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
        lidi.hdr.code = LIN_GETFILTERINFO;
        lidi.li.dwMask = LIM_FILTER & m_dwCallbacks;

        SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

        pszFilter = lidi.li.pszFilter;

        // REVIEW: we should have a way for the notify hanlder to say "store this
        // result and stop asking me for the filter to use every time".
    }

    if (LIF_FORCEUPPERCASE & dwFlags)
    {
        ch = (TCHAR)CharUpper((LPTSTR)ch);
    }
    else if (LIF_FORCELOWERCASE & dwFlags)
    {
        ch = (TCHAR)CharLower((LPTSTR)ch);
    }

    if (IsValidChar(ch, FALSE))
    {
        if (LIF_HIDETIPONVALID & dwFlags)
        {
            HideToolTip();
        }

        // We might have upper or lower cased ch, so reflect this in wParam.  Since
        // wParam was passed by reference this will effect the message we forward
        // on to the original window proc.
        wParam = (WPARAM)ch;

        return TRUE;
    }
    else
    {
        // if we get here then an invalid character was entered

        if (LIF_NOTIFYONBADCHAR & dwFlags)
        {
            NMLIBADCHAR libc = {0};
            libc.hdr.hwndFrom = m_hwnd;
            libc.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
            libc.hdr.code = LIN_BADCHAR;
            libc.wParam = wParam;           // use the original, non case shifted wParam
            libc.lParam = lParam;

            SendMessage(hwndNotify, WM_NOTIFY, libc.hdr.idFrom, (LPARAM)&libc);
        }

        if (!(LIF_SILENT & dwFlags))
        {
            MessageBeep(MB_OK);
        }

        if (!(LIF_WARNINGOFF & dwFlags))
        {
            ShowToolTip();
        }

        return FALSE;
    }
}

LRESULT CInputLimiter::OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // There are hundreds of lines of code in user to successfully handle a paste into an edit control.
    // We need to leverage all that code while still disallowing invalid input to result from the paste.
    // As a result, what we need to do is to get the clip board data, validate that data, place the
    // valid data back onto the clipboard, call the default window proc to let user do it's thing, and
    // then restore the clipboard to it's original format.
    if (OpenClipboard(hwnd))
    {
        HANDLE hdata;
        UINT iFormat;
        DWORD cchBad = 0;           // count of the number of bad characters

        // REVIEW: Should this be based on the compile type or the window type?
        // Compile time check for the correct clipboard format to use:
        if (sizeof(WCHAR) == sizeof(TCHAR))
        {
            iFormat = CF_UNICODETEXT;
        }
        else
        {
            iFormat = CF_TEXT;
        }

        hdata = GetClipboardData(iFormat);

        if (hdata)
        {
            LPTSTR pszData;
            pszData = (LPTSTR)GlobalLock(hdata);
            if (pszData)
            {

                // we need to copy the original data because the clipboard owns the hdata
                // pointer.  That data will be invalid after we call SetClipboardData.
                // We start by calculating the size of the data:
                DWORD dwSize = (DWORD)GlobalSize(hdata);

                // Use the prefered GlobalAlloc for clipboard data
                HANDLE hClone = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize + sizeof(TCHAR));
                HANDLE hNew = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize + sizeof(TCHAR));
                if (hClone && hNew)
                {
                    LPTSTR pszClone = (LPTSTR)GlobalLock(hClone);
                    LPTSTR pszNew = (LPTSTR)GlobalLock(hNew);
                    if (pszClone && pszNew)
                    {
                        int iNew = 0;

                        // copy the original data as-is
                        memcpy(pszClone, pszData, (size_t)dwSize);
                        // ensure that it's NULL terminated
                        pszClone[(dwSize / sizeof(TCHAR))] = TEXT('\0');

                        // at this point we are done with hdata so unlock it
                        GlobalUnlock(hdata);
                        hdata = NULL;

                        // For a paste, we only call the filter callback once, not once for each
                        // character.  Why?  Because.
                        if (LIM_FILTER & m_dwCallbacks)
                        {
                            // If we have callbacks then we need to update the filter and/or mask text.
                            // Otherwise the filter and/or mask text is already correct.
                            NMLIFILTERINFO lidi = {0};
                            lidi.hdr.hwndFrom = m_hwnd;
                            lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
                            lidi.hdr.code = LIN_GETFILTERINFO;
                            lidi.li.dwMask = LIM_FILTER & m_dwCallbacks;

                            SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

                            pszFilter = lidi.li.pszFilter;

                            // REVIEW: we should have a way for the notify hanlder to say "store this
                            // result and stop asking me for the filter to use every time".
                        }

                        for (LPTSTR psz = pszClone; *psz; psz++)
                        {
                            // we do the Upper/Lower casing one character at a time because we don't want to
                            // alter pszClone.  pszClone is used later to restore the ClipBoard.
                            if (LIF_FORCEUPPERCASE & dwFlags)
                            {
                                pszNew[iNew] = (TCHAR)CharUpper((LPTSTR)*psz);  // yes, this funky cast is correct.
                            }
                            else if (LIF_FORCELOWERCASE & dwFlags)
                            {
                                pszNew[iNew] = (TCHAR)CharLower((LPTSTR)*psz);  // yes, this funky cast is correct.
                            }
                            else
                            {
                                pszNew[iNew] = *psz;
                            }

                            if (IsValidChar(pszNew[iNew], TRUE))
                            {
                                iNew++;
                            }
                            else
                            {
                                if (LIF_NOTIFYONBADCHAR & dwFlags)
                                {
                                    NMLIBADCHAR libc = {0};
                                    libc.hdr.hwndFrom = m_hwnd;
                                    libc.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
                                    libc.hdr.code = LIN_BADCHAR;
                                    libc.wParam = (WPARAM)pszClone[iNew + cchBad];  // use the original, non case shifted chat
                                    libc.lParam = lParam;

                                    SendMessage(hwndNotify, WM_NOTIFY, libc.hdr.idFrom, (LPARAM)&libc);
                                }

                                cchBad++;

                                if (LIF_PASTECANCEL & dwFlags)
                                {
                                    iNew = 0;
                                    break;
                                }
                                if (LIF_PASTESTOP & dwFlags)
                                {
                                    break;
                                }
                            }
                        }
                        pszNew[iNew] = NULL;

                        // If there are any characters in the paste buffer then we paste the validated string
                        if (*pszNew)
                        {
                            // we always set the new string.  Worst case it's identical to the old string
                            GlobalUnlock(hNew);
                            pszNew = NULL;
                            SetClipboardData(iFormat, hNew);
                            hNew = NULL;

                            // call the super proc to do the paste
                            DefSubclassProc(hwnd, WM_PASTE, wParam, lParam);

                            // The above call will have closed the clipboard on us.  We try to re-open it.
                            // If this fails it's no big deal, that simply means the SetClipboardData
                            // call below will fail which is good if somebody else managed to open the
                            // clipboard in the mean time.
                            OpenClipboard(hwnd);

                            // and then we set it back to the original value.
                            GlobalUnlock(hClone);
                            pszClone = NULL;
                            if (LIF_KEEPCLIPBOARD & dwFlags)
                            {
                                SetClipboardData(iFormat, hClone);
                                hClone = NULL;
                            }
                        }
                    }

                    if (pszClone)
                    {
                        GlobalUnlock(hClone);
                    }

                    if (pszNew)
                    {
                        GlobalUnlock(hNew);
                    }
                }

                if (hClone)
                {
                    GlobalFree(hClone);
                }

                if (hNew)
                {
                    GlobalFree(hNew);
                }

                // if we failed, unlock
                if (hdata)
                {
                    GlobalUnlock(hdata);
                }
            }
        }
        CloseClipboard();

        if (0 == cchBad)
        {
            // the entire paste was valid
            if (LIF_HIDETIPONVALID & dwFlags)
            {
                HideToolTip();
            }
        }
        else
        {
            // if we get here then at least one invalid character was pasted
            if (!(LIF_SILENT & dwFlags))
            {
                MessageBeep(MB_OK);
            }

            if (!(LIF_WARNINGOFF & dwFlags))
            {
                ShowToolTip();
            }
        }
    }
    return TRUE;
}

void CInputLimiter::ShowToolTip()
{
    TraceMsg(TF_GENERAL, "About to show the tooltip");

    if (!m_hwndToolTip)
    {
        CreateToolTipWindow();
    }

    // Set the tooltip display point
    RECT rc;
    GetWindowRect(m_hwnd, &rc);
    int x, y;
    x = (rc.left+rc.right)/2;
    if (LIF_WARNINGABOVE & dwFlags)
    {
        y = rc.top;
    }
    else if (LIF_WARNINGCENTERED & dwFlags)
    {
        y = (rc.top+rc.bottom)/2;
    }
    else
    {
        y = rc.bottom;
    }
    SendMessage(m_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG(x,y));

    TOOLINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.hwnd = m_hwnd;
    ti.uId = 1;
    if ((LIM_TITLE|LIM_MESSAGE|LIM_ICON) & m_dwCallbacks)
    {
        // If we have callbacks then we need to update the tooltip text.
        // Otherwise the tooltip text is already correct.
        NMLIDISPINFO lidi = {0};
        lidi.hdr.hwndFrom = m_hwnd;
        lidi.hdr.idFrom = GetWindowLong(m_hwnd, GWL_ID);
        lidi.hdr.code = LIN_GETDISPINFO;
        lidi.li.dwMask = (LIM_TITLE|LIM_MESSAGE|LIM_ICON) & m_dwCallbacks;

        SendMessage(hwndNotify, WM_NOTIFY, lidi.hdr.idFrom, (LPARAM)&lidi);

        // REARCHITECT How do we use the icon, bold title, message style tooltips?
        // Until I learn how I'm just using the message string.

        ti.lpszText = lidi.li.pszMessage;

        SendMessage(m_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
        if (lidi.li.pszTitle || lidi.li.hIcon)
        {
            SendMessage(m_hwndToolTip, TTM_SETTITLE, (WPARAM)lidi.li.hIcon, (LPARAM)lidi.li.pszTitle);
        }
    }

    // Show the tooltip
    SendMessage(m_hwndToolTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

    // Set a timer to hide the tooltip
    if (m_uTimerID)
    {
        KillTimer(NULL,LIMITINPUTTIMERID);
    }
    m_uTimerID = SetTimer(m_hwnd, LIMITINPUTTIMERID, iTimeout, NULL);
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
void CInputLimiter::CreateToolTipWindow()
{
    m_hwndToolTip = CreateWindow(
            TOOLTIPS_CLASS,
            NULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            m_hwnd,
            NULL,
            GetModuleHandle(NULL),
            NULL);

    if (m_hwndToolTip)
    {
        SetWindowPos(m_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        TOOLINFO ti = {0};
        RECT     rc = {2,2,2,2};

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRACK | TTF_TRANSPARENT;
        ti.hwnd = m_hwnd;
        ti.uId = 1;
        ti.hinst = hinst;
        // REARCHITECT: How do we use the icon, bold title, message style tooltips?
        // Until I learn how I'm just using the message string.
        ti.lpszText = pszMessage;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(m_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(m_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, cxTipWidth);
        SendMessage(m_hwndToolTip, TTM_SETMARGIN, 0, (LPARAM)&rc);
        if (pszTitle || hIcon)
        {
            // REARCHITECT: hIcon needs to be an image list index or some such.  Get details
            // on how this really works.
            SendMessage(m_hwndToolTip, TTM_SETTITLE, (WPARAM)hIcon, (LPARAM)pszTitle);
        }
    }
    else
    {
        // failed to create tool tip window, now what should we do?  Unsubclass ourselves?
        TraceMsg(TF_GENERAL, "Failed to create tooltip window");
    }
}

void CInputLimiter::HideToolTip()
{
    // When the timer fires we hide the tooltip window
    if (m_uTimerID)
    {
        KillTimer(m_hwnd,LIMITINPUTTIMERID);
        m_uTimerID = 0;
    }
    if (m_hwndToolTip)
    {
        SendMessage(m_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
    }
}

// allows caller to pass in already contructed LIMITINPUT structure...
HRESULT SHLimitInputEditWithFlags(HWND hwndEdit, LIMITINPUT * pli)
{
    HRESULT hr;
    CInputLimiter *pInputLimiter = new CInputLimiter;
    if (pInputLimiter)
    {
        if (pInputLimiter->SubclassEditControl(hwndEdit, pli))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
            delete pInputLimiter;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//  LimitInput
//
//      Limits the characters that can be entered into an edit box.  It intercepts WM_CHAR
//    messages and only allows certain characters through.  Some characters, such as backspace
//    are always allowed through.
//
//  Args:
//      hwndEdit        Handle to an edit control.  Results will be unpredictable if any other window
//                      type is passed in.
//
//      pli             Pointer to a LIMITINPUT structure that determines how the input is limited.
HRESULT SHLimitInputEditChars(HWND hwndEdit, LPCWSTR pszValidChars, LPCWSTR pszInvalidChars)
{
    LPWSTR pszMessage = NULL;

    LIMITINPUT li = {0};
    li.cbSize = sizeof(li);
    li.dwMask = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags = LIF_HIDETIPONVALID;
    li.hinst = g_hinst;
    if (pszValidChars)
    {
        // ick, li.pszFilter is used as const, but since CInputLimiter is derived from the struct itd be a
        // pain to define it as such.
        li.pszFilter = (LPWSTR)pszValidChars;
        li.dwFlags |= LIF_INCLUDEFILTER;
    }
    else
    {
        li.pszFilter = (LPWSTR)pszInvalidChars;
        li.dwFlags |= LIF_EXCLUDEFILTER;
    }

    // create the error message.
    PCWSTR pszChars = pszInvalidChars ? pszInvalidChars : pszValidChars;
    PWSTR pszSpacedChars = new WCHAR[2 * lstrlen(pszChars) + 1];
    if (pszSpacedChars)
    {
        // we're mimicing what IDS_INVALIDFN does for the known set of bad chars on the filesystem --
        // append each char and separate them by spaces.
        PWSTR psz = pszSpacedChars;
        for (int i = 0; i < lstrlen(pszChars); i++)
        {
            *psz++ = pszChars[i];
            *psz++ = L' ';
        }
        *psz = 0;

        int id = pszInvalidChars ? IDS_CHARSINVALID : IDS_CHARSVALID;
        pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(id), pszSpacedChars);

        delete [] pszSpacedChars;
    }

    if (pszMessage)
    {
        li.pszMessage = pszMessage;
    }
    else
    {
        // fall back to the old message
        li.pszMessage = MAKEINTRESOURCE(IDS_INVALIDFN);
    }

    HRESULT hr = SHLimitInputEditWithFlags(hwndEdit, &li);

    if (pszMessage)
    {
        LocalFree(pszMessage);
    }
    return hr;
}

HRESULT SHLimitInputEdit(HWND hwndEdit, IShellFolder *psf)
{
    IItemNameLimits *pinl;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        LPWSTR pszValidChars;
        LPWSTR pszInvalidChars;
        hr = pinl->GetValidCharacters(&pszValidChars, &pszInvalidChars);
        if (SUCCEEDED(hr))
        {
            hr = SHLimitInputEditChars(hwndEdit, pszValidChars, pszInvalidChars);

            if (pszValidChars)
                CoTaskMemFree(pszValidChars);
            if (pszInvalidChars)
                CoTaskMemFree(pszInvalidChars);
        }
        pinl->Release();
    }

    return hr;
}

typedef struct tagCBLIMITINPUT
{
    HRESULT hr;
    IShellFolder *psf;
} CBLIMITINPUT;

// Limiting the input on a combo box is special cased because you first
// have to find the edit box and then LimitInput on that.
BOOL CALLBACK FindTheEditBox(HWND hwnd, LPARAM lParam)
{
    // The combo box only has one child, subclass it
    CBLIMITINPUT *pcbli = (CBLIMITINPUT*)lParam;

    pcbli->hr = SHLimitInputEdit(hwnd, pcbli->psf);
    return FALSE;
}

HRESULT SHLimitInputCombo(HWND hwndComboBox, IShellFolder *psf)
{
    CBLIMITINPUT cbli;
    cbli.hr = E_FAIL;
    cbli.psf = psf;

    EnumChildWindows(hwndComboBox, FindTheEditBox, (LPARAM)&cbli);

    return cbli.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\itemhelp.cpp ===
#include "shellprv.h"


class CLocalCopyHelper  : public ILocalCopy 
                        , public IItemHandler
{
public:
    CLocalCopyHelper();
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // ILocalCopy methods
    STDMETHODIMP Download(LCFLAGS flags, IBindCtx *pbc, LPWSTR *ppszOut);
    STDMETHODIMP Upload(LCFLAGS flags, IBindCtx *pbc);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) { *pclsid = CLSID_LocalCopyHelper; return S_OK;}

    // IItemHandler
    STDMETHODIMP SetItem(IShellItem *psi);
    STDMETHODIMP GetItem(IShellItem **ppsi);

protected:
    ~CLocalCopyHelper();

    //  private methods
    HRESULT _InitCacheEntry(void);
    HRESULT _SetCacheName(void);
    HRESULT _FinishLocal(BOOL fReadOnly);
    HRESULT _GetLocalStream(DWORD grfMode, IStream **ppstm, FILETIME *pft);
    HRESULT _GetRemoteStream(DWORD grfMode, IBindCtx *pbc, IStream **ppstm, FILETIME *pft);

    // members
    long _cRef;
    IShellItem *_psi;
    LPWSTR _pszName;            //  name retrieved from psi
    LPWSTR _pszCacheName;       //  name used to ID cache entry
    LPCWSTR _pszExt;            //  points into _pszName

    //  caches of the MTIMEs for the streams
    FILETIME _ftRemoteGet;
    FILETIME _ftLocalGet;
    FILETIME _ftRemoteCommit;
    FILETIME _ftLocalCommit;
    
    BOOL _fIsLocalFile;         //  this is actually file system item (pszName is a FS path)
    BOOL _fMadeLocal;           //  we have already copied this item locally

    //  put this at the end so we can see all the rest of the pointers easily in debug
    WCHAR _szLocalPath[MAX_PATH];
};

CLocalCopyHelper::CLocalCopyHelper() : _cRef(1)
{
}

CLocalCopyHelper::~CLocalCopyHelper()
{
    ATOMICRELEASE(_psi);

    if (_pszName)
        CoTaskMemFree(_pszName);

    if (_pszCacheName)
        LocalFree(_pszCacheName);
}
    
STDMETHODIMP CLocalCopyHelper::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLocalCopyHelper, ILocalCopy),
        QITABENT(CLocalCopyHelper, IItemHandler),
        QITABENTMULTI(CLocalCopyHelper, IPersist, IItemHandler),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CLocalCopyHelper::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CLocalCopyHelper::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CLocalCopyHelper::SetItem(IShellItem *psi)
{
    if (!_psi)
    {
        SFGAOF flags = SFGAO_STREAM;
        if (SUCCEEDED(psi->GetAttributes(flags, &flags))
        && (flags & SFGAO_STREAM))
        {
            HRESULT hr = psi->GetDisplayName(SIGDN_FILESYSPATH, &_pszName);

            if (SUCCEEDED(hr))
            {
                _fIsLocalFile = TRUE;
            }
            else
                hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEEDITING, &_pszName);


            if (SUCCEEDED(hr))
            {
                _psi = psi;
                _psi->AddRef();
            }

            return hr;
        }
    }
    return E_UNEXPECTED;
}

STDMETHODIMP CLocalCopyHelper::GetItem(IShellItem **ppsi)
{
    *ppsi = _psi;

    if (_psi)
    {
        _psi->AddRef();
        return S_OK;
    }
    else
        return E_UNEXPECTED;
}

#define SZTEMPURL     TEXTW("temp:")
#define CCHTEMPURL    SIZECHARS(SZTEMPURL) -1

HRESULT CLocalCopyHelper::_SetCacheName(void)
{
    ASSERT(!_pszCacheName);
    int cchCacheName = lstrlenW(_pszName) + CCHTEMPURL + 1;
    _pszCacheName = (LPWSTR) LocalAlloc(LPTR, CbFromCchW(cchCacheName));
    
    if (_pszCacheName)
    {
        LPCWSTR pszName = _pszName;

        StringCchCopy(_pszCacheName, cchCacheName, SZTEMPURL);
        StringCchCat(_pszCacheName, cchCacheName, _pszName);

        if (UrlIs(_pszName, URLIS_URL))
        {
            //  need to push past all slashes
            pszName = StrRChr(pszName, NULL, TEXT('/'));
        }
            
        //  the cache APIs need the extension without the dot
        if (pszName)
        {
            _pszExt = PathFindExtension(pszName);
            
            if (*_pszExt)
                _pszExt++;
        }

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

void _GetMTime(IStream *pstm, FILETIME *pft)
{
    //  see if we can get an accurate Mod time
    STATSTG stat;
    if (S_OK == pstm->Stat(&stat, STATFLAG_NONAME))
        *pft = stat.mtime;
    else     
    {
        GetSystemTimeAsFileTime(pft);
    }
}

HRESULT CLocalCopyHelper::_InitCacheEntry(void)
{
    if (!_pszCacheName)
    {
        HRESULT hr = _SetCacheName();

        if (SUCCEEDED(hr) && !CreateUrlCacheEntryW(_pszCacheName, 0, _pszExt, _szLocalPath, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LocalFree(_pszCacheName);
            _pszCacheName = NULL;
        }

        return hr;
    }
    return S_OK;
}

HRESULT CLocalCopyHelper::_GetLocalStream(DWORD grfMode, IStream **ppstm, FILETIME *pft)
{
    HRESULT hr = _InitCacheEntry();
  
    if (SUCCEEDED(hr))
    {
        hr = SHCreateStreamOnFileW(_szLocalPath, grfMode, ppstm);

        if (SUCCEEDED(hr))
            _GetMTime(*ppstm, pft);
    }

    return hr;
}

HRESULT CLocalCopyHelper::_FinishLocal(BOOL fReadOnly)
{
    HRESULT hr = S_OK;
    FILETIME ftExp = {0};
    
    if (CommitUrlCacheEntryW(_pszCacheName, _szLocalPath, ftExp, _ftLocalGet, STICKY_CACHE_ENTRY, NULL, 0, NULL, NULL))
    {
        //  we could also check _GetRemoteStream(STGM_WRITE)
        //  and if it fails we could fail this as well.
        if (fReadOnly)
            SetFileAttributesW(_szLocalPath, FILE_ATTRIBUTE_READONLY);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}


HRESULT CLocalCopyHelper::_GetRemoteStream(DWORD grfMode, IBindCtx *pbc, IStream **ppstm, FILETIME *pft)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (!pbc)
        CreateBindCtx(0, &pbc);
    else
        pbc->AddRef();
        
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
        {
            bo.grfMode = grfMode;
            pbc->SetBindOptions(&bo);
        }

        hr = _psi->BindToHandler(pbc, BHID_Storage, IID_PPV_ARG(IStream, ppstm));

        if (SUCCEEDED(hr))
            _GetMTime(*ppstm, pft);
            
        pbc->Release();
    }

    return hr;
}

STDMETHODIMP CLocalCopyHelper::Download(LCFLAGS flags, IBindCtx *pbc, LPWSTR *ppsz)
{
    if (!_psi)
        return E_UNEXPECTED;
        
    HRESULT hr;
    if (_fIsLocalFile)
    {
        hr = SHStrDup(_pszName, ppsz);
    }
    else if (_fMadeLocal && !(flags & LC_FORCEROUNDTRIP))  
    {
        hr = S_OK;
    }
    else if (flags & LC_SAVEAS)
    {
        hr = _InitCacheEntry();
        if (SUCCEEDED(hr))
        {
            _fMadeLocal = TRUE;
        }
    }
    else  
    {
        //  get the local stream first because it is the cheapest operation.
        IStream *pstmDst;
        hr = _GetLocalStream(STGM_WRITE, &pstmDst, &_ftLocalGet);

        if (SUCCEEDED(hr))
        {
            //  we need to create the temp file here
            IStream *pstmSrc;
            
            hr = _GetRemoteStream(STGM_READ, pbc, &pstmSrc, &_ftRemoteGet);

            if (SUCCEEDED(hr))
            {
                hr = CopyStreamUI(pstmSrc, pstmDst, NULL, 0);

                pstmSrc->Release();
                // now that we have copied the stream

            }

            pstmDst->Release();

            //  need to release teh dest stream first
            if (SUCCEEDED(hr))
            {
                //  finish cleaning up the local file
                hr = _FinishLocal(flags & LCDOWN_READONLY);
                _fMadeLocal = SUCCEEDED(hr);
            }
        }

    }

    if (_fMadeLocal)
    {
        ASSERT(SUCCEEDED(hr));
        hr = SHStrDup(_szLocalPath, ppsz);
    }
    else
        ASSERT(_fIsLocalFile || FAILED(hr));
        

    return hr;
}

STDMETHODIMP CLocalCopyHelper::Upload(LCFLAGS flags, IBindCtx *pbc)
{
    if (!_psi)
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    if (!_fIsLocalFile)
    {
        //  get the local stream first because it is the cheapest operation.
        IStream *pstmSrc;
        hr = _GetLocalStream(STGM_READ, &pstmSrc, &_ftLocalCommit);

        if (SUCCEEDED(hr))
        {
            DWORD stgmRemote = STGM_WRITE;

            if (flags & LC_SAVEAS)
            {
                hr = _FinishLocal(FALSE);
                stgmRemote |= STGM_CREATE;
            }
               
            if (SUCCEEDED(hr))
            {
                IStream *pstmDst;
                hr = _GetRemoteStream(stgmRemote, pbc, &pstmDst, &_ftRemoteCommit);

                if (SUCCEEDED(hr))
                {
                    //  we only bother copying when the local copy changed
                    //  or caller forces us to.
                    //
                    //  FEATURE - UI needs to handle when the remot changes
                    //  if the remote copy changes while the local
                    //  copy is being updated we will overwrite the remote copy
                    //  local changes WIN!
                    //
                    
                    if (flags & LC_FORCEROUNDTRIP || 0 != CompareFileTime(&_ftLocalCommit, &_ftLocalGet))
                        hr = CopyStreamUI(pstmSrc, pstmDst, NULL, 0);
                    else
                        hr = S_FALSE;
                        
                    pstmDst->Release();
                }

            }

            pstmSrc->Release();
        }
    }

    return hr;
}
    
STDAPI CLocalCopyHelper_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLocalCopyHelper * p = new CLocalCopyHelper();

    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\linkwnd.cpp ===
#include "shellprv.h"
#include "ids.h"
#include <oleacc.h>

#ifndef POINTSPERRECT
#define POINTSPERRECT       (sizeof(RECT)/sizeof(POINT))
#endif

#define TESTKEYSTATE(vk)   ((GetKeyState(vk) & 0x8000)!=0)

#define LINKCOLOR_BKGND     COLOR_WINDOW
#define LINKCOLOR_ENABLED   GetSysColor(COLOR_HOTLIGHT)
#define LINKCOLOR_DISABLED  GetSysColor(COLOR_GRAYTEXT)

#define CF_SETCAPTURE  0x0001
#define CF_SETFOCUS    0x0002

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags);
BOOL _HandleWM_UPDATEUISTATE(IN WPARAM wParam, IN LPARAM lParam, IN OUT UINT* puFlags);


//  common IAccessible implementation.

class CAccessibleBase : public IAccessible, public IOleWindow
{
public:
    CAccessibleBase(const HWND& hwnd)
        :   _cRef(1), _ptiAcc(NULL), _hwnd(hwnd)
    { 
        DllAddRef();
    }
    
    virtual ~CAccessibleBase()
    { 
        DllRelease();
        ATOMICRELEASE(_ptiAcc);
    }

    //  IUnknown
    STDMETHODIMP         QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IOleWindow
    STDMETHODIMP GetWindow(HWND* phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                LCID lcid, DISPID * rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                         DISPPARAMS * pdispparams, VARIANT * pvarResult, 
                         EXCEPINFO * pexcepinfo, UINT * puArgErr);
    //  IAccessible
    STDMETHODIMP get_accParent(IDispatch ** ppdispParent);
    STDMETHODIMP get_accChildCount(long * pcChildren);
    STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pbstrValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR * pbstrDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pbstrHelp);
    STDMETHODIMP get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction);
    STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);
    STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    STDMETHODIMP put_accName(VARIANT varChild, BSTR bstrName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR bstrValue);

protected:
    virtual UINT GetDefaultActionStringID() const = 0;
    
private:
    LONG _cRef;
    ITypeInfo*  _ptiAcc;
    const HWND& _hwnd;

#define VALIDATEACCCHILD(varChild, idChild, hrFail) \
        if (!(VT_I4 == varChild.vt && idChild == varChild.lVal)) {return hrFail;}

};


#define TEST_CAPTURE(fTest)           ((_fCapture & fTest) != 0)
#define MODIFY_CAPTURE(fSet, fRemove) {if (fSet){_fCapture |= fSet;} if (fRemove){_fCapture &= ~fRemove;}}
#define RESET_CAPTURE()               {_fCapture=0;}

// this API for compat with old clients of the shell32 link window. that is now
// in comctl32.dll

BOOL WINAPI LinkWindow_RegisterClass()
{
    // get the comctl32 linkwindow, and point the old classname at it
    INITCOMMONCONTROLSEX iccs = {sizeof(iccs), ICC_LINK_CLASS};
    InitCommonControlsEx(&iccs);

    WNDCLASS wc;
    ULONG_PTR dwCookie = 0;
    SHActivateContext(&dwCookie);

    BOOL bRet = GetClassInfo(NULL, WC_LINK, &wc);
    SHDeactivateContext(dwCookie);
    if (bRet)
    {
        wc.lpszClassName = TEXT("Link Window"); // old class name for old clients
        RegisterClass(&wc);
    }
    return bRet;
}

BOOL WINAPI LinkWindow_UnregisterClass(HINSTANCE)
{
    return TRUE;
}

#define GROUPBTN_BKCOLOR    COLOR_WINDOW
#define CAPTION_VPADDING    3
#define CAPTION_HPADDING    2
#define GBM_SENDNOTIFY      (GBM_LAST + 1)

//  class CGroupBtn
class CGroupBtn : public CAccessibleBase

{ // all members private:

    CGroupBtn(HWND hwnd);
    ~CGroupBtn();

    //  IAccessible specialization
    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pbstrName);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    //  CAccessibleBase overrides
    UINT GetDefaultActionStringID() const   { return IDS_GROUPBTN_DEFAULTACTION; }

    //  window procedures
    static  LRESULT WINAPI s_GroupBtnWndProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);


    static LRESULT WINAPI s_BuddyProc(HWND, UINT, WPARAM, LPARAM);

    //  message handlers
    void    NcCreate(LPCREATESTRUCT lpcs);
    LRESULT NcCalcSize(BOOL, LPNCCALCSIZE_PARAMS);
    void    NcPaint(HRGN);
    LRESULT NcMouseMove(WPARAM, LONG, LONG);
    LRESULT NcHitTest(LONG, LONG);
    LRESULT NcButtonDown(UINT nMsg, WPARAM nHittest, const POINTS& pts);
    LRESULT NcDblClick(UINT nMsg, WPARAM nHittest, LPARAM lParam);
    LRESULT ButtonUp(UINT nMsg, WPARAM nHittest, const POINTS& pts);
    void    OnCaptureLost(HWND hwndNew) {RESET_CAPTURE();}
    LRESULT WindowPosChanging(LPWINDOWPOS);
    LRESULT OnSize(WPARAM, LONG, LONG);
    BOOL    SetPlacement(PGBPLACEMENT);
    BOOL    SetBuddy(HWND, ULONG);
    void    SetText(LPCTSTR);
    int     GetText(LPTSTR, int);
    int     GetTextW(LPWSTR, int);
    int     GetTextLength();
    void    SetFont(HFONT);
    HFONT   GetFont();

    //  utility methods
    static void _MapWindowRect(HWND hwnd, HWND hwndRelative, OUT LPRECT prcWindow);
    void        _MapWindowRect(HWND hwndRelative, OUT LPRECT prcWindow);
    HCURSOR     GetHandCursor();
    void        CalcCaptionSize();
    BOOL        CalcClientRect(IN OPTIONAL LPCRECT prcWindow, OUT LPRECT prcClient);
    BOOL        CalcWindowSizeForClient(IN OPTIONAL LPCRECT prcClient, 
                                         IN OPTIONAL LPCRECT prcWindow, 
                                         IN LPCRECT prcNewClient, 
                                         OUT LPSIZE psizeWindow);

    void    DoLayout(BOOL bNewBuddy = FALSE);

    LONG    EnableNotifications(BOOL bEnable);
    LRESULT SendNotify(int nCode, IN OPTIONAL NMHDR* pnmh = NULL);
     
    //  instance and static data
    HWND        _hwnd;
    HWND        _hwndBuddy;
    WNDPROC     _pfnBuddy;
    ULONG       _dwBuddyFlags;
    SIZE        _sizeBuddyMargin;
    HFONT       _hf;
    static ATOM _atom;
    LPTSTR      _pszCaption;
    SIZE        _sizeCaption;
    int         _yDrop;
    BOOL        _fDropped : 1,
                _fInLayout : 1;
    UINT        _fCapture;
    UINT        _fKeyboardCues;
    HCURSOR     _hcurHand;
    LONG        _cNotifyLocks;

    friend ATOM GroupButton_RegisterClass();
    friend HWND CreateGroupBtn(DWORD, LPCTSTR, DWORD, 
                                int x, int y, HWND hwndParent, UINT nID);
};

ATOM WINAPI GroupButton_RegisterClass()
{
    WNDCLASSEX wc = {0};
    wc.cbSize         = sizeof(wc);
    wc.style          = CS_GLOBALCLASS;
    wc.lpfnWndProc    = CGroupBtn::s_GroupBtnWndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)(GROUPBTN_BKCOLOR+1);
    wc.lpszClassName  = GROUPBUTTON_CLASS;
    RegisterClassEx(&wc);
    return (ATOM)TRUE;
}

CGroupBtn::CGroupBtn(HWND hwnd) 
    :   CAccessibleBase(_hwnd),
        _hwnd(hwnd), 
        _hwndBuddy(NULL), 
        _pfnBuddy(NULL),
        _dwBuddyFlags(GBBF_HRESIZE|GBBF_VRESIZE),
        _fInLayout(FALSE),
        _hf(NULL), 
        _pszCaption(NULL),
        _fDropped(TRUE),
        _fKeyboardCues(0),
        _yDrop(0),
        _fCapture(0),
        _hcurHand(NULL),
        _cNotifyLocks(0)
{
    _sizeCaption.cx = _sizeCaption.cy = 0;
    _sizeBuddyMargin.cx = _sizeBuddyMargin.cy = 0;
}

ATOM    CGroupBtn::_atom = 0;


CGroupBtn::~CGroupBtn() 
{
    SetFont(NULL);
    SetText(NULL);
}


//  CGroupBtn IAccessible impl
STDMETHODIMP CGroupBtn::get_accName(VARIANT varChild, BSTR* pbstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (NULL == pbstrName)
        return E_POINTER;
    *pbstrName = 0;

    int cch = GetTextLength();
    if ((*pbstrName = SysAllocStringLen(NULL, cch + 1)) != NULL)
    {
        GetTextW(*pbstrName, cch + 1);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CGroupBtn::accDoDefaultAction(VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    SendNotify(NM_RETURN);
    return S_OK;
}



//  CGroupBtn window impl



//  WM_SETTEXT handler
void CGroupBtn::SetText(LPCTSTR pszText)
{
    if (_pszCaption)
    {
        if (pszText && 0==lstrcmp(_pszCaption, pszText))
            return;
        delete [] _pszCaption;
        _pszCaption = NULL;
    }

    if (pszText && *pszText)
    {
        if ((_pszCaption = new TCHAR[lstrlen(pszText)+1]) != NULL)
            lstrcpy(_pszCaption, pszText);
    }
    
    if (IsWindow(_hwnd))
        CalcCaptionSize();
}


//  WM_GETTEXT handler
int CGroupBtn::GetText(LPTSTR pszText, int cchText)
{
    int cch = 0;
    if (pszText && cchText > 0)
    {
        *pszText = 0;
        if (_pszCaption && lstrcpyn(pszText, _pszCaption, cchText))
            cch = min(lstrlen(_pszCaption), cchText);
    }
    return cch;
}


int CGroupBtn::GetTextW(LPWSTR pwszText, int cchText)
{
#ifdef UNICODE
    return GetText(pwszText, cchText);
#else //UNICODE

    int   cchRet = 0;
    LPSTR pszText = new CHAR[cchText];
    
    if (pszText)
    {
        cchRet = GetText(pszText, cchText);
        if (cchRet)
        {
            SHAnsiToUnicode(pszText, pwszText, cchText);
        }
        delete [] pszText;
    }
    return cchRet;

#endif //UNICODE
}


//  WM_GETTEXTLENGTH handler
int CGroupBtn::GetTextLength()
{
    return (_pszCaption && *_pszCaption) ? lstrlen(_pszCaption) : 0 ;
}


//  WM_SETFONT handler
void CGroupBtn::SetFont(HFONT hf)
{
    if (_hf)
    {
        DeleteObject(_hf);
        _hf = NULL;
    }
    _hf = hf;
}


//  WM_GETFONT handler
HFONT CGroupBtn::GetFont()
{
    if (_hf == NULL)
    {
        //  if we don't have a font, use the parent's font
        HFONT hfParent = (HFONT)SendMessage(GetParent(_hwnd), WM_GETFONT, 0, 0);
        if (hfParent)
        {
            LOGFONT lf;
            if (GetObject(hfParent, sizeof(LOGFONT), &lf) >0)
                _hf = CreateFontIndirect(&lf);
        }
    }
    return _hf;
}


//  Hand cursor load
HCURSOR CGroupBtn::GetHandCursor()
{
    if (!_hcurHand)
        _hcurHand = LoadCursor(NULL, IDC_HAND);

    return _hcurHand;
}


//  Retrieves the window rect in relative coords.
void CGroupBtn::_MapWindowRect(HWND hwnd, HWND hwndRelative, OUT LPRECT prcWindow)
{
    ASSERT(IsWindow(hwnd));
    GetWindowRect(hwnd, prcWindow);
    MapWindowPoints(HWND_DESKTOP, hwndRelative, (LPPOINT)prcWindow, 2);
}


//  Retrieves the window rect in relative coords.
inline void CGroupBtn::_MapWindowRect(HWND hwndRelative, OUT LPRECT prcWindow)
{
    _MapWindowRect(_hwnd, hwndRelative, prcWindow);
}


//  Caches the size of the caption 'bar'.
void CGroupBtn::CalcCaptionSize()
{
    SIZE    sizeCaption = {0,0};
    LPCTSTR pszCaption = (_pszCaption && *_pszCaption) ? _pszCaption : TEXT("|");
    HDC     hdc;

    //  compute caption size based on window text:
    if ((hdc = GetDC(_hwnd)))
    {
        HFONT hf = GetFont(),
              hfPrev = (HFONT)SelectObject(hdc, hf);
        
        if (GetTextExtentPoint32(hdc, pszCaption, lstrlen(pszCaption),
                                  &sizeCaption))
            sizeCaption.cy += CAPTION_VPADDING; // add some vertical padding

        SelectObject(hdc, hfPrev);
        ReleaseDC(_hwnd, hdc);
    }

    _sizeCaption = sizeCaption;
}


//  Computes the size and position of the client area
BOOL CGroupBtn::CalcClientRect(IN OPTIONAL LPCRECT prcWindow, OUT LPRECT prcClient)
{
    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    RECT  rcWindow;

    if (!prcWindow)
    {
        //  Get parent-relative coords
        _MapWindowRect(GetParent(_hwnd), &rcWindow);
        prcWindow = &rcWindow;
    }

    *prcClient = *prcWindow;

    //  compute client rectangle:

    //  allow for border
    if (dwStyle & WS_BORDER)
        InflateRect(prcClient, -1, -1);

    //  allow for caption 'bar'
    prcClient->top += _sizeCaption.cy;

    //  Normalize for NULL rect.
    if (RECTWIDTH(*prcWindow) <=0)
        prcClient->left = prcClient->right = prcWindow->left;
    if (RECTHEIGHT(*prcWindow) <=0)
        prcClient->bottom = prcClient->top = prcWindow->top;

    return TRUE;
}


BOOL CGroupBtn::CalcWindowSizeForClient(
    IN OPTIONAL LPCRECT prcClient, 
    IN OPTIONAL LPCRECT prcWindow, 
    IN LPCRECT prcNewClient, 
    OUT LPSIZE psizeWindow)
{
    if (!(prcNewClient && psizeWindow))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    RECT rcWindow, rcClient;
    if (NULL == prcWindow)
    {
        GetWindowRect(_hwnd, &rcWindow);
        prcWindow = &rcWindow;
    }

    if (NULL == prcClient)
    {
        GetClientRect(_hwnd, &rcClient);
        prcClient = &rcClient;
    }

    SIZE sizeDelta;
    sizeDelta.cx = RECTWIDTH(*prcWindow) - RECTWIDTH(*prcClient);
    sizeDelta.cy = RECTHEIGHT(*prcWindow) - RECTHEIGHT(*prcClient);

    psizeWindow->cx = RECTWIDTH(*prcNewClient)  + sizeDelta.cx;
    psizeWindow->cy = RECTHEIGHT(*prcNewClient) + sizeDelta.cy;
    
    return TRUE;
}


//  WM_WINDOWPOSCHANGING handler
LRESULT CGroupBtn::WindowPosChanging(LPWINDOWPOS pwp)
{
    if (pwp->flags & SWP_NOSIZE)
        return DefWindowProc(_hwnd, WM_WINDOWPOSCHANGING, 0, (LPARAM)pwp);

    //  disallow sizing in buddy slave dimension(s).
    if (IsWindow(_hwndBuddy) && _dwBuddyFlags & (GBBF_HSLAVE|GBBF_VSLAVE) && !_fInLayout)
    {
        RECT rcWindow, rcClient;
        BOOL fResizeBuddy = FALSE;

        GetWindowRect(_hwnd, &rcWindow);
        GetClientRect(_hwnd, &rcClient);

        //  Prepare a buddy size data block
        GBNQUERYBUDDYSIZE qbs;
        qbs.cy = pwp->cy - (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));
        qbs.cx = pwp->cx - (RECTWIDTH(rcWindow) - RECTWIDTH(rcClient));
        
        if (_dwBuddyFlags & GBBF_HSLAVE) // prevent external horz resizing
        {
            pwp->cx = RECTWIDTH(rcWindow);
            //  If we're being resized in the vert dir, query for
            //  optimal buddy width for this height and adjust
            if (_dwBuddyFlags & GBBF_VRESIZE && RECTHEIGHT(rcWindow) != pwp->cy)
            {
                if (SendNotify(GBN_QUERYBUDDYWIDTH, (NMHDR*)&qbs) && qbs.cx >= 0)
                {
                    //  if the owner wants the buddy width to change, do it now.
                    LONG cxNew = qbs.cx + (RECTWIDTH(rcWindow) - RECTWIDTH(rcClient));
                    fResizeBuddy = cxNew != pwp->cx;
                    pwp->cx = cxNew;
                }
            }
        }
        
        if (_dwBuddyFlags & GBBF_VSLAVE) // prevent external vert resizing
        {
            pwp->cy = RECTHEIGHT(rcWindow);
            //  If we're being resized in the horz dir, query for
            //  optimal buddy height for this horizontal and adjust
            if (_dwBuddyFlags & GBBF_HRESIZE && RECTWIDTH(rcWindow) != pwp->cx)
            {
                if (SendNotify(GBN_QUERYBUDDYHEIGHT, (NMHDR*)&qbs) && qbs.cy >= 0)
                {
                    LONG cyNew = qbs.cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));
                    fResizeBuddy = cyNew != pwp->cy;
                    pwp->cy = cyNew;
                }
            }
        }

        if (fResizeBuddy)
        {
            _fInLayout = TRUE;
            SetWindowPos(_hwndBuddy, NULL, 0, 0, qbs.cx, qbs.cy,
                          SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
            _fInLayout = FALSE;
        }
    }

    //  enforce minimum height:
    if (pwp->cy < _sizeCaption.cy)
        pwp->cy = _sizeCaption.cy;

    return 0;
}


LRESULT CGroupBtn::OnSize(WPARAM flags, LONG cx, LONG cy)
{
    DoLayout();
    return 0;
} 


void CGroupBtn::DoLayout(BOOL bNewBuddy)
{
    if (!_fInLayout && IsWindow(_hwndBuddy))
    {
        RECT  rcWindow, rcThis, rcBuddy;
        DWORD dwSwpBuddy = SWP_NOACTIVATE,
              dwSwpThis  = SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE;
        BOOL  fReposThis = FALSE;
        SIZE  sizeNew;

        GetClientRect(_hwnd, &rcThis);
        GetWindowRect(_hwnd, &rcWindow);

        //  get rectangles in parent coords
        MapWindowPoints(_hwnd, GetParent(_hwnd), (LPPOINT)&rcThis,    POINTSPERRECT); 
        MapWindowPoints(HWND_DESKTOP, GetParent(_hwnd), (LPPOINT)&rcWindow,  POINTSPERRECT); 
        _MapWindowRect(_hwndBuddy, GetParent(_hwnd), &rcBuddy);

        //  If we need to reposition ourself to the buddy, 
        //  calculate the new size now.
        if (_dwBuddyFlags & (GBBF_HSLAVE|GBBF_VSLAVE))
            CalcWindowSizeForClient(&rcThis, &rcWindow, &rcBuddy, &sizeNew);

        //  Resize buddy according to size.
        if (_dwBuddyFlags & GBBF_HRESIZE)
        {
            rcBuddy.right = rcBuddy.left + RECTWIDTH(rcThis);

            if (bNewBuddy && 0 == (_dwBuddyFlags & GBBF_VRESIZE)) 
            {
                // query height
                GBNQUERYBUDDYSIZE qbs;
                qbs.cx = RECTWIDTH(rcThis);
                qbs.cy = -1;
                if (SendNotify(GBN_QUERYBUDDYHEIGHT, (NMHDR*)&qbs) && qbs.cy >= 0)
                    rcBuddy.bottom = rcBuddy.top + qbs.cy;
            }
        }
        else if (_dwBuddyFlags & GBBF_HSLAVE)
        { 
            rcWindow.right = rcWindow.left + sizeNew.cx;
            fReposThis = TRUE;
        }
        if (_dwBuddyFlags & GBBF_VRESIZE)
        {
            rcBuddy.bottom = rcBuddy.top + RECTHEIGHT(rcThis);

            if (bNewBuddy && 0 == (_dwBuddyFlags & GBBF_HRESIZE)) 
            {
                // query width
                GBNQUERYBUDDYSIZE qbs;
                qbs.cx = -1;
                qbs.cy = RECTHEIGHT(rcThis);
                if (SendNotify(GBN_QUERYBUDDYWIDTH, (NMHDR*)&qbs) && qbs.cx >= 0)
                    rcBuddy.right = rcBuddy.left + qbs.cx;
            }
        }
        else if (_dwBuddyFlags & GBBF_VSLAVE)
        { 
            rcWindow.bottom = rcWindow.top + sizeNew.cy;
            fReposThis = TRUE;
        }
        
        if (_dwBuddyFlags & GBBF_HSCROLL) 
        { 
            /* not implemented */
        }

        if (_dwBuddyFlags & GBBF_VSCROLL)
        { 
            /* not implemented */
        }

        //  reposition ourself and update our client rect.
        if (fReposThis)
         {
            _fInLayout = TRUE;
            SetWindowPos(_hwnd, NULL, 0, 0, 
                          RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow), dwSwpThis);
            _fInLayout = FALSE;
            GetClientRect(_hwnd, &rcThis);
            MapWindowPoints(_hwnd, GetParent(_hwnd), (LPPOINT)&rcThis,  POINTSPERRECT); 
        }
        
        //  slide buddy into client area and reposition
        OffsetRect(&rcBuddy, rcThis.left - rcBuddy.left, rcThis.top - rcBuddy.top);
        
        _fInLayout = TRUE;
        SetWindowPos(_hwndBuddy, _hwnd, rcBuddy.left, rcBuddy.top,
                      RECTWIDTH(rcBuddy), RECTHEIGHT(rcBuddy), dwSwpBuddy);
        _fInLayout = FALSE;
    }
}


//  GBM_SETPLACEMENT handler
BOOL CGroupBtn::SetPlacement(PGBPLACEMENT pgbp)
{
    RECT  rcWindow, rcClient;
    SIZE  sizeDelta = {0};
    DWORD dwFlags = SWP_NOZORDER|SWP_NOACTIVATE;

    _MapWindowRect(GetParent(_hwnd), &rcWindow);
    CalcClientRect(&rcWindow, &rcClient);

    //  establish whether we need to resize
    if ((pgbp->x < 0 || pgbp->x == rcWindow.left) && 
        (pgbp->y < 0 || pgbp->y == rcWindow.top))
        dwFlags |= SWP_NOMOVE;

    //  compute horizontal placement
    if (pgbp->x >= 0)  // fixed horz origin requested
        OffsetRect(&rcWindow, pgbp->x - rcWindow.left, 0);

    if (pgbp->cx >= 0) // fixed width requested
        rcWindow.right = rcWindow.left + pgbp->cx;
    else
    {
        if (pgbp->cxBuddy >= 0) // client width requested
            sizeDelta.cx = pgbp->cxBuddy - RECTWIDTH(rcClient);
        rcWindow.right  += sizeDelta.cx;
    }
                          
    //  compute vertical placement
    if (pgbp->y >= 0)  // fixed vert origin requested
        OffsetRect(&rcWindow, 0, pgbp->y - rcWindow.top);

    if (pgbp->cy >= 0) // fixed height requested
        rcWindow.bottom = rcWindow.top + pgbp->cy;
    else
    {
        if (pgbp->cyBuddy >= 0) // client height requested
            sizeDelta.cy = pgbp->cyBuddy - RECTHEIGHT(rcClient);
        rcWindow.bottom += sizeDelta.cy;
    }

    if (pgbp->hdwp && (-1 != (LONG_PTR)pgbp->hdwp))
        DeferWindowPos(pgbp->hdwp, _hwnd, NULL, rcWindow.left, rcWindow.top, 
                        RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow),
                        dwFlags);
    else
        SetWindowPos(_hwnd, NULL, rcWindow.left, rcWindow.top, 
                      RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow),
                      dwFlags);

    //  stuff resulting rects
    pgbp->rcWindow = rcWindow;
    return CalcClientRect(&rcWindow, &pgbp->rcBuddy);
}


BOOL CGroupBtn::SetBuddy(HWND hwnd, ULONG dwFlags)
{
    // If we already have a buddy, unhook ourselves
    //
    if (_hwndBuddy)
    {
        if (IsWindow(_hwndBuddy) && _pfnBuddy)
        {
            SetWindowLongPtr(_hwndBuddy, GWLP_USERDATA, (LONG_PTR)NULL);
            SetWindowLongPtr(_hwndBuddy, GWLP_WNDPROC, (LONG_PTR)_pfnBuddy);
        }
        _hwndBuddy = NULL;
        _pfnBuddy = NULL;
    }

    // Handle an invalid window...
    if (!IsWindow(hwnd))
        hwnd = NULL;

    // If we're being buddy'd with a window, hook it
    //
    if (hwnd)
    {
        if (dwFlags & (GBBF_HSLAVE|GBBF_VSLAVE))
        {
            //  subclass the buddy 
            _pfnBuddy = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)s_BuddyProc);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);
        }

        _hwndBuddy = hwnd;
        _dwBuddyFlags = dwFlags;
        DoLayout(TRUE);
    }

    return TRUE;
}


//  WM_NCCREATE handler
void CGroupBtn::NcCreate(LPCREATESTRUCT lpcs)
{
    //  assign user data
    SetWindowLongPtr(_hwnd, GWLP_USERDATA, (LONG_PTR)this);
    
    //  enforce window style bits
    lpcs->style     |= WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
    lpcs->dwExStyle |= WS_EX_TRANSPARENT;
    SetWindowLong(_hwnd, GWL_STYLE, lpcs->style);
    SetWindowLong(_hwnd, GWL_EXSTYLE, lpcs->dwExStyle);

    //  enforce min height
    SetText(lpcs->lpszName);
    if (lpcs->cy < _sizeCaption.cy)
    { 
        lpcs->cy = _sizeCaption.cy;
        SetWindowPos(_hwnd, NULL, 0,0, lpcs->cx, lpcs->cy,
                      SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }
}


//  WM_NCCALCSIZE handler
LRESULT CGroupBtn::NcCalcSize(BOOL fCalcValidRects, LPNCCALCSIZE_PARAMS pnccs)
{
    LRESULT lRet = FALSE;
    RECT   rcClient;

    if (fCalcValidRects && CalcClientRect(&pnccs->rgrc[0], &rcClient))
    {
        pnccs->rgrc[1] = pnccs->rgrc[2];
        pnccs->rgrc[0] = pnccs->rgrc[2] = rcClient;
        return WVR_VALIDRECTS;
    }
    
    return lRet;
}


//  WM_NCPAINT handler
void CGroupBtn::NcPaint(HRGN hrgn)
{
    RECT    rcWindow;
    DWORD   dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    HDC     hdc;

    GetWindowRect(_hwnd, &rcWindow);
    OffsetRect(&rcWindow, -rcWindow.left, -rcWindow.top);

    if ((hdc = GetWindowDC(_hwnd)) != NULL)
    {
        if (dwStyle & WS_BORDER)
        {
            HBRUSH hbr = CreateSolidBrush(COLOR_WINDOWFRAME);
            if (hbr)
            {
                FrameRect(hdc, &rcWindow, hbr);
                DeleteObject(hbr);
            }
        }

        rcWindow.bottom = rcWindow.top + _sizeCaption.cy;

        SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

        ExtTextOut(hdc, rcWindow.left, rcWindow.top, 
                    ETO_OPAQUE, &rcWindow, NULL, 0, NULL);

        InflateRect(&rcWindow, -CAPTION_HPADDING, -(CAPTION_VPADDING/2));
        HFONT hfPrev = (HFONT)SelectObject(hdc, GetFont());
        ExtTextOut(hdc, rcWindow.left, rcWindow.top, 
                    ETO_OPAQUE, &rcWindow, _pszCaption, 
                    _pszCaption ? lstrlen(_pszCaption) : 0, NULL);
        SelectObject(hdc, hfPrev);

        if (0 == (_fKeyboardCues & UISF_HIDEFOCUS))
        {
            if (GetFocus() == _hwnd)
            {
                rcWindow.right = rcWindow.left + _sizeCaption.cx + 1;
                InflateRect(&rcWindow, 1, 0);
                DrawFocusRect(hdc, &rcWindow);
            }
        }

        ReleaseDC(_hwnd, hdc);
    }
}


//  WM_NCMOUSEMOVE handler

LRESULT CGroupBtn::NcMouseMove(WPARAM nHittest, LONG x, LONG y)
{
    if (HTCAPTION == nHittest)
    {
        RECT  rc;
        POINT pt;
        GetWindowRect(_hwnd, &rc);
        rc.bottom = rc.top + _sizeCaption.cy;
        rc.right  = rc.left + _sizeCaption.cx;
        InflateRect(&rc, 0, -(CAPTION_VPADDING/2));
        pt.x = x;
        pt.y = y;

        if (PtInRect(&rc, pt))
        {
            HCURSOR hc = GetHandCursor();
            if (hc != NULL)
            {
                SetCursor(hc);
                return 0;
            }
        }
    }
    return DefWindowProc(_hwnd, WM_NCMOUSEMOVE, nHittest, MAKELPARAM(x, y));
}


//  WM_NCHITTEST handler
LRESULT CGroupBtn::NcHitTest(LONG x, LONG y)
{
    POINT pt;
    RECT  rc, rcClient;
    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    
    pt.x = x;
    pt.y = y;

    GetWindowRect(_hwnd, &rc);
    CalcClientRect(&rc, &rcClient);

    if (PtInRect(&rcClient, pt))
        return HTTRANSPARENT;

    if (PtInRect(&rc, pt))
    {
        if (dwStyle & WS_BORDER)
        {
            if (pt.x == rc.left ||
                pt.x == rc.right ||
                pt.y == rc.bottom)
                return HTBORDER;
        }
        return HTCAPTION;
    }
    return HTNOWHERE;
}


LRESULT CGroupBtn::NcButtonDown(UINT nMsg, WPARAM nHittest, const POINTS& pts)
{
    LRESULT lRet = 0;

    if (HTCAPTION == nHittest)
    {
        SetCursor(GetHandCursor());
        MODIFY_CAPTURE(CF_SETCAPTURE, 0);

        if (GetFocus() != _hwnd)
        {
            MODIFY_CAPTURE(CF_SETFOCUS, 0);
            EnableNotifications(FALSE); // so the host doesn't reposition the link.
            SetFocus(_hwnd);
            EnableNotifications(TRUE);
        }

        SetCapture(_hwnd);
    }
    else
        lRet = DefWindowProc(_hwnd, nMsg, nHittest, MAKELONG(pts.x, pts.y));
        
    return lRet;
}


LRESULT CGroupBtn::ButtonUp(UINT nMsg, WPARAM nHittest, const POINTS& pts)
{
    if (TEST_CAPTURE(CF_SETCAPTURE))
    {
        ReleaseCapture();
        MODIFY_CAPTURE(0, CF_SETCAPTURE);

        POINT ptScrn;
        ptScrn.x = pts.x;
        ptScrn.y = pts.y;
        MapWindowPoints(_hwnd, HWND_DESKTOP, &ptScrn, 1);

        LRESULT nHittest = SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(ptScrn.x, ptScrn.y));

        if (HTCAPTION == nHittest)
        {
            switch (nMsg)
            {
            case WM_LBUTTONUP:
                SendNotify(NM_CLICK);
                break;
            case WM_RBUTTONUP:
                SendNotify(NM_RCLICK);
                break;
            }
        }
    }

    if (TEST_CAPTURE(CF_SETFOCUS))
    {
        MODIFY_CAPTURE(0, CF_SETFOCUS);
        if (GetFocus() == _hwnd) // if we still have the focus...
            SendNotify(NM_SETFOCUS);
    }
    return 0;
}


//  Non-client mouse click/dblclk handler
LRESULT CGroupBtn::NcDblClick(UINT nMsg, WPARAM nHittest, LPARAM lParam)
{
    LRESULT lRet = 0;
    
    if (HTCAPTION == nHittest)
    {
        SetFocus(_hwnd);

        lRet = DefWindowProc(_hwnd, nMsg, HTCLIENT, lParam);

        switch (nMsg)
        {
            case WM_NCLBUTTONDBLCLK:
                SendNotify(NM_DBLCLK);
                break;
            case WM_NCRBUTTONDBLCLK:
                SendNotify(NM_RDBLCLK);
                break;
        }
    }
    else
        lRet = DefWindowProc(_hwnd, nMsg, nHittest, lParam);

    return lRet;
}


LONG CGroupBtn::EnableNotifications(BOOL bEnable)
{
    if (bEnable)
    {
        if (_cNotifyLocks > 0)
            _cNotifyLocks--;
    }
    else
        _cNotifyLocks++;
    
    return _cNotifyLocks;
}


//  WM_NOTIFY transmit helper
LRESULT CGroupBtn::SendNotify(int nCode, IN OPTIONAL NMHDR* pnmh)
{
    if (0 == _cNotifyLocks)
    {
        NMHDR hdr;
        if (NULL == pnmh)
            pnmh = &hdr; 

        pnmh->hwndFrom = _hwnd;
        pnmh->idFrom   = GetDlgCtrlID(_hwnd);
        pnmh->code     = nCode;
        return SendMessage(GetParent(_hwnd), WM_NOTIFY, hdr.idFrom, (LPARAM)pnmh);
    }
    return 0;
}


LRESULT CALLBACK CGroupBtn::s_GroupBtnWndProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CGroupBtn *pThis = (CGroupBtn *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (!pThis && (WM_NCCREATE == wMsg))
    {
        pThis = new CGroupBtn(hDlg);
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pThis);
    }

    if (pThis)
        return pThis->WndProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}



LRESULT CGroupBtn::WndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    
    switch (nMsg)
    {
        case WM_NCHITTEST:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcHitTest(pts.x, pts.y);
        }

        case WM_NCMOUSEMOVE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcMouseMove(wParam, pts.x, pts.y);
        }

        case WM_NCCALCSIZE:
            return NcCalcSize((BOOL)wParam, (LPNCCALCSIZE_PARAMS)lParam);

        case WM_NCPAINT:
            NcPaint((HRGN)wParam);
            return 0;

        case WM_WINDOWPOSCHANGING:
            return WindowPosChanging((LPWINDOWPOS)lParam);

        case WM_SIZE:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return OnSize(wParam, pts.x, pts.y);
        }

        case WM_DESTROY:
            if (IsWindow(_hwndBuddy))
                DestroyWindow(_hwndBuddy);
            break;

        case WM_ERASEBKGND:
            return TRUE; // transparent: no erase bkgnd

        case WM_NCLBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return NcButtonDown(nMsg, wParam, pts);
        }

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        {
            POINTS pts = MAKEPOINTS(lParam);
            return ButtonUp(nMsg, wParam, pts);
        }

        case WM_NCLBUTTONDBLCLK:
        case WM_NCRBUTTONDBLCLK:
            return NcDblClick(nMsg, wParam, lParam);

        case WM_SHOWWINDOW:
            if (IsWindow(_hwndBuddy))
                ShowWindow(_hwndBuddy, wParam ? SW_SHOW : SW_HIDE);
            break;

        case WM_SETTEXT:
            SetText((LPCTSTR)lParam);
            return TRUE;

        case WM_GETTEXT:
            return GetText((LPTSTR)lParam, (int)wParam);

        case WM_SETFONT:
            SetFont((HFONT)wParam);
            if (lParam /* fRedraw */)
                InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_CAPTURECHANGED:
            if (lParam /* NULL if we called ReleaseCapture() */)
                OnCaptureLost((HWND)lParam);
            break;

        case WM_SETFOCUS:
            NcPaint((HRGN)1);
            SendNotify(NM_SETFOCUS);
            break;
             
        case WM_KILLFOCUS:
            NcPaint((HRGN)1);
            SendNotify(NM_KILLFOCUS);
            break;

        case WM_GETDLGCODE:
        {
            MSG* pmsg;
            lRet = DLGC_BUTTON|DLGC_UNDEFPUSHBUTTON;

            if ((pmsg = (MSG*)lParam))
            {
                if ((WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message))
                {
                    switch (pmsg->wParam)
                    {
                    case VK_RETURN:
                    case VK_SPACE:
                        lRet |= DLGC_WANTALLKEYS;
                        break;
                    }
                }
                else if (WM_CHAR == pmsg->message && VK_RETURN == pmsg->wParam)
                {
                    //  Eat VK_RETURN WM_CHARs; we don't want
                    //  Dialog manager to beep when IsDialogMessage gets it.
                    return lRet |= DLGC_WANTMESSAGE;
                }
            }

            return lRet;
        }

        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            switch (wParam)
            {
                case VK_RETURN:
                case VK_SPACE:
                    if (WM_KEYDOWN == nMsg)
                        SendNotify(NM_RETURN);
                    return 0;
            }
            break;

        case WM_UPDATEUISTATE:
            if (_HandleWM_UPDATEUISTATE(wParam, lParam, &_fKeyboardCues))
                SendMessage(hwnd, WM_NCPAINT, 1, 0);
            break;

        case GBM_SETPLACEMENT:
            if (lParam)
                return SetPlacement((PGBPLACEMENT)lParam);
            return 0;

        case GBM_SETDROPSTATE: // WPARAM: BOOL fDropped, LPARAM: n/a, return: BOOL
            return 0;

        case GBM_GETDROPSTATE: // WPARAM: n/a, LPARAM: n/a, return: BOOL fDropped
            return 0;

        case GBM_SENDNOTIFY:
            SendNotify((int)wParam);
            break;

        case WM_NCCREATE:
            NcCreate((LPCREATESTRUCT)lParam);
            break;

        case WM_NCDESTROY:
            lRet = DefWindowProc(hwnd, nMsg, wParam, lParam);
            SetWindowPtr(hwnd, GWLP_USERDATA, NULL);
            _hwnd = NULL;
            Release();
            return lRet;

        case WM_CREATE:
            _InitializeUISTATE(hwnd, &_fKeyboardCues);
            SetText(((LPCREATESTRUCT)lParam)->lpszName);
            break;

        case GBM_SETBUDDY:     // WPARAM: HWND hwndBuddy, LPARAM: MAKELPARAM(cxMargin, cyMargin), return: BOOL
            return SetBuddy((HWND)wParam, (ULONG)lParam);

        case GBM_GETBUDDY:     // WPARAM: n/a, LPARAM: n/a, return: HWND
            return (LRESULT)_hwndBuddy;

        default:
            // oleacc defs thunked for WINVER < 0x0500
            if ((WM_GETOBJECT == nMsg) && (OBJID_CLIENT == (DWORD)lParam || OBJID_TITLEBAR == (DWORD)lParam))
                return LresultFromObject(IID_IAccessible, wParam, SAFECAST(this, IAccessible*));

            break;
    }

    return DefWindowProc(hwnd, nMsg, wParam, lParam);
}
                                                   

LRESULT CGroupBtn::s_BuddyProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    CGroupBtn *pBtn = (CGroupBtn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (nMsg)
    {
    case WM_SIZE:
        {
            LRESULT lRet = CallWindowProc(pBtn->_pfnBuddy, hwnd, nMsg, wParam, lParam);
            if (!pBtn->_fInLayout)
                pBtn->DoLayout();
            return lRet;
        }

    case WM_DESTROY:
        {
            WNDPROC pfn = pBtn->_pfnBuddy;
            pBtn->SetBuddy(NULL, 0);
            return CallWindowProc(pfn, hwnd, nMsg, wParam, lParam);
        }
    }
    return pBtn->_pfnBuddy ? CallWindowProc(pBtn->_pfnBuddy, hwnd, nMsg, wParam, lParam) : 0;
}


//  CAccessibleBase IUnknown impl
STDMETHODIMP CAccessibleBase::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessibleBase, IDispatch),
        QITABENT(CAccessibleBase, IAccessible),
        QITABENT(CAccessibleBase, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CAccessibleBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAccessibleBase::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//  CAccessibleBase IOleWindow impl
STDMETHODIMP CAccessibleBase::GetWindow(HWND* phwnd)
{
    *phwnd = _hwnd;
    return IsWindow(_hwnd) ? S_OK : S_FALSE;
}


//  CAccessibleBase IDispatch impl


static HRESULT _accLoadTypeInfo(ITypeInfo** ppti)
{
    ITypeLib* ptl;
    HRESULT hr = LoadTypeLib(L"oleacc.dll", &ptl);

    if (SUCCEEDED(hr))
    {
        hr = ptl->GetTypeInfoOfGuid(IID_IAccessible, ppti);
        ATOMICRELEASE(ptl);
    }
    return hr;
}

STDMETHODIMP CAccessibleBase::GetTypeInfoCount(UINT * pctinfo) 
{ 
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    HRESULT hr = E_FAIL;
    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    *pptinfo = _ptiAcc;
    (*pptinfo)->AddRef();
    return S_OK;
}

STDMETHODIMP CAccessibleBase::GetIDsOfNames(
    REFIID riid, 
    OLECHAR** rgszNames, 
    UINT cNames,
    LCID lcid, DISPID * rgdispid)
{
    HRESULT hr = E_FAIL;

    if (IID_NULL != riid && IID_IAccessible != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    return _ptiAcc->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

STDMETHODIMP CAccessibleBase::Invoke(
    DISPID  dispidMember, 
    REFIID  riid, 
    LCID    lcid, 
    WORD    wFlags,
    DISPPARAMS * pdispparams, 
    VARIANT * pvarResult, 
    EXCEPINFO * pexcepinfo, 
    UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    if (IID_NULL != riid && IID_IAccessible != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (NULL == _ptiAcc && FAILED((hr = _accLoadTypeInfo(&_ptiAcc))))
        return hr;

    return _ptiAcc->Invoke(this, dispidMember, wFlags, pdispparams, 
                            pvarResult, pexcepinfo, puArgErr);
}

STDMETHODIMP CAccessibleBase::get_accParent(IDispatch ** ppdispParent)
{
    *ppdispParent = NULL;
    if (IsWindow(_hwnd))
        return AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW,
                                           IID_PPV_ARG(IDispatch, ppdispParent));
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accChildCount(long * pcChildren)
{
    *pcChildren = 0;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild)
{
    *ppdispChild = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accValue(VARIANT varChild, BSTR* pbstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrValue = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accDescription(VARIANT varChild, BSTR * pbstrDescription)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrDescription = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    pvarRole->vt    = VT_I4;
    pvarRole->lVal  = ROLE_SYSTEM_LINK;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = STATE_SYSTEM_DEFAULT ;

    if (GetFocus() == _hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    else if (IsWindowEnabled(_hwnd))
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    if (!IsWindowVisible(_hwnd))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

STDMETHODIMP CAccessibleBase::get_accHelp(VARIANT varChild, BSTR* pbstrHelp)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelp = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accHelpTopic(BSTR* pbstrHelpFile, VARIANT varChild, long* pidTopic)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrHelpFile = NULL;
    *pidTopic    = -1;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accKeyboardShortcut(VARIANT varChild, BSTR* pbstrKeyboardShortcut)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    *pbstrKeyboardShortcut = NULL;
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accFocus(VARIANT FAR * pvarFocusChild)
{
    HWND hwndFocus;
    if ((hwndFocus = GetFocus()) == _hwnd || IsChild(_hwnd, hwndFocus))
    {
        pvarFocusChild->vt = VT_I4;
        pvarFocusChild->lVal = CHILDID_SELF;
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::get_accSelection(VARIANT FAR * pvarSelectedChildren)
{
    return get_accFocus(pvarSelectedChildren);  // implemented same as focus.
}

STDMETHODIMP CAccessibleBase::get_accDefaultAction(VARIANT varChild, BSTR* pbstrDefaultAction)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    WCHAR wsz[128];
    if (LoadStringW(HINST_THISDLL, GetDefaultActionStringID(), wsz, ARRAYSIZE(wsz)))
    {
        if (NULL == (*pbstrDefaultAction = SysAllocString(wsz)))
            return E_OUTOFMEMORY;
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CAccessibleBase::accSelect(long flagsSelect, VARIANT varChild)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);

    if (flagsSelect & SELFLAG_TAKEFOCUS)
    {
        SetFocus(_hwnd);
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT rc;
    GetWindowRect(_hwnd, &rc);
    *pxLeft = rc.left;
    *pyTop  = rc.top;
    *pcxWidth  = RECTWIDTH(rc);
    *pcyHeight = RECTHEIGHT(rc);

    varChild.vt = VT_I4;
    varChild.lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    pvarChildAtPoint->vt   = VT_I4;
    pvarChildAtPoint->lVal = CHILDID_SELF;
    return S_OK;
}

STDMETHODIMP CAccessibleBase::put_accName(VARIANT varChild, BSTR bstrName)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

STDMETHODIMP CAccessibleBase::put_accValue(VARIANT varChild, BSTR bstrValue)
{
    VALIDATEACCCHILD(varChild, CHILDID_SELF, E_INVALIDARG);
    return S_FALSE;
}

BOOL _HandleWM_UPDATEUISTATE(WPARAM wParam, LPARAM lParam, OUT UINT* puFlags)
{
    UINT uFlags = *puFlags;

    switch (LOWORD(wParam))
    {
    case UIS_CLEAR:
        *puFlags &= ~(HIWORD(wParam));
        break;

    case UIS_SET:
        *puFlags |= HIWORD(wParam);
        break;
    }

    return uFlags != *puFlags;
}

void _InitializeUISTATE(IN HWND hwnd, IN OUT UINT* puFlags)
{
    HWND hwndParent = GetParent(hwnd);
    *puFlags = (UINT)SendMessage(hwndParent, WM_QUERYUISTATE, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\linkprop.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include <msi.h>
#include <msip.h>
#include "lnkcon.h"
#include "trayp.h"      // for WMTRAY_ messages
#include "util.h"   // for GetIconLocationFromExt
#include "ids.h"

LINKPROP_DATA* Create_LinkPropData()
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA*) LocalAlloc(LPTR, sizeof(*plpd));
    if (plpd)
    {
        plpd->_cRef = 1;
        plpd->hCheckNow = CreateEvent(NULL, TRUE, FALSE, NULL);

    }
    return plpd;
}

LONG AddRef_LinkPropData(LINKPROP_DATA *plpd)
{
    return plpd ? InterlockedIncrement(&plpd->_cRef) : 0;
}

LONG Release_LinkPropData(LINKPROP_DATA *plpd)
{
    if (plpd)
    {
        ASSERT( 0 != plpd->_cRef );
        LONG cRef = InterlockedDecrement(&plpd->_cRef);
        if ( 0 == cRef )
        {
            if (plpd->psl)
                plpd->psl->Release();
            if (plpd->hCheckNow)
            {
                CloseHandle(plpd->hCheckNow);
                plpd->hCheckNow = NULL;
            }
            LocalFree(plpd);
        }
        return cRef;
    }
    return 0;
}


//
// This string defined in shlink.c - hack to allow user to set working dir to $$
// and have it map to whatever "My Documents" is mapped to.
//

void _UpdateLinkIcon(LINKPROP_DATA *plpd, HICON hIcon)
{
    if (!hIcon)
    {
        hIcon = SHGetFileIcon(NULL, plpd->szFile, 0, SHGFI_LARGEICON);
    }

    if (hIcon)
    {
        ReplaceDlgIcon(plpd->hDlg, IDD_ITEMICON, hIcon);
    }
}

// put a path into an edit field, doing quoting as necessary

void SetDlgItemPath(HWND hdlg, int id, LPTSTR pszPath)
{
    PathQuoteSpaces(pszPath);
    SetDlgItemText(hdlg, id, pszPath);
}

// get a path from an edit field, unquoting as possible

void GetDlgItemPath(HWND hdlg, int id, LPTSTR pszPath)
{
    GetDlgItemText(hdlg, id, pszPath, MAX_PATH);
    PathRemoveBlanks(pszPath);
    PathUnquoteSpaces(pszPath);
}


const int c_iShowCmds[] = {
    SW_SHOWNORMAL,
    SW_SHOWMINNOACTIVE,
    SW_SHOWMAXIMIZED,
};

void _DisableAllChildren(HWND hwnd)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL; hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        // we don't want to disable the static text controls (makes the dlg look bad)
        if (!(SendMessage(hwndChild, WM_GETDLGCODE, 0, 0) & DLGC_STATIC))
        {
            EnableWindow(hwndChild, FALSE);
        }
    }
}

HRESULT _GetPathAndArgs(LINKPROP_DATA *plpd, LPTSTR pszPath, LPTSTR pszArgs, UINT cchArgs)
{
    GetDlgItemText(plpd->hDlg, IDD_FILENAME, pszPath, MAX_PATH);
    return PathSeperateArgs(pszPath, pszArgs, cchArgs, NULL);
}


//
// Returns fully qualified path to target of link, and # of characters
// in fully qualifed path as return value
//
INT _GetTargetOfLink(LINKPROP_DATA *plpd, LPTSTR pszTarget)
{
    TCHAR szFile[MAX_PATH];
    INT cch = 0;

    *pszTarget = 0;

    HRESULT hr = _GetPathAndArgs(plpd, szFile, NULL, 0);
    if (SUCCEEDED(hr))
    {
        if (szFile[0])
        {
            LPTSTR psz;
            TCHAR szExp[MAX_PATH];

            if (SHExpandEnvironmentStrings(szFile, szExp, ARRAYSIZE(szExp)))
            {
                cch = SearchPath(NULL, szExp, TEXT(".EXE"), MAX_PATH, pszTarget, &psz);
            }
        }
    }

    return cch;
}


//
// Do checking of the .exe type in the background so the UI doesn't
// get hung up while we scan.  This is particularly important with
// the .exe is over the network or on a floppy.
//
STDAPI_(DWORD) _LinkCheckThreadProc(void *pv)
{
    LINKPROP_DATA *plpd = (LINKPROP_DATA *)pv;
    BOOL fCheck = TRUE, fEnable = FALSE;

    DebugMsg(DM_TRACE, TEXT("_LinkCheckThreadProc created and running"));

    while (plpd->bCheckRunInSep)
    {
        WaitForSingleObject(plpd->hCheckNow, INFINITE);
        ResetEvent(plpd->hCheckNow);

        if (plpd->bCheckRunInSep)
        {
            TCHAR szFullFile[MAX_PATH];
            DWORD cch = _GetTargetOfLink(plpd, szFullFile);

            if ((cch != 0) && (cch < ARRAYSIZE(szFullFile)))
            {
                DWORD dwBinaryType;

                if (PathIsUNC(szFullFile) || IsRemoteDrive(DRIVEID(szFullFile)))
                {
                    // Net Path, let the user decide...
                    fCheck = FALSE;
                    fEnable = TRUE;
                }
                else if (GetBinaryType(szFullFile, &dwBinaryType) && (dwBinaryType == SCS_WOW_BINARY))
                {
                    // 16-bit binary, let the user decide, default to same VDM
                    fCheck = FALSE;
                    fEnable = TRUE;
                }
                else
                {
                    // 32-bit binary, or non-net path.  don't enable the control
                    fCheck = TRUE;
                    fEnable = FALSE;
                }
            } 
            else 
            {
                // Error getting target of the link.  don't enable the control
                fCheck = TRUE;
                fEnable = FALSE;
            }

            plpd->bEnableRunInSepVDM = fEnable;
            plpd->bRunInSepVDM = fCheck;

            if (plpd->hDlgAdvanced && IsWindow(plpd->hDlgAdvanced))
            {
                CheckDlgButton(plpd->hDlgAdvanced, IDD_RUNINSEPARATE, fCheck ? 1 : 0);
                EnableWindow(GetDlgItem(plpd->hDlgAdvanced, IDD_RUNINSEPARATE), fEnable);
            }
        }
    }
    plpd->bLinkThreadIsAlive = FALSE;
    Release_LinkPropData(plpd);
    DebugMsg(DM_TRACE, TEXT("_LinkCheckThreadProc exiting now..."));
    return 0;
}

// shut down the thread

void _StopThread(LINKPROP_DATA *plpd)
{
    if (plpd->bLinkThreadIsAlive)
    {
        plpd->bCheckRunInSep = FALSE;
        SetEvent(plpd->hCheckNow);
    }
}



void * _GetLinkExtraData(IShellLink* psl, DWORD dwSig)
{
    void * pDataBlock = NULL;

    IShellLinkDataList *psld;
    if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &psld))))
    {
        psld->CopyDataBlock(dwSig, &pDataBlock);
        psld->Release();
    }

    return pDataBlock;
}

// Initializes the generic link dialog box.
void _UpdateLinkDlg(LINKPROP_DATA *plpd, BOOL bUpdatePath)
{
    WORD wHotkey;
    int  i, iShowCmd;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szCommand[MAX_PATH];
    HRESULT hr;
    SHFILEINFO sfi;
    BOOL fIsDarwinLink;


    // do this here so we don't slow down the loading
    // of other pages

    if (!bUpdatePath)
    {
        IPersistFile *ppf;

        if (SUCCEEDED(plpd->psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(plpd->szFile, wszPath, ARRAYSIZE(wszPath));
            hr = ppf->Load(wszPath, 0);
            ppf->Release();

            if (FAILED(hr))
            {
                LoadString(HINST_THISDLL, IDS_LINKNOTLINK, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(plpd->hDlg, IDD_FILETYPE, szBuffer);
                _DisableAllChildren(plpd->hDlg);

                DebugMsg(DM_TRACE, TEXT("Shortcut IPersistFile::Load() failed %x"), hr);
                return;
            }
        }
    }
    
    fIsDarwinLink = SetLinkFlags(plpd->psl, 0, 0) & SLDF_HAS_DARWINID;

    SHGetFileInfo(plpd->szFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    SetDlgItemText(plpd->hDlg, IDD_NAME, sfi.szDisplayName);

    // we need to check for darwin links here so that we can gray out
    // things that don't apply to darwin
    if (fIsDarwinLink)
    {
        TCHAR szAppState[MAX_PATH];
        DWORD cchAppState = ARRAYSIZE(szAppState);
        HWND hwndTargetType = GetDlgItem(plpd->hDlg, IDD_FILETYPE);

        // disable the children
        _DisableAllChildren(plpd->hDlg);

        // then special case the icon and the "Target type:" text
        _UpdateLinkIcon(plpd, NULL);

        LPEXP_DARWIN_LINK pDarwinData = (LPEXP_DARWIN_LINK)_GetLinkExtraData(plpd->psl, EXP_DARWIN_ID_SIG);

        // The second clause will see if it is a Darwin Advertisement.
        if (pDarwinData && (INSTALLSTATE_ADVERTISED == MsiQueryFeatureStateFromDescriptorW(pDarwinData->szwDarwinID)))
        {
            // the app is advertised (e.g. not installed), but will be faulted in on first use
            LoadString(HINST_THISDLL, IDS_APP_NOT_FAULTED_IN, szAppState, ARRAYSIZE(szAppState));
        }
        else
        {
            // the darwin app is installed
            LoadString(HINST_THISDLL, IDS_APP_FAULTED_IN, szAppState, ARRAYSIZE(szAppState));
        }

        SetWindowText(hwndTargetType, szAppState);
        EnableWindow(hwndTargetType, TRUE);

        // if we can ge the package name, put that in the Target field
        if (pDarwinData &&
            MsiGetProductInfo(pDarwinData->szwDarwinID,
                              INSTALLPROPERTY_PRODUCTNAME,
                              szAppState,
                              &cchAppState) == ERROR_SUCCESS)
        {
            SetWindowText(GetDlgItem(plpd->hDlg, IDD_FILENAME), szAppState);
        }

        if (pDarwinData)
        {
            LocalFree(pDarwinData);
        }
        
        // we disabled everything in _DisableAllChildren, so re-enable the ones we still apply for darwin
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_NAME), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_PATH), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_HOTKEY), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_SHOWCMD), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDD_LINK_DESCRIPTION), TRUE);
        EnableWindow(GetDlgItem(plpd->hDlg, IDC_ADVANCED), TRUE);

        // we skip all of the gook below if we are darwin since we only support the IDD_NAME, IDD_PATH, IDD_LINK_HOTKEY, 
        // IDD_LINK_SHOWCMD, and IDD_LINK_DESCRIPTION fields
    }
    else
    {
        hr = plpd->psl->GetPath(szCommand, ARRAYSIZE(szCommand), NULL, SLGP_RAWPATH);
        
        if (FAILED(hr))
            hr = plpd->psl->GetPath(szCommand, ARRAYSIZE(szCommand), NULL, 0);

        if (S_OK == hr)
        {
            plpd->bIsFile = TRUE;

            // get type
            if (!SHGetFileInfo(szCommand, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME))
            {
                TCHAR szExp[MAX_PATH];

                // Let's see if the string has expandable environment strings
                if (SHExpa