00B0 //
#define LU_REMOTE_REGISTER      0x000000C0 //

#define LU_LOGICAL_DEST         0x000000D0 //
#define LU_LOGICAL_DEST_MASK    0xFF000000

#define LU_DEST_FORMAT          0x000000E0 //
#define LU_DEST_FORMAT_MASK     0xF0000000
#define LU_DEST_FORMAT_FLAT     0xFFFFFFFF
#define LU_DEST_FORMAT_CLUSTER  0x0FFFFFFF

#define LU_SPURIOUS_VECTOR      0x000000F0 //
#define LU_FAULT_VECTOR         0x00000370 //
#define LU_UNIT_ENABLED         0x00000100
#define LU_UNIT_DISABLED        0x00000000

#define LU_ISR_0                0x00000100 //
#define LU_TMR_0                0x00000180 //
#define LU_IRR_0                0x00000200 //
#define LU_ERROR_STATUS         0x00000280 //
#define LU_INT_CMD_LOW          0x00000300 //
#define LU_INT_CMD_HIGH         0x00000310 //
#define LU_TIMER_VECTOR         0x00000320 //
#define LU_PERF_VECTOR          0x00000340
#define LU_INT_VECTOR_0         0x00000350 //    TEMPORARY - do not use
#define LU_INT_VECTOR_1         0x00000360 //    TEMPORARY - do not use
#define LU_INITIAL_COUNT        0x00000380 //
#define LU_CURRENT_COUNT        0x00000390 //
#define LU_DIVIDER_CONFIG       0x000003E0 //

#define APIC_ID_MASK            0xFF000000
#define APIC_ID_SHIFT           24

#define INT_VECTOR_MASK         0x000000FF
#define RESERVED_HIGH_INT       0x000000F8
#define DELIVERY_MODE_MASK      0x00000700
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_REMOTE_READ     0x00000300
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_STARTUP         0x00000600
#define DELIVER_EXTINT          0x00000700
#define PHYSICAL_DESTINATION    0x00000000
#define LOGICAL_DESTINATION     0x00000800
#define DELIVERY_PENDING        0x00001000
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define REMOTE_IRR              0x00004000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000
#define PERIODIC_TIMER          0x00020000

#define ICR_LEVEL_ASSERTED      0x00004000
#define ICR_LEVEL_DEASSERTED    0x00000000
#define ICR_RR_STATUS_MASK      0x00030000
#define ICR_RR_INVALID          0x00000000
#define ICR_RR_IN_PROGRESS      0x00010000
#define ICR_RR_VALID            0x00020000
#define ICR_SHORTHAND_MASK      0x000C0000
#define ICR_USE_DEST_FIELD      0x00000000
#define ICR_SELF                0x00040000
#define ICR_ALL_INCL_SELF       0x00080000
#define ICR_ALL_EXCL_SELF       0x000C0000


//
//  Io Apic Entry definitions
//
//  Interrupt Types Possible in the PC+MP Table
//  valid for both local and Io Apics
//
#define INT_TYPE_INTR           0x0
#define INT_TYPE_NMI            0x1
#define INT_TYPE_SMI            0x2
#define INT_TYPE_EXTINT         0x3



///////////////////////////////////////////////////////////////////////////////
//
// arbiter.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Attributes for the ranges
//

#define ARBITER_RANGE_BOOT_ALLOCATED    0x01

#define ARBITER_RANGE_ALIAS             0x10
#define ARBITER_RANGE_POSITIVE_DECODE   0x20

#define INITIAL_ALLOCATION_STATE_SIZE   PageSize

#define ARBITER_INSTANCE_SIGNATURE      'sbrA'



///////////////////////////////////////////////////////////////////////////////
//
// busp.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags definitions of DEVICE_INFORMATION and BUS_EXTENSION
//

#define DF_DELETED          0x00000001
#define DF_REMOVED          0X00000002
#define DF_NOT_FUNCTIONING  0x00000004
#define DF_ENUMERATED       0x00000008
#define DF_ACTIVATED        0x00000010
#define DF_QUERY_STOPPED    0x00000020
#define DF_SURPRISE_REMOVED 0x00000040
#define DF_PROCESSING_RDP   0x00000080
#define DF_STOPPED          0x00000100
#define DF_RESTARTED_MOVED  0x00000200
#define DF_RESTARTED_NOMOVE 0x00000400
#define DF_REQ_TRIMMED      0x00000800
#define DF_READ_DATA_PORT   0x40000000
#define DF_BUS              0x80000000


///////////////////////////////////////////////////////////////////////////////
//
// cache.h
//
///////////////////////////////////////////////////////////////////////////////

//  Define two constants describing the view size (and alignment)
//  that the Cache Manager uses to map files.
//

#define VACB_MAPPING_GRANULARITY         (0x40000)
#define VACB_OFFSET_SHIFT                (18)


///////////////////////////////////////////////////////////////////////////////
//
// cc.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  Define our node type codes.
//

#define CACHE_NTC_SHARED_CACHE_MAP       (0x2FF)
#define CACHE_NTC_PRIVATE_CACHE_MAP      (0x2FE)
#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_DEFERRED_WRITE         (0x2FC)
#define CACHE_NTC_MBCB                   (0x2FB)
#define CACHE_NTC_OBCB                   (0x2FA)
#define CACHE_NTC_MBCB_GRANDE            (0x2F9)

//  There is a bit of a trick as we make the jump to the multilevel structure in that
//  we need a real fixed reference count.
//

#define VACB_LEVEL_SHIFT                  (7)

//
//  This is how many bytes of pointers are at each level.  This is the size for both
//  the Vacb array and (optional) Bcb listheads.  It does not include the reference
//  block.
//

// #define VACB_LEVEL_BLOCK_SIZE             ((1 << VACB_LEVEL_SHIFT) * sizeof(PVOID))

//
//  This is the last index for a level.
//

#define VACB_LAST_INDEX_FOR_LEVEL         ((1 << VACB_LEVEL_SHIFT) - 1)

//
//  This is the size of file which can be handled in a single level.
//

#define VACB_SIZE_OF_FIRST_LEVEL         (1 << (VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT))

//
//  This is the maximum number of levels it takes to support 63-bits.  It is
//  used for routines that must remember a path.
//

#define VACB_NUMBER_OF_LEVELS            (((63 - VACB_OFFSET_SHIFT)/VACB_LEVEL_SHIFT) + 1)

//
//  First some constants
//

#define PREALLOCATED_VACBS               (4)


///////////////////////////////////////////////////////////////////////////////
//
// ex.h
//
///////////////////////////////////////////////////////////////////////////////

#define CALL_HASH_TABLE_SIZE 64

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16               // ntifs



///////////////////////////////////////////////////////////////////////////////
//
// cmdata.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define the HINT Length used
//
#define CM_SUBKEY_HINT_LENGTH   4
#define CM_MAX_CACHE_HINT_SIZE 14

//
// Bits used in the ExtFlags in KCB.
//

#define CM_KCB_NO_SUBKEY        0x0001      // This key has no subkeys
#define CM_KCB_SUBKEY_ONE       0x0002      // This key has only one subkey and the
                                            // first 4 char
                                            //
#define CM_KCB_SUBKEY_HINT          0x0004
#define CM_KCB_SYM_LINK_FOUND       0x0008
#define CM_KCB_KEY_NON_EXIST        0x0010
#define CM_KCB_NO_DELAY_CLOSE       0x0020
#define CM_KCB_INVALID_CACHED_INFO  0x0040  // info stored in SubKeyCount is not valid, so we shouldn't rely on it

#define CM_KCB_CACHE_MASK (CM_KCB_NO_SUBKEY | \
                           CM_KCB_KEY_NON_EXIST | \
                           CM_KCB_SUBKEY_ONE | \
                           CM_KCB_SUBKEY_HINT)




//
// CM_KEY_BODY
//
#define KEY_BODY_TYPE           0x6b793032      // "ky02"

//
// ----- CM_KEY_VALUE -----
//

#define CM_KEY_VALUE_SIGNATURE      0x6b76                      // "kv"

#define VALUE_COMP_NAME             0x0001                      // The name for this value is stored in a

//
// ----- CM_KEY_NODE -----
//

#define CM_KEY_NODE_SIGNATURE      0x6b6e           // "kn"
#define CM_LINK_NODE_SIGNATURE     0x6b6c          // "kl"

#define KEY_VOLATILE        0x0001      // This key (and all its children)
                                        // is volatile.

#define KEY_HIVE_EXIT       0x0002      // This key marks a bounary to another
                                        // hive (sort of a link).  The null
                                        // value entry contains the hive
                                        // and hive index of the root of the
                                        // child hive.

#define KEY_HIVE_ENTRY      0x0004      // This key is the root of a particular
                                        // hive.

#define KEY_NO_DELETE       0x0008      // This key cannot be deleted, period.

#define KEY_SYM_LINK        0x0010      // This key is really a symbolic link.
#define KEY_COMP_NAME       0x0020      // The name for this key is stored in a
                                        // compressed form.
#define KEY_PREDEF_HANDLE   0x0040      // There is no real key backing this,
                                        // return the predefined handle.
                                        // Predefined handles are stashed in
                                        // ValueList.Count.

///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////
#define HFILE_TYPE_PRIMARY      0   // Base hive file
#define HFILE_TYPE_LOG          1   // Log (security.log)
#define HFILE_TYPE_EXTERNAL     2   // Target of savekey, etc.
#define HFILE_TYPE_MAX          3

#define HHIVE_SIGNATURE 0xBEE0BEE0

#define HBIN_SIGNATURE          0x6e696268      // "hbin"

#define HHIVE_LINEAR_INDEX      16  // All computed linear indices < HHIVE_LINEAR_INDEX are valid
#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices < HHIVE_EXPONENTIAL_INDEX
                                    // and >= HHIVE_LINEAR_INDEX are valid.
#define HHIVE_FREE_DISPLAY_SIZE 24

#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!
#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index

///////////////////////////////////////////////////////////////////////////////
//
// hardware.h
//
///////////////////////////////////////////////////////////////////////////////

typedef enum {
   WaveInDevice = 0,
   WaveOutDevice,
   MidiOutDevice,
   MidiInDevice,
   LineInDevice,
   CDInternal,
   MixerDevice,
   AuxDevice,
   NumberOfDevices
   } SOUND_DEVICES;

///////////////////////////////////////////////////////////////////////////////
//
// hcdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// values for DeviceExtension Flags
//
#define USBDFLAG_PDO_REMOVED                0x00000001
#define USBDFLAG_HCD_SHUTDOWN               0x00000002
#define USBDFLAG_HCD_STARTED                0x00000004
#define USBDFLAG_HCD_D0_COMPLETE_PENDING    0x00000008
#define USBDFLAG_RH_DELAY_SET_D0            0x00000010


#define HC_ENABLED_FOR_WAKEUP           0x01
#define HC_WAKE_PENDING                 0x02


// device hack flags, these flags alter the stacks default behavior
// in order to support certain broken "legacy" devices

#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002

//
// This macro returns the true device object for the HCD give
// either the true device_object or a PDO owned by the HCD/BUS
// driver.
//

//
// HCD specific URB commands
//

#define URB_FUNCTION_HCD_OPEN_ENDPOINT                0x1000
#define URB_FUNCTION_HCD_CLOSE_ENDPOINT               0x1001
#define URB_FUNCTION_HCD_GET_ENDPOINT_STATE           0x1002
#define URB_FUNCTION_HCD_SET_ENDPOINT_STATE           0x1003
#define URB_FUNCTION_HCD_ABORT_ENDPOINT               0x1004

// this bit is set for all functions that must be handled by HCD
#define HCD_URB_FUNCTION                              0x1000
// this bit is set in the function code by USBD to indicate that
// this is an internal call originating from USBD
#define HCD_NO_USBD_CALL                              0x2000

//
// values for HcdEndpointState
//

//
// set if the current state of the endpoint in the HCD is 'stalled'
//
#define HCD_ENDPOINT_HALTED_BIT            0
#define HCD_ENDPOINT_HALTED                (1<<HCD_ENDPOINT_HALTED_BIT)

//
// set if the HCD has any transfers queued for the endpoint
//
#define HCD_ENDPOINT_TRANSFERS_QUEUED_BIT  1
#define HCD_ENDPOINT_TRANSFERS_QUEUED      (1<<HCD_ENDPOINT_TRANSFERS_QUEUED_BIT)


//
// set if the HCD should reset the data toggle on the host side
//
#define HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT 2
#define HCD_ENDPOINT_RESET_DATA_TOGGLE     (1<<HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT )


//
// HCD specific URBs
//

#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002
#define USBD_EP_FLAG_DOUBLE_BUFFER           0x0004
#define USBD_EP_FLAG_FAST_ISO                0x0008


///////////////////////////////////////////////////////////////////////////////
//
// hidclass\local.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for HIDCLASS_DEVICE_EXTENSION.state
//
enum deviceState {
    DEVICE_STATE_INITIALIZED,
    DEVICE_STATE_STARTING,
    DEVICE_STATE_START_SUCCESS,
    DEVICE_STATE_START_FAILURE,
    DEVICE_STATE_STOPPED,
    DEVICE_STATE_REMOVING,
    DEVICE_STATE_REMOVED,
    DEVICE_STATE_SUSPENDED
};

enum collectionState {
    COLLECTION_STATE_UNINITIALIZED,
    COLLECTION_STATE_INITIALIZED,
    COLLECTION_STATE_RUNNING,
    COLLECTION_STATE_STOPPED,
    COLLECTION_STATE_REMOVING
};

#define             HID_DEVICE_EXTENSION_SIG 'EddH'

///////////////////////////////////////////////////////////////////////////////
//
// hidparse.h
//
///////////////////////////////////////////////////////////////////////////////

#define HIDP_PREPARSED_DATA_SIGNATURE1 'PdiH'
#define HIDP_PREPARSED_DATA_SIGNATURE2 'RDK '



///////////////////////////////////////////////////////////////////////////////
//
// hivedata.h
//
///////////////////////////////////////////////////////////////////////////////



//
// ===== Basic Structures and Definitions =====
//
// These are same whether on disk or in memory.
//

//
// NOTE:    Volatile == storage goes away at reboot
//          Stable == Persistent == Not Volatile
//
typedef enum {
    Stable = 0,
    Volatile = 1
} HSTORAGE_TYPE;

#define HTYPE_COUNT 2

// --- HBASE_BLOCK --- on disk description of the hive
//

//
// NOTE:    HBASE_BLOCK must be >= the size of physical sector,
//          or integrity assumptions will be violated, and crash
//          recovery may not work.
//

#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"

#define HSYS_MAJOR          1               // Must match to read at all
#define HSYS_MINOR          3               // Must be <= to write, always
                                            // set up to writer's version.

#define HBASE_FORMAT_MEMORY 1               // Direct memory load case

#define HBASE_NAME_ALLOC    64              // 32 unicode chars

// #define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))
#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"


#define HCELL_TYPE_MASK         0x80000000
#define HCELL_TYPE_SHIFT        31

#define HCELL_TABLE_MASK        0x7fe00000
#define HCELL_TABLE_SHIFT       21

#define HCELL_BLOCK_MASK        0x001ff000
#define HCELL_BLOCK_SHIFT       12

#define HCELL_OFFSET_MASK       0x00000fff

#define HBLOCK_SIZE             0x1000      // LOGICAL block size
                                            // This is the size of one of
                                            // the registry's logical/virtual
                                            // pages.  It has no particular
                                            // relationship to page size
                                            // of the machine.

#define HSECTOR_SIZE            0x200       // LOGICAL sector size
#define HSECTOR_COUNT           8           // LOGICAL sectors / LOGICAL Block

#define HTABLE_SLOTS        512         // 9 bits of address
#define HDIRECTORY_SLOTS    1024        // 10 bits of address


///////////////////////////////////////////////////////////////////////////////
//
// io.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000



#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010



///////////////////////////////////////////////////////////////////////////////
//
// ke.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

// begin_ntddk begin_wdm
#define THREAD_WAIT_OBJECTS 3           // Builtin usable wait blocks
// end_ntddk end_wdm

#define EVENT_WAIT_BLOCK 2              // Builtin event pair wait block
#define SEMAPHORE_WAIT_BLOCK 2          // Builtin semaphore wait block
#define TIMER_WAIT_BLOCK 3              // Builtin timer wait block

#if (EVENT_WAIT_BLOCK != SEMAPHORE_WAIT_BLOCK)
#error "wait event and wait semaphore must use same wait block"
#endif

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 128


typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject
    } KOBJECTS;


typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
    BufferEmpty,
    BufferInserted,
    BufferStarted,
    BufferFinished,
    BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE;



///////////////////////////////////////////////////////////////////////////////
//
// local.h
//
///////////////////////////////////////////////////////////////////////////////
typedef enum {

    //
    // Device Object Extension Types
    //

    PciPdoExtensionType = 'icP0',
    PciFdoExtensionType,

    //
    // Arbitration Types.  (These are also secondary extensions).
    //

    PciArb_Io,
    PciArb_Memory,
    PciArb_Interrupt,
    PciArb_BusNumber,

    //
    // Translation Types.  (These are also secondary extensions).
    //

    PciTrans_Interrupt,

    //
    // Other exposed interfaces.
    //

    PciInterface_BusHandler,
    PciInterface_IntRouteHandler,
    PciInterface_PciCb,
    PciInterface_LegacyDeviceDetection,
    PciInterface_PmeHandler,
    PciInterface_DevicePresent

} PCI_SIGNATURE;

///////////////////////////////////////////////////////////////////////////////
//
// lpc.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Valid values for Flags field
//

#define PORT_TYPE                           0x0000000F
#define SERVER_CONNECTION_PORT              0x00000001
#define UNCONNECTED_COMMUNICATION_PORT      0x00000002
#define SERVER_COMMUNICATION_PORT           0x00000003
#define CLIENT_COMMUNICATION_PORT           0x00000004
#define PORT_WAITABLE                       0x20000000
#define PORT_NAME_DELETED                   0x40000000
#define PORT_DYNAMIC_SECURITY               0x80000000
#define PORT_DELETED                        0x10000000


///////////////////////////////////////////////////////////////////////////////
//
// mi.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Page protections
//

#define MM_ZERO_ACCESS         0  // this value is not used.
#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define MM_NOCACHE            0x8
#define MM_GUARD_PAGE         0x10
#define MM_DECOMMIT           0x10   //NO_ACCESS, Guard page
#define MM_NOACCESS           0x18   //NO_ACCESS, Guard_page, nocache.
#define MM_UNKNOWN_PROTECTION 0x100  //bigger than 5 bits!
#define MM_LARGE_PAGES        0x111

#define PROTECT_KSTACKS       1

#define MM_KSTACK_OUTSWAPPED  0x1F   //Debug marking for kernel stacks

#define MM_PROTECTION_WRITE_MASK     4
#define MM_PROTECTION_COPY_MASK      1
#define MM_PROTECTION_OPERATION_MASK 7 // mask off guard page and nocache.
#define MM_PROTECTION_EXECUTE_MASK   2

#define MM_SECURE_DELETE_CHECK 0x55


//
// Special pool constants
//
#define MI_SPECIAL_POOL_PAGABLE         0x8000
#define MI_SPECIAL_POOL_VERIFIER        0x4000
#define MI_SPECIAL_POOL_PTE_PAGABLE     0x0002
#define MI_SPECIAL_POOL_PTE_NONPAGABLE  0x0004

#define VI_VERIFYING_DIRECTLY   0x1
#define VI_VERIFYING_INVERSELY  0x2


#define MM_SYS_PTE_TABLES_MAX 5



///////////////////////////////////////////////////////////////////////////////
//
// mm.h
//
///////////////////////////////////////////////////////////////////////////////


typedef enum _MMLISTS {
    ZeroedPageList,
    FreePageList,
    StandbyPageList,  //this list and before make up available pages.
    ModifiedPageList,
    ModifiedNoWritePageList,
    BadPageList,
    ActiveAndValid,
    TransitionPage
} MMLISTS;

#define MM_FREE_WSLE_SHIFT 4

#define WSLE_NULL_INDEX ((ULONG64)0xFFFFFFFFFFFFFFFUI64)

//
//  GDT selectors - These defines are R0 selector numbers, which means
//                  they happen to match the byte offset relative to
//                  the base of the GDT.
//

#define KGDT_NULL       0
#define KGDT_R0_CODE    8
#define KGDT_R0_DATA    16
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_TSS        40
#define KGDT_R0_PCR     48
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64
#define KGDT_LDT        72
#define KGDT_DF_TSS     80
#define KGDT_NMI_TSS    88

//
//  GDT selectors - These defines are R0 selector numbers, which means
//                  they happen to match the byte offset relative to
//                  the base of the GDT.
//

#define KGDT_NULL       0
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64


#define GRAN_BYTE   0
#define GRAN_PAGE   1

#endif

///////////////////////////////////////////////////////////////////////////////
//
// ob.h
//
///////////////////////////////////////////////////////////////////////////////
#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40

#if 0

///////////////////////////////////////////////////////////////////////////////
//
// openhci.h
//
///////////////////////////////////////////////////////////////////////////////


//values for HcFlags
#define HC_FLAG_REMOTE_WAKEUP_CONNECTED     0x00000001
#define HC_FLAG_LEGACY_BIOS_DETECTED        0x00000002
#define HC_FLAG_SLOW_BULK_ENABLE            0x00000004
#define HC_FLAG_SHUTDOWN                    0x00000008  // not really used
#define HC_FLAG_MAP_SX_TO_D3                0x00000010
#define HC_FLAG_IDLE                        0x00000020
#define HC_FLAG_DISABLE_IDLE_CHECK          0x00000040
#define HC_FLAG_DEVICE_STARTED              0x00000080
#define HC_FLAG_LOST_POWER                  0x00000100
#define HC_FLAG_DISABLE_IDLE_MODE           0x00000200
#define HC_FLAG_USE_HYDRA_HACK              0x00000400
#define HC_FLAG_IN_DPC                      0x00000800
#define HC_FLAG_SUSPEND_NEXT_D3             0x00001000
#define HC_FLAG_LIST_FIX_ENABLE             0x00002000
#define HC_FLAG_HUNG_CHECK_ENABLE           0x00004000

#define PENDING_TD_LIST_SIZE                1000

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host


//
// The different ED lists are as follows.
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//
#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))


//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define   HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL

///////////////////////////////////////////////////////////////////////////////
//
// pci.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Note - State.c depends on the order of these.
//
typedef enum {
    PciNotStarted = 0,
    PciStarted,
    PciDeleted,
    PciStopped,
    PciSurpriseRemoved,
    PciSynchronizedOperation,
    PciMaxObjectState
} PCI_OBJECT_STATE;

//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


///////////////////////////////////////////////////////////////////////////////
//
// pcmcia.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Flags indicating card/controller state
//
#define PCMCIA_DEVICE_STARTED                  0x00000001
#define PCMCIA_DEVICE_LOGICALLY_REMOVED        0x00000002
#define PCMCIA_DEVICE_PHYSICALLY_REMOVED       0x00000004
#define PCMCIA_DEVICE_MULTIFUNCTION            0x00000008
#define PCMCIA_DEVICE_WAKE_PENDING             0x00000010
#define PCMCIA_DEVICE_LEGACY_DETECTED          0x00000020
#define PCMCIA_DEVICE_DELETED                  0x00000040
#define PCMCIA_DEVICE_CARDBUS                  0x00000080
#define PCMCIA_FILTER_ADDED_MEMORY             0x00000100
#define PCMCIA_MEMORY_24BIT                    0x00000200
#define PCMCIA_CARDBUS_NOT_SUPPORTED           0x00000400
#define PCMCIA_USE_POLLED_CSC                  0x00000800
#define PCMCIA_ATTRIBUTE_MEMORY_MAPPED         0x00001000
#define PCMCIA_SOCKET_REGISTER_BASE_MAPPED     0x00002000
#define PCMCIA_INTMODE_COMPAQ                  0x00004000
#define PCMCIA_POWER_WORKER_POWERUP            0x00008000
#define PCMCIA_SOCKET_POWER_REQUESTED          0x00010000
#define PCMCIA_CONFIG_STATUS_DEFERRED          0x00020000
#define PCMCIA_POWER_STATUS_DEFERRED           0x00040000
#define PCMCIA_INT_ROUTE_INTERFACE             0x00080000
#define PCMCIA_FDO_CONTEXT_SAVED               0x00100000
#define PCMCIA_FDO_DEFAULT_IRQ_MASK            0x00200000


//
// Socket flags
//
#define SOCKET_CARD_IN_SOCKET          0x00000001
#define SOCKET_CARD_INITIALIZED        0x00000002
#define SOCKET_CARD_POWERED_UP         0x00000004
#define SOCKET_CARD_CONFIGURED         0x00000008
#define SOCKET_CARD_MULTIFUNCTION      0x00000010
#define SOCKET_CARD_CARDBUS            0x00000020
#define SOCKET_CARD_MEMORY             0x00000040
#define SOCKET_CHANGE_INTERRUPT        0x00000080
#define SOCKET_CUSTOM_INTERFACE        0x00000100
#define SOCKET_INSERTED_SOUND_PENDING  0x00000200
#define SOCKET_REMOVED_SOUND_PENDING   0x00000400
#define SOCKET_SUPPORT_MESSAGE_SENT    0x00000800
#define SOCKET_MEMORY_WINDOW_ENABLED   0x00001000
#define SOCKET_CARD_STATUS_CHANGE      0x00002000
#define SOCKET_POWER_STATUS_DEFERRED   0x00004000

//
// Worker states for socket power operations
//
#define SPW_Stopped                 0
#define SPW_Exit                    1
#define SPW_RequestPower            2
#define SPW_ReleasePower            3
#define SPW_SetPowerOn              4
#define SPW_SetPowerOff             5
#define SPW_InitPcCard              6
#define SPW_ParentPowerUp           7
#define SPW_ParentPowerUpComplete   8


//
// Controller classes returned in socket information structure.
//

typedef enum _PCMCIA_CONTROLLER_CLASS {
   PcmciaInvalidControllerClass = -1,
   PcmciaIntelCompatible,
   PcmciaCardBusCompatible,
   PcmciaElcController,
   PcmciaDatabook,
   PcmciaPciPcmciaBridge,
   PcmciaCirrusLogic,
   PcmciaTI,
   PcmciaTopic,
   PcmciaRicoh,
   PcmciaDatabookCB,
   PcmciaOpti,
   PcmciaTrid,
   PcmciaO2Micro,
   PcmciaNEC,
   PcmciaNEC_98
} PCMCIA_CONTROLLER_CLASS, *PPCMCIA_CONTROLLER_CLASS;
#define PcmciaInvalidControllerType 0xffffffff
#define PCMCIA_INVALID_CONFIGURATION    0x00000001
// Max length of device id
#define PCMCIA_MAXIMUM_DEVICE_ID_LENGTH   128


//
// states for PdoPowerWorker
//
#define PPW_Stopped           0
#define PPW_Exit              1
#define PPW_InitialState      2
#define PPW_PowerUp           3
#define PPW_PowerUpComplete   4
#define PPW_PowerDown         5
#define PPW_PowerDownComplete 6
#define PPW_SendIrpDown       7
#define PPW_16BitConfigure    8
#define PPW_Deconfigure       9
#define PPW_VerifyCard        10
#define PPW_CardBusRefresh    11
#define PPW_CardBusDelay      12
//
// phases for ConfigurationWorker
//
// Note that the ConfigurationPhase is simply incremented, these
// definitions are just for clarity.
//
#define CW_Stopped            0
#define CW_Phase1             1
#define CW_Phase2             2
#define CW_Phase3             3
#define CW_Exit               4


///////////////////////////////////////////////////////////////////////////////
//
// pcmp.inc
//
///////////////////////////////////////////////////////////////////////////////

//
//  IMCR (Interrupt Mode Control Register) access definitions
//
#define ImcrDisableApic         0x00
#define ImcrEnableApic          0x01
#define ImcrRegPortAddr         0x22
#if defined(NEC_98)
#define ImcrDataPortAddr        0x700
#else  // defined(NEC_98)
#define ImcrDataPortAddr        0x23
#endif // defined(NEC_98)
#define ImcrPort                0x70

// Physical location where the Extended BIOS Data Area segment adress is store
#define EBDA_SEGMENT_PTR    0x40e
#define BASE_MEM_PTR        0x413

//
//  The PC+MP configuration table Possible Entry Types
//
#define ENTRY_PROCESSOR     0
#define ENTRY_BUS           1
#define ENTRY_IOAPIC        2
#define ENTRY_INTI          3
#define ENTRY_LINTI         4

#define HEADER_SIZE     0x2c


// Number of default configurations for PC+MP version 1.1
#define NUM_DEFAULT_CONFIGS  7

//
// Bits used in the CpuFlags field of the Processor entry
//
#define CPU_DISABLED        0x0   // 1 Bit  - CPU Disabled
#define CPU_ENABLED         0x1   // 1 Bit  - CPU Enabled
#define BSP_CPU             0x2   // Bit #2 - CPU is BSP

//  APIC Versions used by PC+MP systems - this is used in the
//  Processor entries and the IoApic Entries
//
#define APIC_INTEGRATED     0x10  // 8 Bits-Apic Version Register
#define APIC_82489DX        0x0   // 8 Bits-Apic Version Register

//
//  Io Apic Entry definitions
//
//  Valid IoApicFlag values
//
#define IO_APIC_ENABLED         0x1
#define IO_APIC_DISABLED        0x0


//
// Default value for Io Apic ID.
//
#define IOUNIT_APIC_ID          0xE


//
//  PC+MP Signature used to verify the PC+MP table
//  as valid
//
//          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
//
#define PCMP_SIGNATURE      0x504d4350

//
//  PC+MP Signature used to identify the floating pointer
//  structure (in extended BIOS data segment) that contains
//  a pointer to the PC+MP table.
//
//          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
//
#define MP_PTR_SIGNATURE    0x5f504d5f


//
// Extension table definitions
//

#define EXTTYPE_BUS_ADDRESS_MAP           128
#define EXTTYPE_BUS_HIERARCHY             129
#define EXTTYPE_BUS_COMPATIBLE_MAP        130
#define EXTTYPE_PERSISTENT_STORE          131


#define MPS_ADDRESS_MAP_IO                  0
#define MPS_ADDRESS_MAP_MEMORY              1
#define MPS_ADDRESS_MAP_PREFETCH_MEMORY     2
#define MPS_ADDRESS_MAP_UNDEFINED           9

//
//  The System configuration table as used by a PC_MP system
//
//
// The offset is relative to the BIOS starting at f0000H
//
#define PTR_OFFSET          0x0000e6f5
#define BIOS_BASE           0x000f0000

#define PCMP_IMPLEMENTED    0x01    // In MpFeatureInfoByte1
#define PCMP_CONFIG_MASK    0x0e    // In MpFeatureInfoByte1
#define IMCR_MASK           0x80    // In MpFeatureInfoByte2
#define MULT_CLOCKS_MASK    0x40    // In MpFeatureInfoByte2


///////////////////////////////////////////////////////////////////////////////
//
// pnpiop.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Pool tags
//

#define IOP_DNOD_TAG    'donD'
#define IOP_DNDT_TAG    'tdnD'
#define IOP_DPWR_TAG    'rwPD'

//
// Dbg scope
//

#define DBG_SCOPE 1     // Enable SOME DBG stuff on ALL builds
//#define DBG_SCOPE DBG // Enable only on DBG build


//
// DNF_MAKEUP - this devnode's device is created and owned by PnP manager
//

#define DNF_MADEUP                                  0x00000001

//
// DNF_DUPLICATE - this devnode's device is a duplicate of another enumerate PDO
//

#define DNF_DUPLICATE                               0x00000002

//
// DNF_HAL_NODE - a flag to indicate which device node is the root node created by
// the hal
//

#define DNF_HAL_NODE                                0x00000004

//
// DNF_PROCESSED - indicates if the registry instance key of the device node
//                 was created.
//

#define DNF_PROCESSED                               0x00000008

//
// DNF_ENUMERATED - used to track enumeration in IopEnumerateDevice()
//

#define DNF_ENUMERATED                              0x00000010

//
// Singal that we need to send driver query id irps
//

#define DNF_NEED_QUERY_IDS                          0x00000020

//
// THis device has been added to its controlling driver
//

#define DNF_ADDED                                   0x00000040

//
// DNF_HAS_BOOT_CONFIG - the device has resource assigned by BIOS.  It is considered
//    pseudo-started and need to participate in rebalance.
//

#define DNF_HAS_BOOT_CONFIG                         0x00000080

//
// DNF_BOOT_CONFIG_RESERVED - Indicates the BOOT resources of the device are reserved.
//

#define DNF_BOOT_CONFIG_RESERVED                    0x00000100

//
// DNF_START_REQUEST_PENDING - Indicates the device is being started.
//

#define DNF_START_REQUEST_PENDING                   0x00000200

//
// DNF_NO_RESOURCE_REQUIRED - this devnode's device does not require resource.
//

#define DNF_NO_RESOURCE_REQUIRED                    0x00000400

//
// DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED - to distinguished the
//      DeviceNode->ResourceRequirements is a filtered list or not.
//

#define DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED     0x00000800

//
// Indicates the device's resources are bing assigned (but is not done yet.)
// So don't try assign resource to this device.
//

#define DNF_ASSIGNING_RESOURCES                     0x00001000

//
// DNF_RESOURCE_ASSIGNED - this devnode's resources are assigned by PnP
//

#define DNF_RESOURCE_ASSIGNED                       0x00002000

//
// DNF_RESOURCE_REPORTED - this devnode's resources are reported by PnP
//

#define DNF_RESOURCE_REPORTED                       0x00004000

//
// DNF_RESOURCE_REQUIREMENTS_CHANGED - Indicates the device's resource
//      requirements list has been changed.
//

#define DNF_RESOURCE_REQUIREMENTS_CHANGED           0x00008000

//
// DNF_NON_STOPPED_REBALANC - indicates the device can be restarted with new
//      resources without being stopped.
//

#define DNF_NON_STOPPED_REBALANCE                   0x00010000

//
// DNF_STOPPED - indicates this device is currently stopped for reconfiguration of
//               its resources.
//

#define DNF_STOPPED                                 0x00020000

//
// DNF_STARTED - indicates if the device was started, i.e., its StartDevice
//               irp is processed.
//

#define DNF_STARTED                                 0x00040000

//
// The device's controlling driver is a legacy driver
//

#define DNF_LEGACY_DRIVER                           0x00080000

//
// For the reported detected devices, they are considered started.  We still
// need a flag to indicate we need to enumerate the device.
//

#define DNF_NEED_ENUMERATION_ONLY                   0x00100000

//
// DNF_IO_INVALIDATE_DEVICE_RELATIONS_PENDING - indicate the
//      IoInvalidateDeviceRelations request is pending and therequest needs to
//      be queued after the Query_Device_relation irp is completed.
//

#define DNF_IO_INVALIDATE_DEVICE_RELATIONS_PENDING  0x00200000

//
// Indicates the device is being sent a query device relations irp. So no more
//      q-d-r irp at the same time.
//

#define DNF_BEING_ENUMERATED                        0x00400000

//
// DNF_ENUMERATION_REQUEST_QUEUED - indicate the IoInvalidateDeviceRelations
//      request is queued.  So, new IoInvalidateDeviceRelations can be ignored.
//

#define DNF_ENUMERATION_REQUEST_QUEUED              0x00800000

//
// DNF_ENUMERATION_REQUEST_PENDING - Indicates the QUERY_DEVICE_RELATIONS irp
//      returns pending.
//

#define DNF_ENUMERATION_REQUEST_PENDING             0x01000000

//
// This corresponds to the user-mode CM_PROB_WILL_BE_REMOVED problem value and
// the DN_WILL_BE_REMOVED status flag.
//

#define DNF_HAS_PROBLEM                             0x02000000

//
// DNF_HAS_PRIVATE_PROBLEM - indicates this device reported PNP_DEVICE_FAILED
//  to a IRP_MN_QUERY_PNP_DEVICE_STATE without also reporting
//  PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED.
//

#define DNF_HAS_PRIVATE_PROBLEM                     0x04000000

//
// DNF_REMOVE_PENDING_CLOSES is set after a IRP_MN_SURPRISE_REMOVE is sent
// to a device object.  It is an indicator that IRP_MN_REMOVE_DEVICE should
// be sent to the device object as soon as all of the file objects have gone
// away.
//

#define DNF_REMOVE_PENDING_CLOSES                   0x08000000

//
// DNF_DEVICE_GONE is set when a pdo is no longer returned in a query bus
// relations.  It will then be processed as a surprise remove if started.
// This flag is used to better detect when a device is resurrected, and when
// processing surprise remove, to determine if the devnode should be removed
// from the tree.
//

#define DNF_DEVICE_GONE                             0x10000000

//
// DNF_LEGACY_RESOURCE_DEVICENODE is set for device nodes created for legacy
// resource allocation.
//

#define DNF_LEGACY_RESOURCE_DEVICENODE              0x20000000

//
// DNF_NEEDS_REBALANCE is set for device nodes that trigger rebalance.
//

#define DNF_NEEDS_REBALANCE                         0x40000000

//
// DNF_LOCKED_FOR_EJECT is set on device nodes that are being ejected or are
// related to a device being ejected.
//

#define DNF_LOCKED_FOR_EJECT                        0x80000000

//
// This corresponds to the user-mode the DN_WILL_BE_REMOVED status flag.
//

#define DNUF_WILL_BE_REMOVED                        0x00000001

//
// This corresponds to the user-mode DN_NO_SHOW_IN_DM status flag.
//

#define DNUF_DONT_SHOW_IN_UI                        0x00000002

//
// This flag is set when user-mode lets us know that a reboot is required
// for this device.
//

#define DNUF_NEED_RESTART                           0x00000004

//
// This flag is set to let the user-mode know when a device can be disabled
// it is still possible for this to be TRUE, yet disable to fail, as it's
// a polled flag (see also PNP_DEVICE_NOT_DISABLEABLE)
//

#define DNUF_NOT_DISABLEABLE                        0x00000008

//
// Flags used during shutdown when the IO Verifier is trying to remove all
// PNP devices.
//
// DNUF_SHUTDOWN_QUERIED is set when we issue the QueryRemove to a devnode.
//
// DNUF_SHUTDOWN_SUBTREE_DONE is set once we've issued the QueryRemove to all
// a Devnodes descendants.
//
#define DNUF_SHUTDOWN_QUERIED                       0x00000010
#define DNUF_SHUTDOWN_SUBTREE_DONE                  0x00000020

//
// PNP Bugcheck Subcodes
//
#define PNP_ERR_DUPLICATE_PDO                   1
#define PNP_ERR_INVALID_PDO                     2
#define PNP_ERR_BOGUS_ID                        3
#define PNP_ERR_PDO_ENUMERATED_AFTER_DELETION   4
#define PNP_ERR_ACTIVE_PDO_FREED                5

#define PNP_ERR_DEVICE_MISSING_FROM_EJECT_LIST  6
#define PNP_ERR_UNEXPECTED_ADD_RELATION_ERR     7



//
// IOP_RESOURCE_REQUEST
//

#define QUERY_RESOURCE_LIST                0
#define QUERY_RESOURCE_REQUIREMENTS        1

#define REGISTRY_ALLOC_CONFIG              1
#define REGISTRY_FORCED_CONFIG             2
#define REGISTRY_BOOT_CONFIG               4
#define REGISTRY_OVERRIDE_CONFIGVECTOR     1
#define REGISTRY_BASIC_CONFIGVECTOR        2

///////////////////////////////////////////////////////////////////////////////
//
// pnpmgr.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Private device events
//
DEFINE_GUID( GUID_DEVICE_ARRIVAL,           0xcb3a4009L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATED,        0xcb3a400AL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_ENUMERATE_REQUEST, 0xcb3a400BL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_START_REQUEST,     0xcb3a400CL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_REMOVE_PENDING,    0xcb3a400DL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_QUERY_AND_REMOVE,  0xcb3a400EL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_EJECT,             0xcb3a400FL, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_NOOP,              0xcb3a4010L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f);
DEFINE_GUID( GUID_DEVICE_SURPRISE_REMOVAL,  0xce5af000L, 0x80dd, 0x11d2, 0xa8, 0x8d, 0x00, 0xa0, 0xc9, 0x69, 0x6b, 0x4b);


//
// Standard interface device classes
//
DEFINE_GUID( GUID_CLASS_VOLUME,  0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x72);
DEFINE_GUID( GUID_CLASS_LPTPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x74);
DEFINE_GUID( GUID_CLASS_NET,     0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x75);


///////////////////////////////////////////////////////////////////////////////
//
// po.h
//
///////////////////////////////////////////////////////////////////////////////


#define PO_ORDER_NOT_VIDEO          0x0001
#define PO_ORDER_ROOT_ENUM          0x0002
#define PO_ORDER_PAGABLE            0x0004
#define PO_ORDER_MAXIMUM            0x0007

// notify GDI before this order level
#define PO_ORDER_GDI_NOTIFICATION   (PO_ORDER_PAGABLE)


///////////////////////////////////////////////////////////////////////////////
//
// pop.h
//
///////////////////////////////////////////////////////////////////////////////

//
// constants
//
#define PO_IDLE_SCAN_INTERVAL  1       // scan interval in seconds

//
// Values for ios.Parameters.SystemContext
#define POP_NO_CONTEXT      0
#define POP_FLAG_CONTEXT    1                         // if true, it's flags
#define POP_DEVICE_REQUEST  (0x2 | POP_FLAG_CONTEXT)  // an irp sent by RequestPowerChange
#define POP_INRUSH_CONTEXT  (0x4 | POP_FLAG_CONTEXT)  // the active INRUSH irp
#define POP_COUNT_CONTEXT   0xff000000                // byte used for next counting
#define POP_COUNT_SHIFT     24


#define PO_ERROR            0x00000001
#define PO_WARN             0x00000002
#define PO_BATT             0x00000004
#define PO_PACT             0x00000008
#define PO_NOTIFY           0x00000010
#define PO_THERM            0x00000020
#define PO_THROTTLE         0x00000040
#define PO_HIBERNATE        0x00000080
#define PO_POCALL           0x00000200
#define PO_SYSDEV           0x00000400
#define PO_THERM_DETAIL     0x20000000
#define PO_SIDLE            0x40000000
#define PO_HIBER_MAP        0x80000000

#define POP_SIM_CAPABILITIES                0x00000001
#define POP_SIM_ALL_CAPABILITIES            0x00000002
#define POP_ALLOW_AC_THROTTLE               0x00000004
#define POP_IGNORE_S1                       0x00000008
#define POP_IGNORE_UNSUPPORTED_DRIVERS      0x00000010
#define POP_IGNORE_S3                       0x00000020
#define POP_IGNORE_S2                       0x00000040
#define POP_LOOP_ON_FAILED_DRIVERS          0x00000080
#define POP_CRC_MEMORY                      0x00000100
#define POP_IGNORE_CRC_FAILURES             0x00000200
#define POP_TEST_CRC_MEMORY                 0x00000400
#define POP_DEBUG_HIBER_FILE                0x00000800
#define POP_RESET_ON_HIBER                  0x00001000
#define POP_IGNORE_S4                       0x00002000
#define POP_USE_S4BIOS                      0x00004000
#define POP_IGNORE_HIBER_SYMBOL_UNLOAD      0x00008000
#define POP_ENABLE_HIBER_PERF               0x00010000

//
// Universal Power Data - stored in DeviceObject->DeviceObjectExtension->PowerFlags
//

#define POPF_SYSTEM_STATE       0xf         // 4 bits for S0 to S5
#define POPF_DEVICE_STATE       0xf0        // 4 bits to hold D0 to D3


#define POPF_SYSTEM_ACTIVE      0x100       // True if S irp active at this DO
#define POPF_SYSTEM_PENDING     0x200       // True if S irp pending (0x100 must be 1)
#define POPF_DEVICE_ACTIVE      0x400       // same as SYSTEM_ACTIVE but for DEVICE
#define POPF_DEVICE_PENDING     0x800       // same as SYSTEM_PENDING but for DEVICE


#define PO_PM_USER              0x01    // nice to inform user mode, but not needed
#define PO_PM_REISSUE           0x02    // sleep promotoed to shutdown
#define PO_PM_SETSTATE          0x04    // recomputed something to do with the viable state

#define PO_ACT_IDLE                 0
#define PO_ACT_NEW_REQUEST          1
#define PO_ACT_CALLOUT              2
#define PO_ACT_SET_SYSTEM_STATE     3


//
// Types for POP_ACTION_TRIGGER
//

typedef enum {
    PolicyDeviceSystemButton,
    PolicyDeviceThermalZone,
    PolicyDeviceBattery,
    PolicyInitiatePowerActionAPI,
    PolicySetPowerStateAPI,
    PolicyImmediateDozeS4,
    PolicySystemIdle
} POP_POLICY_DEVICE_TYPE;

#define PO_TRG_USER             0x01    // User action initiated
#define PO_TRG_SYSTEM           0x02    // System action initiated
#define PO_TRG_SYNC             0x20    // Trigger is synchronous
#define PO_TRG_SET              0x80    // Event enabled or disabled

// POP_THERMAL_ZONE.State
#define PO_TZ_NO_STATE      0
#define PO_TZ_READ_STATE    1
#define PO_TZ_SET_MODE      2
#define PO_TZ_SET_ACTIVE    3

// POP_THERMAL_ZONE.Flags
#define PO_TZ_THROTTLING    0x01
#define PO_TZ_CLEANUP       0x80

#define PO_TZ_THROTTLE_SCALE    10      // temp reported in 1/10ths kelin
#define PO_TZ_NO_THROTTLE   (100 * PO_TZ_THROTTLE_SCALE)

// PopCoolingMode
#define PO_TZ_ACTIVE        0
#define PO_TZ_PASSIVE       1
#define PO_TZ_INVALID_MODE  2

//
// Action timeouts
//

#define POP_ACTION_TIMEOUT              30
#define POP_ACTION_CANCEL_TIMEOUT       5


///////////////////////////////////////////////////////////////////////////////
//
// pool.h
//
///////////////////////////////////////////////////////////////////////////////


#define POOL_QUOTA_MASK 8

#define POOL_TYPE_MASK (3)

#define POOL_OVERHEAD ((LONG)GetTypeSize("POOL_HEADER"))


//
// Define pool tracking information.
//

#define POOL_BACKTRACEINDEX_PRESENT 0x8000

///////////////////////////////////////////////////////////////////////////////
//
// range.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Range list structures
//

#define RTLP_RANGE_LIST_ENTRY_MERGED         0x0001

///////////////////////////////////////////////////////////////////////////////
//
// srb.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Port driver error codes
//

#define SP_BUS_PARITY_ERROR         0x0001
#define SP_UNEXPECTED_DISCONNECT    0x0002
#define SP_INVALID_RESELECTION      0x0003
#define SP_BUS_TIME_OUT             0x0004
#define SP_PROTOCOL_ERROR           0x0005
#define SP_INTERNAL_ADAPTER_ERROR   0x0006
#define SP_REQUEST_TIMEOUT          0x0007
#define SP_IRQ_NOT_RESPONDING       0x0008
#define SP_BAD_FW_WARNING           0x0009
#define SP_BAD_FW_ERROR             0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST 0x000b


//
// Return values for SCSI_HW_FIND_ADAPTER.
//

#define SP_RETURN_NOT_FOUND     0
#define SP_RETURN_FOUND         1
#define SP_RETURN_ERROR         2
#define SP_RETURN_BAD_CONFIG    3

//
// Notification Event Types
//

typedef enum _SCSI_NOTIFICATION_TYPE {
    RequestComplete,
    NextRequest,
    NextLuRequest,
    ResetDetected,
    CallDisableInterrupts,
    CallEnableInterrupts,
    RequestTimerCall,
    BusChangeDetected,     /* New */
    WMIEvent,
    WMIReregister
} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19

//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)
#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01


///////////////////////////////////////////////////////////////////////////////
//
// trackirp.h
//
///////////////////////////////////////////////////////////////////////////////

#define DOE_DESIGNATED_FDO             0x80000000
#define DOE_BOTTOM_OF_FDO_STACK        0x40000000
#define DOE_RAW_FDO                    0x20000000
#define DOE_EXAMINED                   0x10000000
#define DOE_TRACKED                    0x08000000


#define ASSERTFLAG_TRACKIRPS           0x00000001
#define ASSERTFLAG_MONITOR_ALLOCS      0x00000002
#define ASSERTFLAG_POLICEIRPS          0x00000004
#define ASSERTFLAG_MONITORMAJORS       0x00000008
#define ASSERTFLAG_SURROGATE           0x00000010
#define ASSERTFLAG_SMASH_SRBS          0x00000020
#define ASSERTFLAG_CONSUME_ALWAYS      0x00000040
#define ASSERTFLAG_FORCEPENDING        0x00000080
#define ASSERTFLAG_COMPLETEATDPC       0x00000100
#define ASSERTFLAG_COMPLETEATPASSIVE   0x00000200
#define ASSERTFLAG_DEFERCOMPLETION     0x00000800
#define ASSERTFLAG_ROTATE_STATUS       0x00001000
//                                     ----------
#define ASSERTMASK_COMPLETESTYLE       0x00000F80
#define ASSERTFLAG_SEEDSTACK           0x00010000

//
// Disabling HACKHACKS_ENABLED will remove support for all hack code. The
// hack code allows the machine to fully boot in checked builds. Note that
// those hacks can be individually disabled by setting the IovpHackFlags
// variable at boot time.
//
#define HACKHACKS_ENABLED
#define HACKFLAG_FOR_MUP               0x00000001
#define HACKFLAG_FOR_SCSIPORT          0x00000002
#define HACKFLAG_FOR_ACPI              0x00000004
#define HACKFLAG_FOR_BOGUSIRPS         0x00000008


///////////////////////////////////////////////////////////////////////////////
//
// uhcd.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Interrupt Mask register bits
//
#define UHCD_INT_MASK_SHORT_BIT         3
#define UHCD_INT_MASK_SHORT             (1<<UHCD_INT_MASK_SHORT_BIT)

#define UHCD_INT_MASK_IOC_BIT           2
#define UHCD_INT_MASK_IOC               (1<<UHCD_INT_MASK_IOC_BIT)

#define UHCD_INT_MASK_RESUME_BIT        1
#define UHCD_INT_MASK_RESUME            (1<<UHCD_INT_MASK_RESUME_BIT)

#define UHCD_INT_MASK_TIMEOUT_BIT       0
#define UHCD_INT_MASK_TIMEOUT           (1<<UHCD_INT_MASK_TIMEOUT_BIT)


//
// Port Register Bits
//

#define UHCD_PORT_ENABLE_BIT            2
#define UHCD_PORT_ENABLE                (1<<UHCD_PORT_ENABLE_BIT)


//
// Command Register Bits
//

#define UHCD_CMD_RUN_BIT                0
#define UHCD_CMD_RUN                    (USHORT)(1<<UHCD_CMD_RUN_BIT)

#define UHCD_CMD_RESET_BIT              1
#define UHCD_CMD_RESET                  (USHORT)(1<<UHCD_CMD_RESET_BIT)

#define UHCD_CMD_GLOBAL_RESET_BIT       2
#define UHCD_CMD_GLOBAL_RESET           (USHORT)(1<<UHCD_CMD_GLOBAL_RESET_BIT)

#define UHCD_CMD_SUSPEND_BIT            3
#define UHCD_CMD_SUSPEND                (USHORT)(1<<UHCD_CMD_SUSPEND_BIT)

#define UHCD_CMD_FORCE_RESUME_BIT       4
#define UHCD_CMD_FORCE_RESUME           (USHORT)(1<<UHCD_CMD_FORCE_RESUME_BIT)

#define UHCD_CMD_SW_DEBUG_BIT           5
#define UHCD_CMD_SW_DEBUG               (USHORT)(1<<UHCD_CMD_SW_DEBUG_BIT)

#define UHCD_CMD_SW_CONFIGURED_BIT      6
#define UHCD_CMD_SW_CONFIGURED          (USHORT)(1<<UHCD_CMD_SW_CONFIGURED_BIT)

#define UHCD_CMD_MAXPKT_64_BIT          7
#define UHCD_CMD_MAXPKT_64              (USHORT)(1<<UHCD_CMD_MAXPKT_64_BIT)



//
// Status Register Bits
//

#define UHCD_STATUS_USBINT_BIT          0
#define UHCD_STATUS_USBINT              (1<<UHCD_STATUS_USBINT_BIT)

#define UHCD_STATUS_USBERR_BIT          1
#define UHCD_STATUS_USBERR              (1<<UHCD_STATUS_USBERR_BIT)

#define UHCD_STATUS_RESUME_BIT          2
#define UHCD_STATUS_RESUME              (1<<UHCD_STATUS_RESUME_BIT)

#define UHCD_STATUS_PCIERR_BIT          3
#define UHCD_STATUS_PCIERR              (1<<UHCD_STATUS_PCIERR_BIT)

#define UHCD_STATUS_HCERR_BIT           4
#define UHCD_STATUS_HCERR               (1<<UHCD_STATUS_HCERR_BIT)

#define UHCD_STATUS_HCHALT_BIT          5
#define UHCD_STATUS_HCHALT              (1<<UHCD_STATUS_HCHALT_BIT)

// number of bit times in a USB frame based on a 12MHZ SOF clock
#define UHCD_12MHZ_SOF              11936
//
// values for HcFlags
//

// Set to indicate port resources were assigned
#define HCFLAG_GOT_IO                   0x00000001
// Set at initialization to indicate that the base register
// address must be unmapped when the driver is unloaded.
#define HCFLAG_UNMAP_REGISTERS          0x00000002
// Set if we have a USB BIOS on this system
#define HCFLAG_USBBIOS                  0x00000004
// Current state of BW reclimation
#define HCFLAG_BWRECLIMATION_ENABLED    0x00000008
// This flag indicates if the driver needs to cleanup resources
// allocated in start_device.
#define HCFLAG_NEED_CLEANUP             0x00000010
// HC is idle
#define HCFLAG_IDLE                     0x00000020
// set when the rollover int is disabled
#define HCFLAG_ROLLOVER_IDLE            0x00000040
// set when the controller is stopped
#define HCFLAG_HCD_STOPPED              0x00000080
// turn off idle check
#define HCFLAG_DISABLE_IDLE             0x00000100
// work item queued
#define HCFLAG_WORK_ITEM_QUEUED         0x00000200
// hcd has shut down
#define HCFLAG_HCD_SHUTDOWN             0x00000400
// indicates we need to restore HC from hibernate
#define HCFLAG_LOST_POWER               0x00000800
// set when root hub turns off the HC
#define HCFLAG_RH_OFF                   0x00001000

#define HCFLAG_MAP_SX_TO_D3             0x00002000
// set if we will be suspending in this D3
#define HCFLAG_SUSPEND_NEXT_D3          0x00004000

///////////////////////////////////////////////////////////////////////////////
//
// usbdi.h
//
///////////////////////////////////////////////////////////////////////////////

//
//  URB request codes
//

#define URB_FUNCTION_SELECT_CONFIGURATION            0x0000
#define URB_FUNCTION_SELECT_INTERFACE                0x0001
#define URB_FUNCTION_ABORT_PIPE                      0x0002
#define URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL       0x0003
#define URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL    0x0004
#define URB_FUNCTION_GET_FRAME_LENGTH                0x0005
#define URB_FUNCTION_SET_FRAME_LENGTH                0x0006
#define URB_FUNCTION_GET_CURRENT_FRAME_NUMBER        0x0007
#define URB_FUNCTION_CONTROL_TRANSFER                0x0008
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      0x0009
#define URB_FUNCTION_ISOCH_TRANSFER                  0x000A
#define URB_FUNCTION_RESET_PIPE                      0x001E

//
// These functions correspond
// to the standard commands on the default pipe
//
// direction is implied
//

#define URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE     0x000B
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT   0x0024
#define URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE  0x0028

#define URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE       0x000C
#define URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT     0x0025
#define URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE    0x0029

#define URB_FUNCTION_SET_FEATURE_TO_DEVICE          0x000D
#define URB_FUNCTION_SET_FEATURE_TO_INTERFACE       0x000E
#define URB_FUNCTION_SET_FEATURE_TO_ENDPOINT        0x000F
#define URB_FUNCTION_SET_FEATURE_TO_OTHER           0x0023

#define URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE        0x0010
#define URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE     0x0011
#define URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT      0x0012
#define URB_FUNCTION_CLEAR_FEATURE_TO_OTHER         0x0022

#define URB_FUNCTION_GET_STATUS_FROM_DEVICE         0x0013
#define URB_FUNCTION_GET_STATUS_FROM_INTERFACE      0x0014
#define URB_FUNCTION_GET_STATUS_FROM_ENDPOINT       0x0015
#define URB_FUNCTION_GET_STATUS_FROM_OTHER          0x0021

// direction is specified in TransferFlags

#define URB_FUNCTION_RESERVED0                      0x0016

//
// These are for sending vendor and class commands
// on the default pipe
//
// direction is specified in TransferFlags
//

#define URB_FUNCTION_VENDOR_DEVICE                   0x0017
#define URB_FUNCTION_VENDOR_INTERFACE                0x0018
#define URB_FUNCTION_VENDOR_ENDPOINT                 0x0019
#define URB_FUNCTION_VENDOR_OTHER                    0x0020

#define URB_FUNCTION_CLASS_DEVICE                    0x001A
#define URB_FUNCTION_CLASS_INTERFACE                 0x001B
#define URB_FUNCTION_CLASS_ENDPOINT                  0x001C
#define URB_FUNCTION_CLASS_OTHER                     0x001F

//
// Reserved function codes
//
#define URB_FUNCTION_RESERVED                        0x001D

#define URB_FUNCTION_GET_CONFIGURATION               0x0026
#define URB_FUNCTION_GET_INTERFACE                   0x0027

#define URB_FUNCTION_LAST                            0x0029




///////////////////////////////////////////////////////////////////////////////
//
// usbhub.h
//
///////////////////////////////////////////////////////////////////////////////

//
// Hub and Port status defined below also apply to StatusChnage bits
//
#define HUB_STATUS_LOCAL_POWER      0x01
#define HUB_STATUS_OVER_CURRENT     0x02

#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200


#define HUBFLAG_NEED_CLEANUP        0x00000001
#define HUBFLAG_ENABLED_FOR_WAKEUP  0x00000002
#define HUBFLAG_DEVICE_STOPPING     0x00000004
#define HUBFLAG_HUB_FAILURE         0x00000008
#define HUBFLAG_SUPPORT_WAKEUP      0x00000010
#define HUBFLAG_HUB_STOPPED         0x00000020
#define HUBFLAG_HUB_BUSY            0x00000040
#define HUBFLAG_PENDING_WAKE_IRP    0x00000080
#define HUBFLAG_PENDING_PORT_RESET  0x00000100
#define HUBFLAG_HUB_HAS_LOST_BRAINS 0x00000200

#define USBH_MAX_ENUMERATION_ATTEMPTS   3

//
// Common fields for Pdo and Fdo extensions
//
#define EXTENSION_TYPE_PORT 0x54524f50      // "PORT"
#define EXTENSION_TYPE_HUB  0x20425548      // "HUB "
#define EXTENSION_TYPE_PARENT  0x50525400   // "PRT "
#define EXTENSION_TYPE_FUNCTION  0xfefefeff   // ""


//
// values for PortPdoFlags
//

#define PORTPDO_DEVICE_IS_HUB               0x00000001
#define PORTPDO_DEVICE_IS_PARENT            0x00000002
#define PORTPDO_DEVICE_ENUM_ERROR           0x00000004
#define PORTPDO_LOW_SPEED_DEVICE            0x00000008
#define PORTPDO_REMOTE_WAKEUP_SUPPORTED     0x00000010
#define PORTPDO_REMOTE_WAKEUP_ENABLED       0x00000020
#define PORTPDO_DELETED_PDO                 0x00000040
#define PORTPDO_DELETE_PENDING              0x00000080
#define PORTPDO_NEED_RESET                  0x00000100
#define PORTPDO_STARTED                     0x00000200
#define PORTPDO_WANT_POWER_FEATURE          0x00000400
#define PORTPDO_SYM_LINK                    0x00000800
#define PORTPDO_DEVICE_FAILED               0x00001000
#define PORTPDO_USB_SUSPEND                 0x00002000
#define PORTPDO_OVERCURRENT                 0x00004000
#define PORTPDO_DD_REMOVED                  0x00008000
#define PORTPDO_NOT_ENOUGH_POWER            0x00010000
#define PORTPDO_PDO_RETURNED                0x00020000
#define PORTPDO_NO_BANDWIDTH                0x00040000
#define PORTPDO_RESET_PENDING               0x00080000


///////////////////////////////////////////////////////////////////////////////
//
// wdm.h
//
///////////////////////////////////////////////////////////////////////////////


//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)


///////////////////////////////////////////////////////////////////////////////
//
// wdmaud.h
//
///////////////////////////////////////////////////////////////////////////////

#define WDMAUD_CTL_CODE CTL_CODE

#define IOCTL_SOUND_BASE    FILE_DEVICE_SOUND
#define IOCTL_WDMAUD_BASE   0x0000
#define IOCTL_WAVE_BASE     0x0040
#define IOCTL_MIDI_BASE     0x0080
#define IOCTL_MIXER_BASE    0x00C0

#define IOCTL_WDMAUD_INIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_ADD_DEVNODE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_REMOVE_DEVNODE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_CAPABILITIES          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_NUM_DEVS              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_OPEN_PIN                  WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_CLOSE_PIN                 WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_GET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_VOLUME                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0008, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_EXIT                      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x0009, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_SET_PREFERRED_DEVICE      WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WDMAUD_BASE + 0x000a, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_OUT_PAUSE            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_PLAY             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_POS          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN        WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0007, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_WAVE_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_GET_POS           WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_WAVE_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_WAVE_BASE + 0x0014, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_OUT_RESET            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA       WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIDI_IN_STOP              WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0010, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RECORD            WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0011, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_RESET             WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0012, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIDI_IN_READ_PIN          WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x0013, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_WDMAUD_MIXER_OPEN                WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_CLOSE               WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0001, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINEINFO         WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0002, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETLINECONTROLS     WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0003, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0004, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0005, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_WDMAUD_MIXER_GETHARDWAREEVENTDATA   WDMAUD_CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIXER_BASE + 0x0006, METHOD_BUFFERED, FILE_WRITE_ACCESS)


///////////////////////////////////////////////////////////////////////////////
//
// wdguid.h
//
///////////////////////////////////////////////////////////////////////////////
//
// Device events that can be broadcasted to drivers and user-mode apps.
//
DEFINE_GUID( GUID_HWPROFILE_QUERY_CHANGE,          0xcb3a4001L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_CANCELLED,      0xcb3a4002L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_HWPROFILE_CHANGE_COMPLETE,       0xcb3a4003L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_ARRIVAL,        0xcb3a4004L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_DEVICE_INTERFACE_REMOVAL,        0xcb3a4005L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_QUERY_REMOVE,      0xcb3a4006L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_CANCELLED,  0xcb3a4007L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_TARGET_DEVICE_REMOVE_COMPLETE,   0xcb3a4008L, 0x46f0, 0x11d0, 0xb0, 0x8f, 0x00, 0x60, 0x97, 0x13, 0x05, 0x3f );
DEFINE_GUID( GUID_PNP_CUSTOM_NOTIFICATION,         0xACA73F8EL, 0x8D23, 0x11D1, 0xAC, 0x7D, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
DEFINE_GUID( GUID_PNP_POWER_NOTIFICATION,          0xC2CF0660L, 0xEB7A, 0x11D1, 0xBD, 0x7F, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
#endif

#endif // _EXTFLAGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/
#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#define EXIT_API     ExtRelease

extern WINDBG_EXTENSION_APIS ExtensionApis;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\inc\usbhcdi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb_hcdi.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __USB_HCDI_H__
#define   __USB_HCDI_H__

/*
    Power management rules for USB host controllers transitioning from 
    USB suspend to USB working.  This is what we expect for 
    S3->S0
    S1->S0

    1. The controller must not reset the USB bus or cause a disconnect or power 
       loss on any of the root USB ports.
    2. The system BIOS must not enable any type of legacy USB BIOS or otherwise 
       enable the host controller to a run state.
    3. If a PCI reset occurs in addition to rule 1 the BIOS must restore all 
       host registers to their state prior to entering low power.  Root ports 
       should NOT indicate connect or enable status changes.
    4. The controller hardware must be in a functional state -- capable of 
       driving resume and entering the run state without requiring a global
       hardware reset that otherwise would result in a USB bus reset driven on 
       the root ports.
    
*/

#define USB_BAD_PTR     ((PVOID) (-1))

/* status code returned by core functions */

typedef enum _USB_MINIPORT_STATUS {

    USBMP_STATUS_SUCCESS = 0,
    USBMP_STATUS_BUSY,
    USBMP_STATUS_NO_RESOURCES,
    USBMP_STATUS_NO_BANDWIDTH,
    USBMP_STATUS_INIT_FAILURE,
    USBMP_STATUS_FAILURE,
    USBMP_STATUS_NOT_SUPPORTED,
    USBMP_STATUS_HARDWARE_FAILURE,
    USBMP_STATUS_NTERRCODE_NOT_MAPPFED,
    
} USB_MINIPORT_STATUS;


/* define a test guids for the miniport pass-thru interface */
/* {53D3650A-A4E7-4b0f-BC1D-B76DEB40FA1E}*/
DEFINE_GUID(MINIPORT_PASSTHRU_TEST_GUID, 
0x53d3650a, 0xa4e7, 0x4b0f, 0xbc, 0x1d, 0xb7, 0x6d, 0xeb, 0x40, 0xfa, 0x1e);

/* {386289AA-02EC-486e-925E-838931877F4B}*/
DEFINE_GUID(MINIPORT_PASSTHRU_TEST_BADGUID, 
0x386289aa, 0x2ec, 0x486e, 0x92, 0x5e, 0x83, 0x89, 0x31, 0x87, 0x7f, 0x4b);
// {386289AA-02EC-486e-925E-838931877F4B}

#define TEST_FLAG(var, flag)    (((var) & (flag)) ? TRUE : FALSE)
#define CLEAR_FLAG(var, flag)   ((var) &= ~(flag))
#define SET_FLAG(var, flag)     ((var) |= (flag))

/* 
    Definition for the 32 bit physical address 
    that controller hardware understands.

    If a miniport HW structure only supports 32 bit
    physical addresses then this type is used to 
    indicate it.
    
*/   
typedef ULONG HW_32BIT_PHYSICAL_ADDRESS; 
typedef HW_32BIT_PHYSICAL_ADDRESS *PHW_32BIT_PHYSICAL_ADDRESS;

typedef PHYSICAL_ADDRESS HW_64BIT_PHYSICAL_ADDRESS; 


typedef struct _MP_HW_PHYSICAL_ADDRESS {
    union {
        HW_32BIT_PHYSICAL_ADDRESS Hw32;
        HW_64BIT_PHYSICAL_ADDRESS Hw64;
    };
} MP_HW_PHYSICAL_ADDRESS, *PMP_HW_PHYSICAL_ADDRESS;

C_ASSERT((sizeof(MP_HW_PHYSICAL_ADDRESS) == 8));

/* 
   This structure is used for pointers embedded in 
   HW structures by the miniport.  They is always sized 
   for 64 bit to limit 32/64 bit porting problems.
*/

typedef struct _MP_HW_POINTER {
        PVOID Pointer;
#ifndef _WIN64      
        ULONG PadTo8;
#endif        
} MP_HW_POINTER, *PMP_HW_POINTER;

C_ASSERT((sizeof(MP_HW_POINTER) == 8));

typedef struct _MP_HW_LIST_ENTRY {
   LIST_ENTRY List; 
#ifndef _WIN64        
   ULONG PadTo16[2];
#endif     
} MP_HW_LIST_ENTRY, *PMP_HW_LIST_ENTRY;

C_ASSERT((sizeof(MP_HW_LIST_ENTRY) == 16));


#define PENDPOINT_DATA PVOID
#define PDEVICE_DATA PVOID
#define PTRANSFER_CONTEXT PVOID

/* 
    we redifine the USBDI HCD AREA for the miniport model
*/
struct _USBPORT_DATA {
    PVOID HcdTransferContext;
    PVOID UrbSig;
    PVOID Reserved7[6];
};

#ifdef _WIN64
#define URB_SIG ((PVOID) 0xDEADF00DDEADF00D)
#else
#define URB_SIG ((PVOID) 0xDEADF00D)
#endif

//C_ASSERT(sizeof(struct _URB_HCD_AREA) ==  sizeof(struct _USBPORT_DATA))

#define IN_TRANSFER(tp)       (((tp)->TransferFlags & \
                                USBD_TRANSFER_DIRECTION_IN) ? TRUE : FALSE)

#define SHORT_TRANSFER_OK(tp) (((tp)->TransferFlags & \
                                 USBD_SHORT_TRANSFER_OK) ? TRUE : FALSE)
                                
/*
Common transfer request parameter definition, all transfer
requests passed to the miniport will be mapped to this
format.  The miniport will/can use this structure to
reference fields that are common to all transfers
as well as fields specific to isochronous and
control transfers.
*/

#define MPTX_SPLIT_TRANSFER             0x00000001

typedef struct _TRANSFER_PARAMETERS {

    /* identical to URB field */
    ULONG TransferFlags;
    /* identical to URB field */
    ULONG TransferBufferLength;
    /* uniquely identifies a transfer set */ 
    ULONG SequenceNumber;
    /* miniport special handling requirements */
    ULONG MiniportFlags;
    /* USB frame this transfer completed in */
    ULONG FrameCompleted;
    /* setup packet for control transfers */
    UCHAR SetupPacket[8];  

} TRANSFER_PARAMETERS, *PTRANSFER_PARAMETERS;

typedef struct _MINIPORT_ISO_PACKET {
    /*
      length of this packet
    */
    ULONG Length;
    /*
       bytes transferred this packet
     */
    ULONG LengthTransferred;
    /*
       virtual frame to transmit this packet
    */
    ULONG FrameNumber;
    ULONG MicroFrameNumber;
    /*
       completion code for this packet
     */
    USBD_STATUS UsbdStatus;
    
    ULONG BufferPointerCount;
    
    /* support up to 2 sg entries per packet */
    /* max packet size for a USB 1.1 frame is ~1024 bytes*/
    
    ULONG BufferPointer0Length;
    MP_HW_PHYSICAL_ADDRESS BufferPointer0;

    ULONG BufferPointer1Length;
    MP_HW_PHYSICAL_ADDRESS BufferPointer1;

} MINIPORT_ISO_PACKET, *PMINIPORT_ISO_PACKET;


typedef struct _MINIPORT_ISO_TRANSFER {

    ULONG Sig;
    ULONG PacketCount;
    PUCHAR SystemAddress;
    MINIPORT_ISO_PACKET Packets[1];
    
} MINIPORT_ISO_TRANSFER, *PMINIPORT_ISO_TRANSFER;


/* 
    These structures are used to pass IoMapped transfer
    buffers to the miniport
*/    

//
// Page size and shift value used by the OHCI, EHCI and UHCI
// controller  usb controllers use a defined 
//
// this must always be 4k -- it is defined by the controller HW
#define USB_PAGE_SIZE       0x00001000

#define USB_PAGE_SHIFT      12L


typedef struct _TRANSFER_SG_ENTRY32 {
    MP_HW_PHYSICAL_ADDRESS LogicalAddress;
    PUCHAR SystemAddress;
    ULONG Length;
    ULONG StartOffset;
} TRANSFER_SG_ENTRY32, *PTRANSFER_SG_ENTRY32;

#define USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE   0x00000001

typedef struct _TRANSFER_SG_LIST { 
    ULONG SgFlags;
    PUCHAR MdlVirtualAddress;
    PUCHAR MdlSystemAddress;
    ULONG SgCount;
    TRANSFER_SG_ENTRY32 SgEntry[1];  
} TRANSFER_SG_LIST, *PTRANSFER_SG_LIST;


/************************************************************** 
 **************************************************************
USBPORT Interface Services    

    NOTES:
        - these functions are callable at raised IRQL

        
***************************************************************    
***************************************************************/

#define USBPRTFN __stdcall

/* 
VOID
USBPORTSVC_InvalidateEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

*/

typedef VOID
    (USBPRTFN *PPORTFN_INVALIDATE_ENDPOINT) (
        PDEVICE_DATA,
        PENDPOINT_DATA
    );

/*
PUCHAR
USBPORTSVC_MapHwPhysicalToVirtual(
    HW_32BIT_PHYSICAL_ADDRESS HwPhysicalAddress,
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData    
    )

    maps a physical address from the miniport to 
    a virtual address
*/

typedef PUCHAR
    (USBPRTFN *PPORTFN_PHYS_TO_VIRTUAL) (
        HW_32BIT_PHYSICAL_ADDRESS,
        PDEVICE_DATA,
        PENDPOINT_DATA   
    );

/* 
VOID
USBPORTSVC_CompleteTransfer(
    PDEVICE_DATA DeviceData
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    USBD_STATUS UsbdStatus,
    ULONG BytesTransferred
    );

    Called by miniport to complete an async transfer request
*/

typedef VOID
    (USBPRTFN *PPORTFN_COMPLETE_TRANSFER) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        USBD_STATUS,
        ULONG
    );

/* 
VOID
USBPORTSVC_CompleteIsoTransfer(
    PDEVICE_DATA DeviceData
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

    Called by miniport to complete an iso transfer request
*/

typedef VOID
    (USBPRTFN *PPORTFN_COMPLETE_ISO_TRANSFER) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PMINIPORT_ISO_TRANSFER
    );
    

/* ROOT HUB functions */


/* 
VOID
USBPORTSVC_InvalidateRootHub(
    PDEVICE_DATA DeviceData
    );

    Called by the miniport to indicate the root hub
    needs attention
    
*/

typedef VOID
    (USBPRTFN *PPORTFN_INVALIDATE_ROOTHUB) (
        PDEVICE_DATA
    );


/* Debug functions */

/* 
VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    PVOID Arg0,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4,
    PVOID Arg5
    );

    Called by miniport to print a message to the debugger
    the message is printed if the var USBPORT_DEBUG_TRACE_LEVEL 
    is >= level.
*/

typedef VOID
    (USBPRTFN *PPORTFN_DBGPRINT) (
        PDEVICE_DATA,
        ULONG,
        PCH,
        int, 
        int,
        int,
        int,
        int,
        int
    );

/* 
VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    );

   Triggers a break in the debugger in the registry key
   debugbreakOn is set.  These breakpoins are useful for
   debugging hardware/client software problems
 
*/

typedef VOID
    (USBPRTFN *PPORTFN_TEST_DEBUG_BREAK) (
        PDEVICE_DATA
    );

/* 
VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

 
*/

typedef VOID
    (USBPRTFN *PPORTFN_ASSERT_FAILURE) (
        PDEVICE_DATA,
        PVOID,
        PVOID,
        ULONG,
        PCHAR
    );

/* 
VOID
USBPORTSVC_LogEntry(
    PDEVICE_DATA DeviceData,
    
    );

 
*/

/* Miniport LOG MASKS */
#define G 0x10000001    /* always log */

typedef VOID
    (USBPRTFN *PPORTFN_LOGENTRY) (
        PDEVICE_DATA,
        ULONG,
        ULONG, 
        ULONG_PTR, 
        ULONG_PTR, 
        ULONG_PTR
    );    

/* other functions */

/*
USB_MINIPORT_STATUS 
USBPORTSVC_ReadWriteConfigSpace(
    PDEVICE_DATA DeviceData,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
    
    reads a registry key value from the branch associated 
    with the PDO for the host controller.

    this API reads from either the software or hardware 
    branch

    this function cannot be called at raised IRQL
*/

typedef USB_MINIPORT_STATUS
    (USBPRTFN *PPORTFN_READWRITE_CONFIG_SPACE) (
        PDEVICE_DATA,
        BOOLEAN,
        PVOID,
        ULONG,
        ULONG
    );

/*
VOID 
USBPORTSVC_Wait(
    PDEVICE_DATA DeviceData,
    ULONG MillisecondsToWait
    )

    Execute a syncronous wait for a specified number of 
    milliseconds        
*/

typedef VOID
    (USBPRTFN *PPORTFN_WAIT) (
        PDEVICE_DATA,
        ULONG
    );

/*
VOID 
USBPORTSVC_BugCheck(
    PDEVICE_DATA DeviceData
    )

*/

typedef VOID
    (USBPRTFN *PPORTFN_BUGCHECK) (
        PDEVICE_DATA
    );
    

/*
VOID 
USBPORTSVC_NotifyDoubleBuffer(
    PDEVICE_DATA DeviceData
    PTRANSFER_PARAMETERS TransferParameters,
    PVOID SystemAddress,
    ULONG Length
    )

*/

typedef VOID
    (USBPRTFN *PPORTFN_NOTIFY_DOUBLE_BUFFER) (
        PDEVICE_DATA, 
        PTRANSFER_PARAMETERS,
        PVOID,
        ULONG
    );


/*
USB_MINIPORT_STATUS 
USBPORTSVC_GetMiniportRegistryKeyValue(
    PDEVICE_DATA DeviceData,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
    
    reads a registry key value from the branch associated 
    with the PDO for the host controller.

    this API reads from either the software or hardware 
    branch

    this function cannot be called at raised IRQL
*/

typedef USB_MINIPORT_STATUS
    (USBPRTFN *PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE) (
        PDEVICE_DATA,
        BOOLEAN,
        PWCHAR,
        ULONG,
        PVOID,
        ULONG
    );


/*
VOID 
USBPORTSVC_RequestAsyncCallback(
    PDEVICE_DATA DeviceData,
    ULONG MilliSecondInterval,    
    PVOID Context,
    ULONG ContextLength,
    PMPFN_MINIPORT_CALLBACK Callback    
    )

    request an async callback when the millisecond interval
    has elapsed.

    The context field is copied ant the miniport is called back
    with the copy so it is safe for the miniport to use a stack 
    variable as context.
*/

/*++
    CallBack Definition for async notifiaction service
--*/

typedef VOID
    (__stdcall *PMINIPORT_CALLBACK) (
        PDEVICE_DATA,
        PVOID
    );         

typedef VOID
    (USBPRTFN *PPORTFN_REQUEST_ASYNC_CALLBACK) (
        PDEVICE_DATA,
        ULONG,
        PVOID,
        ULONG,
        PMINIPORT_CALLBACK    
    );

/*
VOID 
USBPORTSVC_InvalidateController(
    PDEVICE_DATA DeviceData,
    USB_CONTROLLER_STATE ControllerState
    )

*/

typedef enum _USB_CONTROLLER_STATE {

    UsbMpControllerPowerFault,
    UsbMpControllerNeedsHwReset,
    UsbMpControllerRemoved,
    UsbMpSimulateInterrupt
    
} USB_CONTROLLER_STATE;


typedef VOID
    (__stdcall *PPORTFN_INVALIDATE_CONTROLLER) (
        PDEVICE_DATA,
        USB_CONTROLLER_STATE
    );  

/************************************************************** 
 **************************************************************
USB MINIPORT interface functions

    prototypes for functions called by the USB port driver
    (usbport)
***************************************************************    
***************************************************************/

#define USBMPFN __stdcall

/***************************************************************
CORE Functions

    The following core functions are serialized as a group they 
    are assocaited with processing data transfers on the bus

 
   MINIPORT_SubmitTransfer
   MINIPORT_SubmitIsoTransfer
   MINIPORT_AbortTransfer
   MINIPORT_OpenEndpoint
   MINIPORT_RebalanceEndpoint
   MINIPORT_QueryEndpointRequirements
   MINIPORT_CloseEndpoint
   MINIPORT_SetEndpointState
   MINIPORT_GetEndpointState
   MINIPORT_PokeEndpoint
   MINIPORT_PollEndpoint
   MINIPORT_Get32bitFrameNumber
   MINIPORT_InterruptNextSOF
   MINIPORT_PollController
   
    
****************************************************************/

/*++
    MINIPORT_SubmitTransfer
    
    program a USB transfer, iso, bulk, interrupt or control to the hardware.  
    if no resources are avaiable then return USBMP_STATUS_BUSY.

    if the transfer is successfully queued to the HW then return 
        USBMP_STATUS_SUCCESS
    

    NOTES:
        -At the time this routine is called the transfer buffer has been 
         mapped (ie no need to call IoMapTransfer).

    URB_FUNCTION_CONTROL_TRANSFER                
    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER      

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SUBMIT_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PTRANSFER_CONTEXT,
        PTRANSFER_SG_LIST
    );

/*++
    MINIPORT_SubmitTransfer
    
    program a USB transfer, iso, bulk, interrupt or control to the hardware.  
    if no resources are avaiable then return USBMP_STATUS_BUSY.

    if the transfer is successfully queued to the HW then return 
        USBMP_STATUS_SUCCESS
    

    NOTES:
        -At the time this routine is called the transfer buffer has been 
         mapped (ie no need to call IoMapTransfer).

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SUBMIT_ISO_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_PARAMETERS,
        PTRANSFER_CONTEXT,
        PMINIPORT_ISO_TRANSFER
    );
    

/*++
    MINIPORT_AbortTransfer

    abort a specfic transfer that has been started, this will only be 
    called if the endpoint is in the ENDPOINT_PAUSED state.

    this call is NOT failable and the HW must have no reference to 
    the transfer on return.

    The miniport does not indicate completion.

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_AbortTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PULONG BytesTransferred
    );    
--*/

typedef VOID
    (USBMPFN *PMPFN_ABORT_TRANSFER) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        PTRANSFER_CONTEXT,
        PULONG 
    );

/*++
    MINIPORT_OpenEndpoint

    open an endpoint.
    
    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    on return the endpoint should be in the PAUSE state

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_OpenEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );    
--*/

typedef enum _ENDPOINT_TRANSFER_TYPE {
    Isochronous = 0,
    Control,
    Bulk,
    Interrupt
} ENDPOINT_TRANSFER_TYPE;


typedef enum _ENDPOINT_TRANSFER_DIRECTION {
    In = 0,
    Out
} ENDPOINT_TRANSFER_DIRECTION;

typedef enum _DEVICE_SPEED {
    LowSpeed = 0,
    FullSpeed,
    HighSpeed
} DEVICE_SPEED;


/* these values are input by the port driver */

/*
    Bandwidth Mamagement:

    All bandwidth allocation is managed by the port driver.  The 
    bandwidth consumed by an endpoint is passed to the miniport 
    but this is purely informational.

    Load balancing for interrupt endpoints is handled by passing
    the miniport the appropriate schedule offset for an interrupt
    endpoint.

    interrupt endpoints may occupy different locations in the 
    schedule dpeneding on the period. The consume bandwidth only
    for locations they occupy.  This is the 'ScheduleOffset'.

    USBPORT will choose an appropriate schedule offset and pass this
    to the miniport for the open.

    period      offsets
       1          0
       2          0,1
       4          0,..3
       8          0,..7
       16         0,..15
       32         0,..31
        
*/

typedef struct _ENDPOINT_PARAMETERS {
    USHORT DeviceAddress;
    USHORT EndpointAddress;
    USHORT MaxPacketSize;
    // adjusted interrupt period
    // will be one of : 128, 64, 32, 16, 8, 4, 2, 1
    UCHAR Period;
    UCHAR MaxPeriod;
    // bandwidth required in bits/ms 
    // ie the reserved bw that this endpont will
    // consume
    DEVICE_SPEED DeviceSpeed;
    ULONG Bandwidth;
    ULONG ScheduleOffset;
    ENDPOINT_TRANSFER_TYPE TransferType;
    ENDPOINT_TRANSFER_DIRECTION TransferDirection;
    PUCHAR CommonBufferVa;
    HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys; 
    ULONG CommonBufferBytes;
    // endpoint parm flags
    ULONG EndpointFlags;
    ULONG MaxTransferSize;
    // usb 2.0 parameters
    // device address of the hub (TT) for this ep
    USHORT TtDeviceAddress;
    // port number (really TT number) of the TT for 
    // this device
    USHORT TtPortNumber;

    UCHAR InterruptScheduleMask;
    UCHAR SplitCompletionMask;
    UCHAR TransactionsPerMicroframe;
    UCHAR Pad;
    USHORT MuxPacketSize;
    ULONG Ordinal;
    
} ENDPOINT_PARAMETERS, *PENDPOINT_PARAMETERS;

/* these are returned by the miniport */
typedef struct _ENDPOINT_REQUIREMENTS {
    /* size of the common buffer the
      miniport will need to service 
      this endpoint */
    ULONG MinCommonBufferBytes; 

    /* 
       the largest single transfer this endpoint
       can handle. If a client driver passes 
       down a larger transfer usbport will break
       it in to multiple requests.

       MinCommonBufferBytes/sizeof(TD) should be 
       enough TDs to statify at least one request
       of MaximumTransferSize.

       Ideally it should be able to handle two -- this 
       will ensure that the bus does not go idle.
       
    */
       
    ULONG MaximumTransferSize;
    
} ENDPOINT_REQUIREMENTS, *PENDPOINT_REQUIREMENTS;


// **
// EP_PARM_FLAG_
// Enpoint Parameter flags, describe required endpoint
// behaviors including possible optimaizations

//#define EP_PARM_FLAG_         0x00000002    

//
// EP_PARM_FLAG_NOHALT - the endpoint should not halt on the 
//      host side as a result of a bus error
//
#define EP_PARM_FLAG_NOHALT           0x00000004  

// optimization flags
#define EP_PARM_ISO_BUFFERING         0x00000008

// 


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_OPEN_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
         PENDPOINT_DATA 
    );

/*++
    MINIPORT_PokeEndpoint

    poke an endpoint.
    use to change the address of an endpoint without 
    removing it from the schedule.

    **This API is used exclusively to change the endpoint 
    address.
    
    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    IRQL = DISPATCH_LEVEL

USB_MINIPORT_STATUS
MINIPORT_PokeEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    
--*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_POKE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
        PENDPOINT_DATA 
    );    


/*++
    MINIPORT_RebalanceEndpoint

    PENDPOINT_DATA is the minport private endpoint
    context
    
    PENDPOINT_PARAMETERS describes the endpoint to open 
    for the miniport -- this information is READ_ONLY

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );    
--*/

typedef VOID
    (USBMPFN *PMPFN_REBALANCE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
        PENDPOINT_DATA 
    );      

/*++
    MINIPORT_QueryEndpointRequirements

    PENDPOINT_DATA is the minport private endpoint
    context
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_QueryEndpointRequirements(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    );   


Notes on Maximum Transfer Sizes:

Control:
    The miniport can assume that no Control transfer buffer passed to 
    it will be larger than EndpointParameters.MAXTRANSFERSIZE.  The miniport 
    should request enough locked memory (common buffer) to support at least 
    one control transfer.

    TBD - The miniport may optionally request that the controller transfer 
    be limmited to a smaller value by setting 
    EndpointRequirements.MAXTRANSFERSIZE.  In this case the miniport must 
    support fragmented control tranfsers.  
    
    EndpointParameters.MAXTRANSFERSIZE can never be larger than 64k by spec.

Interrupt:
    The miniport can indicate the max transfer size for each interrupt
    transfer it can handle in EndpointRequirements.MAXTRANSFERSIZE.
    
    Assume that no transfer buffer will be larger than the this size.
    EndpointParameters.MAXTRANSFERSIZE is the default value. The miniport
    should allocate resources to handle at least two transfers of this size.

Bulk:
    The miniport can indicate the max transfer size for each bulk transfer 
    it can handle in EndpointRequirements.MAXTRANSFERSIZE.  No transfer will 
    be passed in larger than this value. The miniport must request enough 
    resources to program at least two transfers of this size into the hardware. 
    MAXTRANSFERSIZE must be at least 4k.
    
    EndpointParameters.MAXTRANSFERSIZE is the default value.

Basic Iso:
    Miniport may specify an EndpointRequirements.MAXTRANSFERSIZE size 
    but it must also be able to always handle at least two transfers of 
    MAX_ISO_PACKETS_PER_TRANSFER.
        

--*/

/*
    Historical Note:

    The orignal USBD driver shipped in Win98 thru Win2k limits iso requests
    to 255 packets so we are safe to set this limit at 256.

    This is 256ms for full speed and 32 ms for High speed on the hardware 
    per request which is plenty.
    
*/

#define MAX_ISO_PACKETS_PER_TRANSFER    256

typedef VOID
    (USBMPFN *PMPFN_QENDPOINT_REQUIREMENTS) (
        PDEVICE_DATA, 
        PENDPOINT_PARAMETERS,
         PENDPOINT_REQUIREMENTS
    );

/*++
    MINIPORT_PollEndpoint

    Poll the endpoint for done transfers or other changes

    PENDPOINT_DATA is the minport private endpoint
    context
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_PollEndpoint(
    PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_POLL_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );    

/*
    MINIPORT_CloseEndpoint

    close an endpoint, PENDPOINT_DATA is the minport private endpoint
    context

    free any resources allocated for the endpoint other than BW
    
    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_CloseEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );    
*/

typedef VOID
    (USBMPFN *PMPFN_CLOSE_ENDPOINT) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );

/*
    MINIPORT_SetEndpointState

    Set an endpoint to one of our defined transfer states, the endpoint 
    need not be in the state when the miniport returns.
    
    There is an assumption here that the enpoint will reach the 
    desired state on the next SOF, the port will keep track of 
    this and assume that the state transition has occurred after 
    one ms frame has passed.

    These are software state, changes can only be intiated by a 
    request thru the MINIPORT_SetEndpointState function. endpoints
    cannot transition on their own.

    ENDPOINT_IDLE
        The endpoint has no active transfer, set this endpoint to a 
        state that generates minimal activity on the contoller (ie 
        remove it from the schedule,set skip bit etc)

    ENDPOINT_PAUSE 
        temporarily stop any bus activity associated with the endpoint,
        this is a prelude to receiving an abortTransfer.

    ENDPOINT_ACTIVE 
        enable processing of the enpoint -- ie it is in the schedule and
        ready for action

    ENDPOINT_REMOVE 
        the endpoint has been removed from the HW schedule


    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_SetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    MP_ENDPOINT_STATE
    );    

MP_ENDPOINT_STATE
MINIPORT_GetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );     
*/
typedef enum _MP_ENDPOINT_STATE {
    ENDPOINT_TRANSITION = 0,
    ENDPOINT_IDLE,
    ENDPOINT_PAUSE, 
    ENDPOINT_ACTIVE, 
    ENDPOINT_REMOVE,
    ENDPOINT_CLOSED
} MP_ENDPOINT_STATE;    

typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_STATE) (
        PDEVICE_DATA, 
        PENDPOINT_DATA,
        MP_ENDPOINT_STATE
    );
    
typedef MP_ENDPOINT_STATE
    (USBMPFN *PMPFN_GET_ENDPOINT_STATE) (
        PDEVICE_DATA, 
        PENDPOINT_DATA
    );

/*++
    MINIPORT_SetEndpointDataToggle

    resets the data toggle for an endpoint
    
    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_SetEndpointDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData,
    ULONG Toggle
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_DATA_TOGGLE) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        ULONG            
    );          

/*++
    MINIPORT_GetEndpointStatus
    
    returns the status of an endpoint ie HALTED 
    the status of the endpoint is controlled by the HW.
        
    IRQL = DISPATCH_LEVEL
    
MP_ENDPOINT_STATUS
MINIPORT_GetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData
    );       

VOID
MINIPORT_SetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndointData,
    MP_ENDPOINT_STATUS EpStatus
    );       
    
--*/

typedef enum _MP_ENDPOINT_STATUS {
    ENDPOINT_STATUS_RUN = 0,
    ENDPOINT_STATUS_HALT
} MP_ENDPOINT_STATUS;    


typedef MP_ENDPOINT_STATUS
    (USBMPFN *PMPFN_GET_ENDPOINT_STATUS) (
        PDEVICE_DATA,
        PENDPOINT_DATA
    );          
    
typedef VOID
    (USBMPFN *PMPFN_SET_ENDPOINT_STATUS) (
        PDEVICE_DATA,
        PENDPOINT_DATA,
        MP_ENDPOINT_STATUS
    );          

/*++
    MINIPORT_Get32BitFrameNumber

    returns the 32 bit frame number maintained by the HCD

    IRQL = DISPATCH_LEVEL
    
ULONG
MINIPORT_Get32BitFrameNumber(
    PDEVICE_DATA DeviceData
    );       
--*/

typedef ULONG
    (USBMPFN *PMPFN_GET_32BIT_FRAME_NUMBER) (
        PDEVICE_DATA 
    );        

/*++
    MINIPORT_InterruptNextSOF

    requests an interrupt at the next SOF interval

    IRQL = DISPATCH_LEVEL
    
VOID
MINIPORT_InterruptNextSOF(
    PDEVICE_DATA DeviceData
    );       
--*/

typedef VOID
    (USBMPFN *PMPFN_INTERRUPT_NEXT_SOF) (
        PDEVICE_DATA 
    );        
    
/*
    MINIPORT_PollController    

    Optional Poll routine for miniport this function will
    be called at the MiniportPollInterval specficeid in 
    the registration packet.
    
    Specifying a vlue of zero disables polling of the 
    controller.

    IRQL = ANY

VOID
MINIPORT_PollController (
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_POLL_CONTROLLER) (
        PDEVICE_DATA 
    );  
    
/***************************************************************
PNP/POWER Functions

    The following core pnp functions are serialized as a group
    
****************************************************************/

/*
    MINIPORT_CheckController    

    Entry point called by usbport periodically to check the hardware 
    state, this function is not serialized. Typically this is used to 
    detect surprise removal of the hardware. 

    IRQL = ANY

VOID
MINIPORT_CheckController(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_CHECK_CONTROLLER) (
        PDEVICE_DATA 
    );  

/*
    MINIPORT_StartController   

    Initialize Hardware, allocate memory etc.

    on return (STATUS_SUCCESS) the device is considered started and 
    powered and must handle ALL CORE functions.

    the miniport should disable any BIOS if present

    the last thing the driver should do before returning is enable 
    interrupt generation by the controller

    HcParameters are filled in by the miniport
    
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_StartController(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    );
*/    

typedef struct _HC_RESOURCES {

/* values for Flags field */
#define HCR_IO_REGS     0x0000001     
#define HCR_IRQ         0x0000002
#define HCR_MEM_REGS    0x0000004

    ULONG Flags;
    USB_CONTROLLER_FLAVOR ControllerFlavor;
    
    /* interrupt */
    ULONG InterruptVector;
    KIRQL InterruptLevel;
    KAFFINITY Affinity;
    BOOLEAN ShareIRQ;
    KINTERRUPT_MODE InterruptMode;
    PKINTERRUPT InterruptObject;  

    /* io ports */
    /* memory mapped */
    PVOID DeviceRegisters; 
    ULONG DeviceRegistersLength;

    PUCHAR CommonBufferVa;
    HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys; 

    /* BIOS detected
        filled in by miniport
    */
    BOOLEAN DetectedLegacyBIOS;
    BOOLEAN Restart;
    
} HC_RESOURCES, *PHC_RESOURCES;


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_START_CONTROLLER) (
        PDEVICE_DATA, 
        PHC_RESOURCES
    );
    

/*
    MINIPORT_StopController   

    disconnect interrupt, free memory etc.

    on return (non Failable) the device is considered stopped and 
    powered down and will no longer receicve calls to CORE functions.

    NOTES: 
        - The miniport will only receive a stop request if it was 
          successfuly started.
        - Miniport should disable all interrupts from the hardware.          
        - if Hardware Present is FALSE the miniport should not access 
          memory registers or ioports.
          
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT StopController(
    PDEVICE_DATA DeviceData,
    BOOLEAN HardwarePresent
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_STOP_CONTROLLER) (
        PDEVICE_DATA, 
        BOOLEAN 
    );


/*
    MINIPORT_ResetController   

    Reset the host controller hardware

    This function is serialized with the ISR and DPC and holds
    the core function lock in order to provide a safe environment 
    or the miniport to reset the host hardware.
    

VOID
MINIPORT ResetController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_RESET_CONTROLLER) (
        PDEVICE_DATA 
    );


/*
    MINIPORT_SuspendController   

    IRQL = PASSIVE_LEVEL


VOID
MINIPORT SuspendController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_SUSPEND_CONTROLLER) (
        PDEVICE_DATA 
    );

/*
    MINIPORT_ResumeController   

    Attempts to resume HC HW from the suspend state.  The miniport
    may fail this in the event the controller has been hosed by the
    BIOS.  In that even the port driver may attempt to power cycle.

    IRQL = PASSIVE_LEVEL


VOID
MINIPORT ResumeController(
    PDEVICE_DATA DeviceData
    );
*/    

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RESUME_CONTROLLER) (
        PDEVICE_DATA 
    );    

/*
    MINIPORT_FlushInterrupts   

    Flush Interrupts on the USB the controller HW
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT FlushInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_FLUSH_INTERRUPTS) (
        PDEVICE_DATA 
    );   

/*
    MINIPORT_TakePortControl   

    Pre start controller initialization
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT_TakePortControl(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_TAKE_PORT_CONTROL) (
        PDEVICE_DATA 
    );            

/*
    MINIPORT_EnableInterrupts   

    Enable Interrupts by the USB the controller HW
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT EnableInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_ENABLE_INTERRUPTS) (
        PDEVICE_DATA 
    );    

/*
    MINIPORT_DisableInterrupts   

    Disable Interrupts by the USB the controller HW

    On return from this function the controller is expected to 
    not generate ANY interrupts. 
    Also the controller should ack all interrupts since on return
    from this routine the ISR & ISRDPC will no longer be called.

    
    IRQL = This function is synchronized with the ISR


VOID
MINIPORT DisableInterrupts(
    PDEVICE_DATA DeviceData
    );
*/    

typedef VOID
    (USBMPFN *PMPFN_DISABLE_INTERRUPTS) (
        PDEVICE_DATA 
    );        


/***************************************************************
ROOT HUB Functions

MINIPORT_RH_GetRootHubData
MINIPORT_RH_DisableIrq
MINIPORT_RH_EnableIrq

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus 
MINIPORT_RH_GetHubStatus 

Port Functions, all use PMPFN_RH_PORT_FUNCTION
MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower
MINIPORT_RH_SetFeaturePortEnable

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange

****************************************************************/

/* 
    root hub port status data as defined in the Hub Class 
    section of the CORE (USB 1.1) spec.
*/

typedef struct _RH_PORT_STATUS {

    union {
        struct {
        
            /* Status bits 0.. 15 */
            
            ULONG Connected:1;
            ULONG Enabled:1;
            ULONG Suspended:1;
            ULONG OverCurrent:1;
            ULONG Reset:1;        
            ULONG Reserved0:3;
            ULONG PowerOn:1;
            ULONG LowSpeed:1;
            ULONG HighSpeed:1;
            ULONG Reserved1:4;
            /* borrowed from reserved bits to indicate 
                port disposition */
            ULONG OwnedByCC:1; 
        
            /* Change bits 16..31 */
        
            ULONG ConnectChange:1;
            ULONG EnableChange:1;
            ULONG SuspendChange:1;
            ULONG OverCurrentChange:1;
            ULONG ResetChange:1;
            ULONG Reserved2:11;
            
        };
        ULONG ul;
   }; 
} RH_PORT_STATUS, *PRH_PORT_STATUS;

C_ASSERT(sizeof(RH_PORT_STATUS) == sizeof(ULONG));

typedef struct _RH_HUB_STATUS {

    /* Status bits 0.. 15 */
    union {
        struct {   
            ULONG LocalPowerLost:1;
            ULONG OverCurrent:1;
            ULONG Reserved:14;
        
            /* Change bits 16..31 */
        
            ULONG LocalPowerChange:1;
            ULONG OverCurrentChange:1;
            ULONG Reserved2:14;
        };
        ULONG ul;
    };    
} RH_HUB_STATUS, *PRH_HUB_STATUS;

C_ASSERT(sizeof(RH_HUB_STATUS) == sizeof(ULONG));

/*
   Hub Charateristics as defined 
   in 11.11.2 of the USB core spec.
*/   
/* PowerSwitchType */
#define USBPORT_RH_POWER_SWITCH_GANG    0    
#define USBPORT_RH_POWER_SWITCH_PORT    1

typedef union _RH_HUB_CHARATERISTICS {

    USHORT us;
    struct {
        /* 
            00 = Gang switched
            01 = port power switched

            1x = 1.0 hubs with no power 
                 switching
        */
        USHORT PowerSwitchType:2;       /* 0-1      */
        USHORT CompoundDevice:1;        /* 2        */
        USHORT OverCurrentProtection:2; /* 3-4      */
        USHORT Reserved:11;             /* 5-15     */
    }; 

} RH_HUB_CHARATERISTICS, *PRH_HUB_CHARATERISTICS;

C_ASSERT(sizeof(RH_HUB_CHARATERISTICS) == sizeof(USHORT));


typedef struct _ROOTHUB_DATA {

    ULONG NumberOfPorts;         // number of ports on this hub
    RH_HUB_CHARATERISTICS HubCharacteristics;  
    USHORT pad;
    ULONG PowerOnToPowerGood;    // port power on till power good in 2ms
    ULONG HubControlCurrent;     // max current in mA

} ROOTHUB_DATA, *PROOTHUB_DATA;



/*
    MINIPORT_RH_GetRootHubData   

    get information about the root hub, port 
    driver uses this information to emulate 
    the root hub for the miniport
    
    IRQL = PASSIVE_LEVEL


VOID
MINIPORT_RH_GetRootHubData(
    PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_GET_ROOTHUB_DATA) (
        PDEVICE_DATA, 
        PROOTHUB_DATA
    );
    

/*
    MINIPORT_RH_GetStatus   

    Used to support the GET_STATUS command sent to the root hub device.

    may return with the following bits set in Status
    
        USB_GETSTATUS_SELF_POWERED                0x01
        USB_GETSTATUS_REMOTE_WAKEUP_ENABLED       0x02

    are we self powered?
    are we a remote wakeup source?
    
    see section 9.4.5 USB 1.1 spec
    
    
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetStatus(
    PDEVICE_DATA DeviceData
     PUSHORT Status
    );
*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_STATUS) (
        PDEVICE_DATA, 
         PUSHORT
    );

/*
    MINIPORT_RH_DisableIrq  (OPTIONAL)

    If the comntroller is capable of generating interrupts
    on root hub status changes then it must provide this 
    service to disable/enable the feature.

    IRQL = DPC_LEVEL


VOID
MINIPORT_RH_DisableIrq(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_DISABLE_IRQ) (
        PDEVICE_DATA 
    );
    
/*
    MINIPORT_RH_EnableIrq   (OPTIONAL)

    IRQL = DPC_LEVEL


VOID
MINIPORT_RH_EnableIrq(
    PDEVICE_DATA DeviceData
    );
*/

typedef VOID
    (USBMPFN *PMPFN_RH_ENABLE_IRQ) (
        PDEVICE_DATA 
    );
    
/*
    MINIPORT_RH_GetPortStatus   

    Used to support the GET_STATUS hub class command sent 
    to the root hub interface for a port.

    PortNumber = 1,2, etc

    see section 11.16.2.5 of USB 1.1 spec

    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
     PRH_PORT_STATUS PortStatus
    );
*/


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_PORT_STATUS) (
        PDEVICE_DATA, 
        USHORT,
        PRH_PORT_STATUS
    );


/*
    MINIPORT_RH_GetHubStatus   

    Used to support the GET_STATUS hub class command sent 
    to the root hub interface for a hub.

    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_GetHubStatus(
    PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    );
*/


typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_GET_HUB_STATUS) (
        PDEVICE_DATA, 
        PRH_HUB_STATUS
    );


/*
    MINIPORT_RH_PORT_FUNCTION   

    format for root hub services that act on ports.

    PortNumber = 1,2, etc
     
    IRQL = PASSIVE_LEVEL


USB_MINIPORT_STATUS
MINIPORT_RH_PORT_FUNCTION(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

    The following services use the MINIPORT_RH_PORT_FUNCTION
    format
    
    MINIPORT_RH_SetFeaturePortReset   

    MINIPORT_RH_SetFeaturePortPower   

    MINIPORT_RH_SetFeaturePortEnable  

    MINIPORT_RH_SetFeaturePortSuspend  
    
    MINIPORT_RH_ClearFeaturePortEnable   

    MINIPORT_RH_ClearFeaturePortPower   
    
    MINIPORT_RH_ClearFeaturePortEnableChange   

    MINIPORT_RH_ClearFeaturePortConnectChange   

    MINIPORT_RH_ClearFeaturePortResetChange   

*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_RH_PORT_FUNCTION) (
        PDEVICE_DATA, 
        USHORT
    );

/***************************************************************
 INTERRUPT Functions
 
these functions are not serialized
****************************************************************/

/*
    MINIPORT_InterruptService    

    IRQL = ANY

BOOLEAN
MINIPORT_InterruptService (
    PDEVICE_DATA DeviceData
    );
*/

typedef BOOLEAN
    (USBMPFN *PMPFN_INTERRUPT_SERVICE) (
        PDEVICE_DATA
    );


/*
    MINIPORT_InterruptDpc    

    Called by port in response to an interrupt generated by the HW.

    This function is not serialize with other core functions since 
    which allow it to call services in USBPORT that result in 
    immediate calls to core functions.

    The port driver passes a flag to indicate if interrupts need 
    to be re-enabled on completion of this routine.  This is to handle
    the rare case where interrupts have been disabled just after the
    ISR has queued a DPC.

    IRQL = DISPATCH_LEVEL

VOID
MINIPORT_InterruptDpc (
    PDEVICE_DATA DeviceData
    BOOLEAN EnableInterrupts
    );
*/

typedef VOID
    (USBMPFN *PMPFN_INTERRUPT_DPC) (
        PDEVICE_DATA, 
        BOOLEAN 
    );


/***************************************************************
 DEBUG/TEST Functions
 
****************************************************************/

/*
    MINIPORT_SendOnePacket    

    IRQL = ANY

    used to support the single-step debug application.  This api is
    OPTIONAL

    

VOID
MINIPORT_SendOnePacket (
    PDEVICE_DATA DeviceData,
    PPACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkspaceLength,
    PUSBD_STATUS UsbdStatus
    );

*/

typedef enum _SS_PACKET_TYPE {
    ss_Setup = 0,
    ss_In, 
    ss_Out,
    ss_Iso_In,
    ss_Iso_Out
} SS_PACKET_TYPE;    


typedef enum _SS_PACKET_SPEED {
    ss_Low = 0,
    ss_Full, 
    ss_High
} SS_PACKET_SPEED;    


typedef enum _SS_PACKET_DATA_TOGGLE {
    ss_Toggle0 = 0,
    ss_Toggle1
} SS_PACKET_DATA_TOGGLE;    


typedef struct _MP_PACKET_PARAMETERS {
    UCHAR DeviceAddress;
    UCHAR EndpointAddress;
    USHORT MaximumPacketSize;
    USHORT ErrorCount;
    USHORT Pad;
    SS_PACKET_TYPE Type;
    SS_PACKET_SPEED Speed;
    SS_PACKET_DATA_TOGGLE Toggle;
    /* 2.0 hubs */
    USHORT HubDeviceAddress;
    USHORT PortTTNumber;
} MP_PACKET_PARAMETERS, *PMP_PACKET_PARAMETERS;

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_SEND_ONE_PACKET) (
        PDEVICE_DATA, 
        PMP_PACKET_PARAMETERS,
        PUCHAR, 
        PULONG,
        PUCHAR,
        HW_32BIT_PHYSICAL_ADDRESS,
        ULONG,
        USBD_STATUS *
    );


/***************************************************************
 API Functions
    These are called at IRQL passive_level
****************************************************************/

/*
    MINIPORT_PassThru    

    IRQL = PASSIVE_LEVEL

    

USB_MINIPORT_STATUS
MINIPORT_PassThru (
    PDEVICE_DATA DeviceData,
    GUID *FunctionGuid,
    ULONG ParameterLength,
    PVOID Parameters
    );
*/

typedef USB_MINIPORT_STATUS
    (USBMPFN *PMPFN_PASS_THRU) (
        PDEVICE_DATA, 
        GUID *, 
        ULONG,
        PVOID 
    );
    
/***************************************************************
 ***************************************************************
 REGISTRATION PACKET
 ***************************************************************
****************************************************************/

/* HCI Hardware Types */

typedef enum _USB_HCI_TYPE {

    USB_UNKNOWN_HCI = 0,
    USB_OHCI,   
    USB_UHCI,   
    USB_EHCI
    
} USB_HCI_TYPE;


/* Miniport Option Flags */

/* resources required by miniport */ 
#define USB_MINIPORT_OPT_NEED_IRQ             0x00000001
#define USB_MINIPORT_OPT_NEED_IOPORT          0x00000002
#define USB_MINIPORT_OPT_NEED_MEMORY          0x00000004
/* USB version */
#define USB_MINIPORT_OPT_USB11                0x00000008
#define USB_MINIPORT_OPT_USB20                0x00000010
/* support selective suspend */
#define USB_MINIPORT_OPT_NO_SS                0x00000020
/* disables synchronization of the ISRDPC and the 
   MP_DisableInterrupts function. usbed by UHCI 
   to clear/ set PIRQD in config space. */
#define USB_MINIPORT_OPT_NO_IRQ_SYNC          0x00000040
/* indicates controller poll routine should be called 
    this will always be at least ounce evert 500ms
*/    
#define USB_MINIPORT_OPT_POLL_CONTROLLER      0x00000080
/* for bridge drivers with no hw resources */
#define USB_MINIPORT_OPT_NO_PNP_RESOURCES     0x00000100
/* poll whe HW suspended */
#define USB_MINIPORT_OPT_POLL_IN_SUSPEND      0x00000200

#define USB_MINIPORT_HCI_VERSION USB_MINIPORT_HCI_VERSION_1
#define USB_MINIPORT_HCI_VERSION_1            100
#define USB_MINIPORT_HCI_VERSION_2            200

/*
    Bus Bandwidth defined by spec
*/
#define USB_11_BUS_BANDWIDTH                12000
#define USB_20_BUS_BANDWIDTH                400000

#define USB_HCI_MN                          0x10000001

/* version shipped with XP 2600 this must remaon unchanged */

typedef struct _USBPORT_REGISTRATION_PACKET_V1 {

    /* begin version (1) interface definition */

    /* Host Controller HCI Type */
    USB_HCI_TYPE HciType;    
    
    /* registration parameters */
    ULONG OptionFlags;

    /* 
       Total bus bandwidth avaibale in MBits
     */
    ULONG BusBandwidth;

    LONG Reserved;

    ULONG DeviceDataSize;
    ULONG EndpointDataSize;
    ULONG TransferContextSize;

    /* 7 char ASCII NULL terminated name */
    UCHAR Name[8]; 

    /*
        Amount of global common buffer needed
        this memory is passed to the miniport on 
        a start and freed on a stop 
    */
    ULONG CommonBufferBytes;

    /* miniport Functions */
    PMPFN_OPEN_ENDPOINT                   MINIPORT_OpenEndpoint;
    PMPFN_POKE_ENDPOINT                   MINIPORT_PokeEndpoint;
    PMPFN_QENDPOINT_REQUIREMENTS          MINIPORT_QueryEndpointRequirements;
    PMPFN_CLOSE_ENDPOINT                  MINIPORT_CloseEndpoint;
    PMPFN_START_CONTROLLER                MINIPORT_StartController;
    PMPFN_STOP_CONTROLLER                 MINIPORT_StopController;
    PMPFN_SUSPEND_CONTROLLER              MINIPORT_SuspendController;  
    PMPFN_RESUME_CONTROLLER               MINIPORT_ResumeController;
    PMPFN_INTERRUPT_SERVICE               MINIPORT_InterruptService;
    PMPFN_INTERRUPT_DPC                   MINIPORT_InterruptDpc;
    PMPFN_SUBMIT_TRANSFER                 MINIPORT_SubmitTransfer;
    PMPFN_SUBMIT_ISO_TRANSFER             MINIPORT_SubmitIsoTransfer;
    PMPFN_ABORT_TRANSFER                  MINIPORT_AbortTransfer;
    PMPFN_GET_ENDPOINT_STATE              MINIPORT_GetEndpointState;
    PMPFN_SET_ENDPOINT_STATE              MINIPORT_SetEndpointState;  
    PMPFN_POLL_ENDPOINT                   MINIPORT_PollEndpoint; 
    PMPFN_CHECK_CONTROLLER                MINIPORT_CheckController;
    PMPFN_GET_32BIT_FRAME_NUMBER          MINIPORT_Get32BitFrameNumber;
    PMPFN_INTERRUPT_NEXT_SOF              MINIPORT_InterruptNextSOF;
    PMPFN_ENABLE_INTERRUPTS               MINIPORT_EnableInterrupts;
    PMPFN_DISABLE_INTERRUPTS              MINIPORT_DisableInterrupts;
    PMPFN_POLL_CONTROLLER                 MINIPORT_PollController;
    PMPFN_SET_ENDPOINT_DATA_TOGGLE        MINIPORT_SetEndpointDataToggle; 
    PMPFN_GET_ENDPOINT_STATUS             MINIPORT_GetEndpointStatus;
    PMPFN_SET_ENDPOINT_STATUS             MINIPORT_SetEndpointStatus;  
    PMPFN_RESET_CONTROLLER                MINIPORT_ResetController;  
   
    /* root hub functions */
    PMPFN_RH_GET_ROOTHUB_DATA             MINIPORT_RH_GetRootHubData;
    PMPFN_RH_GET_STATUS                   MINIPORT_RH_GetStatus;
    PMPFN_RH_GET_PORT_STATUS              MINIPORT_RH_GetPortStatus;  
    PMPFN_RH_GET_HUB_STATUS               MINIPORT_RH_GetHubStatus;  
    /* root hub port functions */                                
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortReset;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortPower;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortEnable;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortSuspend;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnable;    
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortPower;   
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspend; 
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnableChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortConnectChange;        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortResetChange;                                                        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspendChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortOvercurrentChange;
    
    /* optional root hub functions */
    PMPFN_RH_DISABLE_IRQ                  MINIPORT_RH_DisableIrq;
    PMPFN_RH_ENABLE_IRQ                   MINIPORT_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES
    
        Miniport should return USBMP_STATUS_NOT_SUPPORTED for the 
        services not supported.
     */
    PMPFN_SEND_ONE_PACKET                 MINIPORT_StartSendOnePacket;
    PMPFN_SEND_ONE_PACKET                 MINIPORT_EndSendOnePacket;

    /* PASS-THRU API function
        
    */
    PMPFN_PASS_THRU                        MINIPORT_PassThru;
    

    /* interface Services */
    PPORTFN_DBGPRINT                            USBPORTSVC_DbgPrint;
    PPORTFN_TEST_DEBUG_BREAK                    USBPORTSVC_TestDebugBreak;
    PPORTFN_ASSERT_FAILURE                      USBPORTSVC_AssertFailure;
    PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE     USBPORTSVC_GetMiniportRegistryKeyValue;
    PPORTFN_INVALIDATE_ROOTHUB                  USBPORTSVC_InvalidateRootHub;
    PPORTFN_INVALIDATE_ENDPOINT                 USBPORTSVC_InvalidateEndpoint;
    PPORTFN_COMPLETE_TRANSFER                   USBPORTSVC_CompleteTransfer;
    PPORTFN_COMPLETE_ISO_TRANSFER               USBPORTSVC_CompleteIsoTransfer;
    PPORTFN_LOGENTRY                            USBPORTSVC_LogEntry;
    PPORTFN_PHYS_TO_VIRTUAL                     USBPORTSVC_MapHwPhysicalToVirtual;
    PPORTFN_REQUEST_ASYNC_CALLBACK              USBPORTSVC_RequestAsyncCallback;
    PPORTFN_READWRITE_CONFIG_SPACE              USBPORTSVC_ReadWriteConfigSpace;
    PPORTFN_WAIT                                USBPORTSVC_Wait;
    PPORTFN_INVALIDATE_CONTROLLER               USBPORTSVC_InvalidateController;
    PPORTFN_BUGCHECK                            USBPORTSVC_BugCheck;
    PPORTFN_NOTIFY_DOUBLE_BUFFER                USBPORTSVC_NotifyDoubleBuffer;

    PMPFN_REBALANCE_ENDPOINT                    MINIPORT_RebalanceEndpoint;  
    PMPFN_FLUSH_INTERRUPTS                      MINIPORT_FlushInterrupts;

} USBPORT_REGISTRATION_PACKET_V1, *PUSBPORT_REGISTRATION_PACKET_V1;

/*
    Miniport version 2 (current) api packet
*/
typedef struct _USBPORT_REGISTRATION_PACKET {

    /* begin version (1) interface definition */

    /* Host Controller HCI Type */
    USB_HCI_TYPE HciType;    
    
    /* registration parameters */
    ULONG OptionFlags;

    /* 
       Total bus bandwidth avaibale in MBits
     */
    ULONG BusBandwidth;

    LONG Reserved;

    ULONG DeviceDataSize;
    ULONG EndpointDataSize;
    ULONG TransferContextSize;

    /* 7 char ASCII NULL terminated name */
    UCHAR Name[8]; 

    /*
        Amount of global common buffer needed
        this memory is passed to the miniport on 
        a start and freed on a stop 
    */
    ULONG CommonBufferBytes;

    /* miniport Functions */
    PMPFN_OPEN_ENDPOINT                   MINIPORT_OpenEndpoint;
    PMPFN_POKE_ENDPOINT                   MINIPORT_PokeEndpoint;
    PMPFN_QENDPOINT_REQUIREMENTS          MINIPORT_QueryEndpointRequirements;
    PMPFN_CLOSE_ENDPOINT                  MINIPORT_CloseEndpoint;
    PMPFN_START_CONTROLLER                MINIPORT_StartController;
    PMPFN_STOP_CONTROLLER                 MINIPORT_StopController;
    PMPFN_SUSPEND_CONTROLLER              MINIPORT_SuspendController;  
    PMPFN_RESUME_CONTROLLER               MINIPORT_ResumeController;
    PMPFN_INTERRUPT_SERVICE               MINIPORT_InterruptService;
    PMPFN_INTERRUPT_DPC                   MINIPORT_InterruptDpc;
    PMPFN_SUBMIT_TRANSFER                 MINIPORT_SubmitTransfer;
    PMPFN_SUBMIT_ISO_TRANSFER             MINIPORT_SubmitIsoTransfer;
    PMPFN_ABORT_TRANSFER                  MINIPORT_AbortTransfer;
    PMPFN_GET_ENDPOINT_STATE              MINIPORT_GetEndpointState;
    PMPFN_SET_ENDPOINT_STATE              MINIPORT_SetEndpointState;  
    PMPFN_POLL_ENDPOINT                   MINIPORT_PollEndpoint; 
    PMPFN_CHECK_CONTROLLER                MINIPORT_CheckController;
    PMPFN_GET_32BIT_FRAME_NUMBER          MINIPORT_Get32BitFrameNumber;
    PMPFN_INTERRUPT_NEXT_SOF              MINIPORT_InterruptNextSOF;
    PMPFN_ENABLE_INTERRUPTS               MINIPORT_EnableInterrupts;
    PMPFN_DISABLE_INTERRUPTS              MINIPORT_DisableInterrupts;
    PMPFN_POLL_CONTROLLER                 MINIPORT_PollController;
    PMPFN_SET_ENDPOINT_DATA_TOGGLE        MINIPORT_SetEndpointDataToggle; 
    PMPFN_GET_ENDPOINT_STATUS             MINIPORT_GetEndpointStatus;
    PMPFN_SET_ENDPOINT_STATUS             MINIPORT_SetEndpointStatus;  
    PMPFN_RESET_CONTROLLER                MINIPORT_ResetController;  
   
    /* root hub functions */
    PMPFN_RH_GET_ROOTHUB_DATA             MINIPORT_RH_GetRootHubData;
    PMPFN_RH_GET_STATUS                   MINIPORT_RH_GetStatus;
    PMPFN_RH_GET_PORT_STATUS              MINIPORT_RH_GetPortStatus;  
    PMPFN_RH_GET_HUB_STATUS               MINIPORT_RH_GetHubStatus;  
    /* root hub port functions */                                
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortReset;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortPower;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortEnable;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_SetFeaturePortSuspend;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnable;    
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortPower;   
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspend; 
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortEnableChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortConnectChange;        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortResetChange;                                                        
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortSuspendChange;
    PMPFN_RH_PORT_FUNCTION      MINIPORT_RH_ClearFeaturePortOvercurrentChange;
    
    /* optional root hub functions */
    PMPFN_RH_DISABLE_IRQ                  MINIPORT_RH_DisableIrq;
    PMPFN_RH_ENABLE_IRQ                   MINIPORT_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES
    
        Miniport should return USBMP_STATUS_NOT_SUPPORTED for the 
        services not supported.
     */
    PMPFN_SEND_ONE_PACKET                 MINIPORT_StartSendOnePacket;
    PMPFN_SEND_ONE_PACKET                 MINIPORT_EndSendOnePacket;

    /* PASS-THRU API function
        
    */
    PMPFN_PASS_THRU                        MINIPORT_PassThru;
    

    /* interface Services */
    PPORTFN_DBGPRINT                            USBPORTSVC_DbgPrint;
    PPORTFN_TEST_DEBUG_BREAK                    USBPORTSVC_TestDebugBreak;
    PPORTFN_ASSERT_FAILURE                      USBPORTSVC_AssertFailure;
    PPORTFN_GET_MINIPORT_REGESTRY_KEY_VALUE     USBPORTSVC_GetMiniportRegistryKeyValue;
    PPORTFN_INVALIDATE_ROOTHUB                  USBPORTSVC_InvalidateRootHub;
    PPORTFN_INVALIDATE_ENDPOINT                 USBPORTSVC_InvalidateEndpoint;
    PPORTFN_COMPLETE_TRANSFER                   USBPORTSVC_CompleteTransfer;
    PPORTFN_COMPLETE_ISO_TRANSFER               USBPORTSVC_CompleteIsoTransfer;
    PPORTFN_LOGENTRY                            USBPORTSVC_LogEntry;
    PPORTFN_PHYS_TO_VIRTUAL                     USBPORTSVC_MapHwPhysicalToVirtual;
    PPORTFN_REQUEST_ASYNC_CALLBACK              USBPORTSVC_RequestAsyncCallback;
    PPORTFN_READWRITE_CONFIG_SPACE              USBPORTSVC_ReadWriteConfigSpace;
    PPORTFN_WAIT                                USBPORTSVC_Wait;
    PPORTFN_INVALIDATE_CONTROLLER               USBPORTSVC_InvalidateController;
    PPORTFN_BUGCHECK                            USBPORTSVC_BugCheck;
    PPORTFN_NOTIFY_DOUBLE_BUFFER                USBPORTSVC_NotifyDoubleBuffer;

    PMPFN_REBALANCE_ENDPOINT                    MINIPORT_RebalanceEndpoint;  
    PMPFN_FLUSH_INTERRUPTS                      MINIPORT_FlushInterrupts;

    /* end version (1) definition */       

    /* begin version (2) definition */
    PMPFN_RH_PORT_FUNCTION                      MINIPORT_Chirp_RH_Port;
    PMPFN_TAKE_PORT_CONTROL                     MINIPORT_TakePortControl;
    PVOID pad2;
    PVOID pad3;
    
    /* end version (2) definition */

} USBPORT_REGISTRATION_PACKET, *PUSBPORT_REGISTRATION_PACKET;

/************************************************************** 
**************************************************************
 USBPORT DLL Services    
***************************************************************    
***************************************************************/

#ifndef USBPORT

DECLSPEC_IMPORT
NTSTATUS
USBPORT_RegisterUSBPortDriver(
    PDRIVER_OBJECT DriverObject,
    ULONG MiniportHciVersion,
    PUSBPORT_REGISTRATION_PACKET RegistrationPacket
    );

DECLSPEC_IMPORT
ULONG
USBPORT_GetHciMn(
    );

#endif    

/* miniport must define these */

#undef PDEVICE_DATA
#undef PTRANSFER_CONTEXT
#undef PENDPOINT_DATA 

#endif /* __USB_HCDI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\usbhcdkd.cpp ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/

extern "C"
void
_disable (
    void
    );

extern "C"
void
_enable (
    void
    );

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG64                 STeip;
ULONG64                 STebp;
ULONG64                 STesp;

DBGKD_GET_VERSION64     KernelVersionPacket;
KDDEBUGGER_DATA64       KdDebuggerData;

ULONG64 EXPRLastDump = 0;

//
// Valid for the lifetime of the debug session.
//

ULONG   PageSize;
ULONG64 PaeEnabled;
ULONG   TargetMachine;
BOOL    Connected;

//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                            DEBUG_DATA_PaeEnabled, &PaeEnabled,
                                            sizeof(PaeEnabled), NULL)) == S_OK)
                {
                    if ((Hr = DebugDataSpaces->ReadDebuggerData(
                                                DEBUG_DATA_MmPageSize, &Page,
                                                sizeof(Page), NULL)) == S_OK)
                    {
                        PageSize = (ULONG)(ULONG_PTR)Page;
                    }
                }

                DebugDataSpaces->Release();
            }

            //
            // Get the architecture type.
            //

            if (PageSize)
            {
                if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                           (void **)&DebugControl)) == S_OK)
                {
                    if ((Hr = DebugControl->GetActualProcessorType(
                                                 &TargetMachine)) == S_OK)
                    {
                        Connected = TRUE;
                    }

                    DebugControl->Release();
                }
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        PaeEnabled = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}

BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl( IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}

BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if (Client) {
        if (Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                   (void **)&DebugSystem) != S_OK) {
            return 0;
        }

        DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
        if (phCurrentThread) { 
            *phCurrentThread = (HANDLE) hCurrentThread;
        }
        if (pProcessor) {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }

        DebugSystem->Release();
        return TRUE;
    }
    return FALSE;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\log.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    log.c

Abstract:

    WinDbg Extension Api
    implements !_log

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "usbhcdkd.h"

VOID    
DumpXferLog(
    MEMLOC LogMemLoc,
    MEMLOC StartMemLoc,
    MEMLOC EndMemLoc, 
    ULONG NumEntriesToDump
    )
{
    ULONG i;
    LOG_ENTRY logEntry1, logEntry2;
    ULONG cb;
    MEMLOC m1, m2, m3;
    ENDPOINT_TRANSFER_TYPE t;
    PUCHAR s;
    
    PrintfMemLoc("*TRANSFER LOGSTART: ", LogMemLoc, " ");
    dprintf("# %d \n", NumEntriesToDump);
    
    for (i=0; i< NumEntriesToDump; i++) {

        ReadMemory(LogMemLoc,
           &logEntry2,
           sizeof(logEntry2),
           &cb);
           
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }           

        ReadMemory(LogMemLoc,
           &logEntry1,
           sizeof(logEntry1),
           &cb);
           
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }        
#if 0
        t = (ENDPOINT_TRANSFER_TYPE) logEntry.TransferType;
        switch(logEntry.TransferType) {
        case Isochronous:
            s = "ISO";
            break;
        case Control:
            s = "CON";
            break;
        case Bulk:
            s = "BLK";
            break;
        case Interrupt:
            s = "INT";
            break;
        default:            
            s = "???";
        }   
#endif
        
        dprintf("[%3.3d] Endpoint(%08.8x) - URB:%08.8x IRP:%8.8x\n", 
                 i,
                 logEntry1.le_info1,
                 logEntry1.le_info2,
                 logEntry1.le_info3);
        dprintf("        \t\t\t Bytes [%6.6d]  NT_STATUS %08.8x USBD_STATUS %08.8x\n", 
                 logEntry2.le_info3,
                 logEntry2.le_info2,
                 logEntry2.le_info1);   

    }

}


VOID    
DumpLog(
    MEMLOC LogMemLoc,
    MEMLOC StartMemLoc,
    MEMLOC EndMemLoc, 
    ULONG NumEntriesToDump,
    ULONG MarkSig1,
    ULONG MarkSig2
    )
{
    ULONG i;
    SIG s;
    LOG_ENTRY64 logEntry64;
    LOG_ENTRY32 logEntry32;
    CHAR c;
    ULONG cb;
    MEMLOC m1, m2, m3;

    PrintfMemLoc("*LOG: ", LogMemLoc, " ");
    PrintfMemLoc("*LOGSTART: ", StartMemLoc, " ");
    PrintfMemLoc("*LOGEND: ", EndMemLoc, " ");
    dprintf("# %d \n", NumEntriesToDump);
#if 0    
    s.l = MarkSig1;
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    s.l = MarkSig2;    
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    dprintf("\n");    
#endif
    for (i=0; i< NumEntriesToDump; i++) {

        if (IsPtr64()) { 
            ReadMemory(LogMemLoc,
               &logEntry64,
               sizeof(logEntry64),
               &cb);
  
            s.l = logEntry64.le_sig;

            m1 = logEntry64.le_info1;                
            m2 = logEntry64.le_info2;  
            m3 = logEntry64.le_info3; 
            
        } else {
            ReadMemory(LogMemLoc,
               &logEntry32,
               sizeof(logEntry32),
               &cb);

            s.l = logEntry32.le_sig;

            m1 = logEntry32.le_info1;                
            m2 = logEntry32.le_info2;  
            m3 = logEntry32.le_info3;  
        }

        if (s.l == MarkSig1 || s.l == MarkSig2) {
            c = '*';
        } else {
            c = ' ';
        }

        dprintf("%c[%3.3d]", c, i); 
        PrintfMemLoc(" ", LogMemLoc, " ");
        
        dprintf("%c%c%c%c ", s.c[0],  s.c[1],  s.c[2], s.c[3]);
       
        PrintfMemLoc(" ", m1, " ");
        PrintfMemLoc(" ", m2, " ");
        PrintfMemLoc(" ", m3, "\n");
        
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }
    }

}

VOID    
DumpEnumLog(
    MEMLOC LogMemLoc,
    MEMLOC StartMemLoc,
    MEMLOC EndMemLoc, 
    ULONG NumEntriesToDump
    )
{
    ULONG i;
    SIG s;
    LOG_ENTRY64 logEntry64;
    LOG_ENTRY32 logEntry32;
    CHAR c;
    ULONG cb;
    MEMLOC m1, m2, m3;

    PrintfMemLoc("*LOG: ", LogMemLoc, " ");
    PrintfMemLoc("*LOGSTART: ", StartMemLoc, " ");
    PrintfMemLoc("*LOGEND: ", EndMemLoc, " ");
    dprintf("# %d \n", NumEntriesToDump);
#if 0    
    s.l = MarkSig1;
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    s.l = MarkSig2;    
    dprintf("*(%c%c%c%c) ",  
        s.c[0],  s.c[1],  s.c[2], s.c[3]);
    dprintf("\n");    
#endif
    for (i=0; i< NumEntriesToDump; i++) {

        if (IsPtr64()) { 
            ReadMemory(LogMemLoc,
               &logEntry64,
               sizeof(logEntry64),
               &cb);
  
            s.l = logEntry64.le_sig;

            m1 = logEntry64.le_info1;                
            m2 = logEntry64.le_info2;  
            m3 = logEntry64.le_info3; 
            
        } else {
            ReadMemory(LogMemLoc,
               &logEntry32,
               sizeof(logEntry32),
               &cb);

            s.l = logEntry32.le_sig;

            m1 = logEntry32.le_info1;                
            m2 = logEntry32.le_info2;  
            m3 = logEntry32.le_info3;  
        }

//        if (s.l == MarkSig1 || s.l == MarkSig2) {
//            c = '*';
//        } else {
//            c = ' ';
//        }
        c = ' ';
        dprintf("%c[%3.3d]", c, i); 
        PrintfMemLoc(" ", LogMemLoc, " ");
        
        dprintf("%c%c%c%c ", s.c[0],  s.c[1],  s.c[2], s.c[3]);
       
        PrintfMemLoc(" ", m1, " ");
        PrintfMemLoc(" ", m2, " ");
        PrintfMemLoc(" ", m3, "\n");
        
        LogMemLoc+=cb;            

        if (LogMemLoc > EndMemLoc) {
            LogMemLoc = StartMemLoc;
        }
    }

}


DECLARE_API( _eplog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "_HCD_ENDPOINT";
   
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "Log.LogPtr");
    logStart = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "Log.LogEnd");

    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}




DECLARE_API( _log )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG logIdx, m, i;
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logStart = UsbReadFieldPtr(addr, cs, "Log.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "Log.LogEnd");
    logIdx = UsbReadFieldUlong(addr, cs, "Log.LogIdx");
    m = UsbReadFieldUlong(addr, cs, "Log.LogSizeMask");
    i = logIdx & m;
    
    dprintf(">LOG mask = %x idx = %x (%x)\n", m, logIdx, i );
    if (IsPtr64()) { 
        logPtr += (i*32);
    } else {
        logPtr += (i*16);
    }
    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}


DECLARE_API( _xlog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    ULONG len = 5;
    UCHAR buffer1[256];
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
   
    
    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s ", &buffer1);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    logPtr = UsbReadFieldPtr(addr, cs, "TransferLog.LogStart");
    logStart = UsbReadFieldPtr(addr, cs, "TransferLog.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "TransferLog.LogEnd");

    DumpXferLog (logPtr,
                 logStart,
                 logEnd,
                 len);

    return S_OK;             
}


DECLARE_API( _isolog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR cs[] = "_HCD_ENDPOINT";
   
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");
    sscanf(s, ",%s %s %s", &buffer1, &buffer2, &buffer3);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }

    s1.l = 0;
    if ('\0' != buffer2[0]) {
//        sscanf(buffer2, "%d", &len);
        s1.c[0] = buffer2[0];
        s1.c[1] = buffer2[1];
        s1.c[2] = buffer2[2];
        s1.c[3] = buffer2[3];
    }

    s2.l = 0;
    if ('\0' != buffer3[0]) {
//        sscanf(buffer2, "%d", &len);
        s2.c[0] = buffer3[0];
        s2.c[1] = buffer3[1];
        s2.c[2] = buffer3[2];
        s2.c[3] = buffer3[3];
    }

    logPtr = UsbReadFieldPtr(addr, cs, "IsoLog.LogPtr");
    logStart = UsbReadFieldPtr(addr, cs, "IsoLog.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "IsoLog.LogEnd");

    DumpLog (logPtr,
             logStart,
             logEnd,
             len,
             s1.l,
             s2.l);

    return S_OK;             
}


DECLARE_API( _enumlog )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/
{
    MEMLOC addr;
    PCSTR s;
    UCHAR           buffer1[256];
    UCHAR           buffer2[256];
    UCHAR           buffer3[256];
    SIG s1, s2;
    ULONG len = 5;
    MEMLOC logPtr, logStart, logEnd;
    UCHAR csFdo[] = "usbport!_FDO_EXTENSION";
    UCHAR cs[] = "usbport!_DEVICE_EXTENSION";
    ULONG logIdx, m, i;
    
    buffer1[0] = '\0';
    buffer2[0] = '\0';
    buffer3[0] = '\0';

    GetExpressionEx( args, &addr, &s );
    
    PrintfMemLoc("LOG@: ", addr, "\n");

    sscanf(s, ",%s ", &buffer1);

    if ('\0' != buffer1[0]) {
        sscanf(buffer1, "%d", &len);
    }
    
    logPtr = UsbReadFieldPtr(addr, cs, "EnumLog.LogStart");
    logStart = UsbReadFieldPtr(addr, cs, "EnumLog.LogStart");
    logEnd = UsbReadFieldPtr(addr, cs, "EnumLog.LogEnd");
    logIdx = UsbReadFieldUlong(addr, cs, "EnumLog.LogIdx");
    m = UsbReadFieldUlong(addr, cs, "EnumLog.LogSizeMask");
    i = logIdx & m;

    dprintf(">LOG mask = %x idx = %x (%x)\n", m, logIdx, i );
    if (IsPtr64()) { 
        logPtr += (i*32);
    } else {
        logPtr += (i*16);
    }
    DumpEnumLog (logPtr,
             logStart,
             logEnd,
             len);

    return S_OK;             
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\list.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    list.c

Abstract:

    WinDbg Extension Api
    implements !list

Author:

    jdunn

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"

// _list DH
VOID
DumpDeviceHandleList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_USBD_DEVICE_HANDLE";

    PrintfMemLoc("*LIST -- DeviceHandleList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        USHORT vid, pid;

        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "ListEntry");

        dprintf ("[%d] DeviceHandle: ", i);
        PrintfMemLoc("", memLoc, " ");
        i++;

        dprintf("VID %04.4x PID %04.4x\n",
        UsbReadFieldUshort(memLoc, cs, "DeviceDescriptor.idVendor"),
        UsbReadFieldUshort(memLoc, cs, "DeviceDescriptor.idProduct"));
#if 0
        PrintfMemLoc("\tDriverObject: ",
            UsbReadFieldPtr(mpMemLoc, cs, "DriverObject"),
            "\n");
        PrintfMemLoc("\tMiniportUnload: ",
            UsbReadFieldPtr(mpMemLoc, cs, "MiniportUnload"),
            "\n");
#endif
        flink = UsbReadFieldPtr(memLoc, cs, "ListEntry.Flink");


    }

}

#define LT_ENDPOINT_ACTIVE_LIST     0
#define LT_MAP_TRANSFER_LIST        1
#define LT_DONE_TRANSFER_LIST       2
#define LT_ENDPOINT_CANCEL_LIST     3
#define LT_ENDPOINT_PENDING_LIST    4

// AL, MT, DT
VOID
DumpTransferList(
    ULONG ListType,
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink, blink, memLoc;
    UCHAR cs[] = "_HCD_TRANSFER_CONTEXT";
    ULONG i=0;

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    switch(ListType) {
    case LT_ENDPOINT_ACTIVE_LIST:
        dprintf ("*LIST -- EndpointActiveList\n");
        break;
    case LT_MAP_TRANSFER_LIST:
        dprintf ("*LIST -- MapTransferList\n");
        break;
    case LT_DONE_TRANSFER_LIST:
        dprintf ("*LIST -- DoneTransferList\n");
        break;
    case LT_ENDPOINT_CANCEL_LIST:
        dprintf ("*LIST -- EndpointCancelList\n");
        break;
    case LT_ENDPOINT_PENDING_LIST:
        dprintf ("*LIST -- EndpointPendingList\n");
        break;
    }

    while (flink != HeadMemLoc) {
        ULONG f;

        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "TransferLink");

        dprintf ("[%d] Transfer (_tfer): ", i);

        PrintfMemLoc(" ", memLoc, " ");
        PrintfMemLoc(" Urb (_urb): ",
            UsbReadFieldPtr(memLoc, cs, "Urb"),
            "");

        f = UsbReadFieldUlong(memLoc, cs, "Flags");

        if (f & USBPORT_TXFLAG_IN_MINIPORT) {
            dprintf ("  USBPORT_TXFLAG_IN_MINIPORT\n");
        }

        dprintf ("\n");
        i++;

        flink = UsbReadFieldPtr(memLoc,
            cs, "TransferLink.Flink");

    }

}


// CL
VOID
DumpClosedEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- EpClosedList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "ClosedLink");

        dprintf ("[%d] Endpoint: ", i);
        PrintfMemLoc("", memLoc, "\n");

        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");

        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ",
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir);
        }
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "ClosedLink.Flink");
    }

}


// AT
VOID
DumpAttendEndpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- AttendEndpointList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "AttendLink");

        dprintf ("[%d] Endpoint: ", i);
        PrintfMemLoc("", memLoc, "\n");

        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");

        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ",
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir);
        }
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "AttendLink.Flink");
    }

}



// GL
VOID
DumpGlobalEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    USHORT ea, da;

    PrintfMemLoc("*LIST -- GlobalEndpointList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "GlobalLink");

        dprintf ("[%d] Endpoint (_endp): ", i);
        PrintfMemLoc("", memLoc, "\n");

        da = UsbReadFieldUshort(memLoc, cs, "Parameters.DeviceAddress");
        ea = UsbReadFieldUshort(memLoc, cs, "Parameters.EndpointAddress");
        tt = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferType");
        dir = UsbReadFieldUlong(memLoc, cs, "Parameters.TransferDirection");

        dprintf ("\tDevice Address: 0x%02.2x, ep 0x%02.2x ",
                    da,
                    ea);
        EpType(tt);
        dprintf (" ");
        if (tt != Control) {
            EpDir(dir);
        }
        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "GlobalLink.Flink");
    }

}


// SC
VOID
DumpStateEnpointList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_HCD_ENDPOINT";
    ENDPOINT_TRANSFER_TYPE tt;
    ENDPOINT_TRANSFER_DIRECTION dir;
    ULONG f;

    PrintfMemLoc("*LIST -- EpStateChangeList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "StateLink");

        dprintf ("[%d] Endpoint (_endp): ", i);
        PrintfMemLoc("", memLoc, " ");

        f = UsbReadFieldUlong(memLoc, cs, "StateChangeFrame");
        dprintf ("- frame (0x%x) \n", f);

        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "StateLink.Flink");
    }

}


// PH
VOID
DumpPipeHandleList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "USBD_PIPE_HANDLE_I";

    PrintfMemLoc("*LIST -- PipeHandleList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i<100) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "ListEntry");

        dprintf ("[%d] PipeHandle (_piph): ", i);
        PrintfMemLoc("", memLoc, "\n");

        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "ListEntry.Flink");
    }

#if 0
    LIST_ENTRY headListEntry;
    ULONG pipeMemLoc, result, i=0;
    USBD_PIPE_HANDLE_I pipeHandle;
    ULONG memLocListEntry;

    dprintf ("*LIST -- PipeHandleList\n");
    if (ReadMemory (HeadMemLoc, &headListEntry, sizeof (LIST_ENTRY), &result)) {

        memLocListEntry = (ULONG) headListEntry.Flink;

        while (memLocListEntry != HeadMemLoc) {
            // extact this device handle
            pipeMemLoc = memLocListEntry;
            pipeMemLoc = pipeMemLoc-
                 FIELD_OFFSET(USBD_PIPE_HANDLE_I, ListEntry);

            if (ReadMemory (pipeMemLoc, &pipeHandle, sizeof (pipeHandle), &result)) {
                dprintf ("[%d] PipeHandle: %08.8x endpoint: %08.8x\n", i,
                    pipeMemLoc, pipeHandle.Endpoint);
                // display the address and type
                i++;
                memLocListEntry = (ULONG) pipeHandle.ListEntry.Flink;
            } else {
                dprintf ("Could not read Pipehandle\n");
                break;
            }
        }

    } else {
        dprintf ("Could not read list head\n");
    }
#endif
}

VOID
DumpRegCacheList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_USBPORT_REG_CACHE_ENTRY";

    PrintfMemLoc("*LIST -- RegCache ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i<100) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "RegLink");

        dprintf ("[%d] RegCache  ( _USBPORT_REG_CACHE_ENTRY ): ", i);
        PrintfMemLoc("", memLoc, "\n");

        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "RegLink.Flink");
    }
}


// TT
VOID
DumpTtList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    ULONG i=0;
    UCHAR cs[] = "_TRANSACTION_TRANSLATOR";

    PrintfMemLoc("*LIST -- TtList ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    //PrintfMemLoc("blink: ", blink, "\n");
    //PrintfMemLoc("flink: ", flink, "\n");

    while (flink != HeadMemLoc && i<100) {
        // get the address of the USBPORT_MINIPORT_DRIVER
        // struct
        memLoc = flink - UsbFieldOffset(cs,
            "TtLink");

        dprintf ("[%d] TT (_tt): ", i);
        PrintfMemLoc("", memLoc, "\n");

        dprintf ("\n");
        i++;
        flink = UsbReadFieldPtr(memLoc, cs, "TtLink.Flink");
    }
}


// BA
VOID
DumpBadRequestList(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc, irpMemLoc;
    ULONG i=0;

    PrintfMemLoc("*LIST -- BadRequest ", HeadMemLoc, "\n");

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    PrintfMemLoc("blink: ", blink, "\n");
    PrintfMemLoc("flink: ", flink, "\n");
    memLoc = flink;

    while (flink != HeadMemLoc && i<30) {

        irpMemLoc = memLoc;
        GetFieldValue(memLoc, "_LIST_ENTRY", "Flink", memLoc);
        irpMemLoc = irpMemLoc-
             UsbFieldOffset("_IRP",
                    "Tail.Overlay.ListEntry");

        dprintf ("[%d] Irp: ", i);
        PrintfMemLoc("", irpMemLoc, "\n");
        i++;


        flink = memLoc;
    }
}


// AI
VOID
DumpAbortIrpList(
    MEMLOC HeadMemLoc
    )
{

    MEMLOC flink;
    MEMLOC blink;
    MEMLOC memLoc;
    MEMLOC irpMemLoc;
    ULONG i = 0;

    PrintfMemLoc("*LIST -- AbortIrpList ", HeadMemLoc, "\n");
#if 0
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    memLoc = flink;

    while (memLoc != HeadMemLoc) {

        // extract this entry

        irpMemLoc = memLoc;
        GetFieldValue(memLoc, "_LIST_ENTRY", "Flink", memLoc);
        irpMemLoc = irpMemLoc-
             UsbFieldOffset("_IRP",
                    "Tail.Overlay.ListEntry");

        dprintf ("[%d] Irp: ", i);
        PrintfMemLoc("", irpMemLoc, "\n");
        i++;
    }
#endif
}



PCHAR
ListEmpty(
    MEMLOC HeadMemLoc
    )
{
    MEMLOC flink;
    MEMLOC blink;

    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink);
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink);

    if (flink == HeadMemLoc) {
        return "empty\n";
    } else {
        return "\n";
    }
}


DECLARE_API( _list )

/*++

Routine Description:

   dumps a usbport list

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );

    PrintfMemLoc("list: ", addr, " ");
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    if (_strcmpi(parm, "DH") == 0) {
        DumpDeviceHandleList(addr);
    }

    if (_strcmpi(parm, "GL") == 0) {
        DumpGlobalEnpointList(addr);
    }

    if (_strcmpi(parm, "AL") == 0) {
        DumpTransferList(LT_ENDPOINT_ACTIVE_LIST, addr);
    }

    if (_strcmpi(parm, "PL") == 0) {
        DumpTransferList(LT_ENDPOINT_PENDING_LIST, addr);
    }

    if (_strcmpi(parm, "AI") == 0) {
        DumpAbortIrpList(addr);
    }

    if (_strcmpi(parm, "BA") == 0) {
        DumpBadRequestList(addr);
    }

    if (_strcmpi(parm, "XL") == 0) {
        DumpClosedEnpointList(addr);
    }

    if (_strcmpi(parm, "AT") == 0) {
        DumpAttendEndpointList(addr);
    }

    if (_strcmpi(parm, "SC") == 0) {
        DumpStateEnpointList(addr);
    }

    if (_strcmpi(parm, "PH") == 0) {
        DumpPipeHandleList(addr);
    }

    if (_strcmpi(parm, "TT") == 0) {
        DumpTtList(addr);
    }

    if (_strcmpi(parm, "DT") == 0) {
        DumpTransferList(LT_DONE_TRANSFER_LIST, addr);
    }

    if (_strcmpi(parm, "MT") == 0) {
        DumpTransferList(LT_MAP_TRANSFER_LIST, addr);
    }

    if (_strcmpi(parm, "RE") == 0) {
        DumpRegCacheList(addr);
    }

#if 0
    if (_strcmpi(parm, "XL") == 0) {
        DumpClosedEnpointList(memLoc, level);
    }

    if (_strcmpi(parm, "SC") == 0) {
        DumpStateEnpointList(memLoc, level);
    }

    if (_strcmpi(parm, "PH") == 0) {
        DumpPipeHandleList(memLoc, level);
    }

    if (_strcmpi(parm, "AT") == 0) {
        DumpAttendEndpointList(memLoc, level);
    }

    // endpoint transfer lists
    if (_strcmpi(parm, "AL") == 0) {
        DumpTransferList(LT_ENDPOINT_ACTIVE_LIST, memLoc, level);
    }

    if (_strcmpi(parm, "CL") == 0) {
        DumpTransferList(LT_ENDPOINT_CANCEL_LIST, memLoc, level);
    }

    if (_strcmpi(parm, "PL") == 0) {
        DumpTransferList(LT_ENDPOINT_PENDING_LIST, memLoc, level);
    }


    // global transfer lists
    if (_strcmpi(parm, "MT") == 0) {
        DumpTransferList(LT_MAP_TRANSFER_LIST, memLoc, level);
    }

    if (_strcmpi(parm, "DT") == 0) {
        DumpTransferList(LT_DONE_TRANSFER_LIST, memLoc, level);
    }

    if (_strcmpi(parm, "AI") == 0) {
        DumpAbortIrpList(memLoc, level);
    }
#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\struc.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    struc.c

Abstract:

    WinDbg Extension Api
    implements !_devh   dumps USBD_DEVICE_HANDLE
               !_piph   dumps USBD_PIPE_HANDLE_I 
               !_endp   dumps HCD_ENDPOINT
               !_cmbf   dumps USBPORT_COMMON_BUFFER
               !_tfer   dumps HCD_TRANSFER_CONTEXT
               !_mdl    dumps MDL
               !_cfgh   dumps 

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


VOID    
DumpDeviceHandle(
    MEMLOC MemLoc
    )
{
    MEMLOC l, t;
    USB_DEVICE_DESCRIPTOR dd;
    ULONG f, cb;
    UCHAR cs[] = "_USBD_DEVICE_HANDLE";
    STRUC_ENTRY DevHandle[] = {
        "Sig", FT_SIG,
        "DeviceAddress", FT_USHORT,
        "Tt", FT_PTR,
        "PendingUrbs", FT_ULONG,
        "TtPortNumber", FT_USHORT,
        "HubDeviceHandle", FT_PTR,
        "ConfigurationHandle", FT_PTR,
        "DeviceSpeed", FT_DEVSPEED
    };
    FLAG_TABLE devFlags[] = {
        "USBPORT_DEVICEFLAG_ROOTHUB", USBPORT_DEVICEFLAG_ROOTHUB,
        "USBPORT_DEVICEFLAG_FREED_BY_HUB", USBPORT_DEVICEFLAG_FREED_BY_HUB
    }; 

    PrintfMemLoc("*USBD_DEVICE_HANDLE ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &DevHandle[0], sizeof(DevHandle)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "DeviceFlags");
    dprintf("DeviceFlags: %08.8x\n", f); 
    UsbDumpFlags(f, devFlags, 
        sizeof(devFlags)/sizeof(FLAG_TABLE));

    dprintf("-pipe list-\n");

    l = MemLoc + UsbFieldOffset(cs, "PipeHandleList");
    PrintfMemLoc("\t(PH) PipeHandleList: ", 
            l, 
            ListEmpty(l));    

    dprintf("-tt list-\n");
    l = MemLoc + UsbFieldOffset(cs, "TtList");
    PrintfMemLoc("\t(TT) TtList: ", 
            l, 
            ListEmpty(l));                

    t = MemLoc + UsbFieldOffset(cs, "DeviceDescriptor");
    PrintfMemLoc("DeviceDescriptor ", t, "\n");

    ReadMemory(t,
               &dd,
               sizeof(dd),
               &cb);

    DumpUSBDescriptor(&dd);
    
}


VOID    
DumpTt(
    MEMLOC MemLoc
    )
{
    ULONG f, i;
    UCHAR cs[] = "_TRANSACTION_TRANSLATOR";
    UCHAR s[64];
    STRUC_ENTRY tt[] = {
        "Sig", FT_SIG,
        "DeviceAddress", FT_USHORT,
        "PdoDeviceObject", FT_PTR,
    };

    PrintfMemLoc("*TRANSACTION_TRANSLATOR ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &tt[0], sizeof(tt)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "TotalBusBandwidth");
    dprintf("TotalBusBandwidth: %d\n", f); 
    
    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        sprintf(s, "BandwidthTable[%d]", i);
               
        dprintf("\tBandwidthTable[%d] - %d\n", i,
            UsbReadFieldUlong(MemLoc, cs, s)); 
    }        
    
}


VOID    
DumpIPipe(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_USBD_PIPE_HANDLE_I";
    ULONG f, cb;
    STRUC_ENTRY p[] = {
        "Sig", FT_SIG,
        "Endpoint", FT_PTR,
        "UsbdPipeFlags", FT_ULONG,
    };
    FLAG_TABLE pipeStateFlags[] = {
        "USBPORT_PIPE_STATE_CLOSED", USBPORT_PIPE_STATE_CLOSED,
         };   
    MEMLOC tmp;  
    USB_ENDPOINT_DESCRIPTOR ed;

    f = UsbReadFieldUlong(MemLoc, cs, "PipeStateFlags"); 
    dprintf("PipeStateFlags: %08.8x\n", f);
    UsbDumpFlags(f, pipeStateFlags, 
        sizeof(pipeStateFlags)/sizeof(FLAG_TABLE));
    UsbDumpStruc(MemLoc, cs, 
        &p[0], sizeof(p)/sizeof(STRUC_ENTRY));

    tmp = MemLoc + UsbFieldOffset(cs, "EndpointDescriptor");
    PrintfMemLoc("EndpointDescriptor ", tmp, "\n");

    ReadMemory(tmp,
               &ed,
               sizeof(ed),
               &cb);

    DumpUSBDescriptor(&ed);

}


VOID    
DumpIsoPacket(
    MEMLOC MemLoc,
    ULONG Idx
    )
{
    UCHAR cs[] = "_MINIPORT_ISO_PACKET";
    ULONG f, c, i;
    UCHAR s[32]; 
    STRUC_ENTRY t[] = {
        "Length", FT_ULONG,
        "LengthTransferred", FT_ULONG,
        "FrameNumber", FT_ULONG,
        "MicroFrameNumber", FT_ULONG,
        "UsbdStatus", FT_ULONG,
        "BufferPointerCount", FT_ULONG,
        "BufferPointer0Length", FT_ULONG,
        "BufferPointer0.Hw32", FT_ULONG,
        "BufferPointer1Length", FT_ULONG,
        "BufferPointer1.Hw32", FT_ULONG,         
    };

    sprintf(s, "*PACKET[%x] - ", Idx);
    PrintfMemLoc(s, MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));
}


VOID    
DumpIsoTransferContext(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_MINIPORT_ISO_TRANSFER";
    UCHAR s[64];
    ULONG f, c, i, p;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "PacketCount", FT_ULONG,
        "SystemAddress", FT_PTR,
    };

    PrintfMemLoc("*MINIPORT_ISO_TRANSFER ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));
        
    p = UsbReadFieldUlong(MemLoc, cs, "PacketCount");
    for (i=0; i<p; i++) {
        MEMLOC t;
        
        sprintf(s, "Packets[%x]", i);
        t = MemLoc + UsbFieldOffset(cs, s);

        DumpIsoPacket(t, i);
    }
}


VOID    
DumpTransferContext(
    MEMLOC MemLoc
    )
{
    MEMLOC sgList;
    USBPORT_TRANSFER_DIRECTION d;
    UCHAR cs[] = "_HCD_TRANSFER_CONTEXT";
    ULONG f, c, i;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "TotalLength", FT_ULONG,
        "MillisecTimeout", FT_ULONG,
        "MiniportBytesTransferred", FT_ULONG,
        "MiniportFrameCompleted", FT_ULONG,
        "TimeoutTime", FT_ULONG64,
        "Irp", FT_PTR,
        "Urb", FT_PTR,
        "Transfer", FT_PTR,
        "CompleteEvent", FT_PTR,
        "MapRegisterBase", FT_PTR,
        "NumberOfMapRegisters", FT_ULONG,
        "Endpoint", FT_PTR,
        "MiniportContext", FT_PTR,
        "IsoTransfer", FT_PTR,
    };
    FLAG_TABLE txFlags[] = {
        "USBPORT_TXFLAG_CANCELED", USBPORT_TXFLAG_CANCELED,
        "USBPORT_TXFLAG_MAPPED", USBPORT_TXFLAG_MAPPED,
        "USBPORT_TXFLAG_HIGHSPEED", USBPORT_TXFLAG_HIGHSPEED,
    
        "USBPORT_TXFLAG_IN_MINIPORT", USBPORT_TXFLAG_IN_MINIPORT,
        "USBPORT_TXFLAG_ABORTED", USBPORT_TXFLAG_ABORTED,
        "USBPORT_TXFLAG_ISO", USBPORT_TXFLAG_ISO,
        "USBPORT_TXFLAG_TIMEOUT", USBPORT_TXFLAG_TIMEOUT,

        "USBPORT_TXFLAG_TIMEOUT", USBPORT_TXFLAG_TIMEOUT,
        "USBPORT_TXFLAG_DEVICE_GONE", USBPORT_TXFLAG_DEVICE_GONE,
        "USBPORT_TXFLAG_SPLIT_CHILD", USBPORT_TXFLAG_SPLIT_CHILD,
        "USBPORT_TXFLAG_MPCOMPLETED", USBPORT_TXFLAG_MPCOMPLETED,
        "USBPORT_TXFLAG_SPLIT", USBPORT_TXFLAG_SPLIT
         }; 

    PrintfMemLoc("*TRANSFER ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: 0x%08.8x\n", f);    
    UsbDumpFlags(f, txFlags, 
            sizeof(txFlags)/sizeof(FLAG_TABLE));

    d = UsbReadFieldUlong(MemLoc, cs, "Direction");   
    dprintf("Direction: ");
    switch (d) {
    case NotSet: 
        dprintf("NotSet\n");
        break;
    case ReadData:
        dprintf("ReadData\n");
        break;
    case WriteData:
        dprintf("WriteData\n");
        break;
    }

    {
    MEMLOC tmp;
    STRUC_ENTRY tp[] = {
        "TransferFlags", FT_ULONG,
        "TransferBufferLength", FT_ULONG,
        "SetupPacket[0]", FT_UCHAR,
        "SetupPacket[1]", FT_UCHAR,
        "SetupPacket[2]", FT_UCHAR,
        "SetupPacket[3]", FT_UCHAR,
        "SetupPacket[4]", FT_UCHAR,
        "SetupPacket[5]", FT_UCHAR,
        "SetupPacket[6]", FT_UCHAR,
        "SetupPacket[7]", FT_UCHAR,
        };
    tmp = MemLoc + UsbFieldOffset(cs, "Tp");
    dprintf("<TRANSFER_PARAMETERS>\n");
    UsbDumpStruc(tmp, "_TRANSFER_PARAMETERS", 
        &tp[0], sizeof(tp)/sizeof(STRUC_ENTRY));
 
    }       


    {
    STRUC_ENTRY sg[] = {
        "SgFlags", FT_ULONG,
        "MdlVirtualAddress", FT_PTR,
        "MdlSystemAddress", FT_PTR,
        "SgCount", FT_ULONG,
        };
    sgList = MemLoc + UsbFieldOffset(cs, "SgList");
    dprintf("<SG_LIST>\n");
    UsbDumpStruc(sgList, "_TRANSFER_SG_LIST", 
        &sg[0], sizeof(sg)/sizeof(STRUC_ENTRY));
 
    c = UsbReadFieldUlong(sgList, "_TRANSFER_SG_LIST", "SgCount");
    }
    dprintf("<SG_LIST(%d)>\n", c);
    for (i=0; i< c; i++) {
        UCHAR s[64];
        MEMLOC tmp;
        STRUC_ENTRY sg[] = {
            "StartOffset", FT_ULONG,
            "Length", FT_ULONG,
            "LogicalAddress", FT_PTR,
            "SystemAddress", FT_PTR
            };
        sprintf(s, "SgEntry[%d]", i);            
        tmp = sgList + UsbFieldOffset("_TRANSFER_SG_LIST", s);
        dprintf("<SG_ENTRY> [%d]\n", i);
        UsbDumpStruc(tmp, "TRANSFER_SG_ENTRY32", 
            &sg[0], sizeof(sg)/sizeof(STRUC_ENTRY));
    }    
#if 0
        // dump the sg list 
        dprintf("SGList.SgFlags: %08.8x\n", transfer->SgList.SgFlags);
        dprintf("SGList.MdlVirtualAddress: %08.8x\n", transfer->SgList.MdlVirtualAddress);
        dprintf("SGList.SgCount: %08.8x\n", transfer->SgList.SgCount);
        for (i=0; i< transfer->SgList.SgCount; i++) {
             dprintf("SGList.SgEntry[%d].StartOffset: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].StartOffset);
             dprintf("SGList.SgEntry[%d].Length: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].Length);            
             dprintf("SGList.SgEntry[%d].LogicalAddress: %08.8x\n", 
                i, transfer->SgList.SgEntry[i].LogicalAddress);             
        }

        if (transfer->Flags & USBPORT_TXFLAG_ISO) {
            DumpIsoTransferContext((ULONG) transfer->IsoTransfer);
        }
        
        free(transfer);

    }
#endif    
}


VOID    
EpStatus(
    MP_ENDPOINT_STATUS status
    )
{
    switch(status) {
    case ENDPOINT_STATUS_RUN:
        dprintf("\t ENDPOINT_STAUS_RUN\n");
        break;
    case ENDPOINT_STATUS_HALT:
        dprintf("\t ENDPOINT_STATUS_HALT\n");
        break;
    }
}


VOID    
EpState(
    MP_ENDPOINT_STATE state
    )
{
    switch(state) {
    case ENDPOINT_TRANSITION:
        dprintf("\t ENDPOINT_TRANSITION\n");
        break;
    case ENDPOINT_IDLE:
        dprintf("\t ENDPOINT_IDLE\n");
        break;
    case ENDPOINT_PAUSE: 
        dprintf("\t ENDPOINT_PAUSE\n");
        break;
    case ENDPOINT_ACTIVE: 
        dprintf("\t ENDPOINT_ACTIVE\n");
        break;
    case ENDPOINT_REMOVE: 
        dprintf("\t ENDPOINT_REMOVE\n");
        break;
    case ENDPOINT_CLOSED:
        dprintf("\t ENDPOINT_CLOSED\n");
        break;
    }
}


VOID    
EpType(
    ENDPOINT_TRANSFER_TYPE Typ
    )
{
    switch(Typ) {
    case Isochronous:
        dprintf("Isochronous");
        break;
    case Control:
        dprintf("Control");
        break;
    case Bulk: 
        dprintf("Bulk");
        break;
    case Interrupt: 
        dprintf("Interrupt");
        break;
    }
}


VOID    
EpDir(
    ENDPOINT_TRANSFER_DIRECTION Dir
    )
{
    switch(Dir) {
    case In:
        dprintf("In");
        break;
    case Out:
        dprintf("Out");
        break;
    }
}

VOID    
EpSpeed(
    DEVICE_SPEED Speed
    )
{
    switch(Speed) {
    case LowSpeed:
        dprintf("LowSpeed");
        break;
    case FullSpeed:
        dprintf("FullSpeed");
        break;
    case HighSpeed:
        dprintf("HighSpeed");
        break;        
    }
}


VOID    
DumpEndpointParameters(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_ENDPOINT_PARAMETERS";    

    PrintfMemLoc("-endpoint Parameters- ", MemLoc, "\n");

    dprintf("\tDeviceAddress: 0x%x\n", 
         UsbReadFieldUshort(MemLoc, cs, "DeviceAddress"));
    dprintf("\tEndpointAddress: 0x%x\n", 
         UsbReadFieldUshort(MemLoc, cs, "EndpointAddress"));
    dprintf("\tMaxPacketSize: 0x%08.8x\n", 
        UsbReadFieldUshort(MemLoc, cs, "MaxPacketSize"));
    dprintf("\tPeriod: 0x%0.2x\n", 
        UsbReadFieldUchar(MemLoc, cs, "Period"));
    dprintf("\tMaxPeriod: 0x%0.2x\n", 
        UsbReadFieldUchar(MemLoc, cs, "MaxPeriod"));        
    dprintf("\tBandwidth: 0x%08.8x %d Bits/Sec\n", 
        UsbReadFieldUlong(MemLoc, cs, "Bandwidth"),
        UsbReadFieldUlong(MemLoc, cs, "Bandwidth"));
    dprintf("\tSchedule Offset: %d\n",
        UsbReadFieldUlong(MemLoc, cs, "ScheduleOffset"));
    dprintf("\tType: ");
    EpType(UsbReadFieldUlong(MemLoc, cs, "TransferType"));
    dprintf("\n\tDirection: ");
    EpDir(UsbReadFieldUlong(MemLoc, cs, "TransferDirection"));
    dprintf("\n");
    
    PrintfMemLoc("\tCommonBufferVa: ",   
        UsbReadFieldPtr(MemLoc, cs, "CommonBufferVa"),
        "\n");
    
    dprintf("\tCommonBufferPhys (32 bit): %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "CommonBufferPhys"));
    dprintf("\tCommonBufferBytes: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "CommonBufferBytes"));
    dprintf("\tEndpointFlags: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "EndpointFlags"));
    dprintf("\tMaxTransferSize: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "MaxTransferSize"));
    dprintf("\tDeviceSpeed: %d - ", 
        UsbReadFieldUlong(MemLoc, cs, "DeviceSpeed"));
    EpSpeed(UsbReadFieldUlong(MemLoc, cs, "DeviceSpeed"));
    dprintf("\n");

    dprintf("\tTtDeviceAddress: 0x%x - ", 
        UsbReadFieldUlong(MemLoc, cs, "TtDeviceAddress"));
    dprintf("TtPortNumber: %d - \n", 
        UsbReadFieldUlong(MemLoc, cs, "TtPortNumber"));
    dprintf("\tInterruptScheduleMask: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "InterruptScheduleMask"));
    dprintf("\tSplitCompletionMask: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "SplitCompletionMask"));
    dprintf("\tTransactionsPerMicroframe: x%x - \n", 
        UsbReadFieldUchar(MemLoc, cs, "TransactionsPerMicroframe"));        
    dprintf("\tMuxPacketSize: x%x - \n", 
        UsbReadFieldUshort(MemLoc, cs, "MuxPacketSize"));            
    dprintf("\tOrdinal: x%x - \n", 
        UsbReadFieldUlong(MemLoc, cs, "Ordinal"));                
    PrintfMemLoc("\tBudgetNextEndpoint:", 
        UsbReadFieldPtr(MemLoc, cs, "BudgetNextEndpoint"),
        "\n");        
}


VOID    
DumpEndpoint(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_HCD_ENDPOINT";
    SIG s;
    FLAG_TABLE epFlags[] = {
        "EPFLAG_MAP_XFERS", EPFLAG_MAP_XFERS,
        "EPFLAG_ROOTHUB", EPFLAG_ROOTHUB,
        "EPFLAG_NUKED", EPFLAG_NUKED,
        "EPFLAG_VIRGIN", EPFLAG_VIRGIN,
        "EPFLAG_DEVICE_GONE", EPFLAG_DEVICE_GONE
         };     
    MP_ENDPOINT_STATUS epStatus;
    MP_ENDPOINT_STATE epState;
    ULONG f;
    MEMLOC l;
         
    PrintfMemLoc("*ENDPOINT ", MemLoc, "\n");

    s.l = UsbReadFieldUlong(MemLoc, cs, "Sig");
    Sig(s.l, "");
    if (s.l != SIG_ENDPOINT) {
        BadSig(s.l, SIG_ENDPOINT);
        return;
    }
    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: %08.8x\n", f);    
    UsbDumpFlags(f, epFlags, 
        sizeof(epFlags)/sizeof(FLAG_TABLE));

    
    dprintf("Busy: %d\n", 
        UsbReadFieldUlong(MemLoc, cs, "Busy"));    

    PrintfMemLoc("FdoDeviceObject:", 
        UsbReadFieldPtr(MemLoc, cs, "DeviceDescriptor"),
        "\n");
        
    epStatus = UsbReadFieldUlong(MemLoc, cs, "CurrentStatus");
    dprintf("CurrentStatus: %08.8x\n", epStatus); 
    EpStatus(epStatus);     

    epState = UsbReadFieldUlong(MemLoc, cs, "CurrentState");
    dprintf("CurrentState: %08.8x\n", epState); 
    EpState(epState);  
        
    epState = UsbReadFieldUlong(MemLoc, cs, "NewState");
    dprintf("NewState: %08.8x\n", epState); 
    EpState(epState);  
        
    dprintf("StateChangeFrame: %08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "StateChangeFrame"));
    
    PrintfMemLoc("EpWorkerFunction:", 
        UsbReadFieldPtr(MemLoc, cs, "EpWorkerFunction"),
        "\n");
    PrintfMemLoc("CommonBuffer:", 
        UsbReadFieldPtr(MemLoc, cs, "CommonBuffer"),
        "\n");        
        
    PrintfMemLoc("Usb2LibEpContext:", 
        UsbReadFieldPtr(MemLoc, cs, "Usb2LibEpContext"),
        "\n");
             
    PrintfMemLoc("MiniportContext: ", 
            MemLoc + UsbFieldOffset(cs, "MiniportEndpointData"),
            "\n");
//    dprintf("HubDeviceAddress: 0x%08.8x\n", endpoint.HubDeviceAddress);
//    dprintf("PortTTNumber: 0x%08.8x\n", endpoint.PortTTNumber);

    DumpEndpointParameters(MemLoc + UsbFieldOffset(cs, "Parameters"));        

    dprintf("-lists-\n");

    l = MemLoc + UsbFieldOffset(cs, "ActiveList");
    PrintfMemLoc("\t(AL) ActiveList: ", 
            l, 
            ListEmpty(l));            
            
    l = MemLoc + UsbFieldOffset(cs, "PendingList");
    PrintfMemLoc("\t(PL) PendingList: ", 
            l, 
            ListEmpty(l));   
            
    l = MemLoc + UsbFieldOffset(cs, "CancelList");
    PrintfMemLoc("\t(CL) CancelList: ", 
            l, 
            ListEmpty(l));   
            
    l = MemLoc + UsbFieldOffset(cs, "AbortIrpList");
    PrintfMemLoc("\t(AI) AbortIrpList: ", 
            l, 
            ListEmpty(l));

             
            
//    LIST_ENTRY AbortIrpList;
#if 0
    // for linkage to global endpoint list
    dprintf("-linkage-\n");
    dprintf("\tGlobalLink.Flink: %08.8x\n", endpoint.GlobalLink.Flink);
    dprintf("\tGlobalLink.Blink: %08.8x\n", endpoint.GlobalLink.Blink);

    dprintf("\tAttendLink.Flink: %08.8x\n", endpoint.AttendLink.Flink);
    dprintf("\tAttendLink.Blink: %08.8x\n", endpoint.AttendLink.Blink);

    dprintf("\tStateLink.Flink: %08.8x\n", endpoint.StateLink.Flink);
    dprintf("\tStateLink.Blink: %08.8x\n", endpoint.StateLink.Blink);

    dprintf("\tClosedLink.Flink: %08.8x\n", endpoint.ClosedLink.Flink);
    dprintf("\tClosedLink.Blink: %08.8x\n", endpoint.ClosedLink.Blink);
#endif
}


VOID    
DumpCommonBuffer(
    ULONG MemLoc,
    ULONG Level
    )
{
    USBPORT_COMMON_BUFFER header;
    ULONG result;
 
    if (!ReadMemory (MemLoc, &header, sizeof (header), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*COMMON_BUFFER_HEADER %08.8x\n", MemLoc);
    Sig(header.Sig, "");
    if (header.Sig != SIG_CMNBUF) {
        BadSig(header.Sig, SIG_CMNBUF);
        return;
    }   
    dprintf("Flags: %08.8x\n", header.Flags);
    dprintf("TotalLength: %08.8x\n", header.TotalLength);
    dprintf("VirtualAddress: %08.8x\n", header.VirtualAddress);
    dprintf("BaseVa: %08.8x\n", header.BaseVa);
    dprintf("BasePhys: %08.8x\n", header.BasePhys);
    dprintf("MiniportLength: %08.8x\n", header.MiniportLength);
    dprintf("PadLength: %08.8x\n", header.PadLength);
    dprintf("MiniportVa: %08.8x\n", header.MiniportVa);
    dprintf("MiniportPhys: %08.8x\n", header.MiniportPhys);

}


VOID    
DumpMdl(
    ULONG MemLoc
    )
{
    PMDL mdl;
    MDL tmpMdl;
    PUCHAR buffer;
    ULONG result, count, i;
    PULONG pages;

    if (!ReadMemory (MemLoc, &tmpMdl, sizeof (tmpMdl), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    buffer = (PUCHAR) malloc(tmpMdl.Size);
    
    if (buffer != NULL) { 
    
        if (!ReadMemory (MemLoc, buffer, tmpMdl.Size, &result)) {
            BadMemLoc(MemLoc);
            free(buffer);
            return;
        }
        
        mdl = (PMDL) buffer;
        pages = (PULONG) (buffer+sizeof(MDL));

        dprintf("*MDL %08.8x\n", MemLoc);
        dprintf("Size: %d\n", mdl->Size);
        dprintf("Flags: %04.4x\n", mdl->MdlFlags);
        dprintf("MappedSystemVa: %08.8x\n", mdl->MappedSystemVa);
        dprintf("StartVa: %08.8x\n", mdl->StartVa);
        dprintf("ByteCount: %08.8x\n", mdl->ByteCount);
        dprintf("ByteOffset: %08.8x\n", mdl->ByteOffset);
        count = (mdl->Size - sizeof(MDL)) / sizeof(ULONG);
        dprintf("<Page Count> %d\n", count);
        
        for (i = 0; i < count; i++) {
            dprintf("Page[%d]: %08.8x\n", i, *pages);
            pages++;
        }

        free(buffer);
    }        
}


VOID    
DumpInterfaceHandle(
    MEMLOC MemLoc
    )
{   
    UCHAR cs[] = "_USBD_INTERFACE_HANDLE_I";
    ULONG f, cb;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "HasAlternateSettings", FT_UCHAR,
    };
    UCHAR c, i;
    MEMLOC tmp;
    USB_INTERFACE_DESCRIPTOR id;
    

    dprintf("***\n");
    PrintfMemLoc("*INTERFACE_HANDLE ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    c = UsbReadFieldUchar(MemLoc, cs, 
        "InterfaceDescriptor.bNumEndpoints");

    tmp = MemLoc + UsbFieldOffset(cs, "InterfaceDescriptor");
    PrintfMemLoc("InterfaceDescriptor ", tmp, "\n");

    ReadMemory(tmp,
               &id,
               sizeof(id),
               &cb);

    DumpUSBDescriptor(&id);
    for (i=0; i<c; i++) {
        UCHAR s[32];
        dprintf("pipe[%02.2d] ", i);
        sprintf(s, "PipeHandle[%d]", i);
        PrintfMemLoc("_piph ", 
            MemLoc + UsbFieldOffset(cs, s), "\n");
    }
    dprintf("***\n");
}


VOID
DumpInterfaceHandleList(
    MEMLOC HeadMemLoc
    )
{

    MEMLOC flink, blink, memLoc;
    UCHAR cs[] = "_USBD_INTERFACE_HANDLE_I";
    ULONG i=0;
    
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Flink", flink); 
    GetFieldValue(HeadMemLoc, "_LIST_ENTRY", "Blink", blink); 

    while (flink != HeadMemLoc) {
    
        memLoc = flink - UsbFieldOffset(cs, 
            "InterfaceLink");

        dprintf ("[%d] iHandle (_ihan): ", i);
                    
        PrintfMemLoc(" ", memLoc, "\n");             
                    
        i++;

        flink = UsbReadFieldPtr(memLoc, 
            cs, "InterfaceLink.Flink");
        DumpInterfaceHandle(memLoc);            

    }
}


VOID    
DumpUsbDescriptorMemLoc(
    ULONG MemLoc
    )
{
#if 0
    USB_COMMON_DESCRIPTOR cd;
    ULONG result;
    ULONG listMemLoc;
    PUCHAR tmp;
 
    if (!ReadMemory (MemLoc, &cd, sizeof (cd), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USB DESCRIPTOR %08.8x length:%d type:%d Next->%08.8x\n", 
        MemLoc, cd.bLength, cd.bDescriptorType,
        MemLoc+cd.bLength);

    tmp = malloc(cd.bLength);
    if (tmp) {
    
        if (!ReadMemory (MemLoc, tmp, cd.bLength, &result)) {
            BadMemLoc(MemLoc);
            return;
        }            

        DumpUSBDescriptor(tmp);
        
        free (tmp);        
    }    
#endif    
}    

VOID
DumpCfgDescriptorMemLoc(
    ULONG MemLoc
    )
{
#if 0
    USB_CONFIGURATION_DESCRIPTOR cf;
    PUSB_COMMON_DESCRIPTOR cd;
    ULONG result;
    PUCHAR tmp, tmp2;
 
    if (!ReadMemory (MemLoc, &cf, sizeof(cf), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USB CONFIG DESCRIPTOR %08.8x\n", 
        MemLoc);

    tmp = malloc(cf.wTotalLength);
    if (tmp) {
    
        if (!ReadMemory (MemLoc, tmp, cf.wTotalLength, &result)) {
            BadMemLoc(MemLoc);
            return;
        }            

        tmp2 = tmp;
        while (tmp2-tmp < cf.wTotalLength) {
            cd = (PUSB_COMMON_DESCRIPTOR) tmp2;
            DumpUSBDescriptor(tmp2);
            tmp2+=cd->bLength;
        }            
        
        free (tmp);        
    }    
#endif    
}    


VOID    
DumpConfigHandle(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_USBD_CONFIG_HANDLE";
    SIG s;
    MEMLOC cf, list;
    
    PrintfMemLoc("*USBD_CONFIG_HANDLE ", MemLoc, "\n");

    s.l = UsbReadFieldUlong(MemLoc, cs, "Sig");
    Sig(s.l, "");
    if (s.l != SIG_CONFIG_HANDLE) {
        BadSig(s.l, SIG_ENDPOINT);
        return;
    }

    cf = UsbReadFieldPtr(MemLoc, cs, "ConfigurationDescriptor");
    PrintfMemLoc("ConfigurationDescriptor ", cf, "\n");
 
    list = MemLoc + UsbFieldOffset(cs, 
            "InterfaceHandleList");

    DumpInterfaceHandleList(list);
}


DECLARE_API( _iso )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpIsoTransferContext (addr);

    return S_OK; 
}



DECLARE_API( _tt )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpTt (addr);

    return S_OK; 
}



DECLARE_API( _devh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpDeviceHandle (addr);

    return S_OK; 
}


DECLARE_API( _piph )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);

    DumpIPipe(addr);

    return S_OK; 
}


DECLARE_API( _endp )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpEndpoint(addr);

    return S_OK; 
}


DECLARE_API( _cmbf )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpCommonBuffer (memLoc, level);

    return S_OK; 
}


DECLARE_API( _tfer )

/*++

Routine Description:

   dumps transfer Context for usbport
Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpTransferContext(addr);

    return S_OK; 
}


DECLARE_API( _mdl )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpMdl (memLoc);

    return S_OK; 
}


DECLARE_API( _cfgh )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpConfigHandle(addr);

    return S_OK; 
}


DECLARE_API( _ifh )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpInterfaceHandle(addr);

    return S_OK; 
}


DECLARE_API( _descusb )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpUsbDescriptorMemLoc(memLoc);

    return S_OK; 
}


DECLARE_API( _desccfg )

/*++

Routine Description:

   dumps an MDL
   
Arguments:

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           level = 1;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%lx", &level);
    }

    DumpCfgDescriptorMemLoc(memLoc);

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\usbhcdkd.h ===
#include "usb.h"
#include "usbhcdi.h"

// include all bus interfaces
#include "usbbusif.h"
#include "hubbusif.h"

// inclulde ioctl defs for port drivers
#include "usbkern.h"
#include "usbuser.h"

#include "..\..\USB2LIB\usb2lib.h"
#include "..\usbport\dbg.h"
#include "..\usbport\usbport.h"

//#define DEBUGIT

typedef union _SIG {
    UCHAR c[4];
    ULONG l;
} SIG, *PSIG;    

typedef struct _FLAG_TABLE {
    PUCHAR Name;
    ULONG Mask;
} FLAG_TABLE, *PFLAG_TABLE;

#define GETMEMLOC(base, typ, field) \
    ((base) + FIELD_OFFSET(typ, field))


typedef ULONG64 MEMLOC, *PMEMLOC; 

typedef struct _STRUC_ENTRY {
    PUCHAR FieldName;
    ULONG FieldType;
} STRUC_ENTRY, *PSTRUC_ENTRY;

#define FT_ULONG        1
#define FT_UCHAR        2
#define FT_USHORT       3
#define FT_PTR          4
#define FT_SIG          5
#define FT_DEVSPEED     6 
#define FT_ULONG64      7 

ULONG
CheckSym();


#define CHECKSYM()\
    {\
    ULONG n;\
    if ((n=CheckSym()) != S_OK) {\
        return n;\
    }\
    }



VOID
UsbDumpStruc(
    MEMLOC MemLoc,
    PUCHAR Cs,
    PSTRUC_ENTRY FieldList,
    ULONG NumEntries
    );

CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    );

VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     );    

VOID
BadMemLoc(
    ULONG MemLoc
    );

VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    );
    
VOID    
DumpIPipe(
    MEMLOC MEmLoc
    );

PCHAR
ListEmpty(
    MEMLOC HeadMemLoc
    );

VOID
DumpPowerCaps(
    MEMLOC MemLoc
    );

VOID 
UsbDumpFlags(
    ULONG Flags,
    PFLAG_TABLE FlagTable,
    ULONG NumEntries
    );

VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    );

VOID    
DumpEndpointParameters(
    MEMLOC MemLoc
    );
    

VOID    
DumpUSBDescriptor(
    PVOID Descriptor
    );

VOID    
EpType(
    ENDPOINT_TRANSFER_TYPE Typ
    );    

VOID    
EpDir(
    ENDPOINT_TRANSFER_DIRECTION Dir
    );    

VOID
Sig(
    ULONG Sig,
    PUCHAR p
    );    

VOID    
DumpInterfaceInfo(
    MEMLOC MemLoc
    );

ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );        

UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );

USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    );    

VOID    
DumpEHCI_StaticQHs(
    MEMLOC MemLoc
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\usbehci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    WinDbg Extension Api
    implements !_ehcitd
               !_ehciqh
               !_ehciep

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbehci\ehci.h"
#include "..\miniport\usbehci\usbehci.h"
#include "usbhcdkd.h"

VOID
DumpEHCI_qTD(
    PHW_QUEUE_ELEMENT_TD qTd
    )
{
    ULONG i;

    dprintf("\t qTD\n");
    dprintf("\t Next_qTD: %08.8x\n", qTd->Next_qTD);
    dprintf("\t AltNext_qTD: %08.8x\n", qTd->AltNext_qTD);
    dprintf("\t Token: 0x%08.8x\n", qTd->Token.ul);

    dprintf("\t\t PingState: 0x%x\n", qTd->Token.PingState);
    dprintf("\t\t SplitXstate: 0x%x\n", qTd->Token.SplitXstate);
    dprintf("\t\t MissedMicroFrame: 0x%x\n", qTd->Token.MissedMicroFrame);
    dprintf("\t\t XactErr: 0x%x\n", qTd->Token.XactErr);
    dprintf("\t\t BabbleDetected: 0x%x\n", qTd->Token.BabbleDetected);
    dprintf("\t\t DataBufferError: 0x%x\n", qTd->Token.DataBufferError);

    dprintf("\t\t Halted: 0x%x\n", qTd->Token.Halted);
    dprintf("\t\t Active: 0x%x\n", qTd->Token.Active);
    dprintf("\t\t Pid: 0x%x - ", qTd->Token.Pid);
    switch(qTd->Token.Pid) {
    case HcTOK_Out:
        dprintf("HcTOK_Out\n");
        break;
    case HcTOK_In:
        dprintf("HcTOK_In\n");
        break;
    case HcTOK_Setup:
        dprintf("HcTOK_Setup\n");
        break;
    case HcTOK_Reserved:
        dprintf("HcTOK_Reserved\n");
        break;
    }
    dprintf("\t\t ErrorCounter: 0x%x\n", qTd->Token.ErrorCounter);
    dprintf("\t\t C_Page: 0x%x\n", qTd->Token.C_Page);
    dprintf("\t\t InterruptOnComplete: 0x%x\n", qTd->Token.InterruptOnComplete);
    dprintf("\t\t BytesToTransfer: 0x%x\n", qTd->Token.BytesToTransfer);
    dprintf("\t\t DataToggle: 0x%x\n", qTd->Token.DataToggle);


    for (i=0; i<5; i++) {
        dprintf("\t BufferPage[%d]: 0x %05.5x-%03.3x  %08.8x\n", i,
            qTd->BufferPage[i].BufferPointer,
            qTd->BufferPage[i].CurrentOffset,
            qTd->BufferPage[i].ul);
    }

}


VOID
DumpEHCI_Td(
    ULONG MemLoc
    )
{

    HCD_TRANSFER_DESCRIPTOR td;
    ULONG result;
    ULONG i;

    if (!ReadMemory (MemLoc, &td, sizeof(td), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    if (td.Sig != SIG_HCD_TD) {
        dprintf("%08.8x is not a TD\n", MemLoc);
    }
    dprintf("*USBEHCI TD %08.8x\n", MemLoc);
    Sig(td.Sig, "");
    DumpEHCI_qTD(&td.HwTD);
    dprintf("Packet:");
    for (i=0; i<8; i++) {
        dprintf("%02.2x ", td.Packet[i]);
    }
    dprintf("\n");
    dprintf("PhysicalAddress: %08.8x\n",td.PhysicalAddress);
    dprintf("EndpointData: %08.8x\n",td.EndpointData);
    dprintf("TransferLength : %08.8x\n", td.TransferLength);
    dprintf("TransferContext: %08.8x\n",td.TransferContext);
    dprintf("Flags: %08.8x\n",td.Flags);
    if (td.Flags & TD_FLAG_BUSY) {
        dprintf("\tTD_FLAG_BUSY\n");
    }
    if (td.Flags & TD_FLAG_XFER) {
        dprintf("\tTD_FLAG_XFER\n");
    }
    if (td.Flags & TD_FLAG_DONE) {
        dprintf("\tTD_FLAG_DONE\n");
    }
    if (td.Flags & TD_FLAG_SKIP) {
        dprintf("\tTD_FLAG_SKIP\n");
    }
    if (td.Flags & TD_FLAG_DUMMY) {
        dprintf("\tTD_FLAG_DUMMY\n");
    }
    dprintf("NextHcdTD: %08.8x\n",td.NextHcdTD);
    dprintf("AltNextHcdTD: %08.8x\n",td.AltNextHcdTD);
}


VOID
DumpEHCI_SiTd(
    ULONG MemLoc
    )
{
    UCHAR cs[] = "usbehci!_HCD_SI_TRANSFER_DESCRIPTOR";

    PrintfMemLoc("*USBEHCI ENDPOINT_DATA ", MemLoc, "\n");

    Sig(UsbReadFieldUlong(MemLoc, cs, "Sig"), "");
    dprintf("PhysicalAddress: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "PhysicalAddress"));
    dprintf("StartOffset: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "StartOffset"));
    PrintfMemLoc("Packet: ",
                 UsbReadFieldPtr(MemLoc, cs, "Packet"),
                 "\n");
    PrintfMemLoc("Transfer: ",
                 UsbReadFieldPtr(MemLoc, cs, "Transfer"),
                 "\n");
    PrintfMemLoc("NextLink: ",
                 UsbReadFieldPtr(MemLoc, cs, "NextLink"),
                 "\n");

    dprintf("HwTD.NextLink: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.NextLink"));
    dprintf("HwTD.Caps: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.Caps"));
    dprintf("HwTD.Control: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.Control"));
    dprintf("HwTD.State: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.BufferPointer0"));
    dprintf("HwTD.State: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.BufferPointer1"));
    dprintf("HwTD.BackPointer: 0x%08.8x\n",
        UsbReadFieldUlong(MemLoc, cs, "HwTD.BackPointer"));

   // PrintfMemLoc("StaticEd: ",
   //              UsbReadFieldPtr(MemLoc, cs, "StaticEd"),
   //              "\n");
}


VOID
DumpEHCI_iTd(
    MEMLOC MemLoc
    )
{
    HCD_HSISO_TRANSFER_DESCRIPTOR td;
    ULONG i, cb;
    ULONG flags;
    UCHAR s[64];
    UCHAR cs[] = "usbehci!_HCD_HSISO_TRANSFER_DESCRIPTOR";
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "HostFrame", FT_ULONG,
        "FirstPacket.Pointer", FT_PTR,
        "Transfer.Pointer", FT_PTR,
        "NextLink", FT_PTR,
        "ReservedMBNull", FT_PTR,
    };

    ReadMemory(MemLoc,
               &td,
               sizeof(td),
               &cb);

    if (td.Sig != SIG_HCD_ITD) {
        dprintf("not a iTD\n");
    }
    PrintfMemLoc("*USBEHCI iTD ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    dprintf("\t NextLink %08.8x\n", td.HwTD.NextLink.HwAddress);
    dprintf("\t (%08.8x)BufferPointer0 %08.8x\n", td.HwTD.BufferPointer0.ul,
        td.HwTD.BufferPointer0.BufferPointer);
    dprintf("\t\t Dev x%x Ept x%x\n", td.HwTD.BufferPointer0.DeviceAddress,
        td.HwTD.BufferPointer0.EndpointNumber);

    dprintf("\t (%08.8x)BufferPointer1 %08.8x\n", td.HwTD.BufferPointer1.ul,
        td.HwTD.BufferPointer1.BufferPointer);
    dprintf("\t\t MaxPacketSize x%x\n", td.HwTD.BufferPointer1.MaxPacketSize);

    dprintf("\t (%08.8x)BufferPointer2 %08.8x\n", td.HwTD.BufferPointer2.ul,
        td.HwTD.BufferPointer2.BufferPointer);
    dprintf("\t\t Multi x%x\n", td.HwTD.BufferPointer2.Multi);

    dprintf("\t (%08.8x)BufferPointer3 %08.8x\n", td.HwTD.BufferPointer3.ul,
        td.HwTD.BufferPointer3.BufferPointer);
    dprintf("\t (%08.8x)BufferPointer4 %08.8x\n", td.HwTD.BufferPointer4.ul,
        td.HwTD.BufferPointer4.BufferPointer);
    dprintf("\t (%08.8x)BufferPointer5 %08.8x\n", td.HwTD.BufferPointer5.ul,
        td.HwTD.BufferPointer5.BufferPointer);
    dprintf("\t (%08.8x)BufferPointer6 %08.8x\n", td.HwTD.BufferPointer6.ul,
        td.HwTD.BufferPointer6.BufferPointer);
    for (i=0; i<8; i++) {
        dprintf("\t Transaction[%d](%08.8x)\n",
            i, td.HwTD.Transaction[i].ul);
        dprintf("\t Transaction[%d].Offset %08.8x\n",
            i, td.HwTD.Transaction[i].Offset);
        dprintf("\t Transaction[%d].PageSelect %d\n",
            i, td.HwTD.Transaction[i].PageSelect);
        dprintf("\t Transaction[%d].Length %08.8x\n",
            i, td.HwTD.Transaction[i].Length);
         dprintf("\t\t active %d ioc %d - xerr:%d babble:%d dataerr:%d\n",
            td.HwTD.Transaction[i].Active,
            td.HwTD.Transaction[i].InterruptOnComplete,
            td.HwTD.Transaction[i].XactError,
            td.HwTD.Transaction[i].BabbleDetect,
            td.HwTD.Transaction[i].DataBufferError
            );
    }
}


VOID
DumpEHCI_StaticQh(
    MEMLOC MemLoc
    )
{
    ULONG f;
    FLAG_TABLE qhFlags[] = {
        "EHCI_QH_FLAG_IN_SCHEDULE", EHCI_QH_FLAG_IN_SCHEDULE,
        "EHCI_QH_FLAG_QH_REMOVED", EHCI_QH_FLAG_QH_REMOVED,
        "EHCI_QH_FLAG_STATIC", EHCI_QH_FLAG_STATIC,
        "EHCI_QH_FLAG_HIGHSPEED", EHCI_QH_FLAG_HIGHSPEED,
         };
    UCHAR cs[] = "_HCD_QUEUEHEAD_DESCRIPTOR";
    SIG s;

    PrintfMemLoc("*USBEHCI Static QH ", MemLoc, "\n");
    s.l = UsbReadFieldUlong(MemLoc, cs, "Sig");
    Sig(s.l, "");
    f = UsbReadFieldUlong(MemLoc, cs, "QhFlags");
    dprintf("Flags: %08.8x\n", f);
    UsbDumpFlags(f, qhFlags,
            sizeof(qhFlags)/sizeof(FLAG_TABLE));

    dprintf("\tPhysicalAddress: 0x%x\n",
         UsbReadFieldUlong(MemLoc, cs, "PhysicalAddress"));
    PrintfMemLoc("\tNextQh: ",
        UsbReadFieldPtr(MemLoc, cs, "NextQh"),
        "\n");
    PrintfMemLoc("\tPrevQh: ",
        UsbReadFieldPtr(MemLoc, cs, "PrevQh"),
        "\n");

    // now walk the regular queue heads
    MemLoc = UsbReadFieldPtr(MemLoc, cs, "NextQh");
    while (MemLoc) {
        PrintfMemLoc("\t\t: ",   MemLoc, " ");
        f = UsbReadFieldUlong(MemLoc, cs, "QhFlags");
        if (f & EHCI_QH_FLAG_STATIC) {
            dprintf("STATIC\n");
        } else {
            dprintf("\n");
        }
        MemLoc = UsbReadFieldPtr(MemLoc, cs, "NextQh");

    }
}

VOID
DumpEHCI_HwQh(
    MEMLOC MemLoc
    )
{
    HW_QUEUEHEAD_DESCRIPTOR hwQH;
    ULONG cb;

    ReadMemory(MemLoc,
               &hwQH,
               sizeof(hwQH),
               &cb);

    PrintfMemLoc("*HwQH ", MemLoc, "\n");

    dprintf("HwQH\n");

    dprintf("\t HwQH.HLink %08.8x\n", hwQH.HLink.HwAddress);

    dprintf("\t HwQH.EpChars %08.8x\n", hwQH.EpChars.ul);
    dprintf("\t\t DeviceAddress: 0x%x\n", hwQH.EpChars.DeviceAddress);
    dprintf("\t\t EndpointNumber: 0x%x\n", hwQH.EpChars.EndpointNumber);
    dprintf("\t\t EndpointSpeed: 0x%x", hwQH.EpChars.EndpointSpeed);

    switch(hwQH.EpChars.EndpointSpeed) {
    case HcEPCHAR_FullSpeed:
        dprintf("HcEPCHAR_FullSpeed");
        break;
    case HcEPCHAR_HighSpeed:
        dprintf("HcEPCHAR_HighSpeed");
        break;
    case HcEPCHAR_LowSpeed:
        dprintf("HcEPCHAR_LowSpeed");
        break;
    case HcEPCHAR_Reserved:
        dprintf("HcEPCHAR_Reserved");
        break;
    }
    dprintf("\n");

    dprintf("\t\t DataToggleControl: 0x%x\n", hwQH.EpChars.DataToggleControl);
    dprintf("\t\t HeadOfReclimationList: 0x%x\n", hwQH.EpChars.HeadOfReclimationList);
    dprintf("\t\t MaximumPacketLength: 0x%x - %d\n",
        hwQH.EpChars.MaximumPacketLength, hwQH.EpChars.MaximumPacketLength);
    dprintf("\t\t ControlEndpointFlag: %d\n", hwQH.EpChars.ControlEndpointFlag);
    dprintf("\t\t NakReloadCount: %d\n", hwQH.EpChars.NakReloadCount);

    dprintf("\t HwQH.EpCaps %08.8x\n", hwQH.EpCaps.ul);
    dprintf("\t\t InterruptScheduleMask: 0x%x\n", hwQH.EpCaps.InterruptScheduleMask);
    dprintf("\t\t SplitCompletionMask: 0x%x\n", hwQH.EpCaps.SplitCompletionMask);
    dprintf("\t\t HubAddress: 0x%x\n", hwQH.EpCaps.HubAddress);
    dprintf("\t\t PortNumber: 0x%x\n", hwQH.EpCaps.PortNumber);
    dprintf("\t\t HighBWPipeMultiplier: 0x%x\n", hwQH.EpCaps.HighBWPipeMultiplier);

    dprintf("\t HwQH.CurrentTD %08.8x\n", hwQH.CurrentTD.HwAddress);
    dprintf("\t HwQH.Overlay\n");
    DumpEHCI_qTD((PHW_QUEUE_ELEMENT_TD)&hwQH.Overlay);


}

VOID
DumpEHCI_Qh(
    MEMLOC MemLoc
    )
{

    UCHAR cs[] = "usbehci!_HCD_QUEUEHEAD_DESCRIPTOR";
    ULONG f, s;
    STRUC_ENTRY t[] = {
              "PhysicalAddress", FT_ULONG,
              "Sig", FT_ULONG,
              "QhFlags", FT_ULONG,
              "Ordinal", FT_ULONG,
              "Period", FT_ULONG,
              "Reserved", FT_ULONG,
              "EndpointData", FT_PTR,
              "NextQh", FT_PTR,
              "PrevQh", FT_PTR,
              "NextLink", FT_PTR
    };
    FLAG_TABLE qhFlags[] = {
        "EHCI_QH_FLAG_IN_SCHEDULE", EHCI_QH_FLAG_IN_SCHEDULE,
        "EHCI_QH_FLAG_QH_REMOVED", EHCI_QH_FLAG_QH_REMOVED,
        "EHCI_QH_FLAG_STATIC", EHCI_QH_FLAG_STATIC,
        "EHCI_QH_FLAG_HIGHSPEED", EHCI_QH_FLAG_HIGHSPEED,
         };

    s = UsbReadFieldUlong(MemLoc, cs, "Sig");
    f = UsbReadFieldUlong(MemLoc, cs, "Flags");

    if (s != SIG_HCD_AQH &&
        s != SIG_HCD_QH) {
    }

    PrintfMemLoc("*USBEHCI QH ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    UsbDumpFlags(f, qhFlags,
            sizeof(qhFlags)/sizeof(FLAG_TABLE));

    DumpEHCI_HwQh(MemLoc);
}


VOID
DumpEHCI_EndpointData(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_ENDPOINT_DATA";
    UCHAR ts[] = "usbehci!_HCD_TRANSFER_DESCRIPTOR";
    ULONG f, i=0;
    MEMLOC head, tail, m;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "QueueHead", FT_PTR,
        "PendingTransfers", FT_ULONG,
        "MaxPendingTransfers", FT_ULONG,
        "HcdTailP", FT_PTR,
        "HcdHeadP", FT_PTR,
        "StaticQH", FT_PTR,
        "PeriodTableEntry", FT_PTR,
        "TdList", FT_PTR,
        "SiTdList", FT_PTR,
        "HsIsoTdList", FT_PTR,
        "TdCount", FT_ULONG,
        "PrevEndpoint", FT_PTR,
        "NextEndpoint", FT_PTR,
        "DummyTd", FT_PTR,
        "LastFrame", FT_ULONG,
        "TransferList.Flink", FT_PTR,
        "TransferList.Blink", FT_PTR,
        //"MaxErrorCount", FT_ULONG,
    };
    FLAG_TABLE epFlags[] = {
        "EHCI_EDFLAG_HALTED", EHCI_EDFLAG_HALTED,
        "EHCI_EDFLAG_NOHALT", EHCI_EDFLAG_NOHALT
         };

    PrintfMemLoc("*USBEHCI ENDPOINT_DATA ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
    dprintf("Flags: 0x%08.8x\n", f);
    UsbDumpFlags(f, epFlags,
            sizeof(epFlags)/sizeof(FLAG_TABLE));

    DumpEndpointParameters(MemLoc + UsbFieldOffset(cs, "Parameters"));

    // dump the transfers
    head = UsbReadFieldPtr(MemLoc, cs, "HcdHeadP");
    tail = UsbReadFieldPtr(MemLoc, cs, "HcdTailP");
    PrintfMemLoc("<HEAD> ", head, "\n");
    while (head != tail && i<32) {
        i++;
        dprintf("\t TD ");
        PrintfMemLoc("", head, " ");

        dprintf ("[%08.8x] ",
            UsbReadFieldUlong(head, ts, "PhysicalAddress"));

        m = UsbReadFieldPtr(head, ts, "TransferContext");
        PrintfMemLoc("XFER ", m, "\n");

        head = UsbReadFieldPtr(head, ts, "NextHcdTD");
    }
    PrintfMemLoc("<TAIL> ", tail, "\n");

}


VOID
DumpEHCI_DumpTfer(
    ULONG MemLoc
    )
{

    TRANSFER_CONTEXT tc;
    ULONG result;
    SIG s;

    if (!ReadMemory (MemLoc, &tc, sizeof(tc), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    if (tc.Sig != SIG_EHCI_TRANSFER) {
        dprintf("%08.8x is not TRANSFER_CONTEXT\n", MemLoc);
    }

    Sig(tc.Sig, "");
    dprintf("PendingTds: 0x%08.8x\n", tc.PendingTds);
    dprintf("TransferParameters: 0x%08.8x\n", tc.TransferParameters);
    dprintf("UsbdStatus: 0x%08.8x\n", tc.UsbdStatus);
    dprintf("BytesTransferred: 0x%08.8x\n", tc.BytesTransferred);
    dprintf("XactErrCounter: %d\n", tc.XactErrCounter);
    dprintf("EndpointData: 0x%08.8x\n", tc.EndpointData);
}


VOID
DumpEHCI_DeviceData(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_DEVICE_DATA";
    ULONG f;
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "OperationalRegisters", FT_PTR,
        "CapabilitiesRegisters", FT_PTR,
        "EnabledInterrupts", FT_ULONG,
        "AsyncQueueHead", FT_PTR,
        "ControllerFlavor", FT_ULONG,
        "FrameNumberHighPart", FT_ULONG,
        "PortResetChange", FT_ULONG,
        "PortSuspendChange", FT_ULONG,
        "PortConnectChange", FT_ULONG,
        "IrqStatus", FT_ULONG,
        "NumberOfPorts", FT_USHORT,
        "PortPowerControl", FT_USHORT,
        "HighSpeedDeviceAttached", FT_ULONG,
        "FrameListBaseAddress", FT_PTR,
        "FrameListBasePhys", FT_ULONG,
        "IsoEndpointListHead", FT_PTR,
        "DummyQueueHeads", FT_PTR
    };
//    FLAG_TABLE ddFlags[] = {
//        "EHCI_DD_FLAG_NOCHIRP", EHCI_DD_FLAG_NOCHIRP,
//        "EHCI_DD_FLAG_SOFT_ERROR_RETRY", EHCI_DD_FLAG_SOFT_ERROR_RETRY
//         };

    PrintfMemLoc("*USBEHCI DEVICE DATA ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "Flags");
//    dprintf("Flags: 0x%08.8x\n", f);
//    UsbDumpFlags(f, ddFlags,
//            sizeof(ddFlags)/sizeof(FLAG_TABLE));

    DumpEHCI_StaticQHs(MemLoc);

}


VOID
DumpEHCI_StaticQHs(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbehci!_DEVICE_DATA";
    ULONG i;
    MEMLOC m;
    UCHAR s[64];
    UCHAR t[64];

    ULONG p[65] = {
      1, 2, 2, 4, 4, 4, 4, 8,
      8, 8, 8, 8, 8, 8, 8,16,
     16,16,16,16,16,16,16,16,
     16,16,16,16,16,16,16,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,32,
     32,32,32,32,32,32,32,0,0};

    for (i=0; i< 65; i++) {
        sprintf(s, "StaticQH[%d] (%d):", i, p[i]);
        sprintf(t, "StaticInterruptQH[%x]", i);
        m = UsbReadFieldPtr(MemLoc, cs, t);
        PrintfMemLoc(s, m, "\n");
    }
}


VOID
DumpEHCI_Frame(
    MEMLOC MemLoc,
    ULONG fn
    )
{
    MEMLOC m, t, frame;
    UCHAR qhs[] = "usbehci!_HCD_QUEUEHEAD_DESCRIPTOR";
    UCHAR cs[] = "usbehci!_DEVICE_DATA";
    UCHAR itds[] = "_HCD_HSISO_TRANSFER_DESCRIPTOR";
    UCHAR sitds[] = "_HCD_SI_TRANSFER_DESCRIPTOR";
    ULONG s, i;

    m = UsbReadFieldPtr(MemLoc, cs, "DummyQueueHeads");
    m = m+fn*sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    frame = UsbReadFieldPtr(MemLoc, cs, "FrameListBaseAddress");
    frame = frame+fn*4;

    PrintfMemLoc("Frame @", frame, "\n");

    // first element should be dummy QH
    PrintfMemLoc("dummy QH @", m, "\n");
    s = UsbReadFieldUlong(m, qhs, "Sig");
    Sig(s, "");
    dprintf("Phys: 0x%08.8x\n",
       UsbReadFieldUlong(m, qhs, "PhysicalAddress"));
    dprintf("\tNextPhys-> 0x%08.8x\n",
               UsbReadFieldUlong(m, qhs, "HwQH.HLink.HwAddress"));
    m = UsbReadFieldPtr(m, qhs, "NextLink");
    PrintfMemLoc("\tNextLink->", m, "\n");

    i= 0;
    while (m && i< 30) {
        i++;
        s = UsbReadFieldUlong(m, qhs, "Sig");
        // queue head?
        if (s==SIG_HCD_QH) {
            PrintfMemLoc("interrupt QH @", m, "\n");
            Sig(s, "");
            dprintf("Phys: 0x%08.8x\n",
               UsbReadFieldUlong(m, qhs, "PhysicalAddress"));
            dprintf("Period: %d\n",
               UsbReadFieldUlong(m, qhs, "Period"));
            dprintf("\tNextPhys-> 0x%08.8x\n",
               UsbReadFieldUlong(m, qhs, "HwQH.HLink.HwAddress"));
            m = UsbReadFieldPtr(m, qhs, "NextLink");
            PrintfMemLoc("\tNextLink->", m, "\n");

            continue;
        }

        if (s==SIG_HCD_IQH) {
            PrintfMemLoc("static interrupt IQH @", m, "\n");
            Sig(s, "");
            dprintf("Phys: 0x%08.8x\n",
               UsbReadFieldUlong(m, qhs, "PhysicalAddress"));
            dprintf("Period: %d\n",
               UsbReadFieldUlong(m, qhs, "Period"));

            dprintf("\tNextPhys-> 0x%08.8x\n",
               UsbReadFieldUlong(m, qhs, "HwQH.HLink.HwAddress"));

            m = UsbReadFieldPtr(m, qhs, "NextLink");
            PrintfMemLoc("\tNextLink->", m, "\n");

            continue;
        }

        s = UsbReadFieldUlong(m, itds, "Sig");
        if (s==SIG_HCD_ITD) {
            PrintfMemLoc("hs iso ITD @", m, "\n");
            Sig(s, "");
            dprintf("Phys: 0x%08.8x\n",
               UsbReadFieldUlong(m, itds, "PhysicalAddress"));
            dprintf("\tNextPhys-> 0x%08.8x\n",
               UsbReadFieldUlong(m, itds, "HwTD.NextLink.HwAddress"));

            m = UsbReadFieldPtr(m, itds, "NextLink");
            PrintfMemLoc("\tNextLink->", m, "\n");

            continue;
        }

        s = UsbReadFieldUlong(m, sitds, "Sig");
        if (s==SIG_HCD_SITD) {
            PrintfMemLoc("iso SITD @", m, "\n");
            Sig(s, "");
            dprintf("Phys: 0x%08.8x\n",
               UsbReadFieldUlong(m, sitds, "PhysicalAddress"));
            dprintf("\tNextPhys-> 0x%08.8x\n",
               UsbReadFieldUlong(m, sitds, "HwTD.NextLink.HwAddress"));

            m = UsbReadFieldPtr(m, sitds, "NextLink");
            PrintfMemLoc("\tNextLink->", m, "\n");

            continue;
        }

        break;
    }

}


VOID
DumpEHCI_OpRegs(
    MEMLOC MemLoc,
    ULONG NumPorts
    )
{

    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    USBSTS sts;
    ULONG l, i;
    USBINTR irqE;
    ULONG cb;

    l = sizeof(HC_OPERATIONAL_REGISTER) + sizeof(PORTSC) * NumPorts;
    hcOp = malloc(l);

    if (!hcOp) {
        return;
    }

    ReadMemory(MemLoc,
               hcOp,
               l,
               &cb);

    PrintfMemLoc("*(ehci)HC_OPERATIONAL_REGISTER ", MemLoc, "\n");

    cmd = hcOp->UsbCommand;
    dprintf("\tUSBCMD %08.8x\n" , cmd.ul);
    dprintf("\t.HostControllerRun: %d\n", cmd.HostControllerRun);
    dprintf("\t.HostControllerReset: %d\n", cmd.HostControllerReset);
    dprintf("\t.FrameListSize: %d\n", cmd.FrameListSize);
    dprintf("\t.PeriodicScheduleEnable: %d\n", cmd.PeriodicScheduleEnable);
    dprintf("\t.AsyncScheduleEnable: %d\n", cmd.AsyncScheduleEnable);
    dprintf("\t.IntOnAsyncAdvanceDoorbell: %d\n", cmd.IntOnAsyncAdvanceDoorbell);
    dprintf("\t.HostControllerLightReset: %d\n", cmd.HostControllerLightReset);
    dprintf("\t.InterruptThreshold: %d\n", cmd.InterruptThreshold);
    dprintf("\n");

    sts = hcOp->UsbStatus;
    dprintf("\tUSBSTS %08.8x\n" , sts.ul);
    dprintf("\t.UsbInterrupt: %d\n", sts.UsbInterrupt);
    dprintf("\t.UsbError: %d\n", sts.UsbError);
    dprintf("\t.PortChangeDetect: %d\n", sts.PortChangeDetect);
    dprintf("\t.FrameListRollover: %d\n", sts.FrameListRollover);
    dprintf("\t.HostSystemError: %d\n", sts.HostSystemError);
    dprintf("\t.IntOnAsyncAdvance: %d\n", sts.IntOnAsyncAdvance);
    dprintf("\t----\n");
    dprintf("\t.HcHalted: %d\n", sts.HcHalted);
    dprintf("\t.Reclimation: %d\n", sts.Reclimation);
    dprintf("\t.PeriodicScheduleStatus: %d\n", sts.PeriodicScheduleStatus);
    dprintf("\t.AsyncScheduleStatus: %d\n", sts.AsyncScheduleStatus);
    dprintf("\n");

    irqE = hcOp->UsbInterruptEnable;
    dprintf("\tUSBINTR %08.8x\n" , irqE.ul);
    dprintf("\t.UsbInterrupt: %d\n", irqE.UsbInterrupt);
    dprintf("\t.UsbError: %d\n", irqE.UsbError);
    dprintf("\t.PortChangeDetect: %d\n", irqE.PortChangeDetect);
    dprintf("\t.FrameListRollover: %d\n", irqE.FrameListRollover);
    dprintf("\t.HostSystemError: %d\n", irqE.HostSystemError);
    dprintf("\t.IntOnAsyncAdvance: %d\n", irqE.IntOnAsyncAdvance);

    dprintf("\tPeriodicListBase %08.8x\n" , hcOp->PeriodicListBase);
    dprintf("\tAsyncListAddr %08.8x\n" , hcOp->AsyncListAddr);

    for (i=0; i<NumPorts; i++) {
        PORTSC p;

        p.ul = hcOp->PortRegister[i].ul;

        dprintf("\tPortSC[%d] %08.8x\n", i, p.ul);
        dprintf("\t\tPortConnect x%x\n", p.PortConnect);
        dprintf("\t\tPortConnectChange x%x\n", p.PortConnectChange);
        dprintf("\t\tPortEnable x%x\n", p.PortEnable);
        dprintf("\t\tPortEnableChange x%x\n", p.PortEnableChange);
        dprintf("\t\tOvercurrentActive x%x\n", p.OvercurrentActive);
        dprintf("\t\tOvercurrentChange x%x\n", p.OvercurrentChange);
        dprintf("\t\tForcePortResume x%x\n", p.ForcePortResume);
        dprintf("\t\tPortSuspend x%x\n", p.PortSuspend);
        dprintf("\t\tPortReset x%x\n", p.PortReset);
        dprintf("\t\tHighSpeedDevice x%x\n", p.HighSpeedDevice);
        dprintf("\t\tLineStatus x%x\n", p.LineStatus);
        dprintf("\t\tPortPower x%x\n", p.PortPower);
        dprintf("\t\tPortOwnedByCC x%x\n", p.PortOwnedByCC);
        dprintf("\t\tPortIndicator x%x\n", p.PortIndicator);
        dprintf("\t\tPortTestControl x%x\n", p.PortTestControl);
        dprintf("\t\tWakeOnConnect x%x\n", p.WakeOnConnect);
        dprintf("\t\tWakeOnDisconnect x%x\n", p.WakeOnDisconnect);
        dprintf("\t\tWakeOnOvercurrent x%x\n", p.WakeOnOvercurrent);
    }
    free(hcOp);

}



DECLARE_API( _ehcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpEHCI_DeviceData(addr);

    return S_OK;
}

DECLARE_API( _ehciitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{

    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpEHCI_iTd (addr);

    return S_OK;
}


DECLARE_API( _ehcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_Td (memLoc);

    return S_OK;
}


DECLARE_API( _ehcisitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_SiTd (memLoc);

    return S_OK;
}


DECLARE_API( _ehciqh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpEHCI_Qh(addr);

    return S_OK;
}


DECLARE_API( _ehcistq )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpEHCI_StaticQh(addr);

    return S_OK;
}


DECLARE_API( _ehciep )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpEHCI_EndpointData (addr);

    return S_OK;
}


DECLARE_API( _ehcitfer )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpEHCI_DumpTfer(memLoc);

    return S_OK;
}


DECLARE_API( _ehciregs )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    ULONG parm = 0;

    GetExpressionEx( args, &addr, &s );

    if (s[0] != '\0') {
        sscanf(s, ",%d", &parm);
    }

    DumpEHCI_OpRegs(addr, parm);

    return S_OK;
}


DECLARE_API( _ehciframe )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC addr;
    PCSTR s;
    ULONG parm = 0;

    GetExpressionEx( args, &addr, &s );

    if (s[0] != '\0') {
        sscanf(s, ",%d", &parm);
    }

    DumpEHCI_Frame(addr, parm);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Chris Robinson (crobins) Feburary 1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "usbhcdkd.h"


VOID    
DumpUSBDescriptor(
    PVOID Descriptor
    )
{
    PUSB_DEVICE_DESCRIPTOR dd = Descriptor;
    PUSB_COMMON_DESCRIPTOR cd = Descriptor;
    PUSB_INTERFACE_DESCRIPTOR id = Descriptor;
    PUSB_CONFIGURATION_DESCRIPTOR cf = Descriptor;
    PUSB_ENDPOINT_DESCRIPTOR ed = Descriptor;

    switch (cd->bDescriptorType) {
    case USB_CONFIGURATION_DESCRIPTOR_TYPE:
        dprintf("[CONFIGURATION DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", cf->bLength);
        dprintf("bDescriptorType 0x%x\n", cf->bDescriptorType);
        dprintf("wTotalLength 0x%x (%d)\n", cf->wTotalLength, cf->wTotalLength);
        dprintf("bNumInterfaces 0x%x\n", cf->bNumInterfaces);
        dprintf("bConfigurationValue 0x%x\n", cf->bConfigurationValue);
        dprintf("iConfiguration 0x%x\n", cf->iConfiguration);
        dprintf("bmAttributes 0x%x\n", cf->bmAttributes);
        dprintf("MaxPower 0x%x (%d)\n", cf->MaxPower, cf->MaxPower);
        break;
        
    case USB_INTERFACE_DESCRIPTOR_TYPE:
        dprintf("[INTERFACE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", id->bLength);
        dprintf("bDescriptorType 0x%x\n", id->bDescriptorType);
        dprintf("bInterfaceNumber 0x%x\n", id->bInterfaceNumber);
        dprintf("bAlternateSetting 0x%x\n", id->bAlternateSetting);
        dprintf("bNumEndpoints 0x%x\n", id->bNumEndpoints);
        dprintf("bInterfaceClass 0x%x\n", id->bInterfaceClass);
        dprintf("bInterfaceSubClass 0x%x\n", id->bInterfaceSubClass);
        dprintf("bInterfaceProtocol 0x%x\n", id->bInterfaceProtocol);
        dprintf("iInterface 0x%x\n", id->iInterface);
        break;
                    
    case USB_DEVICE_DESCRIPTOR_TYPE:
        dprintf("[DEVICE DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", dd->bLength);
        dprintf("bDescriptorType 0x%x\n", dd->bDescriptorType);
        dprintf("bcdUSB 0x%x\n", dd->bcdUSB);
        dprintf("bDeviceClass 0x%x\n", dd->bDeviceClass);
        dprintf("bDeviceSubClass 0x%x\n", dd->bDeviceSubClass); 
        dprintf("bDeviceProtocol 0x%x\n", dd->bDeviceProtocol);
        dprintf("bMaxPacketSize0 0x%x\n", dd->bMaxPacketSize0);
        dprintf("idVendor 0x%x\n", dd->idVendor);
        dprintf("idProduct 0x%x\n", dd->idProduct);
        dprintf("bcdDevice 0x%x\n", dd->bcdDevice);
        dprintf("iManufacturer 0x%x\n", dd->iManufacturer);
        dprintf("iProduct 0x%x\n", dd->iProduct);
        dprintf("iSerialNumber 0x%x\n", dd->iSerialNumber);
        dprintf("bNumConfigurations 0x%x\n", dd->bNumConfigurations);
        break;
    case USB_ENDPOINT_DESCRIPTOR_TYPE:
        dprintf("[ENDPOINT DESCRIPTOR]\n");
        dprintf("bLength 0x%x\n", ed->bLength);
        dprintf("bDescriptorType 0x%x\n", ed->bDescriptorType);
        dprintf("bEndpointAddress 0x%x\n", ed->bEndpointAddress);
        dprintf("bmAttributes 0x%x\n", ed->bmAttributes);
        dprintf("wMaxPacketSize 0x%x\n", ed->wMaxPacketSize);
        dprintf("bInterval 0x%x\n", ed->bInterval);
        break;
        
    default:        
        dprintf("[DESCRIPTOR ???]\n");
    }   
    
}


VOID
DumpUnicodeString(
    UNICODE_STRING uniString
    )
{

       
    dprintf(">> Buffer: %08.8x, Length %d\n", 
        uniString.Buffer, uniString.Length);                    

}    


VOID
Sig(
    ULONG Sig,
    PUCHAR p
    )
{
    SIG s;
    
    dprintf(p);
    s.l = Sig;
    dprintf("Sig:%08.8x %c%c%c%c\n", Sig,
            s.c[0],  s.c[1],  s.c[2], s.c[3]); 

}      


CPPMOD
ScanfMemLoc(
    PMEMLOC MemLoc,
    PCSTR args
    )
{
//    UCHAR           buffer[256];
    ULONG tmp1 = 0, tmp2 = 0;

    //buffer[0] = '\0';

    if (IsPtr64()) {
        //sscanf(args, "%lx %lx", &MemLoc->p64, buffer);
    } else {
        sscanf(args, "%lx %lx", &tmp1, &tmp2);
        *MemLoc = (ULONG64) tmp1;             
        dprintf("tmp1 = %x tmp2 = %x\n", tmp1, tmp2);
    }
}          


VOID
PrintfMemLoc(
     PUCHAR Str1,
     MEMLOC MemLoc,
     PUCHAR Str2
     )
{
    if (IsPtr64()) {   
        ULONG tmp = (ULONG) MemLoc;
        ULONG tmp1 = (ULONG) (MemLoc>>32); 
#ifdef DEBUGIT          
        dprintf("%s%08.8x%08.8x (64)%s", Str1, tmp1, tmp, Str2); 
#else
        dprintf("%s%08.8x%08.8x %s", Str1, tmp1, tmp, Str2); 
#endif
    } else {
        ULONG tmp = (ULONG) MemLoc;
#ifdef DEBUGIT          
        dprintf("%s%08.8x (32)%s", Str1, tmp, Str2); 
#else   
        dprintf("%s%08.8x %s", Str1, tmp, Str2);
#endif        
    }
}


VOID
BadMemLoc(
    ULONG MemLoc
    )
{
    dprintf("could not read mem location %08.8x\n", MemLoc);
}     


VOID
BadSig(
    ULONG Sig,
    ULONG ExpectedSig
    )
{
    dprintf("Bad Structure Signature %08.8x\n", Sig);
}     


VOID 
UsbDumpFlags(
    ULONG Flags,
    PFLAG_TABLE FlagTable,
    ULONG NumEntries
    )
{
    ULONG i;
    PFLAG_TABLE ft = FlagTable;
    
    for (i=0; i< NumEntries; i++) {
        if (ft->Mask & Flags) {
            dprintf ("\t> %s\n", ft->Name);
        }
        ft++;
    }
}


ULONG
UsbFieldOffset(
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG offset;
    ULONG r;

    r = GetFieldOffset(Type, Field, &offset);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x offset %x>", r, offset);
#endif     

    return offset;
}


MEMLOC
UsbReadFieldPtr(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    MEMLOC p;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, p);
#ifdef DEBUGIT      
    dprintf("<UsbReadFieldPtr %x>", r);
#endif    
    return p;
}


UCHAR
UsbReadFieldUchar(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    UCHAR ch;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, ch);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUchar %x>", r);
#endif      
    return ch;
}


ULONG
UsbReadFieldUlong(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    ULONG l;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, l);
#ifdef DEBUGIT     
    dprintf("<UsbReadFieldUlong %x>", r);
#endif    
    return l;
}


USHORT
UsbReadFieldUshort(
    IN ULONG64   Addr,
    IN LPSTR     Type,
    IN LPSTR     Field
    )
{
    USHORT s;
    ULONG r;

    r = GetFieldValue(Addr, Type, Field, s);
#ifdef DEBUGIT    
    dprintf("<UsbReadFieldUshort %x>", r);
#endif    
    return s;
}

VOID
UsbDumpStruc(
    MEMLOC MemLoc,
    PUCHAR Cs,
    PSTRUC_ENTRY FieldList,
    ULONG NumEntries
    )
{
    ULONG i, l;
    UCHAR s[80];
    SIG sig;

    for (i=0; i< NumEntries; i++) {
        switch (FieldList->FieldType) {
        case FT_ULONG:
            dprintf("%s: 0x%08.8x\n",
                FieldList->FieldName,
                UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_UCHAR:
            dprintf("%s: 0x%02.2x\n",
                FieldList->FieldName,
                UsbReadFieldUchar(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_USHORT:
            dprintf("%s: 0x%04.4x\n",
                FieldList->FieldName,
                UsbReadFieldUshort(MemLoc, Cs, FieldList->FieldName));
            break;
        case FT_PTR:
            sprintf(s, "%s: ", FieldList->FieldName);
            PrintfMemLoc(s, 
            UsbReadFieldPtr(MemLoc, Cs, FieldList->FieldName),
            "\n");
            break;
        case FT_SIG:
            sig.l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            Sig(sig.l, "");
            break;
        case FT_DEVSPEED:
            l = UsbReadFieldUlong(MemLoc, Cs, FieldList->FieldName);
            dprintf("%s: ",
                FieldList->FieldName);
            switch (l) {
            case UsbLowSpeed:
                dprintf("UsbLowSpeed\n");
                break;
            case UsbFullSpeed:
                dprintf("UsbFullSpeed\n");
                break;
            case UsbHighSpeed:
                dprintf("UsbHighSpeed\n");
                break;            
            }
            break;
        }       
        FieldList++;
    }
    
}

ULONG
CheckSym() 
{
    MEMLOC m;
    
    //
    // Verify that we have the right symbols.
    //

    m = GetExpression ("usbport!USBPORT_MiniportDriverList");

    if (m == 0) {

        dprintf ("Incorrect symbols for USBPORT\n");
        return E_INVALIDARG;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\urb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    urb.c

Abstract:

    WinDbg Extension Api
    implements !_urb


Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usbhcdkd.h"


PUCHAR
UsbdFunctionName(
    USHORT Function
    )
{
    switch(Function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:
        return "URB_FUNCTION_SELECT_CONFIGURATION";
    case URB_FUNCTION_SELECT_INTERFACE:
        return "URB_FUNCTION_SELECT_INTERFACE";
    case URB_FUNCTION_ABORT_PIPE:
        return "URB_FUNCTION_ABORT_PIPE";
    case URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL:
        return "URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL";
    case URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL:
        return "URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL";
    case URB_FUNCTION_GET_FRAME_LENGTH:
        return "URB_FUNCTION_GET_FRAME_LENGTH";
    case URB_FUNCTION_SET_FRAME_LENGTH:
        return "URB_FUNCTION_SET_FRAME_LENGTH";
    case URB_FUNCTION_GET_CURRENT_FRAME_NUMBER  :
        return "URB_FUNCTION_GET_CURRENT_FRAME_NUMBER";
    case URB_FUNCTION_CONTROL_TRANSFER:
        return "URB_FUNCTION_CONTROL_TRANSFER";
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        return "URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER";
    case URB_FUNCTION_ISOCH_TRANSFER:
        return "URB_FUNCTION_ISOCH_TRANSFER";
    case URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL:
        return "URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT";
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
        return "URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE";
    case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE";
    case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT";
    case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
        return "URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE";
    case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
        return "URB_FUNCTION_SET_FEATURE_TO_DEVICE";
    case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
        return "URB_FUNCTION_SET_FEATURE_TO_INTERFACE";
    case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
        return "URB_FUNCTION_SET_FEATURE_TO_ENDPOINT";
    case URB_FUNCTION_SET_FEATURE_TO_OTHER:
        return "URB_FUNCTION_SET_FEATURE_TO_OTHER";
    case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE";
    case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE";
    case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT";
    case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
        return "URB_FUNCTION_CLEAR_FEATURE_TO_OTHER";
    case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
        return "URB_FUNCTION_GET_STATUS_FROM_DEVICE";
    case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
        return "URB_FUNCTION_GET_STATUS_FROM_INTERFACE";
    case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
        return "URB_FUNCTION_GET_STATUS_FROM_ENDPOINT";
    case URB_FUNCTION_GET_STATUS_FROM_OTHER:
        return "URB_FUNCTION_GET_STATUS_FROM_OTHER";
    case URB_FUNCTION_VENDOR_DEVICE:
        return "URB_FUNCTION_VENDOR_DEVICE";
    case URB_FUNCTION_VENDOR_INTERFACE:
        return "URB_FUNCTION_VENDOR_INTERFACE";
    case URB_FUNCTION_VENDOR_ENDPOINT:
        return "URB_FUNCTION_VENDOR_ENDPOINT";
    case URB_FUNCTION_VENDOR_OTHER:
        return "URB_FUNCTION_VENDOR_OTHER";
    case URB_FUNCTION_CLASS_DEVICE:
        return "URB_FUNCTION_CLASS_DEVICE";
    case URB_FUNCTION_CLASS_INTERFACE:
        return "URB_FUNCTION_CLASS_INTERFACE";
    case URB_FUNCTION_CLASS_ENDPOINT:
        return "URB_FUNCTION_CLASS_ENDPOINT";
    case URB_FUNCTION_CLASS_OTHER:
        return "URB_FUNCTION_CLASS_OTHER";
    case URB_FUNCTION_GET_CONFIGURATION:
        return "URB_FUNCTION_GET_CONFIGURATION";
    case URB_FUNCTION_GET_INTERFACE:
        return "URB_FUNCTION_GET_INTERFACE";
    }

    return "???";
}


VOID
DumpPipeRequest(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_URB_PIPE_REQUEST";
    STRUC_ENTRY ap[] = {
        "PipeHandle", FT_PTR,
        "Reserved", FT_ULONG,
    };

    UsbDumpStruc(MemLoc, cs,
        &ap[0], sizeof(ap)/sizeof(STRUC_ENTRY));
}


VOID
DumpControlTransfer(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_TRANSFER_URB";
    ULONG f;
    PUSB_DEFAULT_PIPE_SETUP_PACKET setup;
    USB_DEFAULT_PIPE_SETUP_PACKET tmp;
    PUCHAR s;
    PUCHAR Dir_String[2] = {"HOST_TO_DEVICE",
                            "DEVICE_TO_HOST"};
    PUCHAR Type_String[3] = {"STANDARD",
                             "CLASS",
                             "VENDOR"};

    PUCHAR Recipient_String[3] = {"DEVICE",
                                  "INTERFACE",
                                  "ENDPOINT"};

#define MAX_BREQ  13
    PUCHAR bReq_String[MAX_BREQ] = {
                "USB_REQUEST_GET_STATUS",       // 0
                "USB_REQUEST_CLEAR_FEATURE",    // 1
                "",                             // 2
                "USB_REQUEST_SET_FEATURE",      // 3
                "",                             // 4
                "USB_REQUEST_SET_ADDRESS",      // 5
                "USB_REQUEST_GET_DESCRIPTOR",   // 6
                "USB_REQUEST_SET_DESCRIPTOR",   // 7
                "USB_REQUEST_GET_CONFIGURATION",// 8
                "USB_REQUEST_SET_CONFIGURATION",// 9
                "USB_REQUEST_GET_INTERFACE",    // 10
                "USB_REQUEST_SET_INTERFACE",    // 11
                "USB_REQUEST_SYNC_FRAME"        // 12
                };


    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ResevedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR,
    };


    dprintf("*CONTROL TRANSFER\n");

    f = UsbReadFieldUlong(MemLoc, cs, "TransferFlags");
    dprintf("TransferFlags: %08.8x\n", f);
    UsbDumpFlags(f, xferFlags,
        sizeof(xferFlags)/sizeof(FLAG_TABLE));
    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));



    {
    ULONG64 addr;
    ULONG cb;

    addr = MemLoc + UsbFieldOffset(cs,
            "u.SetupPacket");

    ReadMemory(addr,
               &tmp,
               sizeof(tmp),
               &cb);
    }

    setup = (PUSB_DEFAULT_PIPE_SETUP_PACKET) &tmp;
    s = (PUCHAR) setup;

    dprintf(
        "<SetupPacket> %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x %02.2x\n",
        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
    dprintf("bmRequestType (%02.2x)\n", setup->bmRequestType.B);
    dprintf("\tRecipient %d - %s\n", setup->bmRequestType.Recipient,
        Recipient_String[setup->bmRequestType.Recipient]);
    dprintf("\tType %d - %s\n", setup->bmRequestType.Type,
        Type_String[setup->bmRequestType.Type]);
    dprintf("\tDir %d - %s\n", setup->bmRequestType.Dir,
        Dir_String[setup->bmRequestType.Dir]);
    dprintf("\tReserved %d\n", setup->bmRequestType.Reserved);
    dprintf("bRequest %d  ", setup->bRequest);
    if (setup->bmRequestType.Type == 0 && setup->bRequest < MAX_BREQ) {
        dprintf("%s\n", bReq_String[setup->bRequest]);
    } else {
        dprintf("\n");
    }
    dprintf("wValue 0x%04.4x (LowByte %02.2x HiByte %02.2x)\n", setup->wValue.W,
        setup->wValue.LowByte, setup->wValue.HiByte);
    dprintf("wIndex 0x%04.4x\n", setup->wIndex);
    dprintf("wLength 0x%04.4x\n", setup->wLength);

}


VOID
DumpAsyncTransfer(
    MEMLOC MemLoc
    )
{
    ULONG flags;
    UCHAR cs[] = "_TRANSFER_URB";
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ReservedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR
    };
    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };

    dprintf("*ASYNC TRANSFER\n");
    flags =  UsbReadFieldUlong(MemLoc, cs, "TransferFlags");
    dprintf("TransferFlags: %08.8x\n", flags);
    UsbDumpFlags(flags, xferFlags,
        sizeof(xferFlags)/sizeof(FLAG_TABLE));

    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

}


VOID
DumpIsochTransfer(
    MEMLOC MemLoc
    )
{
    ULONG flags;
    UCHAR s[64];
    UCHAR cs[] = "_TRANSFER_URB";
    STRUC_ENTRY t[] = {
        "UsbdPipeHandle", FT_PTR,
        "TransferBufferLength", FT_ULONG,
        "TransferBuffer", FT_PTR,
        "TransferBufferMDL", FT_PTR,
        "ReservedMBNull", FT_PTR,
        "pd.HcdTransferContext", FT_PTR,
        "u.Isoch.StartFrame", FT_ULONG,
        "u.Isoch.NumberOfPackets", FT_ULONG,
        "u.Isoch.ErrorCount", FT_ULONG
    };
    FLAG_TABLE xferFlags[] = {
        "USBD_TRANSFER_DIRECTION_IN", USBD_TRANSFER_DIRECTION_IN,
        "USBD_SHORT_TRANSFER_OK", USBD_SHORT_TRANSFER_OK,
        "USBD_START_ISO_TRANSFER_ASAP", USBD_START_ISO_TRANSFER_ASAP
         };
    ULONG p, i;

    dprintf("*ISOCH TRANSFER\n");
    flags =  UsbReadFieldUlong(MemLoc, cs, "TransferFlags");
    dprintf("TransferFlags: %08.8x\n", flags);
    UsbDumpFlags(flags, xferFlags,
        sizeof(xferFlags)/sizeof(FLAG_TABLE));

    UsbDumpStruc(MemLoc, cs,
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    // attempt to dump the packet struc
    p = UsbReadFieldUlong(MemLoc, cs, "u.Isoch.NumberOfPackets");
    for (i=0; i<p; i++) {
        USBD_ISO_PACKET_DESCRIPTOR pd;
        MEMLOC t;
        ULONG cb;

        sprintf(s, "u.Isoch.IsoPacket[0]", i);
        t = MemLoc + UsbFieldOffset(cs, s)+sizeof(pd)*i;

        ReadMemory(t,
                   &pd,
                   sizeof(pd),
                   &cb);

        dprintf("Packet[%d]: Offset %08.8x Length %08.8x UsbdStatus %08.8x\n", i,
            pd.Offset, pd.Length, pd.Status);
    }

}


VOID
DumpPipeInfo(
    MEMLOC MemLoc
    )
{
    ULONG i;
    UCHAR cs[] = "_USBD_PIPE_INFORMATION";
    STRUC_ENTRY ps[] = {
        "MaximumPacketSize", FT_USHORT,
        "EndpointAddress", FT_UCHAR,
        "Interval", FT_UCHAR,
        "PipeType", FT_ULONG,
        "PipeHandle", FT_PTR,
        "MaximumTransferSize", FT_ULONG,
        "PipeFlags", FT_ULONG,
    };

    PrintfMemLoc("Pipe:  ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs,
        &ps[0], sizeof(ps)/sizeof(STRUC_ENTRY));

#if 0
    dprintf("\t\tPipeType: ");
    switch(PipeInfo->PipeType) {
    case UsbdPipeTypeControl:
        dprintf("UsbdPipeTypeControl\n");
        break;
    case UsbdPipeTypeIsochronous:
        dprintf("UsbdPipeTypeIsochronous\n");
        break;
    case UsbdPipeTypeBulk:
        dprintf("UsbdPipeTypeBulk\n");
        break;
    case UsbdPipeTypeInterrupt:
        dprintf("UsbdPipeTypeInterrupt\n");
        break;
    }
#endif
}


VOID
DumpInterfaceInfo(
    MEMLOC MemLoc
    )
{
    ULONG i, np;
    UCHAR cs[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY is[] = {
        "Length", FT_USHORT,
        "InterfaceNumber", FT_UCHAR,
        "AlternateSetting", FT_UCHAR,
        "Class", FT_UCHAR,
        "SubClass", FT_UCHAR,
        "Protocol", FT_UCHAR,
        "Reserved", FT_UCHAR,
        "InterfaceHandle", FT_PTR,
        "NumberOfPipes", FT_ULONG,
    };

    dprintf("Interface -----------------\n");

    UsbDumpStruc(MemLoc, cs,
        &is[0], sizeof(is)/sizeof(STRUC_ENTRY));

    np = UsbReadFieldUlong(MemLoc, cs, "NumberOfPipes");

    for (i=0; i < np; i++) {
        UCHAR s[80];
        MEMLOC p;

        dprintf("Pipe[%02.2d] -----------------\n", i);
        sprintf(s, "Pipes[%d]", i);

        p= MemLoc + UsbFieldOffset(cs, s);

        DumpPipeInfo(p);
    }
}


VOID
DumpSelectConfiguration(
    MEMLOC MemLoc,
    ULONG UrbLength
    )
{
    UCHAR cs[] = "_URB_SELECT_CONFIGURATION";
    UCHAR is[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY sc[] = {
        "ConfigurationHandle", FT_PTR,
        "ConfigurationDescriptor", FT_PTR,
    };
    MEMLOC start, end;
    ULONG i = 0;

    dprintf("*SELECT_CONFIG\n");
    UsbDumpStruc(MemLoc, cs,
        &sc[0], sizeof(sc)/sizeof(STRUC_ENTRY));

    start = MemLoc;
    end = start+UrbLength;

    start += UsbFieldOffset(cs, "Interface");

    while (start < end && i < 8) {
        ULONG length;

        length = UsbReadFieldUshort(start, is, "Length");

        DumpInterfaceInfo(start);

        start+=length;
        i++;
    }
}


VOID
DumpSelectInterface(
    MEMLOC MemLoc,
    ULONG UrbLength
    )
{
    UCHAR cs[] = "_URB_SELECT_INTERFACE";
    UCHAR is[] = "_USBD_INTERFACE_INFORMATION";
    STRUC_ENTRY sc[] = {
        "ConfigurationHandle", FT_PTR
    };
    MEMLOC start, end;
    ULONG i = 0;

    dprintf("*SELECT_INTERFACE\n");
    UsbDumpStruc(MemLoc, cs,
        &sc[0], sizeof(sc)/sizeof(STRUC_ENTRY));

    start = MemLoc;
    end = start+UrbLength;

    start += UsbFieldOffset(cs, "Interface");

    while (start < end && i < 8) {
        ULONG length;

        length = UsbReadFieldUshort(start, is, "Length");

        DumpInterfaceInfo(start);

        start+=length;
        i++;
    }
}


VOID
DumpUrb(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "_URB_HEADER";
    ULONG f;
    USHORT func;
    STRUC_ENTRY urbHeader[] = {
        "Length", FT_USHORT,
        "Status", FT_ULONG,
        "UsbdDeviceHandle", FT_PTR,
    };
    FLAG_TABLE usbdFlags[] = {

        "USBPORT_REQUEST_IS_TRANSFER", USBPORT_REQUEST_IS_TRANSFER,
        "USBPORT_REQUEST_MDL_ALLOCATED", USBPORT_REQUEST_MDL_ALLOCATED,
        "USBPORT_REQUEST_USES_DEFAULT_PIPE", USBPORT_REQUEST_USES_DEFAULT_PIPE,

        "USBPORT_REQUEST_NO_DATA_PHASE", USBPORT_REQUEST_NO_DATA_PHASE,
        "USBPORT_RESET_DATA_TOGGLE", USBPORT_RESET_DATA_TOGGLE,
        "USBPORT_TRANSFER_ALLOCATED", USBPORT_TRANSFER_ALLOCATED
         };

    PrintfMemLoc("*URB @", MemLoc, "\n");

    func = UsbReadFieldUshort(MemLoc, cs, "Function");
    dprintf("Function: 0x%04.4x  (%s)\n", func,
        UsbdFunctionName(func));

    UsbDumpStruc(MemLoc, cs,
        &urbHeader[0], sizeof(urbHeader)/sizeof(STRUC_ENTRY));

    f = UsbReadFieldUlong(MemLoc, cs, "UsbdFlags");
    dprintf("UsbdFlags: 0x%08.8x\n", f);
    UsbDumpFlags(f, usbdFlags,
            sizeof(usbdFlags)/sizeof(FLAG_TABLE));


    // dump the function specific stuff
    switch (func) {
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT:
    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT:
    case URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE:
    case URB_FUNCTION_SET_FEATURE_TO_DEVICE:
    case URB_FUNCTION_SET_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_SET_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_SET_FEATURE_TO_OTHER:
    case URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE:
    case URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT:
    case URB_FUNCTION_CLEAR_FEATURE_TO_OTHER:
    case URB_FUNCTION_GET_STATUS_FROM_DEVICE:
    case URB_FUNCTION_GET_STATUS_FROM_INTERFACE:
    case URB_FUNCTION_GET_STATUS_FROM_ENDPOINT:
    case URB_FUNCTION_GET_STATUS_FROM_OTHER:
    case URB_FUNCTION_VENDOR_DEVICE:
    case URB_FUNCTION_VENDOR_INTERFACE:
    case URB_FUNCTION_VENDOR_ENDPOINT:
    case URB_FUNCTION_VENDOR_OTHER:
    case URB_FUNCTION_CLASS_DEVICE:
    case URB_FUNCTION_CLASS_INTERFACE:
    case URB_FUNCTION_CLASS_ENDPOINT:
    case URB_FUNCTION_CLASS_OTHER:
    case URB_FUNCTION_GET_CONFIGURATION:
    case URB_FUNCTION_GET_INTERFACE:
        DumpControlTransfer(MemLoc);
        break;
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        DumpAsyncTransfer(MemLoc);
        break;
//    case URB_FUNCTION_SELECT_INTERFACE:
//        DumpSelectInterface((PURB) rawUrb);
//        break;
    case URB_FUNCTION_SELECT_INTERFACE:
        DumpSelectInterface(MemLoc, UsbReadFieldUshort(MemLoc, cs, "Length"));
        break;
    case URB_FUNCTION_SELECT_CONFIGURATION:
        DumpSelectConfiguration(MemLoc, UsbReadFieldUshort(MemLoc, cs, "Length"));
        break;
    case URB_FUNCTION_ISOCH_TRANSFER:
        DumpIsochTransfer(MemLoc);
        break;
    case URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL:
        DumpPipeRequest(MemLoc);
        break;
    case URB_FUNCTION_ABORT_PIPE:
        DumpPipeRequest(MemLoc);
        break;
    default:
        dprintf ("Don't know how to dump\n");
    }

}


DECLARE_API( _urb )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    // fetch the list head
    addr = GetExpression(args);

    DumpUrb (addr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\common.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbehci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "ehci.h"
#include "dbg.h"

#include "usbehci.h"

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\usbohci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    WinDbg Extension Api
    implements !_ohcitd
               !_ohcied
               !_ohciep
               !_ohcitfer

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbohci\openhci.h"
#include "..\miniport\usbohci\usbohci.h"
#include "usbhcdkd.h"

VOID    
DumpOHCI_EpTransfers(
    ULONG HeadP_MemLoc,
    ULONG TailP_MemLoc
    );

VOID
HwConditionCode(
    ULONG cc
    ) 
{

    switch (cc) {
    case HcCC_NoError:       
        dprintf("HcCC_NoError");
        break;
    case HcCC_CRC:         
        dprintf("HcCC_CRC ");
        break;
    case HcCC_BitStuffing:             
        dprintf("HcCC_BitStuffing");
        break;
    case HcCC_DataToggleMismatch:            
        dprintf("HcCC_DataToggleMismatch");
        break;
    case HcCC_Stall:            
        dprintf("HcCC_Stall ");
        break;            
    case HcCC_DeviceNotResponding:            
        dprintf("HcCC_DeviceNotResponding");
        break;            
    case HcCC_PIDCheckFailure:           
        dprintf("HcCC_PIDCheckFailure");
        break;
    case HcCC_UnexpectedPID:            
        dprintf("HcCC_UnexpectedPID");
        break;
    case HcCC_DataOverrun:            
        dprintf("HcCC_DataOverrun");
        break;
    case HcCC_DataUnderrun:            
        dprintf("HcCC_DataUnderrun");
        break;
    case HcCC_BufferOverrun:            
        dprintf("HcCC_BufferOverrun ");
        break;
    case HcCC_BufferUnderrun:            
        dprintf("HcCC_BufferUnderrun");
        break;
    case HcCC_NotAccessed:                
        dprintf("HcCC_NotAccessed");
        break;
    default:                
        dprintf("???");
        break;        
    }
}


VOID    
DumpOHCI_Td(
    MEMLOC MemLoc
    )
{
    
    HCD_TRANSFER_DESCRIPTOR td;
    ULONG cb;
    ULONG i;

    // tds are a fixed size of 64/32 platforms so 
    // we can just read it in

    ReadMemory(MemLoc,
               &td,
               sizeof(td),
               &cb);

    PrintfMemLoc("*USBOHCI TD ", MemLoc, "\n");

    dprintf("HwTD");
    if (td.HwTD.Asy.Isochronous) {
        // dump as iso
        dprintf("\tIsochronous %x, \n", td.HwTD.Iso.Isochronous);
        dprintf("\tStartingFrame: %x\n", td.HwTD.Iso.StartingFrame);
        dprintf("\tFrameCount: %d (%d frames) \n", td.HwTD.Iso.FrameCount,
            td.HwTD.Iso.FrameCount+1);
        // dump the psw
    
        dprintf("\tPSW:\n"); 
        for (i=0; i< td.HwTD.Iso.FrameCount+2; i++) {
            // input
            dprintf("\t\tinput:[%d].Offset: x%x - %d\n", i, 
                td.HwTD.Packet[i].Offset,
                td.HwTD.Packet[i].Offset);
            dprintf("\t\tinput:[%d].Ones: x%x \n", i, td.HwTD.Packet[i].Ones);

            dprintf("\t\toutput:[%d].Size: %d\n", i, td.HwTD.Packet[i].Size);
            dprintf("\t\toutput:[%d].ConditionCode: %d\n", i, td.HwTD.Packet[i].ConditionCode);
        }
    } else {        
    
        // dump as async
        dprintf("\tIsochronous %x, \n", td.HwTD.Asy.Isochronous);
        dprintf("\tShortXferOk: %x\n", td.HwTD.Asy.ShortXferOk);
        dprintf("\tDirection: %x\n", td.HwTD.Asy.Direction);
        dprintf("\tToggle: %x", td.HwTD.Asy.Toggle);
        dprintf("\tIntDelay: %x", td.HwTD.Asy.IntDelay);
        dprintf("\tErrorCount: %x\n", td.HwTD.Asy.ErrorCount); 
        dprintf("\tConditionCode: x%x - ", td.HwTD.Asy.ConditionCode); 
        HwConditionCode(td.HwTD.Asy.ConditionCode);
        dprintf("\n");
        
        switch (td.HwTD.Asy.Toggle) {
        case HcTDToggle_FromEd:
            dprintf("HcTDToggle_FromEd\n");
            break;
        case HcTDToggle_Data0:
            dprintf("HcTDToggle_Data0\n");
            break;
        case HcTDToggle_Data1:
            dprintf("HcTDToggle_Data1\n");
            break;
        }            
    }        

    // these fields are common for iso & async
    
    dprintf("\tCBP: ! %x\n", td.HwTD.CBP);    
    dprintf("\tBE:  ! %x\n", td.HwTD.BE); 
    dprintf("\tNextTD: ! %x\n", td.HwTD.NextTD); 

    dprintf("PhysicalAddress: %08.8x\n", td.PhysicalAddress); 
    Sig(td.Sig, ""); 
    dprintf("Flags: 0x%08.8x\n", td.Flags);
    dprintf("EndpointData: %08.8x\n", td.EndpointData);
    dprintf("TransferContext: %08.8x\n", td.TransferContext);
    dprintf("TransferCount: 0x%08.8x\n", td.TransferCount);
    dprintf("FrameIndex: %d\n", td.FrameIndex);
    dprintf("NextHcdTD: %08.8x\n", td.NextHcdTD);
            

}


VOID    
DumpOHCI_Ed(
    ULONG MemLoc
    )
{
    
    HCD_ENDPOINT_DESCRIPTOR ed;
    ULONG result;

    if (!ReadMemory (MemLoc, &ed, sizeof(ed), &result)) {
        BadMemLoc(MemLoc);
        return;
    }
    
    dprintf("*USBOHCI ED %08.8x\n", MemLoc);
    dprintf("HwED");
    dprintf("\tFunctionAddress: 0x%x\n", ed.HwED.FunctionAddress);
    dprintf("\tEndpointNumber: %x\n", ed.HwED.EndpointNumber);
    dprintf("\tDirection: %x\n", ed.HwED.Direction);
    dprintf("\tLowSpeed: %x\n", ed.HwED.LowSpeed);
    dprintf("\tsKip: %x\n", ed.HwED.sKip);
    dprintf("\tIsochronous: %x\n", ed.HwED.Isochronous);
    dprintf("\tMaxPacket: 0x%x\n", ed.HwED.MaxPacket);
    
    dprintf("\tTailP: ! %x\n", ed.HwED.TailP);    
    dprintf("\tHeadP: ! %x", ed.HwED.HeadP);    
    if (ed.HwED.HeadP & HcEDHeadP_HALT) {
        dprintf(" (halted)");
    }   
    dprintf("\n");
    dprintf("\tNextED: %x\n", ed.HwED.NextED); 
    
    dprintf("PhysicalAddress: %08.8x\n", ed.PhysicalAddress); 
    Sig(ed.Sig, ""); 
    dprintf("EdFlags: 0x%08.8x\n", ed.EdFlags);
    dprintf("EndpointData: %08.8x\n", ed.EndpointData);
    dprintf("SwLink.List.Flink: %08.8x\n", ed.SwLink.List.Flink);
    dprintf("SwLink.List.Blink: %08.8x\n", ed.SwLink.List.Blink);

}


VOID    
DumpOHCI_EndpointData(
    MEMLOC MemLoc
    )
{
    
    UCHAR cs[] = "usbohci!_ENDPOINT_DATA";
 
    PrintfMemLoc("*USBOHCI ENDPOINT_DATA ", MemLoc, "\n");

    Sig(UsbReadFieldUlong(MemLoc, cs, "Sig"), "");
//    dprintf("MaxPendingTransfers: 0x%08.8x\n", epData.MaxPendingTransfers);
    dprintf("PendingTransfers: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "PendingTransfers"));
    PrintfMemLoc("StaticEd: ", 
                 UsbReadFieldPtr(MemLoc, cs, "StaticEd"),
                 "\n");
    PrintfMemLoc("TdList: ", 
                 UsbReadFieldPtr(MemLoc, cs, "TdList"),
                 "\n");
    PrintfMemLoc("HcdEd: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdEd"),
                 "\n");
                 
    dprintf("TdCount: 0x%08.8x\n", 
        UsbReadFieldUlong(MemLoc, cs, "TdCount"));

    PrintfMemLoc("HcdTailP: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdTailP"),
                 "\n");
    PrintfMemLoc("HcdHeadP: ", 
                 UsbReadFieldPtr(MemLoc, cs, "HcdHeadP"),
                 "\n");                 

//    DumpOHCI_Ed(epData.HcdEd);
    
//    DumpOHCI_EpTransfers((ULONG) epData.HcdHeadP, (ULONG) epData.HcdTailP);


}


VOID    
DumpOHCI_TransferContext(
    ULONG MemLoc
    )
{
    
    TRANSFER_CONTEXT tc;
    ULONG result;
    SIG s;
 
    if (!ReadMemory (MemLoc, &tc, sizeof(tc), &result)) {
        BadMemLoc(MemLoc);
        return;
    }

    dprintf("*USBOHCI TRANSFER_CONTEXT %08.8x\n", MemLoc);
    Sig(tc.Sig, "");
    dprintf("BytesTransferred: 0x%08.8x\n", tc.BytesTransferred);
    dprintf("TransferParameters: %x\n", 
        tc.TransferParameters);
    dprintf("PendingTds: %d\n", tc.PendingTds);
    dprintf("Flags: %08.8x\n", tc.TcFlags);
    dprintf("UsbdStatus: 0x%08.8x\n", tc.UsbdStatus);
    dprintf("NextXferTd: %08.8x\n", tc.NextXferTd);
    dprintf("StatusTd: %08.8x\n", tc.StatusTd);
    dprintf("EndpointData: %08.8x\n", tc.EndpointData);
}    


VOID    
DumpOHCI_EpTransfers(
    ULONG HeadP_MemLoc,
    ULONG TailP_MemLoc
    )
{
#if 0
    HCD_TRANSFER_DESCRIPTOR td;
    ULONG memLoc, result;
    
    // start at headp and walk to tail
    dprintf("\t TRANSFERS: HeadP\n");

    memLoc = HeadP_MemLoc;

    do {
        
        if (!ReadMemory (memLoc, &td, sizeof(td), &result)) {
           break;
        }   

        dprintf("\t> TD %8.8x(! %8.8x) - Transfer %8.8x Next-> ! %8.8x\n",
                memLoc, td.PhysicalAddress, td.TransferContext.Pointer,
                td.HwTD.NextTD);
       

        if (memLoc == TailP_MemLoc) {
            break;
        }
        
        memLoc = (ULONG) td.NextHcdTD.Pointer;
        
    } while (1);
#endif    
}


VOID    
DumpOHCI_DeviceData(
    MEMLOC MemLoc,
    BOOLEAN Verbose
    )
{
    UCHAR cs[] = "usbohci!_DEVICE_DATA";
    ULONG f, i;
    UCHAR fld[40], fld1[40], fld2[40], fld3[40], fld4[40];
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "HC", FT_PTR,
        "BIOS_Interval", FT_ULONG,
        "SofModifyValue", FT_ULONG,
        "FrameHighPart", FT_ULONG,
        "HcHCCA", FT_PTR,
        "HcHCCAPhys", FT_ULONG,
        "HydraLsHsHackEd", FT_PTR,
        "StaticEDs", FT_PTR,
        "StaticEDsPhys", FT_ULONG,
        "ControllerFlavor", FT_ULONG,
        
    };
    ULONG period[] =  {1, 2, 2, 4, 4, 4, 4, 8,
                      8, 8, 8, 8, 8, 8, 8,16,
                      16,16,16,16,16,16,16,16,
                      16,16,16,16,16,16,16,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,32,
                      32,32,32,32,32,32,32,
                      0, 0};
//    FLAG_TABLE ddFlags[] = {
//        "EHCI_DD_FLAG_NOCHIRP", EHCI_DD_FLAG_NOCHIRP,
//        "EHCI_DD_FLAG_SOFT_ERROR_RETRY", EHCI_DD_FLAG_SOFT_ERROR_RETRY
//         };     

    PrintfMemLoc("*USBOHCI DEVICE DATA ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

    if (Verbose) {
        for (i= 0; i< NO_ED_LISTS; i++) {
            dprintf("\t[%02.2d] (%2.2dms): ", i, period[i]);
            sprintf(fld , "StaticEDList[%d]", i);
            sprintf(fld1, "StaticEDList[%d].HwED", i);
            sprintf(fld2, "StaticEDList[%d].HwEDPhys", i);
            PrintfMemLoc("StaticED @ ",
                MemLoc + UsbFieldOffset(cs, fld),
                " ");
            PrintfMemLoc("HwED ",
                UsbReadFieldPtr(MemLoc, cs, fld1),
                " ");

            dprintf("(!%08.8x)\n", 
                UsbReadFieldUlong(MemLoc, cs, fld2));
                
            sprintf(fld1, "StaticEDList[%d].NextIdx", i);            
            sprintf(fld2, "StaticEDList[%d].EdFlags", i);   
            sprintf(fld3, "StaticEDList[%d].HccaOffset", i);   
            sprintf(fld4, "StaticEDList[%d].PhysicalHead", i);   
            
            dprintf("\t\tNextIdx(%03.3d) EdFlags %08.8x Hcca Offset %d ", 
                UsbReadFieldUlong(MemLoc, cs, fld1), 
                UsbReadFieldUlong(MemLoc, cs, fld2),
                UsbReadFieldUlong(MemLoc, cs, fld3));
            PrintfMemLoc("PhysicalHead ",
                MemLoc + UsbFieldOffset(cs, fld4),
                "\n");

            sprintf(fld1, "StaticEDList[%d].TransferEdList.Flink", i);          
            PrintfMemLoc("\t\tTransferEdList.Flink ", 
                UsbReadFieldPtr(MemLoc, cs, fld1),
                "\n");
            sprintf(fld1, "StaticEDList[%d].TransferEdList.Blink", i);          
            PrintfMemLoc("\t\tTransferEdList.Blink ", 
                UsbReadFieldPtr(MemLoc, cs, fld1),
                "\n");
                            
        }   
    }
            
}

VOID    
DumpOHCI_Ints(
    ULONG i
    )
{
    if (i & HcInt_SchedulingOverrun) {
        dprintf("\t HcInt_SchedulingOverrun \n");
    }
    if (i & HcInt_WritebackDoneHead) {
        dprintf("\t HcInt_WritebackDoneHead \n");
    }
    if (i & HcInt_StartOfFrame) {
        dprintf("\t HcInt_StartOfFrame \n");
    }
    if (i & HcInt_ResumeDetected) {
        dprintf("\t HcInt_ResumeDetected \n");
    }
    if (i & HcInt_UnrecoverableError) {
        dprintf("\t HcInt_UnrecoverableError \n");
    }
    if (i & HcInt_RootHubStatusChange) {
        dprintf("\t HcInt_RootHubStatusChange \n");
    }
    if (i & HcInt_OwnershipChange) {
        dprintf("\t HcInt_OwnershipChange \n");
    }
    if (i & HcInt_MasterInterruptEnable) {
        dprintf("\t HcInt_MasterInterruptEnable \n");
    }
    if (i & HcInt_FrameNumberOverflow) {
        dprintf("\t HcInt_FrameNumberOverflow \n");
    }

     dprintf("\n");
}

VOID    
DumpOHCI_OpRegs(
    MEMLOC MemLoc
    )
{
    HC_OPERATIONAL_REGISTER hc;
    HC_CONTROL cmd;
    HC_COMMAND_STATUS sts;    
    ULONG l, i, p;
    ULONG cb;

    ReadMemory(MemLoc,
               &hc,
               sizeof(HC_OPERATIONAL_REGISTER),
               &cb);

    PrintfMemLoc("*(ohci)HC_OPERATIONAL_REGISTER ", MemLoc, "\n");

    cmd = hc.HcControl;
    dprintf("\tHC_CONTROL %08.8x\n" , cmd.ul);
    dprintf("\t.ControlBulkServiceRatio: %d\n", cmd.ControlBulkServiceRatio); 
    dprintf("\t.IsochronousEnable: %d\n", cmd.IsochronousEnable); 
    dprintf("\t.ControlListEnable: %d\n", cmd.ControlListEnable); 
    dprintf("\t.BulkListEnable: %d\n", cmd.BulkListEnable); 
    dprintf("\t.HostControllerFunctionalState: %d\n", cmd.HostControllerFunctionalState); 
    dprintf("Reset=0 Resume=1 Operational=2 Suspend=3\n");                     

    dprintf("\t.InterruptRouting: %d\n", cmd.InterruptRouting); 
    dprintf("\t.RemoteWakeupConnected: %d\n", cmd.RemoteWakeupConnected); 
    dprintf("\t.RemoteWakeupEnable: %d\n", cmd.RemoteWakeupEnable); 
    dprintf("\n");
    
    sts = hc.HcCommandStatus;
    dprintf("\tHC_COMMAND_STATUS %08.8x\n" , sts.ul);
    dprintf("\t.HostControllerReset: %d\n", sts.HostControllerReset); 
    dprintf("\t.ControlListFilled: %d\n", sts.ControlListFilled); 
    dprintf("\t.BulkListFilled: %d\n", sts.BulkListFilled); 
    dprintf("\t.OwnershipChangeRequest: %d\n", sts.OwnershipChangeRequest); 
    dprintf("\t.SchedulingOverrunCount: %d\n", sts.SchedulingOverrunCount); 
    dprintf("\n");

    dprintf("\tHcInterruptStatus: %08.8x\n" , hc.HcInterruptStatus);  
    DumpOHCI_Ints(hc.HcInterruptStatus);
    dprintf("\tHcInterruptEnable: %08.8x\n" , hc.HcInterruptEnable);  
    DumpOHCI_Ints(hc.HcInterruptEnable);
    dprintf("\tHcInterruptDisable: %08.8x\n" , hc.HcInterruptDisable);  
    DumpOHCI_Ints(hc.HcInterruptDisable);
    dprintf("\tHcHCCA: %08.8x\n" , hc.HcHCCA);  
    dprintf("\tHcPeriodCurrentED: %08.8x\n" , hc.HcPeriodCurrentED);  
    dprintf("\tHcControlHeadED: %08.8x\n" , hc.HcControlHeadED);  
    dprintf("\tHcControlCurrentED: %08.8x\n" , hc.HcControlCurrentED);  
    dprintf("\tHcBulkHeadED: %08.8x\n" , hc.HcBulkHeadED);  
    dprintf("\tHcBulkCurrentED: %08.8x\n" , hc.HcBulkCurrentED);  
    dprintf("\tHcDoneHead: %08.8x\n" , hc.HcDoneHead);  
    dprintf("\tHcFmInterval: %08.8x\n" , hc.HcFmInterval.ul);  
    dprintf("\tHcFmRemaining: %08.8x\n" , hc.HcFmRemaining.ul);  
    dprintf("\tHcFmNumber: %08.8x\n" , hc.HcFmNumber);  
    dprintf("\tHcPeriodicStart: %08.8x\n" , hc.HcPeriodicStart);  
    dprintf("\tHcLSThreshold: %08.8x\n" , hc.HcLSThreshold);  

    dprintf("\t-------\n");
    dprintf("\tCurrent Frame Index = %d\n", hc.HcFmNumber & 0x0000001f);
    dprintf("\t-------\n");

    dprintf("\tHcRhDescriptorA: %08.8x\n" , hc.HcRhDescriptorA.ul);  
    dprintf("\t\tNumberDownstreamPorts: %d\n" , hc.HcRhDescriptorA.s.NumberDownstreamPorts);  
    dprintf("\t\tHubChars: %x\n" , hc.HcRhDescriptorA.s.HubChars);  
    dprintf("\t\tPowerOnToPowerGoodTime: %d\n" , hc.HcRhDescriptorA.s.PowerOnToPowerGoodTime);  
    dprintf("\tHcRhDescriptorB: %08.8x\n" , hc.HcRhDescriptorB.ul);  
    dprintf("\tHcRhStatus: %08.8x\n" , hc.HcRhStatus);  
    for (p=0; p< hc.HcRhDescriptorA.s.NumberDownstreamPorts; p++) {
        dprintf("\tHcRhPortStatus[%d]: %08.8x\n",p ,hc.HcRhPortStatus[p]);  
    }
}


DECLARE_API( _ohcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_Td (addr);

    return S_OK; 
}


DECLARE_API( _ohcied )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpOHCI_Ed (memLoc);

    return S_OK; 
}


DECLARE_API( _ohciep )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_EndpointData (addr);

    return S_OK; 
}


DECLARE_API( _ohcitfer )

/*++

Routine Description:

   dumps TRANSFER_CONTEXT
Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    ULONG           memLoc;
    UCHAR           buffer[256];
    ULONG           len = 30;
    ULONG           result;

    //UNREFERENCED_PARAMETER (dwProcessor);
    //UNREFERENCED_PARAMETER (dwCurrentPc);
    //UNREFERENCED_PARAMETER (hCurrentThread);
    //UNREFERENCED_PARAMETER (hCurrentProcess);

    buffer[0] = '\0';

    sscanf(args, "%lx, %s", &memLoc, buffer);

    if ('\0' != buffer[0]) {
        sscanf(buffer, "%d", &len);
    }

    DumpOHCI_TransferContext (memLoc);

    return S_OK; 
}


DECLARE_API( _ohciregs )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpOHCI_OpRegs(addr);

    return S_OK; 
}


DECLARE_API( _ohcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );
    
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    DumpOHCI_DeviceData(addr, parm[0] == 'v');

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\kdexts\usbuhci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbuhci.c

Abstract:

    WinDbg Extension Api
    implements 

Author:

    jd

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "usb.h"
#include "usbhcdi.h"
#include "..\miniport\usbuhci\uhci.h"
#include "..\miniport\usbuhci\usbuhci.h"
#include "usbhcdkd.h"


VOID    
DumpUHCI_DeviceData(
    MEMLOC MemLoc,
    BOOLEAN Verbose
    )
{
    UCHAR cs[] = "usbuhci!_DEVICE_DATA";
    ULONG f, i;
    UCHAR fld[40], fld1[40], fld2[40], fld3[40], fld4[40];
    STRUC_ENTRY t[] = {
        "Sig", FT_SIG,
        "Registers", FT_PTR,
        "EnabledInterrupts", FT_ULONG,
        "AsyncQueueHead", FT_PTR,
        "ControllerFlavor", FT_ULONG,
        "LastFrame", FT_ULONG,
        "FrameNumberHighPart", FT_ULONG,
        "PortResetChange", FT_ULONG,
        "PortSuspendChange", FT_ULONG,
        "PortConnectChange", FT_ULONG,
        "IrqStatus", FT_USHORT,
        "PortPowerControl", FT_USHORT,
        "FrameListVA", FT_PTR,
        "ControlQueueHead", FT_PTR,
        "BulkQueueHead", FT_PTR,
        "LastBulkQueueHead", FT_PTR
    
    };

    PrintfMemLoc("*USBUHCI DEVICE DATA ", MemLoc, "\n");
    UsbDumpStruc(MemLoc, cs, 
        &t[0], sizeof(t)/sizeof(STRUC_ENTRY));

}


VOID    
DumpUHCI_Qh(
    MEMLOC MemLoc
    )
{
    HW_QUEUE_HEAD hwqh;
    ULONG cb;
    UCHAR cs[] = "_HCD_QUEUEHEAD_DESCRIPTOR";
    STRUC_ENTRY qh[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "QhFlags", FT_ULONG,
        "NextQh", FT_PTR,
        "PrevQh", FT_PTR,
        "EndpointData", FT_PTR,
    };

    PrintfMemLoc("*USBUHCI QH ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
         &qh[0], sizeof(qh)/sizeof(STRUC_ENTRY));

    ReadMemory(MemLoc,
               &hwqh,
               sizeof(hwqh),
               &cb);

    dprintf("HwQH\n");
    
    // dump as 
    dprintf("\t HLink %08.8x ", hwqh.HLink.HwAddress);
    if (hwqh.HLink.Terminate) {
        dprintf("(T)");    
    } 
    if (hwqh.HLink.QHTDSelect) {
        dprintf("(QH)");    
    } 
    dprintf("\n"); 
    
    dprintf("\t\t Physical Address %08.8x \n", 
        hwqh.HLink.HwAddress & ~HW_LINK_FLAGS_MASK);

     // dump as 
    dprintf("\t VLink %08.8x ", hwqh.VLink.HwAddress);
    if (hwqh.VLink.Terminate) {
        dprintf("(T)");    
    } 
    if (hwqh.VLink.QHTDSelect) {
        dprintf("(QTD)");    
    } 
    dprintf("\n"); 
     
    dprintf("\t\t Physical Address %08.8x \n", 
        hwqh.VLink.HwAddress & ~HW_LINK_FLAGS_MASK);

}


VOID    
DumpUHCI_FrameList(
    MEMLOC MemLoc
    )
{
    UCHAR cs[] = "usbuhci!_DEVICE_DATA";
    ULONG addr, cb, i;
    MEMLOC fl;
    
    fl = UsbReadFieldPtr(MemLoc, cs, "FrameListVA"), 
    PrintfMemLoc("*FRAME LIST @", fl, "\n");

    for (i = 0; i< 1024; i++) {
        ReadMemory(fl,
                   &addr,
                   sizeof(addr),
                   &cb);    
        dprintf("[%03.3x] - %08.8x  ", i, addr & ~HW_LINK_FLAGS_MASK);                         
        fl+=sizeof(ULONG);

        if ((i+1)%4 == 0) {
            dprintf("\n");
        }
    }                   

}


VOID    
DumpUHCI_Td(
    MEMLOC MemLoc
    )
{
    HW_QUEUE_ELEMENT_TD hwtd;
    ULONG cb;
    UCHAR cs[] = "_HCD_TRANSFER_DESCRIPTOR";
    STRUC_ENTRY td[] = {
        "Sig", FT_SIG,
        "PhysicalAddress", FT_ULONG,
        "Packet[0]", FT_UCHAR,
        "Packet[1]", FT_UCHAR,
        "Packet[2]", FT_UCHAR,
        "Packet[3]", FT_UCHAR,
        "Packet[4]", FT_UCHAR,
        "Packet[5]", FT_UCHAR,
        "Packet[6]", FT_UCHAR,
        "TransferContext", FT_PTR,
        "Flags", FT_ULONG,
        "TransferLength", FT_ULONG,
        "NextHcdTD", FT_PTR,
        "DoubleBufferIndex", FT_ULONG
    };

    PrintfMemLoc("*USBUHCI TD ", MemLoc, "\n");

    UsbDumpStruc(MemLoc, cs, 
        &td[0], sizeof(td)/sizeof(STRUC_ENTRY));

    // tds are a fixed size of 64/32 platforms so 
    // we can just read it in

    ReadMemory(MemLoc,
               &hwtd,
               sizeof(hwtd),
               &cb);

    dprintf("HwTD\n");

    // dump as async
    dprintf("\t LinkPointer %08.8x\n", hwtd.LinkPointer);
    dprintf("\t Control %08.8x\n", hwtd.Control);
    dprintf("\t\t Control.Reserved1 %d\n", hwtd.Control.Reserved1);
    dprintf("\t\t Control.ActualLength %d\n", hwtd.Control.ActualLength);
    dprintf("\t\t Control.BitstuffError %d\n", hwtd.Control.BitstuffError);
    dprintf("\t\t Control.Reserved2 %d\n", hwtd.Control.Reserved2);
    dprintf("\t\t Control.TimeoutCRC %d\n", hwtd.Control.TimeoutCRC);
    dprintf("\t\t Control.NAKReceived %d\n", hwtd.Control.NAKReceived);
    dprintf("\t\t Control.BabbleDetected %d\n", hwtd.Control.BabbleDetected);
    dprintf("\t\t Control.DataBufferError %d\n", hwtd.Control.DataBufferError);
    dprintf("\t\t Control.Stalled %d\n", hwtd.Control.Stalled);
    dprintf("\t\t Control.Active %d\n", hwtd.Control.Active);
    dprintf("\t\t Control.InterruptOnComplete %d\n", hwtd.Control.InterruptOnComplete);
    dprintf("\t\t Control.IsochronousSelect %d\n", hwtd.Control.IsochronousSelect);
    dprintf("\t\t Control.LowSpeedDevice %d\n", hwtd.Control.LowSpeedDevice);
    dprintf("\t\t Control.ErrorCount %d\n", hwtd.Control.ErrorCount);
    dprintf("\t\t Control.ShortPacketDetect %d\n", hwtd.Control.ShortPacketDetect);
    dprintf("\t\t Control.Reserved3 %d\n", hwtd.Control.Reserved3);
    dprintf("\t Token %08.8x\n", hwtd.Token);
    dprintf("\t\t Token.DeviceAddress %d\n", hwtd.Token.DeviceAddress);
    dprintf("\t\t Token.Endpoint %d\n", hwtd.Token.Endpoint);
    dprintf("\t\t Token.DataToggle %d\n", hwtd.Token.DataToggle);
    dprintf("\t\t Token.Reserved %d\n", hwtd.Token.Reserved);
    dprintf("\t\t Token.MaximumLength %d\n", hwtd.Token.MaximumLength);
    dprintf("\n");
}


DECLARE_API( _uhcifl )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_FrameList (addr);

    return S_OK; 
}

    
DECLARE_API( _uhcitd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_Td (addr);

    return S_OK; 
}


DECLARE_API( _uhciqh )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
     
    // fetch the list head
    addr = GetExpression(args);
    
    DumpUHCI_Qh (addr);

    return S_OK; 
}


DECLARE_API( _uhciports )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;

    return S_OK; 
}




DECLARE_API( _uhcidd )

/*++

Routine Description:

   dumps the extension

Arguments:

    args - Address flags

Return Value:

    None

--*/

{
    MEMLOC  addr;
    PCSTR s;
    UCHAR parm[32];

    GetExpressionEx( args, &addr, &s );
    
    sscanf(s, ",%s", &parm);
    dprintf("%s\n", parm);

    DumpUHCI_DeviceData(addr, parm[0] == 'v');

    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\async.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control and bulk

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"


//implements the following miniport functions:

//non paged
//EHCI_OpenControlEndpoint
//EHCI_InterruptTransfer
//EHCI_OpenControlEndpoint
//EHCI_InitializeTD
//EHCI_InitializeQH


VOID
EHCI_EnableAsyncList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.AsyncScheduleEnable = 1;

    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);

    LOGENTRY(DeviceData, G, '_enA', cmd.ul, 0, 0);

}


VOID
EHCI_DisableAsyncList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    USBSTS sts;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.AsyncScheduleEnable = 0;

    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);

    // Note this just requests the async schedule to disable
    // it is not a synchronous function, the list may be running
    // on return from this function. We synchronize with the real
    // status in the flush function.
    //
    // The reason is that this function is used to optimize perf
    // by turning off the async list when no xfers are availble.
    // We don't want to block the diver waititing for the list to
    // disable.

    LOGENTRY(DeviceData, G, '_dsL', cmd.ul, 0, 0);

}


VOID
EHCI_LinkTransferToQueue(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR FirstTd
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    BOOLEAN syncWithHw;

    qh = EndpointData->QueueHead;

    // now link the transfers to the queue.
    // Two cases to handle:
    //
    // case 1: HeadP is pointing to dummy, no transfer
    // case 2: HeadP points to possibly active transfer

    LOGENTRY(DeviceData, G, '_L2Q', qh, EndpointData, EndpointData->HcdHeadP);

    syncWithHw = EHCI_HardwarePresent(DeviceData, FALSE);

    EHCI_ASSERT(DeviceData, EndpointData->HcdHeadP != NULL);
    if (EndpointData->HcdHeadP == EndpointData->DummyTd) {
        // The hardware will be accessing the dummy QH
        // link it in

        if (syncWithHw) {
            EHCI_LockQueueHead(DeviceData,
                               qh,
                               EndpointData->Parameters.TransferType);
        }

        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        LOGENTRY(DeviceData, G, '_L21', qh, EndpointData, 0);

        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
            FirstTd->HwTD.AltNext_qTD.HwAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
            FirstTd->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;

        if (syncWithHw) {
            EHCI_UnlockQueueHead(DeviceData,
                                 qh);
        }

        EndpointData->HcdHeadP = FirstTd;
    } else {

        PHCD_TRANSFER_DESCRIPTOR td, lastTd;
        PTRANSFER_CONTEXT transfer, tmp;
        ULONG i, active;

        // new transfer already points to
        // dummyTd

        // walk the transfer list to the last td
        lastTd = td = EndpointData->HcdHeadP;
        ASSERT_TD(DeviceData, td);
        while (td != EndpointData->DummyTd) {
            lastTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            LOGENTRY(DeviceData, G, '_nx2', qh, td, 0);
            ASSERT_TD(DeviceData, td);
        }
        // note last td should not be dummy, if dummy td were
        // head we would not be in this case
        EHCI_ASSERT(DeviceData, lastTd != EndpointData->DummyTd);
        ASSERT_TD(DeviceData, lastTd);
        LOGENTRY(DeviceData, G, '_lst', qh, lastTd, 0);

        transfer = TRANSFER_CONTEXT_PTR(lastTd->TransferContext);

        // note that we cannot lock the queue head here since
        // that might screw up any split transactions we have

        // instead we use a write loop to take care of any
        // race conditions caused by us accessing the overlay
        // concurrently with the controller


        // fixup the alt_next pointers in the TDs of the
        // last transfer
        for (i=0; i<EndpointData->TdCount; i++) {
            td = &EndpointData->TdList->Td[i];
            tmp = TRANSFER_CONTEXT_PTR(td->TransferContext);
            if (tmp == transfer) {
                SET_ALTNEXT_TD(DeviceData, td, FirstTd);
            }
        }

        // point the last TD at the first TD
        SET_NEXT_TD(DeviceData, lastTd, FirstTd);

        // now check the overlay, if the last TD is current
        // then we need to update the overlay too
        LOGENTRY(DeviceData, G, '_ckk', qh->HwQH.CurrentTD.HwAddress,
            lastTd, lastTd->PhysicalAddress);

        if (qh->HwQH.CurrentTD.HwAddress == lastTd->PhysicalAddress) {
            LOGENTRY(DeviceData, G, '_upo', qh->HwQH.CurrentTD.HwAddress,
                    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress,
                    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress);

            qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
                FirstTd->PhysicalAddress;
            qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
                EHCI_TERMINATE_BIT;
        }
    }
}




PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_InitializeQH(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an QH for inserting in to the
   schedule

   returns a ptr to the QH passed in

Arguments:


--*/
{

    RtlZeroMemory(Qh, sizeof(*Qh));

    // make double sure we have the prober alignment
    // on the TD structures
    EHCI_ASSERT(DeviceData, (HwPhysAddress & HW_LINK_FLAGS_MASK) == 0);
    Qh->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Qh->EndpointData) = EndpointData;
    Qh->Sig = SIG_HCD_QH;

    // init the hw descriptor
    Qh->HwQH.EpChars.DeviceAddress = EndpointData->Parameters.DeviceAddress;
    Qh->HwQH.EpChars.EndpointNumber = EndpointData->Parameters.EndpointAddress;

    switch (EndpointData->Parameters.DeviceSpeed) {
    case LowSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_LowSpeed;
        LOGENTRY(DeviceData, G, '_iLS', EndpointData, 0, 0);
        break;
    case FullSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        LOGENTRY(DeviceData, G, '_iFS', EndpointData, 0, 0);
        break;
    case HighSpeed:
        Qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;
        LOGENTRY(DeviceData, G, '_iHS', EndpointData, 0, 0);
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    }

    Qh->HwQH.EpChars.MaximumPacketLength =
        EndpointData->Parameters.MaxPacketSize;

    Qh->HwQH.EpCaps.HighBWPipeMultiplier = 1;
    if (EndpointData->Parameters.DeviceSpeed == HcEPCHAR_HighSpeed) {
        Qh->HwQH.EpCaps.HubAddress =  0;
        Qh->HwQH.EpCaps.PortNumber = 0;
    } else {
        Qh->HwQH.EpCaps.HubAddress =
            EndpointData->Parameters.TtDeviceAddress;
        Qh->HwQH.EpCaps.PortNumber =
            EndpointData->Parameters.TtPortNumber;
        if (EndpointData->Parameters.TransferType == Control) {
            Qh->HwQH.EpChars.ControlEndpointFlag = 1;
        }
        LOGENTRY(DeviceData, G, '_iTT',
            EndpointData->Parameters.TtPortNumber,
            EndpointData->Parameters.TtDeviceAddress,
            Qh->HwQH.EpChars.ControlEndpointFlag);
    }

    // init the overlay are such that we are in the 'advance queue'
    // state with the next queue Tds pointing to terminate links
    Qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    Qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    Qh->HwQH.Overlay.qTD.Token.Active = 0;
    Qh->HwQH.Overlay.qTD.Token.Halted = 0;

    return Qh;
}


PHCD_TRANSFER_DESCRIPTOR
EHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for insertin in to the
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{
    RtlZeroMemory(Td, sizeof(*Td));

    // make double sure we have the prober alignment
    // on the TD structures
    EHCI_ASSERT(DeviceData, (HwPhysAddress & HW_LINK_FLAGS_MASK) == 0);
    Td->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Td->EndpointData) = EndpointData;
    Td->Sig = SIG_HCD_TD;
    TRANSFER_CONTEXT_PTR(Td->TransferContext) = FREE_TD_CONTEXT;

    return Td;
}


USB_MINIPORT_STATUS
EHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize a control transfer


    NOTES:

    HW pointers nextTD and AltNextTD are shadowed in
    NextHcdTD and AltNextHcdTD.



Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR prevTd, td, setupTd, statusTd;
    ULONG lengthMapped, dataTDCount = 0;
    ULONG nextToggle;


    // we can do any control transfer with six TDs
    if (EndpointData->FreeTds < 6)  {
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;
    DeviceData->PendingControlAndBulk++;

    nextToggle = HcTOK_Toggle1;

    // we have enough tds, program the transfer

    //
    // first prepare a TD for the setup packet
    //

    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, 0);

    //
    // allocate setup stage
    //
    TransferContext->PendingTds++;
    setupTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    if (!setupTd) {
        goto EHCI_ControlTransferNoTds;
    }
    INITIALIZE_TD_FOR_TRANSFER(setupTd, TransferContext);

    //
    // Move setup data into TD (8 chars long)
    //
    RtlCopyMemory(&setupTd->Packet[0],
                  &TransferParameters->SetupPacket[0],
                  8);

    // this will set the offset and phys address bits at
    // the same time
    setupTd->HwTD.BufferPage[0].ul = (ULONG)(((PCHAR) &setupTd->Packet[0])
                        - ((PCHAR) &setupTd->HwTD)) + setupTd->PhysicalAddress;

    setupTd->HwTD.Token.BytesToTransfer = 8;
    setupTd->HwTD.Token.Pid = HcTOK_Setup;
    setupTd->HwTD.Token.DataToggle = HcTOK_Toggle0;
    setupTd->HwTD.Token.Active = 1;


    LOGENTRY(DeviceData,
             G, '_set',
             setupTd,
             *((PLONG) &TransferParameters->SetupPacket[0]),
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate the status phase TD now so we can
    // point the data TDs to it
    TransferContext->PendingTds++;
    statusTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    if (!statusTd) {
        goto EHCI_ControlTransferNoTds;
    }
    INITIALIZE_TD_FOR_TRANSFER(statusTd, TransferContext);

    // point setup to status
    SET_ALTNEXT_TD(DeviceData, setupTd, statusTd);

    //
    // now setup the data phase
    //

    td = prevTd = setupTd;
    lengthMapped = 0;
    while (lengthMapped < TransferParameters->TransferBufferLength) {

        //
        // fields for data TD
        //

        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        if (!td) {
            goto EHCI_ControlTransferNoTds;
        }
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        dataTDCount++;
        TransferContext->PendingTds++;
        SET_NEXT_TD(DeviceData, prevTd, td);

        // use direction specified in transfer
        if (TEST_FLAG(TransferParameters->TransferFlags,
                USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = nextToggle;
        td->HwTD.Token.Active = 1;

        SET_ALTNEXT_TD(DeviceData, td, statusTd);

        LOGENTRY(DeviceData,
            G, '_dta', td, lengthMapped,
            TransferParameters->TransferBufferLength);

        lengthMapped =
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,
                                      lengthMapped,
                                      &nextToggle,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        // calculate next data toggle
        // if number of packets is odd the nextToggle is 0
        // otherwise it is 1




        prevTd = td;
    }

    // last td prepared points to status
    SET_NEXT_TD(DeviceData, td, statusTd);

    //
    // now do the status phase
    //

    LOGENTRY(DeviceData, G, '_sta', statusTd, 0, dataTDCount);

    // do the status phase

    // no buffer
    statusTd->HwTD.BufferPage[0].ul = 0;

    statusTd->HwTD.Token.BytesToTransfer = 0;
    statusTd->TransferLength = 0;
    // status stage is always toggle 1
    statusTd->HwTD.Token.DataToggle = HcTOK_Toggle1;
    statusTd->HwTD.Token.Active = 1;
    statusTd->HwTD.Token.InterruptOnComplete = 1;

    // status phase is opposite data dirrection
    if (TEST_FLAG(TransferParameters->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
        statusTd->HwTD.Token.Pid = HcTOK_Out;
    } else {
        statusTd->HwTD.Token.Pid = HcTOK_In;
    }

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, td);

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, statusTd, EndpointData->DummyTd);

    // set the active bit in the setup Phase TD, this will
    // activate the transfer

    PCI_TRIGGER(DeviceData->OperationalRegisters);

    // tell the hc we have control transfers available
    // do this vefore we link in because we will try
    // to sync with the hardware
    EHCI_EnableAsyncList(DeviceData);


    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             setupTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);


    return USBMP_STATUS_SUCCESS;

 EHCI_ControlTransferNoTds:

    // Should never get here!
    USBPORT_BUGCHECK(DeviceData);
    return USBMP_STATUS_BUSY;
}


USB_MINIPORT_STATUS
EHCI_BulkTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferUrb,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
     )
{
    PHCD_TRANSFER_DESCRIPTOR firstTd, prevTd, td, tailTd;
    ULONG lengthMapped;
    ULONG need;

    // figure out how many TDs we will need
    need = TransferUrb->TransferBufferLength/(16*1024)+1;

    if (need > EndpointData->FreeTds) {
        LOGENTRY(DeviceData, G, '_BBS', EndpointData, TransferUrb, 0);
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;
    DeviceData->PendingControlAndBulk++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_BIT', EndpointData, TransferUrb, 0);

    lengthMapped = 0;
    prevTd = NULL;
    while (lengthMapped < TransferUrb->TransferBufferLength) {

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        if (TransferContext->PendingTds == 1) {
            firstTd = td;
        } else {
            SET_NEXT_TD(DeviceData, prevTd, td);
        }
        SET_ALTNEXT_TD(DeviceData, td, EndpointData->DummyTd);

        //
        // fields for data TD
        //
        td->HwTD.Token.InterruptOnComplete = 1;

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        LOGENTRY(DeviceData,
            G, '_dta', td, lengthMapped, TransferUrb->TransferBufferLength);

        lengthMapped =
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,
                                      lengthMapped,
                                      NULL,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        prevTd = td;
    }

    // special case the zero length transfer
    if (TransferUrb->TransferBufferLength == 0) {

        TEST_TRAP();

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        EHCI_ASSERT(DeviceData, TransferContext->PendingTds == 1);
        firstTd = td;
        SET_ALTNEXT_TD(DeviceData, td, EndpointData->DummyTd);

        td->HwTD.Token.InterruptOnComplete = 1;

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }

        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        // point to a dummy buffer
        td->HwTD.BufferPage[0].ul =
            td->PhysicalAddress;

        td->HwTD.Token.BytesToTransfer =
            0;
        td->TransferLength = 0;
    }

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, td, EndpointData->DummyTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, td);
    LOGENTRY(DeviceData, G,
        '_ftd',  0, 0, firstTd);

    // we now have a complete setup of TDs representing this transfer
    // (Next)    firstTd(1)->{td}(2)->{td}(3)->td(4)->dummyTd(tbit)
    // (AltNext) all point to dummyTd (tbit)
//TEST_TRAP();
    // tell the hc we have control transfers available
    EHCI_EnableAsyncList(DeviceData);

    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             firstTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_OpenBulkOrControlEndpoint(
     PDEVICE_DATA DeviceData,
     BOOLEAN Control,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, qhPhys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    ULONG tdCount, bytes;
    PHCD_TRANSFER_DESCRIPTOR dummyTd;

    LOGENTRY(DeviceData, G, '_opC', 0, 0, EndpointParameters);

    InitializeListHead(&EndpointData->DoneTdList);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    // 256 byte block used to check for overlay sync
    // problems
    EndpointData->QhChkPhys = phys;
    EndpointData->QhChk = buffer;
    RtlZeroMemory(buffer, 256);
    phys += 256;
    buffer += 256;
    bytes -= 256;

    // make the Ed
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;
    qhPhys = phys;
    // how much did we get

    phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    tdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);

    if (EndpointParameters->TransferType == Control) {
        SET_FLAG(EndpointData->Flags, EHCI_EDFLAG_NOHALT);
    }

    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        EHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);

        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);
    }
    EndpointData->FreeTds = tdCount;

    EndpointData->QueueHead =
        EHCI_InitializeQH(DeviceData,
                          EndpointData,
                          qh,
                          qhPhys);

    if (Control) {
        // use data toggle in the TDs for control
        qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Toggle_From_qTD;
        EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);
        EndpointData->HcdHeadP = NULL;

    } else {
        PHCD_TRANSFER_DESCRIPTOR dummyTd;

        qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Ignore_Toggle;
        EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_BULK_ENDPOINT);
        //qh->HwQH.EpChars.NakReloadCount = 4;

    }

    // allocate a dummy TD for short tranfsers
    // the dummy TD is usd to mark the end of the cuurent transfer
    //
    dummyTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    dummyTd->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->NextHcdTD) = NULL;
    dummyTd->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->AltNextHcdTD) = NULL;
    dummyTd->HwTD.Token.Active = 0;
    SET_FLAG(dummyTd->Flags, TD_FLAG_DUMMY);
    EndpointData->DummyTd = dummyTd;
    EndpointData->HcdHeadP = dummyTd;

    // endpoint is not active, set up the overlay
    // so that the currentTD is the Dummy

    qh->HwQH.CurrentTD.HwAddress = dummyTd->PhysicalAddress;
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
    qh->HwQH.Overlay.qTD.Token.Active = 0;

    // we now have an inactive QueueHead and a Dummy
    // tail TD

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_InsertQueueHeadInAsyncList(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR asyncQh, nextQh;
    HW_LINK_POINTER newLink;

    asyncQh = DeviceData->AsyncQueueHead;

    LOGENTRY(DeviceData, G, '_Ain', 0, Qh, asyncQh);
    EHCI_ASSERT(DeviceData, !TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));

    // ASYNC QUEUE looks like this:
    //
    //
    //            |- we insert here
    //|static QH|<->|xfer QH|<->|xfer QH|<->
    //     |                              |
    //     ---------------<->--------------

    // link new qh to the current 'head' ie
    // first transfer QH
    nextQh = QH_DESCRIPTOR_PTR(asyncQh->NextQh);

    Qh->HwQH.HLink.HwAddress =
        asyncQh->HwQH.HLink.HwAddress;
    QH_DESCRIPTOR_PTR(Qh->NextQh) = nextQh;
    QH_DESCRIPTOR_PTR(Qh->PrevQh) = asyncQh;

    QH_DESCRIPTOR_PTR(nextQh->PrevQh) = Qh;

    // put the new qh at the head of the queue

    newLink.HwAddress = Qh->PhysicalAddress;
    SET_QH(newLink.HwAddress);
    asyncQh->HwQH.HLink.HwAddress = newLink.HwAddress;
    QH_DESCRIPTOR_PTR(asyncQh->NextQh) = Qh;

    SET_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);

}


VOID
EHCI_RemoveQueueHeadFromAsyncList(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Remove a aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh, asyncQh;
    HW_LINK_POINTER newLink;
    HW_LINK_POINTER asyncHwQh;
    HW_32BIT_PHYSICAL_ADDRESS tmp;
    PHC_OPERATIONAL_REGISTER hcOp;

    hcOp = DeviceData->OperationalRegisters;

    LOGENTRY(DeviceData, G, '_Arm', Qh, 0, 0);
    // if already removed bail
    if (!TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE)) {
        return;
    }

    nextQh = QH_DESCRIPTOR_PTR(Qh->NextQh);
    prevQh = QH_DESCRIPTOR_PTR(Qh->PrevQh);;

    // ASYNC QUEUE looks like this:
    //
    //|static QH|->|xfer QH|->|xfer QH|->
    //     |                            |
    //     -------------<----------------

    asyncQh = DeviceData->AsyncQueueHead;
    asyncHwQh.HwAddress = asyncQh->PhysicalAddress;
    SET_QH(asyncHwQh.HwAddress);

    // unlink
    LOGENTRY(DeviceData, G, '_ulk', Qh, prevQh, nextQh);
    newLink.HwAddress = nextQh->PhysicalAddress;
    SET_QH(newLink.HwAddress);
    prevQh->HwQH.HLink.HwAddress =
        newLink.HwAddress;
    QH_DESCRIPTOR_PTR(prevQh->NextQh) = nextQh;
    QH_DESCRIPTOR_PTR(nextQh->PrevQh) = prevQh;

    // flush the HW cache after an unlink, the scheduke
    // should be enabled if we are removeing a QH
    EHCI_AsyncCacheFlush(DeviceData);

    // we need to update the async list base address reg in case this
    // qh is the current qh, if it is we will just replace it with
    // the static version
    tmp = READ_REGISTER_ULONG(&hcOp->AsyncListAddr);

    if (tmp == Qh->PhysicalAddress) {
        WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr,
                             asyncHwQh.HwAddress);
    }

    CLEAR_FLAG(Qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
}


// figure out which sgentry a particular offset in to
// a client buffer falls
#define GET_SG_INDEX(sg, i, offset)\
    for((i)=0; (i) < (sg)->SgCount; (i)++) {\
        if ((offset) >= (sg)->SgEntry[(i)].StartOffset &&\
            (offset) < (sg)->SgEntry[(i)].StartOffset+\
                (sg)->SgEntry[(i)].Length) {\
            break;\
        }\
    }

#define GET_SG_OFFSET(sg, i, offset, sgoffset)\
    (sgoffset) = (offset) - (sg)->SgEntry[(i)].StartOffset


ULONG
EHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PULONG NextToggle,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps a data buffer to TDs according to EHCI rules

    An EHCI TD can cover up to 20k with 5 page crossing.
    Note that 20k is the most data a single td can describe

    Each sg entry represents one 4k EHCI 'page'

x = pagebreak
c = current ptr
b = buffer start
e = buffer end


    {..sg[sgIdx]..}
b...|---
    x--c----
    [  ]
        \
         sgOffset
[      ]
        \
         LengthMapped


Worst case for 20k transfer has 5 page breaks and requires
but 6 bp entries

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}{..sg5..}
    |        |        |        |        |        |        |
    x--------x--------x--------x--------x--------x--------x
        b-------------------------------------------->e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>



case 1: (<6 sg entries remain)
    (A)- transfer < 16k,  page breaks (if c=b sgOffset = 0)

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}
    |        |        |        |        |        |
    x--------x--------x--------x--------x--------x
        b------------------------------------>e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
        [.................iTD.................]

    (B)- last part of a transfer

             {..sgN..}{.sgN+1.}{.sgN+2.}{.sgN+3.}{.sgN+4.}
             |        |        |        |        |        |
             x--------x--------x--------x--------x--------x
       b.....|.c------------------------------------->e
             <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
               [..................iTD.................]

case 2:  (>5 sg entries remain)
    (A)- transfer > 20k, first part of a large transfer

    {..sg0..}{..sg1..}{..sg2..}{..sg3..}{..sg4..}{..sg5..}
    |        |        |        |        |        |        |
    x--------x--------x--------x--------x--------x--------x
        b-------------------------------------------->e
    <..bp0..><..bp1..><..bp2..><..bp3..><..bp4..>
        [....................iTD................]

    (B)- continuation of a large transfer


Interesting DMA tests (USBTEST):

    length, offset - cases hit


Arguments:

Returns:

    LengthMapped

--*/
{
    ULONG sgIdx, sgOffset, bp, i;
    ULONG lengthThisTd;
    PTRANSFER_PARAMETERS tp;

    // A TD can have up to 5 page crossing.  This means we
    // can put 5 sg entries in to one TD.

    // point to first entry

    LOGENTRY(DeviceData, G, '_Mpr', TransferContext,
        0, LengthMapped);

    EHCI_ASSERT(DeviceData, SgList->SgCount != 0);

    tp = TransferContext->TransferParameters;

    GET_SG_INDEX(SgList, sgIdx, LengthMapped);
    LOGENTRY(DeviceData, G, '_Mpp', SgList, 0, sgIdx);
    EHCI_ASSERT(DeviceData, sgIdx < SgList->SgCount);

    if ((SgList->SgCount-sgIdx) < 6) {
        // first case, <6 entries left
        // ie <20k, we can fit this in
        // a single TD.

#if DBG
        if (sgIdx == 0) {
            // case 1A
            // USBT dma test length 4096, offset 0
            // will hit this case
            // TEST_TRAP();
            LOGENTRY(DeviceData, G, '_c1a', SgList, 0, sgIdx);
        } else {
            // case 1B
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c1b', SgList, 0, sgIdx);
            //TEST_TRAP();
        }
#endif
        lengthThisTd = tp->TransferBufferLength - LengthMapped;

        // compute offset into this TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped);

        // adjust for the amount of buffer consumed by the
        // previous TD

        // sets current offset and address at the same time
        Td->HwTD.BufferPage[0].ul =
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + sgOffset;

        i = sgIdx+1;
        for (bp = 1; bp < 5 && i < SgList->SgCount; bp++,i++) {
            Td->HwTD.BufferPage[bp].ul =
                SgList->SgEntry[i].LogicalAddress.Hw32;
            EHCI_ASSERT(DeviceData, Td->HwTD.BufferPage[bp].CurrentOffset == 0);
        }

        LOGENTRY(DeviceData, G, '_sg1', Td->HwTD.BufferPage[0].ul, 0,
            0);

    } else {
        // second case, >=6 entries left
        // we will need more than one TD
        ULONG adjust, packetCount;
#if DBG
        if (sgIdx == 0) {
            // case 2A
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2a', SgList, 0, sgIdx);
            //TEST_TRAP();
        } else {
            // case 2B
            // USBT dma test length 12288 offset 1
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2b', SgList, 0, sgIdx);
            //TEST_TRAP();
        }
#endif
        // sg offset is the offset in to the current TD to start
        // using
        // ie it is the number of bytes already consumed by the
        // previous td
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped);
#if DBG
        if (sgIdx == 0) {
             EHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif
        //
        // consume the next 4 sgEntries
        //

        // sets currentOffset at the same time
        Td->HwTD.BufferPage[0].ul =
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32+sgOffset;
        lengthThisTd = EHCI_PAGE_SIZE - Td->HwTD.BufferPage[0].CurrentOffset;

        i = sgIdx+1;
        for (bp = 1; bp < 5; bp++,i++) {
            Td->HwTD.BufferPage[bp].ul =
                SgList->SgEntry[i].LogicalAddress.Hw32;
            EHCI_ASSERT(DeviceData, Td->HwTD.BufferPage[bp].CurrentOffset == 0);
            EHCI_ASSERT(DeviceData, i < SgList->SgCount);
            lengthThisTd += EHCI_PAGE_SIZE;
        }

        // round TD length down to the highest multiple
        // of max_packet size

        packetCount = lengthThisTd/MaxPacketSize;
        LOGENTRY(DeviceData, G, '_sg2', MaxPacketSize, packetCount, lengthThisTd);

        adjust = lengthThisTd - packetCount*MaxPacketSize;

        if (adjust) {
            lengthThisTd-=adjust;
            LOGENTRY(DeviceData, G, '_adj', adjust, lengthThisTd, 0);
        }

        if (NextToggle) {
        // calculate next data toggle if requested
        // two cases
        // case 1: prev NextToggle is 1
            // if number of packets is odd the nextToggle is 0
            // otherwise it is 1
        // case 2: prev NextToggle is 0
            // if number of packets is odd the nextToggle is 1
            // otherwise it is 0

        // so if packet count is even the value remains unchanged
        // otherwise we have to toggle it.
            if (packetCount % 2) {
                // packet count this TD is odd
                *NextToggle = (*NextToggle) ? 0 : 1;
            }
        }

        EHCI_ASSERT(DeviceData, lengthThisTd != 0);
        EHCI_ASSERT(DeviceData, lengthThisTd >= SgList->SgEntry[sgIdx].Length);

    }

    LengthMapped += lengthThisTd;
    Td->HwTD.Token.BytesToTransfer =
            lengthThisTd;
    Td->TransferLength = lengthThisTd;

    LOGENTRY(DeviceData, G, '_Mp1', LengthMapped, lengthThisTd, Td);

    return LengthMapped;
}


VOID
EHCI_SetAsyncEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHC_OPERATIONAL_REGISTER hcOp;
    ENDPOINT_TRANSFER_TYPE epType;

    qh = EndpointData->QueueHead;

    epType = EndpointData->Parameters.TransferType;

    switch(State) {
    case ENDPOINT_ACTIVE:
        if (epType == Interrupt) {
            // now insert the qh in the schedule
            EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                              EndpointData);

        } else {
            // put queue head in the schedule
            EHCI_InsertQueueHeadInAsyncList(DeviceData,
                                            EndpointData->QueueHead);
        }
        break;

    case ENDPOINT_PAUSE:
        // remove queue head from the schedule
        if (epType == Interrupt) {
            EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                                 EndpointData);
        } else {
            EHCI_RemoveQueueHeadFromAsyncList(DeviceData,
                                              EndpointData->QueueHead);
        }
        break;

    case ENDPOINT_REMOVE:
        qh->QhFlags |= EHCI_QH_FLAG_QH_REMOVED;

        if (epType == Interrupt) {
            EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                                 EndpointData);
        } else {
            EHCI_RemoveQueueHeadFromAsyncList(DeviceData,
                                              EndpointData->QueueHead);
        }

        // generate a cache flush after we remove so the the HW
        // does not have the QH cached
        EHCI_InterruptNextSOF(DeviceData);

        break;

    default:

        TEST_TRAP();
    }

    EndpointData->State = State;
}


MP_ENDPOINT_STATUS
EHCI_GetAsyncEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATUS status;

    status = ENDPOINT_STATUS_RUN;

    if (TEST_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED)) {
        status = ENDPOINT_STATUS_HALT;
    }

    LOGENTRY(DeviceData, G, '_gps', EndpointData, status, 0);

    return status;
}


VOID
EHCI_SetAsyncEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    LOGENTRY(DeviceData, G, '_set', EndpointData, Status, 0);

    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        CLEAR_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);

        qh->HwQH.Overlay.qTD.Token.Halted = 0;
        break;

    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }
}


VOID
EHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    PTRANSFER_PARAMETERS tp;
    USBD_STATUS usbdStatus;
    ULONG byteCount;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);
    ASSERT_TRANSFER(DeviceData, transferContext);

    tp = transferContext->TransferParameters;
    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {
        LOGENTRY(DeviceData, G, '_Ktd', transferContext,
                         0,
                         Td);

        goto free_it;
    }

    // completion status for this TD?
    // since the endpoint halts on error the  error
    // bits should have been written back to the TD
    // we use these bits to dermine the error
    if (Td->HwTD.Token.Halted == 1) {
        usbdStatus = EHCI_GetErrorFromTD(DeviceData,
                                         endpointData,
                                         Td);
    } else {
        usbdStatus = USBD_STATUS_SUCCESS;
    }

    LOGENTRY(DeviceData, G, '_Dtd', transferContext,
                         usbdStatus,
                         Td);

    byteCount = Td->TransferLength -
        Td->HwTD.Token.BytesToTransfer;

    LOGENTRY(DeviceData, G, '_tln', byteCount,
        Td->TransferLength, Td->HwTD.Token.BytesToTransfer);

    if (Td->HwTD.Token.Pid != HcTOK_Setup) {

        // data or status phase of a control transfer or a bulk/int
        // data transfer
        LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, byteCount);

        transferContext->BytesTransferred += byteCount;

    }

    // note that we only set transferContext->UsbdStatus
    // if we find a TD with an error this will cause us to
    // record the last TD with an error as the error for
    // the transfer.
    if (USBD_STATUS_SUCCESS != usbdStatus) {

        // map the error to code in USBDI.H
        transferContext->UsbdStatus =
            usbdStatus;

        LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
    }

free_it:

    // mark the TD free
    EHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        endpointData->PendingTransfers--;

        if (endpointData->Parameters.TransferType == Bulk ||
            endpointData->Parameters.TransferType == Control) {

            USBCMD cmd;
            PHC_OPERATIONAL_REGISTER hcOp;

            hcOp = DeviceData->OperationalRegisters;
            DeviceData->PendingControlAndBulk--;

            cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

            if (DeviceData->PendingControlAndBulk == 0 &&
                cmd.IntOnAsyncAdvanceDoorbell == 0 &&
                TEST_FLAG(DeviceData->Flags, EHCI_DD_EN_IDLE_EP_SUPPORT)) {
                EHCI_DisableAsyncList(DeviceData);
            }
        }
//if (transferContext->BytesTransferred == 0 &&
//    endpointData->Parameters.TransferType == Bulk) {
//    TEST_TRAP();
//}
        LOGENTRY(DeviceData, G, '_cpt',
            transferContext->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);


        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  tp,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}


USBD_STATUS
EHCI_GetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    Maps the error bits in the TD to a USBD_STATUS code

Arguments:

Return Value:

--*/

{
    LOGENTRY(DeviceData, G, '_eTD', Td->HwTD.Token.ul, Td, 0);

    EHCI_ASSERT(DeviceData, Td->HwTD.Token.Halted == 1);
        //ULONG MissedMicroFrame:1; // 2
        //ULONG XactErr:1;          // 3
        //ULONG BabbleDetected:1;   // 4
        //ULONG DataBufferError:1;  // 5

    if (Td->HwTD.Token.XactErr) {
        LOGENTRY(DeviceData, G, '_mp1', 0, 0, 0);

        return USBD_STATUS_XACT_ERROR;
    }

    if (Td->HwTD.Token.BabbleDetected) {
        LOGENTRY(DeviceData, G, '_mp2', 0, 0, 0);

        return USBD_STATUS_BABBLE_DETECTED;
    }

    if (Td->HwTD.Token.DataBufferError) {
        LOGENTRY(DeviceData, G, '_mp3', 0, 0, 0);

        return USBD_STATUS_DATA_BUFFER_ERROR;
    }

    if (Td->HwTD.Token.MissedMicroFrame) {
        LOGENTRY(DeviceData, G, '_mp6', 0, 0, 0);
        return USBD_STATUS_XACT_ERROR;
    }

    // no bit set -- treat as a stall
    LOGENTRY(DeviceData, G, '_mp4', 0, 0, 0);
    return USBD_STATUS_STALL_PID;

}


VOID
EHCI_AbortAsyncTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT AbortTransferContext
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete ant associated transfers

Arguments:

Return Value:

--*/
{

    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_32BIT_PHYSICAL_ADDRESS abortTdPhys;
    PTRANSFER_CONTEXT currentTransfer;
    ULONG byteCount;

    qh = EndpointData->QueueHead;

    // The endpoint should not be in the schedule

    LOGENTRY(DeviceData, G, '_abr', qh, AbortTransferContext, EndpointData->HcdHeadP);
    EHCI_ASSERT(DeviceData, !TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));

    // one less pending transfer
    EndpointData->PendingTransfers--;

    // our mission now is to remove all TDs associated with
    // this transfer

    // get the last known head, we update the head when we process
    // (AKA poll) the enopoint.
    // walk the list to the tail (dummy) TD

    // find the transfer we wish to cancel...

    // walk the list and find the first TD belonging
    // to this transfer

    // cases to handle
    // case 1 this is the first transfer in the list
    // case 2 this is a middle transfer in the list
    // case 3 this is the last transfer in the list
    // case 4 transfer is not in the list

    td = EndpointData->HcdHeadP;

    ASSERT_TD(DeviceData, td);

    if (TRANSFER_CONTEXT_PTR(td->TransferContext) == AbortTransferContext) {

        // case 1
        byteCount = 0;

        while (td != EndpointData->DummyTd &&
               TRANSFER_CONTEXT_PTR(td->TransferContext) == AbortTransferContext) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            // see if any data has been transferred
            byteCount += (td->TransferLength -
                td->HwTD.Token.BytesToTransfer);

            tmp = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            EHCI_FREE_TD(DeviceData, EndpointData, tmp)
        }

        if (byteCount) {
            AbortTransferContext->BytesTransferred += byteCount;
        }

        // td now points to the 'next transfer TD'

        // this puts us in the 'advance queue' state
        // ie overlay is !active && !halted, update the
        // overlay area as appropriate.
        //
        // NOTE: the hw is not accessing the qh at this time

        // do not zero the queue head because this will
        // trash the state of the data toggle
        //RtlZeroMemory(&qh->HwQH.Overlay.qTD,
        //              sizeof(qh->HwQH.Overlay.qTD));

        // point at the waste area to check for sync problems
        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
            td->HwTD.AltNext_qTD.HwAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
            td->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;

        EndpointData->HcdHeadP = td;

    } else {

        PHCD_TRANSFER_DESCRIPTOR prevTd, nextTd;

        // determine the current transfer in the overlay
        EHCI_ASSERT(DeviceData, qh->HwQH.CurrentTD.HwAddress);

        currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                USBPORT_PHYSICAL_TO_VIRTUAL(qh->HwQH.CurrentTD.HwAddress,
                                            DeviceData,
                                            EndpointData);
        currentTransfer =
                TRANSFER_CONTEXT_PTR(currentTd->TransferContext);

        LOGENTRY(DeviceData, G, '_Act', currentTransfer,
            currentTd, EndpointData->HcdHeadP);

        // case 2, 3

        // walk from the head to the first td of the transfer
        // we are interested in.

        prevTd = td = EndpointData->HcdHeadP;
        while (td != NULL) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            if (TRANSFER_CONTEXT_PTR(td->TransferContext) == AbortTransferContext) {
                break;
            }

            prevTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            LOGENTRY(DeviceData, G, '_nxt', prevTd, td, 0);

        }
        LOGENTRY(DeviceData, G, '_atd', 0, td, 0);

        abortTdPhys = td->PhysicalAddress;
        // now walk to the first td of the next transfer, free
        // TDs for this transfer as we go
        while (td != NULL &&
               TRANSFER_CONTEXT_PTR(td->TransferContext) == AbortTransferContext) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            tmp = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            EHCI_FREE_TD(DeviceData, EndpointData, tmp);
        }

        nextTd = td;

        LOGENTRY(DeviceData, G, '_Apn', prevTd,
            nextTd, abortTdPhys);

        // now link prevTd to nextTd
        if (prevTd == NULL) {
            // case 4 transfer not in the list
            // should this happen?
            TEST_TRAP();
        }

        // next TD might be dummy
        EHCI_ASSERT(DeviceData, nextTd != NULL);
        EHCI_ASSERT(DeviceData, prevTd != NULL);

//SET_NEXT_AND_ALTNEXT_TD
        SET_NEXT_TD(DeviceData, prevTd, nextTd);
        SET_ALTNEXT_TD(DeviceData, prevTd, nextTd);

        // fixup overlay area as needed,
        // if the aborted transfer was current we want to pick
        // up the next transfer

        if (currentTransfer == AbortTransferContext) {
            LOGENTRY(DeviceData, G, '_At1', currentTransfer, 0, 0);
            // aborted transfer is current, prime the
            // overlay with the next transfer

            // catch HW sync problems
            qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

            qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = nextTd->PhysicalAddress;
            qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
            qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
            qh->HwQH.Overlay.qTD.Token.Active = 0;
            // preserve halted bit

        } else if (TRANSFER_CONTEXT_PTR(prevTd->TransferContext) ==
                   currentTransfer) {
            // previous transfer was current, make sure the overlay
            // area (current transfer) does not point to a deleted td
            LOGENTRY(DeviceData, G, '_At2', currentTransfer, 0, 0);

            // check overlay
            if (qh->HwQH.Overlay.qTD.Next_qTD.HwAddress == abortTdPhys) {
                qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
                    nextTd->PhysicalAddress;
            }

            if (qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress == abortTdPhys) {
                qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
                    nextTd->PhysicalAddress;
            }

            // correct all TDs for the current transfer
            td = EndpointData->HcdHeadP;
            while (td != NULL) {

                // nextTd is firstTd of the NEXT transfer
                if (TRANSFER_CONTEXT_PTR(td->TransferContext) == currentTransfer) {
                    // alt next always points to next transfer
                    td->HwTD.AltNext_qTD.HwAddress = nextTd->PhysicalAddress;
                    SET_ALTNEXT_TD(DeviceData, td, nextTd);
                }

                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }
        }
    }
}


USB_MINIPORT_STATUS
EHCI_PokeAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;
    EHCI_ASSERT(DeviceData, qh != NULL);

    EndpointData->Parameters = *EndpointParameters;

    qh->HwQH.EpChars.DeviceAddress =
        EndpointData->Parameters.DeviceAddress;

    qh->HwQH.EpChars.MaximumPacketLength =
        EndpointData->Parameters.MaxPacketSize;

    qh->HwQH.EpCaps.HubAddress =
        EndpointData->Parameters.TtDeviceAddress;

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_LockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     ENDPOINT_TRANSFER_TYPE EpType
    )
/*++

Routine Description:

    Synchronously update the overlate area, this involves using the
    doorbell to wait for queue head to flush off the HC hardware

    the caller is responisble for resuming

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG mf, cmf;

    hcOp = DeviceData->OperationalRegisters;

    LOGENTRY(DeviceData, G, '_LKq', Qh, 0, 0);

    EHCI_ASSERT(DeviceData, !TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING));
    EHCI_ASSERT(DeviceData, DeviceData->LockQh == NULL);

    SET_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING);

    nextQh = QH_DESCRIPTOR_PTR(Qh->NextQh);
    prevQh = QH_DESCRIPTOR_PTR(Qh->PrevQh);
    ASSERT(prevQh);

    DeviceData->LockPrevQh = prevQh;
    DeviceData->LockNextQh = nextQh;
    DeviceData->LockQh = Qh;

    if (nextQh) {
        phys = nextQh->PhysicalAddress;
        SET_QH(phys);
    } else {
        phys = 0;
        SET_T_BIT(phys);
    }

    // note that we only mess with the HW nextlinks and this
    // is temporary

    // unlink this queue head
    prevQh->HwQH.HLink.HwAddress = phys;
    mf = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

    if (EpType == Interrupt) {

        do {
            cmf = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);
        } while (cmf == mf);

    } else {
        EHCI_AsyncCacheFlush(DeviceData);
    }

    LOGENTRY(DeviceData, G, '_LKx', Qh, 0, 0);


}


VOID
EHCI_AsyncCacheFlush(
     PDEVICE_DATA DeviceData
     )
/*++

Routine Description:

    Synchronously flushes the async controller cache by ringing
    the async doorbell and waiting

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
    USBSTS sts;

    hcOp = DeviceData->OperationalRegisters;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    sts.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);

    // check the real status of the async list. if disabled
    // we should not need to flush the cache.
    // 0
    if (sts.AsyncScheduleStatus == 0 &&
        cmd.AsyncScheduleEnable == 0) {
        return;
    }

    // 1->0 wait for it to go to 0
    if (sts.AsyncScheduleStatus == 1 &&
        cmd.AsyncScheduleEnable == 0) {
        do {
            sts.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
            cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
        } while (sts.AsyncScheduleStatus &&
                 cmd.ul != 0xFFFFFFFF &&
                 cmd.HostControllerRun);
        return;
    }

    // 0->1 wait for it to enable
    if (sts.AsyncScheduleStatus == 0 &&
        cmd.AsyncScheduleEnable == 1) {
        do {
            sts.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
            cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
        } while (!sts.AsyncScheduleStatus &&
                 cmd.ul != 0xFFFFFFFF &&
                 cmd.HostControllerRun);
    }

    EHCI_ASSERT(DeviceData, cmd.AsyncScheduleEnable == 1);
    EHCI_ASSERT(DeviceData, sts.AsyncScheduleStatus == 1);
    // if not enabled enable it, this would be a bug though
//    cmd.AsyncScheduleEnable = 1;

//    cmd.IntOnAsyncAdvanceDoorbell = 1;
//    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
//                         cmd.ul);

    // wait for it.
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    while (cmd.IntOnAsyncAdvanceDoorbell &&
           cmd.HostControllerRun &&
           cmd.ul != 0xFFFFFFFF) {
        KeStallExecutionProcessor(1);
        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    }
}


VOID
EHCI_UnlockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
     )
/*++

Routine Description:

    compliment to LockQueueHead, this function reactivates the qh after
    modifications are complete

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;
    HW_32BIT_PHYSICAL_ADDRESS phys;

    LOGENTRY(DeviceData, G, '_UKq', Qh, 0, 0);
    EHCI_ASSERT(DeviceData, TEST_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING));
    EHCI_ASSERT(DeviceData, DeviceData->LockQh != NULL);
    EHCI_ASSERT(DeviceData, DeviceData->LockQh == Qh);

    CLEAR_FLAG(Qh->QhFlags, EHCI_QH_FLAG_UPDATING);
    DeviceData->LockQh = NULL;

    prevQh = DeviceData->LockPrevQh;

    phys = Qh->PhysicalAddress;
    SET_QH(phys);

    prevQh->HwQH.HLink.HwAddress =  phys;

    LOGENTRY(DeviceData, G, '_UKx', Qh, 0, phys);
}


VOID
EHCI_PollActiveAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
/*++

Routine Description:

    The queue head is in the running state we will just process
    the TDs that are completed up to 'current'  if dummy goes
    current then all TDs will be complete

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_32BIT_PHYSICAL_ADDRESS tdPhys, curTdPhys;
    PTRANSFER_CONTEXT transfer;
    ULONG cf = 0;
    BOOLEAN syncWithHw;

#if DBG
    cf = EHCI_Get32BitFrameNumber(DeviceData);
#endif

    qh = EndpointData->QueueHead;
    curTdPhys =  qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK;

    LOGENTRY(DeviceData, G, '_pol', qh, cf, curTdPhys);

    EHCI_ASSERT(DeviceData, curTdPhys != 0);
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                    USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                                DeviceData,
                                                EndpointData);

    // walk the soft list of TDs and complete all TDs
    // up to the currentTD

    // get the last known head
    LOGENTRY(DeviceData, G, '_hd1',
             EndpointData->HcdHeadP,
             0,
             currentTd);

    if (currentTd == EndpointData->QhChk) {
        // endpoint is transitioning to run a transfer or
        // is pointing at the waste area, do not poll at
        // this time
        LOGENTRY(DeviceData, G, '_pl!', 0, 0, currentTd);
        return;
    }

    // only do HW sync if QH is not in schedule
    syncWithHw = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE) ?
                    TRUE : FALSE;
    // skip sync on hot remove
    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        syncWithHw = FALSE;
    }

    ASSERT_TD(DeviceData, currentTd);
    td = EndpointData->HcdHeadP;

    if (td == currentTd &&
        td != EndpointData->DummyTd) {
        // currentTd is head verify that it is not complete
        if (td->HwTD.Token.Active == 0) {
            PHCD_TRANSFER_DESCRIPTOR tmp;

            //currentTd = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            LOGENTRY(DeviceData, G, '_cAT', td, currentTd,
                qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK);

            tmp = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            if (tmp &&
                td->HwTD.Next_qTD.HwAddress != tmp->PhysicalAddress) {
                td->HwTD.Next_qTD.HwAddress = tmp->PhysicalAddress;
            }

            tmp = TRANSFER_DESCRIPTOR_PTR(td->AltNextHcdTD);
            if (tmp &&
                td->HwTD.AltNext_qTD.HwAddress != tmp->PhysicalAddress) {
                td->HwTD.AltNext_qTD.HwAddress = tmp->PhysicalAddress;
            }

            if (qh->HwQH.CurrentTD.HwAddress == td->PhysicalAddress &&
                td->HwTD.Token.Active == 0 &&
                (qh->HwQH.Overlay.qTD.Next_qTD.HwAddress !=
                    td->HwTD.Next_qTD.HwAddress ||
                 qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress !=
                    td->HwTD.AltNext_qTD.HwAddress))  {

                LOGENTRY(DeviceData, G, '_upp', qh, td, 0);

                qh->HwQH.Overlay.qTD.Next_qTD.HwAddress =
                        td->HwTD.Next_qTD.HwAddress;
                qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress =
                        td->HwTD.AltNext_qTD.HwAddress;

            }

            EHCI_InterruptNextSOF(DeviceData);
        }
    }

    while (td != currentTd) {

        EHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DUMMY));
        // TDs between head and current should not be active

        transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);
        LOGENTRY(DeviceData, G, '_dt1', td, 0, transfer);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_dtS', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }

    // now check current TD if next td is the dummy and this td is
    // not active then we need to bump the current TD to dummy and
    // complete this TD. This will only occur if this is the last TD
    // queued
    // also check if this is a short transfer on the last transfer queued,
    // in this case the AltNextHcdTd will point to dummy and we will need
    // to advance passed the skipped TDs.


    if ((TRANSFER_DESCRIPTOR_PTR(currentTd->NextHcdTD) ==
            EndpointData->DummyTd &&
         currentTd->HwTD.Token.Active == 0) ||
         // or a short packet
        (TRANSFER_DESCRIPTOR_PTR(currentTd->AltNextHcdTD) ==
            EndpointData->DummyTd &&
         currentTd->HwTD.Token.Active == 0 &&
         currentTd->HwTD.Token.BytesToTransfer != 0) ) {

        LOGENTRY(DeviceData, G, '_bmp', currentTd, 0, 0);
        // synchronize with hardware in the event this td
        // has not been completely written back

        // since we are about to trash the overlay area there should
        // be no transfer current, we use the async doorbell to wait
        // for an the async TD to be completely flushed.
        //
        // In the event of a periodic transfer the HW may have prefetched
        // the periodic list so we need to wait for the microframe counter
        // to turn over.

        if (syncWithHw) {
            EHCI_LockQueueHead(DeviceData,
                               qh,
                               EndpointData->Parameters.TransferType);
        }

        qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

        td = currentTd;
        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        if (td->HwTD.Token.BytesToTransfer != 0 &&
            TRANSFER_DESCRIPTOR_PTR(td->AltNextHcdTD) == EndpointData->DummyTd) {
            // start at first alt TD
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            // short xfer
            while (td != EndpointData->DummyTd) {
                SET_FLAG(td->Flags, TD_FLAG_SKIP);
                InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }

        }


        qh->HwQH.CurrentTD.HwAddress = EndpointData->DummyTd->PhysicalAddress;
        qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
        qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
        qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;

        EndpointData->HcdHeadP = EndpointData->DummyTd;

        if (syncWithHw) {
            EHCI_UnlockQueueHead(DeviceData,
                               qh);
        }

        // check for sync problems
        EHCI_QHCHK(DeviceData, EndpointData);

    } else {

        EHCI_ASSERT(DeviceData, td != NULL);
        EndpointData->HcdHeadP = td;
    }
}


VOID
EHCI_PollHaltedAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    HW_32BIT_PHYSICAL_ADDRESS tdPhys, curTdPhys;
    PTRANSFER_CONTEXT transfer, errTransfer;
    BOOLEAN syncWithHw;

    // we are halted probably due to an error and
    // currentTd should be the offending TD
    qh = EndpointData->QueueHead;
    curTdPhys =  qh->HwQH.CurrentTD.HwAddress & ~HW_LINK_FLAGS_MASK;

    LOGENTRY(DeviceData, G, '_plH', qh, 0, curTdPhys);
    EHCI_ASSERT(DeviceData, curTdPhys != 0);

    // only do HW sync if QH is not in schedule
    syncWithHw = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE) ?
                    TRUE : FALSE;
    // skip sync on hot remove
    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        syncWithHw = FALSE;
    }

    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
                    USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                                DeviceData,
                                                EndpointData);

    if (currentTd == EndpointData->QhChk) {
        // endpoint is transitioning to run a transfer or
        // is pointing at the waste area, do not poll at
        // this time
        LOGENTRY(DeviceData, G, '_hl!', 0, 0, currentTd);
        return;
    }

    ASSERT_TD(DeviceData, currentTd);

    // we are halted probably due to an error and
    // currentTd should be the offending TD
    // we should not error on the dummy TD
    EHCI_ASSERT(DeviceData, EndpointData->DummyTd != currentTd);


    // walk the soft list of TDs and complete all TDs
    // up to the currentTD
    td = EndpointData->HcdHeadP;
    LOGENTRY(DeviceData, G, '_hed', 0, 0, td);

    while (td != currentTd) {

        EHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DUMMY));
        // TDs between head and current should not be active

        transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);
        LOGENTRY(DeviceData, G, '_dt2', td, 0, transfer);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_d2S', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }

    // adjust 'currentTd' to be the first TD of the NEXT
    // transfer
    td = currentTd;
    errTransfer = TRANSFER_CONTEXT_PTR(td->TransferContext);

    while (TRANSFER_CONTEXT_PTR(td->TransferContext) == errTransfer) {

        LOGENTRY(DeviceData, G, '_d3D', td, 0, 0);
        if (td->HwTD.Token.Active == 1) {
            // if the TD is active then it must have been
            // skipped due to a short xfer condition
            LOGENTRY(DeviceData, G, '_d3S', td, 0, 0);
            SET_FLAG(td->Flags, TD_FLAG_SKIP);
        }

        SET_FLAG(td->Flags, TD_FLAG_DONE);

        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

    }

    EHCI_ASSERT(DeviceData, td != NULL);
    // td is now first td of next transfer
    EndpointData->HcdHeadP = currentTd = td;

    // now fix up the queue head overlay area such that the
    // next transfer will run

    if (syncWithHw) {
    // sync with the HC hardware
        EHCI_LockQueueHead(DeviceData,
                           qh,
                           EndpointData->Parameters.TransferType);
    }

    qh->HwQH.CurrentTD.HwAddress = EndpointData->QhChkPhys;

    EHCI_ASSERT(DeviceData, qh->HwQH.Overlay.qTD.Token.Halted);

    // currentTD value should be irrelevent
    // we are !active, halted
    // overlay should be !active !halted when the queue head is reset
    // ie Advance Queue state
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = td->PhysicalAddress;
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;

    if (syncWithHw) {
    // queue head can now be aceesed by HW
        EHCI_UnlockQueueHead(DeviceData,
                             qh);
    }

    // if this is a control endpoint the we need to clear the
    // halt condition
    if (TEST_FLAG(EndpointData->Flags, EHCI_EDFLAG_NOHALT)) {
        LOGENTRY(DeviceData, G, '_clH', qh, 0, 0);

        CLEAR_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);

        qh->HwQH.Overlay.qTD.Token.Active = 0;
        qh->HwQH.Overlay.qTD.Token.Halted = 0;
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0;
    }
}


VOID
EHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    This is where we poll bulk and interrupt endpoins.  BI endpoints
    use a 'dummy' TD to denote the end of the current transfer


Arguments:

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    BOOLEAN active, halted;
    PHCD_TRANSFER_DESCRIPTOR td;
    PLIST_ENTRY listEntry;
    ULONG cf = 0;

    EHCI_QHCHK(DeviceData, EndpointData);

#if DBG
    cf = EHCI_Get32BitFrameNumber(DeviceData);
#endif

    if (EndpointData->PendingTransfers == 0) {
        // if we have no transfers queued then there is
        // nothing to do
        LOGENTRY(DeviceData, G, '_poN', EndpointData, 0, cf);
        return;
    }


    //  get the queue head and a snapshot of the overlay
    qh = EndpointData->QueueHead;
    RtlCopyMemory(&overlay,
                  &qh->HwQH.Overlay.qTD,
                  sizeof(overlay));

    if (TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_QH_REMOVED)) {
        // don't check endpoint if qh has been removed
        LOGENTRY(DeviceData, G, '_qRM', EndpointData, 0, cf);
        return;
    }

    LOGENTRY(DeviceData, G, '_poo', EndpointData, 0, cf);

    //
    // Active AND Halted    -- should never happen
    // !Active AND !Halted  -- advance queue head
    // Active AND !Halted   -- executing transaction in overlay
    // !Active AND Halted   -- queue had is stopped due to an error

    halted = (BOOLEAN) overlay.Token.Halted;
    active = (BOOLEAN) overlay.Token.Active;

    if (!active && halted) {
        // queue is halted
        SET_FLAG(EndpointData->Flags, EHCI_EDFLAG_HALTED);
        EHCI_PollHaltedAsyncEndpoint(DeviceData, EndpointData);
    } else {
        // queue is active
        EHCI_PollActiveAsyncEndpoint(DeviceData, EndpointData);
    }

    // now flush all completed TDs in order of completion from
    // our 'done' List

    while (!IsListEmpty(&EndpointData->DoneTdList)) {

        listEntry = RemoveHeadList(&EndpointData->DoneTdList);


        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR,
                     DoneLink);



        EHCI_ASSERT(DeviceData, (td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)));
        EHCI_ProcessDoneAsyncTd(DeviceData,
                                td);

    }

}


VOID
EHCI_AssertQhChk(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     )
{
    PULONG p;
    ULONG i;

    p = (PULONG) EndpointData->QhChk;

    for (i=0; i<256/sizeof(*p); i++) {
        EHCI_ASSERT(DeviceData, *p == 0);
        p++;
    }
}


VOID
EHCI_SetNextTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR  LinkTd,
    PHCD_TRANSFER_DESCRIPTOR  NextTd,
    BOOLEAN SetAltNext
    )
{
    EHCI_ASSERT(DeviceData, LinkTd != NextTd);\

    if (SetAltNext) {

        do {
            LinkTd->HwTD.Next_qTD.HwAddress = NextTd->PhysicalAddress;
            LinkTd->HwTD.AltNext_qTD.HwAddress = NextTd->PhysicalAddress;
        } while (LinkTd->HwTD.Next_qTD.HwAddress  !=
                 LinkTd->HwTD.AltNext_qTD.HwAddress);
        TRANSFER_DESCRIPTOR_PTR(LinkTd->NextHcdTD) = NextTd;
        TRANSFER_DESCRIPTOR_PTR(LinkTd->AltNextHcdTD) = NextTd;

    } else {
        LinkTd->HwTD.Next_qTD.HwAddress = NextTd->PhysicalAddress;
        TRANSFER_DESCRIPTOR_PTR(LinkTd->NextHcdTD) = NextTd;
    }

}


VOID
EHCI_SetAltNextTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR  LinkTd,
    PHCD_TRANSFER_DESCRIPTOR  NextTd
    )
{
    EHCI_ASSERT(DeviceData, LinkTd != NextTd);

    LinkTd->HwTD.AltNext_qTD.HwAddress = NextTd->PhysicalAddress;

    TRANSFER_DESCRIPTOR_PTR(LinkTd->AltNextHcdTD) = NextTd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\dbg.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/


#include "common.h"



// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//EHCI_KdPrintX

#if DBG


ULONG
_cdecl
EHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\dbg.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros
    
Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// 
// Structure signatures
//

#define EHCI_TAG          'ehci'        //"EHCI"

// write to one of the reserved operational registers
// we use this to trigger the PCI analyzer
#define PCI_TRIGGER(hcOp)  WRITE_REGISTER_ULONG(&(hcOp)->PciTrigger, 0xABADBABE);


#if DBG

#define DEBUG_LOG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//
 
#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak;                           

//
// This Breakpoint means we either need to test the code path 
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<EHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }                            
                         


#define ASSERT_TRANSFER(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_EHCI_TRANSFER)

#define ASSERT_TD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_TD)
#define ASSERT_SITD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_SITD)
#define ASSERT_ITD(dd, t) EHCI_ASSERT((dd), (t)->Sig == SIG_HCD_ITD)

#define ASSERT_DUMMY_TD(dd, t) \
    EHCI_ASSERT((dd), (t)->NextHcdTD.Pointer == NULL);\
    EHCI_ASSERT((dd), (t)->AltNextHcdTD.Pointer == NULL);

ULONG
_cdecl
EHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   EHCI_KdPrint(_x_) EHCI_KdPrintX _x_

#define EHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }        

#define EHCI_QHCHK(dd, ed)  EHCI_AssertQhChk(dd, ed);

#else 

// debug macros for retail build

#define TEST_TRAP()
#define DEBUG_BREAK(dd)

#define ASSERT_TRANSFER(dd, t) 

#define ASSERT_DUMMY_TD(dd, t)
#define ASSERT_TD(dd, t) 
#define ASSERT_SITD(dd, t)
#define ASSERT_ITD(dd, t) 


#define EHCI_ASSERT(dd, exp )

#define   EHCI_KdPrint(_x_) 

#define EHCI_QHCHK(dd, ed)

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\ehci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    ehci.h

Abstract:

   Definitions from Enhanced USB 2.0  
   controller specification

Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created jdunn

--*/


#ifndef EHCI_H
#define EHCI_H

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//

// maximum time to wait for reset to go low in microseconds
#define USBEHCI_MAX_RESET_TIME  500

#define EHCI_PAGE_SIZE      0x1000

//
// Host Controler Hardware Registers as accessed in memory
//

//
// HCLENGTHVERION - Capability Register Length / Interface Versoin Number
//

typedef union _HCLENGTHVERSION {
   ULONG                   ul;
   struct {                 
      ULONG                 HcCapLength:8;                      // 0-7
      ULONG                 Reserved:8;                         // 8-15
      ULONG                 HcVersion:16;                       // 16-31
   };
} HCLENGTHVERSION, *PHCLENGTHVERSION;

C_ASSERT((sizeof(HCLENGTHVERSION) == sizeof(ULONG)));

//
// HCSPARAMS - Structural Parameters
//

typedef union _HCSPARAMS {
   ULONG                   ul;
   struct {                 
      ULONG                 NumberOfPorts:4;                    // 0-3
      ULONG                 PortPowerControl:1;                 // 4
      ULONG                 Reserved1:3;                        // 5-7
      ULONG                 NumberOfPortsPerCompConroller:4;    // 8-11
      ULONG                 NumberOfCompControllers:4;          // 12-15
      ULONG                 PortLEDs:1;                         // 16
      ULONG                 Reserved2:15;                       // 17-31
   };
} HCSPARAMS, *PHCSPARMS;

C_ASSERT((sizeof(HCSPARAMS) == sizeof(ULONG)));

//
// HCCPARAMS - Capability Parameters
//

typedef union _HCCPARAMS {
   ULONG                   ul;
   struct {                 
      ULONG                 Bit64Addressing:1;      // 0
      ULONG                 ProgramableFrameList:1; // 1
      ULONG                 AsynSchedulePark:1;     // 2
      ULONG                 Reserved1:1;            // 3
      ULONG                 IsochronousThreshold:4; // 4-7
      ULONG                 EECP:8; // 8-15
      ULONG                 Reserved2:16;           // 16-31
   };
} HCCPARAMS, *PHCCPARMS;

C_ASSERT((sizeof(HCCPARAMS) == sizeof(ULONG)));

//
//  EECP Register
//

#define EECP_CAP_RESERVED           0x00
#define EECP_PRE_OS_HANDOFF         0x01

typedef union _HC_EECP {
   ULONG                   ul;
   struct {                 
      ULONG                 CapId:8;          // 0-7
      ULONG                 NextCap:8;        // 8-15
      ULONG                 CapData:16;       // 16-31
   };
} HC_EECP, *PHC_EECP;

C_ASSERT((sizeof(HC_EECP) == sizeof(ULONG)));

//
// EECP BIOS Registers
//

typedef union _USBLEGSUP {
   ULONG                   ul;
   struct {                 
      ULONG                 CapId:8;          // 0-7
      ULONG                 NextCap:8;        // 8-15
      ULONG                 HcBIOSowned:1;    // 16
      ULONG                 Reserved1:7;      // 17-23
      ULONG                 HcOSowned:1;      // 24
      ULONG                 Reserved2:7;      // 25-31
   };
} USBLEGSUP, *PUSBLEGSUP;

C_ASSERT((sizeof(USBLEGSUP) == sizeof(ULONG)));

typedef union _USBLEGCTLSTS {
   ULONG                   ul;
   struct {                 
      ULONG                 UsbSMIEnable:1;             // 0
      ULONG                 SMIonUSBErrorEn:1;          // 1  
      ULONG                 SMIonPortChangeEn:1;        // 2  
      ULONG                 SMIonFrameListRolloverEn:1; // 3  
      
      ULONG                 SMIonHostSystemErrorEn:1;   // 4  
      ULONG                 SMIonAsyncAdvanceEn:1;      // 5  
      ULONG                 Reserved1:7;                // 6-12
      ULONG                 SMIonOSownershipEn:1;       // 13  
      ULONG                 SMIonPCICommandEn:1;        // 14  
      ULONG                 SMIonBAREn:1;               // 15  

      ULONG                 SMIonUSBComplete:1;         // 16  
      ULONG                 SMIonUSBError:1;            // 17  
      ULONG                 SMIonPortChange:1;          // 18
      ULONG                 SMIonFrameListRollover:1;   // 19

      ULONG                 SMIonHostSystemError:1;     // 20
      ULONG                 SMIonAsyncAdvance:1;        // 21
      ULONG                 Reserved2:7;                // 22-28
      ULONG                 SMIonOSownership:1;         // 29
      ULONG                 SMIonPCIcommand:1;          // 30
      ULONG                 SMIonBAR:1;                 // 31
   };
} USBLEGCTLSTS, *PUSBLEGCTLSTS;

C_ASSERT((sizeof(USBLEGCTLSTS) == sizeof(ULONG)));

typedef struct _USB_LEGACYBIOS_REGISTERS {

   USBLEGSUP                Caps;
   USBLEGCTLSTS             CtlSts;
   
} USB_LEGACYBIOS_REGISTERS, *PUSB_LEGACYBIOS_REGISTERS;

C_ASSERT((sizeof(USB_LEGACYBIOS_REGISTERS) == (2 * sizeof(ULONG))));


//
// CAPABILITIES REGISTER
//

typedef struct _HC_CAPABILITIES_REGISTER {

   HCLENGTHVERSION          HcLengthVersion;
   HCSPARAMS                HcStructuralParameters;
   HCCPARAMS                HcCapabilityParameters;
   
} HC_CAPABILITIES_REGISTER, *PHC_CAPABILITIES_REGISTER;

C_ASSERT((sizeof(HC_CAPABILITIES_REGISTER) == (3 * sizeof(ULONG))));

//
// USBCMD - USB Command Register
//

//
// Definitions for HC_QTD_TOKEN.Pid
//

#define HcCmd_FrameListSizeIs1024         0    
#define HcCmd_FrameListSizeIs512          1    
#define HcCmd_FrameListSizeIs256          2    


typedef union _USBCMD {

    ULONG                   ul;
    struct {                
        ULONG               HostControllerRun:1;        // 0
        ULONG               HostControllerReset:1;      // 1
        ULONG               FrameListSize:2;            // 2-3
        ULONG               PeriodicScheduleEnable:1;   // 4
        ULONG               AsyncScheduleEnable:1;      // 5
        ULONG               IntOnAsyncAdvanceDoorbell:1;// 6
        ULONG               HostControllerLightReset:1; // 7
        ULONG               Reserved1:8;                // 8-15
        ULONG               InterruptThreshold:8;       // 16-23
        ULONG               Reserved2:8;                // 24-31
    };
    
} USBCMD, *PUSBCMD;

C_ASSERT((sizeof(USBCMD) == sizeof(ULONG)));

//
// USBSTS - USB Status Register
//

#define HcInterruptStatusMask                   0x0000003F     

#define HcInt_IntOnasyncAdvance                 0x00000020
#define HcInt_HostSystemError                   0x00000010
#define HcInt_FrameListRollover                 0x00000008
#define HcInt_PortChangeDetect                  0x00000004
#define HcInt_UsbError                          0x00000002
#define HcInt_UsbInterrupt                      0x00000001

typedef union _USBSTS {

    ULONG                   ul;
    struct {                
        // controller interrupt status bits
        ULONG               UsbInterrupt:1;                 // 0
        ULONG               UsbError:1;                     // 1
        ULONG               PortChangeDetect:1;             // 2
        ULONG               FrameListRollover:1;            // 3
        ULONG               HostSystemError:1;              // 4
        ULONG               IntOnAsyncAdvance:1;            // 5
        ULONG               ReservedStatus:6;               // 6-11
        
        // controller status
        ULONG               HcHalted:1;                     // 12
        ULONG               Reclimation:1;                  // 13
        ULONG               PeriodicScheduleStatus:1;       // 14
        ULONG               AsyncScheduleStatus:1;          // 15
        ULONG               Reserved:16;                    // 16-31
    };
    
} USBSTS, *PUSBSTS;

C_ASSERT((sizeof(USBSTS) == sizeof(ULONG)));


//
// USBINTR - USB Interrupt Enable Register
//

typedef union _USBINTR {

    ULONG                   ul;
    struct {                
        ULONG               UsbInterrupt:1;                 // 0
        ULONG               UsbError:1;                     // 1
        ULONG               PortChangeDetect:1;             // 2
        ULONG               FrameListRollover:1;            // 3
        ULONG               HostSystemError:1;              // 4
        ULONG               IntOnAsyncAdvance:1;            // 5
        //HostSystemError
        //HostControllerProcessError
        ULONG               Reserved:26;                   // 6-31
    };
    
} USBINTR, *PUSBINTR;

C_ASSERT((sizeof(USBINTR) == sizeof(ULONG)));

//
// FRNUM - Frame Number Register
//

typedef union _FRINDEX {

    ULONG                   ul;
    struct {                
        ULONG               FrameListCurrentIndex:14;
        ULONG               Reserved:18;
    };
    
} FRINDEX, *PFRINDEX;

C_ASSERT((sizeof(FRINDEX) == sizeof(ULONG)));

//
// CONFIGFLAG - 
//

typedef union _CONFIGFLAG {

    ULONG                   ul;
    struct {                
        ULONG               RoutePortsToEHCI:1;
        ULONG               Reserved:31;
    };
    
} CONFIGFLAG, *PCONFIGFLAG;

C_ASSERT((sizeof(CONFIGFLAG) == sizeof(ULONG)));


//
// PORTSC - Port Status and Control Register
//

typedef union _PORTSC {

    ULONG                   ul;
    struct {                
        ULONG               PortConnect:1;          // 0
        ULONG               PortConnectChange:1;    // 1
        ULONG               PortEnable:1;           // 2
        ULONG               PortEnableChange:1;     // 3   
        
        ULONG               OvercurrentActive:1;    // 4
        ULONG               OvercurrentChange:1;    // 5
        ULONG               ForcePortResume:1;      // 6
        ULONG               PortSuspend:1;          // 7
        
        ULONG               PortReset:1;            // 8
        ULONG               HighSpeedDevice:1;      // 9
        ULONG               LineStatus:2;           // 10-11   
        
        ULONG               PortPower:1;            // 12
        ULONG               PortOwnedByCC:1;        // 13
        ULONG               PortIndicator:2;        // 14-15
        
        ULONG               PortTestControl:4;      // 16-19  
        
        ULONG               WakeOnConnect:1;        // 20
        ULONG               WakeOnDisconnect:1;     // 21
        ULONG               WakeOnOvercurrent:1;    // 22
        ULONG               Reserved:9;             // 23-31
    };
    
} PORTSC, *PPORTSC;

C_ASSERT((sizeof(PORTSC) == sizeof(ULONG)));




// OPERATIONAL REGISTER

typedef struct _HC_OPERATIONAL_REGISTER {

    // 00h
    USBCMD                          UsbCommand;     
    USBSTS                          UsbStatus;     
    USBINTR                         UsbInterruptEnable;    
    FRINDEX                         UsbFrameIndex;

    // 10h
    HW_32BIT_PHYSICAL_ADDRESS       SegmentSelector;
    HW_32BIT_PHYSICAL_ADDRESS       PeriodicListBase;     
    HW_32BIT_PHYSICAL_ADDRESS       AsyncListAddr;
    //ULONG                           Reserved;
    ULONG                           PciTrigger;

    // 20h
    ULONG                           ReservedB0[4];

    // 30h
    ULONG                           ReservedB1[4];

    // 40h
    CONFIGFLAG                      ConfigFlag;
    PORTSC                          PortRegister[1];
   
} HC_OPERATIONAL_REGISTER, *PHC_OPERATIONAL_REGISTER;


//#define HcDTYPE_iTD                 0    // iterative TD
//#define HcDTYPE_QH                  1    // queue head
//#define HcDTYPE_siTD                2    // isochronousTD

// note that bits 0,1,2 are used for QH type
// bits 4, and 5 are used for the nak cnt in the 
// transfer overlay
#define HW_LINK_FLAGS_MASK          0x0000001f

typedef union _HW_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;         
// this screws up the 64-bit compiler    
#if 0   
   struct {
        ULONG Terminate:1;                   // 0
        ULONG DType:2;                       // 1-2
        ULONG ReservedMBZ:2;                 // 3-4
        ULONG PhysicalAddressBits:27;        // 5-31
   };
#endif   
   
} HW_LINK_POINTER, *PHW_LINK_POINTER;

#define EHCI_TERMINATE_BIT      0x00000001 // 00001
#define EHCI_DTYPE_QH           0x00000002 // 00010
#define EHCI_DTYPE_SITD         0x00000004 // 00100
#define EHCI_RsvdMBZ            0x00000018 // 11000
#define EHCI_DTYPE_Mask         0x0000001E // 11110

#define SET_T_BIT(addr) ((addr) |= EHCI_TERMINATE_BIT)
#define SET_SITD(addr) do {\
                        ((addr) &= ~EHCI_DTYPE_Mask);\
                        ((addr) |= EHCI_DTYPE_SITD);\
                       } while (0)

#define SET_QH(addr)  do {\
                        ((addr) &= ~EHCI_DTYPE_Mask);\
                        ((addr) |= EHCI_DTYPE_QH);\
                      } while (0)

C_ASSERT((sizeof(HW_LINK_POINTER) == sizeof(ULONG)));

//
// Isochronous Transfer Descriptor
//

typedef union _HC_ITD_BUFFER_POINTER0 {
    ULONG ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved:1;               // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER0, *PHC_ITD_BUFFER_POINTER0;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER0) == sizeof(ULONG)));


typedef union _HC_ITD_BUFFER_POINTER1 {
    ULONG ul;
    struct {
        ULONG MaxPacketSize:11;         // 0-10
        ULONG Direction:1;              // 11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER1, *PHC_ITD_BUFFER_POINTER1;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER1) == sizeof(ULONG)));


typedef union _HC_ITD_BUFFER_POINTER2 {
    ULONG ul;
    struct {
        ULONG Multi:2;                  // 0-1
        ULONG Reserved:10;              // 2-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER2, *PHC_ITD_BUFFER_POINTER2;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER2) == sizeof(ULONG)));

typedef union _HC_ITD_BUFFER_POINTER {
    ULONG ul;
    struct {
        ULONG Reserved:12;              // 0-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_ITD_BUFFER_POINTER, *PHC_ITD_BUFFER_POINTER;

C_ASSERT((sizeof(HC_ITD_BUFFER_POINTER) == sizeof(ULONG)));


typedef union _HC_ITD_TRANSACTION {
    ULONG ul;
    struct {
        ULONG Offset:12;                // 0-11
        ULONG PageSelect:3;             // 12-14
        ULONG InterruptOnComplete:1;    // 15
        ULONG Length:12;                // 16-27
        ULONG XactError:1;              // 28
        ULONG BabbleDetect:1;           // 29
        ULONG DataBufferError:1;        // 30
        ULONG Active:1;                 // 31
    };    
} HC_ITD_TRANSACTION, *PHC_ITD_TRANSACTION;

C_ASSERT((sizeof(HC_ITD_TRANSACTION) == sizeof(ULONG)));

typedef struct _HW_ISOCHRONOUS_TD {
    HW_LINK_POINTER         NextLink;
    HC_ITD_TRANSACTION      Transaction[8];
    HC_ITD_BUFFER_POINTER0  BufferPointer0;
    HC_ITD_BUFFER_POINTER1  BufferPointer1;
    HC_ITD_BUFFER_POINTER2  BufferPointer2;
    HC_ITD_BUFFER_POINTER   BufferPointer3;
    HC_ITD_BUFFER_POINTER   BufferPointer4;
    HC_ITD_BUFFER_POINTER   BufferPointer5;
    HC_ITD_BUFFER_POINTER   BufferPointer6;
    ULONG                   BufferPointer64[7];
    ULONG                   Pad[9];
} HW_ISOCHRONOUS_TD, *PHW_ISOCHRONOUS_TD;

C_ASSERT((sizeof(HW_ISOCHRONOUS_TD) == 128));

//
// Split Transaction Isochronous Transfer Descriptor
//

typedef union _HC_SITD_CAPS {
    ULONG   ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved0:1;              // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG Reserved1:4;              // 12-15
        ULONG HubAddress:7;             // 16-22
        ULONG Reserved2:1;              // 23
        ULONG PortNumber:7;             // 24-30        
        ULONG Direction:1;              // 31
    };
} HC_SITD_CAPS, *PHC_SITD_CAPS;

C_ASSERT((sizeof(HC_SITD_CAPS) == sizeof(ULONG)));

typedef union _HC_SITD_CONTROL {
    ULONG   ul;
    struct {
        ULONG sMask:8;                  // 0-7  
        ULONG cMask:8;                  // 8-15        
        ULONG Reserved:16;              // 16-31
    };
} HC_SITD_CONTROL, *PHC_SITD_CONTROL;

C_ASSERT((sizeof(HC_SITD_CONTROL) == sizeof(ULONG)));

typedef union _HC_SITD_STATE {
    ULONG   ul;
    struct {
        ULONG Reserved0:1;              // 0
        ULONG SplitXState:1;            // 1
        ULONG MissedMicroframe:1;       // 2  
        ULONG XactErr:1;                // 3
        ULONG BabbleDetected:1;         // 4
        ULONG DataBufferError:1;        // 5
        ULONG ERR:1;                    // 6
        ULONG Active:1;                 // 7
        
        ULONG cProgMask:8;              // 8-15
        ULONG BytesToTransfer:10;       // 16-25
        ULONG Reserved1:4;              // 26-29
        ULONG PageSelect:1;             // 30        
        ULONG InterruptOnComplete:1;    // 31
    };
} HC_SITD_STATE, *PHC_SITD_STATE;

C_ASSERT((sizeof(HC_SITD_STATE) == sizeof(ULONG)));

// Tposition
#define TPOS_ALL        0
#define TPOS_BEGIN      1

typedef union _HC_SITD_BUFFER_POINTER1 {
    ULONG ul;
    struct {
        ULONG Tcount:3;                 // 0-2
        ULONG Tposition:2;              // 3-4
        ULONG Reseved:7;                // 5-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_SITD_BUFFER_POINTER1, *PHC_SITD_BUFFER_POINTER1;

C_ASSERT((sizeof(HC_SITD_BUFFER_POINTER1) == sizeof(ULONG)));

typedef union _HC_SITD_BUFFER_POINTER0 {
    ULONG ul;
    struct {
        ULONG CurrentOffset:12;         // 0-11
        ULONG BufferPointer:20;         // 12-31
    };    
} HC_SITD_BUFFER_POINTER0, *PHC_SITD_BUFFER_POINTER0;

C_ASSERT((sizeof(HC_SITD_BUFFER_POINTER0) == sizeof(ULONG)));

typedef struct _HW_SPLIT_ISOCHRONOUS_TD {
    HW_LINK_POINTER         NextLink;
    HC_SITD_CAPS            Caps;
    HC_SITD_CONTROL         Control;
    HC_SITD_STATE           State;
    HC_SITD_BUFFER_POINTER0 BufferPointer0;
    HC_SITD_BUFFER_POINTER1 BufferPointer1;
    HW_LINK_POINTER         BackPointer;
    ULONG                   BufferPointer64_0;
    ULONG                   BufferPointer64_1;
    ULONG                   Pad[7];
} HW_SPLIT_ISOCHRONOUS_TD, *PHW_SPLIT_ISOCHRONOUS_TD;


C_ASSERT((sizeof(HW_SPLIT_ISOCHRONOUS_TD) == 64));

//
// Queue Element Transfer Descriptor
//

//
// Definitions for HC_QTD_TOKEN.Pid
//

#define HcTOK_Out           0    
#define HcTOK_In            1    
#define HcTOK_Setup         2    
#define HcTOK_Reserved      3     

#define HcTOK_PingDoOut     0
#define HcTOK_PingDoPing    1     

#define HcTOK_Toggle0       0
#define HcTOK_Toggle1       1   

typedef union _HC_BUFFER_POINTER {
    ULONG ul;
    struct {
        ULONG CurrentOffset:12;     // 0-11
        ULONG BufferPointer:20;     // 12-31
    };    
} HC_BUFFER_POINTER, *PHC_BUFFER_POINTER;

C_ASSERT((sizeof(HC_BUFFER_POINTER) == sizeof(ULONG)));


typedef union _HC_QTD_TOKEN {
    ULONG   ul;
    struct {
        // status bits
        ULONG PingState:1;        // 0
        ULONG SplitXstate:1;      // 1
        ULONG MissedMicroFrame:1; // 2
        ULONG XactErr:1;          // 3
        ULONG BabbleDetected:1;   // 4
        ULONG DataBufferError:1;  // 5
        ULONG Halted:1;           // 6
        ULONG Active:1;           // 7
        
        ULONG Pid:2;                    // 8-9
        ULONG ErrorCounter:2;           // 10-11
        ULONG C_Page:3;                 // 12-14
        ULONG InterruptOnComplete:1;    // 15
        
        ULONG BytesToTransfer:15;       // 16-30        
        ULONG DataToggle:1;             // 31
    };
} HC_QTD_TOKEN, *PHC_QTD_TOKEN;

C_ASSERT((sizeof(HC_QTD_TOKEN) == sizeof(ULONG)));


typedef struct _HW_QUEUE_ELEMENT_TD {
    HW_LINK_POINTER             Next_qTD;
    HW_LINK_POINTER             AltNext_qTD;
    HC_QTD_TOKEN                Token;  
    HC_BUFFER_POINTER           BufferPage[5]; 
    ULONG                       BufferPage64[5];
    ULONG                       Pad[3];
} HW_QUEUE_ELEMENT_TD, *PHW_QUEUE_ELEMENT_TD;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 64));


typedef union HC_OVLAY_8 {
    ULONG   ul;
    struct {
        // status bits
        ULONG CprogMask:8;        // 0-7
        ULONG Buffer:24;
    };
} HC_OVLAY_8, *PHC_OVLAY_8;

C_ASSERT((sizeof(HC_OVLAY_8) == sizeof(ULONG)));

typedef union HC_OVLAY_9 {
    ULONG   ul;
    struct {
        // status bits
        ULONG fTag:5;        // 0-4
        ULONG Sbytes:7;      // 5-11
        ULONG Buffer:20;
    };
} HC_OVLAY_9, *PHC_OVLAY_9;

C_ASSERT((sizeof(HC_OVLAY_9) == sizeof(ULONG)));


typedef struct _HW_OVERLAY_AREA {
    HW_LINK_POINTER             Next_qTD;       // dw4
    HW_LINK_POINTER             AltNext_qTD;    // dw5
    HC_QTD_TOKEN                Token;          // dw6
    HC_BUFFER_POINTER           BufferPage0;    // dw7
    HC_OVLAY_8                  OverlayDw8;
    HC_OVLAY_9                  OverlayDw9;
    HC_BUFFER_POINTER           BufferPage3;
    HC_BUFFER_POINTER           BufferPage4;
    ULONG                       BufferPage64[5];
    ULONG                       Pad[3];
} HW_OVERLAY_AREA, *PHW_OVERLAY_AREA;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 64));

//
// General Transfer Descriptor
//

typedef union _HW_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD         qTD;
    HW_OVERLAY_AREA             Ov;
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 64));


//
// Definitions for HC_ENDPOINT_CHARACTERSITICS.DataToggleControl
//
#define HcEPCHAR_Ignore_Toggle         0    // ignore DT bit from incomming QTD
#define HcEPCHAR_Toggle_From_qTD       1    // DT from incomming QTD

//
// Definitions for HC_ENDPOINT_CHARACTERSITICS.EndpointSpeed
//

#define HcEPCHAR_FullSpeed      0    // 12Mbs
#define HcEPCHAR_LowSpeed       1    // 1.5Mbs
#define HcEPCHAR_HighSpeed      2    // 480Mbs
#define HcEPCHAR_Reserved       3     


typedef union _HC_ENDPOINT_CHARACTERSITICS {
    ULONG   ul;
    struct {
        ULONG DeviceAddress:7;          // 0-6
        ULONG Reserved1:1;              // 7
        ULONG EndpointNumber:4;         // 8-11
        ULONG EndpointSpeed:2;          // 12-13
        ULONG DataToggleControl:1;      // 14
        ULONG HeadOfReclimationList:1;  // 15
        ULONG MaximumPacketLength:11;   // 16-26
        ULONG ControlEndpointFlag:1;    // 27
        ULONG NakReloadCount:4;         // 28-31
    } ;   
} HC_ENDPOINT_CHARACTERSITICS, *PHC_ENDPOINT_CHARACTERSITICS;

C_ASSERT((sizeof(HC_ENDPOINT_CHARACTERSITICS) == sizeof(ULONG)));


typedef union _HC_ENDPOINT_CAPABILITIES {
    ULONG   ul;
    struct {
        ULONG InterruptScheduleMask:8;  // 0-7
        ULONG SplitCompletionMask:8;    // 8-15
        ULONG HubAddress:7;             // 16-22
        ULONG PortNumber:7;             // 23-29
        ULONG HighBWPipeMultiplier:2;   // 30-31
    };
} HC_ENDPOINT_CAPABILITIES, *PHC_ENDPOINT_CAPABILITIES;

C_ASSERT((sizeof(HC_ENDPOINT_CAPABILITIES) == sizeof(ULONG)));

//
// Queue Head Descriptor
//

typedef struct _HW_QUEUEHEAD_DESCRIPTOR {

   HW_LINK_POINTER                  HLink;         // horizontal link ptr dw:0
   HC_ENDPOINT_CHARACTERSITICS      EpChars;       // dw:1
   HC_ENDPOINT_CAPABILITIES         EpCaps;        // dw:2
   HW_LINK_POINTER                  CurrentTD;     // dw:3
   HW_TRANSFER_DESCRIPTOR           Overlay;       // dw:4-11
   
} HW_QUEUEHEAD_DESCRIPTOR, *PHW_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HW_QUEUEHEAD_DESCRIPTOR) == 80));

#include <POPPACK.H>

#endif /* EHCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\iso.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   iso.c

Abstract:

   miniport transfer code for interrupt endpoints

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-01 : created, jdunn

--*/

#include "common.h"

/*
    We build a table of 32 TDs for iso endpoints and insert them in the
    schedule, these TDs are static -- we only change the buffer pointers.

    The TD 'table' represents a 32ms snapshot of time.

    We end up with each iso endpoint siTD list as a column in the table



frame  dummyQH iso1  iso2  iso3  staticQH
  1             |     |     |       |---> (periodic lists)
  2             |     |     |       |
  3             |     |     |       |
  4             |     |     |       |
...             |     |     |       |
                |     |     |       |
1024            |     |     |       |
*/


#define     ISO_SCHEDULE_SIZE       32
#define     ISO_SCHEDULE_MASK       0x1f

#define HIGHSPEED(ed) ((ed)->Parameters.DeviceSpeed == HighSpeed ? TRUE : FALSE)

VOID
EHCI_RebalanceIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    PHCD_SI_TRANSFER_DESCRIPTOR siTd;
    ULONG i, f;
    ULONG currentFrame;

    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    // should only have to deal with s-mask and c-mask changes

    EHCI_ASSERT(DeviceData, !HIGHSPEED(EndpointData));

    //NOTE: irql should be raised for us

    // update internal copy of parameters
    EndpointData->Parameters = *EndpointParameters;


    f = currentFrame & ISO_SCHEDULE_MASK;
    for (i=0; i<EndpointData->TdCount; i++) {

        siTd = &EndpointData->SiTdList->Td[f];

        siTd->HwTD.Control.cMask =
            EndpointParameters->SplitCompletionMask;
        siTd->HwTD.Control.sMask =
            EndpointParameters->InterruptScheduleMask;

        f++;
        f &= ISO_SCHEDULE_MASK;
    }

}


VOID
EHCI_InitializeSiTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd,
    PHCD_SI_TRANSFER_DESCRIPTOR PrevSiTd,
    HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress
    )
/*++

Routine Description:

    Initailze a static SiTD for an endpoint

Arguments:

Return Value:

    none
--*/
{
    SiTd->Sig = SIG_HCD_SITD;
    SiTd->PhysicalAddress = PhysicalAddress;
    ISO_PACKET_PTR(SiTd->Packet) = NULL;

    SiTd->HwTD.Caps.ul = 0;
    SiTd->HwTD.Caps.DeviceAddress =
        EndpointParameters->DeviceAddress;
    SiTd->HwTD.Caps.EndpointNumber =
        EndpointParameters->EndpointAddress;
    SiTd->HwTD.Caps.HubAddress =
        EndpointParameters->TtDeviceAddress;
    SiTd->HwTD.Caps.PortNumber =
        EndpointParameters->TtPortNumber;
    // 1 = IN 0 = OUT
    SiTd->HwTD.Caps.Direction =
        (EndpointParameters->TransferDirection == In) ? 1 : 0;

    SiTd->HwTD.Control.ul = 0;
    SiTd->HwTD.Control.cMask =
        EndpointParameters->SplitCompletionMask;
    SiTd->HwTD.Control.sMask =
        EndpointParameters->InterruptScheduleMask;

    SiTd->HwTD.BackPointer.HwAddress =
        PrevSiTd->PhysicalAddress;

    SiTd->HwTD.State.ul = 0;
}


VOID
EHCI_InsertIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

   schedule should look like:

   DUMMYQH->ISOQH-ISOQH->INTQH

Arguments:


--*/
{
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;

    LOGENTRY(DeviceData, G, '_iAD', PrevEndpointData,
        NextEndpointData, EndpointData);

    //frameBase = DeviceData->FrameListBaseAddress;

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {

        PHCD_SI_TRANSFER_DESCRIPTOR siTd, nextSiTd;
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        PHCD_QUEUEHEAD_DESCRIPTOR dQh;
        ULONG phys;

        siTd = &EndpointData->SiTdList->Td[i&0x1f];

        // fixup next link
        if (NextEndpointData == NULL &&
            PrevEndpointData == NULL) {

            // list empty add to head
            if (i == 0) {
                EHCI_ASSERT(DeviceData, DeviceData->IsoEndpointListHead == NULL);
                DeviceData->IsoEndpointListHead = EndpointData;
                EndpointData->PrevEndpoint = NULL;
                EndpointData->NextEndpoint = NULL;
            }
            // list empty add to head

            // no iso endpoints, link to the interrupt
            // queue heads via the dummy qh
            //
            // point at the static perodic queue head pointed to
            // by the appropriate dummy
            // DUMMY->INTQH
            //  to
            // ISOTD->INTQH
            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            siTd->HwTD.NextLink.HwAddress = dQh->HwQH.HLink.HwAddress;
            HW_PTR(siTd->NextLink) = HW_PTR(dQh->NextLink);

            phys = siTd->PhysicalAddress;
            SET_SITD(phys);
            //
            // appropriate dummy should point to these TDs
            // DUMMY->INTQH, ISOTD->INTQH
            //  to
            // DUMMY->ISOTD->INTQH
            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys;
            HW_PTR(dQh->NextLink) = (PUCHAR) siTd;

        } else {

            if (NextEndpointData == NULL) {
            // tail of list, list not empty
            // add to tail
                if (i == 0) {
                    EHCI_ASSERT(DeviceData, PrevEndpointData != NULL);
                    EHCI_ASSERT(DeviceData, DeviceData->IsoEndpointListHead != NULL);

                    PrevEndpointData->NextEndpoint = EndpointData;
                    EndpointData->PrevEndpoint = PrevEndpointData;
                    EndpointData->NextEndpoint = NULL;
                }

                LOGENTRY(DeviceData, G, '_iTL', PrevEndpointData,
                        NextEndpointData, EndpointData);

                // tail of list, link to qh
                // ISOTD->INTQH
                //  to
                // ISOTD->newISOTD->INTQH
                //
                if (HIGHSPEED(PrevEndpointData)) {

                    PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;

                    PUCHAR next;

                    previTd = &PrevEndpointData->HsIsoTdList->Td[i];
                    ASSERT_ITD(DeviceData, previTd);

                    siTd = &EndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, siTd);

                    // fixup current next ptr
                    phys = previTd->HwTD.NextLink.HwAddress;
                    next = HW_PTR(previTd->NextLink);
                    siTd->HwTD.NextLink.HwAddress = phys;
                    HW_PTR(siTd->NextLink) = next;

                    // fixup prev next ptr
                    HW_PTR(previTd->NextLink) = (PUCHAR) siTd;
                    phys = siTd->PhysicalAddress;
                    SET_SITD(phys);
                    previTd->HwTD.NextLink.HwAddress = phys;

                } else  {

                    PHCD_SI_TRANSFER_DESCRIPTOR prevSiTd;
                    PUCHAR next;

                    prevSiTd = &PrevEndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, prevSiTd);

                    siTd = &EndpointData->SiTdList->Td[i&0x1f];
                    ASSERT_SITD(DeviceData, siTd);

                    if (i<32) {
                        //newISOTD->INTQH
                        phys = prevSiTd->HwTD.NextLink.HwAddress;
                        next = HW_PTR(prevSiTd->NextLink);
                        siTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(siTd->NextLink) = next;
                        LOGENTRY(DeviceData, G, '_in1', phys, next, siTd);

                        //ISOTD->newISOTD
                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        next = (PUCHAR) siTd;
                        prevSiTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(prevSiTd->NextLink) = next;

                        LOGENTRY(DeviceData, G, '_in2', phys, next, siTd);
                    }
                }

            // add to tail
            } else {
            // list not empty, not tail
            // add to middle OR head
                //
                // link to the next iso endpoint
                // ISOTD->INTQH
                //  to
                // newISOTD->ISOTD->INTQH
                if (i == 0) {
                    EHCI_ASSERT(DeviceData, NextEndpointData != NULL);
                    EndpointData->NextEndpoint = NextEndpointData;
                    NextEndpointData->PrevEndpoint = EndpointData;
                }

                // link to next
                nextSiTd = &NextEndpointData->SiTdList->Td[i&0x1f];
                phys = nextSiTd->PhysicalAddress;
                SET_SITD(phys);

                // link to the next iso endpoint
                siTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(siTd->NextLink) = (PUCHAR) nextSiTd;

                // link to prev
                if (PrevEndpointData != NULL) {
                    // middle
                    // ISOTD->ISOTD->INTQH, newISOTD->ISOTD->INTQH
                    // to
                    // ISOTD->newISOTD->ISOTD->INTQH

                    if (i == 0) {
                        PrevEndpointData->NextEndpoint = EndpointData;
                        EndpointData->PrevEndpoint = PrevEndpointData;
                    }

                    if (HIGHSPEED(PrevEndpointData)) {

                        PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;

                        previTd = &PrevEndpointData->HsIsoTdList->Td[i];
                        ASSERT_ITD(DeviceData, previTd);

                        siTd = &EndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, siTd);

                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        previTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(previTd->NextLink) = (PUCHAR) siTd;
                    } else  {

                        PHCD_SI_TRANSFER_DESCRIPTOR prevSiTd;

                        prevSiTd = &PrevEndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, prevSiTd);

                        siTd = &EndpointData->SiTdList->Td[i&0x1f];
                        ASSERT_SITD(DeviceData, siTd);

                        phys = siTd->PhysicalAddress;
                        SET_SITD(phys);
                        prevSiTd->HwTD.NextLink.HwAddress = phys;
                        HW_PTR(prevSiTd->NextLink) = (PUCHAR)siTd;
                    }
                } else {
                    // head of list, list not empty
                    if (i == 0) {
                        EHCI_ASSERT(DeviceData, NextEndpointData != NULL);
                        EHCI_ASSERT(DeviceData, NextEndpointData ==
                                        DeviceData->IsoEndpointListHead);

                        DeviceData->IsoEndpointListHead = EndpointData;
                        EndpointData->PrevEndpoint = NULL;
                    }

                    phys = siTd->PhysicalAddress;
                    SET_SITD(phys);
                    // head of list, link to Dummy QH
                    //
                    // appropriate dummy should point to these TDs
                    // DUMMY->ISOTD->INTQH, newISOTD->ISOTD->INTQH
                    //  to
                    // DUMMY->newISOTD->ISOTD->INTQH
                    dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
                    dQh->HwQH.HLink.HwAddress = phys;
                    HW_PTR(dQh->NextLink) = (PUCHAR) siTd;
                }

            }
        } // not empty

    }

}


VOID
EHCI_RemoveIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   unlink the iso TDs from the schedule

Arguments:


--*/
{
    ULONG i;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;
    PHCD_QUEUEHEAD_DESCRIPTOR dQh;

    prevEndpoint = EndpointData->PrevEndpoint;
    nextEndpoint = EndpointData->NextEndpoint;

    LOGENTRY(DeviceData, G, '_iRM', prevEndpoint,
        nextEndpoint, EndpointData);

    if (DeviceData->IsoEndpointListHead == EndpointData) {
        // this is the head

        for (i=0; i<USBEHCI_MAX_FRAME; i++) {

            PHCD_SI_TRANSFER_DESCRIPTOR siTd;
            ULONG phys;

            siTd = &EndpointData->SiTdList->Td[i&0x1f];
            phys = siTd->HwTD.NextLink.HwAddress;

            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys;
            HW_PTR(dQh->NextLink) = HW_PTR(siTd->NextLink);
        }

        DeviceData->IsoEndpointListHead =
            EndpointData->NextEndpoint;
        if (nextEndpoint != NULL) {
            EHCI_ASSERT(DeviceData,
                        nextEndpoint->PrevEndpoint == EndpointData);
            nextEndpoint->PrevEndpoint = NULL;
        }
    } else {
        // middle or tail
        EHCI_ASSERT(DeviceData, prevEndpoint != NULL);

        if (HIGHSPEED(prevEndpoint)) {

            for (i=0; i<USBEHCI_MAX_FRAME; i++) {
                PHCD_HSISO_TRANSFER_DESCRIPTOR previTd;
                PHCD_SI_TRANSFER_DESCRIPTOR siTd;
                ULONG phys;

                siTd = &EndpointData->SiTdList->Td[i&0x1f];
                previTd = &prevEndpoint->HsIsoTdList->Td[i];

                phys = siTd->HwTD.NextLink.HwAddress;
                previTd->HwTD.NextLink.HwAddress = phys;

                HW_PTR(previTd->NextLink) = HW_PTR(siTd->NextLink);
            }
            prevEndpoint->NextEndpoint =
                    EndpointData->NextEndpoint;
            if (nextEndpoint) {
                nextEndpoint->PrevEndpoint = prevEndpoint;
            }
        } else {

            for (i=0; i<ISO_SCHEDULE_SIZE; i++) {

                PHCD_SI_TRANSFER_DESCRIPTOR siTd, prevSiTd;
                ULONG phys;

                siTd = &EndpointData->SiTdList->Td[i];
                prevSiTd = &prevEndpoint->SiTdList->Td[i];

                phys = siTd->HwTD.NextLink.HwAddress;
                prevSiTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(prevSiTd->NextLink) = HW_PTR(siTd->NextLink);
            }
            prevEndpoint->NextEndpoint =
                    EndpointData->NextEndpoint;
            if (nextEndpoint) {
                nextEndpoint->PrevEndpoint = prevEndpoint;
            }

        }
    }
}


USB_MINIPORT_STATUS
EHCI_OpenIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG i;
    ULONG bytes;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;

    LOGENTRY(DeviceData, G, '_opR', 0, 0, EndpointParameters);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    EndpointData->SiTdList = (PHCD_SITD_LIST) buffer;
    // bugbug use manifest
    EndpointData->TdCount = ISO_SCHEDULE_SIZE;
    EndpointData->LastFrame = 0;

    for (i=0; i<EndpointData->TdCount; i++) {

        EHCI_InitializeSiTD(DeviceData,
                            EndpointData,
                            EndpointParameters,
                            &EndpointData->SiTdList->Td[i],
                            i > 0 ?
                                &EndpointData->SiTdList->Td[i-1] :
                                &EndpointData->SiTdList->Td[EndpointData->TdCount-1],
                            phys);

        phys += sizeof(HCD_SI_TRANSFER_DESCRIPTOR);

    }
    EndpointData->SiTdList->Td[0].HwTD.BackPointer.HwAddress =
        EndpointData->SiTdList->Td[EndpointData->TdCount-1].PhysicalAddress;

    // split iso eps are inserted after any high speed eps

    if (DeviceData->IsoEndpointListHead == NULL) {
        // empty list
        prevEndpoint = NULL;
        nextEndpoint = NULL;
    } else {

        prevEndpoint = NULL;
        nextEndpoint = DeviceData->IsoEndpointListHead;
        // walk the list to the first non HS ep or to
        // a NULL

        while (nextEndpoint != NULL &&
               HIGHSPEED(nextEndpoint)) {
            prevEndpoint = nextEndpoint;
            nextEndpoint = prevEndpoint->NextEndpoint;
        }

        if (nextEndpoint != NULL) {
            //
            // nextEndpoint is first non high speed endpoint
            // see what order it sould be added
            if (EndpointData->Parameters.Ordinal == 1) {
                // ordinal 1 add after this one
                prevEndpoint = nextEndpoint;
                nextEndpoint = prevEndpoint->NextEndpoint;
            }
        }
    }

    // insert this column of TDs thru the schedule
    EHCI_InsertIsoTdsInSchedule(DeviceData,
                                EndpointData,
                                prevEndpoint,
                                nextEndpoint);

    // init endpoint structures
    InitializeListHead(&EndpointData->TransferList);

    EHCI_EnablePeriodicList(DeviceData);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_MapIsoPacketToTd(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PMINIPORT_ISO_PACKET Packet,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd
    )
/*++

Routine Description:



Arguments:

Returns:

--*/
{
    ULONG length;

    LOGENTRY(DeviceData, G, '_mpI', SiTd, 0, Packet);

    SiTd->HwTD.State.ul = 0;
    SiTd->HwTD.BufferPointer0.ul = 0;
    SiTd->HwTD.BufferPointer1.ul = 0;

    SiTd->HwTD.BufferPointer0.ul =
        Packet->BufferPointer0.Hw32;
    length = Packet->BufferPointer0Length;
    SiTd->StartOffset = SiTd->HwTD.BufferPointer0.CurrentOffset;

    SiTd->HwTD.BufferPointer1.ul = 0;
    if (Packet->BufferPointerCount > 1) {
        EHCI_ASSERT(DeviceData,
                    (Packet->BufferPointer1.Hw32 & 0xFFF) == 0);

        SiTd->HwTD.BufferPointer1.ul =
            Packet->BufferPointer1.Hw32;
        length += Packet->BufferPointer1Length;
    }

    // not sure if this is corrext for IN
    SiTd->HwTD.BufferPointer1.Tposition = TPOS_ALL;

    if (EndpointData->Parameters.TransferDirection == Out) {

        if (length == 0) {
           SiTd->HwTD.BufferPointer1.Tcount = 1;
        } else {
           SiTd->HwTD.BufferPointer1.Tcount = ((length -1) / 188) +1;
        }

        if (SiTd->HwTD.BufferPointer1.Tcount == 1) {
            SiTd->HwTD.BufferPointer1.Tposition = TPOS_ALL;
        } else {
            SiTd->HwTD.BufferPointer1.Tposition = TPOS_BEGIN;
        }

        EHCI_ASSERT(DeviceData, SiTd->HwTD.BufferPointer1.Tcount <= 6);

    } else {
        SiTd->HwTD.BufferPointer1.Tcount = 0;
    }

    SiTd->HwTD.State.BytesToTransfer = length;
    SiTd->HwTD.State.Active = 1;
    SiTd->HwTD.State.InterruptOnComplete = 1;

    EHCI_ASSERT(DeviceData, SiTd->HwTD.BackPointer.HwAddress != 0);
}


VOID
EHCI_CompleteIsoPacket(
    PDEVICE_DATA DeviceData,
    PMINIPORT_ISO_PACKET Packet,
    PHCD_SI_TRANSFER_DESCRIPTOR SiTd
    )
/*++

Routine Description:



Arguments:

Returns:

--*/
{
    ULONG length;
    ULONG cf = EHCI_Get32BitFrameNumber(DeviceData);

    LOGENTRY(DeviceData, G, '_cpI', Packet, SiTd, cf);

    if (SiTd->HwTD.State.Active == 1) {
        // missed
        Packet->LengthTransferred = 0;
        LOGENTRY(DeviceData, G, '_cms',
            Packet,
            0,
            Packet->FrameNumber);

    } else {

        //length = SiTd->HwTD.BufferPointer0.CurrentOffset -
        //    SiTd->StartOffset;
        //LOGENTRY(DeviceData, G, '_cp2',
        //    Packet->FrameNumber,
        //    SiTd->HwTD.BufferPointer0.CurrentOffset,
        //    SiTd->StartOffset);

        length = Packet->Length - SiTd->HwTD.State.BytesToTransfer;
        LOGENTRY(DeviceData, G, '_cp3',
            Packet->FrameNumber,
            Packet->Length ,
            SiTd->HwTD.State.BytesToTransfer);

        Packet->LengthTransferred = length;
        LOGENTRY(DeviceData, G, '_cpL', Packet, SiTd, length);
    }

     //Packet->LengthTransferred = 928;

    // map status
    LOGENTRY(DeviceData, G, '_cpS', Packet, SiTd->HwTD.State.ul,
        Packet->UsbdStatus);

    Packet->UsbdStatus = USBD_STATUS_SUCCESS;
}


PMINIPORT_ISO_PACKET
EHCI_GetPacketForFrame(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT *Transfer,
    ULONG Frame
    )
/*++

Routine Description:

    fetch the iso packet associated with the given frame
    if we have one in our current transfer list

Arguments:

Returns:

--*/
{
    ULONG i;
    PLIST_ENTRY listEntry;

    listEntry = EndpointData->TransferList.Flink;
    while (listEntry != &EndpointData->TransferList) {

        PTRANSFER_CONTEXT transfer;

        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT,
                     TransferLink);

        ASSERT_TRANSFER(DeviceData, transfer);

        if (Frame <= transfer->FrameComplete) {
            for(i=0; i<transfer->IsoTransfer->PacketCount; i++) {
                if (transfer->IsoTransfer->Packets[i].FrameNumber == Frame) {
                    *Transfer = transfer;
                    return &transfer->IsoTransfer->Packets[i];
                }
            }
        }

        listEntry = transfer->TransferLink.Flink;
    }

    return NULL;
}

ULONG xCount = 0;
ULONG pCount = 0;

VOID
EHCI_InternalPollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'


    static iso TD table
    --------------------
    0                       < -- (lastFrame & 0x1f)
    1                       {completed}
    2                       {completed}
    3                       {limbo}
    4                       < -- (currentframe & 0x1f)
    ...

    31
    ---------------------


Arguments:

Return Value:

--*/

{
    ULONG x, i;
    ULONG currentFrame, lastFrame;
    PHCD_SI_TRANSFER_DESCRIPTOR siTd;
    PMINIPORT_ISO_PACKET packet;
    PLIST_ENTRY listEntry;
    PTRANSFER_CONTEXT transfer;
    ULONG transfersPending, fc;

    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    lastFrame = EndpointData->LastFrame;

    LOGENTRY(DeviceData, G, '_pis', lastFrame, currentFrame,
        EndpointData);

   // if (pCount > 60) {
   //     TEST_TRAP();
   // }

    if (currentFrame - lastFrame > ISO_SCHEDULE_SIZE) {
        // overrun
        lastFrame = currentFrame-1;
        LOGENTRY(DeviceData, G, '_ove', lastFrame, currentFrame, 0);

        // dump the current contents
        for (i = 0; i <ISO_SCHEDULE_SIZE; i++) {

            siTd = &EndpointData->SiTdList->Td[i];

            transfer = ISO_TRANSFER_PTR(siTd->Transfer);

            if (transfer != NULL) {
                ISO_PACKET_PTR(siTd->Packet) = NULL;
                ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
                transfer->PendingPackets--;
            }
        }
    }

    if (lastFrame == currentFrame) {
        // too early to do anything
        LOGENTRY(DeviceData, G, '_ear', lastFrame, currentFrame, 0);
        return;
    }

    // TDs between lastframe and currentframe are complete,
    // complete the packets associated with them


//    f0
//    f1
//    f2  < ------- last frame   }
//    f3                         }  these are complete
//    f4                         <- backpointer may still be pointing here
//    f5  < ------- current frame
//    f6
//    f7
//    f8

    x = (lastFrame & (ISO_SCHEDULE_MASK));

    LOGENTRY(DeviceData, G, '_frm', lastFrame, x, currentFrame);
    while (x != ((currentFrame-1) & ISO_SCHEDULE_MASK)) {
        siTd = &EndpointData->SiTdList->Td[x];

        ASSERT_SITD(DeviceData, siTd);
        // complete this packet
        packet = ISO_PACKET_PTR(siTd->Packet);
        transfer = ISO_TRANSFER_PTR(siTd->Transfer);
        LOGENTRY(DeviceData, G, '_gpk', transfer, packet, x);

        if (packet != NULL) {
            transfer = ISO_TRANSFER_PTR(siTd->Transfer);
            ASSERT_TRANSFER(DeviceData, transfer);
            EHCI_CompleteIsoPacket(DeviceData, packet, siTd);
            ISO_PACKET_PTR(siTd->Packet) = NULL;
            ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
            transfer->PendingPackets--;
        }

        lastFrame++;
        x++;
        x &= ISO_SCHEDULE_MASK;
    }

    // attempt to program what we can, if siTD is NULL
    // then we can program this frame
    // NOTE: No scheduling if paused!
    if (EndpointData->State != ENDPOINT_PAUSE) {
        LOGENTRY(DeviceData, G, '_psh', 0, 0, 0);

        for (i=0; i <ISO_SCHEDULE_SIZE; i++) {

            x = ((currentFrame+i) & ISO_SCHEDULE_MASK);

            siTd = &EndpointData->SiTdList->Td[x];
            ASSERT_SITD(DeviceData, siTd);

            LOGENTRY(DeviceData, G, '_gpf', siTd, x, currentFrame+i);

            // open slot?
            if (ISO_PACKET_PTR(siTd->Packet) != NULL) {
                // no, bail
                continue;
            }

            // yes, see if we have a packet
            packet = EHCI_GetPacketForFrame(DeviceData,
                                            EndpointData,
                                            &transfer,
                                            currentFrame+i);

            if (packet != NULL) {
                EHCI_ASSERT(DeviceData, ISO_PACKET_PTR(siTd->Packet) == NULL);

                EHCI_MapIsoPacketToTd(DeviceData, EndpointData,
                    packet, siTd);
                ISO_PACKET_PTR(siTd->Packet) = packet;
                ASSERT_TRANSFER(DeviceData, transfer);
                ISO_TRANSFER_PTR(siTd->Transfer) = transfer;
                transfer->PendingPackets++;
            }
        }
    }

    EHCI_ASSERT(DeviceData, lastFrame < currentFrame);
    EndpointData->LastFrame = lastFrame;

    // walk our list of active iso transfers and see
    // if any are complete

    listEntry = EndpointData->TransferList.Flink;
    transfersPending = 0;

    while (listEntry != &EndpointData->TransferList && Complete) {
        PTRANSFER_CONTEXT transfer;

        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT,
                     TransferLink);

        LOGENTRY(DeviceData, G, '_ckt', transfer, transfer->FrameComplete+2
            , currentFrame);

        EHCI_ASSERT(DeviceData, transfer->Sig == SIG_EHCI_TRANSFER);
        if (currentFrame >= transfer->FrameComplete + 2 &&
            transfer->PendingPackets == 0) {

            listEntry = transfer->TransferLink.Flink;
            RemoveEntryList(&transfer->TransferLink);
            LOGENTRY(DeviceData, G, '_cpi', transfer, 0, 0);

    // if (xCount==2) {
    //    TEST_TRAP();
    //}
            USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                          EndpointData,
                                          transfer->TransferParameters,
                                          transfer->IsoTransfer);
        } else {
            transfersPending++;
            fc = transfer->FrameComplete;
            listEntry = transfer->TransferLink.Flink;
        }
    }

    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    if (transfersPending == 1 &&
        fc >= currentFrame &&
        (fc - currentFrame) < 2 ) {
        LOGENTRY(DeviceData, G, '_rei', fc, currentFrame, 0);

        EHCI_InterruptNextSOF(DeviceData);
    }
}


VOID
EHCI_PollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
{
    LOGENTRY(DeviceData, G, '_ipl', 0, 0, 0);

    if (!IsListEmpty(&EndpointData->TransferList)) {
        LOGENTRY(DeviceData, G, '_III', 0, 0, 0);

        if (HIGHSPEED(EndpointData)) {
            EHCI_InternalPollHsIsoEndpoint(DeviceData, EndpointData, TRUE);
        } else {
            EHCI_InternalPollIsoEndpoint(DeviceData, EndpointData, TRUE);
        }
    }
}


USB_MINIPORT_STATUS
EHCI_AbortIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;

    // iso TD table should be idle at this point all we
    // need to do is make sure we have no TDs still pointing
    // at this transfer and remove it frome any internal
    // queues

    if (HIGHSPEED(EndpointData)) {

        for (i = 0; i <USBEHCI_MAX_FRAME; i++) {

            PHCD_HSISO_TRANSFER_DESCRIPTOR hsIsoTd;
            ULONG period = EndpointData->Parameters.Period;

            LOGENTRY(DeviceData, G, '_ibh', TransferContext,
                    EndpointData, period);

            hsIsoTd = &EndpointData->HsIsoTdList->Td[i];

            if (ISO_TRANSFER_PTR(hsIsoTd->Transfer) == TransferContext) {
                ISO_TRANSFER_PTR(hsIsoTd->Transfer) = NULL;

                ISO_PACKET_PTR(hsIsoTd->FirstPacket) = NULL;
                TransferContext->PendingPackets -= (8/period);
            }
        }
    } else {

        for (i = 0; i <ISO_SCHEDULE_SIZE; i++) {
            PHCD_SI_TRANSFER_DESCRIPTOR siTd;

            LOGENTRY(DeviceData, G, '_ibi', TransferContext,
                    EndpointData, 1);

            siTd = &EndpointData->SiTdList->Td[i];

            if (ISO_TRANSFER_PTR(siTd->Transfer) == TransferContext) {
                ISO_TRANSFER_PTR(siTd->Transfer) = NULL;
                ISO_PACKET_PTR(siTd->Packet) = NULL;
                TransferContext->PendingPackets--;
            }
        }
    }

    EHCI_ASSERT(DeviceData, TransferContext->TransferLink.Flink != NULL);
    EHCI_ASSERT(DeviceData, TransferContext->TransferLink.Blink != NULL);

    // remove this transfer from our lists
    RemoveEntryList(&TransferContext->TransferLink);
    TransferContext->TransferLink.Flink = NULL;
    TransferContext->TransferLink.Blink = NULL;

    return USBMP_STATUS_SUCCESS;

}


USB_MINIPORT_STATUS
EHCI_SubmitIsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // init the structures and queue the endpoint
    LOGENTRY(DeviceData, G, '_ISO', TransferContext, 0, 0);

    RtlZeroMemory(TransferContext, sizeof(TRANSFER_CONTEXT));
    TransferContext->Sig = SIG_EHCI_TRANSFER;
    TransferContext->IsoTransfer = IsoTransfer;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    if (HIGHSPEED(EndpointData)) {
         TransferContext->FrameComplete =
            IsoTransfer->Packets[0].FrameNumber + IsoTransfer->PacketCount/8;
    } else {
        TransferContext->FrameComplete =
            IsoTransfer->Packets[0].FrameNumber + IsoTransfer->PacketCount;
    }
    TransferContext->PendingPackets = 0;

    // if queues are empty the go ahead and reset the table
    // so we can fill now
    if (IsListEmpty(&EndpointData->TransferList)) {
        EndpointData->LastFrame = 0;
        LOGENTRY(DeviceData, G, '_rsi', 0, 0, 0);
    }

    InsertTailList(&EndpointData->TransferList,
                   &TransferContext->TransferLink);

    // scehdule the initial part of the transfer if
    // possible
    if (HIGHSPEED(EndpointData)) {
        EHCI_InternalPollHsIsoEndpoint(DeviceData,
                                       EndpointData,
                                       FALSE);
    } else {
        EHCI_InternalPollIsoEndpoint(DeviceData,
                                     EndpointData,
                                     FALSE);
    }

    xCount++;
    //if (xCount==2) {
    //    TEST_TRAP();
    //}
    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_SetIsoEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ENDPOINT_TRANSFER_TYPE epType;
    ULONG i, j;

    epType = EndpointData->Parameters.TransferType;
    EHCI_ASSERT(DeviceData, epType == Isochronous);

    switch(State) {
    case ENDPOINT_ACTIVE:
        EndpointData->LastFrame =  EHCI_Get32BitFrameNumber(DeviceData);
        break;

    case ENDPOINT_PAUSE:
        // clear the active bit on all TDs
        if (HIGHSPEED(EndpointData)) {
            for (i=0; i<EndpointData->TdCount; i++) {
                for(j=0; j<8; j++) {
                    EndpointData->HsIsoTdList->Td[i].HwTD.Transaction[j].Active = 0;
                }
            }
        } else {
            for (i=0; i<EndpointData->TdCount; i++) {
                EndpointData->SiTdList->Td[i].HwTD.State.Active = 0;
            }
        }
        break;

    case ENDPOINT_REMOVE:
        if (HIGHSPEED(EndpointData)) {
            EHCI_RemoveHsIsoTdsFromSchedule(DeviceData,
                                          EndpointData);
        } else {
            EHCI_RemoveIsoTdsFromSchedule(DeviceData,
                                          EndpointData);
        }
        break;

    default:
        TEST_TRAP();
    }

    EndpointData->State = State;
}

/*
    High Speed Iso code


    We use a variation of the split Iso code here. We allocate 1024
    static TDs and insert them in the schedule.  These TDs are then
    updated with the current transfers instead of inserted or removed.


*/

VOID
EHCI_Initialize_iTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd,
    HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress,
    ULONG Frame
    )
/*++

Routine Description:

    Initailze a static SiTD for an endpoint

Arguments:

Return Value:

    none
--*/
{
    ULONG i;

    IsoTd->Sig = SIG_HCD_ITD;
    IsoTd->PhysicalAddress = PhysicalAddress;
    ISO_PACKET_PTR(IsoTd->FirstPacket) = NULL;
    IsoTd->HostFrame = Frame;

    for (i=0; i< 8; i++) {
        IsoTd->HwTD.Transaction[i].ul = 0;
    }

    IsoTd->HwTD.BufferPointer0.DeviceAddress =
        EndpointParameters->DeviceAddress;
    IsoTd->HwTD.BufferPointer0.EndpointNumber =
        EndpointParameters->EndpointAddress;

    IsoTd->HwTD.BufferPointer1.MaxPacketSize =
        EndpointParameters->MuxPacketSize;
    // 1 = IN 0 = OUT
    IsoTd->HwTD.BufferPointer1.Direction =
        (EndpointParameters->TransferDirection == In) ? 1 : 0;

    IsoTd->HwTD.BufferPointer2.Multi =
        EndpointParameters->TransactionsPerMicroframe;

}

#define EHCI_OFFSET_MASK    0x00000FFF
#define EHCI_PAGE_SHIFT     12

VOID
EHCI_MapHsIsoPacketsToTd(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PMINIPORT_ISO_PACKET FirstPacket,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd,
    BOOLEAN InterruptOnComplete
    )
/*++

Routine Description:



Arguments:

Returns:

--*/
{
    PHC_ITD_BUFFER_POINTER currentBp;
    PMINIPORT_ISO_PACKET pkt = FirstPacket;
    ULONG page, offset, bpCount, i;
    ULONG frame = FirstPacket->FrameNumber;

    LOGENTRY(DeviceData, G, '_HHS', IsoTd, 0, FirstPacket);
    ASSERT_ITD(DeviceData, IsoTd);

    bpCount = 0;
    currentBp = (PHC_ITD_BUFFER_POINTER) &IsoTd->HwTD.BufferPointer0;

    // map the first packet
    page = (pkt->BufferPointer0.Hw32 >> EHCI_PAGE_SHIFT);
    currentBp->BufferPointer = page;

    // This Td will represent 8 packets
    for (i=0; i<8; i++) {

        EHCI_ASSERT(DeviceData, pkt->FrameNumber == frame);

        page = (pkt->BufferPointer0.Hw32 >> EHCI_PAGE_SHIFT);
        offset = pkt->BufferPointer0.Hw32 & EHCI_OFFSET_MASK;

        if (page != currentBp->BufferPointer) {
            currentBp++;
            bpCount++;
            currentBp->BufferPointer = page;
        }

        IsoTd->HwTD.Transaction[i].Offset = offset;
        IsoTd->HwTD.Transaction[i].Length = pkt->Length;
        IsoTd->HwTD.Transaction[i].PageSelect = bpCount;
        if (InterruptOnComplete && i==7) {
            IsoTd->HwTD.Transaction[i].InterruptOnComplete = 1;
        } else {
            IsoTd->HwTD.Transaction[i].InterruptOnComplete = 0;
        }
        IsoTd->HwTD.Transaction[i].Active = 1;

        if (pkt->BufferPointerCount > 1) {
            page = (pkt->BufferPointer1.Hw32 >> EHCI_PAGE_SHIFT);
            currentBp++;
            bpCount++;
            currentBp->BufferPointer = page;
            EHCI_ASSERT(DeviceData, bpCount <= 6)
        }

        pkt++;

    }

    LOGENTRY(DeviceData, G, '_mhs', IsoTd, 0, bpCount);
}


VOID
EHCI_CompleteHsIsoPackets(
    PDEVICE_DATA DeviceData,
    PMINIPORT_ISO_PACKET FirstPacket,
    PHCD_HSISO_TRANSFER_DESCRIPTOR IsoTd
    )
/*++

Routine Description:

    Complete the eight high speed packets associated with this
    TD

Arguments:

Returns:

--*/
{
    ULONG length, i;
    ULONG cf = EHCI_Get32BitFrameNumber(DeviceData);
    PMINIPORT_ISO_PACKET pkt = FirstPacket;

    LOGENTRY(DeviceData, G, '_cpI', pkt, IsoTd, cf);

    for (i=0; i<8; i++) {
        if (IsoTd->HwTD.Transaction[i].Active == 1) {
            // missed
            pkt->LengthTransferred = 0;
            LOGENTRY(DeviceData, G, '_cms',
                pkt,
                i,
                pkt->FrameNumber);
            pkt->UsbdStatus = USBD_STATUS_ISO_NOT_ACCESSED_BY_HW;
        } else {
            // if this is an out assume all data transferred
            if (IsoTd->HwTD.BufferPointer1.Direction == 0) {
                // out
                length = pkt->Length;
                LOGENTRY(DeviceData, G, '_cp3',
                    pkt->FrameNumber,
                    pkt->Length ,
                    pkt);
            } else {
                // in
                length = IsoTd->HwTD.Transaction[i].Length;
                LOGENTRY(DeviceData, G, '_cp4',
                    pkt->FrameNumber,
                    pkt->Length ,
                    pkt);
            }

            pkt->LengthTransferred = length;

            // check the errubit

            if (IsoTd->HwTD.Transaction[i].XactError) {
                pkt->UsbdStatus = USBD_STATUS_XACT_ERROR;
                //TEST_TRAP();
            } else if (IsoTd->HwTD.Transaction[i].BabbleDetect) {
                pkt->UsbdStatus = USBD_STATUS_BABBLE_DETECTED;
            } else if (IsoTd->HwTD.Transaction[i].DataBufferError) {
                pkt->UsbdStatus = USBD_STATUS_DATA_BUFFER_ERROR;
            } else {
                pkt->UsbdStatus = USBD_STATUS_SUCCESS;
            }
            LOGENTRY(DeviceData, G, '_cpL', pkt, IsoTd, length);

            pkt++;
        }
    }
}


USB_MINIPORT_STATUS
EHCI_OpenHsIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    ULONG i;
    ULONG bytes;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;

    LOGENTRY(DeviceData, G, '_opS', 0, 0, EndpointParameters);


    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    EndpointData->HsIsoTdList = (PHCD_HSISOTD_LIST) buffer;
    // bugbug use manifest
    EndpointData->TdCount = USBEHCI_MAX_FRAME;
    EndpointData->LastFrame = 0;

    for (i=0; i<EndpointData->TdCount; i++) {

        EHCI_Initialize_iTD(DeviceData,
                            EndpointData,
                            EndpointParameters,
                            &EndpointData->HsIsoTdList->Td[i],
                            phys,
                            i);

        phys += sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR);

    }

    //
    if (DeviceData->IsoEndpointListHead == NULL) {
        // empty list, no iso endpoints
        prevEndpoint = NULL;
        nextEndpoint = NULL;
    } else {
        // currently we insert HS endpoints in front of split
        // iso endpoints, so for high speed we just stick them
        // on the head of the list

        prevEndpoint = NULL;
        nextEndpoint = DeviceData->IsoEndpointListHead;
    }

    // insert this column of TDs thru the schedule
    EHCI_InsertHsIsoTdsInSchedule(DeviceData,
                                  EndpointData,
                                  prevEndpoint,
                                  nextEndpoint);

    // init endpoint structures
    InitializeListHead(&EndpointData->TransferList);

    EHCI_EnablePeriodicList(DeviceData);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RemoveHsIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   unlink the iso TDs from the schedule

Arguments:


--*/
{
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;
    PENDPOINT_DATA prevEndpoint, nextEndpoint;
    PHCD_QUEUEHEAD_DESCRIPTOR dQh;

    prevEndpoint = EndpointData->PrevEndpoint;
    nextEndpoint = EndpointData->NextEndpoint;

    LOGENTRY(DeviceData, G, '_iRM', prevEndpoint,
        nextEndpoint, EndpointData);

    if (DeviceData->IsoEndpointListHead == EndpointData) {
        // this is the head

        //frameBase = DeviceData->FrameListBaseAddress;
        for (i=0; i<USBEHCI_MAX_FRAME; i++) {

            PHCD_HSISO_TRANSFER_DESCRIPTOR iTd;
            ULONG phys;

            iTd = &EndpointData->HsIsoTdList->Td[i];
            phys = iTd->HwTD.NextLink.HwAddress;

            dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
            dQh->HwQH.HLink.HwAddress = phys;

            dQh->NextLink = iTd->NextLink;

            //*frameBase = phys;
            //frameBase++;
        }

        DeviceData->IsoEndpointListHead =
            EndpointData->NextEndpoint;

        if (nextEndpoint != NULL) {
            EHCI_ASSERT(DeviceData,
                        nextEndpoint->PrevEndpoint == EndpointData);
            nextEndpoint->PrevEndpoint = NULL;
        }
    } else {
        // middle
        TEST_TRAP();
        EHCI_ASSERT(DeviceData, HIGHSPEED(prevEndpoint));

        // link prev to next, prev will always be a HS ep
        prevEndpoint->NextEndpoint = nextEndpoint;
        if (nextEndpoint != NULL) {
            nextEndpoint->PrevEndpoint = prevEndpoint;
        }

        for (i=0; i<USBEHCI_MAX_FRAME; i++) {

            PHCD_HSISO_TRANSFER_DESCRIPTOR iTd, previTd;
            ULONG phys;

            iTd = &EndpointData->HsIsoTdList->Td[i];
            previTd = &prevEndpoint->HsIsoTdList->Td[i];

            phys = iTd->HwTD.NextLink.HwAddress;
            previTd->HwTD.NextLink.HwAddress = phys;
        }

    }
}


VOID
EHCI_InsertHsIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    //PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;

    LOGENTRY(DeviceData, G, '_iAH', PrevEndpointData,
        NextEndpointData, EndpointData);

    // always insert to head
    EHCI_ASSERT(DeviceData, PrevEndpointData == NULL);

    DeviceData->IsoEndpointListHead = EndpointData;
    EndpointData->PrevEndpoint = NULL;

    EndpointData->NextEndpoint =
        NextEndpointData;
    if (NextEndpointData != NULL) {
        NextEndpointData->PrevEndpoint = EndpointData;
    }

    //frameBase = DeviceData->FrameListBaseAddress;

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {

        PHCD_HSISO_TRANSFER_DESCRIPTOR iTd, nextiTd, previTd;
        HW_32BIT_PHYSICAL_ADDRESS qh;
        PHCD_QUEUEHEAD_DESCRIPTOR dQh;
        ULONG phys;

        iTd = &EndpointData->HsIsoTdList->Td[i];
        ASSERT_ITD(DeviceData, iTd);

        dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);
        // fixup next link
        if (NextEndpointData == NULL) {
            // no iso endpoints, link to the interrupt
            // queue heads via the dummy queue head
            // qh = *frameBase;
            qh = dQh->HwQH.HLink.HwAddress;
            iTd->HwTD.NextLink.HwAddress = qh;
            iTd->NextLink = dQh->NextLink;

        } else {
            // link to the next iso endpoint

            if (HIGHSPEED(NextEndpointData)) {
                PHCD_HSISO_TRANSFER_DESCRIPTOR tmp;

                tmp = &NextEndpointData->HsIsoTdList->Td[i];
                iTd->HwTD.NextLink.HwAddress =
                    tmp->PhysicalAddress;
                HW_PTR(iTd->NextLink) = (PUCHAR) tmp;
            } else {
                PHCD_SI_TRANSFER_DESCRIPTOR tmp;
                ULONG phys;

                tmp = &NextEndpointData->SiTdList->Td[i%ISO_SCHEDULE_SIZE];
                phys = tmp->PhysicalAddress;
                SET_SITD(phys);

                iTd->HwTD.NextLink.HwAddress = phys;
                HW_PTR(iTd->NextLink) = (PUCHAR) tmp;
            }

        }

        // fixup prev link
        // since we always insert Hs iso on the head of the list
        // prev endpoint should always be NULL
        EHCI_ASSERT(DeviceData, PrevEndpointData == NULL);
        phys = iTd->PhysicalAddress;

        // link dummy QH to this TD
        dQh->HwQH.HLink.HwAddress = phys;
        HW_PTR(dQh->NextLink) = (PUCHAR) iTd;

        //*frameBase = phys;
        //frameBase++;


    }
}

#define     HSISO_SCHEDULE_MASK       0x3ff

VOID
EHCI_InternalPollHsIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'


    static iso TD table
    --------------------
    0                       < -- (lastFrame & 0x3ff)
    1                       {completed}
    2                       {completed}
    3                       {completed}
    4                       < -- (currentframe & 0x3ff)
    ...

    1023
    ---------------------


Arguments:

Return Value:

--*/

{
    ULONG x, i;
    ULONG currentFrame, lastFrame;
    PHCD_HSISO_TRANSFER_DESCRIPTOR iTd;
    PHCD_HSISO_TRANSFER_DESCRIPTOR lastiTd;
    PMINIPORT_ISO_PACKET packet;
    PLIST_ENTRY listEntry;
    PTRANSFER_CONTEXT transfer;

    currentFrame = EHCI_Get32BitFrameNumber(DeviceData);
    lastFrame = EndpointData->LastFrame;

    LOGENTRY(DeviceData, G, '_pis', lastFrame, currentFrame,
        EndpointData);

    if (currentFrame - lastFrame > USBEHCI_MAX_FRAME) {
        // overrun
        lastFrame = currentFrame-1;
        LOGENTRY(DeviceData, G, '_ov1', lastFrame, currentFrame, 0);

        // dump the current contents
        for (i=0; i <USBEHCI_MAX_FRAME; i++) {

            iTd = &EndpointData->HsIsoTdList->Td[i];

            transfer = ISO_TRANSFER_PTR(iTd->Transfer);

            if (transfer != NULL) {
                ISO_PACKET_PTR(iTd->FirstPacket) = NULL;
                ISO_TRANSFER_PTR(iTd->Transfer) = NULL;
                transfer->PendingPackets-=8;
            }
        }
    }

    if (lastFrame == currentFrame) {
        // too early to do anything
        LOGENTRY(DeviceData, G, '_ear', lastFrame, currentFrame, 0);
        return;
    }

    // TDs between lastframe and currentframe are complete,
    // complete the packets associated with them


//    f0
//    f1
//    f2  < ------- last frame   }
//    f3                         }  these are complete
//    f4                         }
//    f5  < ------- current frame
//    f6
//    f7
//    f8

    x = (lastFrame & (HSISO_SCHEDULE_MASK));

    lastiTd = NULL;

    LOGENTRY(DeviceData, G, '_frh', lastFrame, x, currentFrame);
    while (x != ((currentFrame-1) & HSISO_SCHEDULE_MASK)) {
        iTd = &EndpointData->HsIsoTdList->Td[x];

        ASSERT_ITD(DeviceData, iTd);
        // complete this packet
        packet = ISO_PACKET_PTR(iTd->FirstPacket);
        transfer = ISO_TRANSFER_PTR(iTd->Transfer);
        LOGENTRY(DeviceData, G, '_gpk', transfer, packet, x);

        if (packet != NULL) {
            transfer = ISO_TRANSFER_PTR(iTd->Transfer);
            ASSERT_TRANSFER(DeviceData, transfer);
            EHCI_CompleteHsIsoPackets(DeviceData, packet, iTd);
            ISO_PACKET_PTR(iTd->FirstPacket) = NULL;
            ISO_TRANSFER_PTR(iTd->Transfer) = NULL;
            transfer->PendingPackets-=8;
        }

        lastFrame++;
        x++;
        x &= HSISO_SCHEDULE_MASK;
    }

    // attempt to program what we can, if iTD is NULL
    // then we can program this frame
    // NOTE: No scheduling if paused!
    if (EndpointData->State != ENDPOINT_PAUSE) {
        LOGENTRY(DeviceData, G, '_psh', 0, 0, 0);

        for (i=0; i <USBEHCI_MAX_FRAME; i++) {

            x = ((currentFrame+i) & HSISO_SCHEDULE_MASK);

            iTd = &EndpointData->HsIsoTdList->Td[x];
            ASSERT_ITD(DeviceData, iTd);

            LOGENTRY(DeviceData, G, '_gpf', iTd, x, currentFrame+i);

            // open slot?
            if (ISO_PACKET_PTR(iTd->FirstPacket) != NULL) {
                // no, bail
                continue;
            }

            // yes, see if we have a packet
            // this will fetch the first packet to transmit this frame
            packet = EHCI_GetPacketForFrame(DeviceData,
                                            EndpointData,
                                            &transfer,
                                            currentFrame+i);

            if (packet != NULL) {
                BOOLEAN ioc = FALSE;
                ULONG sf, ef;

                EHCI_ASSERT(DeviceData, ISO_PACKET_PTR(iTd->FirstPacket) == NULL);
                if ((currentFrame+i) == transfer->FrameComplete) {
                    ioc = TRUE;
                }

                sf = transfer->FrameComplete -
                    transfer->IsoTransfer->PacketCount +5;

                ef = transfer->FrameComplete -5;

                // generate some interrupts on the first few frames of the
                // transfer to help flush out any previous transfers
                if (currentFrame+i <= sf ||
                    currentFrame+i >= ef) {
                    ioc = TRUE;
                }
//interrupt every frame
//ioc = TRUE;
                //if ((currentFrame % 2) == 0) {
                //    ioc = TRUE;
                //}
                // map 8 microframes
                EHCI_MapHsIsoPacketsToTd(DeviceData, EndpointData,
                    packet, iTd, ioc);
                lastiTd = iTd;
                ISO_PACKET_PTR(iTd->FirstPacket) = packet;
                ASSERT_TRANSFER(DeviceData, transfer);
                ISO_TRANSFER_PTR(iTd->Transfer) = transfer;
                transfer->PendingPackets+=8;
            } else {
                ULONG j;
                // re-init itd
                for (j=0; j<8; j++) {
                    iTd->HwTD.Transaction[j].InterruptOnComplete = 0;
                }
            }
        }

        // take a interrupt on the last TD programmed
        if (lastiTd != NULL) {
            lastiTd->HwTD.Transaction[7].InterruptOnComplete = 1;
        }
    }

    EHCI_ASSERT(DeviceData, lastFrame < currentFrame);
    EndpointData->LastFrame = lastFrame;

    // walk our list of active iso transfers and see
    // if any are complete
//restart:
    listEntry = EndpointData->TransferList.Flink;
    while (listEntry != &EndpointData->TransferList && Complete) {
        PTRANSFER_CONTEXT transfer;

        transfer = (PTRANSFER_CONTEXT) CONTAINING_RECORD(
                     listEntry,
                     struct _TRANSFER_CONTEXT,
                     TransferLink);

        LOGENTRY(DeviceData, G, '_ckt', transfer, transfer->FrameComplete+2
            , currentFrame);

        EHCI_ASSERT(DeviceData, transfer->Sig == SIG_EHCI_TRANSFER);
        if (currentFrame >= transfer->FrameComplete &&
            transfer->PendingPackets == 0) {

            listEntry = transfer->TransferLink.Flink;
            RemoveEntryList(&transfer->TransferLink);
            LOGENTRY(DeviceData, G, '_cpi', transfer, 0, 0);

            USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                          EndpointData,
                                          transfer->TransferParameters,
                                          transfer->IsoTransfer);
        } else {
            listEntry = transfer->TransferLink.Flink;
        }
    }
}


USB_MINIPORT_STATUS
EHCI_PokeIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;

    if (HIGHSPEED(EndpointData)) {
        TEST_TRAP();
    } else {
        PHCD_SI_TRANSFER_DESCRIPTOR siTd;

        for (i=0; i<EndpointData->TdCount; i++) {

            siTd = &EndpointData->SiTdList->Td[i];
            ASSERT_SITD(DeviceData, siTd);

            siTd->HwTD.Caps.DeviceAddress =
                EndpointParameters->DeviceAddress;
            siTd->HwTD.Caps.HubAddress =
                EndpointParameters->TtDeviceAddress;

        }
    }
    return USBMP_STATUS_SUCCESS;
}


PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetDummyQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    )
/*++

Routine Description:

Arguments:

Return Value:

    queue head

--*/
{
    PUCHAR base;

    base = DeviceData->DummyQueueHeads;

    return (PHCD_QUEUEHEAD_DESCRIPTOR)
        (base + sizeof(HCD_QUEUEHEAD_DESCRIPTOR) * Frame);
}


VOID
EHCI_AddDummyQueueHeads(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    NEC errata:

    Insert a table of 1024 dummy queue heads in the schedule for
    HW to access and point them at the interrupt queue heads.

    These queue heads must be before any iso TDs

    This is a workaround for a law ine the NEC B0' stepping version
    of the controller.  We must put 'dummy' QH at the front of the
    peridoic list such that the first thing fetched is always a QH
    even when ISO TDs are in the schedule.

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR dQh, stqh;
    HW_32BIT_PHYSICAL_ADDRESS qhPhys;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;
    ULONG i;
    HW_32BIT_PHYSICAL_ADDRESS phys;

    frameBase = DeviceData->FrameListBaseAddress;

    phys = DeviceData->DummyQueueHeadsPhys;

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {

        // no iso endpoints should be in the schedule yet
        qhPhys = *frameBase;
        dQh = EHCI_GetDummyQueueHeadForFrame(DeviceData, i);

        // init the dummy queue head

        RtlZeroMemory(dQh, sizeof(*dQh));
        dQh->PhysicalAddress = phys;
        dQh->Sig = SIG_DUMMY_QH;

        dQh->HwQH.EpChars.DeviceAddress = 128;
        dQh->HwQH.EpChars.EndpointNumber = 0;
        dQh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        dQh->HwQH.EpChars.MaximumPacketLength = 64;

        dQh->HwQH.EpCaps.InterruptScheduleMask = 0;
        dQh->HwQH.EpCaps.SplitCompletionMask = 0;
        dQh->HwQH.EpCaps.HubAddress = 0;
        dQh->HwQH.EpCaps.PortNumber = 0;
        dQh->HwQH.EpCaps.HighBWPipeMultiplier = 0;

        dQh->HwQH.CurrentTD.HwAddress = 0;

        dQh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
        dQh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
        dQh->HwQH.Overlay.qTD.Token.Active = 0;

        phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

        // link dummy to first interrupt queue head
        dQh->HwQH.HLink.HwAddress = qhPhys;
        stqh = EHCI_GetQueueHeadForFrame(DeviceData, i);
        EHCI_ASSERT(DeviceData, (qhPhys & ~EHCI_DTYPE_Mask) ==
            stqh->PhysicalAddress);

        HW_PTR(dQh->NextLink) = (PUCHAR)stqh;

        // add dummy queue head to frame list
        qhPhys = dQh->PhysicalAddress;

        SET_QH(qhPhys);
        *frameBase = qhPhys;

        frameBase++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\mpinit.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
     PDRIVER_OBJECT DriverObject,
     PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG mn;
    
    mn = USBPORT_GetHciMn();

    if (mn != USB_HCI_MN) {
        TEST_TRAP();
        return STATUS_UNSUCCESSFUL;
    }

    RegistrationPacket.DeviceDataSize =
        sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize =
        sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize =
        sizeof(TRANSFER_CONTEXT);

    // enough for 4k frame list plus 4k of scratch space
    // plus static queue head table
    // plus 1024 'dummy' queue heads
    RegistrationPacket.CommonBufferBytes = 8192 +
        (sizeof(HCD_QUEUEHEAD_DESCRIPTOR) * 64) + 
        (sizeof(HCD_QUEUEHEAD_DESCRIPTOR) *1024);

    RegistrationPacket.MINIPORT_StartController =
        EHCI_StartController;
    RegistrationPacket.MINIPORT_StopController =
        EHCI_StopController;
    RegistrationPacket.MINIPORT_SuspendController =
        EHCI_SuspendController;
    RegistrationPacket.MINIPORT_ResumeController =
        EHCI_ResumeController;
    RegistrationPacket.MINIPORT_EnableInterrupts =
        EHCI_EnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts =
        EHCI_DisableInterrupts;
    RegistrationPacket.MINIPORT_InterruptService =
        EHCI_InterruptService;

    // root hub functions
    RegistrationPacket.MINIPORT_RH_DisableIrq =
        EHCI_RH_DisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq =
        EHCI_RH_EnableIrq;
    RegistrationPacket.MINIPORT_RH_GetRootHubData =
        EHCI_RH_GetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus =
        EHCI_RH_GetStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus =
        EHCI_RH_GetHubStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus =
        EHCI_RH_GetPortStatus;

    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset =
        EHCI_RH_SetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower =
        EHCI_RH_SetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable =
        EHCI_RH_SetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend =
        EHCI_RH_SetFeaturePortSuspend;

    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable =
        EHCI_RH_ClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower =
        EHCI_RH_ClearFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend =
        EHCI_RH_ClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange =
        EHCI_RH_ClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange =
        EHCI_RH_ClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange =
        EHCI_RH_ClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange =
        EHCI_RH_ClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange =
        EHCI_RH_ClearFeaturePortOvercurrentChange;

    RegistrationPacket.MINIPORT_SetEndpointStatus =
        EHCI_SetEndpointStatus;
    RegistrationPacket.MINIPORT_GetEndpointStatus =
        EHCI_GetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle =
        EHCI_SetEndpointDataToggle;
    RegistrationPacket.MINIPORT_OpenEndpoint =
        EHCI_OpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint =
        EHCI_PokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements =
        EHCI_QueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint =
        EHCI_CloseEndpoint;
    RegistrationPacket.MINIPORT_PollEndpoint =
        EHCI_PollEndpoint;
    RegistrationPacket.MINIPORT_SetEndpointState =
        EHCI_SetEndpointState;
    RegistrationPacket.MINIPORT_GetEndpointState =
        EHCI_GetEndpointState;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber =
        EHCI_Get32BitFrameNumber;
    RegistrationPacket.MINIPORT_PollController =
        EHCI_PollController;
    RegistrationPacket.MINIPORT_CheckController =
        EHCI_CheckController;        
    RegistrationPacket.MINIPORT_InterruptNextSOF =
        EHCI_InterruptNextSOF;
    RegistrationPacket.MINIPORT_SubmitTransfer =
        EHCI_SubmitTransfer;
    RegistrationPacket.MINIPORT_InterruptDpc =
        EHCI_InterruptDpc;
    RegistrationPacket.MINIPORT_AbortTransfer =
        EHCI_AbortTransfer;
    RegistrationPacket.MINIPORT_StartSendOnePacket =
        EHCI_StartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket =
        EHCI_EndSendOnePacket;
    RegistrationPacket.MINIPORT_PassThru =
        EHCI_PassThru;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer =
        EHCI_SubmitIsoTransfer;        
    RegistrationPacket.MINIPORT_RebalanceEndpoint =
        EHCI_RebalanceEndpoint;       
    RegistrationPacket.MINIPORT_FlushInterrupts =
        EHCI_FlushInterrupts;        
    RegistrationPacket.MINIPORT_Chirp_RH_Port =
        EHCI_RH_ChirpRootPort;                
    RegistrationPacket.MINIPORT_TakePortControl = 
        EHCI_TakePortControl;

    RegistrationPacket.OptionFlags = USB_MINIPORT_OPT_NEED_IRQ |
                                     USB_MINIPORT_OPT_NEED_MEMORY |
                                     USB_MINIPORT_OPT_USB20 |
                                    // disable ss sometimes for testing                                        
                                    // USB_MINIPORT_OPT_NO_SS |
                                     USB_MINIPORT_OPT_POLL_CONTROLLER;

    RegistrationPacket.HciType = USB_EHCI;
    RegistrationPacket.BusBandwidth = USB_20_BUS_BANDWIDTH;

    DriverObject->DriverUnload = NULL;

    return USBPORT_RegisterUSBPortDriver(
                DriverObject,
                USB_MINIPORT_HCI_VERSION_2,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\periodic.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   periodic.c

Abstract:

   miniport transfer code for interrupt endpoints

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"

/* 

For USB 2 period indicates a microframe polling interval so 
our tree structure is based on microframes.


      |- 1 ms frame -->|<---------  microframe ------------->|
      mic <32>  <16>  <08>   <04>      <02>              <01>
    
          (table entry)
          
[FRAME.MICROFRAME]          
[0.0] 0   ( 0) -\ 
                ( 0)-\
[2.0] 16  ( 1) -/     \
                      ( 0)-\
[1.0] 8   ( 2) -\     /     \
                ( 1)-/       \
[3.0] 24  ( 3) -/             \
                              (0)-\
[0.4] 4   ( 4) -\             /     \
                ( 2)-\       /       \
[2.4] 20  ( 5) -/     \     /         \
                      ( 1)-/           \
[1.4] 12  ( 6) -\     /                 \
                ( 3)-/                   \  
[3.4] 28  ( 7) -/                         \
                                          (0)-\
[0.2] 2   ( 8) -\                         /    \
                ( 4)-\                   /      \
[2.2] 18  ( 9) -/     \                 /        \
                       ( 2)-\          /          \
[1.2] 10  (10) -\     /      \        /            \
                ( 5)-/        \      /              \
[3.2] 26  (11) -/              \    /                \
                               (1)-/                  \
[0.6] 6   (12) -\              /                       \
                ( 6)-\        /                         \
[2.6] 22  (13) -/     \      /                           \
                       ( 3)-/                             \
[1.6] 14  (14) -\     /                                    \ 
                ( 7)-/                                      \
[3.6] 30  (15) -/                                            \
                                                             (0)                          
[0.1] 1   (16) -\                                            /
                ( 8)-\                                      /
[2.1] 17  (17) -/     \                                    /
                      ( 4)-\                              /
[1.1] 9   (18) -\     /     \                            /
                ( 9)-/       \                          /
[3.1] 25  (19) -/             \                        /
                              (2)-\                   /
[0.5] 5   (20) -\             /    \                 /
                (10)-\       /      \               /
[2.5] 21  (21) -/     \     /        \             /
                      ( 5)-/          \           /
[1.5] 13  (22) -\     /                \         /
                (11)-/                  \       /
[3.5] 29  (23) -/                        \     /
                                          (1)-/
[0.3] 3   (24) -\                        /
                (12)-\                  /
[2.3] 19  (25) -/     \                /
                      ( 6)-\          /
[1.3] 11  (26) -\     /     \        /
                (13)-/       \      /
[3.3] 27  (27) -/             \    /   
                              (3)-/
[0.7] 7   (28) -\             /
                (14)-\       /
[2.7] 23  (29) -/     \     /
                      ( 7)-/
[1.7] 15  (30) -\     /
                (15)-/
[3.7] 31  (31) -/


Allocations:
    period.offset           table entries
      1                    0, 1, 2.........31
      
      2.0                  0, 1, 2.........15
      2.1                 16,17,18.........31
      
      4.0                  0, 1, 2..........7
      4.1                  8, 9,10.........15 
      4.2                 16,17,18.........23
      4.3                 24,25,26.........31

      8.0                  0, 1, 2, 3
      8.1                  4, 5, 6, 7
      8.2                  8, 9,10,11
      8.3                 12,13,14,15
      8.4                 16,17,18,19
      8.5                 20,21,22,23
      8.6                 24,25,26,27
      8.7                 28,29,30,31

      ...


we mainatin a set of dummy queue heads that correspond to the 1ms nodes
in the chart above.

            the queue head table has 4 entries QH 0..3

            frame   mic frame      qh
              0       0..7         <0>
              1       0..7         <1>
              
driver maintains a mini tree that has seven QHs that are placed in the 
schedule.

period frame(microframes)

      32(4) 16(2)  1(8)

frame

 0   (a 0) -\ 
           (e 0)-\
 2   (b 1) -/     \
                 (g 0)-
 1   (c 2) -\     /     
           (f 1)-/       
 3   (d 3) -/             
                        


idx    QH  frame
 0       a    0
 1       b    2
 2       c    1
 3       d    3
 4       e    0,2
 5       f    1,3
 6       g    0,2,1,3
*/

/* 

We represent each possible node in the tree with a data structure that decodes
the appropriate queue head and S-Mask for the node

*e.g 
    for period 8 microframe, sched offset 0 QH = g s-mask = 1

    // The structure contains entries for the 64 possible nodes
    // plus the static ED for bulk and control (2) each entry 
    // corresponds to the period in the following table.
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,

queue heads used for high speed

 0   (3) -\ 
           (1)-\
 2   (4) -/     \
                 (0)-
 1   (5) -\     /     
           (2)-/       
 3   (6) -/
 
*/

/* offsets for each period list */

#define ED_INTERRUPT_1mf    0 //period = 1mf
#define ED_INTERRUPT_2mf    1 //period = 2mf       
#define ED_INTERRUPT_4mf    3 //period = 4mf
#define ED_INTERRUPT_8mf    7 //period = 8mf
#define ED_INTERRUPT_16mf   15 //period = 16mf
#define ED_INTERRUPT_32mf   31 //period = 32mf

#define ED_INTERRUPT_1ms    0 //period = 1ms
#define ED_INTERRUPT_2ms    1 //period = 2ms       
#define ED_INTERRUPT_4ms    3 //period = 4ms
#define ED_INTERRUPT_8ms    7 //period = 8ms
#define ED_INTERRUPT_16ms   15 //period = 16ms
#define ED_INTERRUPT_32ms   31 //period = 32ms


PERIOD_TABLE periodTable[64] =
   {   // period, qh-idx, s-mask
        1,  0, 0xFF,        // 1111 1111 bits 0..7
        
        2,  0, 0x55,        // 0101 0101 bits 0,2,4,6
        2,  0, 0xAA,        // 1010 1010 bits 1,3,5,7
        
        4,  0, 0x11,        // 0001 0001 bits 0,4 
        4,  0, 0x44,        // 0100 0100 bits 2,6 
        4,  0, 0x22,        // 0010 0010 bits 1,5
        4,  0, 0x88,        // 1000 1000 bits 3,7
        
        8,  0, 0x01,        // 0000 0001 bits 0
        8,  0, 0x10,        // 0001 0000 bits 4
        8,  0, 0x04,        // 0000 0100 bits 2 
        8,  0, 0x40,        // 0100 0000 bits 6
        8,  0, 0x02,        // 0000 0010 bits 1
        8,  0, 0x20,        // 0010 0000 bits 5
        8,  0, 0x08,        // 0000 1000 bits 3
        8,  0, 0x80,        // 1000 0000 bits 7
 
        16,  1, 0x01,       // 0000 0001 bits 0 
        16,  2, 0x01,       // 0000 0001 bits 0 
        16,  1, 0x10,       // 0001 0000 bits 4
        16,  2, 0x10,       // 0001 0000 bits 4 
        16,  1, 0x04,       // 0000 0100 bits 2  
        16,  2, 0x04,       // 0000 0100 bits 2  
        16,  1, 0x40,       // 0100 0000 bits 6  
        16,  2, 0x40,       // 0100 0000 bits 6 
        16,  1, 0x02,       // 0000 0010 bits 1 
        16,  2, 0x02,       // 0000 0010 bits 1 
        16,  1, 0x20,       // 0010 0000 bits 5 
        16,  2, 0x20,       // 0010 0000 bits 5 
        16,  1, 0x08,       // 0000 1000 bits 3 
        16,  2, 0x08,       // 0000 1000 bits 3 
        16,  1, 0x80,       // 1000 0000 bits 7   
        16,  2, 0x80,       // 1000 0000 bits 7 

        32,  3, 0x01,       // 0000 0000 bits 0
        32,  5, 0x01,       // 0000 0000 bits 0
        32,  4, 0x01,       // 0000 0000 bits 0
        32,  6, 0x01,       // 0000 0000 bits 0
        32,  3, 0x10,       // 0000 0000 bits 4
        32,  5, 0x10,       // 0000 0000 bits 4
        32,  4, 0x10,       // 0000 0000 bits 4
        32,  6, 0x10,       // 0000 0000 bits 4
        32,  3, 0x04,       // 0000 0000 bits 2
        32,  5, 0x04,       // 0000 0000 bits 2
        32,  4, 0x04,       // 0000 0000 bits 2
        32,  6, 0x04,       // 0000 0000 bits 2
        32,  3, 0x40,       // 0000 0000 bits 6
        32,  5, 0x40,       // 0000 0000 bits 6
        32,  4, 0x40,       // 0000 0000 bits 6 
        32,  6, 0x40,       // 0000 0000 bits 6
        32,  3, 0x02,       // 0000 0000 bits 1
        32,  5, 0x02,       // 0000 0000 bits 1
        32,  4, 0x02,       // 0000 0000 bits 1
        32,  6, 0x02,       // 0000 0000 bits 1
        32,  3, 0x20,       // 0000 0000 bits 5
        32,  5, 0x20,       // 0000 0000 bits 5
        32,  4, 0x20,       // 0000 0000 bits 5
        32,  6, 0x20,       // 0000 0000 bits 5
        32,  3, 0x04,       // 0000 0000 bits 3
        32,  5, 0x04,       // 0000 0000 bits 3
        32,  4, 0x04,       // 0000 0000 bits 3
        32,  6, 0x04,       // 0000 0000 bits 3
        32,  3, 0x40,       // 0000 0000 bits 7
        32,  5, 0x40,       // 0000 0000 bits 7
        32,  4, 0x40,       // 0000 0000 bits 7
        32,  6, 0x40,       // 0000 0000 bits 7
        
    };

VOID
EHCI_EnablePeriodicList(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHC_OPERATIONAL_REGISTER hcOp;
    USBCMD cmd;
   
    hcOp = DeviceData->OperationalRegisters;
    
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.PeriodicScheduleEnable = 1;
    
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);
                         
    LOGENTRY(DeviceData, G, '_enP', cmd.ul, 0, 0); 
            
}    

 UCHAR ClassicPeriodIdx[8] = {
                           ED_INTERRUPT_1ms, //period = 1ms
                           ED_INTERRUPT_2ms, //period = 2ms       
                           ED_INTERRUPT_4ms, //period = 4ms       
                           ED_INTERRUPT_8ms, //period = 8ms       
                           ED_INTERRUPT_16ms,//period = 16ms       
                           ED_INTERRUPT_32ms,//period = 32ms       
                           ED_INTERRUPT_32ms,//period = 64ms               
                           ED_INTERRUPT_32ms //period = 128ms    
                           };

USB_MINIPORT_STATUS
EHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, qhPhys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    ULONG tdCount, bytes, offset;
    PPERIOD_TABLE periodTableEntry;
    BOOLEAN classic;
    PHCD_TRANSFER_DESCRIPTOR dummyTd;
    UCHAR periodIdx[8] = {
                           ED_INTERRUPT_1mf, //period = 1mf
                           ED_INTERRUPT_2mf, //period = 2mf       
                           ED_INTERRUPT_4mf, //period = 4mf       
                           ED_INTERRUPT_8mf, //period = 8mf       
                           ED_INTERRUPT_16mf,//period = 16mf       
                           ED_INTERRUPT_32mf,//period = 32mf       
                           ED_INTERRUPT_32mf,//period = 64mf               
                           ED_INTERRUPT_32mf //period = 128mf    
                           };

    classic = 
        (EndpointData->Parameters.DeviceSpeed != HighSpeed) ? TRUE : FALSE;
                    
    LOGENTRY(DeviceData, G, '_opI', EndpointData, EndpointParameters, classic);

    // select the proper list
    // the period is a power of 2 ie 
    // 32,16,8,4,2,1
    // we just need to find which bit is set
    GET_BIT_SET(EndpointParameters->Period, i);
    EHCI_ASSERT(DeviceData, i < 8);
    EHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

    InitializeListHead(&EndpointData->DoneTdList);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    offset = EndpointParameters->ScheduleOffset; 

    if (classic) {
        i = ClassicPeriodIdx[i];
        periodTableEntry = NULL;
    } else {
        i = periodIdx[i];
        periodTableEntry = &periodTable[i+offset];
    }        

    LOGENTRY(DeviceData, G, '_iep', EndpointData, 
        periodTableEntry, i);

    // locate the appropriate queue head and period 
    // table entry

    if (classic) {
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[i+offset];
        EndpointData->PeriodTableEntry = NULL;  
    } else {
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[periodTableEntry->qhIdx];
        EndpointData->PeriodTableEntry = periodTableEntry;         
    }

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;

    EndpointData->QhChkPhys = phys;
    EndpointData->QhChk = buffer;  
    RtlZeroMemory(buffer, 256);
    phys += 256;
    buffer += 256;
    bytes -= 256;
    
    // make the Ed
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;
    qhPhys = phys;
   
    phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    tdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    EHCI_ASSERT(DeviceData, tdCount >= TDS_PER_INTERRUPT_ENDPOINT);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        EHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->FreeTds = tdCount;

    EndpointData->QueueHead = 
        EHCI_InitializeQH(DeviceData,
                          EndpointData,
                          qh,
                          qhPhys);            

    if (classic) {    
        // use mask parameters passed to us
        qh->HwQH.EpCaps.InterruptScheduleMask = 
            EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
            EndpointParameters->SplitCompletionMask;
        
    } else {
        qh->HwQH.EpCaps.InterruptScheduleMask = 
            periodTableEntry->InterruptScheduleMask;        
    } 

    // init our polling variables
    dummyTd = EHCI_ALLOC_TD(DeviceData, EndpointData);
    dummyTd->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->NextHcdTD) = NULL;
    dummyTd->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;
    TRANSFER_DESCRIPTOR_PTR(dummyTd->AltNextHcdTD) = NULL;
    dummyTd->HwTD.Token.Active = 0;
    SET_FLAG(dummyTd->Flags, TD_FLAG_DUMMY);
    EndpointData->DummyTd = dummyTd;
    EndpointData->HcdHeadP = dummyTd;
    
    // endpoint is not active, set up the overlay
    // so that the currentTD is the Dummy
    
    qh->HwQH.CurrentTD.HwAddress = dummyTd->PhysicalAddress;
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT; 
    qh->HwQH.Overlay.qTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;    
    qh->HwQH.Overlay.qTD.Token.BytesToTransfer = 0;
    qh->HwQH.Overlay.qTD.Token.Active = 0;

    return USBMP_STATUS_SUCCESS;              
}


VOID
EHCI_InsertQueueHeadInPeriodicList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Insert an interrupt endpoint into the h/w schedule

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticQH, qh, nxtQH, prvQH;
    HW_LINK_POINTER hLink;

    staticQH = EndpointData->StaticQH;
    qh = EndpointData->QueueHead;

    EHCI_ASSERT(DeviceData,
                TEST_FLAG(staticQH->QhFlags, EHCI_QH_FLAG_STATIC));

    EHCI_ASSERT(DeviceData,
                !TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE));
    
    nxtQH = QH_DESCRIPTOR_PTR(staticQH->NextQh); 
    prvQH = staticQH;

    // Note: This function must be coherent with the budgeter code
    // the budgeter inserts endpoints such that the newer endpoints
    // are at the end of the sublist, older are at the begining. The 
    // lower the ordinal value the older the endpoint.  The ordinal 
    // values are used to maintain the same ordering in the event the
    // schedule must be reconstructed

    // hook this queue head to the the static 
    // queue head list, two cases

    // case 1:
    // insert QH1, queue head list is not empty:
    //
    // |staticQH|<->QH2<->QH3<->|staticQH|<->QH4
    //
    // |staticQH|<->QH2<->QH3<->QH1<->|staticQH|<->QH4
    //              (o=1)  (o=2)  (o=3)
    //  for case one qeue must insert the queue head in the list 
    //  based on the ordinal value we need to compute prev and
    //  next
    

    // case 2:
    // insert QH1, queue head sublist is empty
    //
    // |staticQH|<->|staticQH|<->QH4 
    //
    // |staticQH|<->QH1<->|staticQH|<->QH4
    
    LOGENTRY(DeviceData, G, '_inQ', EndpointData, qh, staticQH);    

    // find the correct spot
    // prvQH, nxtQH are currently the beginnig and end of the 
    // sublist
    qh->Ordinal = EndpointData->Parameters.Ordinal;
    qh->Period = EndpointData->Parameters.Period;
   
    if (TEST_FLAG(prvQH->QhFlags, EHCI_QH_FLAG_STATIC) &&
        (nxtQH == NULL || TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC))) {
        // case 2 qh list is empty
          
        LOGENTRY(DeviceData, G, '_iq1', prvQH, 0, nxtQH);    
        
    } else {
        // case 1 qh list is not empty 
        
        // find the correct position based on ordinal 
        while (nxtQH != NULL && 
               !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC) && 
               qh->Ordinal > nxtQH->Ordinal) {

            prvQH = nxtQH;
            nxtQH = QH_DESCRIPTOR_PTR(prvQH->NextQh);
            
        }                               
        
        //if (nxtQH != NULL && 
        //    !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        //    // middle insertion
        //    TEST_TRAP();
        //}            
    }


    // do the insertion
    
    QH_DESCRIPTOR_PTR(qh->NextQh) = nxtQH;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = prvQH;
    // next link points back
    if (nxtQH != NULL && 
        !TEST_FLAG(nxtQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        QH_DESCRIPTOR_PTR(nxtQH->PrevQh) = qh;
    }        

    // prev points to new qh
    QH_DESCRIPTOR_PTR(prvQH->NextQh) = qh;
    
    // now link to HW,order of operation is
    // important here
    hLink.HwAddress = qh->PhysicalAddress;
    SET_QH(hLink.HwAddress);
    
    qh->HwQH.HLink = prvQH->HwQH.HLink;
    prvQH->HwQH.HLink = hLink;

    SET_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
    
}


VOID
EHCI_RemoveQueueHeadFromPeriodicList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   remove an interrupt endpoint into from the h/w schedule

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticQH, qh, prevQH, nextQH;
    HW_LINK_POINTER hLink;

    staticQH = EndpointData->StaticQH;
    qh = EndpointData->QueueHead;

    if (!TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE))  {
        return;
    }
    
    LOGENTRY(DeviceData, G, '_rmQ', EndpointData, qh, staticQH);    

    
  
    // remove the queue head

    // remove QH2, two cases
    // |staticQH|<->QH1<->QH2<->QH3<->|staticQH|<->QH4
    //
    // |staticQH|<->QH1<->QH3<->|staticQH|<->QH4


    prevQH = QH_DESCRIPTOR_PTR(qh->PrevQh);
    nextQH = QH_DESCRIPTOR_PTR(qh->NextQh);

    // unlink next ptrs
    QH_DESCRIPTOR_PTR(prevQH->NextQh) = nextQH;
    if (nextQH != NULL && 
        !TEST_FLAG(nextQH->QhFlags, EHCI_QH_FLAG_STATIC)) {
        QH_DESCRIPTOR_PTR(nextQH->PrevQh) = prevQH;    
    }

    // hw unlink, nextqh will be null if this is period 1ms
    // qh
    if (nextQH == NULL) {
        hLink.HwAddress = 0;
        SET_T_BIT(hLink.HwAddress);
    } else {
        hLink.HwAddress = nextQH->PhysicalAddress;
        SET_QH(hLink.HwAddress);
    }             
    prevQH->HwQH.HLink = hLink;

    CLEAR_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE);
    QH_DESCRIPTOR_PTR(qh->NextQh) = NULL;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = NULL;
}


USB_MINIPORT_STATUS
EHCI_InterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferUrb,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize interrupt Transfer

    NOTES:
    
    HW pointers nextTD and AltNextTD are shadowed in 
    NextHcdTD and AltNextHcdTD.
    
    

Arguments:


--*/    
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR firstTd, prevTd, td;
    ULONG lengthMapped;
    
    // if we have enough TDs do the transfer
    if (EndpointData->FreeTds == 0) {
        TEST_TRAP();            
        LOGENTRY(DeviceData, G, '_IIS', EndpointData, TransferUrb, 0);
        return USBMP_STATUS_BUSY;
    }

    EndpointData->PendingTransfers++;

    // if we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_IIT', EndpointData, TransferUrb, 0);

    lengthMapped = 0;
    prevTd = NULL;
    
    while (lengthMapped < TransferUrb->TransferBufferLength) {

        TransferContext->PendingTds++;
        td = EHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        if (TransferContext->PendingTds == 1) {
            firstTd = td;
        } else if (prevTd) {
            SET_NEXT_TD(DeviceData, prevTd, td);
        } 
    
        //
        // fields for data TD
        //

        // use direction specified in transfer
        if (TEST_FLAG(TransferUrb->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            td->HwTD.Token.Pid = HcTOK_In;
        } else {
            td->HwTD.Token.Pid = HcTOK_Out;
        }                                   
        
        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        td->HwTD.Token.Active = 1;

        LOGENTRY(DeviceData, 
            G, '_dta', td, lengthMapped, TransferUrb->TransferBufferLength);

        lengthMapped = 
            EHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,     
                                      lengthMapped,
                                      NULL,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        prevTd = td;
         
    }

    // interrupt on the last TD
    td->HwTD.Token.InterruptOnComplete = 1;

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, td->PhysicalAddress, firstTd);

    // td points to last TD in this transfer, point it at the dummy
    SET_NEXT_TD(DeviceData, td, EndpointData->DummyTd);

    EHCI_LinkTransferToQueue(DeviceData,
                             EndpointData,
                             firstTd);

    ASSERT_DUMMY_TD(DeviceData, EndpointData->DummyTd);

    // tell the hc we have periodic transfers available
    EHCI_EnablePeriodicList(DeviceData);        

    return USBMP_STATUS_SUCCESS;
}


/* 
    CLASSIC

    The classic tree has 63 possible nodes, usport bw manager will select the 
    appropriate node based on a 'classic' bus.

    usbport maintains bandwidth management for each classic bus, however 
    budgeting the microframes is left to the miniport.

    classic 1ms interrupt schedule, NOTE:this schedule shares some queue heads with 
    the hish speed schedule.

    * = shared queue head

fr <32>  <16>  <08>   <04>      <02>              <01>
    
      
0   ( 0) -\ 
          ( 0)-\
16  ( 1) -/     \
                ( 0)-\
8   ( 2) -\     /     \
          ( 1)-/       \
24  ( 3) -/             \
                        *(0)-\
4   ( 4) -\             /    \
          ( 2)-\       /      \
20  ( 5) -/     \     /        \
                ( 1)-/          \
12  ( 6) -\     /                \
          ( 3)-/                  \  
28  ( 7) -/                        \
                                   *(0)-\
2   ( 8) -\                        /    \
          ( 4)-\                  /      \
18  ( 9) -/     \                /        \
                ( 2)-\          /          \
10  (10) -\     /     \        /            \
          ( 5)-/       \      /              \
26  (11) -/             \    /                \
                        *(1)-/                  \
6   (12) -\             /                       \
          ( 6)-\       /                         \
22  (13) -/     \     /                           \
                ( 3)-/                             \
14  (14) -\     /                                   \ 
          ( 7)-/                                     \
30  (15) -/                                           \
                                                      *(0)                          
1   (16) -\                                           /
          ( 8)-\                                     /
17  (17) -/     \                                   /
                ( 4)-\                             /
9   (18) -\     /     \                           /
          ( 9)-/       \                         /
25  (19) -/             \                       /
                        *(2)-\                  /
5   (20) -\             /    \                /
          (10)-\       /      \              /
21  (21) -/     \     /        \            /
                ( 5)-/          \          /
13  (22) -\     /                \        /
          (11)-/                  \      /
29  (23) -/                        \    /
                                   *(1)-/
3   (24) -\                        /
          (12)-\                  /
19  (25) -/     \                /
                ( 6)-\          /
11  (26) -\     /     \        /
          (13)-/       \      /
27  (27) -/             \    /   
                        *(3)-/
7   (28) -\             /
          (14)-\       /
23  (29) -/     \     /
                ( 7)-/
15  (30) -\     /
          (15)-/
31  (31) -/

     
    The node table is arrangened in the standard usb 1.1 fashion so that 
    the schedule offset passed to us by the budget engine applies
    
    // the static array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,


    CLASSIC BUDGET

    The classic budget is maintained by the port driver we 
    simply need to program the endpoint at the appropriate
    offset (node) with the given smask cmask

period(ms)    queue head(index)            
    1                0                          
    2                1                          
    2                2                                        
    4                3                          
    4                4                          
    4                5                          
    4                6                          
    8                7
    8                8
    8                9     
    8               10 
    8               11
    8               12
    8               13
    8               14
    
*/

UCHAR EHCI_Frame2Qhead[32] = {
/*
offset     ms frame
*/
0, //        0                    
16,//        1                 
8, //        2                
24,//        3               
4, //        4                
20,//        5               
12,//        6                 
28,//        7               
2, //        8                
18,//        9               
10,//       10
26,//       11
6, //       12               
22,//       13
14,//       14
30,//       15
1, //       16               
17,//       17
9, //       18
25,//       19
5, //       20               
21,//       21
13,//       22
29,//       23
3, //       24               
19,//       25
11,//       26
27,//       27
7, //       28               
23,//       29
15,//       30 
31,//       31
};

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetQueueHeadForFrame(
     PDEVICE_DATA DeviceData,
     ULONG Frame
    )
/*++

Routine Description:

Arguments:

Return Value:

    static queue head associated with a particular frame
    
--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG f;

    // normalize frame
    f = Frame%32;
        
    qh = DeviceData->StaticInterruptQH[EHCI_Frame2Qhead[f]+ED_INTERRUPT_32ms];

    return qh;
    
}


/* 

Queue head index table, values correspond to index in StaticQueueHead List

fr <32>  <16>  <08>   <04>      <02>              <01>
    
      
0   (31) -\ 
          (15)-\
16  (32) -/     \
                (7)-\
8   (33) -\     /     \
          (16)-/       \
24  (34) -/             \
                       *(3)-\
4   (35) -\             /    \
          (17)-\       /      \
20  (36) -/     \     /        \
                (8)-/          \
12  (37) -\     /                \
          (18)-/                  \  
28  (38) -/                        \
                                  *(1)-\
2   (39) -\                        /    \
          (19)-\                  /      \
18  (40) -/     \                /        \
                (9)-\          /          \
10  (41) -\     /     \        /            \
          (20)-/       \      /              \
26  (42) -/             \    /                \
                       *(4)-/                  \
6   (43) -\             /                       \
          (21)-\       /                         \
22  (44) -/     \     /                           \
                (10)-/                             \
14  (45) -\     /                                   \ 
          (22)-/                                     \
30  (46) -/                                           \
                                                      *(0)                          
1   (47) -\                                           /
          (23)-\                                     /
17  (48) -/     \                                   /
                (11)-\                             /
9   (49) -\     /     \                           /
          (24)-/       \                         /
25  (50) -/             \                       /
                       *(5)-\                  /
5   (51) -\             /    \                /
          (25)-\       /      \              /
21  (51) -/     \     /        \            /
                (12)-/          \          /
13  (53) -\     /                \        /
          (26)-/                  \      /
29  (54) -/                        \    /
                                  *(2)-/
3   (55) -\                        /
          (27)-\                  /
19  (56) -/     \                /
                (13)-\          /
11  (57) -\     /     \        /
          (28)-/       \      /
27  (58) -/             \    /   
                       *(6)-/
7   (59) -\             /
          (29)-\       /
23  (60) -/     \     /
                (14)-/
15  (61) -\     /
          (30)-/
31  (62) -/

*/

UCHAR EHCI_QHeadLinkTable[63] = {
    /* nextQueueHead    QueueHead */
           0xff,      //      0
           0,         //      1
           0,         //      2  
           1,         //      3
           1,         //      4
           2,         //      5
           2,         //      6
           3,         //      7
           3,         //      8
           4,         //      9
           4,         //      10
           5,         //      11
           5,         //      12
           6,         //      13
           6,         //      14
           7,         //      15
           7,         //      16
           8,         //      17
           8,         //      18
           9,         //      19
           9,         //      20
          10,         //      21
          10,         //      22
          11,         //      23
          11,         //      24
          12,         //      25
          12,         //      26
          13,         //      27
          13,         //      28
          14,         //      29
          14,         //      30
          15,         //      31
          15,         //      32
          16,         //      33
          16,         //      34
          17,         //      35
          17,         //      36
          18,         //      37
          18,         //      38
          19,         //      39
          19,         //      40
          20,         //      41
          20,         //      42
          21,         //      43
          21,         //      44          
          22,         //      45
          22,         //      46
          23,         //      47
          23,         //      48
          24,         //      49
          24,         //      50
          25,         //      51
          25,         //      52     
          26,         //      53
          26,         //      54
          27,         //      55
          27,         //      56
          28,         //      57
          28,         //      58
          29,         //      59     
          29,         //      60
          30,         //      61
          30,         //      62     
};


VOID
EHCI_InitailizeInterruptSchedule(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i;
    
    // first initialize all the 'dummy' queue heads
    
    for (i=0; i<63; i++) {
        qh = DeviceData->StaticInterruptQH[i];
        
        SET_T_BIT(qh->HwQH.Overlay.qTD.Next_qTD.HwAddress);
        qh->HwQH.Overlay.qTD.Token.Halted = 1;
        qh->HwQH.EpChars.HeadOfReclimationList = 0;
        qh->Sig = SIG_HCD_IQH;
    }

    
#define INIT_QH(q, nq, f) \
    do {\
    QH_DESCRIPTOR_PTR((q)->NextQh) = (nq); \
    QH_DESCRIPTOR_PTR((q)->PrevQh) = NULL; \
    (q)->HwQH.HLink.HwAddress = (nq)->PhysicalAddress; \
    (q)->HwQH.HLink.HwAddress |= EHCI_DTYPE_QH;\
    (q)->HwQH.EpCaps.InterruptScheduleMask =0xff;\
    (q)->QhFlags |= EHCI_QH_FLAG_STATIC;\
    (q)->QhFlags |= f;\
    } while(0)
    
    // now build the above tree
    for (i=1; i<63; i++) {        
        INIT_QH(DeviceData->StaticInterruptQH[i], 
                DeviceData->StaticInterruptQH[EHCI_QHeadLinkTable[i]],
                i<=6 ? EHCI_QH_FLAG_HIGHSPEED : 0);
    }

    // last qh has t bit set
    
    DeviceData->StaticInterruptQH[0]->HwQH.HLink.HwAddress = 0;        
    SET_T_BIT(DeviceData->StaticInterruptQH[0]->HwQH.HLink.HwAddress);
    DeviceData->StaticInterruptQH[0]->QhFlags |= 
        (EHCI_QH_FLAG_HIGHSPEED | EHCI_QH_FLAG_STATIC);
    
#undef INIT_QH    
}


VOID
EHCI_WaitFrames(
     PDEVICE_DATA DeviceData,
     ULONG Frames
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    FRINDEX frameIndex;
    ULONG frameNumber, i, c;

    hcOp = DeviceData->OperationalRegisters;

    for (c=0; c< Frames; c++) {
        // bugbug this code does not handle varaible frame list
        // sizes
        frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

        frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
        // shift off the microframes 
        frameNumber >>= 3;

        i = frameNumber;

        do {
            frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

            frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
            // shift off the microframes 
            frameNumber >>= 3;
        } while (frameNumber == i);
    }                

}


VOID
EHCI_RebalanceInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,        
    PENDPOINT_DATA EndpointData
    ) 
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    // update internal copy of parameters
    EndpointData->Parameters = *EndpointParameters;
    
    // period promotion?
    if (qh->Period != EndpointParameters->Period) {
        ULONG i, offset;
        
        EHCI_KdPrint((DeviceData, 1, "'period change old - %d new %d\n",
            qh->Period, EndpointParameters->Period));     
            
        EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                             EndpointData); 

        EHCI_WaitFrames(DeviceData, 2);

        // clear residual data from overlay area
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0;           
        qh->HwQH.Overlay.qTD.Token.SplitXstate = 0;
        qh->HwQH.Overlay.Ov.OverlayDw8.CprogMask = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.Sbytes = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.fTag = 0;
        
        
        EHCI_ASSERT(DeviceData, 
                    EndpointData->Parameters.DeviceSpeed != HighSpeed);
                    
        // select the proper list
        // the period is a power of 2 ie 
        // 32,16,8,4,2,1
        // we just need to find which bit is set
        GET_BIT_SET(EndpointParameters->Period, i);
        EHCI_ASSERT(DeviceData, i < 8);
        EHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

        offset = EndpointParameters->ScheduleOffset; 

        i = ClassicPeriodIdx[i];
        EndpointData->StaticQH = 
            DeviceData->StaticInterruptQH[i+offset];
        EndpointData->PeriodTableEntry = NULL;  

        qh->Period = EndpointParameters->Period;
        qh->HwQH.EpCaps.InterruptScheduleMask = 
                EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
                EndpointParameters->SplitCompletionMask;

        EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                           EndpointData); 
        
    } else {

        EHCI_RemoveQueueHeadFromPeriodicList(DeviceData,
                                             EndpointData); 

        EHCI_WaitFrames(DeviceData, 2);

        // clear residual data from overlay area
        qh->HwQH.Overlay.qTD.Token.ErrorCounter = 0; 
        qh->HwQH.Overlay.qTD.Token.SplitXstate = 0;
        qh->HwQH.Overlay.Ov.OverlayDw8.CprogMask = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.Sbytes = 0;
        qh->HwQH.Overlay.Ov.OverlayDw9.fTag = 0;
        
        qh->HwQH.EpCaps.InterruptScheduleMask = 
                EndpointParameters->InterruptScheduleMask;
        qh->HwQH.EpCaps.SplitCompletionMask = 
                EndpointParameters->SplitCompletionMask;

        EHCI_InsertQueueHeadInPeriodicList(DeviceData,
                                           EndpointData);                 
    }                
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\int.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-19-99 : created, jdunn

--*/



#include "common.h"


BOOLEAN
EHCI_InterruptService (
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_OPERATIONAL_REGISTER hcOp;
    ULONG enabledIrqs, frameNumber;
    USBSTS irqStatus;
    FRINDEX frameIndex;

    hcOp = DeviceData->OperationalRegisters;

    // assume it is not ours
    usbInt = FALSE;

    if (EHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        return FALSE;
    }
    // get a mask of possible interrupts
    enabledIrqs = READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);

    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    // just look at the IRQ status bits
    irqStatus.ul &= HcInterruptStatusMask;
    // AND with the enabled IRQs
    irqStatus.ul &= enabledIrqs;

    // irqStatus now possibly contains bits set for any currently
    // enabled interrupts

    if (irqStatus.ul != 0)  {

        DeviceData->IrqStatus = irqStatus.ul;

        WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul,
                             irqStatus.ul);

#if DBG

        if (irqStatus.HostSystemError) {
            // something has gone terribly wrong
            EHCI_ASSERT(DeviceData, FALSE);
        }
#endif

        // This code maintains the 32-bit 1 ms frame counter

        // bugbug this code does not handle varaible frame list
        // sizes
        frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

        frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
        // shut off the microframes
        frameNumber >>= 3;

        // did the sign bit change ?
        if ((DeviceData->LastFrame ^ frameNumber) & 0x0400) {
            // Yes
            DeviceData->FrameNumberHighPart += 0x0800 -
                ((frameNumber ^ DeviceData->FrameNumberHighPart) & 0x0400);
        }

        // remember the last frame number
        DeviceData->LastFrame = frameNumber;

        // inications are that this came from the
        // USB controller
        usbInt = TRUE;

        // disable all interrupts until the DPC for ISR runs
        //WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
        //                     0);

    }

    return usbInt;
}


VOID
EHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    USBSTS irqStatus, tmp;
    FRINDEX frameIndex;

    hcOp = DeviceData->OperationalRegisters;

    // ack all status bits asserted now
    //tmp.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    tmp.ul = DeviceData->IrqStatus;
    DeviceData->IrqStatus = 0;
    frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

    LOGENTRY(DeviceData, G, '_idp', tmp.ul, 0,
                 frameIndex.ul);

    //WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul,
    //                     tmp.ul);

    // now process status bits aserted,
    // just look at the IRQ status bits
    irqStatus.ul = tmp.ul & HcInterruptStatusMask;
    // AND with the enabled IRQs, these are the interrupts
    // we are interested in
    irqStatus.ul &= DeviceData->EnabledInterrupts.ul;


    if (irqStatus.UsbInterrupt ||
        irqStatus.UsbError ||
        irqStatus.IntOnAsyncAdvance) {
        LOGENTRY(DeviceData, G, '_iEP', irqStatus.ul, 0, 0);

        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);
    }

    if (irqStatus.PortChangeDetect) {
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    // since ehci does not provide a way to globally mask
    // interrupts we must mask off all interrupts in our ISR.
    // When the ISR DPC completes we re-enable the set of
    // currently enabled interrupts.

    if (EnableInterrupts) {
        LOGENTRY(DeviceData, G, '_iEE', 0, 0, 0);

        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                             DeviceData->EnabledInterrupts.ul);
    }
}


VOID
USBMPFN
EHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;

    hcOp = DeviceData->OperationalRegisters;

    // mask off all interrupts
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         0);
}


VOID
USBMPFN
EHCI_FlushInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBSTS irqStatus;

    hcOp = DeviceData->OperationalRegisters;

    // flush any outstanding interrupts
    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul,
                        irqStatus.ul);

}


VOID
USBMPFN
EHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;

    hcOp = DeviceData->OperationalRegisters;

    // activate the controllers interrupt
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         DeviceData->EnabledInterrupts.ul);

}


VOID
EHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBINTR enabledIrqs;

    hcOp = DeviceData->OperationalRegisters;

    // clear the port change interrupt
    enabledIrqs.ul =
        READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);

    enabledIrqs.PortChangeDetect =
        DeviceData->EnabledInterrupts.PortChangeDetect = 0;

    if (enabledIrqs.UsbInterrupt) {
        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                             enabledIrqs.ul);
    }
}


VOID
EHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBINTR enabledIrqs;

    hcOp = DeviceData->OperationalRegisters;

    // enable the port change interrupt
    enabledIrqs.ul =
        READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);

    enabledIrqs.PortChangeDetect =
            DeviceData->EnabledInterrupts.PortChangeDetect = 1;

    if (enabledIrqs.UsbInterrupt) {
        WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                             enabledIrqs.ul);
    }

}


VOID
EHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    USBCMD cmd;

    hcOp = DeviceData->OperationalRegisters;

    // before we use the doorbell enable the async list
    EHCI_EnableAsyncList(DeviceData);

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    cmd.IntOnAsyncAdvanceDoorbell = 1;

    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);
//  TEST_TRAP();
}


ULONG
EHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    )
{
    ULONG highPart, currentFrame, frameNumber;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    FRINDEX frameIndex;

    hcOp = DeviceData->OperationalRegisters;

     // get Hcd's high part of frame number
    highPart = DeviceData->FrameNumberHighPart;

    // bugbug this code does not handle varaible frame list
    // sizes
    frameIndex.ul = READ_REGISTER_ULONG(&hcOp->UsbFrameIndex.ul);

    frameNumber = (ULONG) frameIndex.FrameListCurrentIndex;
    // shift off the microframes
    frameNumber >>= 3;

    currentFrame = ((frameNumber & 0x0bff) | highPart) +
        ((frameNumber ^ highPart) & 0x0400);

    return currentFrame;

}


BOOLEAN
EHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    )
{
    ULONG tmp;
    PHC_OPERATIONAL_REGISTER hcOp;

    hcOp = DeviceData->OperationalRegisters;

    tmp = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    if (tmp == 0xffffffff) {
        if (Notify) {
            USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
        }
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\roothub.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus
MINIPORT_RH_GethubStatus

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "common.h"

#include "usbpriv.h"


typedef struct _EHCI_PORT_EVENT_CONTEXT {
    USHORT PortNumber;
} EHCI_PORT_EVENT_CONTEXT, *PEHCI_PORT_EVENT_CONTEXT;


VOID
EHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/
{
    HubData->NumberOfPorts =
        DeviceData->NumberOfPorts;

    if (DeviceData->PortPowerControl == 1) {
        HubData->HubCharacteristics.PowerSwitchType =
            USBPORT_RH_POWER_SWITCH_PORT;
    } else {
        HubData->HubCharacteristics.PowerSwitchType =
            USBPORT_RH_POWER_SWITCH_GANG;
    }

    HubData->HubCharacteristics.Reserved = 0;
    HubData->HubCharacteristics.OverCurrentProtection = 0;
    HubData->HubCharacteristics.CompoundDevice = 0;

    HubData->PowerOnToPowerGood = 2;
    // this value is the current consumed by the hub
    // brains, for the embeded hub this doesn't make
    // much sense.
    //
    // so we report zero
    HubData->HubControlCurrent = 0;

    LOGENTRY(DeviceData, G, '_hub', HubData->NumberOfPorts,
        DeviceData->PortPowerControl, 0);

}


USB_MINIPORT_STATUS
EHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnable (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    EHCI_KdPrint((DeviceData, 0, "port[%d] disable (1) %x\n", PortNumber, port.ul));

    port.PortEnable = 0;
    MASK_CHANGE_BITS(port);

    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                         port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortPower (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    // turn power off

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    port.PortPower = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RH_PortResumeComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port resume
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResumeContext = Context;
    USHORT portNumber;

    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResumeContext->PortNumber;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    LOGENTRY(DeviceData, G, '_pRS', port.ul,
        DeviceData->PortSuspendChange, portNumber);

EHCI_KdPrint((DeviceData, 1, "port[%d] resume (1) %x\n", portNumber, port.ul));

    // writing a 0 stops resume
    MASK_CHANGE_BITS(port);
    port.ForcePortResume = 0;
    port.PortSuspend = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
        port.ul);

    // indicate a change to suspend state ie resume complete
    SET_BIT(DeviceData->PortSuspendChange, portNumber-1);
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspend (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResumeContext;

    // resume the port
    hcOp = DeviceData->OperationalRegisters;

    // mask off CC chirping on this port
    SET_BIT(DeviceData->PortPMChirp, PortNumber-1);

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    // writing a 1 generates resume signalling
    port.ForcePortResume = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    // time it
    portResumeContext.PortNumber = PortNumber;
    // some hubs require us to wait longer if the downstream
    // device drivers resume for > 10 ms.  Looks like we need
    // 50 for the NEC B1 hub.
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in ms,
                                   &portResumeContext,
                                   sizeof(portResumeContext),
                                   EHCI_RH_PortResumeComplete);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspendChange (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    CLEAR_BIT(DeviceData->PortSuspendChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortOvercurrentChange (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    EHCI_KdPrint((DeviceData, 1,
                  "'EHCI_RH_ClearFeatureOvercurrentChange\n"));

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

    MASK_CHANGE_BITS(port);
    port.OvercurrentChange = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
EHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    portStatus->ul = 0;
    LOGENTRY(DeviceData, G, '_Pp1', PortNumber, port.ul, 0);

    // low speed detect, if low speed then do an immediate
    // handoff to the CC
    // This field is only valid if enable status is 0 and
    // connect status is 1
    if ((port.LineStatus == 1) &&
         port.PortOwnedByCC == 0 &&
         port.PortSuspend == 0 &&
         port.PortEnable == 0 &&
         port.PortConnect == 1 ) {

        EHCI_KdPrint((DeviceData, 1, "'low speed device detected\n"));

        // low speed device detected
        port.PortOwnedByCC = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                             port.ul);

        return USBMP_STATUS_SUCCESS;
    }

    // map the bits to the port status structure

    portStatus->Connected =
        port.PortConnect;
    portStatus->Enabled =
        port.PortEnable;
    portStatus->Suspended =
        port.PortSuspend;
    portStatus->OverCurrent =
        port.OvercurrentActive;
    portStatus->Reset =
        port.PortReset;
    portStatus->PowerOn =
        port.PortPower;
    portStatus->OwnedByCC =
        port.PortOwnedByCC;


    if (portStatus->Connected == 1) {
        portStatus->HighSpeed = 1;
        portStatus->LowSpeed = 0;
    } else {
        // report high speed when no device connected
        // this should work around a bug in the usbhub
        // driver -- the hub driver does not refresh the
        // port status register if the first reset attempt
        // fails.
        portStatus->HighSpeed = 1;
    }

    // chirping support allows us to use the
    // port change status bit
    if (port.PortConnectChange == 1) {
        SET_BIT(DeviceData->PortConnectChange, PortNumber-1);
    }

    portStatus->EnableChange =
        port.PortEnableChange;
    portStatus->OverCurrentChange =
        port.OvercurrentChange;

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortResetChange, PortNumber-1)) {
        portStatus->ResetChange = 1;
    }

    if (TEST_BIT(DeviceData->PortConnectChange, PortNumber-1)) {
        portStatus->ConnectChange = 1;
    }

    if (TEST_BIT(DeviceData->PortSuspendChange, PortNumber-1)) {
        portStatus->SuspendChange = 1;
    }

    LOGENTRY(DeviceData, G, '_gps',
        PortNumber, portStatus->ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RH_FinishReset(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResetContext = Context;
    USHORT portNumber;
    ULONG NecUsb2HubHack = 0;

    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResetContext->PortNumber;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    EHCI_KdPrint((DeviceData, 0, "port[%d] reset (4) %x\n", portNumber, port.ul));

    if (port.ul == 0xFFFFFFFF) {
        // just bail if hardware disappears
        return;
    }

    // at this point we will know if this is a high speed
    // device -- if it is not then we need to hand the port
    // to the CC

    // port enable of zero means we have a full or low speed
    // device (ie not chirping).
#if DBG
    if (port.PortConnect == 0) {
        EHCI_KdPrint((DeviceData, 0, "HS device dropped\n"));
    }
#endif
    if (port.PortEnable == 0 &&
        port.PortConnect == 1 &&
        port.PortConnectChange == 0) {

        // do the handoff
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        port.PortOwnedByCC = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                             port.ul);

        // do not indicate a reset change, this will cause the
        // hub driver to timeout the reset and detect that
        // no device is connected.  when this occurs on a USB 2
        // controller the hub driver will ignore the error.
        //CLEAR_BIT(DeviceData->PortResetChange, portNumber-1);
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
    } else {
        // we have a USB 2.0 device, indicate the reset change
        // NOTE if the device dropped off the bus (NEC USB 2 hub or
        // user removed it) we still indicate a reset change on high
        // speed
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    CLEAR_BIT(DeviceData->PortPMChirp, portNumber-1);

}


VOID
EHCI_RH_PortResetComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    PEHCI_PORT_EVENT_CONTEXT portResetContext = Context;
    USHORT portNumber;
    BOOLEAN forceHighSpeed = FALSE;
    ULONG microsecs;

    hcOp = DeviceData->OperationalRegisters;
    portNumber = portResetContext->PortNumber;

EHCI_RH_PortResetComplete_Retry:

    microsecs = 0;
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
    LOGENTRY(DeviceData, G, '_prC', port.ul,
        DeviceData->PortResetChange, portNumber);

EHCI_KdPrint((DeviceData, 0, "port[%d] reset (1) %x\n", portNumber, port.ul));

    // writing a 0 stops reset
    MASK_CHANGE_BITS(port);
    port.PortReset = 0;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                         port.ul);

    // wait for reset to go low -- this should be on the order of
    // microseconds
    do {

        KeStallExecutionProcessor(20);        // spec says 10 microseconds
                                              // Intel controller needs 20
        microsecs+=20;
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        EHCI_KdPrint((DeviceData, 1, "port[%d] reset (2) %x\n",
            portNumber, port.ul));

        if (microsecs > USBEHCI_MAX_RESET_TIME) {
            // > 1 microframe (125 us) has passed, retry
            EHCI_KdPrint((DeviceData, 0, "port[%d] reset (timeout) %x\n", portNumber, port.ul));
            goto EHCI_RH_PortResetComplete_Retry;
        }

      // bail if HW is gone
    } while (port.PortReset == 1 && port.ul != 0xFFFFFFFF);

EHCI_KdPrint((DeviceData, 0, "port[%d] reset (3) %x\n", portNumber, port.ul));

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in 10 ms,
                                   portResetContext,
                                   sizeof(*portResetContext),
                                   EHCI_RH_FinishReset);

}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResetContext;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_spr', port.ul,
        0, PortNumber);

    // mask off CC chirping on this port
    SET_BIT(DeviceData->PortPMChirp, PortNumber-1);

    // do a normal reset sequence
    LOGENTRY(DeviceData, G, '_res', port.ul, 0, PortNumber);
    MASK_CHANGE_BITS(port);
    port.PortEnable = 0;
    port.PortReset = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

    // schedule a callback
    portResetContext.PortNumber = PortNumber;
    // note that usbport calls us back with a copy of this
    // structure not the pointer to the original structure

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   50, // callback in x ms,
                                   &portResetContext,
                                   sizeof(portResetContext),
                                   EHCI_RH_PortResetComplete);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    // NOTE:
    // there should be no transactions in progress at the
    // time we suspend the port.
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_sps', port.ul,
        0, PortNumber);

    // writing a 1 suspends the port
    MASK_CHANGE_BITS(port);
    port.PortSuspend = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);
    // wiat 1 microframe for current transaction to finish
    KeStallExecutionProcessor(125);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_spp', port.ul,
        0, PortNumber);

    // writing a 1 turns on power
    MASK_CHANGE_BITS(port);
    port.PortPower = 1;
    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
        port.ul);
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    // do nothing, independent enable not supported

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    hcOp = DeviceData->OperationalRegisters;

    //
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_pcc', port.ul,
        0, PortNumber);

    // writing a 1 zeros the change bit
    if (port.PortConnectChange == 1) {
        // mask off other change bits
        MASK_CHANGE_BITS(port);
        port.PortConnectChange = 1;

        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
            port.ul);
    }

    CLEAR_BIT(DeviceData->PortConnectChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;

    LOGENTRY(DeviceData, G, '_cpe', PortNumber, 0, 0);

    hcOp = DeviceData->OperationalRegisters;

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    MASK_CHANGE_BITS(port);
    port.PortEnableChange = 1;

    WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    )
/*++
--*/
{
    // nothing intersting for the root
    // hub to report
    HubStatus->ul = 0;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{

    CLEAR_BIT(DeviceData->PortResetChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}



VOID
EHCI_OptumtuseratePort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Forces the port to high speed mode.

    NOTE:
    Current mechanism only works on the NEC controller.

--*/
{
      PHC_OPERATIONAL_REGISTER hcOp;
      PORTSC port;

      LOGENTRY(DeviceData, G, '_obt', PortNumber, 0, 0);

      hcOp = DeviceData->OperationalRegisters;

      port.ul = 0x5100a;

      WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
         port.ul);

      KeStallExecutionProcessor(10);        //stall for 10 microseconds

      // force high speed mode on the port
      port.ul = 0x01005;

      WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
          port.ul);

      KeStallExecutionProcessor(100);        //stall for 10 microseconds

}

USB_MINIPORT_STATUS
EHCI_RH_UsbprivRootPortStatus(
    PDEVICE_DATA DeviceData,
    ULONG ParameterLength,
    PVOID Parameters
    )
{

    PUSBPRIV_ROOTPORT_STATUS portStatusParams;
    PHC_OPERATIONAL_REGISTER hcOp;
    PRH_PORT_STATUS portStatus;
    PORTSC port;
    USHORT portNumber;

    if (ParameterLength < sizeof(USBPRIV_ROOTPORT_STATUS))
    {
        return (USBMP_STATUS_FAILURE);
    }

    //
    // Read the port status for this port from the registers
    //

    hcOp = DeviceData->OperationalRegisters;

    portStatusParams = (PUSBPRIV_ROOTPORT_STATUS) Parameters;

    portNumber = portStatusParams->PortNumber;
    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

    LOGENTRY(DeviceData, G, '_Up1', portNumber, port.ul, 0);

    //
    // Check to see if the port is resuming.  If so, clear the bit and
    //  reenable the port.
    //

    if (port.ForcePortResume)
    {
        //
        // Clear the port resume
        //

        USBPORT_WAIT(DeviceData, 50);

        MASK_CHANGE_BITS(port);
        port.ForcePortResume = 0;
        port.PortSuspend = 0;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul, port.ul);

        //
        // Reread the port status
        //

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

        SET_BIT(DeviceData->PortSuspendChange, portNumber-1);

        LOGENTRY(DeviceData, G, '_Up2', portNumber, port.ul, 0);
    }

    //
    // Map the current port information to the port status
    //

    portStatus = &portStatusParams->PortStatus;

    portStatus->ul = 0;
    portStatus->Connected =
        port.PortConnect;
    portStatus->Enabled =
        port.PortEnable;
    portStatus->Suspended =
        port.PortSuspend;
    portStatus->OverCurrent =
        port.OvercurrentActive;
    portStatus->Reset =
        port.PortReset;
    portStatus->PowerOn =
        port.PortPower;
    portStatus->OwnedByCC =
        port.PortOwnedByCC;

    if (portStatus->Connected == 1) {
        portStatus->HighSpeed = 1;
        portStatus->LowSpeed = 0;
    } else {
        // report high speed when no device connected
        // this should work around a bug in the usbhub
        // driver -- the hub driver does not refresh the
        // port status register if the first reset attempt
        // fails.
        portStatus->HighSpeed = 1;
    }

    portStatus->ConnectChange =
        port.PortConnectChange;
    portStatus->EnableChange =
        port.PortEnableChange;
    portStatus->OverCurrentChange =
        port.OvercurrentChange;

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortResetChange, portNumber-1)) {
        portStatus->ResetChange = 1;
    }

    if (TEST_BIT(DeviceData->PortConnectChange, portNumber-1)) {
        portStatus->ConnectChange = 1;
    }

    if (TEST_BIT(DeviceData->PortSuspendChange, portNumber-1)) {
        portStatus->SuspendChange = 1;
    }

    LOGENTRY(DeviceData, G, '_Ups',
        portNumber, portStatus->ul, port.ul);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_RH_ChirpRootPort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PORTSC port;
    EHCI_PORT_EVENT_CONTEXT portResetContext;
    ULONG mics;

    hcOp = DeviceData->OperationalRegisters;

#if DBG
    {
    USBCMD cmd;

    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    EHCI_ASSERT(DeviceData, cmd.HostControllerRun == 1);
    }
#endif

    port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
    LOGENTRY(DeviceData, G, '_chr', port.ul,
        0, PortNumber);

    EHCI_KdPrint((DeviceData, 0, ">port[%d] chirp %x\n", PortNumber, port.ul));

    if (TEST_BIT(DeviceData->PortPMChirp, PortNumber-1)) {
        // skip the chirp if we have already done this
        EHCI_KdPrint((DeviceData, 0, "<skip port chirp[%d] %x\n", PortNumber, port.ul));
        return USBMP_STATUS_SUCCESS;
    }

    if (!port.PortPower) {
        // skip if not powered, this will cause us to
        // bypass the chirp if the controller has not initialized
        // such as in the case of BOOT
        EHCI_KdPrint((DeviceData, 0, "<skip port chirp[%d] %x, no power\n", PortNumber, port.ul));
        return USBMP_STATUS_SUCCESS;
    }

    // port is connect and not enabled and not owned by CC
    // therefore we should probably chirp it
    if (port.PortConnect &&
        !port.PortEnable &&
        !port.PortOwnedByCC) {

        //TEST_TRAP();
        // quick check for handoff of LS devices
        if ((port.LineStatus == 1) &&
             port.PortOwnedByCC == 0 &&
             port.PortSuspend == 0 &&
             port.PortEnable == 0 &&
             port.PortConnect == 1 ) {

            // low speed device detected
            port.PortOwnedByCC = 1;
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul);
            EHCI_KdPrint((DeviceData, 0, ">port chirp[%d] %x, ->cc(1)\n", PortNumber,
                        port.ul));
            return USBMP_STATUS_SUCCESS;
        }

        // do a normal reset sequence
        LOGENTRY(DeviceData, G, '_rss', port.ul, 0, PortNumber);

        // set reset and clear connect change
        port.PortEnable = 0;
        port.PortReset = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

        USBPORT_WAIT(DeviceData, 10);

EHCI_RH_ChirpRootPort_Retry:

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
        MASK_CHANGE_BITS(port);
        port.PortReset = 0;
        mics = 0;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul, port.ul);

        // wait for reset to go low -- this should be on the order of
        // microseconds
        do {
            // writing a 0 stops reset
            KeStallExecutionProcessor(20);        // spec says 10 microseconds
                                                  // Intel controller needs 20
            mics +=20;
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            EHCI_KdPrint((DeviceData, 1, "port reset (2) %x\n", port.ul));

            if (mics > USBEHCI_MAX_RESET_TIME) {
                // reset did not clear in 1 microframe, try again to clear it
                goto EHCI_RH_ChirpRootPort_Retry;
            }
        } while (port.PortReset == 1);

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);

        if (port.PortEnable == 0) {

            // do the handoff
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            port.PortOwnedByCC = 1;
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul);

            EHCI_KdPrint((DeviceData, 0, "<port chirp[%d] %x, ->cc(2)\n", PortNumber,
                        port.ul));
        } else {
            // clear the enable bit so the device does not listen
            // on address 0
            port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul);
            port.PortEnable = 0;
            MASK_CHANGE_BITS(port);

            // allow some SOFs before we disable
            // The Cypress USB 2 device will drop off the bus if it doen't see
            // any SOFs
            USBPORT_WAIT(DeviceData, 10);
            SET_BIT(DeviceData->PortPMChirp, PortNumber-1);
            WRITE_REGISTER_ULONG(&hcOp->PortRegister[PortNumber-1].ul,
                                 port.ul);

            EHCI_KdPrint((DeviceData, 0, "<chirp port[%d] disable %x\n",
                PortNumber, port.ul));

        }
    } else {
         EHCI_KdPrint((DeviceData, 0, "<no port chirp[%d] %x\n", PortNumber, port.ul));
    }

    return USBMP_STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\sstool.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for sstool (single step tool) interface

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    1-1-00 : created, jdunn

--*/

#include "common.h"

typedef struct _SS_PACKET_CONTEXT {
    MP_HW_POINTER    Qh;
    MP_HW_POINTER    Td;
    MP_HW_POINTER    Data;
    ULONG padTo8[2];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

#define EHCI_TEST_TD_ALIGNMENT    256

C_ASSERT((sizeof(SS_PACKET_CONTEXT) <= EHCI_TEST_TD_ALIGNMENT));
C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) <= EHCI_TEST_TD_ALIGNMENT));
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) <= EHCI_TEST_TD_ALIGNMENT));


//implements the following miniport functions:

//non paged
//EHCI_StartSendOnePacket
//EHCI_EndSendOnePacket

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    PUCHAR pch, data;
    PSS_PACKET_CONTEXT context;
    HW_LINK_POINTER hwQh, tdLink;
    ULONG phys, qhPhys, tdPhys, dataPhys, i;
    ULONG siz;

    hcOp = DeviceData->OperationalRegisters;
    
    // allocate an TD from the scratch space and 
    // initialize it
    phys = WorkspacePhysicalAddress;
    pch = WorkspaceVirtualAddress;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch); 

    // specify a TD alignment to work around HW bugs.
    siz = EHCI_TEST_TD_ALIGNMENT;
    
    context = (PSS_PACKET_CONTEXT) pch;
    pch += siz;
    phys += siz;

    // carve out a qh
    qhPhys = phys;
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) pch;
    pch += siz;
    phys += siz;
    LOGENTRY(DeviceData, G, '_ssQ', qh, 0, qhPhys); 

    // carve out a TD
    tdPhys = phys;
    td = (PHCD_TRANSFER_DESCRIPTOR) pch;
    pch += siz;
    phys += siz;
    LOGENTRY(DeviceData, G, '_ssT', td, 0, tdPhys); 


    // use the rest for data
    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0); 

    dataPhys = phys;
    data = pch;
    RtlCopyMemory(data, PacketData, *PacketLength);
    pch+=*PacketLength;
    phys+=*PacketLength;

    // init qh
    RtlZeroMemory(qh, sizeof(*qh));
    qh->PhysicalAddress = qhPhys;
    ENDPOINT_DATA_PTR(qh->EndpointData) = NULL;
    qh->Sig = SIG_HCD_DQH;

    hwQh.HwAddress = qh->PhysicalAddress;
    SET_QH(hwQh.HwAddress);
    
    //qh->HwQH.EpChars.HeadOfReclimationList = 1;

    // manual Toggle
    qh->HwQH.EpChars.DataToggleControl = HcEPCHAR_Toggle_From_qTD;
    
    // init the hw descriptor
    qh->HwQH.EpChars.DeviceAddress = 
        PacketParameters->DeviceAddress;
    qh->HwQH.EpChars.EndpointNumber = 
        PacketParameters->EndpointAddress;


    qh->HwQH.EpCaps.HighBWPipeMultiplier = 1;        
    qh->HwQH.EpCaps.HubAddress = 0;
    qh->HwQH.EpCaps.PortNumber = 0;

    // link back to ourselves
    //qh->HwQH.HLink.HwAddress = hwQh.HwAddress;        
        
    switch (PacketParameters->Speed) {
    case ss_Low:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_LowSpeed;
        qh->HwQH.EpCaps.HubAddress = PacketParameters->HubDeviceAddress;
        qh->HwQH.EpCaps.PortNumber = PacketParameters->PortTTNumber;
        break;
    case ss_Full:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_FullSpeed;
        qh->HwQH.EpCaps.HubAddress = PacketParameters->HubDeviceAddress;
        qh->HwQH.EpCaps.PortNumber = PacketParameters->PortTTNumber;
        break;
    case ss_High:
        qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    } 
// jdxxx    
//qh->HwQH.EpChars.EndpointSpeed = HcEPCHAR_HighSpeed;    

    qh->HwQH.EpChars.MaximumPacketLength = 
        PacketParameters->MaximumPacketSize;

    // init td
    RtlZeroMemory(td, sizeof(*td));
    for (i=0; i<5; i++) {
        td->HwTD.BufferPage[i].ul = 0x0badf000;
    }

    td->PhysicalAddress = tdPhys;
    td->Sig = SIG_HCD_TD;
    
    switch(PacketParameters->Type) {
    case ss_Setup:
        LOGENTRY(DeviceData, G, '_sSU', 0, 0, 0); 
        td->HwTD.Token.Pid = HcTOK_Setup;
        break;
    case ss_In: 
        LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0); 
        td->HwTD.Token.Pid = HcTOK_In;
        break;
    case ss_Out:
        td->HwTD.Token.Pid = HcTOK_Out;
        LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0); 
        break;
    case ss_Iso_In:
        break;
    case ss_Iso_Out:       
        break;
    }

    switch(PacketParameters->Toggle) {
    case ss_Toggle0:
        td->HwTD.Token.DataToggle = HcTOK_Toggle0; 
        break;
    case ss_Toggle1:
        td->HwTD.Token.DataToggle = HcTOK_Toggle1;
        break;
    }  

    // prime the overlay with td so that this td
    // becomes the current td.
    qh->HwQH.Overlay.qTD.Next_qTD.HwAddress = 
        td->PhysicalAddress;

    td->HwTD.Token.Active = 1;
    td->HwTD.Token.ErrorCounter = PacketParameters->ErrorCount;

    // point TD at the data
    td->HwTD.BufferPage[0].ul = dataPhys;
    td->HwTD.Token.BytesToTransfer = *PacketLength;

    tdLink.HwAddress = 0;
    SET_T_BIT(tdLink.HwAddress);
    td->HwTD.Next_qTD.HwAddress = tdLink.HwAddress;
    td->HwTD.AltNext_qTD.HwAddress = tdLink.HwAddress;

    QH_DESCRIPTOR_PTR(context->Qh) = qh;
    TRANSFER_DESCRIPTOR_PTR(context->Td) = td;
    HW_PTR(context->Data) = data;

    *UsbdStatus = USBD_STATUS_SUCCESS;

    // stick the QH in the schedule and wait for it to complete
    
    // swap the async qh, wait one frame then 
    // replace the old value.

    // NOTE: This will interrupt normal bus operation for one ms

    //WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, hwQh.HwAddress);    
    EHCI_InsertQueueHeadInAsyncList(DeviceData, qh);                   

    EHCI_EnableAsyncList(DeviceData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
EHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PUCHAR pch;
    PSS_PACKET_CONTEXT context;
    HW_LINK_POINTER asyncHwQh;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    PUCHAR data;

    LOGENTRY(DeviceData, G, '_ssE', 0, 0, 0); 

    hcOp = DeviceData->OperationalRegisters;
    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;

    qh = QH_DESCRIPTOR_PTR(context->Qh);
    td = TRANSFER_DESCRIPTOR_PTR(context->Td);
    data = HW_PTR(context->Data);

    LOGENTRY(DeviceData, G, '_sE2', qh, td, *PacketLength ); 

    asyncHwQh.HwAddress = DeviceData->AsyncQueueHead->PhysicalAddress;
    SET_QH(asyncHwQh.HwAddress);

    *PacketLength = *PacketLength - td->HwTD.Token.BytesToTransfer;    

    LOGENTRY(DeviceData, G, '_sE3', td->HwTD.Token.BytesToTransfer, td,  
        *PacketLength );     
        
    RtlCopyMemory(PacketData, data, *PacketLength);

    EHCI_DisableAsyncList(DeviceData);

    EHCI_RemoveQueueHeadFromAsyncList(DeviceData, qh);                   
    
//    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, asyncHwQh.HwAddress);    

    // return the error here
    *UsbdStatus = USBD_STATUS_SUCCESS;
    if (td->HwTD.Token.Halted == 1) {
        if (td->HwTD.Token.XactErr) {
            *UsbdStatus = USBD_STATUS_XACT_ERROR;
        } else  if (td->HwTD.Token.BabbleDetected) {
            *UsbdStatus = USBD_STATUS_BABBLE_DETECTED;
        } else  if (td->HwTD.Token.DataBufferError) {
            *UsbdStatus = USBD_STATUS_DATA_BUFFER_ERROR;
        } else {
            *UsbdStatus = USBD_STATUS_STALL_PID;
        }
    }
    
    EHCI_KdPrint((DeviceData, 1, "'Status.XactErr %d\n",
        td->HwTD.Token.XactErr));    
    EHCI_KdPrint((DeviceData, 1, "'Status.BabbleDetected %d\n",
        td->HwTD.Token.BabbleDetected));  
    EHCI_KdPrint((DeviceData, 1, "'Status.DataBufferError %d\n",
        td->HwTD.Token.DataBufferError));
    
    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\async.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control, interrupt and bulk

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    6-26-99 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:

//non paged
//OHCI_OpenControlEndpoint
//OHCI_InterruptTransfer
//OHCI_OpenControlEndpoint


USB_MINIPORT_STATUS
OHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    PHCD_TRANSFER_DESCRIPTOR lastTd, td;    
    ULONG lengthMapped, dataTDCount = 0;    
    ULONG toggleForDataPhase = HcTDToggle_Data1;

    // see if we can handle this transfer (put it on the HW)
    // if not return BUSY, port driver will retry later

    ASSERT_TRANSFER(DeviceData, TransferContext);

    // NOTE: we can gate the number of transfers 
    // by a number of methods:
    //  - fixed count
    //  - available TDs
    //  - registry key
    
    // bugbug fixed to one transfer at a time for now

    //if (EndpointData->PendingTransfers == 
    //    EndpointData->MaxPendingTransfers) {
    //    TEST_TRAP();
    //    return USBMP_STATUS_BUSY;
    //}

    // Need one TD for every page of the data buffer, plus one for the SETUP
    // TD and one for the STATUS TD.
    //
    if (TransferSGList->SgCount + 2 > 
        OHCI_FreeTds(DeviceData, EndpointData)) {
        // not enough TDs!
        return USBMP_STATUS_BUSY;
    }        
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    //
    // first prepare a TD for the setup packet
    //
    
    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, 0);

    //        
    // grab the dummy TD from the tail of the queue
    //
    lastTd = td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);
    INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
    // count setup TD 
    TransferContext->PendingTds++;
    
    //
    // Move setup data into TD (8 chars long)
    //
    RtlCopyMemory(&td->HwTD.Packet[0],
                  &TransferParameters->SetupPacket[0],
                  8);
            
    td->HwTD.CBP = (ULONG)(((PCHAR) & td->HwTD.Packet[0])
                               - ((PCHAR) &td->HwTD)) + td->PhysicalAddress;
    td->HwTD.BE = td->HwTD.CBP + 7;
    td->HwTD.Control = 0;
    
    td->HwTD.Asy.Direction = HcTDDirection_Setup;
    td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
    td->HwTD.Asy.Toggle = HcTDToggle_Data0;
    td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;
        
                      
    LOGENTRY(DeviceData,
             G, '_set', 
             td, 
             *((PLONG) &TransferParameters->SetupPacket[0]), 
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate another TD       
    lastTd = td;
    td = OHCI_ALLOC_TD(DeviceData, EndpointData);
    OHCI_ASSERT(DeviceData, td != USB_BAD_PTR);
    INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
    SET_NEXT_TD(lastTd, td);
    
    //
    // now setup the data phase
    //

    lengthMapped = 0;
    while (lengthMapped < TransferParameters->TransferBufferLength) {
    
        //
        // fields for data TD
        //

        dataTDCount++;
        // count this Data TD
        TransferContext->PendingTds++;

        if (IN_TRANSFER(TransferParameters)) {          
            td->HwTD.Asy.Direction = HcTDDirection_In;
        } else {
            td->HwTD.Asy.Direction = HcTDDirection_Out;
        }
        td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
        td->HwTD.Asy.Toggle = toggleForDataPhase;
        td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;

        // after the first TD get the toggle from ED                                     
        toggleForDataPhase = HcTDToggle_FromEd;
        
        LOGENTRY(DeviceData, 
            G, '_dta', td, lengthMapped, TransferParameters->TransferBufferLength);

        lengthMapped = 
            OHCI_MapAsyncTransferToTd(DeviceData,
                                      EndpointData->Parameters.MaxPacketSize,     
                                      lengthMapped,
                                      TransferContext,
                                      td,
                                      TransferSGList);

        // allocate another TD                
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        OHCI_ASSERT(DeviceData, td != USB_BAD_PTR);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        SET_NEXT_TD(lastTd, td);

    }

    //
    // set the shortxfer OK bit on the last TD only
    //
    if (SHORT_TRANSFER_OK(TransferParameters)) {
        lastTd->HwTD.Asy.ShortXferOk = 1;   
        SET_FLAG(TransferContext->TcFlags, TC_FLAGS_SHORT_XFER_OK);         
    } 
    
    //
    // now do the status phase
    //

    LOGENTRY(DeviceData, G, '_sta', td, 0, dataTDCount);
#if DBG
    if (dataTDCount > 1) {
        TEST_TRAP();
    }
#endif

    // status direction is opposite data direction,
    // specify interrupt on completion
    
    td->HwTD.Control = 0;
    td->HwTD.Asy.IntDelay = HcTDIntDelay_0ms;
    td->HwTD.Asy.Toggle = HcTDToggle_Data1;
    td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;    
    td->HwTD.CBP = 0;
    td->HwTD.BE = 0;

    // status phase moves no data
    td->TransferCount = 0;
    SET_FLAG(td->Flags, TD_FLAG_CONTROL_STATUS);
    
    if (IN_TRANSFER(TransferParameters)) {
        td->HwTD.Asy.Direction = HcTDDirection_Out;
    } else {
        td->HwTD.Asy.Direction = HcTDDirection_In;
        td->HwTD.Asy.ShortXferOk = 1;            
    }

    // count status TD
    TransferContext->StatusTd = td;
    TransferContext->PendingTds++;

    OHCI_ASSERT(DeviceData, TransferContext->PendingTds == dataTDCount+2);
        
    //
    // now put a new dummy TD on the tail of the EP queue
    //

    // allocate the new dummy tail
    lastTd = td;
    td = OHCI_ALLOC_TD(DeviceData, EndpointData);
    OHCI_ASSERT(DeviceData, td != USB_BAD_PTR);
    SET_NEXT_TD(lastTd, td);
    SET_NEXT_TD_NULL(td);
    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //
    
    EndpointData->HcdTailP = 
        TransferContext->NextXferTd = td;
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, 
            td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
            
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;
    
    // tell the hc we have control transfers available
    OHCI_EnableList(DeviceData, EndpointData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_BulkOrInterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    PHCD_TRANSFER_DESCRIPTOR lastTd, td;    
    ULONG lengthMapped;    

    // see if we have enough free TDs to handle this transfer
    // if not return BUSY, port driver will retry later
    
    LOGENTRY(DeviceData, G, '_ITR', EndpointData, TransferParameters, 
        TransferContext);

    ASSERT_TRANSFER(DeviceData, TransferContext);
        
    //if (EndpointData->PendingTransfers == 
    //    EndpointData->MaxPendingTransfers) {
    //   LOGENTRY(DeviceData, G, '_bsy', EndpointData, TransferContext,
    //       TransferParameters);
    //    
    //    return USBMP_STATUS_BUSY;
    //}

    if (TransferSGList->SgCount > 
        OHCI_FreeTds(DeviceData, EndpointData)) {
        // not enough TDs
        
        return USBMP_STATUS_BUSY;
    }   
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_nby', EndpointData, TransferParameters, 
        EndpointData->HcdEd);

    //        
    // grab the dummy TD from the tail of the queue
    //
    lastTd = td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);
    
    //
    // now setup the data TDs
    //

    // always build at least one data td
    lengthMapped = 0;
    
    do {

        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        
        //
        // fields for data TD
        //

        td->HwTD.Control = 0;
        td->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;
        td->HwTD.Asy.Toggle = HcTDToggle_FromEd;
        td->HwTD.Asy.ConditionCode = HcCC_NotAccessed;

        if (IN_TRANSFER(TransferParameters)) {
            td->HwTD.Asy.Direction = HcTDDirection_In;
        } else {
            // short transfers are OK on out packets.
            // actually I'm not even sure what this does
            // for outbound requests
            td->HwTD.Asy.Direction = HcTDDirection_Out;
            td->HwTD.Asy.ShortXferOk = 1;            
        }
        
        LOGENTRY(DeviceData, 
            G, '_ita', td, lengthMapped, TransferParameters->TransferBufferLength);
        TransferContext->PendingTds++;
        
        if (TransferParameters->TransferBufferLength != 0) {
            lengthMapped = 
                OHCI_MapAsyncTransferToTd(DeviceData,
                                          EndpointData->Parameters.MaxPacketSize,
                                          lengthMapped,
                                          TransferContext,
                                          td,
                                          TransferSGList);
        } else {
            OHCI_ASSERT(DeviceData, TransferSGList->SgCount == 0);

            td->HwTD.CBP = 0; 
            td->HwTD.BE = 0; 
            td->TransferCount = 0;
        }

        // allocate another TD                
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        OHCI_ASSERT(DeviceData, td != USB_BAD_PTR);
        SET_NEXT_TD(lastTd, td);

    } while (lengthMapped < TransferParameters->TransferBufferLength);

    //
    // About ShortXferOk:
    //
    // This bit will trigger the controller to generate an error
    // and halt the ed if it is not set. The client may specify 
    // behavior on short transfers (packets) in the transfersFlags
    // field of the URB.
    //

    // we must not set short transfer OK on split transfers since
    // the next transfer may not be a new transfer
    
    if (SHORT_TRANSFER_OK(TransferParameters) && 
        !TEST_FLAG(TransferParameters->MiniportFlags, MPTX_SPLIT_TRANSFER)) {

        // we can only set this bit in the last TD of the 
        // transfer since that TD points to the next transfer.
        //
        // All other TDs must still generate an error and the
        // ed must be resumed by us.

        lastTd->HwTD.Asy.ShortXferOk = 1;   
        SET_FLAG(TransferContext->TcFlags, TC_FLAGS_SHORT_XFER_OK);  
    }
    
    lastTd->HwTD.Asy.IntDelay = HcTDIntDelay_0ms;
    
    //
    // now put a new dummy TD on the tail of the EP queue
    //

    SET_NEXT_TD(lastTd, td);
    SET_NEXT_TD_NULL(td);

    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //

    TransferContext->NextXferTd = 
        EndpointData->HcdTailP = td;
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds , 
        td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
        
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;

    LOGENTRY(DeviceData, G, '_ego', EndpointData->HcdHeadP,
                 TransferContext->TcFlags, 0);                   

    // tell the hc we have bulk/interrupt transfers available
    OHCI_EnableList(DeviceData, EndpointData);        

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_OpenControlEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, available, tdCount;
    
    LOGENTRY(DeviceData, G, '_opC', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    available = EndpointParameters->CommonBufferBytes;

#if DBG
   {
        ULONG offset;
    
        offset = BYTE_OFFSET(buffer);

        // OHCI requires 16 byte alignemnt
        OHCI_ASSERT(DeviceData, (offset % 16) == 0);    
    }
#endif    
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_CONTROL];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    available -= sizeof(HCD_ENDPOINT_DESCRIPTOR);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;

    tdCount = available/sizeof(HCD_TRANSFER_DESCRIPTOR);
    LOGENTRY(DeviceData, G, '_tdC', tdCount, TDS_PER_CONTROL_ENDPOINT, 0);
    OHCI_ASSERT(DeviceData, tdCount >= TDS_PER_CONTROL_ENDPOINT);

    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    // control endpoints do not halt
    ed->EdFlags = EDFLAG_CONTROL | EDFLAG_NOHALT;
    
    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);
                                      
    return USBMP_STATUS_SUCCESS;            
}


USB_MINIPORT_STATUS
OHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, bytes, offset;
    // this is an index table that converts the 
    // period to a list index
    UCHAR periodTable[8] = {
                           ED_INTERRUPT_1ms, //period = 1ms
                           ED_INTERRUPT_2ms, //period = 2ms       
                           ED_INTERRUPT_4ms, //period = 4ms       
                           ED_INTERRUPT_8ms, //period = 8ms       
                           ED_INTERRUPT_16ms,//period = 16ms       
                           ED_INTERRUPT_32ms,//period = 32ms       
                           ED_INTERRUPT_32ms,//period = 64ms               
                           ED_INTERRUPT_32ms //period = 128ms    
                           };
                    
    
    // carve up our common buffer
    // TDS_PER_ENDPOINT TDs plus an ED
    
    LOGENTRY(DeviceData, G, '_opI', 0, 0, EndpointParameters->Period);
    

    // select the proper list
    // the period is a power of 2 ie 
    // 32,16,8,4,2,1
    // we just need to find which bit is set
    GET_BIT_SET(EndpointParameters->Period, i);
    OHCI_ASSERT(DeviceData, i < 8);
    OHCI_ASSERT(DeviceData, EndpointParameters->Period < 64);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    bytes = EndpointParameters->CommonBufferBytes;
    offset = EndpointParameters->ScheduleOffset; 
   
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[periodTable[i]+offset];

    LOGENTRY(DeviceData, G, '_lst', i, periodTable[i], offset);            

    // we found the correct base list 

    EndpointData->StaticEd->AllocatedBandwidth += 
        EndpointParameters->Bandwidth;
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    bytes -= sizeof(HCD_ENDPOINT_DESCRIPTOR); 

    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);

    OHCI_ASSERT(DeviceData, 
        EndpointData->TdCount >= TDS_PER_INTERRUPT_ENDPOINT);
    // Bugbug - use what we get
    for (i=0; i<EndpointData->TdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);

    return USBMP_STATUS_SUCCESS;              
}


USB_MINIPORT_STATUS
OHCI_OpenBulkEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, bytes;
    
    LOGENTRY(DeviceData, G, '_opB', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    bytes = EndpointParameters->CommonBufferBytes;
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_BULK];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    bytes -= sizeof(HCD_ENDPOINT_DESCRIPTOR); 
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);

    OHCI_ASSERT(DeviceData, 
        EndpointData->TdCount >= TDS_PER_BULK_ENDPOINT);
    // Bugbug - use what we get
    for (i=0; i<EndpointData->TdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                             EndpointData,
                             &EndpointData->TdList->Td[i],
                             phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);

    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);

    return USBMP_STATUS_SUCCESS;              
}


//
// When the HEADP is set to a new value we risk loosing 
// the current data toggle stored there. 
// This macro resets headp and preserves the flags which
// include the toggle.
//
#define RESET_HEADP(dd, ed, address) \
    {\
    ULONG headp;\
    headp = ((ed)->HwED.HeadP & HcEDHeadP_FLAGS) | (address);\
    LOGENTRY((dd), G, '_rhp', headp, (ed), 0); \
    (ed)->HwED.HeadP = headp; \
    }



VOID
OHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    
    The goal here is to determine which TDs, if any, 
    have completed and complete ant associated transfers

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    PTRANSFER_CONTEXT transfer;
    BOOLEAN clearHalt = FALSE;
    HW_32BIT_PHYSICAL_ADDRESS headP;
    
    ed = EndpointData->HcdEd;

    LOGENTRY(DeviceData, G, '_pol', ed, EndpointData, 0);        

    // note it is important the the compiler generate a 
    // dword move when reading the queuehead HeadP register 
    // since this location is also accessed by the host
    // hardware
    headP = ed->HwED.HeadP;

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(headP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);
                                            
    LOGENTRY(DeviceData, G, '_cTD', currentTd, 
        headP & ~HcEDHeadP_FLAGS, 
            TRANSFER_CONTEXT_PTR(currentTd->TransferContext));                 


    if (ed->HwED.HeadP & HcEDHeadP_HALT) {
        // ed is 'halted'
        LOGENTRY(DeviceData, G, '_hlt', ed, EndpointData->HcdHeadP, 0);        

        clearHalt = (BOOLEAN) (ed->EdFlags & EDFLAG_NOHALT);

        // walk the swHeadP to the currentTD this (this will
        // be the first TD after the offending TD)

        td = EndpointData->HcdHeadP;
        while (td != currentTd) {
        
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        

            OHCI_ASSERT(DeviceData, !TEST_FLAG(td->Flags, TD_FLAG_DONE));
            LOGENTRY(DeviceData, G, '_wtd', td, transfer->TcFlags, transfer);        

            if (td->HwTD.Asy.ConditionCode == HcCC_NoError) {
                // not the offending TD,
                // mark this TD done
                SET_FLAG(td->Flags, TD_FLAG_DONE);
                OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                            td->DoneLink.Blink == NULL);
                InsertTailList(&EndpointData->DoneTdList,
                               &td->DoneLink);
            } else {
                // some kind of error 
                if (td->HwTD.Asy.ConditionCode == HcCC_NotAccessed) {
                
                    // if the 'current transfer' is DONE because 
                    // of a short packet then the remaining TDs 
                    // need to be flushed out.
                    // current TD should be pointing at the next 
                    // TD to run (next transfer or status for control)
                    
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    SET_FLAG(td->Flags, TD_FLAG_SKIP);
                    OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                                td->DoneLink.Blink == NULL);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    
                    LOGENTRY(DeviceData, G, '_fld', td, 0, 0);             
                
                } else if (td->HwTD.Asy.ConditionCode == HcCC_DataUnderrun && 
                    TEST_FLAG(transfer->TcFlags, TC_FLAGS_SHORT_XFER_OK)) {

                    // special case HcCC_DataUnderrun.  this error 
                    // needs to be ignored if shortxferOK is set.

                    // cases handled (HcCC_DataUnderrun):
                    //
                    // 1. control transfer and error before the status phase w/
                    //      short xfer OK 
                    //      we need to advance to the status phase and ignore 
                    //      error and resume ep
                    //
                    // 2. interrupt/bulk with short xfer OK, ignore the error 
                    //      advance to the next transfer resume ep
                    //

                    LOGENTRY(DeviceData, G, '_sok', td, 0, 0);        
                                    

                    // reset the error on the offending Td
                    td->HwTD.Asy.ConditionCode = HcCC_NoError;    
                    // resume the ep
                    clearHalt = TRUE; 

                    // if this is a control transfer bump 
                    // HW headp to the status phase
                    if (!TEST_FLAG(td->Flags, TD_FLAG_CONTROL_STATUS) &&
                        transfer->StatusTd != NULL) {
                        // control transfer data phase, bump 
                        // HW headp to the status phase
                        TEST_TRAP();
                        RESET_HEADP(DeviceData, ed, transfer->StatusTd->PhysicalAddress);
                        currentTd = transfer->StatusTd;
                    } else {

                        // if the current transfer is a split we must flush
                        // all other split elements as well.
                        
                        if (transfer->TransferParameters->MiniportFlags & 
                            MPTX_SPLIT_TRANSFER) {

                            PTRANSFER_CONTEXT tmpTransfer;
                            PHCD_TRANSFER_DESCRIPTOR tmpTd;
                            ULONG seq;
                            
                            TEST_TRAP();

                            seq = transfer->TransferParameters->SequenceNumber;
                            tmpTd = transfer->NextXferTd;
                            tmpTransfer = 
                                TRANSFER_CONTEXT_PTR(tmpTd->TransferContext);

                            // find the first tranfer with a new sequence
                            // number or the tail of the list
                                
                            while (tmpTransfer != FREE_TD_CONTEXT && 
                                   tmpTransfer->TransferParameters->SequenceNumber 
                                       == seq) {

                                // mark all TDs done for this transfer
            
                                tmpTd = tmpTransfer->NextXferTd;
                                tmpTransfer = 
                                    TRANSFER_CONTEXT_PTR(tmpTd->TransferContext);                                           
                            }
                            
                            RESET_HEADP(DeviceData, ed, tmpTd->PhysicalAddress);   
                            currentTd = tmpTd;
                            
                        } else {
                            // bump HW headp to the next transfer
                            RESET_HEADP(DeviceData, ed, transfer->NextXferTd->PhysicalAddress);   
                            currentTd = transfer->NextXferTd;

                        }
                    }
                           
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                                td->DoneLink.Blink == NULL);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    
                } else {
                    // general error, mark the TD as completed
                    // update Headp to point to the next transfer
                    LOGENTRY(DeviceData, G, '_ger', td, 0, 0);  
                    
                    SET_FLAG(td->Flags, TD_FLAG_DONE);
                    OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                                td->DoneLink.Blink == NULL);
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                    RESET_HEADP(DeviceData, ed, transfer->NextXferTd->PhysicalAddress)
                    currentTd = transfer->NextXferTd;
                    
                 }
            }
            // we walk the SW links
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            
        } /* while */

    } else {
    
        // ed is not 'halted'

        // First walk the swHeadP to the current TD (hw headp)               
        // mark all TDs we find as completed
        //
        // NOTE: this step may be skipped if the 
        // done queue is reliable

        td = EndpointData->HcdHeadP;

        LOGENTRY(DeviceData, G, '_nht', td, currentTd, 0);        

        while (td != currentTd) {
            LOGENTRY(DeviceData, G, '_mDN', td, 0, 0); 
            SET_FLAG(td->Flags, TD_FLAG_DONE);
            OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                        td->DoneLink.Blink == NULL);
            InsertTailList(&EndpointData->DoneTdList,
                           &td->DoneLink);
                
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
        }            
    }

    // set the sw headp to the new current head
    EndpointData->HcdHeadP = currentTd;
    
    // now flush all completed TDs
    // do this in order of completion

    // now flush all completed TDs. Do it in order of completion.
    while (!IsListEmpty(&EndpointData->DoneTdList)) {
    
        PLIST_ENTRY listEntry;
    
        listEntry = RemoveHeadList(&EndpointData->DoneTdList);
        
        
        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR, 
                     DoneLink);
           

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            OHCI_ProcessDoneAsyncTd(DeviceData,
                                    td,
                                    TRUE);
        }
                                
    }
#if 0    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {
            OHCI_ProcessDoneAsyncTd(DeviceData,
                                    td,
                                    TRUE);
        }                                  
    }
#endif
     
    if (clearHalt) {
        // auto clear the halt condition and
        // resume processing on the endpoint
        LOGENTRY(DeviceData, G, '_cht', ed, 0, 0);  
        ed->HwED.HeadP &= ~HcEDHeadP_HALT;       
    }

}


VOID
OHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    )
/*++

Routine Description:

    process a completed TD

Parameters
    
--*/
{
    PTRANSFER_CONTEXT transferContext;    
    PENDPOINT_DATA endpointData;
    USBD_STATUS usbdStatus;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    LOGENTRY(DeviceData, G, '_Dtd', transferContext, 
                         Td->HwTD.Asy.ConditionCode,
                         Td);       

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {

        OHCI_ASSERT(DeviceData, HcCC_NotAccessed == Td->HwTD.Asy.ConditionCode);
        // td was unused, part of short-transfer
        LOGENTRY(DeviceData, G, '_skT', Td, transferContext, 0);
        Td->HwTD.Asy.ConditionCode = HcCC_NoError;
           
    } else {

        if (Td->HwTD.CBP) { 
            //
            // A value of 0 here indicates a zero length data packet
            // or that all bytes have been transfered.
            //
            // A non-zero value means we recieved a short packet and 
            // therefore need to adjust the transferCount to reflect bytes 
            // transferred
            
            //
            // The buffer is only spec'ed for length up to two 4K pages.
            // (BE is the physical address of the last byte in the
            // TD buffer.  CBP is the current byte pointer)
            //
            // TransferCount is intailized to the number of bytes to transfer,
            // we need to subtract the difference between the end and 
            // current ptr (ie end-current = bytes not transferred) and
            // update the TransferCount.

            // transfer count should never go negative
            // TransferCount will be zero on the status 
            // phase of a control transfer so we skip 
            // the calculation

            if (Td->TransferCount) {
                Td->TransferCount -=
                    /* have we gone further than a page? */
                    ((((Td->HwTD.BE ^ Td->HwTD.CBP) & ~OHCI_PAGE_SIZE_MASK)
                      ? OHCI_PAGE_SIZE : 0) +
                    /* minus the data buffer not used */
                    ((Td->HwTD.BE & OHCI_PAGE_SIZE_MASK) - 
                     (Td->HwTD.CBP & OHCI_PAGE_SIZE_MASK)+1));
            }            
            LOGENTRY(DeviceData, G, '_xfB', Td->HwTD.BE & OHCI_PAGE_SIZE_MASK, 
                             Td->HwTD.CBP & OHCI_PAGE_SIZE_MASK,
                             Td->TransferCount);                         
        }            

        if (HcTDDirection_Setup != Td->HwTD.Asy.Direction) {  
            
            // data phase of a control transfer or a bulk/int 
            // data transfer 
            LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, Td->TransferCount);
            
            transferContext->BytesTransferred += Td->TransferCount;
        }
        
        if (HcCC_NoError == Td->HwTD.Asy.ConditionCode) { 

            LOGENTRY(DeviceData, G, '_tOK', Td->HwTD.CBP, 0, 0);    

        } else {
            // map the error to code in USBDI.H

            transferContext->UsbdStatus =
                (Td->HwTD.Asy.ConditionCode | 0xC0000000);
                
            LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
        }
    }        

    // mark the TD free
    OHCI_FREE_TD(DeviceData, endpointData, Td);
    
    if (transferContext->PendingTds == 0 && CompleteTransfer) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate 
        // we can teake another
        endpointData->PendingTransfers--;

        LOGENTRY(DeviceData, G, '_cpt', 
            transferContext->UsbdStatus, 
            transferContext, 
            transferContext->BytesTransferred);
            
        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  transferContext->TransferParameters,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}

// figure out which sgentry a particular offset in to 
// a client buffer falls
#define GET_SG_INDEX(sg, i, offset)\
    do {\
    for((i)=0; (i) < (sg)->SgCount; (i)++) {\
        if ((offset) >= (sg)->SgEntry[(i)].StartOffset &&\
            (offset) < (sg)->SgEntry[(i)].StartOffset+\
                (sg)->SgEntry[(i)].Length) {\
            break;\
        }\
    }\
    } while (0)

#define GET_SG_OFFSET(sg, i, offset, sgoffset)\
    (sgoffset) = (offset) - (sg)->SgEntry[(i)].StartOffset


ULONG
OHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td, 
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps a data buffer to TDs according to OHCI rules

    An OHCI TD can cover up to 8k with a single page crossing.

    Each sg entry represents one 4k OHCI 'page' 

x = pagebreak
c = current ptr
b = buffer start
e = buffer end


    {..sg[sgIdx]..}
b...|---
    x--c----
    [  ]
        \ 
         sgOffset
[      ]
        \
         LengthMapped   
    

case 1: (1 sg entry remains)
    (A)- transfer < 4k, no page breaks (if c=b sgOffset = 0)
    
      {.sg0...}     
      | b---->e      
      x-c------x
        [..TD.]

    (B)- last part of a transfer
    
            {..sgN..}
      b.....|.c---->e        
            x--------x    
              [..TD.]

case 2:  (2 sg entries remain)
    (A)- transfer < 8k, one page break (if c=b sgOffset = 0)
         
     {..sg0..}{..sg1..}
     |   b----|----->e
     x---c----x--------x   
         [.....TD....]
         
    (B)- last 8k of transfer

           {.sgN-1.}{..sgN..} 
      b....|--------|---->e
           x-c------x--------x        
           [.....TD.......]

case 3: (3+ sg entries remain)
    (A)- transfer 8k, two page breaks (c=b)

     {..sg0..}{..sg1..}{..sg2..}
         b----|--------|--->e
     x---c----x--------x--------x
         [.....TD...<>]
        <>=<TD length must be multiple of MaxPacketSize>

    (B)- continuation of large tarnsfer

           {.sgN-2.}{.sgN-1.}{..sgN..}
        b..|--------------------->e
           x--c-----x--------x--------x
              [.....TD......]  
        <TD length must be multiple of MaxPacketSize>    

Interesting DMA tests (USBTEST):

    length, offset - cases hit
    
    4096 0 - 1a
    4160 0 - 2a
    4096 512 - 2a
    8192 512 - 3a, 1b
    8192 513 - 3a, 2b
    12288 1 - 3a, 3b, 2b
    
Arguments:

Returns:

    LengthMapped
    
--*/
{
    HW_32BIT_PHYSICAL_ADDRESS logicalStart, logicalEnd;
    ULONG sgIdx, sgOffset;
    ULONG lengthThisTd;
    PTRANSFER_PARAMETERS transferParameters;
    
    // A TD can have up to one page crossing.  This means we 
    // can put two sg entries in to one TD, one for the first 
    // physical page, and one for the second.

    // point to first entry

    LOGENTRY(DeviceData, G, '_Mpr', TransferContext,
        0, LengthMapped); 

    transferParameters = TransferContext->TransferParameters;
    
    OHCI_ASSERT(DeviceData, SgList->SgCount != 0);

    GET_SG_INDEX(SgList, sgIdx, LengthMapped);
    LOGENTRY(DeviceData, G, '_Mpp', SgList, 0, sgIdx); 
    OHCI_ASSERT(DeviceData, sgIdx < SgList->SgCount);

    // check for one special case where the SG entries
    // all map to the same physical page
    if (TEST_FLAG(SgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE)) {
        // in this case we map each sg entry to a single TD
        LOGENTRY(DeviceData, G, '_cOD', SgList, 0, sgIdx);

//        TEST_TRAP();

        // adjust for the amount of buffer consumed by the 
        // previous TD
        logicalStart = 
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32;
            
        lengthThisTd = SgList->SgEntry[sgIdx].Length;
        
        logicalEnd = SgList->SgEntry[sgIdx].LogicalAddress.Hw32; 
        logicalEnd += lengthThisTd;

        OHCI_ASSERT(DeviceData, lengthThisTd <= OHCI_PAGE_SIZE)            

        goto OHCI_MapAsyncTransferToTd_Done;

    }
    
    if ((SgList->SgCount-sgIdx) == 1) {
        // first case, 1 entries left 
        // ie <4k, we can fit this in 
        // a single TD.

#if DBG
        if (sgIdx == 0) {
            // case 1A
            // USBT dma test length 4096, offset 0
            // will hit this case
            // TEST_TRAP();
            LOGENTRY(DeviceData, G, '_c1a', SgList, 0, sgIdx);
        } else {
            // case 1B
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c1b', SgList, 0, sgIdx);
            
        }
#endif
        lengthThisTd = 
            transferParameters->TransferBufferLength - LengthMapped;

        // compute offset into this TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);       
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 

        // adjust for the amount of buffer consumed by the 
        // previous TD
        logicalStart = 
            SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + sgOffset;
        lengthThisTd -= sgOffset;
        
        logicalEnd = SgList->SgEntry[sgIdx].LogicalAddress.Hw32; 
        logicalEnd += lengthThisTd;

        LOGENTRY(DeviceData, G, '_sg1', logicalStart, 0, logicalEnd); 
        
    } else if ((SgList->SgCount - sgIdx) == 2) {
    
        // second case, 2 entries left 
        // ie <8k we can also fit this in 
        // a single TD.
#if DBG
        if (sgIdx == 0) {
            // case 2A
            // USBT dma test length 4160 offset 0
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2a', SgList, 0, sgIdx);
            
        } else {
            // case 2B
            // USBT dma test length 8192 offset 513
            // will hit this case
            LOGENTRY(DeviceData, G, '_c2b', SgList, 0, sgIdx);
            //TEST_TRAP();
            // bugbug run with DMA test
        }
#endif
        lengthThisTd = 
            transferParameters->TransferBufferLength - LengthMapped;

        // compute offset into first TD
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);   
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 
#if DBG
        if (sgIdx == 0) {
             OHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif

        // adjust pointers for amount consumed by previous TD
        logicalStart = SgList->SgEntry[sgIdx].LogicalAddress.Hw32 + 
            sgOffset;
            
        logicalEnd = SgList->SgEntry[sgIdx+1].LogicalAddress.Hw32; 
        logicalEnd += SgList->SgEntry[sgIdx+1].Length;

        LOGENTRY(DeviceData, G, '_sg2', logicalStart, 
            lengthThisTd, logicalEnd); 
        
    } else {
        // third case, more than 2 sg entries.
        //
        ULONG adjust, packetCount;
#if DBG
        if (sgIdx == 0) {
            // case 3A
            // USBT dma test length 8192 offset 512
            // will hit this case
            LOGENTRY(DeviceData, G, '_c3a', SgList, 0, sgIdx);
            
        } else {
            // case 3B
            // USBT dma test length 12288 offset 1
            // will hit this case
            LOGENTRY(DeviceData, G, '_c3b', SgList, 0, sgIdx);
            
        }
#endif        
        // sg offset is the offset in to the current TD to start
        // using
        // ie it is the number of bytes already consumed by the 
        // previous td
        GET_SG_OFFSET(SgList, sgIdx, LengthMapped, sgOffset);   
        LOGENTRY(DeviceData, G, '_sgO', sgOffset, sgIdx, LengthMapped); 
#if DBG
        if (sgIdx == 0) {
             OHCI_ASSERT(DeviceData, sgOffset == 0);
        }
#endif
        //
        // consume the next two sg entrys
        //
        logicalStart = SgList->SgEntry[sgIdx].LogicalAddress.Hw32+
            sgOffset;

        logicalEnd = SgList->SgEntry[sgIdx+1].LogicalAddress.Hw32+
            SgList->SgEntry[sgIdx+1].Length;             
        
        lengthThisTd = SgList->SgEntry[sgIdx].Length +
                       SgList->SgEntry[sgIdx+1].Length -
                       sgOffset;

        // round TD length down to the highest multiple
        // of max_packet size
        
        packetCount = lengthThisTd/MaxPacketSize;
        LOGENTRY(DeviceData, G, '_sg3', logicalStart, packetCount, logicalEnd); 

        adjust = lengthThisTd - packetCount*MaxPacketSize;

        lengthThisTd = packetCount*MaxPacketSize;
        if (adjust) {        
            OHCI_ASSERT(DeviceData, adjust > (logicalEnd & 0x00000FFF));
            logicalEnd-=adjust;
            LOGENTRY(DeviceData, G, '_adj', adjust, lengthThisTd, logicalEnd); 
        }            

        OHCI_ASSERT(DeviceData, lengthThisTd != 0);
        OHCI_ASSERT(DeviceData, lengthThisTd >= SgList->SgEntry[sgIdx].Length);
        
    }

OHCI_MapAsyncTransferToTd_Done:

    Td->HwTD.CBP = logicalStart; 
    Td->HwTD.BE = logicalEnd-1; 
    LengthMapped += lengthThisTd;
    Td->TransferCount = lengthThisTd;
    
    LOGENTRY(DeviceData, G, '_Mp1', LengthMapped, lengthThisTd, Td);  

    return LengthMapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\usbehci.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    hydramp.c

Abstract:

    USB 2.0 EHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/



#include "common.h"

#include <initguid.h>
#include "usbpriv.h"

//implements the following miniport functions:
//EHCI_StartController
//EHCI_StopController
//EHCI_DisableInterrupts
//EHCI_EnableInterrupts

USB_MINIPORT_STATUS
EHCI_InitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp;
    PHC_CAPABILITIES_REGISTER hcCap;
    USBCMD cmd;
    HCSPARAMS hcSparms;
    LARGE_INTEGER finishTime, currentTime;

    hcCap = DeviceData->CapabilitiesRegisters;
    hcOp = DeviceData->OperationalRegisters;

    // reset the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_res', cmd.ul, 0, 0);
    cmd.HostControllerReset = 1;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    KeQuerySystemTime(&finishTime);
    // no spec'ed time -- we will graciously grant 0.1 sec.
    //
    // figure when we quit (.1 seconds later)
    finishTime.QuadPart += 1000000;

    // wait for reset bit to got to zero
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    while (cmd.HostControllerReset) {

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {

            EHCI_KdPrint((DeviceData, 0,
                "'EHCI controller failed to reset in .1 sec!\n"));

            return USBMP_STATUS_HARDWARE_FAILURE;
        }

        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    }

    hcSparms.ul =
        READ_REGISTER_ULONG(&hcCap->HcStructuralParameters.ul);

    DeviceData->NumberOfPorts =
        (USHORT) hcSparms.NumberOfPorts;

    DeviceData->PortPowerControl =
        (USHORT) hcSparms.PortPowerControl;

    // inialize operational registers
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, 0);
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase, 0);

    // set the enabled interrupts cache, we'll enable
    // these interrupts when asked
    DeviceData->EnabledInterrupts.UsbInterrupt = 1;
    DeviceData->EnabledInterrupts.UsbError = 1;
    DeviceData->EnabledInterrupts.FrameListRollover = 1;
    DeviceData->EnabledInterrupts.HostSystemError = 1;
    DeviceData->EnabledInterrupts.IntOnAsyncAdvance = 1;

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_InitializeSchedule(
     PDEVICE_DATA DeviceData,
     PUCHAR StaticQHs,
     HW_32BIT_PHYSICAL_ADDRESS StaticQHsPhys
    )
/*++

Routine Description:

    Build the schedule of static Eds

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHC_OPERATIONAL_REGISTER hcOp;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_LINK_POINTER asyncHwQh;
    PHW_32BIT_PHYSICAL_ADDRESS frameBase;

    hcOp = DeviceData->OperationalRegisters;

    // allocate a frame list
    frameBase = DeviceData->FrameListBaseAddress =
            (PHW_32BIT_PHYSICAL_ADDRESS) StaticQHs;
    DeviceData->FrameListBasePhys =
        StaticQHsPhys;
    StaticQHs += USBEHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);
    StaticQHsPhys += USBEHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);

    // allocate a 'Dummy' QH for the Async list
    qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(qh, sizeof(*qh));
    asyncHwQh.HwAddress =
        qh->PhysicalAddress = StaticQHsPhys;
    // no current TD
    // t-bit set on next TD
    SET_T_BIT(qh->HwQH.Overlay.qTD.Next_qTD.HwAddress);
    qh->HwQH.Overlay.qTD.Token.Halted = 1;
    qh->HwQH.EpChars.HeadOfReclimationList = 1;
    qh->Sig = SIG_HCD_AQH;
    SET_QH(asyncHwQh.HwAddress);
    // link to ourselves
    qh->HwQH.HLink.HwAddress = asyncHwQh.HwAddress;
    QH_DESCRIPTOR_PTR(qh->NextQh) = qh;
    QH_DESCRIPTOR_PTR(qh->PrevQh) = qh;

    DeviceData->AsyncQueueHead = qh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    // allocate 64 static interrupt queue heads
    for (i=0; i<64; i++) {
        qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;
        qh->PhysicalAddress = StaticQHsPhys;

        DeviceData->StaticInterruptQH[i] = qh;

        StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    EHCI_InitailizeInterruptSchedule(DeviceData);

    for (i=0; i<USBEHCI_MAX_FRAME; i++) {

        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        HW_32BIT_PHYSICAL_ADDRESS qhPhys;

        qh = EHCI_GetQueueHeadForFrame(DeviceData, i);

        qhPhys = qh->PhysicalAddress;
        SET_QH(qhPhys);

        *frameBase = qhPhys;
        frameBase++;
    }

    DeviceData->DummyQueueHeads = StaticQHs;
    DeviceData->DummyQueueHeadsPhys = StaticQHsPhys;

    StaticQHs+= sizeof(HCD_QUEUEHEAD_DESCRIPTOR)*USBEHCI_MAX_FRAME;
    StaticQHsPhys+= sizeof(HCD_QUEUEHEAD_DESCRIPTOR)*USBEHCI_MAX_FRAME;

    EHCI_AddDummyQueueHeads(DeviceData);

    // program the frame list
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase,
        DeviceData->FrameListBasePhys);

    // write the async qh to the controller
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, asyncHwQh.HwAddress);

    mpStatus = USBMP_STATUS_SUCCESS;

    return mpStatus;
}


VOID
EHCI_ReadUlongRegFlag(
     PDEVICE_DATA DeviceData,
     PUCHAR DebugString,
     PWCHAR FlagName,
     ULONG FlagNameSize,
     ULONG FlagBit
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG flag;

    // get SOF modify value from registry
    mpStatus =
        USBPORT_GET_REGISTRY_KEY_VALUE(DeviceData,
                                       TRUE, // software branch
                                       FlagName,
                                       FlagNameSize,
                                       &flag,
                                       sizeof(flag));

    // if this call fails we just use the default

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        if (flag) {
            SET_FLAG(DeviceData->Flags, FlagBit);
        }
        EHCI_KdPrint((DeviceData, 1, "'%s: %d \n",
                DebugString, flag));

    }
}

VOID
EHCI_GetRegistryParameters(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    EHCI_ReadUlongRegFlag(DeviceData,
            "Enable Idle Endpoint Support",
            EN_IDLE_ENDPOINT_SUPPORT,
            sizeof(EN_IDLE_ENDPOINT_SUPPORT),
            EHCI_DD_EN_IDLE_EP_SUPPORT);

}


VOID
USBMPFN
EHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USBCMD cmd;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;

    hcOp = DeviceData->OperationalRegisters;

    // clear the run bit
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_stp', cmd.ul, 0, 0);
    cmd.HostControllerRun = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    // mask off all interrupts
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         0);

    // set cc control of the hc ports to the companion
    // controllers
    configFlag.ul = 0;
    configFlag.RoutePortsToEHCI = 0;
    WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

}


VOID
USBMPFN
EHCI_TakePortControl(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;

    hcOp = DeviceData->OperationalRegisters;

    configFlag.ul = READ_REGISTER_ULONG(&hcOp->ConfigFlag.ul);
    EHCI_KdPrint((DeviceData, 0, "'EHCI - configflag %x\n", configFlag.ul));
    DeviceData->LastConfigFlag.ul = configFlag.ul;

    // set default port routing
    configFlag.ul = 0;
    configFlag.RoutePortsToEHCI = 1;
    WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

}


USB_MINIPORT_STATUS
USBMPFN
EHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    PHC_CAPABILITIES_REGISTER hcCap = NULL;
    PUCHAR base;
    USBCMD cmd;
    HCLENGTHVERSION hcLengthVersion;
    ULONG capLength;
    ULONG hciVersion;
    CONFIGFLAG configFlag;
    UCHAR fladj; // fBIOS set frame length adjustment

    DeviceData->Sig = SIG_EHCI_DD;
    DeviceData->ControllerFlavor =
        HcResources->ControllerFlavor;
    DeviceData->DeviceStarted = FALSE;

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &DeviceData->Vid,
        0,
        sizeof(DeviceData->Vid));

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &DeviceData->Dev,
        2,
        sizeof(DeviceData->Dev));

#if DBG
    if (AGERE(DeviceData)) {
        EHCI_KdPrint((DeviceData, 0, "'EHCI Agere Controller Detected\n"));
    } else if (NEC(DeviceData)) {
        EHCI_KdPrint((DeviceData, 0, "'EHCI NEC Controller Detected\n"));
    } else {
        EHCI_KdPrint((DeviceData, 0, "'EHCI Generic Controller Detected\n"));
    }
#endif

    // get the frame length adjustment value set by the BIOS
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &fladj,
        0x61,
        sizeof(fladj));

    DeviceData->SavedFladj = fladj;

    DeviceData->IsoEndpointListHead = NULL;

    if (EHCI_PastExpirationDate(DeviceData)) {
        return USBMP_STATUS_INIT_FAILURE;
    }

    // assume success
    mpStatus = USBMP_STATUS_SUCCESS;

    EHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_MEM_REGS | HCR_IRQ)) !=
        (HCR_MEM_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;
    }

    base = HcResources->DeviceRegisters;

    hcCap = DeviceData->CapabilitiesRegisters =
       (PHC_CAPABILITIES_REGISTER) base;

    hcLengthVersion.ul = READ_REGISTER_ULONG(&hcCap->HcLengthVersion.ul);

    capLength = hcLengthVersion.HcCapLength;
    hciVersion = hcLengthVersion.HcVersion;

    EHCI_KdPrint((DeviceData, 1, "'EHCI CAPLENGTH = 0x%x\n", capLength));
    EHCI_KdPrint((DeviceData, 1, "'EHCI HCIVERSION = 0x%x\n", hciVersion));

    // set up or device data structure
    hcOp = DeviceData->OperationalRegisters =
        (PHC_OPERATIONAL_REGISTER) (base + capLength);

    EHCI_KdPrint((DeviceData, 1, "'EHCI mapped Operational Regs = %x\n", hcOp));
    EHCI_KdPrint((DeviceData, 1, "'EHCI mapped Capabilities Regs = %x\n", hcCap));

    EHCI_GetRegistryParameters(DeviceData);

//    if (mpStatus == USBMP_STATUS_SUCCESS) {
//        mpStatus = EHCI_StopBIOS(DeviceData);
//    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller
        mpStatus = EHCI_InitializeHardware(DeviceData);
    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // inialize static Queue Heads
        PUCHAR staticQHs;
        HW_32BIT_PHYSICAL_ADDRESS staticQHsPhys;

        // carve the common buffer block in to
        // static QueueHeads
        //
        // set up the schedule

        staticQHs = HcResources->CommonBufferVa;
        staticQHsPhys = HcResources->CommonBufferPhys;

        // set up the schedule
        mpStatus = EHCI_InitializeSchedule(DeviceData,
                                           staticQHs,
                                           staticQHsPhys);


    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &fladj,
            0x61,
            sizeof(fladj));

        if (fladj != DeviceData->SavedFladj) {
            TEST_TRAP();

            fladj = DeviceData->SavedFladj;
            USBPORT_WRITE_CONFIG_SPACE(
                DeviceData,
                &fladj,
                0x61,
                sizeof(fladj));
        }

        // set default port routing
        configFlag.ul = 0;
        configFlag.RoutePortsToEHCI = 1;
        WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

        DeviceData->LastConfigFlag.ul = configFlag.ul;

        // set the interrupt threshold to maximum
        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
        cmd.InterruptThreshold = 1;
        WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

        // start the controller
        cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
        LOGENTRY(DeviceData, G, '_run', cmd.ul, 0, 0);
        cmd.HostControllerRun = 1;
        WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

        DeviceData->DeviceStarted = TRUE;

        if (HcResources->Restart) {
            USHORT p;
            // we have a restart, re-power the ports here so that
            // we can hand of devices that are on the 1.1 bus
            EHCI_KdPrint((DeviceData, 0, "'Restart, power chirpable ports\n"));
            // power the ports
            for (p = 1; p <= DeviceData->NumberOfPorts; p++) {
                EHCI_RH_SetFeaturePortPower(DeviceData, p);
            }

            // no poweron2powergood for EHCI root ports, wait
            // 100 ms for port power stabilization
            // 100 ms minimum debiunce time
            USBPORT_WAIT(DeviceData, 200);

// bugbug this will keep some HS mass storage devices from failing after
// hibernate, however it will significantly increase resume from hibernate
// time. see bug #586818
// USBPORT_WAIT(DeviceData, 500);
            for (p = 1; p <= DeviceData->NumberOfPorts; p++) {
                EHCI_RH_ChirpRootPort(DeviceData, p);
            }

        }

    } else {

        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}


VOID
EHCI_SuspendController(
     PDEVICE_DATA DeviceData
    )
{
    USBCMD cmd;
    USBSTS status;
    USBINTR intr;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    ULONG i,p;
    USBSTS irqStatus;

    hcOp = DeviceData->OperationalRegisters;
    // save all volatile regs from the core power well

    // since we may loose power on the controller chip (not bus)
    // the miniport is resposnible for saving HW state
    DeviceData->PeriodicListBaseSave =
        READ_REGISTER_ULONG(&hcOp->PeriodicListBase);
    DeviceData->AsyncListAddrSave =
        READ_REGISTER_ULONG(&hcOp->AsyncListAddr);
    DeviceData->SegmentSelectorSave =
        READ_REGISTER_ULONG(&hcOp->SegmentSelector);
    // preserve the state of the list enable bits
    DeviceData->CmdSave.ul =
        READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);

    // reset the PM chirp state flags for another pass at power
    // management
    DeviceData, DeviceData->PortPMChirp == 0;

    // Save away the command register
    // DeviceData->SuspendCommandReg.us =
    //    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    // clear the int on async advance doorbell
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    cmd.IntOnAsyncAdvanceDoorbell = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul,
                         cmd.ul);


    // Stop the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_st1', cmd.ul, 0, 0);
    cmd.HostControllerRun = 0;
    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    // ack any interrupts that may be left over from the halt
    // process.  The controller should not generate any new
    // interrupts when it is stopped. For some reason the NEC
    // controller generates a doorbel interrupt on halt.

    // wait 1 microframe
    KeStallExecutionProcessor(125);
    irqStatus.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
    // just look at the IRQ status bits
    irqStatus.ul &= HcInterruptStatusMask;
    if (irqStatus.ul != 0)  {
        WRITE_REGISTER_ULONG(&hcOp->UsbStatus.ul,
                             irqStatus.ul);
    }

    // mask off all interrupts now
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         0);


    // Wait for the HC to halt
    // Note that according to the sepc if we don't halt in ms
    // (16ms) the hardware is busted.
    for (i=0; i<10; i++) {
        status.ul = READ_REGISTER_ULONG(&hcOp->UsbStatus.ul);
        if (status.HcHalted) {
            break;
        }
        USBPORT_WAIT(DeviceData, 1);
    }

    if (status.HcHalted != 1) {
        // hardware is f'ed up
        TEST_TRAP();
    }

    //if (!status.HCHalted) {
    //
    //    // Can't get the HCHalted bit to stick, so reset the controller.
    //    command.GlobalReset = 1;
    //    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
    //
    //    USBPORT_WAIT(DeviceData, 10);
    //
    //    command.GlobalReset = 0;
    //    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    //    // Re-enable interrupts, since they are zero'd out on reset.
    //    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->EnabledInterrupts.us);
    //
    //}

    // enable the port chage interrupt, this allows us to wake
    // in the selective suspend case
    intr.ul = READ_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul);
    intr.PortChangeDetect = 1;
    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul, intr.ul);
}


USB_MINIPORT_STATUS
EHCI_ResumeController(
     PDEVICE_DATA DeviceData
    )
{
    USBCMD cmd;
    PHC_OPERATIONAL_REGISTER hcOp = NULL;
    CONFIGFLAG configFlag;

    hcOp = DeviceData->OperationalRegisters;

    EHCI_KdPrint((DeviceData, 1, "'>EHCI_ResumeController\n"));

    // don't mess with handoff regs for now
    //configFlag.ul = 0;
    //configFlag.RoutePortsToEHCI = 1;
    //WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

    // restore volitile regs
    //configFlag.ul = READ_REGISTER_ULONG(&hcOp->ConfigFlag.ul);
    configFlag.ul = DeviceData->LastConfigFlag.ul;
    if (configFlag.RoutePortsToEHCI == 0) {
        // we have a reset
        EHCI_KdPrint((DeviceData, 1, "'Routing bit has reset to 0\n"));

        configFlag.RoutePortsToEHCI = 1;
        DeviceData->LastConfigFlag.ul = configFlag.ul;
        WRITE_REGISTER_ULONG(&hcOp->ConfigFlag.ul, configFlag.ul);

        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    // restore volitile regs
    WRITE_REGISTER_ULONG(&hcOp->SegmentSelector, DeviceData->SegmentSelectorSave);
    WRITE_REGISTER_ULONG(&hcOp->PeriodicListBase, DeviceData->PeriodicListBaseSave);
    WRITE_REGISTER_ULONG(&hcOp->AsyncListAddr, DeviceData->AsyncListAddrSave);

    // start the controller
    cmd.ul = READ_REGISTER_ULONG(&hcOp->UsbCommand.ul);
    LOGENTRY(DeviceData, G, '_run', cmd.ul, 0, 0);
    cmd.HostControllerRun = 1;

    // restore volatile cmd bits
    cmd.AsyncScheduleEnable = DeviceData->CmdSave.AsyncScheduleEnable;
    cmd.PeriodicScheduleEnable = DeviceData->CmdSave.PeriodicScheduleEnable;
    cmd.InterruptThreshold = DeviceData->CmdSave.InterruptThreshold;


    WRITE_REGISTER_ULONG(&hcOp->UsbCommand.ul, cmd.ul);

    WRITE_REGISTER_ULONG(&hcOp->UsbInterruptEnable.ul,
                         DeviceData->EnabledInterrupts.ul);

    EHCI_KdPrint((DeviceData, 1, "'<EHCI_ResumeController\n"));

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
EHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;

    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;

    switch (EndpointParameters->TransferType) {

    case Control:

        EndpointData->MaxPendingTransfers = 1;
        mpStatus = EHCI_OpenBulkOrControlEndpoint(
                DeviceData,
                TRUE,
                EndpointParameters,
                EndpointData);

        break;

    case Interrupt:

        mpStatus = EHCI_OpenInterruptEndpoint(
                    DeviceData,
                    EndpointParameters,
                    EndpointData);

        break;

    case Bulk:

        EndpointData->MaxPendingTransfers = 1;
        mpStatus = EHCI_OpenBulkOrControlEndpoint(
                DeviceData,
                FALSE,
                EndpointParameters,
                EndpointData);

        break;

    case Isochronous:

        if (EndpointParameters->DeviceSpeed == HighSpeed) {
            mpStatus = EHCI_OpenHsIsochronousEndpoint(
                        DeviceData,
                        EndpointParameters,
                        EndpointData);
        } else {
            mpStatus = EHCI_OpenIsochronousEndpoint(
                        DeviceData,
                        EndpointParameters,
                        EndpointData);
        }
        break;

    default:
        TEST_TRAP();
        mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    }

    return mpStatus;
}


VOID
EHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing to do here
}


USB_MINIPORT_STATUS
EHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData,
        EndpointParameters, 0);

    switch(EndpointData->Parameters.TransferType) {
    case Interrupt:
    case Control:
    case Bulk:
        return EHCI_PokeAsyncEndpoint(DeviceData,
                                      EndpointParameters,
                                      EndpointData);
    case Isochronous:
        return EHCI_PokeIsoEndpoint(DeviceData,
                                    EndpointParameters,
                                    EndpointData);
    }

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    switch (EndpointParameters->TransferType) {
    case Interrupt:
        EHCI_RebalanceInterruptEndpoint(DeviceData,
                                        EndpointParameters,
                                        EndpointData);
        break;

    case Isochronous:
        EHCI_RebalanceIsoEndpoint(DeviceData,
                                  EndpointParameters,
                                  EndpointData);
        break;
    }
}


USB_MINIPORT_STATUS
EHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{


    switch (EndpointParameters->TransferType) {

    case Control:

        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_CONTROL_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_CONTROL_TRANSFER_SIZE;
        break;

    case Interrupt:

        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_INTERRUPT_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_INTERRUPT_TRANSFER_SIZE;

        break;

    case Bulk:

        //
        // TDS_PER_ENDPOINT limits the largest transfer we
        // can handle.
        //

        // TDS_PER_ENDPOINT TDs plus an ED
        EndpointRequirements->MinCommonBufferBytes =
            sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
                TDS_PER_BULK_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize =
            MAX_BULK_TRANSFER_SIZE;
        break;

     case Isochronous:

        if (EndpointParameters->DeviceSpeed == HighSpeed) {
            EndpointRequirements->MinCommonBufferBytes =
                    USBEHCI_MAX_FRAME*sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR);

            EndpointRequirements->MaximumTransferSize =
                MAX_HSISO_TRANSFER_SIZE;
        } else {
            // TDS_PER_ENDPOINT TDs plus an ED
            EndpointRequirements->MinCommonBufferBytes =
                    TDS_PER_ISO_ENDPOINT*sizeof(HCD_SI_TRANSFER_DESCRIPTOR);

            EndpointRequirements->MaximumTransferSize =
                MAX_ISO_TRANSFER_SIZE;
        }
        break;

    default:
        USBPORT_BUGCHECK(DeviceData);
    }

    return USBMP_STATUS_SUCCESS;
}


VOID
EHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) {

    case Control:
    case Bulk:
    case Interrupt:
        EHCI_PollAsyncEndpoint(DeviceData, EndpointData);
        break;
    case Isochronous:
        EHCI_PollIsoEndpoint(DeviceData, EndpointData);
        break;
    }
}


PHCD_TRANSFER_DESCRIPTOR
EHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Allocate a TD from an endpoints pool

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;

    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!TEST_FLAG(td->Flags, TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            EndpointData->FreeTds--;
            return td;
        }
    }

    // we should always find one
    EHCI_ASSERT(DeviceData, FALSE);
    USBPORT_BUGCHECK(DeviceData);

    return NULL;
}


VOID
EHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        EHCI_SetAsyncEndpointStatus(DeviceData,
                                    EndpointData,
                                    Status);
        break;
    case Isochronous:
        // nothing to do for iso
        break;

    default:
        USBPORT_BUGCHECK(DeviceData);
    }
}


MP_ENDPOINT_STATUS
EHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        return EHCI_GetAsyncEndpointStatus(DeviceData,
                                           EndpointData);
        break;
    }

    // return RUNNING for iso

    return ENDPOINT_STATUS_RUN;
}


VOID
EHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    LOGENTRY(DeviceData, G, '_ses', EndpointData, 0, State);

    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        EHCI_SetAsyncEndpointState(DeviceData,
                                   EndpointData,
                                   State);
        break;
    case Isochronous:
        EHCI_SetIsoEndpointState(DeviceData,
                                 EndpointData,
                                 State);
        break;
    default:
        USBPORT_BUGCHECK(DeviceData);
    }

}


MP_ENDPOINT_STATE
EHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATE currentState;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    // assume we are active
    currentState = ENDPOINT_ACTIVE;

    qh = EndpointData->QueueHead;

    // removed from schedule?
    if (!TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_IN_SCHEDULE)) {
        // yes
        currentState = TEST_FLAG(qh->QhFlags, EHCI_QH_FLAG_QH_REMOVED) ?
                ENDPOINT_REMOVE : ENDPOINT_PAUSE;
    }

    LOGENTRY(DeviceData, G, '_ges', EndpointData, 0, currentState);

    return currentState;
}


VOID
EHCI_PollController(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}


USB_MINIPORT_STATUS
EHCI_SubmitTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_EHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {
    case Control:
        mpStatus =
            EHCI_ControlTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);
        break;
    case Interrupt:
        mpStatus =
            EHCI_InterruptTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);
        break;
    case Bulk:
        mpStatus =
            EHCI_BulkTransfer(DeviceData,
                              EndpointData,
                              TransferParameters,
                              TransferContext,
                              TransferSGList);
        break;
    default:
        TEST_TRAP();
    }

    return mpStatus;
}


VOID
EHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
{
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Interrupt:
    case Bulk:
        EHCI_AbortAsyncTransfer(DeviceData,
                                EndpointData,
                                TransferContext);
        break;
    default:
        EHCI_AbortIsoTransfer(DeviceData,
                              EndpointData,
                              TransferContext);
    }
}


USB_MINIPORT_STATUS
EHCI_PassThru (
     PDEVICE_DATA DeviceData,
     GUID *FunctionGuid,
     ULONG ParameterLength,
     OUT PVOID Parameters
    )
{
    PUCHAR p = Parameters;
    UCHAR pdkApi;
    ULONG portNumber;
    USB_MINIPORT_STATUS mpStatus;

    mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    if (RtlEqualMemory(FunctionGuid, &GUID_USBPRIV_ROOTPORT_STATUS, sizeof(GUID)))
    {
        mpStatus = EHCI_RH_UsbprivRootPortStatus(DeviceData,
                                              ParameterLength,
                                              Parameters);
    }

#if 0
    portNumber = *(p+1);

    mpStatus = USBMP_STATUS_NOT_SUPPORTED;

    // pdkApi - force full speed

    pdkApi = *p;
    switch (pdkApi) {
    // obtumtuserate the port as requested
    case 0:
        {
        PHC_OPERATIONAL_REGISTER hcOp;
        USHORT portNumber;
        PORTSC port;

        portNumber = *(p+1);
        hcOp = DeviceData->OperationalRegisters;

        // first power the port up
        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);
        port.PortPower = 1;
        WRITE_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul,
                port.ul);

        KeStallExecutionProcessor(10);        //stall for 10 microseconds

        EHCI_OptumtuseratePort(DeviceData, portNumber);

        port.ul = READ_REGISTER_ULONG(&hcOp->PortRegister[portNumber-1].ul);

        SET_BIT(DeviceData->HighSpeedDeviceAttached, portNumber-1);

        // see if it worked
        if (port.ul == 0x1205) {
            mpStatus = USBMP_STATUS_SUCCESS;
        } else {
            mpStatus = USBMP_STATUS_FAILURE;
        }

        LOGENTRY(DeviceData, G, '_hsE', portNumber, mpStatus, port.ul);
        TEST_TRAP();
        }
        break;

    case 1:
        // force a connect change

        // indicate a port change condition to the hub
        SET_BIT(DeviceData->PortConnectChange, portNumber-1);

        break;
    }
#endif

    return mpStatus;
}



VOID
EHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    )
/*++

Routine Description:

Arguments:

    Toggle is 0 or 1

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    if (EndpointData->Parameters.TransferType == Control ||
        EndpointData->Parameters.TransferType == Isochronous) {

        // nothing to do for control and iso
        return;
    }

    qh = EndpointData->QueueHead;
    qh->HwQH.Overlay.qTD.Token.DataToggle = Toggle;

    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle);
}

VOID
EHCI_CheckController(
    PDEVICE_DATA DeviceData
    )
{
    if (DeviceData->DeviceStarted) {
        EHCI_HardwarePresent(DeviceData, TRUE);
    }
}

// Beta versions of our miniport driver have a hard coded exp date

#ifdef NO_EXP_DATE
#define EXPIRATION_DATE     0
#else
//Sep 1, 2001
//#define EXPIRATION_DATE     0x01c133406ab2406c

//Oct 24, 2001
//#define EXPIRATION_DATE     0x01c15cd5887bc884

//Dec 31, 2001
//#define EXPIRATION_DATE     0x01c19251a68bfac0
#endif

BOOLEAN
EHCI_PastExpirationDate(
    PDEVICE_DATA DeviceData
    )
{
    LARGE_INTEGER  systemTime;

    KeQuerySystemTime(&systemTime);

    EHCI_KdPrint((DeviceData, 1, "system time: %x %x\n", systemTime.QuadPart));
    EHCI_KdPrint((DeviceData, 1, "exp system time: %x %x\n", EXPIRATION_DATE));

    if (EXPIRATION_DATE &&
        systemTime.QuadPart > EXPIRATION_DATE) {
        EHCI_KdPrint((DeviceData, 1, "driver expired"));
        return TRUE;
    }

    return FALSE;
}

UCHAR
EHCI_GetEECP(
    PDEVICE_DATA DeviceData,
    UCHAR CapabilityId
    )
/*
    returns the offset of a specific EECP in config space
    given a cap id

    returns 0 if no EECP or Id not found

*/
{
    UCHAR eecpOffset;
    HC_EECP eecp;
    PHC_CAPABILITIES_REGISTER hcCap;

    hcCap = DeviceData->CapabilitiesRegisters;

    eecpOffset = (UCHAR) hcCap->HcCapabilityParameters.EECP;

    if (eecpOffset == 0) {
        return eecpOffset;
    }



    EHCI_KdPrint((DeviceData, 1, "EECP offset found @ 0x%x\n", eecpOffset));

    do {

        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &eecp,
            eecpOffset,
            sizeof(eecp));

        EHCI_KdPrint((DeviceData, 1, "EECP cap 0x%x Next 0x%x (%08.8x)\n",
            eecp.CapId, eecp.NextCap, eecp.ul));

        if (eecp.CapId == CapabilityId) {
            return eecpOffset;
        }

        eecpOffset = (UCHAR) eecp.NextCap;

    } while (eecpOffset);

    return eecpOffset;
}


USB_MINIPORT_STATUS
EHCI_StopBIOS(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Stop Legacy BIOS

Arguments:

Return Value:

--*/
{
    UCHAR biosOffset;
    USB_LEGACYBIOS_REGISTERS hcLegs;

    biosOffset = EHCI_GetEECP(DeviceData, EECP_PRE_OS_HANDOFF);

    // do we have BIOS
    if (biosOffset) {
        // hey! nice Legs.
        EHCI_KdPrint((DeviceData, 1, "EHCI Legacy BIOS EECP registers detected\n"));

        // read the legacy registers
        USBPORT_READ_CONFIG_SPACE(DeviceData, &hcLegs, biosOffset, sizeof(hcLegs));

        // see if BIOS is enabled
        if (hcLegs.Caps.HcBIOSowned) {
            USBLEGSUP legSup;

            EHCI_KdPrint((DeviceData, 0, "EHCI Legacy BIOS detected\n"));
            TEST_TRAP();

            // take ownership,
            // set OS owned
            legSup.ul = hcLegs.Caps.ul;
            legSup.HcOSowned = 1;

            USBPORT_WRITE_CONFIG_SPACE(DeviceData, &legSup, biosOffset, sizeof(legSup));

            // wait on Bios owned to go to zero
            do {
                USBPORT_READ_CONFIG_SPACE(DeviceData, &legSup, biosOffset, sizeof(legSup));
            } while (legSup.HcBIOSowned);

        }
    }

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\common.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

   common header for OHCI miniport

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#ifndef COMMON_H
#define COMMON_H

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "openhci.h"
#include "dbg.h"
#include "usbohci.h"

#endif //COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbehci\usbehci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbehci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __EHCI_H__
#define   __EHCI_H__

#define NO_EXP_DATE

#define MASK_CHANGE_BITS(p)\
    do {\
    (p).OvercurrentChange = 0;\
    (p).PortEnableChange = 0;\
    (p).PortConnectChange = 0;\
    } while (0);

/*
    define some known busted hardware types
*/
#define AGERE(dd) ((dd)->Vid == 0x11c1 && (dd)->Dev == 0x5805) ? TRUE : FALSE

//#define LUCENT(dd) ((dd)->ControllerFlavor == EHCI_Lucent) ? TRUE : FALSE
#define NEC(dd) ((dd)->ControllerFlavor == EHCI_NEC) ? TRUE : FALSE

#define MU_960(dd) ((dd)->ControllerFlavor == EHCI_960MUlator) ? TRUE : FALSE

/*
    define resource consumption for endpoints types
*/

#define T_256K          0x00040000
#define T_64K           0x00010000
#define T_4K            0x00001000
#define T_4MB           0x00400000


// Control:
// largest possible transfer for control is 64k
// therefore we support up to 2 transfers of this
// size in HW.  Most control transfers are much
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in
// HW since a single control transfer cannot be
// broken up.

#define MAX_CONTROL_TRANSFER_SIZE   T_64K
// worst case 64k control transfer 4 + status and
// setup + dummy  =
#define TDS_PER_CONTROL_ENDPOINT        7


// Bulk:
#define MAX_BULK_TRANSFER_SIZE        T_4MB
// enough for 4 MB
#define TDS_PER_BULK_ENDPOINT           210

// Interrupt:
#define MAX_INTERRUPT_TRANSFER_SIZE  T_4K
// enough for up to 4 4k transfers + dummy
#define TDS_PER_INTERRUPT_ENDPOINT      5

// Isochronous:
#define MAX_ISO_TRANSFER_SIZE        T_256K
// 2 256 packet transfers *3k packet size, we can actually
// handle more
#define MAX_HSISO_TRANSFER_SIZE         0x00180000
#define TDS_PER_ISO_ENDPOINT            32


// default size of frame list
#define USBEHCI_MAX_FRAME            1024

/*
    Registry Keys
*/

// Software Branch PDO Keys
#define EN_IDLE_ENDPOINT_SUPPORT L"EnIdleEndpointSupport"


// Hardware Branch PDO Keys


// debug signatures
#define  SIG_HCD_IQH            'qi02'
#define  SIG_HCD_AQH            'qa02'
#define  SIG_HCD_QH             'hq02'
#define  SIG_HCD_DQH            'qd02'
#define  SIG_HCD_TD             'dt02'
#define  SIG_HCD_SITD           'dtIS'
#define  SIG_HCD_ITD            'dtIH'
#define  SIG_EP_DATA            'pe02'
#define  SIG_EHCI_TRANSFER      'rt02'
#define  SIG_EHCI_DD            'iche'
#define  SIG_DUMMY_QH           'hqmd'


#undef PDEVICE_DATA

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG PendingTds;
    PTRANSFER_PARAMETERS TransferParameters;
    USBD_STATUS UsbdStatus;
    ULONG BytesTransferred;
    ULONG XactErrCounter;
    // struct _HCD_TRANSFER_DESCRIPTOR *NextTransferTd;
    struct _ENDPOINT_DATA *EndpointData;

    //for ISO
    ULONG FrameComplete;
    LIST_ENTRY TransferLink;
    PMINIPORT_ISO_TRANSFER IsoTransfer;
    ULONG PendingPackets;
    ULONG PostedFrame;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)

// values for HCD_QUEUEHEAD_DESCRIPTOR.Flags
#define EHCI_QH_FLAG_IN_SCHEDULE        0x00000001
#define EHCI_QH_FLAG_QH_REMOVED         0x00000002
#define EHCI_QH_FLAG_STATIC             0x00000004
#define EHCI_QH_FLAG_HIGHSPEED          0x00000008
#define EHCI_QH_FLAG_UPDATING           0x00000010


typedef struct _HCD_QUEUEHEAD_DESCRIPTOR {
   HW_QUEUEHEAD_DESCRIPTOR    HwQH;     // 40 dwords

   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      QhFlags;
   ULONG                      Ordinal;
   ULONG                      Period;
   ULONG                      Reserved;

   MP_HW_POINTER              EndpointData;
   //MP_HW_POINTER              HcdTail;
   MP_HW_POINTER              NextQh;
   MP_HW_POINTER              PrevQh;
   MP_HW_POINTER              NextLink;

#ifdef _WIN64
   ULONG                      PadTo256[6];
#else
   ULONG                      PadTo256[6];
#endif
} HCD_QUEUEHEAD_DESCRIPTOR, *PHCD_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) == 160));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)
#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define QH_DESCRIPTOR_PTR(p) ((struct _HCD_QUEUEHEAD_DESCRIPTOR *) (p).Pointer)
#define HW_PTR(p) ((UCHAR * ) (p).Pointer)
#define ISO_PACKET_PTR(p) ((struct _MINIPORT_ISO_PACKET *) (p).Pointer)
#define ISO_TRANSFER_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)


// values for HCD_TRANSFER_DESCRIPTOR.Flags

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
//#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010
#define TD_FLAG_DUMMY               0x00000020


typedef struct _HCD_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD        HwTD;      //64 (16 dwords)
    ULONG                      Sig;
    ULONG                      Flags;
    ULONG                      TransferLength;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;

    UCHAR                      Packet[8]; // space for setup packet data
    MP_HW_POINTER              EndpointData;
    MP_HW_POINTER              TransferContext;
    MP_HW_POINTER              NextHcdTD;
    MP_HW_POINTER              AltNextHcdTD;

    LIST_ENTRY                 DoneLink;
#ifdef _WIN64
    ULONG                      PadToX[30];
#else
    ULONG                      PadToX[32];
#endif
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 256));

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

/*
    Structures used for iso see iso.c
*/

typedef struct _HCD_SI_TRANSFER_DESCRIPTOR {
    HW_SPLIT_ISOCHRONOUS_TD    HwTD;    //64 (16dwords)

    ULONG                      Sig;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
    ULONG                      StartOffset;
    ULONG                      Reserved;

    MP_HW_POINTER              Packet;
    MP_HW_POINTER              Transfer;
    MP_HW_POINTER              NextLink;
#ifdef _WIN64
    ULONG                      PadToX[6];
#else
    ULONG                      PadToX[6];
#endif
} HCD_SI_TRANSFER_DESCRIPTOR, *PHCD_SI_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_SI_TRANSFER_DESCRIPTOR) == 128));


typedef struct _HCD_SITD_LIST {
    HCD_SI_TRANSFER_DESCRIPTOR Td[1];
} HCD_SITD_LIST, *PHCD_SITD_LIST;


typedef struct _HCD_HSISO_TRANSFER_DESCRIPTOR {
    HW_ISOCHRONOUS_TD          HwTD; // 128 (32dwords)

    ULONG                      Sig;
    HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
    ULONG                      HostFrame;
    ULONG                      Reserved;

    MP_HW_POINTER              FirstPacket;
    MP_HW_POINTER              Transfer;
    MP_HW_POINTER              NextLink;
#ifdef _WIN64
    ULONG                      PadTo256[22];
#else
    ULONG                      PadTo256[22];
#endif

} HCD_HSISO_TRANSFER_DESCRIPTOR, *PHCD_HSISO_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_HSISO_TRANSFER_DESCRIPTOR) == 256));


typedef struct _HCD_HSISOTD_LIST {
    HCD_HSISO_TRANSFER_DESCRIPTOR Td[1];
} HCD_HSISOTD_LIST, *PHCD_HSISOTD_LIST;


/*
    Used for data structure that describes the interrupt
    schedule (see periodic.c)
*/
typedef struct _PERIOD_TABLE {
    UCHAR Period;
    UCHAR qhIdx;
    UCHAR InterruptScheduleMask;
} PERIOD_TABLE, *PPERIOD_TABLE;

#define EHCI_EDFLAG_HALTED           0x00000001
//#define EHCI_EDFLAG_FLUSHED          0x00000002
#define EHCI_EDFLAG_NOHALT           0x00000004

typedef struct _ENDPOINT_DATA {

    ULONG Sig;
    ENDPOINT_PARAMETERS Parameters;
    PHCD_QUEUEHEAD_DESCRIPTOR QueueHead;
    ULONG Flags;
    ULONG PendingTransfers;
    ULONG MaxPendingTransfers;

   // PHCD_TRANSFER_DESCRIPTOR HcdTailP;
    PHCD_TRANSFER_DESCRIPTOR HcdHeadP;

    PHCD_QUEUEHEAD_DESCRIPTOR StaticQH;
    PPERIOD_TABLE PeriodTableEntry;

    PHCD_TD_LIST TdList;
    PHCD_SITD_LIST SiTdList;
    PHCD_HSISOTD_LIST HsIsoTdList;

    ULONG TdCount;
    ULONG FreeTds;
    ULONG LastFrame;
    ULONG QhChkPhys;
    PVOID QhChk;

    LIST_ENTRY TransferList;
    LIST_ENTRY DoneTdList;
    MP_ENDPOINT_STATE State;
    struct _ENDPOINT_DATA *PrevEndpoint;
    struct _ENDPOINT_DATA *NextEndpoint;

    PHCD_TRANSFER_DESCRIPTOR DummyTd;
//    ULONG MaxErrorCount;

} ENDPOINT_DATA, *PENDPOINT_DATA;

// values for Flags field in DeviceData
//#define EHCI_DD_FLAG_NOCHIRP                0x000000001
#define EHCI_DD_EN_IDLE_EP_SUPPORT          0x000000002


typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_OPERATIONAL_REGISTER    OperationalRegisters;
    PHC_CAPABILITIES_REGISTER   CapabilitiesRegisters;

    USBINTR                     EnabledInterrupts;

    PHCD_QUEUEHEAD_DESCRIPTOR   AsyncQueueHead;

    USB_CONTROLLER_FLAVOR       ControllerFlavor;

    ULONG                       LastFrame;
    ULONG                       FrameNumberHighPart;

    ULONG                       PortResetChange;
    ULONG                       PortSuspendChange;
    ULONG                       PortConnectChange;
    ULONG                       PortPMChirp;

    ULONG                       IrqStatus;

    USHORT                      NumberOfPorts;
    USHORT                      PortPowerControl;


    PHCD_QUEUEHEAD_DESCRIPTOR   LockPrevQh;
    PHCD_QUEUEHEAD_DESCRIPTOR   LockNextQh;
    PHCD_QUEUEHEAD_DESCRIPTOR   LockQh;

    // both these are used for non-chirping devices
    // port state masks
    //ULONG                       PortConnectState;
    ULONG                       HighSpeedDeviceAttached;

    PHCD_QUEUEHEAD_DESCRIPTOR   StaticInterruptQH[65];

    PHW_32BIT_PHYSICAL_ADDRESS  FrameListBaseAddress;
    HW_32BIT_PHYSICAL_ADDRESS   FrameListBasePhys;

    PENDPOINT_DATA              IsoEndpointListHead;
    PVOID                       DummyQueueHeads;
    HW_32BIT_PHYSICAL_ADDRESS   DummyQueueHeadsPhys;

    ULONG                       PeriodicListBaseSave;
    ULONG                       AsyncListAddrSave;
    ULONG                       SegmentSelectorSave;
    USBCMD                      CmdSave;

    USHORT                      Vid;
    USHORT                      Dev;

    CONFIGFLAG                  LastConfigFlag;

    ULONG                       PendingControlAndBulk;

    // we only need this for older revs of usbport
    // that will call checkController after start fails
    BOOLEAN                     DeviceStarted;
    UCHAR                       SavedFladj;



} DEVICE_DATA, *PDEVICE_DATA;

/*
    Callouts to port driver services
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_COMPLETE_TRANSFER(dd, ep, tp, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (tp), \
            (status), (length));

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep));

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep));

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_REQUEST_ASYNC_CALLBACK(dd, t, c, cl, f) \
        RegistrationPacket.USBPORTSVC_RequestAsyncCallback((dd), (t), \
            (c), (cl), (f));

#define USBPORT_WAIT(dd, t) \
        RegistrationPacket.USBPORTSVC_Wait((dd), (t));

#define USBPORT_BUGCHECK(dd) \
        RegistrationPacket.USBPORTSVC_BugCheck(dd)

#define USBPORT_COMPLETE_ISO_TRANSFER(dd, ep, t, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (t), \
            (iso));

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_READ_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), TRUE, \
            (b), (o), (l))

#define USBPORT_WRITE_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), FALSE, \
            (b), (o), (l))

#ifdef _WIN64
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABEABADBABE)
#else
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABE)
#endif

// note: we must initialize the low 12 bits of the
// buffer page ptr to zero to the last three nipples
// are 0

#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        { ULONG i;\
        TRANSFER_CONTEXT_PTR((td)->TransferContext) = (tc);\
        (td)->Flags |= TD_FLAG_XFER; \
        for (i=0; i<5; i++) {\
        (td)->HwTD.BufferPage[i].ul = 0x0bad0000;\
        }\
        (td)->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT;\
        (td)->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;\
        (td)->HwTD.Token.ul = 0;\
        (td)->HwTD.Token.ErrorCounter = 3;\
        TRANSFER_DESCRIPTOR_PTR((td)->NextHcdTD) = NULL;\
        }

#define SET_NEXT_TD(dd, linkTd, nextTd) \
        EHCI_SetNextTd((dd), (linkTd), (nextTd), FALSE)

#define SET_ALTNEXT_TD(dd, linkTd, nextTd) \
        EHCI_SetAltNextTd((dd), (linkTd), (nextTd))

#define SET_NEXT_AND_ALTNEXT_TD(dd, linkTd, nextTd) \
        EHCI_SetNextTd((dd), (linkTd), (nextTd), TRUE)

#define SET_NEXT_TD_NULL(linkTd) \
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = NULL;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->AltNextHcdTD) = NULL;\
    (linkTd)->HwTD.Next_qTD.HwAddress = EHCI_TERMINATE_BIT; \
    (linkTd)->HwTD.AltNext_qTD.HwAddress = EHCI_TERMINATE_BIT;


#ifdef _WIN64
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACEDEADFACE)
#else
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACE)
#endif

#define EHCI_FREE_TD(dd, ep, td) \
    (td)->Flags = 0;\
    (td)->HwTD.Next_qTD.HwAddress = 0;\
    (td)->HwTD.AltNext_qTD.HwAddress = 0;\
    (ep)->FreeTds++;\
    LOGENTRY((dd), G, '_fTD', (td), 0, 0);\
    TRANSFER_CONTEXT_PTR((td)->TransferContext) = FREE_TD_CONTEXT;

#define EHCI_ALLOC_TD(dd, ep) EHCI_AllocTd((dd), (ep));


#define TEST_BIT(value, bitNumber) ((value) & (1<<(bitNumber))) ? TRUE : FALSE

#define SET_BIT(value, bitNumber) ((value) |= (1<<(bitNumber)))

#define CLEAR_BIT(value, bitNumber)  ((value) &= ~(1<<(bitNumber)))


// assuming only one bit is set this macro returns that bit
//
#define GET_BIT_SET(d, bit) \
    {   \
        UCHAR tmp = (d);\
        (bit)=0; \
        while (!(tmp & 0x01)) {\
            (bit)++;\
            tmp >>= 1;\
        };\
    }

//
// USBEHCI.C Function Prototypes
//

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartController(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    );

VOID
USBMPFN
EHCI_StopController(
    PDEVICE_DATA DeviceData,
    BOOLEAN HwPresent
    );

USB_MINIPORT_STATUS
EHCI_ResumeController(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_SuspendController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_OpenEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_CloseEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_PokeEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_QueryEndpointRequirements(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_REQUIREMENTS EndpointRequirements
    );

VOID
EHCI_PollEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

PHCD_TRANSFER_DESCRIPTOR
EHCI_AllocTd(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATUS Status
    );

MP_ENDPOINT_STATUS
EHCI_GetEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

MP_ENDPOINT_STATE
EHCI_GetEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_PollController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

VOID
EHCI_AbortTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
EHCI_PassThru (
    PDEVICE_DATA DeviceData,
    GUID *FunctionGuid,
    ULONG ParameterLength,
    PVOID Parameters
    );

USB_MINIPORT_STATUS
EHCI_RH_UsbprivRootPortStatus(
    PDEVICE_DATA DeviceData,
    ULONG ParameterLength,
    PVOID Parameters
    );

VOID
EHCI_SetEndpointDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    ULONG Toggle
    );

//
// ASYNC.C Function Prototypes
//

VOID
EHCI_EnableAsyncList(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_DisableAsyncList(
    PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
EHCI_FlushInterrupts(
    PDEVICE_DATA DeviceData
    );

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_InitializeQH(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh,
    HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

PHCD_TRANSFER_DESCRIPTOR
EHCI_InitializeTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

USB_MINIPORT_STATUS
EHCI_ControlTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

USB_MINIPORT_STATUS
EHCI_BulkTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

USB_MINIPORT_STATUS
EHCI_OpenBulkOrControlEndpoint(
    PDEVICE_DATA DeviceData,
    BOOLEAN Control,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_InsertQueueHeadInAsyncList(
    PDEVICE_DATA DeviceData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

VOID
EHCI_RemoveQueueHeadFromAsyncList(
    PDEVICE_DATA DeviceData,
    PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

ULONG
EHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PULONG NextToggle,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td,
    PTRANSFER_SG_LIST SgList
    );

VOID
EHCI_SetAsyncEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

VOID
EHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

USBD_STATUS
EHCI_GetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

VOID
EHCI_AbortAsyncTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    );

//
// INT.C Function Prototypes
//

BOOLEAN
EHCI_InterruptService (
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_InterruptDpc (
    PDEVICE_DATA DeviceData,
    BOOLEAN EnableInterrupts
    );

VOID
USBMPFN
EHCI_DisableInterrupts(
    PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
EHCI_EnableInterrupts(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RH_DisableIrq(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RH_EnableIrq(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_InterruptNextSOF(
    PDEVICE_DATA DeviceData
    );

ULONG
EHCI_Get32BitFrameNumber(
    PDEVICE_DATA DeviceData
    );

//
// PERIODIC.C Function Prototypes
//

USB_MINIPORT_STATUS
EHCI_OpenInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_InsertQueueHeadInPeriodicList(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_RemoveQueueHeadFromPeriodicList(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_InterruptTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferUrb,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    );

VOID
EHCI_InitailizeInterruptSchedule(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_ComputeClassicBudget(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PUCHAR sMask,
    PUCHAR cMask
    );

//
// ROOTHUB.C Function Prototypes
//

VOID
EHCI_RH_GetRootHubData(
    PDEVICE_DATA DeviceData,
    PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
EHCI_RH_GetStatus(
    PDEVICE_DATA DeviceData,
    PUSHORT Status
    );

USB_MINIPORT_STATUS
EHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

USB_MINIPORT_STATUS
EHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    );


USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_RH_PortResetComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    );

USB_MINIPORT_STATUS
EHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_CheckController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnable(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortPower(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspend (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortSuspendChange (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
EHCI_RH_ClearFeaturePortOvercurrentChange (
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
EHCI_OptumtuseratePort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

//
// SSTOOL.C Function Prototypes
//

USB_MINIPORT_STATUS
USBMPFN
EHCI_StartSendOnePacket(
    PDEVICE_DATA DeviceData,
    PMP_PACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkSpaceLength,
    USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
USBMPFN
EHCI_EndSendOnePacket(
    PDEVICE_DATA DeviceData,
    PMP_PACKET_PARAMETERS PacketParameters,
    PUCHAR PacketData,
    PULONG PacketLength,
    PUCHAR WorkspaceVirtualAddress,
    HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    ULONG WorkSpaceLength,
    USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
EHCI_OpenIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetIsoEndpointState(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATE State
    );

VOID
EHCI_RebalanceEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_SetAsyncEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    MP_ENDPOINT_STATUS Status
    );

MP_ENDPOINT_STATUS
EHCI_GetAsyncEndpointStatus(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

VOID
EHCI_PollIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_AbortIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext
    );

VOID
EHCI_InternalPollHsIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    BOOLEAN Complete
    );

VOID
EHCI_InsertHsIsoTdsInSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PENDPOINT_DATA PrevEndpointData,
    PENDPOINT_DATA NextEndpointData
    );

USB_MINIPORT_STATUS
EHCI_OpenHsIsochronousEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_EnablePeriodicList(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_RemoveHsIsoTdsFromSchedule(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_RebalanceInterruptEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

VOID
EHCI_RebalanceIsoEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_PARAMETERS EndpointParameters,
    PENDPOINT_DATA EndpointData
    );

BOOLEAN
EHCI_PastExpirationDate(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
EHCI_PokeAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
EHCI_PokeIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

PHCD_QUEUEHEAD_DESCRIPTOR
EHCI_GetDummyQueueHeadForFrame(
    PDEVICE_DATA DeviceData,
    ULONG Frame
    );

VOID
EHCI_AddDummyQueueHeads(
    PDEVICE_DATA DeviceData
    );

BOOLEAN
EHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    );

VOID
EHCI_LockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh,
     ENDPOINT_TRANSFER_TYPE EpType
     );

VOID
EHCI_UnlockQueueHead(
     PDEVICE_DATA DeviceData,
     PHCD_QUEUEHEAD_DESCRIPTOR Qh
     );

VOID
EHCI_PollHaltedEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_PollActiveEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_AssertQhChk(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
     );

VOID
EHCI_LinkTransferToQueue(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR FirstTd
    );

USB_MINIPORT_STATUS
EHCI_RH_ChirpRootPort(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
USBMPFN
EHCI_TakePortControl(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_AsyncCacheFlush(
     PDEVICE_DATA DeviceData
     );

USB_MINIPORT_STATUS
EHCI_StopBIOS(
    PDEVICE_DATA DeviceData
    );

VOID
EHCI_SetNextTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR  LinkTd,
    PHCD_TRANSFER_DESCRIPTOR  NextTd,
    BOOLEAN SetAltNext
    );

VOID
EHCI_SetAltNextTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR  LinkTd,
    PHCD_TRANSFER_DESCRIPTOR  NextTd
    );

#endif /* __EHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros
    
Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// 
// Structure signatures
//

#define OHCI_TAG          'hymp'        //"HYMP"

// always log
#define DEBUG_LOG

#if DBG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//
 
#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak;                           

//
// This Breakpoint means we either need to test the code path 
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<OHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }                            
                         
#define ASSERT_TRANSFER(dd, t) OHCI_ASSERT((dd), (t)->Sig == SIG_OHCI_TRANSFER)

ULONG
_cdecl
OHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   OHCI_KdPrint(_x_) OHCI_KdPrintX _x_

#define OHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }        


#define OHCI_ASSERT_ED(dd, ed) OHCI_ASSERT((dd), ((ed)->Sig == SIG_HCD_ED || \
                                                  (ed)->Sig == SIG_HCD_DUMMY_ED))

#else 

// debug macros for retail build

#define TEST_TRAP()

#define ASSERT_TRANSFER(dd, t)

#define DEBUG_BREAK(dd) 

#define OHCI_KdPrint(_x_)

#define OHCI_ASSERT_ED(dd, ed)

#define OHCI_ASSERT(dd, exp )

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//OHCI_KdPrintX

#if DBG


ULONG
_cdecl
OHCI_KdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\errata.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errata.c

Abstract:

    documented errata for all of our favorite types of 
    openhci USB controllers.

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#include "common.h"

/* 
    Hydra Errata

    The folllowing code is specific for the COMPAQ Hydra OHCI hardware
    design -- it should not be executed on other controllers
*/

// Hydra HighSpeed/LowSpeed Data Corruption Bug


VOID
InitializeHydraHsLsFix(
    )
/*++

Routine Description:

    Data corruption can occur on the Hydra part when iso transfers 
    follow lowspeed interrupt transfers.  

    The classic repro of this bug is playing 'dance of the surgar 
    plum fairys' on USB speakers while moving the USB mouse. This 
    generates low speed interrupt INs and High speed ISO OUTs.

    The 'fix' is to introduce a 'specific delay before the HS Iso 
    transfers and after teh LS interrupt transfers.


    (31) -\ 
          (15)-\
    (32) -/     \
                (7 )-\
    (33) -\     /     \
          (16)-/       \
    (34) -/   
    
    
Arguments:

Return Value:

    none

--*/
{

    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHCD_DEVICE_DATA deviceData;
    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;

    OpenHCI_KdPrint((1, "'*** WARNING: Turning on HS/LS Fix ***\n"));
    //
    // **
    // WARNING:
    /*
        The folllowing code is specific for the COMPAQ OHCI hardware
        design -- it should not be executed on other controllers
    */

    /* Dummy ED must look like this:

    ED->TD->XXX
    XXX is bogus address 0xABADBABE
    (HeadP points to TD)
    (TailP points to XXX)

    TD has CBP=0 and BE=0
    NextTD points to XXX

    TD will never be retired by the hardware

    */

    //
    // create a dummy interrupt ED with period 1
    //
    deviceData = (PHCD_DEVICE_DATA) DeviceObject->DeviceExtension;

    // Reserve the 17 dummy EDs+TDs
    //
    OpenHCI_ReserveDescriptors(deviceData, 34);

    // add 17 dummy EDs+TDs
    //
    for (i=0; i< 17; i++) {
        ed = InsertEDForEndpoint(deviceData, NULL, ED_INTERRUPT_1ms,
                &td);

        OHCI_ASSERT(td);
        ed->Endpoint = NULL;

        ed->HcED.FunctionAddress = 0;
        ed->HcED.EndpointNumber = 0;
        ed->HcED.Direction = 0;
        ed->HcED.LowSpeed = 0;
        ed->HcED.sKip = 1;
        ed->HcED.Isochronous = 0;
        ed->HcED.MaxPacket = 0;

        //fixup the TD
        td->Canceled = FALSE;
        td->NextHcdTD = (PVOID)-1;
        td->UsbdRequest = MAGIC_SIG;

        td->HcTD.CBP = 0;
        td->HcTD.BE = 0;
        td->HcTD.Control = 0;
        td->HcTD.NextTD = 0xABADBABE;

        // set head/Tail pointers
//        ed->HcED.HeadP = td->PhysicalAddress;
//        ed->HcED.TailP = 0xABADBABE;

        // turn it on
        LOGENTRY(G, 'MagI', 0, ed, td);
        //TEST_TRAP();
        //ed->HcED.sKip = 0;

    }

    return STATUS_SUCCESS;
}



/*
    NEC Errata
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\errata.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errata.c

Abstract:

    documented errata for all of our favorite types of 
    openhci USB controllers.

Environment:

    Kernel mode

Revision History:

    12-31-99 : created jdunn

--*/


#include "common.h"

/* 
    Hydra Errata

    The folllowing code is specific for the COMPAQ Hydra OHCI hardware
    design -- it should not be executed on other controllers
*/

// Hydra HighSpeed/LowSpeed Data Corruption Bug


ULONG
InitializeHydraHsLsFix(
     PDEVICE_DATA DeviceData,
     PUCHAR CommonBuffer,
     HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys
    )
/*++

Routine Description:

    Data corruption can occur on the Hydra part when iso and bulk 
    transfers follow lowspeed interrupt transfers.  

    The classic repro of this bug is playing 'dance of the surgar 
    plum fairys' on USB speakers while moving the USB mouse. This 
    generates low speed interrupt INs and High speed ISO OUTs.

    The 'fix' is to introduce a 'specific delay before the HS Iso 
    transfers and after the LS interrupt transfers.

                <Interrupt Schedule>

    staticEd(period)

                 (4) -\ 
                       (2)-\
                 (4) -/     \
                             (1 )-><DELAY>->(Iso)->(Control and Bulk)
                 (4) -\      /     
                        (2)-/       
                 (4) -/   
    
    
    The <DELAY> is a predifined set of dummy EDs and TDs.
    
Arguments:

Return Value:

    returns the ammount of common buffer used for the 'hack'

--*/
{
    PHCD_ENDPOINT_DESCRIPTOR ed, tailEd;
    PHCD_TRANSFER_DESCRIPTOR td;
    PHC_STATIC_ED_DATA static1msEd;   
    ULONG i;
    ULONG bufferUsed = 0;

    static1msEd = &DeviceData->StaticEDList[ED_INTERRUPT_1ms];
    
    /* 

    To achieve the proper timming we must insert 17 dumy EDs 
    each dummy ED must look like this:

    ED->TD->XXX
    XXX is bogus address = 0xABADBABE
    (HeadP points to TD)
    (TailP points to XXX)

    TD has CBP=0 and BE=0
    NextTD points to XXX

    The TD will never be retired by the hardware

    so we end up with:

    staticEd(1ms)->dED(1)->dED(2)....dED(17)->(1ms transferEds)

    NOTE: Since the problem only occurs with low speed, and 
    low speed may not have a period < 8ms we don't need to 
    worry about 1ms interrupt transfers.


    */

    //
    // add 17 dummy ED TD pairs
    //
    
    for (i=0; i< 17; i++) {
    
        ed = (PHCD_ENDPOINT_DESCRIPTOR) CommonBuffer;

        RtlZeroMemory(ed, sizeof(*ed));
        ed->PhysicalAddress = CommonBufferPhys;

        CommonBuffer += sizeof(HCD_TRANSFER_DESCRIPTOR);
        CommonBufferPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);
        bufferUsed += sizeof(HCD_ENDPOINT_DESCRIPTOR);

        td = (PHCD_TRANSFER_DESCRIPTOR) CommonBuffer;

        RtlZeroMemory(td, sizeof(*td));
        td->PhysicalAddress = CommonBufferPhys;

        CommonBuffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
        CommonBufferPhys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
        bufferUsed += sizeof(HCD_ENDPOINT_DESCRIPTOR);

        LOGENTRY(DeviceData, G, 'hyF', 0, ed, td);

        // initialize the ed and td
        
        ed->Sig = SIG_HCD_DUMMY_ED;
        ed->EdFlags = 0;

        // inint dummy HW ED
        ed->HwED.sKip = 1;
        ed->HwED.HeadP = td->PhysicalAddress;
        ed->HwED.TailP = 0xABADBABE;

        td->Sig = SIG_HCD_TD;
        td->Flags = 0;
        td->HwTD.NextTD = 0xABADBABE;

        // insert in the schedule on the 1ms list

        if (IsListEmpty(&static1msEd->TransferEdList)) { 

            //
            // list is currently empty,
            // link it to the head of the hw queue
            //

            DeviceData->HydraLsHsHackEd = ed;

            InsertHeadList(&static1msEd->TransferEdList, 
                           &ed->SwLink.List);
        
            // PhysicaHead is the address of the 
            // NextED entry in the static HwED for the list list,  
            // (ie &HwED->nextEd == physicalHead)
            // so we end up with
            // StaticEd->TransferHwED->TransferHwED->NextStaticED
            //
                        
            LOGENTRY(DeviceData, G, '_INh', 
                    static1msEd->PhysicalHead, 
                    ed, 
                    static1msEd);
                    
            // tail points to old list head HW ed head
            ed->HwED.NextED = *static1msEd->PhysicalHead;
            // new head is this ed
            *static1msEd->PhysicalHead = ed->PhysicalAddress;
        } else {
        
            //
            // Something already on the list,
            // Link ED into tail of transferEd list
            //
        
            tailEd = CONTAINING_RECORD(static1msEd->TransferEdList.Blink,
                                       HCD_ENDPOINT_DESCRIPTOR,
                                       SwLink);
                                  
            LOGENTRY(DeviceData, G, '_Led', 0, tailEd, static1msEd);
            InsertTailList(&static1msEd->TransferEdList, &ed->SwLink.List);
            ed->HwED.NextED = 0;
            tailEd->HwED.NextED = ed->PhysicalAddress;
        }
    }

    return bufferUsed;
}



/*
    NEC Errata
*/


/*
    AMD Errata
*/

ULONG
OHCI_ReadRhDescriptorA(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Read the number of downstream ports and other root hub characteristics
    from the HcRhDescriptorA register.
    
    If this register reads as all zero or any of the reserved bits are set
    then try reading the register again.  This is a workaround for some
    early revs of the AMD K7 chipset, which can sometimes return bogus values
    if the root hub registers are read while the host controller is
    performing PCI bus master ED & TD reads.

    Attempt up to ten reads if a reserved bit is set. If a reserved bit is 
    set on or register is zero on purpose we will still return the 
    register after doing penece of ten reads thanks to AMD.

Arguments:

Return Value:

    descrA register (hopefully)

--*/
{
    HC_RH_DESCRIPTOR_A descrA;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG i;

    hc = DeviceData->HC;
    
    for (i = 0; i < 10; i++) {
    
        descrA.ul = READ_REGISTER_ULONG(&hc->HcRhDescriptorA.ul);

        if ((descrA.ul) && (!(descrA.ul & HcDescA_RESERVED))) {
            break;
        } else {
            KeStallExecutionProcessor(5);
        }
        
    }

    return descrA.ul;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\iso.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   iso.c

Abstract:

   miniport transfer code for iso

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    3-1-00 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:

USB_MINIPORT_STATUS
OHCI_OpenIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys, edPhys;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i, available, tdCount;
        
    LOGENTRY(DeviceData, G, '_opS', 0, 0, 0);

    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;
    available = EndpointParameters->CommonBufferBytes;


#if DBG
   {
        ULONG offset;
    
        offset = BYTE_OFFSET(buffer);

        // OHCI requires 16 byte alignemnt
        OHCI_ASSERT(DeviceData, (offset % 16) == 0);    
    }
#endif    
   
    // use control list
    EndpointData->StaticEd = 
        &DeviceData->StaticEDList[ED_ISOCHRONOUS];
        
    // make the Ed
    ed = (PHCD_ENDPOINT_DESCRIPTOR) buffer;
    
    edPhys = phys;
    phys += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    buffer += sizeof(HCD_ENDPOINT_DESCRIPTOR);
    available -= sizeof(HCD_ENDPOINT_DESCRIPTOR);
    
    EndpointData->TdList = (PHCD_TD_LIST) buffer;

    tdCount = available/sizeof(HCD_TRANSFER_DESCRIPTOR);
    LOGENTRY(DeviceData, G, '_tdC', tdCount, TDS_PER_ISO_ENDPOINT, 0);
    OHCI_ASSERT(DeviceData, tdCount >= TDS_PER_ISO_ENDPOINT);

    EndpointData->TdCount = tdCount;
    for (i=0; i<tdCount; i++) {
        OHCI_InitializeTD(DeviceData,
                          EndpointData,
                          &EndpointData->TdList->Td[i],
                          phys);                                         
                             
        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);    
    }

    EndpointData->HcdEd = 
        OHCI_InitializeED(DeviceData,
                             EndpointData,
                             ed,
                             &EndpointData->TdList->Td[0],
                             edPhys);            

    // iso endpoints do not halt
    ed->EdFlags = EDFLAG_NOHALT;
    
    OHCI_InsertEndpointInSchedule(DeviceData,
                                  EndpointData);
                                      
    return USBMP_STATUS_SUCCESS;            
}


ULONG
OHCI_IsoTransferLookAhead(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

    Calculates how many TDs we will need for this transfer

Arguments:

Return Value:

--*/    
{
    PHCD_TRANSFER_DESCRIPTOR td, lastTd;
    ULONG currentPacket;
    PMINIPORT_ISO_TRANSFER tmpIsoTransfer;
    ULONG need = 1, n;

    LOGENTRY(DeviceData, G, '_lk1', EndpointData, TransferParameters, 
        EndpointData->HcdEd);

    OHCI_ASSERT(DeviceData, IsoTransfer->PacketCount > 0);
    // sometimes you just need memory
    n = sizeof(MINIPORT_ISO_TRANSFER) + sizeof(MINIPORT_ISO_PACKET) *
            (IsoTransfer->PacketCount-1);
    tmpIsoTransfer = ExAllocatePool(NonPagedPool, n);
    if (tmpIsoTransfer == NULL) {
        // this will cause us to return busy
        return 99999;
    }
    RtlCopyMemory(tmpIsoTransfer, IsoTransfer, n);

    td = OHCI_ALLOC_TD(DeviceData, EndpointData);
    currentPacket = 0;
    // we need at least one TD to do the caculations
    if (td == USB_BAD_PTR) {
        // this will cause us to return busy
        return 99999;
    }

    do {
    
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        //TransferContext->PendingTds++;
        //EndpointData->PendingTds++;
        
        currentPacket = 
            OHCI_MapIsoTransferToTd(DeviceData,
                                    tmpIsoTransfer,
                                    currentPacket, 
                                    td);              

        // alloc another iso TD
        lastTd = td;
        // reuse the same td since this is not a real transfer            
        //td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        need++;
        
        SET_NEXT_TD(lastTd, td);        
        
    } while (currentPacket < tmpIsoTransfer->PacketCount);

    // free the TD we borrowed
    OHCI_FREE_TD(DeviceData, EndpointData, td);
    ExFreePool(tmpIsoTransfer);
    
    return need;
}


USB_MINIPORT_STATUS
OHCI_IsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/    
{
    PHCD_TRANSFER_DESCRIPTOR td, lastTd;
    ULONG currentPacket;
    ULONG tdsNeeded;
    
    EndpointData->PendingTransfers++;

    // we have enough tds, program the transfer

    LOGENTRY(DeviceData, G, '_nby', EndpointData, TransferParameters, 
        EndpointData->HcdEd);

    TransferContext->IsoTransfer = IsoTransfer;

    // lookahead calculation
    // see if we can handle this transfer 
    //
    tdsNeeded = OHCI_IsoTransferLookAhead(DeviceData,
                                          EndpointData,
                                          TransferParameters,
                                          TransferContext,
                                          IsoTransfer);
    
    if ((EndpointData->TdCount - EndpointData->PendingTds) < 
         tdsNeeded) {

        return USBMP_STATUS_BUSY;         
    }    
    
    //        
    // grab the dummy TD from the tail of the queue
    //
    td = EndpointData->HcdTailP;
    OHCI_ASSERT(DeviceData, td->Flags & TD_FLAG_BUSY);

    currentPacket = 0;

    LOGENTRY(DeviceData, G, '_iso', EndpointData, TransferContext, 
        td);

    do {
    
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);
        TransferContext->PendingTds++;
        EndpointData->PendingTds++;
        
        currentPacket = 
            OHCI_MapIsoTransferToTd(DeviceData,
                                    IsoTransfer,
                                    currentPacket, 
                                    td);              

        // alloc another iso TD
        lastTd = td;
        td = OHCI_ALLOC_TD(DeviceData, EndpointData);
        OHCI_ASSERT(DeviceData, td != USB_BAD_PTR);
        SET_NEXT_TD(lastTd, td);        
        
    } while (currentPacket < IsoTransfer->PacketCount);

    // td should be the new dummy,
    // now put a new dummy TD on the tail of the EP queue
    //

    SET_NEXT_TD_NULL(td);
    
    //
    // Set new TailP in ED
    // note: This is the last TD in the list and the place holder.
    //

    TransferContext->NextXferTd = 
        EndpointData->HcdTailP = td;
//if (TransferParameters->TransferBufferLength > 128) {
//    TEST_TRAP();
//}
    
    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Til',  TransferContext->PendingTds , 
        td->PhysicalAddress, EndpointData->HcdEd->HwED.HeadP);
    EndpointData->HcdEd->HwED.TailP = td->PhysicalAddress;

    LOGENTRY(DeviceData, G, '_igo', EndpointData->HcdHeadP,
                 TransferContext->TcFlags, 0);                   
                 
//if (TransferParameters->TransferBufferLength > 128) {
//    TEST_TRAP();
//}
    
    return USBMP_STATUS_SUCCESS;
}


ULONG
OHCI_MapIsoTransferToTd(
     PDEVICE_DATA DeviceData,
     PMINIPORT_ISO_TRANSFER IsoTransfer,
     ULONG CurrentPacket,
     PHCD_TRANSFER_DESCRIPTOR Td 
    )
/*++

Routine Description:

    

Arguments:

Returns:

    LengthMapped
    
--*/
{
    HW_32BIT_PHYSICAL_ADDRESS logicalStart, logicalEnd;
    HW_32BIT_PHYSICAL_ADDRESS startPage, endPage;
    PMINIPORT_ISO_PACKET iPacket;
    ULONG packetsThisTd;
    ULONG lengthThisTd, offset;
    USHORT startFrame;

    packetsThisTd = 0;
    lengthThisTd = 0;
    logicalStart = 0;

    LOGENTRY(DeviceData, G, '_mpI', CurrentPacket, 
            IsoTransfer->PacketCount, 0);    
    OHCI_ASSERT(DeviceData, CurrentPacket < IsoTransfer->PacketCount);

    Td->FrameIndex = CurrentPacket;
    
    while (CurrentPacket < IsoTransfer->PacketCount) {
    
        LOGENTRY(DeviceData, G, '_mpC', CurrentPacket, 
            IsoTransfer->PacketCount, 0);    

        iPacket = &IsoTransfer->Packets[CurrentPacket];

        OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount < 3);
        OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount != 0);

        // cases are:
        // case 1 - packet has pagebreak
        //   case 1a we have already filled in part of the current TD
        //      <bail, next pass will be 1b>
        //
        //   case 1b we have not used the current TD yet
        //      <add packet to TD and bail>
        //
        // case 2 - packet has no pagebreak and will fit
        //   case 2a current packet is on different page than previous
        //           packet
        //      <add packet and bail>
        //
        //   case 2b current packet is on same page as previous packet
        //      <add packet and try to add another>
        //
        //   case 2c TD has not been used yet
        //      <add packet and try to add another>
        //
        // case 3 - packet will not fit
        //      <bail>
        
        // does the packet have a page break?
        if (iPacket->BufferPointerCount > 1) {
            // yes,
            // case 1
            
            if (packetsThisTd != 0) {
                // case 1a 
                // we have packets in this TD bail, 
                // leave it for next time
                LOGENTRY(DeviceData, G, '_c1a', 0, 0, lengthThisTd);
                break;
            } 
            
            // case 1b give the packet its own TD
            
            // convert to a 16-bit frame number
            startFrame = (USHORT) iPacket->FrameNumber;

            LOGENTRY(DeviceData, G, '_c1b', iPacket, CurrentPacket, startFrame);

            logicalStart = iPacket->BufferPointer0.Hw32 & ~OHCI_PAGE_SIZE_MASK;
            offset = iPacket->BufferPointer0.Hw32 & OHCI_PAGE_SIZE_MASK;
            
            logicalEnd = iPacket->BufferPointer1.Hw32 + 
                iPacket->BufferPointer1Length;  
                
            lengthThisTd = iPacket->Length;
            packetsThisTd++;

            CurrentPacket++;
            
            Td->HwTD.Packet[0].Offset = (USHORT) offset;
            Td->HwTD.Packet[0].Ones = 0xFFFF;

            break;
        }

        // will this packet fit in the current Td?
        
        if (packetsThisTd < 8 && 
            (lengthThisTd+iPacket->Length < OHCI_PAGE_SIZE * 2)) {

            LOGENTRY(DeviceData, G, '_fit', iPacket, CurrentPacket, 0);

            OHCI_ASSERT(DeviceData, iPacket->BufferPointerCount == 1);
            OHCI_ASSERT(DeviceData, iPacket->Length == 
                iPacket->BufferPointer0Length);
                
            // yes
            // case 2
            if (logicalStart == 0) {
                // first packet, set logical start & end
                // case 2c and frame number
                LOGENTRY(DeviceData, G, '_c2c', iPacket, CurrentPacket, 0);

                startFrame = (USHORT) iPacket->FrameNumber;

                offset = iPacket->BufferPointer0.Hw32 & OHCI_PAGE_SIZE_MASK;
                logicalStart = iPacket->BufferPointer0.Hw32 & ~OHCI_PAGE_SIZE_MASK;
                
                logicalEnd = iPacket->BufferPointer0.Hw32 + 
                    iPacket->BufferPointer0Length;
                lengthThisTd += iPacket->Length; 
                Td->HwTD.Packet[0].Offset = (USHORT) offset;
                Td->HwTD.Packet[0].Ones = 0xFFFF;
                packetsThisTd++;
                    
                CurrentPacket++;
                
            } else {
                // not first packet
                LOGENTRY(DeviceData, G, '_adp', iPacket, CurrentPacket, 
                    packetsThisTd);

                logicalEnd = iPacket->BufferPointer0.Hw32 + 
                    iPacket->Length;
                OHCI_ASSERT(DeviceData, lengthThisTd < OHCI_PAGE_SIZE * 2);                    
                
                Td->HwTD.Packet[packetsThisTd].Offset 
                    = (USHORT) (lengthThisTd + offset);     
                Td->HwTD.Packet[packetsThisTd].Ones = 0xFFFF;                    
                
                lengthThisTd += iPacket->Length;                     
                packetsThisTd++;

                startPage = logicalStart & ~OHCI_PAGE_SIZE_MASK;                     
                endPage = logicalEnd & ~OHCI_PAGE_SIZE_MASK;
                
                CurrentPacket++;
                
                // did we cross a page?
                if (startPage != endPage) {
                    // yes, bail now
                    LOGENTRY(DeviceData, G, '_c2a', Td, CurrentPacket, 0);
                    break;
                }

                LOGENTRY(DeviceData, G, '_c2b', Td, CurrentPacket, 0);

                // no, keep going
            }
        } else {
            // won't fit
            // bail and leave it for next time
            LOGENTRY(DeviceData, G, '_ca3', Td, CurrentPacket, 0);
            break;
        }
    }

    Td->HwTD.CBP = logicalStart; 
    Td->HwTD.BE = logicalEnd-1; 
    Td->TransferCount = lengthThisTd;
    Td->HwTD.Iso.StartingFrame = startFrame;
    Td->HwTD.Iso.FrameCount = packetsThisTd-1;
    Td->HwTD.Iso.Isochronous = 1;
    Td->HwTD.Iso.IntDelay = HcTDIntDelay_0ms;
    LOGENTRY(DeviceData, G, '_iso', Td, 0, CurrentPacket);
    
    return CurrentPacket;
}


VOID
OHCI_ProcessDoneIsoTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    )
/*++

Routine Description:

    process a completed Iso TD

Parameters
    
--*/
{
    PTRANSFER_CONTEXT transferContext;    
    PENDPOINT_DATA endpointData;
    USBD_STATUS usbdStatus;
    PMINIPORT_ISO_TRANSFER isoTransfer;
    ULONG frames, n, i;

    transferContext = TRANSFER_CONTEXT_PTR(Td->TransferContext);
    isoTransfer = transferContext->IsoTransfer;

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;
    endpointData->PendingTds--;

    LOGENTRY(DeviceData, G, '_Did', transferContext, 
                         0,
                         Td);       

    // walk the PSWs and fill in the IsoTransfer structure

    frames = Td->HwTD.Iso.FrameCount+1;
    n = Td->FrameIndex;
    
    for (i = 0; i<frames; i++) {
    
        PMINIPORT_ISO_PACKET mpPak;   
        PHC_OFFSET_PSW psw;
        
        mpPak = &isoTransfer->Packets[n+i];
        psw = &Td->HwTD.Packet[i];

        mpPak->LengthTransferred = 0;
        
        if (IN_TRANSFER(transferContext->TransferParameters)) {
            // in transfer                         

            // if we got an error the length may still be
            // valid, so we return it
            if (psw->ConditionCode != HcCC_NotAccessed) {
                mpPak->LengthTransferred = psw->Size;
            }
            LOGENTRY(DeviceData, G, '_isI', 
                    i,
                    mpPak->LengthTransferred, 
                    psw->ConditionCode);

        } else {
            // out transfer 
            
            // assume all data was sent if no error is indicated
            if (psw->ConditionCode == HcCC_NoError) {
                mpPak->LengthTransferred = mpPak->Length;
            }
            LOGENTRY(DeviceData, G, '_isO', 
                    i,
                    mpPak->LengthTransferred, 
                    psw->ConditionCode);
        }

        if (psw->ConditionCode == HcCC_NoError) {
            mpPak->UsbdStatus = USBD_STATUS_SUCCESS;
        } else {
            mpPak->UsbdStatus = psw->ConditionCode;
            mpPak->UsbdStatus |= 0xC0000000;
        }      

    }
    
    // mark the TD free
    OHCI_FREE_TD(DeviceData, endpointData, Td);
    
    if (transferContext->PendingTds == 0 && CompleteTransfer) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate 
        // we can take another
        endpointData->PendingTransfers--;

        transferContext->TransferParameters->FrameCompleted = 
            OHCI_Get32BitFrameNumber(DeviceData);
       

        LOGENTRY(DeviceData, G, '_cpi', 
            transferContext, 
            0,
            0);
            
        USBPORT_COMPLETE_ISO_TRANSFER(DeviceData,
                                      endpointData,
                                      transferContext->TransferParameters,
                                      transferContext->IsoTransfer);
    }
}


VOID
OHCI_PollIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'
    
    The goal here is to determine which TDs, if any, 
    have completed and complete any associated transfers

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    PTRANSFER_CONTEXT transfer;
    HW_32BIT_PHYSICAL_ADDRESS headP;
    
    ed = EndpointData->HcdEd;

    LOGENTRY(DeviceData, G, '_pli', ed, 0, 0);        

    // note it is important the the compiler generate a 
    // dword move when reading the queuehead HeadP register 
    // since this location is also accessed by the host
    // hardware
    headP = ed->HwED.HeadP;

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(headP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);
                                            
    LOGENTRY(DeviceData, G, '_cTD', currentTd, 
        headP & ~HcEDHeadP_FLAGS, 
            TRANSFER_CONTEXT_PTR(currentTd->TransferContext));                 

    // iso endpoints shpuld not halt
    OHCI_ASSERT(DeviceData, (ed->HwED.HeadP & HcEDHeadP_HALT) == 0) 
    
    
    // Walk the swHeadP to the current TD (hw headp)               
    // mark all TDs we find as completed
    //
    // NOTE: this step may be skipped if the 
    // done queue is reliable

    td = EndpointData->HcdHeadP;

    while (td != currentTd) {
        LOGENTRY(DeviceData, G, '_mDN', td, 0, 0); 
        SET_FLAG(td->Flags, TD_FLAG_DONE);
        td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
    }            

    // set the sw headp to the new current head
    EndpointData->HcdHeadP = currentTd;
    
    // now flush all completed TDs
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {
            OHCI_ProcessDoneIsoTd(DeviceData,
                                  td,
                                  TRUE);
        }                                  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\mpinit.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
     PDRIVER_OBJECT DriverObject,
     PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    RegistrationPacket.DeviceDataSize =
        sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize =
        sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize =
        sizeof(TRANSFER_CONTEXT);

    // enough for HCCA plus
    RegistrationPacket.CommonBufferBytes = OHCI_COMMON_BUFFER_SIZE;

    /* miniport Functions */
    RegistrationPacket.MINIPORT_OpenEndpoint =
        OHCI_OpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint =
        OHCI_PokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements =
        OHCI_QueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint =
        OHCI_CloseEndpoint;
    RegistrationPacket.MINIPORT_StartController =
        OHCI_StartController;
    RegistrationPacket.MINIPORT_StopController =
        OHCI_StopController;
    RegistrationPacket.MINIPORT_SuspendController =
        OHCI_SuspendController;
    RegistrationPacket.MINIPORT_ResumeController =
        OHCI_ResumeController;
    RegistrationPacket.MINIPORT_InterruptService =
        OHCI_InterruptService;
    RegistrationPacket.MINIPORT_InterruptDpc =
        OHCI_InterruptDpc;
    RegistrationPacket.MINIPORT_SubmitTransfer =
        OHCI_SubmitTransfer;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer =
        OHCI_SubmitIsoTransfer;
    RegistrationPacket.MINIPORT_AbortTransfer =
        OHCI_AbortTransfer;
    RegistrationPacket.MINIPORT_GetEndpointState =
        OHCI_GetEndpointState;
    RegistrationPacket.MINIPORT_SetEndpointState =
        OHCI_SetEndpointState;
    RegistrationPacket.MINIPORT_PollEndpoint =
        OHCI_PollEndpoint;
    RegistrationPacket.MINIPORT_CheckController =
        OHCI_CheckController;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber =
        OHCI_Get32BitFrameNumber;
    RegistrationPacket.MINIPORT_InterruptNextSOF =
        OHCI_InterruptNextSOF;
    RegistrationPacket.MINIPORT_EnableInterrupts =
        OHCI_EnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts =
        OHCI_DisableInterrupts;
    RegistrationPacket.MINIPORT_PollController =
        OHCI_PollController;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle =
        OHCI_SetEndpointDataToggle;
    RegistrationPacket.MINIPORT_GetEndpointStatus =
        OHCI_GetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointStatus =
        OHCI_SetEndpointStatus;
    RegistrationPacket.MINIPORT_ResetController =
        OHCI_ResetController;
    RegistrationPacket.MINIPORT_FlushInterrupts =
        OHCI_FlushInterrupts;        

    /* root hub functions */
    RegistrationPacket.MINIPORT_RH_GetRootHubData =
        OHCI_RH_GetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus =
        OHCI_RH_GetStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus =
        OHCI_RH_GetPortStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus =
        OHCI_RH_GetHubStatus;

    /* root hub port functions */
    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset =
        OHCI_RH_SetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower =
        OHCI_RH_SetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable =
        OHCI_RH_SetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend =
        OHCI_RH_SetFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable =
        OHCI_RH_ClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower =
        OHCI_RH_ClearFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend =
        OHCI_RH_ClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange =
        OHCI_RH_ClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange =
        OHCI_RH_ClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange =
        OHCI_RH_ClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange =
        OHCI_RH_ClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange =
        OHCI_RH_ClearFeaturePortOvercurrentChange;

    /* optional root hub functions */
    RegistrationPacket.MINIPORT_RH_DisableIrq =
        OHCI_RH_DisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq =
        OHCI_RH_EnableIrq;

    /* OPTIONAL DEBUG SERVICES */
    RegistrationPacket.MINIPORT_StartSendOnePacket =
        OHCI_StartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket =
        OHCI_EndSendOnePacket;

    // OHCI needs both IRQ and memory resources
    RegistrationPacket.OptionFlags =
        USB_MINIPORT_OPT_NEED_IRQ |
        USB_MINIPORT_OPT_NEED_MEMORY |
        USB_MINIPORT_OPT_POLL_IN_SUSPEND |
        USB_MINIPORT_OPT_USB11;

    RegistrationPacket.HciType = USB_OHCI;
    RegistrationPacket.BusBandwidth = USB_11_BUS_BANDWIDTH;

    DriverObject->DriverUnload = OHCI_Unload;

    return USBPORT_RegisterUSBPortDriver(
                DriverObject,
                USB_MINIPORT_HCI_VERSION,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\openhci.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    openhci.h

Abstract:

   Definitions from OPENHCI 1.0 USB specification

Environment:

    Kernel & user mode

Revision History:

    12-28-95 : created jfuller & kenray

--*/


#ifndef OPENHCI_H
#define OPENHCI_H

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//

#define MAXIMUM_OVERHEAD   210

#define OHCI_PAGE_SIZE 0x1000
// #define OHCI_PAGE_SIZE 0x20
#define OHCI_PAGE_SIZE_MASK (OHCI_PAGE_SIZE - 1)


//
// 7.1.1 HcRevision Register
// Definition of Host Controller Revision register
//
typedef union _HC_REVISION {
   ULONG                   ul;
   struct {
      ULONG                Rev:8;
      ULONG                :24;
   };
} HC_REVISION, *PHC_REVISION;

C_ASSERT(sizeof(HC_REVISION) == 4);

//
// 7.1.2 HcControl Register
// Definition of Host Controller Control register
//
typedef union _HC_CONTROL {
   ULONG                   ul;
   struct {
      ULONG                ControlBulkServiceRatio:2;
      ULONG                PeriodicListEnable:1;
      ULONG                IsochronousEnable:1;
      ULONG                ControlListEnable:1;
      ULONG                BulkListEnable:1;
      ULONG                HostControllerFunctionalState:2;
      ULONG                InterruptRouting:1;
      ULONG                RemoteWakeupConnected:1;
      ULONG                RemoteWakeupEnable:1;
      ULONG                :21;
   };
} HC_CONTROL, *PHC_CONTROL;

C_ASSERT(sizeof(HC_CONTROL) == 4);

#define HcCtrl_CBSR_MASK                     0x00000003L
#define HcCtrl_CBSR_1_to_1                   0x00000000L
#define HcCtrl_CBSR_2_to_1                   0x00000001L
#define HcCtrl_CBSR_3_to_1                   0x00000002L
#define HcCtrl_CBSR_4_to_1                   0x00000003L
#define HcCtrl_PeriodicListEnable            0x00000004L
#define HcCtrl_IsochronousEnable             0x00000008L
#define HcCtrl_ControlListEnable             0x00000010L
#define HcCtrl_BulkListEnable                0x00000020L
#define HcCtrl_ListEnableMask                0x00000038L

#define HcCtrl_HCFS_MASK                     0x000000C0L
#define HcCtrl_HCFS_USBReset                 0x00000000L
#define HcCtrl_HCFS_USBResume                0x00000040L
#define HcCtrl_HCFS_USBOperational           0x00000080L
#define HcCtrl_HCFS_USBSuspend               0x000000C0L

#define HcCtrl_InterruptRouting              0x00000100L
#define HcCtrl_RemoteWakeupConnected         0x00000200L
#define HcCtrl_RemoteWakeupEnable            0x00000400L

#define HcHCFS_USBReset                      0x00000000
#define HcHCFS_USBResume                     0x00000001
#define HcHCFS_USBOperational                0x00000002
#define HcHCFS_USBSuspend                    0x00000003

//
// 7.1.3 HcCommandStatus Register
// Definition of Host Controller Command/Status register
//
typedef union _HC_COMMAND_STATUS {
   ULONG                   ul;               // use HcCmd flags below
   struct {
      ULONG                HostControllerReset:1;
      ULONG                ControlListFilled:1;
      ULONG                BulkListFilled:1;
      ULONG                OwnershipChangeRequest:1;
      ULONG                :12;
      ULONG                SchedulingOverrunCount:2;
      ULONG                :14;
   };
} HC_COMMAND_STATUS, *PHC_COMMAND_STATUS;

C_ASSERT(sizeof(HC_COMMAND_STATUS) == 4);

#define HcCmd_HostControllerReset            0x00000001
#define HcCmd_ControlListFilled              0x00000002
#define HcCmd_BulkListFilled                 0x00000004
#define HcCmd_OwnershipChangeRequest         0x00000008
#define HcCmd_SOC_Mask                       0x00030000
#define HcCmd_SOC_Offset                     16
#define HcCmd_SOC_Mask_LowBits               0x00000003

//
// 7.3.1 HcFmInterval Register
// Definition of Host Controller Frame Interval register
//
typedef union _HC_FM_INTERVAL {
   ULONG                   ul;              // use HcFmI flags below
   struct {
      ULONG                FrameInterval:14;
      ULONG                :2;
      ULONG                FSLargestDataPacket:15;
      ULONG                FrameIntervalToggle:1;
   };
} HC_FM_INTERVAL, *PHC_FM_INTERVAL;

C_ASSERT(sizeof(HC_FM_INTERVAL) == 4);

#define HcFmI_FRAME_INTERVAL_MASK            0x00003FFF
#define HcFmI_FS_LARGEST_DATA_PACKET_MASK    0x7FFF0000
#define HcFmI_FS_LARGEST_DATA_PACKET_SHIFT   16
#define HcFmI_FRAME_INTERVAL_TOGGLE          0x80000000

//
// 7.3.2 HcFmRemaining Register
// Definition of Host Controller Frame Remaining register
//
typedef union _HC_FM_REMAINING {
   ULONG                   ul;
   struct {
      ULONG                FrameRemaining:14;
      ULONG                :17;
      ULONG                FrameRemainingToggle:1;
   };
} HC_FM_REMAINING, *PHC_FM_REMAINING;

C_ASSERT(sizeof(HC_FM_REMAINING) == 4);

//
// 7.3.3 HcFmNumber Register
// Definition of Host Controller Frame Number register
//
typedef union _HC_FM_NUMBER {
   ULONG                   ul;
   struct {
      ULONG                FrameNumber:16;
      ULONG                :16;
   };
} HC_FM_NUMBER, *PHC_FM_NUMBER;

C_ASSERT(sizeof(HC_FM_NUMBER) == 4);

#define HcFmNumber_MASK                     0x0000FFFF
#define HcFmNumber_RESERVED                 0xFFFF0000

//
// 7.4.1 HcRhDescriptorA Register
// Definition of Host Controller Root Hub DescriptorA register
//
typedef union _HC_RH_DESCRIPTOR_A {
   ULONG                   ul;
   struct {
        ULONG               NumberDownstreamPorts:8;
        ULONG               HubChars:16;                    
        ULONG               PowerOnToPowerGoodTime:8;
   } s;
} HC_RH_DESCRIPTOR_A, *PHC_RH_DESCRIPTOR_A;

C_ASSERT(sizeof(HC_RH_DESCRIPTOR_A) == 4);

#define HcDescA_PowerSwitchingModePort          0x00000100L
#define HcDescA_NoPowerSwitching                0x00000200L
#define HcDescA_DeviceType                      0x00000400L
#define HcDescA_OvercurrentProtectionMode       0x00000800L
#define HcDescA_NoOvercurrentProtection         0x00001000L

// HcRhDescriptorA reserved bits which should not be set.  Note that although
// the NumberDownstreamPorts field is 8 bits wide, the maximum number of ports
// supported by the OpenHCI specification is 15.
//
#define HcDescA_RESERVED                        0x00FFE0F0L


//
// 7.4.2 HcRhDescriptorB Register
// Definition of Host Controller Root Hub DescritorB register
//
typedef union _HC_RH_DESCRIPTOR_B {
   ULONG                   ul;
   struct {
      USHORT               DeviceRemovableMask;
      USHORT               PortPowerControlMask;
   };
} HC_RH_DESCRIPTOR_B, *PHC_RH_DESCRIPTOR_B;

C_ASSERT(sizeof(HC_RH_DESCRIPTOR_B) == 4);

//
// Host Controler Hardware Registers as accessed in memory
//
typedef struct _HC_OPERATIONAL_REGISTER {
   // 0 0x00 - 0,4,8,c
   HC_REVISION             HcRevision;
   HC_CONTROL              HcControl;
   HC_COMMAND_STATUS       HcCommandStatus;
   ULONG                   HcInterruptStatus;   // use HcInt flags below
   // 1 0x10
   ULONG                   HcInterruptEnable;   // use HcInt flags below
   ULONG                   HcInterruptDisable;  // use HcInt flags below
   ULONG                   HcHCCA;              // physical pointer to Host Controller Communications Area
   ULONG                   HcPeriodCurrentED;   // physical ptr to current periodic ED
   // 2 0x20
   ULONG                   HcControlHeadED;     // physical ptr to head of control list
   ULONG                   HcControlCurrentED;  // physical ptr to current control ED
   ULONG                   HcBulkHeadED;        // physical ptr to head of bulk list
   ULONG                   HcBulkCurrentED;     // physical ptr to current bulk ED
   // 3 0x30
   ULONG                   HcDoneHead;          // physical ptr to internal done queue
   HC_FM_INTERVAL          HcFmInterval;
   HC_FM_REMAINING         HcFmRemaining;
   ULONG                   HcFmNumber;
   // 4 0x40
   ULONG                   HcPeriodicStart;
   ULONG                   HcLSThreshold;
   HC_RH_DESCRIPTOR_A      HcRhDescriptorA;
   HC_RH_DESCRIPTOR_B      HcRhDescriptorB;
   // 5 0x50
   ULONG                   HcRhStatus;          // use HcRhS flags below
   ULONG                   HcRhPortStatus[15];  // use HcRhPS flags below
} HC_OPERATIONAL_REGISTER, *PHC_OPERATIONAL_REGISTER;

C_ASSERT(sizeof(HC_OPERATIONAL_REGISTER) == (0x54 + 4 * 15));

//
// 7.1.4 HcInterrruptStatus Register
// 7.1.5 HcInterruptEnable  Register
// 7.1.6 HcInterruptDisable Register
//
#define HcInt_SchedulingOverrun              0x00000001L
#define HcInt_WritebackDoneHead              0x00000002L
#define HcInt_StartOfFrame                   0x00000004L
#define HcInt_ResumeDetected                 0x00000008L
#define HcInt_UnrecoverableError             0x00000010L
#define HcInt_FrameNumberOverflow            0x00000020L
#define HcInt_RootHubStatusChange            0x00000040L
#define HcInt_OwnershipChange                0x40000000L
#define HcInt_MasterInterruptEnable          0x80000000L

//
// 7.4.3 HcRhStatus Register
//
#define HcRhS_LocalPowerStatus                  0x00000001  // read only
#define HcRhS_OverCurrentIndicator              0x00000002  // read only
#define HcRhS_DeviceRemoteWakeupEnable          0x00008000  // read only
#define HcRhS_LocalPowerStatusChange            0x00010000  // read only
#define HcRhS_OverCurrentIndicatorChange        0x00020000  // read only

#define HcRhS_ClearGlobalPower                  0x00000001  // write only
#define HcRhS_SetRemoteWakeupEnable             0x00008000  // write only
#define HcRhS_SetGlobalPower                    0x00010000  // write only
#define HcRhS_ClearOverCurrentIndicatorChange   0x00020000  // write only
#define HcRhS_ClearRemoteWakeupEnable           0x80000000  // write only

//
// 7.4.4 HcRhPortStatus Register
//

//
// The bits in this register have a double meaning depending 
// on if you read or write them
//

#define HcRhPS_CurrentConnectStatus          0x00000001  // read only
#define HcRhPS_PortEnableStatus              0x00000002  // read only
#define HcRhPS_PortSuspendStatus             0x00000004  // read only
#define HcRhPS_PortOverCurrentIndicator      0x00000008  // read only
#define HcRhPS_PortResetStatus               0x00000010  // read only
#define HcRhPS_PortPowerStatus               0x00000100  // read only
#define HcRhPS_LowSpeedDeviceAttached        0x00000200  // read only
#define HcRhPS_ConnectStatusChange           0x00010000  // read only
#define HcRhPS_PortEnableStatusChange        0x00020000  // read only
#define HcRhPS_PortSuspendStatusChange       0x00040000  // read only
#define HcRhPS_OverCurrentIndicatorChange    0x00080000  // read only
#define HcRhPS_PortResetStatusChange         0x00100000  // read only

#define HcRhPS_ClearPortEnable               0x00000001  // write only
#define HcRhPS_SetPortEnable                 0x00000002  // write only
#define HcRhPS_SetPortSuspend                0x00000004  // write only
#define HcRhPS_ClearPortSuspend              0x00000008  // write only
#define HcRhPS_SetPortReset                  0x00000010  // write only
#define HcRhPS_SetPortPower                  0x00000100  // write only
#define HcRhPS_ClearPortPower                0x00000200  // write only
#define HcRhPS_ClearConnectStatusChange      0x00010000  // write only
#define HcRhPS_ClearPortEnableStatusChange   0x00020000  // write only
#define HcRhPS_ClearPortSuspendStatusChange  0x00040000  // write only
#define HcRhPS_ClearPortOverCurrentChange    0x00080000  // write only
#define HcRhPS_ClearPortResetStatusChange    0x00100000  // write only

#define HcRhPS_RESERVED     (~(HcRhPS_CurrentConnectStatus       | \
                               HcRhPS_PortEnableStatus           | \
                               HcRhPS_PortSuspendStatus          | \
                               HcRhPS_PortOverCurrentIndicator   | \
                               HcRhPS_PortResetStatus            | \
                               HcRhPS_PortPowerStatus            | \
                               HcRhPS_LowSpeedDeviceAttached     | \
                               HcRhPS_ConnectStatusChange        | \
                               HcRhPS_PortEnableStatusChange     | \
                               HcRhPS_PortSuspendStatusChange    | \
                               HcRhPS_OverCurrentIndicatorChange | \
                               HcRhPS_PortResetStatusChange        \
                            ))


typedef struct _HCCA_BLOCK {
   ULONG                     HccaInterruptTable[32]; // physical pointer to interrupt lists
   USHORT                    HccaFrameNumber;        // 16-bit current frame number
   USHORT                    HccaPad1;               // When the HC updates
                                                     // HccaFrameNumber, it sets
                                                     // this word to zero.
   ULONG                     HccaDoneHead;           // pointer to done queue
   ULONG                     Reserved[30];           // pad to 256 bytes
} HCCA_BLOCK, *PHCCA_BLOCK;

// this size is defined in the
// OpenHCI Specification it should always be 256 bytes
C_ASSERT (sizeof(HCCA_BLOCK) == 256);

//
// Host Controller Endpoint Descriptor Control DWORD
//
typedef union _HC_ENDPOINT_CONTROL {
   ULONG                      Control;       // use HcEDControl flags below
   struct {
      ULONG                   FunctionAddress:7;
      ULONG                   EndpointNumber:4;
      ULONG                   Direction:2;   // use HcEDDirection flags below
      ULONG                   LowSpeed:1;
      ULONG                   sKip:1;
      ULONG                   Isochronous:1;
      ULONG                   MaxPacket:11;
      ULONG                   Unused:5;      //available for software use
   };
} HC_ENDPOINT_CONTROL, *PHC_ENDPOINT_CONTROL;

//
// Definitions for HC_ENDPOINT_CONTROL.Control
//
#define HcEDControl_MPS_MASK  0x07FF0000  // Maximum Packet Size field
#define HcEDControl_MPS_SHIFT 16          // Shift Count for MPS
#define HcEDControl_ISOCH     0x00008000  // Bit set for isochronous endpoints
#define HcEDControl_SKIP      0x00004000  // Bit tells hw to skip this endpoint
#define HcEDControl_LOWSPEED  0x00002000  // Bit set if device is a low speed device
#define HcEDControl_DIR_MASK  0x00001800  // Transfer direction field
#define HcEDControl_DIR_DEFER 0x00000000  // Defer direction select to TD (Control Endpoints)
#define HcEDControl_DIR_OUT   0x00000800  // Direction is from host to device
#define HcEDControl_DIR_IN    0x00001000  // Direction is from device to host
#define HcEDControl_EN_MASK   0x00000780  // Endpoint Number field
#define HcEDControl_EN_SHIFT  7           // Shift Count for EN
#define HcEDControl_FA_MASK   0x0000007F  // Function Address field
#define HcEDControl_FA_SHIFT  0           // Shift Count for FA

//
// Definitions for HC_ENDPOINT_CONTROL.Direction
//
#define HcEDDirection_Defer   0           // Defer direction to TD (Control Endpoints)
#define HcEDDirection_Out     1           // Direction from host to device
#define HcEDDirection_In      2           // Direction from device to host

//
// Host Controller Endpoint Descriptor, refer to Section 4.2, Endpoint Descriptor
//

typedef struct _HW_ENDPOINT_DESCRIPTOR {
   HC_ENDPOINT_CONTROL;                    // dword 0
   HW_32BIT_PHYSICAL_ADDRESS      TailP;   //physical pointer to HC_TRANSFER_DESCRIPTOR
   HW_32BIT_PHYSICAL_ADDRESS      HeadP;   //flags + phys ptr to HC_TRANSFER_DESCRIPTOR
   HW_32BIT_PHYSICAL_ADDRESS      NextED;  //phys ptr to HC_ENDPOINT_DESCRIPTOR
} HW_ENDPOINT_DESCRIPTOR, *PHW_ENDPOINT_DESCRIPTOR;

// NOTE: this structure MUST have 16 byte alignment for the hardware
C_ASSERT(sizeof(HW_ENDPOINT_DESCRIPTOR) == 16);

//
// Definitions for HC_ENDPOINT_DESCRIPTOR.HeadP
//
#define HcEDHeadP_FLAGS 0x0000000F  //mask for flags in HeadP
#define HcEDHeadP_HALT  0x00000001  //hardware stopped bit
#define HcEDHeadP_CARRY 0x00000002  //hardware toggle carry bit

//
// HCD Isochronous offset/status words
//
typedef union _HC_OFFSET_PSW {
   struct {
      USHORT      Offset:13;                       // Offset within two pages of packet buffer
      USHORT      Ones:3;                          // should be 111b when in Offset format
   };
   struct {
      USHORT      Size:11;                         // Size of packet received
      USHORT      :1;                              // reserved
      USHORT      ConditionCode:4;                 // use HcCC flags below
   };
   USHORT         PSW;                             // use HcPSW flags below
} HC_OFFSET_PSW, *PHC_OFFSET_PSW;

//
// Definitions for HC_OFFSET_PSW.PSW
//
#define HcPSW_OFFSET_MASK           0x0FFF         // Packet buffer offset field
#define HcPSW_SECOND_PAGE           0x1000         // Is this packet on 2nd page
#define HcPSW_ONES                  0xE000         // The ones for Offset form
#define HcPSW_CONDITION_CODE_MASK   0xF000         // Packet ConditionCode field
#define HcPSW_CONDITION_CODE_SHIFT  12             // shift count for Code
#define HcPSW_RETURN_SIZE           0x07FF         // The size field.

//
// HCD Transfer Descriptor Control DWord
//
typedef union _HC_TRANSFER_CONTROL {
   ULONG                            Control;          // use HcTDControl flags below
   struct _HC_GENERAL_TD_CONTROL{
      ULONG                         :16;              // available for s/w use in GTD
      ULONG                         Isochronous:1;      // should be 0 for GTD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         ShortXferOk:1;    // if set don't report error on short transfer
      ULONG                         Direction:2;      // use HcTDDirection flags below
      ULONG                         IntDelay:3;       // use HcTDIntDelay flags below
      ULONG                         Toggle:2;         // use HcTDToggle flags below
      ULONG                         ErrorCount:2;
      ULONG                         ConditionCode:4;  // use HcCC flags below
   } Asy;
   struct _HC_ISOCHRONOUS_TD_CONTROL{
      ULONG                         StartingFrame:16;
      ULONG                         Isochronous:1;// should be 1 for ITD, s/w flag
      ULONG                         :1;               // available for s/w use
      ULONG                         :3;               // available for s/w use in ITD
      ULONG                         IntDelay:3;       // IntDelay
      ULONG                         FrameCount:3;     // one less than number of frames described in ITD
      ULONG                         :1;               // available for s/w use in ITD
      ULONG                         :4;               // ConditionCode
   } Iso;
} HC_TRANSFER_CONTROL, *PHC_TRANSFER_CONTROL;

//
// Definitions for HC_TRANSFER_CONTROL.Control
//
#define HcTDControl_STARTING_FRAME        0x0000FFFF  // mask for starting frame (Isochronous)
#define HcTDControl_ISOCHRONOUS           0x00010000  // 1 for Isoch TD, 0 for General TD
#define HcTDControl_SHORT_XFER_OK         0x00040000  // 0 if short transfers are errors
#define HcTDControl_DIR_MASK              0x00180000  // Transfer direction field
#define HcTDControl_DIR_SETUP             0x00000000  // direction is setup packet from host to device
#define HcTDControl_DIR_OUT               0x00080000  // direction is from host to device
#define HcTDControl_DIR_IN                0x00100000  // direction is from device to host
#define HcTDControl_INT_DELAY_MASK        0x00E00000  // Interrupt Delay field
#define HcTDControl_INT_DELAY_0_MS        0x00000000  // Interrupt at end of frame TD is completed
#define HcTDControl_INT_DELAY_1_MS        0x00200000  // Interrupt no later than end of 1st frame after TD is completed
#define HcTDControl_INT_DELAY_2_MS        0x00400000  // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDControl_INT_DELAY_3_MS        0x00600000  // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDControl_INT_DELAY_4_MS        0x00800000  // Interrupt no later than end of 4th frame after TD is completed
#define HcTDControl_INT_DELAY_5_MS        0x00A00000  // Interrupt no later than end of 5th frame after TD is completed
#define HcTDControl_INT_DELAY_6_MS        0x00C00000  // Interrupt no later than end of 6th frame after TD is completed

#ifdef NSC
#define HcTDControl_INT_DELAY_NO_INT      0x00C00000  // Almost infinity but not yet quite.
#elif DISABLE_INT_DELAY_NO_INT
#define HcTDControl_INT_DELAY_NO_INT      0x00000000  // Interrupt at the completion of all packets.
#else
#define HcTDControl_INT_DELAY_NO_INT      0x00E00000  // Do not cause an interrupt for normal completion of this TD
#endif

#define HcTDControl_FRAME_COUNT_MASK      0x07000000  // mask for FrameCount field (Isochronous)
#define HcTDControl_FRAME_COUNT_SHIFT     24          // shift count for FrameCount (Isochronous)
#define HcTDControl_FRAME_COUNT_MAX       8           // Max number of for frame count per TD
#define HcTDControl_TOGGLE_MASK           0x03000000  // mask for Toggle control field
#define HcTDControl_TOGGLE_FROM_ED        0x00000000  // get data toggle from CARRY field of ED
#define HcTDControl_TOGGLE_DATA0          0x02000000  // use DATA0 for data PID
#define HcTDControl_TOGGLE_DATA1          0x03000000  // use DATA1 for data PID
#define HcTDControl_ERROR_COUNT           0x0C000000  // mask for Error Count field
#define HcTDControl_CONDITION_CODE_MASK   0xF0000000  // mask for ConditionCode field
#define HcTDControl_CONDITION_CODE_SHIFT  28          // shift count for ConditionCode

//
// Definitions for HC_TRANSFER_CONTROL.Direction
//
#define HcTDDirection_Setup               0           // setup packet from host to device
#define HcTDDirection_Out                 1           // direction from host to device
#define HcTDDirection_In                  2           // direction from device to host

//
// Definitions for Hc_TRANSFER_CONTROL.IntDelay
//
#define HcTDIntDelay_0ms                  0           // interrupt at end of frame TD is completed
#define HcTDIntDelay_1ms                  1           // Interrupt no later than end of 1st frame after TD is completed
#define HcTDIntDelay_2ms                  2           // Interrupt no later than end of 2nd frame after TD is completed
#define HcTDIntDelay_3ms                  3           // Interrupt no later than end of 3rd frame after TD is completed
#define HcTDIntDelay_4ms                  4           // Interrupt no later than end of 4th frame after TD is completed
#define HcTDIntDelay_5ms                  5           // Interrupt no later than end of 5th frame after TD is completed
#define HcTDIntDelay_6ms                  6           // Interrupt no later than end of 6th frame after TD is completed
#define HcTDIntDelay_NoInterrupt          7           // do not generate interrupt for normal completion of this TD

//
// Definitions for HC_TRANSFER_CONTROL.Toggle
//
#define HcTDToggle_FromEd                 0           // get toggle for Endpoint Descriptor toggle CARRY bit
#define HcTDToggle_Data0                  2           // use Data0 PID
#define HcTDToggle_Data1                  3           // use Data1 PID

//
// Definitions for HC_TRANSFER_CONTROL.ConditionCode and HC_OFFSET_PSW.ConditionCode
//
#define HcCC_NoError                      0x0UL
#define HcCC_CRC                          0x1UL
#define HcCC_BitStuffing                  0x2UL
#define HcCC_DataToggleMismatch           0x3UL
#define HcCC_Stall                        0x4UL
#define HcCC_DeviceNotResponding          0x5UL
#define HcCC_PIDCheckFailure              0x6UL
#define HcCC_UnexpectedPID                0x7UL
#define HcCC_DataOverrun                  0x8UL
#define HcCC_DataUnderrun                 0x9UL
      //                                  0xA         // reserved
      //                                  0xB         // reserved
#define HcCC_BufferOverrun                0xCUL
#define HcCC_BufferUnderrun               0xDUL
#define HcCC_NotAccessed                  0xEUL
      //                                  0xF         // this also means NotAccessed

//
// Host Controller Transfer Descriptor, refer to Section 4.3, Transfer Descriptors
//
typedef struct _HW_TRANSFER_DESCRIPTOR {
   HC_TRANSFER_CONTROL;                            // dword 0
   ULONG                            CBP;           // phys ptr to start of buffer
   ULONG                            NextTD;        // phys ptr to HC_TRANSFER_DESCRIPTOR
   ULONG                            BE;            // phys ptr to end of buffer (last byte)
   HC_OFFSET_PSW                    Packet[8];     // isoch & Control packets
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 32));

#include <POPPACK.H>

#endif /* OPENHCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\int.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine
    
Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-19-99 : created, jdunn

--*/

#include "common.h"


BOOLEAN
OHCI_InterruptService (
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG irqStatus, enabledIrqs, tmp;
    
    hc = DeviceData->HC;

    // assume it is not ours
    usbInt = FALSE;

    // see if we have lost the controller due to 
    // a surprise remove
    if (OHCI_HardwarePresent(DeviceData, FALSE) == FALSE) {
        return FALSE;
    }
    
    // get a mask of possible interrupts
    enabledIrqs = READ_REGISTER_ULONG (&hc->HcInterruptEnable);

    irqStatus = READ_REGISTER_ULONG(&hc->HcInterruptStatus);
    // mask off non-enabled irqs
    irqStatus &= enabledIrqs;

    // irqStatus now possibly contains bits set for any currently 
    // enabled interrupts

    if ((irqStatus != 0) &&
        (enabledIrqs & HcInt_MasterInterruptEnable)) { 

        // check for frame number overflow        
        if (irqStatus & HcInt_FrameNumberOverflow) {
            DeviceData->FrameHighPart
                += 0x10000 - (0x8000 & (DeviceData->HcHCCA->HccaFrameNumber
                                    ^ DeviceData->FrameHighPart));
        }

#if DBG
        if (irqStatus & HcInt_UnrecoverableError) {
            // something has gone terribly wrong
            OHCI_KdPrint((DeviceData, 0, "'HcInt_UnrecoverableError! DD(%x)\n",
                DeviceData));
            //DbgBreakPoint();
        }
#endif        

        // indications are that this came from the USB controller
        usbInt = TRUE;

        // disable interrupts until the DPC for ISR runs
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_MasterInterruptEnable);

    }        

    return usbInt;
}       


VOID
OHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    ULONG irqStatus;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG doneQueue, cf;
    
    hc = DeviceData->HC;
    
    irqStatus = READ_REGISTER_ULONG(&hc->HcInterruptStatus); 

    cf = OHCI_Get32BitFrameNumber(DeviceData);
    // what was the reason for the interrupt?
    if (irqStatus & HcInt_RootHubStatusChange) {
        LOGENTRY(DeviceData, G, '_rhS', DeviceData, 0, 0);  
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }

    if (irqStatus & HcInt_WritebackDoneHead) {

        // controller indicates some done TDs
        doneQueue = DeviceData->HcHCCA->HccaDoneHead;
        LOGENTRY(DeviceData, G, '_dnQ', DeviceData, doneQueue, 
            cf);  

        // we will have a problem if we ever actually use the doneQ.
        // Currently we do not use it so the hydra bug where the doneQ
        // is wriiten back as zero won't hurt us.
        //if (doneQueue == 0) {
        //}

        // write the done head back to zero
        DeviceData->HcHCCA->HccaDoneHead = 0;
        LOGENTRY(DeviceData, G, '_dQZ', DeviceData, doneQueue, 0);  
        
//        if (DoneQueue) {
//            OpenHCI_ProcessDoneQueue(deviceData, (DoneQueue & 0xFFFFfffe));
//            //
//            // BUGBUG (?)  No interrupts can come in while processing
//            // the done queue.  Is this bad?  This might take a while.
//            //
//        } 
        // check all endpoints
        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);        
    }

    if (irqStatus & HcInt_StartOfFrame) {
        // got the SOF we requested, disable it
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_StartOfFrame);             
    }

    if (irqStatus & HcInt_ResumeDetected) {
        // got the resume, disable it
        WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                             HcInt_ResumeDetected);             
    }

    if (irqStatus & HcInt_UnrecoverableError) {
        // host controller is dead, try to recover...
        USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerNeedsHwReset);
    }

    // acknowlege the interrupts we processed --
    // we should have proceesed them all
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, irqStatus);

    // see if we need to re-enable ints
    if (EnableInterrupts) {
        // throw the master irq enable to allow more interupts
        WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                             HcInt_MasterInterruptEnable);    
    }                             

}


VOID
OHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                         HcInt_RootHubStatusChange);  
}


VOID
OHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_RootHubStatusChange);
}


ULONG
OHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    )
{
    ULONG hp, fn, n;
    /*
     * This code accounts for the fact that HccaFrameNumber is updated by the
     * HC before the HCD gets an interrupt that will adjust FrameHighPart. No
     * synchronization is nescisary due to great cleaverness. 
     */
    hp = DeviceData->FrameHighPart;
    fn = DeviceData->HcHCCA->HccaFrameNumber;
    n = ((fn & 0x7FFF) | hp) + ((fn ^ hp) & 0x8000);

    return n;
}


VOID
OHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    
    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_StartOfFrame);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\roothub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus 
MINIPORT_RH_GethubStatus 

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "common.h"

VOID
OHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/    
{

    HC_RH_DESCRIPTOR_A descrA;
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    descrA.ul = OHCI_ReadRhDescriptorA(DeviceData);
    OHCI_ASSERT(DeviceData, (descrA.ul) && (!(descrA.ul & HcDescA_RESERVED)));

    HubData->NumberOfPorts = descrA.s.NumberDownstreamPorts;
    DeviceData->NumberOfPorts = HubData->NumberOfPorts;
    HubData->HubCharacteristics.us = (USHORT)descrA.s.HubChars; 
    HubData->PowerOnToPowerGood = descrA.s.PowerOnToPowerGoodTime;    

    // This may upset the stopwatch fanatics, but it appears that a minimum
    // delay is necessary here in some cases.  One example being resuming from
    // hibernation on a 7800 with a USB IntelliMouse Explorer attached.
    // (The delay happens in the hub driver after powering on each port).
    //
    HubData->PowerOnToPowerGood = max(descrA.s.PowerOnToPowerGoodTime, 25);

    // OHCI controllers generally use the 1.0 USB spec.
    // HubChars were revised in 1.1 so we need to do some 
    // mapping.
    // We will assume it is gang switched unless the port 
    // power switching bit is set
    
    HubData->HubCharacteristics.PowerSwitchType = 
            USBPORT_RH_POWER_SWITCH_GANG;
            
    if (descrA.ul & HcDescA_PowerSwitchingModePort) {  
        HubData->HubCharacteristics.PowerSwitchType = 
            USBPORT_RH_POWER_SWITCH_PORT;
    }                

    // this value is the current consumed by the hub 
    // brains, for the embedded hub this doesn't make
    // much sense.
    // so we report zero.
    //
    HubData->HubControlCurrent = 0;
    
}


USB_MINIPORT_STATUS
OHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
     PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnable (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortEnable);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortPower (
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    )
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortPower);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PULONG  pulRegister;
    ULONG   statusAsUlong;
    ULONG   i;

    hc = DeviceData->HC;

    // hw array is zero based
    //
    pulRegister = &hc->HcRhPortStatus[PortNumber-1];

    //
    // by coincedence rhStatus register defined in OHCI is an 
    // exact match of the RH_PORT_STATUS define in the USB core
    // spec.
    //

    // If this register reads as all zero or any of the reserved bits are set
    // then try reading the register again.  This is a workaround for some
    // early revs of the AMD K7 chipset, which can sometimes return bogus values
    // if the root hub registers are read while the host controller is
    // performing PCI bus master ED & TD reads.
    //
    for (i = 0; i < 10; i++)
    {
        statusAsUlong = READ_REGISTER_ULONG(pulRegister);

        if ((statusAsUlong) && (!(statusAsUlong & HcRhPS_RESERVED)))
        {
            break;
        }
        else
        {
            KeStallExecutionProcessor(5);
        }
    }

    portStatus->ul = statusAsUlong;

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortReset);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortSuspend);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortSuspend);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortSuspendStatusChange);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    if (PortNumber == 0) {
        WRITE_REGISTER_ULONG(&hc->HcRhStatus, HcRhS_ClearOverCurrentIndicatorChange);
    } else {
        WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_ClearPortOverCurrentChange);
    }        
    

    return USBMP_STATUS_SUCCESS;
}     



USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortPower);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], HcRhPS_SetPortEnable);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
   
--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearConnectStatusChange);

    return USBMP_STATUS_SUCCESS;
}     


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearPortEnableStatusChange);

    return USBMP_STATUS_SUCCESS;
}  


USB_MINIPORT_STATUS
OHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    ULONG statusAsUlong;
    
    hc = DeviceData->HC;

    // we will never report a localpower change
    HubStatus->LocalPowerLost = 0;
    HubStatus->LocalPowerChange = 0;

    // see if we should reort an overcurrent condition
    // 
    statusAsUlong = 
        READ_REGISTER_ULONG(&hc->HcRhStatus);
    
    HubStatus->OverCurrent = 
        (statusAsUlong & HcRhS_OverCurrentIndicator) ? 1: 0;

    HubStatus->OverCurrentChange = 
        (statusAsUlong & HcRhS_OverCurrentIndicatorChange) ? 1: 0;

    return USBMP_STATUS_SUCCESS;    
}


USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;
    
    WRITE_REGISTER_ULONG(&hc->HcRhPortStatus[PortNumber-1], 
        HcRhPS_ClearPortResetStatusChange);

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\dbg.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/


#include "pch.h"



// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//EHCI_KdPrintX

#if DBG


ULONG
_cdecl
UhciKdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    va_start(list, Format);
    for (i=0; i<6; i++) {
        arg[i] = va_arg(list, int);
    }            
    
    USBPORT_DBGPRINT(
        DeviceData, Level, Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\dbg.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

// write to one of the reserved operational registers
// we use this to trigger the PCI analyzer
#define PCI_TRIGGER(hcOp)  WRITE_REGISTER_ULONG(&(hcOp)->PciTrigger, 0xABADBABE);

// always log
#define DEBUG_LOG


#if DBG

// Triggers a break in the debugger in the registry key
// debugbreakOn is set.  These breakpoins are useful for
// debugging hardware/client software problems
//

#define DEBUG_BREAK(dd)  RegistrationPacket.USBPORTSVC_TestDebugBreak(dd);

//
// This Breakpoint means we either need to test the code path
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
//

#define TEST_TRAP()      {\
                            DbgPrint("<UHCI TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }


#define TRAP_FATAL_ERROR()      {\
                            DbgPrint("<UHCI FATAL_ERROR> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                         }


#define ASSERT_TRANSFER(dd, t) UHCI_ASSERT((dd), (t)->Sig == SIG_UHCI_TRANSFER)

#define ASSERT_TD(dd, t) UHCI_ASSERT((dd), (t)->Sig == SIG_HCD_TD)

ULONG
_cdecl
UhciKdPrintX(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    ...
    );

#define   UhciKdPrint(_x_) UhciKdPrintX _x_

#define UHCI_ASSERT(dd, exp ) \
    if (!(exp)) {\
        RegistrationPacket.USBPORTSVC_AssertFailure( (dd), #exp, __FILE__, __LINE__, NULL );\
    }


#else

// debug macros for retail build

#define TEST_TRAP()
#define DEBUG_BREAK(dd)
#define TRAP_FATAL_ERROR()

#define ASSERT_TRANSFER(dd, t)

#define ASSERT_TD(dd, t)

#define UHCI_ASSERT(dd, exp )

#define   UhciKdPrint(_x_)

#endif /* DBG */

// retail and debug

#ifdef DEBUG_LOG

#define LOGENTRY(dd, mask, sig, info1, info2, info3)  \
    RegistrationPacket.USBPORTSVC_LogEntry( (dd), (mask), (sig), \
        (ULONG_PTR)(info1), (ULONG_PTR)(info2), (ULONG_PTR)(info3) )

#else

#define LOGENTRY(dd, mask, sig, info1, info2, info3)

#endif


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\bios.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    hydramp.c

Abstract:

    USB 2.0 UHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    8-12-2000 : created, jsenior

--*/



#include "pch.h"


//implements the following miniport functions:
//UhciStopBIOS
//UhciStartBIOS


USB_MINIPORT_STATUS
UhciStopBIOS(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    )

/*++

Routine Description:

    This routine steals the USB controller from the BIOS, 
    making sure that it saves all the registers for later.

Arguments:

    DeviceData - DeviceData for this USB controller.
    HcResources - The resources from the pnp start device.

Return Value:

    NT status code.

--*/

{
    USBCMD cmd;
    USBSTS status;
    PHC_REGISTER reg;

    USBSETUP legsup;
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_SUCCESS;
    LARGE_INTEGER startTime;
    ULONG sofModifyValue = 0;
    LARGE_INTEGER finishTime;

    UhciKdPrint((DeviceData, 2, "'Stop Bios.\n"));
    
    UHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_IO_REGS | HCR_IRQ)) != 
        (HCR_IO_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;        
    }

    // set up or device data structure
    reg = DeviceData->Registers = 
        (PHC_REGISTER) (HcResources->DeviceRegisters);

    UhciKdPrint((DeviceData, 2, "'UHCI mapped Operational Regs = %x\n", reg));

    //  Disable PIRQD, NOTE: the Hal should have disabled it for us

    //
    // Disable the PIRQD
    //
    
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
        sizeof(legsup));

#if DBG

    if (legsup & LEGSUP_USBPIRQD_EN) {
        UhciKdPrint((DeviceData, 2, "'PIRQD enabled on StartController (%x)\n", 
            legsup));    
    }
    
#endif

    UhciDisableInterrupts(DeviceData);
    
    //    UhciGetRegistryParameters(DeviceData);

    //
    // Get the SOF modify value. First, retrieve from
    // hardware, then see if we have something in the
    // registry to set it to, then save it away.
    //
/*    sofModifyValue = READ_PORT_UCHAR(&reg->StartOfFrameModify.uc);
    // Grab any SOF ModifyValue indicated in the registry
    // bugbug - todo
//    UHCD_GetSOFRegModifyValue(DeviceObject,
  //                            &sofModifyValue);
    // save the SOF modify for posterity
    DeviceData->BiosStartOfFrameModify.uc = (CHAR) sofModifyValue;
    UHCI_ASSERT(DeviceData, sofModifyValue <= 255);
  */
    
    // IF the host controller is in the global reset state, 
    // clear the bit prior to trying to stop the controller.
    // stop the controller,
    // clear RUN bit and config flag so BIOS won't reinit
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    cmd.GlobalReset = 0;
    cmd.RunStop = 0;
    cmd.ConfigureFlag = 0;
    WRITE_PORT_USHORT(&DeviceData->Registers->UsbCommand.us, cmd.us);

    // NOTE: if no BIOS is present
    // halt bit is initially set with PIIX3
    // halt bit is initially clear with VIA

    // now wait for HC to halt
    // Spec'ed to take 10 ms, so that's what we'll wait for
    KeQuerySystemTime(&finishTime); // get current time
    finishTime.QuadPart += 1000000; 

    KeQuerySystemTime(&startTime);
    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    while (!status.HCHalted) {
        LARGE_INTEGER sysTime;

        status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
        UhciKdPrint((DeviceData, 2, "'STATUS = %x\n", status.us));

        KeQuerySystemTime(&sysTime);
        if (sysTime.QuadPart >= finishTime.QuadPart) {
            // time out
            UhciKdPrint((DeviceData, 0,
                "'TIMEOUT HALTING CONTROLLER! (contact jsenior)\n"));
            TEST_TRAP();
            break;
        }
    }
    
    WRITE_PORT_USHORT(&reg->UsbStatus.us, 0xff);

    // If a legacy bios, disable it. note that PIRQD is disabled
    if ((legsup & LEGSUP_BIOS_MODE) != 0) {

        UhciKdPrint((DeviceData, 0, "'*** uhci detected a USB legacy BIOS ***\n"));
        HcResources->DetectedLegacyBIOS = TRUE;
        
        //
        // if BIOS mode bits set we have to take over
        //

        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
            sizeof(legsup));

        // shut off host controller SMI enable
        legsup = 0x0000;
        USBPORT_WRITE_CONFIG_SPACE(   
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,     // offset of legacy bios reg
            sizeof(legsup));
    }
        
    UhciKdPrint((DeviceData, 2, "'Legacy support reg = 0x%x\n", legsup));

    UhciKdPrint((DeviceData, 2, "'exit UhciStopBIOS 0x%x\n", mpStatus));

    return mpStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\usbohci.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.c

Abstract:

    USB OHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2-19-99 : created, jdunn

--*/

#include "common.h"

//implements the following miniport functions:
//OHCI_InitializeHardware
//OHCI_StartController
//OHCI_StopController
//OHCI_OpenEndpoint
//OHCI_QueryEndpointRequirements
//OHCI_PokeEndpoint

USB_MINIPORT_STATUS
OHCI_InitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
    ULONG reg;
    ULONG sofModifyValue;
    LARGE_INTEGER finishTime, currentTime;

    hc = DeviceData->HC;

    //
    // if we made it here then we now own the HC and can initialize it.
    //

    //
    // Get current frame interval (could account for a known clock error)
    //
    DeviceData->BIOS_Interval.ul = READ_REGISTER_ULONG(&hc->HcFmInterval.ul);

    // If FrameInterval is outside the range of the nominal value of 11999
    // +/- 1% then assume the value is bogus and set it to the nominal value.
    //
    if ((DeviceData->BIOS_Interval.FrameInterval < 11879) ||
        (DeviceData->BIOS_Interval.FrameInterval > 12119)) {
        DeviceData->BIOS_Interval.FrameInterval = 11999; // 0x2EDF
    }

    //
    // Set largest data packet (in case BIOS did not set)
    //
    DeviceData->BIOS_Interval.FSLargestDataPacket =
        ((DeviceData->BIOS_Interval.FrameInterval - MAXIMUM_OVERHEAD) * 6) / 7;
    DeviceData->BIOS_Interval.FrameIntervalToggle ^= 1;

    //
    // do a hardware reset of the controller
    //
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, HcCmd_HostControllerReset);
    //
    // Wait at least 10 microseconds for the reset to complete
    //
    KeStallExecutionProcessor(20);  

    //
    // Take HC to USBReset state, 
    // NOTE: this generates global reset signaling on the bus
    //
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    control.HostControllerFunctionalState = HcCtrl_HCFS_USBReset;
    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);


    //
    // Restore original frame interval, if we have a registry override 
    // value we use it instead.
    //

    // check for a registry based SOF modify Value.
    // if we have one override the BIOS value
    if (DeviceData->Flags & HMP_FLAG_SOF_MODIFY_VALUE) {
        DeviceData->BIOS_Interval.FrameInterval =
            DeviceData->SofModifyValue;
    }            

    // for some reason writing this register does not always take on 
    // the hydra so we loop until it sticks

    KeQuerySystemTime(&finishTime);
    // figure when we quit (.5 seconds later)
    finishTime.QuadPart += 5000000; 
    
    do {
    
        WRITE_REGISTER_ULONG(&hc->HcFmInterval.ul, DeviceData->BIOS_Interval.ul);
        reg = READ_REGISTER_ULONG(&hc->HcFmInterval.ul);

        OHCI_KdPrint((DeviceData, 2, "'fi reg = %x set = %x\n", reg,
            DeviceData->BIOS_Interval.ul));

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {
            // half a second has elapsed ,give up and fail the hardware        
            OHCI_KdPrint((DeviceData, 0, 
                "'frame interval not set\n"));
                
            LOGENTRY(DeviceData, G, '_fr!', 0, 0, 0);
            return USBMP_STATUS_HARDWARE_FAILURE;
        }            

    } while (reg != DeviceData->BIOS_Interval.ul);

    OHCI_KdPrint((DeviceData, 2, "'fi = %x\n", DeviceData->BIOS_Interval.ul));

    //
    // Set the HcPeriodicStart register to 90% of the FrameInterval
    //
    WRITE_REGISTER_ULONG(&hc->HcPeriodicStart,
                         (DeviceData->BIOS_Interval.FrameInterval * 9 + 5)
                         / 10);

    // set the ptr to the HCCA
    WRITE_REGISTER_ULONG(&hc->HcHCCA, DeviceData->HcHCCAPhys);
                         
    //
    // Enable interrupts, this will not cause the controller 
    // to generate any because master-enable is not set yet.
    //
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_UnrecoverableError);
                         
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_StopBIOS(
    PDEVICE_DATA DeviceData,
    PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    ULONG hcControl;

    hc = DeviceData->HC;

    //
    // Check to see if a System Management Mode driver owns the HC
    //
    
    hcControl = READ_REGISTER_ULONG(&hc->HcControl.ul);

    if (hcControl & HcCtrl_InterruptRouting) {
    
        OHCI_KdPrint((DeviceData, 1, "'detected Legacy BIOS\n"));

        HcResources->DetectedLegacyBIOS = TRUE;

        if ((hcControl == HcCtrl_InterruptRouting) &&
            (READ_REGISTER_ULONG(&hc->HcInterruptEnable) == 0)) {
        
            // Major assumption:  If HcCtrl_InterruptRouting is set but
            // no other bits in HcControl are set, i.e. HCFS==UsbReset,
            // and no interrupts are enabled, then assume that the BIOS
            // is not actually using the host controller.  In this case
            // just clear the erroneously set HcCtrl_InterruptRouting.
            //
            // This assumption appears to be correct on a Portege 3010CT,
            // where HcCtrl_InterruptRouting is set during a Resume from
            // Standby, but the BIOS doesn't actually appear to be using
            // the host controller.  If we were to continue on and set
            // HcCmd_OwnershipChangeRequest, the BIOS appears to wake up
            // and try to take ownership of the host controller instead of
            // giving it up.
            //

            OHCI_KdPrint((DeviceData, 0, 
                "'HcCtrl_InterruptRouting erroneously set\n"));

            WRITE_REGISTER_ULONG(&hc->HcControl.ul, 0);
            
        } else {
        
            LARGE_INTEGER finishTime, currentTime;
            
            //
            // A SMM driver does own the HC, it will take some time to
            // get the SMM driver to relinquish control of the HC.  We
            // will ping the SMM driver, and then wait repeatedly until
            // the SMM driver has relinquished control of the HC.
            //
            // THIS CODE ONLY WORKS IF WE ARE EXECUTING IN THE CONTEXT
            // OF A SYSTEM THREAD.
            //

            // The HAL has disabled interrupts on the HC.  Since
            // interruptrouting is set we assume there is a functional 
            // smm BIOS.  The BIOS will need the master interrupt 
            // enabled to complete the handoff (if it is disabled the 
            // machine will hang).  So we re-enable the master interrupt 
            // here.

            WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                                 HcInt_MasterInterruptEnable);

            WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul,
                                 HcCmd_OwnershipChangeRequest);

            // hack for NEC -- disable the root hub status change 
            // to prevent an unhandled interrupt from being asserted
            // after handoff
            WRITE_REGISTER_ULONG(&hc->HcInterruptDisable,
                                 HcInt_RootHubStatusChange);                                 
// bugbug expose with service
            KeQuerySystemTime(&finishTime);
            // figure when we quit (.5 seconds later)
            finishTime.QuadPart += 5000000; 

            //
            // We told the SMM driver we want the HC, now all we can do is wait
            // for the SMM driver to be done with the HC.
            //
            while (READ_REGISTER_ULONG(&hc->HcControl.ul) &
                   HcCtrl_InterruptRouting) {
                   
                KeQuerySystemTime(&currentTime);

                if (currentTime.QuadPart >= finishTime.QuadPart) {
                
                    OHCI_KdPrint((DeviceData, 0, 
                        "'SMM has not relinquised HC -- this is a HW bug\n"));

                    LOGENTRY(DeviceData, G, '_sm!', 0, 0, 0);
                    return USBMP_STATUS_HARDWARE_FAILURE;
                }
            }

            // we have control, disable master interrupt until we 
            // finish intializing
            WRITE_REGISTER_ULONG(&hc->HcInterruptStatus,
                                 0xffffffff);

            WRITE_REGISTER_ULONG(&hc->HcInterruptDisable,
                                 HcInt_MasterInterruptEnable);

        }
    }
    
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
OHCI_InitializeSchedule(
     PDEVICE_DATA DeviceData,
     PUCHAR StaticEDs,
     HW_32BIT_PHYSICAL_ADDRESS StaticEDsPhys,
     PUCHAR EndCommonBuffer
    )
/*++

Routine Description:

    Build the schedule of static Eds 

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHC_OPERATIONAL_REGISTER hc;
    
    //
    // Allocate staticly disabled EDs, and set head pointers for 
    // scheduling lists
    //
    // The static ED list is contains all the static interrupt EDs (64)
    // plus the static ED for bulk and control (2)
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,
    // CONTROL
    // BULK

    // each static ED points to another static ED 
    // (except for the 1ms ed) the INDEX of the next 
    // ED in the StaticEDList is stored in NextIdx,
    // these values are constent
    CHAR nextIdxTable[63] = {
             // 0  1  2  3  4  5  6  7
     (CHAR)ED_EOF, 0, 0, 1, 1, 2, 2, 3, 
             // 8  9 10 11 12 13 14 15
                3, 4, 4, 5, 5, 6, 6, 7, 
             //16 17 18 19 20 21 22 23               
                7, 8, 8, 9, 9,10,10,11,
             //24 25 26 27 28 29 30 31                 
               11,12,12,13,13,14,14,15,
             //32 33 34 35 36 37 38 39  
               15,16,16,17,17,18,18,19,
             //40 41 42 43 44 45 46 47   
               19,20,20,21,21,22,22,23,
             //48 49 50 51 52 53 54 55               
               23,24,24,25,25,26,26,27,
             //56 57 58 59 60 61 62 63               
               27,28,28,29,29,30,30
    };             

/*
    Numbers are the index into the static ed table

    (31) -\ 
          (15)-\
    (32) -/     \
                (7 )-\
    (33) -\     /     \
          (16)-/       \
    (34) -/             \
                        (3)-\
    (35) -\             /    \
          (17)-\       /      \
    (36) -/     \     /        \
                (8 )-/          \
    (37) -\     /                \
          (18)-/                  \  
    (38) -/                        \
                                   (1)-\
    (39) -\                        /    \
          (19)-\                  /      \
    (40) -/     \                /        \
                (9 )-\          /          \
    (41) -\     /     \        /            \
          (20)-/       \      /              \
    (42) -/             \    /                \
                        (4)-/                  \
    (43) -\             /                       \
          (21)-\       /                         \
    (44) -/     \     /                           \
                (10)-/                             \
    (45) -\     /                                   \ 
          (22)-/                                     \
    (46) -/                                           \
                                                      (0)                          
    (47) -\                                           /
          (23)-\                                     /
    (48) -/     \                                   /
                (11)-\                             /
    (49) -\     /     \                           /
          (24)-/       \                         /
    (50) -/             \                       /
                        (5)-\                  /
    (51) -\             /    \                /
          (25)-\       /      \              /
    (52) -/     \     /        \            /
                (12)-/          \          /
    (53) -\     /                \        /
          (26)-/                  \      /
    (54) -/                        \    /
                                   (2)-/
    (55) -\                        /
          (27)-\                  /
    (56) -/     \                /
                (13)-\          /
    (57) -\     /     \        /
          (28)-/       \      /
    (58) -/             \    /   
                        (6)-/
    (59) -\             /
          (29)-\       /
    (60) -/     \     /
                (14)-/
    (61) -\     /
          (30)-/
    (62) -/
*/

    // corresponding offsets for the 32ms list heads in the 
    // HCCA -- these are entries 31..62
    ULONG used = 0;
    CHAR Hcca32msOffsets[32] = {
                 0, 16,  8, 24,  4, 20, 12, 28, 
                 2, 18, 10, 26,  6, 22, 14, 30,  
                 1, 17,  9, 25,  5, 21, 13, 29,  
                 3, 19, 11, 27,  7, 23, 15, 31
                 };            

    DeviceData->StaticEDs = StaticEDs;
    DeviceData->StaticEDsPhys = StaticEDsPhys;

    hc = DeviceData->HC;
    
    // initailze all interrupt EDs

    for (i=0; i<ED_CONTROL; i++) {
        CHAR n;
        PHW_ENDPOINT_DESCRIPTOR hwED;
        
        //
        // Carve EDs from the common buffer 
        //
        hwED = (PHW_ENDPOINT_DESCRIPTOR) StaticEDs;
        n = nextIdxTable[i];
        
        // initialize the hardware ED
        hwED->TailP = hwED->HeadP = 0xDEAD0000;
        //hwED->TailP = hwED->HeadP = StaticEDsPhys;
        hwED->Control = HcEDControl_SKIP;   // ED is disabled
        
        LOGENTRY(DeviceData, G, '_isc', n, &DeviceData->StaticEDList[0], 0);
     
        if (n == (CHAR)ED_EOF) {
            hwED->NextED = 0;
        } else {
            OHCI_ASSERT(DeviceData, n>=0 && n<31);
            hwED->NextED = DeviceData->StaticEDList[n].HwEDPhys;
        }                

        // initailze the list we use for real EDs
        InitializeListHead(&DeviceData->StaticEDList[i].TransferEdList);
        DeviceData->StaticEDList[i].HwED = hwED;
        DeviceData->StaticEDList[i].HwEDPhys = StaticEDsPhys; 
        DeviceData->StaticEDList[i].NextIdx = n;
        DeviceData->StaticEDList[i].EdFlags = EDFLAG_INTERRUPT;
        
          // store address of hcc table entry
        DeviceData->StaticEDList[i].PhysicalHead = 
            &hwED->NextED;

        // next ED
        StaticEDs += sizeof(HW_ENDPOINT_DESCRIPTOR);
        StaticEDsPhys += sizeof(HW_ENDPOINT_DESCRIPTOR);
    }

    // now set the head pointers in the HCCA
    // the HCCA points to all the 32ms list heads
    for (i=0; i<32; i++) {
    
        ULONG hccaOffset;

        hccaOffset = Hcca32msOffsets[i];
        
        DeviceData->HcHCCA->HccaInterruptTable[hccaOffset] = 
            DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].HwEDPhys;
        DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].HccaOffset = 
            hccaOffset;    

        // physical head for 32ms list point to HCCA
        DeviceData->StaticEDList[i+ED_INTERRUPT_32ms].PhysicalHead = 
            &DeviceData->HcHCCA->HccaInterruptTable[hccaOffset];
            
    }

    //
    // Setup EDList entries for Control & Bulk
    //
    InitializeListHead(&DeviceData->StaticEDList[ED_CONTROL].TransferEdList);
    DeviceData->StaticEDList[ED_CONTROL].NextIdx = (CHAR) ED_EOF;
    DeviceData->StaticEDList[ED_CONTROL].PhysicalHead = &hc->HcControlHeadED;
    DeviceData->StaticEDList[ED_CONTROL].EdFlags = EDFLAG_CONTROL | EDFLAG_REGISTER;
        
    InitializeListHead(&DeviceData->StaticEDList[ED_BULK].TransferEdList);
    DeviceData->StaticEDList[ED_BULK].NextIdx = (CHAR) ED_EOF;
    DeviceData->StaticEDList[ED_BULK].PhysicalHead = &hc->HcBulkHeadED;
    DeviceData->StaticEDList[ED_BULK].EdFlags = EDFLAG_BULK | EDFLAG_REGISTER;

    if (DeviceData->ControllerFlavor == OHCI_Hydra) {
        used = InitializeHydraHsLsFix(DeviceData, StaticEDs, StaticEDsPhys);
    }        

    StaticEDs += used;
    StaticEDsPhys += used;

    OHCI_ASSERT(DeviceData, StaticEDs <= EndCommonBuffer);
    
    mpStatus = USBMP_STATUS_SUCCESS;
    
    return mpStatus;
}


VOID
OHCI_GetRegistryParameters(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    sets the registry based sof modify value

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG clocksPerFrame;
    
    // get SOF modify value from registry
    mpStatus = 
        USBPORT_GET_REGISTRY_KEY_VALUE(DeviceData,
                                       TRUE, // software branch
                                       SOF_MODIFY_KEY, 
                                       sizeof(SOF_MODIFY_KEY), 
                                       &clocksPerFrame, 
                                       sizeof(clocksPerFrame));

    // if this call fails we just use the default
    
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        SET_FLAG(DeviceData->Flags, HMP_FLAG_SOF_MODIFY_VALUE);
        DeviceData->SofModifyValue = clocksPerFrame;   
        OHCI_KdPrint((DeviceData, 1, "'Recommended Clocks/Frame %d \n", 
                clocksPerFrame));
   
    }
    
}


VOID
USBMPFN
OHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HC_CONTROL control;
    PHC_OPERATIONAL_REGISTER hc = NULL;
    
    hc = DeviceData->HC;

    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    
    control.ul &= ~(HcCtrl_PeriodicListEnable |
                    HcCtrl_IsochronousEnable |
                    HcCtrl_ControlListEnable |
                    HcCtrl_BulkListEnable |
                    HcCtrl_RemoteWakeupEnable);
                    
    control.HostControllerFunctionalState =
        HcHCFS_USBSuspend;
        
    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 0xFFFFffff);
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, 0xFFFFffff);

}


USB_MINIPORT_STATUS
USBMPFN
OHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    PHC_OPERATIONAL_REGISTER hc = NULL;
    PUCHAR endCommonBuffer;

    OHCI_KdPrint((DeviceData, 1, "'OPENHCI Miniport\n"));

    // clear the suspend flag in case this is a restart
    CLEAR_FLAG(DeviceData->Flags, HMP_FLAG_SUSPENDED);    
    // assume success
    mpStatus = USBMP_STATUS_SUCCESS;
    
    OHCI_ASSERT(DeviceData, HcResources->CommonBufferVa != NULL);
    // validate our resources
    if ((HcResources->Flags & (HCR_MEM_REGS | HCR_IRQ)) != 
        (HCR_MEM_REGS | HCR_IRQ)) {
        mpStatus = USBMP_STATUS_INIT_FAILURE;        
    }

    // set up or device data structure
    hc = DeviceData->HC = HcResources->DeviceRegisters;
    DeviceData->Sig = SIG_OHCI_DD;
    DeviceData->ControllerFlavor = 
        HcResources->ControllerFlavor;
    if (DeviceData->ControllerFlavor == OHCI_Hydra) {
        OHCI_KdPrint((DeviceData, 1, "'OPENHCI Hydra Detected\n"));
    }

    OHCI_GetRegistryParameters(DeviceData);

    // init misc fields in the extension

    // attempt to stop the BIOS
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        mpStatus = OHCI_StopBIOS(DeviceData, HcResources);
    }        

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        PUCHAR staticEDs;
        HW_32BIT_PHYSICAL_ADDRESS staticEDsPhys;

        // carve the common buffer block in to HCCA and
        // static EDs
        //
        // set the HCCA and
        // set up the schedule

        DeviceData->HcHCCA = (PHCCA_BLOCK)
            HcResources->CommonBufferVa;
        DeviceData->HcHCCAPhys = 
            HcResources->CommonBufferPhys; 
        endCommonBuffer = HcResources->CommonBufferVa + 
            OHCI_COMMON_BUFFER_SIZE;
            
            
        staticEDs = HcResources->CommonBufferVa + sizeof(HCCA_BLOCK);
        staticEDsPhys = HcResources->CommonBufferPhys + sizeof(HCCA_BLOCK);                
        mpStatus = OHCI_InitializeSchedule(DeviceData,
                                              staticEDs,
                                              staticEDsPhys,
                                              endCommonBuffer);            

    } 
    
    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller 
        mpStatus = OHCI_InitializeHardware(DeviceData);
    }      

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        HC_CONTROL control;

        // When the HC is in the operational state, HccaPad1 should be set to
        // zero every time the HC updates HccaFrameNumer.  Preset HccaPad1 to
        // zero before entering the operational state.  OHCI_CheckController()
        // should always find a zero value in HccaPad1 when the HC is in the
        // operational state.
        // 
        DeviceData->HcHCCA->HccaPad1 = 0;

        // activate the controller
        control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
        control.HostControllerFunctionalState = HcHCFS_USBOperational;
        // enable control and bulk interrupt and iso we only disable 
        // them if we need to remove ED or if the controller 
        // is idle.
        control.ControlListEnable = 1;
        control.BulkListEnable = 1;
        control.PeriodicListEnable = 1;
        control.IsochronousEnable = 1;
        
        WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

        // enable power for the root hub
        // since messing with the 'operatinal state' messes
        // up the root hub we the do the global power set here
        WRITE_REGISTER_ULONG(&hc->HcRhStatus, HcRhS_SetGlobalPower);

    } else {
        
        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}


VOID
USBMPFN
OHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc = NULL;

    // set up or device data structure
    hc = DeviceData->HC;
        
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 
                         HcInt_MasterInterruptEnable);
}


VOID
USBMPFN
OHCI_FlushInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //nop
}

VOID
USBMPFN
OHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc = NULL;

    // set up or device data structure
    hc = DeviceData->HC;

    // activate the controllers interrupt
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable, 
                         HcInt_MasterInterruptEnable);

}


VOID
OHCI_InsertEndpointInSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Insert an endpoint into the h/w schedule

Arguments:


--*/
{
    PHC_STATIC_ED_DATA staticEd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    
    staticEd = EndpointData->StaticEd;
    ed = EndpointData->HcdEd;
    
    //
    // Link endpoint descriptor into HCD tracking queue
    //
    // each static ED stucture conatins a list of real
    // EDs (that are for transfers)
    //
    // the HW list is linear with :
    // TransferHwED->TransferHwED->0

    if (IsListEmpty(&staticEd->TransferEdList)) {

        //
        // list is currently empty,
        // link it to the head of the hw queue
        //

        InsertHeadList(&staticEd->TransferEdList, &ed->SwLink.List);
        if (staticEd->EdFlags & EDFLAG_REGISTER) {

            // control and bulk EDs are linked thru a hw register
            // in the hc
            // 
            // the HW list is linear with :
            // TransferHwED->TransferHwED->0
            //
            // update the hardware register that points to the list head

            LOGENTRY(DeviceData, G, '_IN1', 0, ed, staticEd);
            // next points to static head
            ed->HwED.NextED = READ_REGISTER_ULONG(staticEd->PhysicalHead);
            // new head is this ed
            WRITE_REGISTER_ULONG(staticEd->PhysicalHead, ed->PhysicalAddress);
            
        } else {

            // for interrupt we have two cases
            //
            // case 1:
            // 32ms interrupt, PhysicalHead is the address of the entry
            // in the HCCA that points to the first 32 ms list 
            // (ie &HCCA[n] == physicalHead),
            // so we end up with:
            // HCCA[n]->TransferHwED->TransferHwED->StaticEd(32)->
            //
            // case 2:
            // not 32ms interrupt, PhysicaHead is the address of the 
            // NextED entry in the static HwED for the list list,  
            // (ie &HwED->nextEd == physicalHead)
            // so we end up with
            // StaticEd->TransferHwED->TransferHwED->NextStaticED
            //
            
                        
            LOGENTRY(DeviceData, G, '_IN2', staticEd->PhysicalHead, 
                ed, staticEd);
            // tail points to old list head HW ed head
            ed->HwED.NextED = *staticEd->PhysicalHead;
            // new head is this ed
            *staticEd->PhysicalHead = ed->PhysicalAddress;
        }
    } else {
    
        PHCD_ENDPOINT_DESCRIPTOR tailEd;
        
        //
        // Something already on the list,
        // Link ED into tail of transferEd list
        //
        
        tailEd = CONTAINING_RECORD(staticEd->TransferEdList.Blink,
                                   HCD_ENDPOINT_DESCRIPTOR,
                                   SwLink);
                                  
        LOGENTRY(DeviceData, G, '_Led', 0, tailEd, staticEd);
        //LOGENTRY(G, 'INT1', list, ed, 0);
        InsertTailList(&staticEd->TransferEdList, &ed->SwLink.List);
        ed->HwED.NextED = 0;
        tailEd->HwED.NextED = ed->PhysicalAddress;
    }
}


VOID
OHCI_RemoveEndpointFromSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

   Remove an endpoint from the h/w schedule

Arguments:


--*/
{
    PHC_STATIC_ED_DATA staticEd;
    PHCD_ENDPOINT_DESCRIPTOR ed, previousEd;

    staticEd = EndpointData->StaticEd;
    ed = EndpointData->HcdEd;
    OHCI_ASSERT_ED(DeviceData, ed);

    LOGENTRY(DeviceData, G, '_Red', EndpointData, staticEd, 0);

    // Unlink the ED from the physical ED list 
    
    // two cases:
    
    if (&staticEd->TransferEdList == ed->SwLink.List.Blink) {
    // case 1, we are at the head of the list
        // make the next guy the head
        LOGENTRY(DeviceData, G, '_yHD', EndpointData, 0, 0);
        if (ed->EdFlags & EDFLAG_REGISTER) {
            WRITE_REGISTER_ULONG(staticEd->PhysicalHead, ed->HwED.NextED);
        } else {
            *staticEd->PhysicalHead = ed->HwED.NextED;
        }
    } else {
    // case 2 we are not at the head
        // use the sw link to get the previus ed
        previousEd =
            CONTAINING_RECORD(ed->SwLink.List.Blink,
                              HCD_ENDPOINT_DESCRIPTOR,
                              SwLink);
        LOGENTRY(DeviceData, G, '_nHD', EndpointData, previousEd, 0);
        OHCI_ASSERT_ED(DeviceData, previousEd); 

        previousEd->HwED.NextED = ed->HwED.NextED;

    }
    // remove ourselves from the software list
    RemoveEntryList(&ed->SwLink.List); 
    // on no list
    EndpointData->StaticEd = NULL;
    
}    


PHCD_ENDPOINT_DESCRIPTOR
OHCI_InitializeED(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_ENDPOINT_DESCRIPTOR Ed,
     PHCD_TRANSFER_DESCRIPTOR DummyTd,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for inserting in to the 
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{

    RtlZeroMemory(Ed, sizeof(*Ed));
    
    Ed->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Ed->EndpointData) = EndpointData;
    Ed->Sig = SIG_HCD_ED;

    // init the hw descriptor
    Ed->HwED.FunctionAddress = EndpointData->Parameters.DeviceAddress;
    Ed->HwED.EndpointNumber = EndpointData->Parameters.EndpointAddress;

    if (EndpointData->Parameters.TransferType == Control) {
        Ed->HwED.Direction = HcEDDirection_Defer;   
    } else if (EndpointData->Parameters.TransferDirection == In) {
        Ed->HwED.Direction = HcEDDirection_In;
    } else {
        Ed->HwED.Direction = HcEDDirection_Out;
    }
    
    Ed->HwED.sKip = 1;

    if (EndpointData->Parameters.DeviceSpeed == LowSpeed) {
        Ed->HwED.LowSpeed = 1;
    } 
    
    if (EndpointData->Parameters.TransferType == Isochronous) {
        Ed->HwED.Isochronous = 1;
    } 
    Ed->HwED.MaxPacket = EndpointData->Parameters.MaxPacketSize;

    // set head tail ptr to point to the dummy TD
    Ed->HwED.TailP = Ed->HwED.HeadP = DummyTd->PhysicalAddress;
    SET_FLAG(DummyTd->Flags, TD_FLAG_BUSY);
    EndpointData->HcdHeadP = EndpointData->HcdTailP = DummyTd;

    return Ed;
}


PHCD_TRANSFER_DESCRIPTOR
OHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    )
/*++

Routine Description:

   Initialize an ED for insertin in to the 
   schedule

   returns a ptr to the ED passed in

Arguments:


--*/
{
    RtlZeroMemory(Td, sizeof(*Td));
    
    Td->PhysicalAddress = HwPhysAddress;
    ENDPOINT_DATA_PTR(Td->EndpointData) = EndpointData;
    Td->Flags = 0;
    Td->Sig = SIG_HCD_TD;
    TRANSFER_CONTEXT_PTR(Td->TransferContext) = FREE_TD_CONTEXT;

    return Td;
}


USB_MINIPORT_STATUS
OHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    
    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;
    InitializeListHead(&EndpointData->DoneTdList);
     
    switch (EndpointParameters->TransferType) {
    
    case Control:
        mpStatus = OHCI_OpenControlEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
            
        break;
        
    case Interrupt:
        mpStatus = OHCI_OpenInterruptEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
                
        break;
    case Bulk:
        mpStatus = OHCI_OpenBulkEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
                
        break;        
    case Isochronous:
        mpStatus = OHCI_OpenIsoEndpoint(
                DeviceData,
                EndpointParameters,
                EndpointData);
        
        break;
        
    default:
        mpStatus = USBMP_STATUS_NOT_SUPPORTED;
    }

    return mpStatus;
}


USB_MINIPORT_STATUS
OHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData, 
        EndpointParameters, 0);
    
    ed = EndpointData->HcdEd;

    oldBandwidth = EndpointData->Parameters.Bandwidth;
    EndpointData->Parameters = *EndpointParameters;
    
    ed->HwED.FunctionAddress = 
        EndpointData->Parameters.DeviceAddress; 
        
    ed->HwED.MaxPacket = 
        EndpointData->Parameters.MaxPacketSize;

    // adjust bw if necessary
    if (EndpointData->Parameters.TransferType == Isochronous ||
        EndpointData->Parameters.TransferType == Interrupt) {

        // subtract the old bandwidth
        EndpointData->StaticEd->AllocatedBandwidth -= 
            oldBandwidth;
        // add on new bw            
        EndpointData->StaticEd->AllocatedBandwidth += 
            EndpointData->Parameters.Bandwidth;
    }           

    return USBMP_STATUS_SUCCESS;
}


VOID
OHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need 
    for this endpoint

Arguments:

Return Value:

--*/
{


    switch (EndpointParameters->TransferType) {
    
    case Control:
    
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_CONTROL_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize = 
            MAX_CONTROL_TRANSFER_SIZE;

        break;
        
    case Interrupt:
    
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_INTERRUPT_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

#ifdef TEST_SPLIT
        EndpointRequirements->MaximumTransferSize = 
            EndpointParameters->MaxPacketSize;

#else 
        EndpointRequirements->MaximumTransferSize = 
            MAX_INTERRUPT_TRANSFER_SIZE; 
#endif
        break;
        
    case Bulk:
        
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_BULK_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);
#ifdef TEST_SPLIT
        EndpointRequirements->MaximumTransferSize = 4096;

#else 
        EndpointRequirements->MaximumTransferSize = 
            MAX_BULK_TRANSFER_SIZE; 
#endif
        break;

    case Isochronous:

        // BUGBUG NOTE
        // the 1.1 USBDI caped requests at 255 packets per urb 
        EndpointRequirements->MinCommonBufferBytes = 
            sizeof(HCD_ENDPOINT_DESCRIPTOR) + 
                TDS_PER_ISO_ENDPOINT*sizeof(HCD_TRANSFER_DESCRIPTOR);

        EndpointRequirements->MaximumTransferSize = 
            MAX_ISO_TRANSFER_SIZE; 

        break;        
        
    default:
        TEST_TRAP();
    }
    
}


VOID
OHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing to do here
}


VOID
OHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) { 
    case Control:
    case Interrupt:
    case Bulk:    
        OHCI_PollAsyncEndpoint(DeviceData, EndpointData);
        break;
    case Isochronous:
        OHCI_PollIsoEndpoint(DeviceData, EndpointData);
        break;
    }        
    
}


VOID
OHCI_PollController(
     PDEVICE_DATA DeviceData
    )     
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    BOOLEAN hcOk = TRUE;
    PHC_OPERATIONAL_REGISTER hc;
    ULONG irqStatus;
    
    hc = DeviceData->HC;
    
    if (TEST_FLAG(DeviceData->Flags, HMP_FLAG_SUSPENDED)) {

        ULONG ps;
        ULONG p;
        
        // indicates polling while controller is 
        // suspended but in D0
        //
        // should invalidate the root hub only if changes 
        // are detected on the root ports.            

        //
        // check all the ports
        //
    
        for (p=0; p< DeviceData->NumberOfPorts; p++) {
            ps = READ_REGISTER_ULONG(&hc->HcRhPortStatus[p]);
            
            if (ps & HcRhPS_ConnectStatusChange) {
                //TEST_TRAP();
                LOGENTRY(DeviceData, G, '_rPS', DeviceData, 0, 0);  
                USBPORT_INVALIDATE_ROOTHUB(DeviceData);
                break;
            }
        }
        
        return;
    }
    
#if 0
    // see if the controller is still operating

    fn = DeviceData->HcHCCA->HccaFrameNumber;
    if (DeviceData->LastFn && DeviceData->LastFn == fn) {
        hcOk = FALSE;
    } 

    if (hcOK) {
        DeviceData->LastFn = fn;
    } else {
        OHCI_KdPrint((DeviceData, 0, "Controller has crashed\n");
        // bugbug, signal USBPORT to attempt recovery
        TEST_TRAP();
    }
#endif    
}


VOID
OHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT AbortTransferContext,
     PULONG BytesTransferred
    )
/*++

Routine Description:

    Called when a transfer needs to be removed 
    from the schedule.

    This process is vertually identical regardless 
    of transfer type

Arguments:

Return Value:

--*/

{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd, tmpTd;
    PHCD_ENDPOINT_DESCRIPTOR ed;
    ULONG i;
    BOOLEAN found = FALSE;
    BOOLEAN iso = FALSE; // assume its async

    if (EndpointData->Parameters.TransferType == Isochronous) {
        iso = TRUE;
    }
    
    ed = EndpointData->HcdEd;

    //
    //  The endpoint should have the skip bit set 
    //  ie 'paused'
    //
    OHCI_ASSERT(DeviceData, ed->HwED.sKip == 1);
    
    LOGENTRY(DeviceData, G, '_abr', ed, AbortTransferContext, 
        EndpointData);        

    // one less pending transfer
    EndpointData->PendingTransfers--;

    // our mission now is to remove all TDs associated with 
    // this transfer

    // get the 'currentTD' 
    currentTd = (PHCD_TRANSFER_DESCRIPTOR)
            USBPORT_PHYSICAL_TO_VIRTUAL(ed->HwED.HeadP & ~HcEDHeadP_FLAGS,
                                        DeviceData,
                                        EndpointData);

    // we have three possible cases to deal with:
    // case 1: the transfer is current, headp points to a TD 
    //            associated with this transfer
    // case 2: transfer is already done, we just need to free 
    //            the TDs  
    // case 3: transfer is not processed, we need to link
    //            the current transfer to the next.
    

    if (TRANSFER_CONTEXT_PTR(currentTd->TransferContext)
        == AbortTransferContext) {
    
        LOGENTRY(DeviceData, G, '_aCU', currentTd, 
            0, 0);                 
    
        // case 1: transfer is current 
      
        found = TRUE;

        // set Headp to next transfer and update sw pointers in ED 
        tmpTd = AbortTransferContext->NextXferTd;
        // preserve the data toggle for whatever the transfer 
        ed->HwED.HeadP = tmpTd->PhysicalAddress | 
            (ed->HwED.HeadP & HcEDHeadP_CARRY);
        EndpointData->HcdHeadP = tmpTd;

        // loop thru all TDs and free the ones for this tarnsfer
        for (i=0; i<EndpointData->TdCount; i++) {
           tmpTd = &EndpointData->TdList->Td[i];

            if (TRANSFER_CONTEXT_PTR(tmpTd->TransferContext)
                == AbortTransferContext) {
                if (iso) {
                    OHCI_ProcessDoneIsoTd(DeviceData,
                                          tmpTd,
                                          FALSE);
                } else {
                    OHCI_ProcessDoneAsyncTd(DeviceData,
                                            tmpTd,
                                            FALSE);
                }
            }                    
        }            
        
    } else {

        // not current, walk the the list of TDs from the 
        // last known HeadP to the current TD if we find it 
        // it is already done (case 2).

        // Issue to investigate:  What if we find some TDs which belong to
        // this transfer but we stop walking the TD list when we hit currentTd
        // and there are still TDs queued which belong to this transfer?  If
        // they stay stuck on the HW and the transfer is freed that would be
        // bad.

        td = EndpointData->HcdHeadP;
        while (td != currentTd) {
        
            PTRANSFER_CONTEXT transfer;    
            
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        

            if (transfer == AbortTransferContext) {
                // case 2 the transfer TDs have already
                // been comlpleted by the hardware
                found = TRUE;

                LOGENTRY(DeviceData, G, '_aDN', currentTd, 
                    td, 0);    

                // free this TD
                tmpTd = td;
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

                // if this TD was the head we need to bump the
                // headp
                if (tmpTd == EndpointData->HcdHeadP) {
                    EndpointData->HcdHeadP = td;
                }

                if (iso) {
                    OHCI_ProcessDoneIsoTd(DeviceData,
                                          tmpTd,
                                          FALSE);
                } else {
                    OHCI_ProcessDoneAsyncTd(DeviceData,
                                            tmpTd,
                                            FALSE);
                }
                
            } else {
            
                // we walk the SW links
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }    
        }           
    }

    if (!found) {
    
        PHCD_TRANSFER_DESCRIPTOR firstTd, lastTd;
        PTRANSFER_CONTEXT prevTransfer;
        
        // case 3 the transfer is not current and not done. 
        // 1. we need to find it.
        // 2. unlink it from the prevoius transfer
        // 3. free the TDs
        // 4. link prev transfer to the next

        
        
        td = EndpointData->HcdHeadP;
        firstTd = NULL;

        LOGENTRY(DeviceData, G, '_abP', EndpointData->HcdHeadP, 
                    EndpointData->HcdTailP, currentTd);    

        // start at the current HeadP and find the first 
        // td for this transfer

        lastTd = td;
        while (td != EndpointData->HcdTailP) {
            PTRANSFER_CONTEXT transfer;
            
            transfer = TRANSFER_CONTEXT_PTR(td->TransferContext);        
            ASSERT_TRANSFER(DeviceData, transfer);                        
            
            if (transfer == AbortTransferContext) {
                // found it 
                LOGENTRY(DeviceData, G, '_fnT', transfer, 
                    td, 0);    

                firstTd = td;
                break;
            } else {
                lastTd = td;
                td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);
            }
        }

        OHCI_ASSERT(DeviceData, firstTd != NULL);

        // found the first TD, walk to the HcdTailP or the 
        // next transfer and free these TDs
        td = firstTd;
        while (td != EndpointData->HcdTailP) {
            
            tmpTd = td;
            td = TRANSFER_DESCRIPTOR_PTR(td->NextHcdTD);

            if (iso) {
                OHCI_ProcessDoneIsoTd(DeviceData,
                                      tmpTd,
                                      FALSE);
            } else {
                OHCI_ProcessDoneAsyncTd(DeviceData,
                                        tmpTd,
                                        FALSE);
            }

            if (TRANSFER_CONTEXT_PTR(td->TransferContext) != 
                AbortTransferContext) {
                break;
            }                 
            
        }

        LOGENTRY(DeviceData, G, '_NnT', 0, td, 0);    

        // td should now point to the next Transfer (or the 
        // tail)

        OHCI_ASSERT(DeviceData, 
            TRANSFER_CONTEXT_PTR(td->TransferContext) !=
            AbortTransferContext);        

        // BUGBUG toggle?

        // link last TD of the prev transfer to this TD
        // 
        prevTransfer = TRANSFER_CONTEXT_PTR(lastTd->TransferContext);

        prevTransfer->NextXferTd = td;
        
        TRANSFER_DESCRIPTOR_PTR(lastTd->NextHcdTD) = td;

        lastTd->HwTD.NextTD = td->PhysicalAddress;
    }

    *BytesTransferred = AbortTransferContext->BytesTransferred;

}


USB_MINIPORT_STATUS
OHCI_SubmitIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_OHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    OHCI_ASSERT(DeviceData, 
        EndpointData->Parameters.TransferType == Isochronous);         
        
    mpStatus = 
        OHCI_IsoTransfer(DeviceData,
                         EndpointData,
                         TransferParameters,
                         TransferContext,
                         IsoTransfer);           

    return mpStatus;
}            


USB_MINIPORT_STATUS
OHCI_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus;

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_OHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {        
    case Control:
        mpStatus = 
            OHCI_ControlTransfer(DeviceData,
                                 EndpointData,
                                 TransferParameters,
                                 TransferContext,
                                 TransferSGList);           
        break;
    case Interrupt:
    case Bulk:
        mpStatus = 
            OHCI_BulkOrInterruptTransfer(DeviceData,
                                         EndpointData,
                                         TransferParameters,
                                         TransferContext,
                                         TransferSGList);
        break;
    default:
        TEST_TRAP();
    }

    return mpStatus;
}


PHCD_TRANSFER_DESCRIPTOR
OHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Allocate a TD, it is OK to fail

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;    
    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!(td->Flags & TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            OHCI_ASSERT(DeviceData, td->DoneLink.Flink == NULL &&
                                    td->DoneLink.Blink == NULL);
            return td;
        }                    
    }

    // if we don't have enough TDs the caller has to handle this case.
    // generally we make sure we have enough before we ever call this 
    // function so the callers just assert that the return is not 
    // USB_BAD_PTR
    
    return USB_BAD_PTR;
}


ULONG
OHCI_FreeTds(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    return the number of free TDs

Arguments:

Return Value:

--*/
{
    ULONG i;
    PHCD_TRANSFER_DESCRIPTOR td;    
    ULONG n=0;
    
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (!(td->Flags & TD_FLAG_BUSY)) {
            n++;
        }                    
    }

    return n;
}


VOID
OHCI_EnableList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHC_OPERATIONAL_REGISTER hc;
    ULONG listFilled = 0;
    ULONG temp;
    
    hc = DeviceData->HC;
    
    temp = READ_REGISTER_ULONG(&hc->HcControlHeadED);
    if (temp) {
        SET_FLAG(listFilled, HcCmd_ControlListFilled);
    }
    
    temp = READ_REGISTER_ULONG (&hc->HcBulkHeadED);
    if (temp) {
        SET_FLAG(listFilled, HcCmd_BulkListFilled);
    }
    
    if (EndpointData->Parameters.TransferType == Bulk) {
        SET_FLAG(listFilled, HcCmd_BulkListFilled);
    } else if (EndpointData->Parameters.TransferType == Control) {
        SET_FLAG(listFilled, HcCmd_ControlListFilled);
    }
    
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul,
                         listFilled);
                         
    LOGENTRY(DeviceData, G, '_enL', listFilled, EndpointData, 0); 
            
}    


VOID
OHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    
    ed = EndpointData->HcdEd;
    
    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        // clear halt bit 
        ed->HwED.HeadP &= ~HcEDHeadP_HALT; 
        OHCI_EnableList(DeviceData, EndpointData);        
        break;
        
    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }        
}        


MP_ENDPOINT_STATUS
OHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    MP_ENDPOINT_STATUS status = ENDPOINT_STATUS_RUN;
    
    ed = EndpointData->HcdEd;

    if ((ed->HwED.HeadP & HcEDHeadP_HALT) && 
        !TEST_FLAG(ed->EdFlags, EDFLAG_NOHALT)) {
        status = ENDPOINT_STATUS_HALT; 
    }        

    return status;        
}        


VOID
OHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    )    
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    PHC_OPERATIONAL_REGISTER hc;
    
    ed = EndpointData->HcdEd;
    
    switch(State) {
    case ENDPOINT_ACTIVE:
        // clear the skip bit
        ed->HwED.sKip = 0;
        // if its bulk or control set the 
        // 'list filled' bits
        OHCI_EnableList(DeviceData, EndpointData);        
        break;
        
    case ENDPOINT_PAUSE:
        ed->HwED.sKip = 1;
        break;
        
    case ENDPOINT_REMOVE:
        
        SET_FLAG(ed->EdFlags, EDFLAG_REMOVED);
        ed->HwED.sKip = 1;
        // free the bw
        EndpointData->StaticEd->AllocatedBandwidth -= 
            EndpointData->Parameters.Bandwidth;
            
        OHCI_RemoveEndpointFromSchedule(DeviceData,
                                        EndpointData);

        break;            
        
    default:        
        TEST_TRAP();
    }        
}    


VOID
OHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    )     
/*++

Routine Description:

Arguments:

    Toggle is 0 or 1

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;

    ed = EndpointData->HcdEd;

    if (Toggle == 0) {
        ed->HwED.HeadP &= ~HcEDHeadP_CARRY;
    } else {
        ed->HwED.HeadP |= HcEDHeadP_CARRY; 
    }

    // we should get here unless we are paused or halted or 
    // we have no tranfsers
    OHCI_ASSERT(DeviceData, (ed->HwED.sKip == 1) ||
                            (ed->HwED.HeadP & HcEDHeadP_HALT) || 
                            ((ed->HwED.HeadP & ~HcEDHeadP_FLAGS) == ed->HwED.TailP));
                            
    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle); 
}


MP_ENDPOINT_STATE
OHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    )     
/*++

Routine Description:

Arguments:

Return Value:

--*/
{ 
    PHCD_ENDPOINT_DESCRIPTOR ed;
    MP_ENDPOINT_STATE state = ENDPOINT_ACTIVE;

    ed = EndpointData->HcdEd;

    if (TEST_FLAG(ed->EdFlags, EDFLAG_REMOVED)) {
        state = ENDPOINT_REMOVE;        
        goto OHCI_GetEndpointState_Done;
    }
    
    if (ed->HwED.sKip == 1) {
        state = ENDPOINT_PAUSE; 
        goto OHCI_GetEndpointState_Done;
    }

OHCI_GetEndpointState_Done:

    LOGENTRY(DeviceData, G, '_eps', EndpointData, 0, state); 
    
    return state;
}


#if 0
VOID
USBMPFN
OHCI_SendGoatPacket(
     PDEVICE_DATA DeviceData,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress
     COMPLETION ROUTINE
    )
/*++

Routine Description:

    Transmit the 'magic' iso packet.

    This is a fire and forget API so 

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PHW_TRANSFER_DESCRIPTOR hwTD;

    // hang a special ISO td of the static is ED 
    pch = WorkspaceVirtualAddress;
    phys = WorkspacePhysicalAddress;

    hwTD = pch;
    hwTDPhys = phys;

    pch += xxx;
    phys += xxx 

    goatData = pch;
    goatDataPhys = phys;

    pch += sizeof(USB_GOAT_DATA);
    phys += sizeof(USB_GOAT_DATA);
    
    // initialize the goat packet

    strcpy(goatData, USB_GOAT_DATA, 
    
    hwTD->NextTD = 0;    
    hwTD->CBP = goatDataPhys;
    hwTD->BE = dataPhys+sizeof(USB_GOAT_DATA)-1;
    hwTD->ConditionCode = HcCC_NotAccessed;
    hwTD->ErrorCount = 0;
    hwTD->IntDelay = HcTDIntDelay_0ms;
    hwTD->ShortXferOk = 0;
    
    hwTD->Isochrinous = 1;
    hwTD->FrameCount = 0;
    hwTD->StartFrameNumber = xxx;

    // hang the TD on the static ISO ED

    // clear the skip bit
}
#endif

USB_MINIPORT_STATUS
USBMPFN
OHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PUCHAR pch;
    PHW_ENDPOINT_DESCRIPTOR hwED;
    ULONG hwEDPhys, phys;
    PHW_TRANSFER_DESCRIPTOR hwTD, hwDummyTD;
    ULONG hwTDPhys, hwDummyTDPhys, dataPhys; 
    PUCHAR data;
    PHC_STATIC_ED_DATA staticControlEd;
    ULONG i;
    PSS_PACKET_CONTEXT context;

    staticControlEd = &DeviceData->StaticEDList[ED_CONTROL];
    hc = DeviceData->HC;

    // allocate an ED & TD from the scratch space and initialize it
    phys = WorkspacePhysicalAddress;
    pch = WorkspaceVirtualAddress;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch); 

    context = (PSS_PACKET_CONTEXT) pch;
    pch += sizeof(SS_PACKET_CONTEXT);
    phys += sizeof(SS_PACKET_CONTEXT);
  

    // carve out an ED
    hwEDPhys = phys;
    hwED = (PHW_ENDPOINT_DESCRIPTOR) pch;
    pch += sizeof(HW_ENDPOINT_DESCRIPTOR);
    phys += sizeof(HW_ENDPOINT_DESCRIPTOR);

    // carve out a TD
    hwTDPhys = phys;
    hwTD = (PHW_TRANSFER_DESCRIPTOR) pch;
    pch += sizeof(HW_TRANSFER_DESCRIPTOR);
    phys += sizeof(HW_TRANSFER_DESCRIPTOR);

    // carve out a dummy TD
    hwDummyTDPhys = phys;
    hwDummyTD = (PHW_TRANSFER_DESCRIPTOR) pch;
    pch += sizeof(HW_TRANSFER_DESCRIPTOR);
    phys += sizeof(HW_TRANSFER_DESCRIPTOR);
        
    // use the rest for data
    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0); 

    dataPhys = phys;
    data = pch;
    RtlCopyMemory(data, PacketData, *PacketLength);
    pch+=*PacketLength;
    phys+=*PacketLength;

    // init the hw ed descriptor
    hwED->NextED = 0;
    hwED->FunctionAddress = PacketParameters->DeviceAddress;
    hwED->EndpointNumber = PacketParameters->EndpointAddress;
    hwED->sKip = 0;
    hwED->Direction = HcEDDirection_Defer;
    switch (PacketParameters->Speed) {
    case ss_Low:
        hwED->LowSpeed = 1;
        break;            
    default:        
        hwED->LowSpeed = 0;
    }        
    hwED->MaxPacket = PacketParameters->MaximumPacketSize;
    hwED->HeadP = hwTDPhys;
    hwED->TailP = hwDummyTDPhys;

    // init the TD for this packet
    hwTD->NextTD = hwDummyTDPhys;    
    hwTD->Asy.ConditionCode = HcCC_NotAccessed;
    hwTD->Asy.ErrorCount = 0;
    hwTD->Asy.IntDelay = HcTDIntDelay_0ms;
    hwTD->Asy.ShortXferOk = 1;
    
    if (0 == *PacketLength) {
        hwTD->CBP = 0;
        hwTD->BE = 0;
    }
    else {
       hwTD->CBP = dataPhys;
       hwTD->BE = dataPhys+*PacketLength-1;
    }

    // init the dummy TD
    hwDummyTD->NextTD = 0;
    hwDummyTD->CBP = 0xFFFFFFFF;

    LOGENTRY(DeviceData, G, '_ss2', hwTD, context, hwED); 
    LOGENTRY(DeviceData, G, '_ss3', dataPhys, data, *PacketLength); 

    switch(PacketParameters->Type) {
    case ss_Setup:
        LOGENTRY(DeviceData, G, '_sSU', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_Setup;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_In: 
        LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_In;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_Out:
        LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0); 
        hwED->Direction = HcEDDirection_Defer;   
        hwED->Isochronous = 0;
        hwTD->Asy.Direction = HcTDDirection_Out;
        hwTD->Asy.Isochronous = 0;
        break;
    case ss_Iso_In:
        break;
    case ss_Iso_Out:       
        break;
    }

    switch(PacketParameters->Toggle) {
    case ss_Toggle0:
        hwTD->Asy.Toggle = HcTDToggle_Data0; 
        break;
    case ss_Toggle1:
        hwTD->Asy.Toggle = HcTDToggle_Data1; 
        break;
    }        

    //TEST_TRAP();
    
    //
    // Replace the control ED in the list with the ED just created.  
    // Save the old value of both the control and bulk lists so 
    //  they can be replaced when this transfer is complete.
    //
    // NOTE: This will interrupt normal bus operation for at least one ms

    context->PhysHold = READ_REGISTER_ULONG(staticControlEd->PhysicalHead);    
    HW_DATA_PTR(context->Data) = data;
    HW_TRANSFER_DESCRIPTOR_PTR(context->Td) = hwTD;
    
    WRITE_REGISTER_ULONG(staticControlEd->PhysicalHead, hwEDPhys);    
    
    //
    // Enable the control list and disable the bulk list.  Disabling the 
    //  bulk list temporarily will allow the single step transaction to
    //  complete without interfering with bulk data.  In this manner, the
    //  bulk data INs and OUTs can be sent without interfering with bulk
    //  devices currently on the bus.  
    //
    //  NOTE: I think attempting to use this feature without first disabling
    //          the root hub could lead to some problems.  
    //
    
    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, HcCmd_ControlListFilled);
              
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
OHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    PUCHAR pch;
    PSS_PACKET_CONTEXT context;
    PHC_STATIC_ED_DATA staticControlEd;
    PHC_STATIC_ED_DATA staticBulkEd;
    ULONG currentBulkEd;

    PHW_TRANSFER_DESCRIPTOR hwTd;
    PUCHAR data;
    ULONG  listFilled;

    staticControlEd = &DeviceData->StaticEDList[ED_CONTROL];
    staticBulkEd    = &DeviceData->StaticEDList[ED_BULK];

    hc = DeviceData->HC;
    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;
    hwTd = HW_TRANSFER_DESCRIPTOR_PTR(context->Td);
    data = HW_DATA_PTR(context->Data);

    LOGENTRY(DeviceData, G, '_ssE', hwTd, 0, 0); 

    //TEST_TRAP();

    // compute bytes transferred 
    if (hwTd->CBP) {
        // we never have pagebreaks in the single step TD
        *PacketLength = *PacketLength - ((hwTd->BE & OHCI_PAGE_SIZE_MASK) - 
                          (hwTd->CBP & OHCI_PAGE_SIZE_MASK)+1);          
    } 
         
    // return any errors
    if (hwTd->Asy.ConditionCode == HcCC_NoError) {
        *UsbdStatus = USBD_STATUS_SUCCESS;
    } else {
        *UsbdStatus =
                (hwTd->Asy.ConditionCode | 0xC0000000);
    }                

    LOGENTRY(DeviceData, G, '_ssX', hwTd, *PacketLength, 0); 
    
    RtlCopyMemory(PacketData,
                  data,
                  *PacketLength);
                  
    //
    // Restore the previous control structure and enable the control and
    //  bulk lists if they are non-NULL (ie. point to valid EDs.)
    //
          
    listFilled = 0;

    WRITE_REGISTER_ULONG(staticControlEd->PhysicalHead, context->PhysHold); 
    if (context->PhysHold) {
        listFilled |= HcCmd_ControlListFilled;
    }

    currentBulkEd = READ_REGISTER_ULONG(staticBulkEd->PhysicalHead);
    if (currentBulkEd) {
        listFilled |= HcCmd_BulkListFilled;
    }

    WRITE_REGISTER_ULONG(&hc->HcCommandStatus.ul, listFilled);

    return USBMP_STATUS_SUCCESS;
}

VOID
OHCI_SuspendController(
     PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
    
    hc = DeviceData->HC;

    // mask off interrupts that are not appropriate
    WRITE_REGISTER_ULONG(&hc->HcInterruptDisable, 0xFFFFffff);    

    // flush any rogue status
    WRITE_REGISTER_ULONG(&hc->HcInterruptStatus, 0xFFFFffff);    

    // put the controller in 'suspend'
    
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    control.HostControllerFunctionalState = HcHCFS_USBSuspend;
    control.RemoteWakeupEnable = 1;

    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

        
    // enable the resume interrupt
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_MasterInterruptEnable |
                         HcInt_RootHubStatusChange | 
                         HcInt_ResumeDetected | 
                         HcInt_UnrecoverableError);

    SET_FLAG(DeviceData->Flags, HMP_FLAG_SUSPENDED);                         
}


USB_MINIPORT_STATUS
OHCI_ResumeController(
     PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    reverse what was done in 'suspend'

Arguments:

Return Value:

    None

--*/
{
    PHC_OPERATIONAL_REGISTER hc;
    HC_CONTROL control;
     
    hc = DeviceData->HC;

    CLEAR_FLAG(DeviceData->Flags, HMP_FLAG_SUSPENDED);      
    // is some cases the BIOS trashes the state of the controller,
    // even though we enter suspend.  
    // This is usually platform specific and indicates a broken BIOS
    control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
    if (control.HostControllerFunctionalState == HcHCFS_USBReset) {

        return USBMP_STATUS_HARDWARE_FAILURE;
        
    } else {
    
        // When the HC is in the operational state, HccaPad1 should be set to
        // zero every time the HC updates HccaFrameNumer.  Preset HccaPad1 to
        // zero before entering the operational state.  OHCI_CheckController()
        // should always find a zero value in HccaPad1 when the HC is in the
        // operational state.
        // 
        DeviceData->HcHCCA->HccaPad1 = 0;

        // put the controller in 'operational' state 
    
        control.ul = READ_REGISTER_ULONG(&hc->HcControl.ul);
        control.HostControllerFunctionalState = HcHCFS_USBOperational;
        
        WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);
    }
    
    // re-enable interrupts
    WRITE_REGISTER_ULONG(&hc->HcInterruptEnable,
                         HcInt_OwnershipChange |
                         HcInt_SchedulingOverrun |
                         HcInt_WritebackDoneHead |
                         HcInt_FrameNumberOverflow |
                         HcInt_UnrecoverableError);

    WRITE_REGISTER_ULONG(&hc->HcControl.ul, control.ul);

    return USBMP_STATUS_SUCCESS;
}


VOID
OHCI_Unload(
     PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

Arguments:

    DriverObject - pointer to a driver object

Return Value:

    None

--*/
{
    // provide an unload routine 

    // we do this just to test the port driver
}


BOOLEAN
OHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    )
{
    ULONG tmp;
    PHC_OPERATIONAL_REGISTER hc;

    hc = DeviceData->HC;

    tmp = READ_REGISTER_ULONG(&hc->HcCommandStatus.ul);

    if (tmp == 0xffffffff) {
        if (Notify) {
            USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
        }            
        return FALSE;
    }

    return TRUE;
}


VOID
OHCI_CheckController(
    PDEVICE_DATA DeviceData
    )
{
    PHC_OPERATIONAL_REGISTER    hc;
    ULONG                       currentDeadmanFrame;
    ULONG                       lastDeadmanFrame;
    ULONG                       frameDelta;

    hc = DeviceData->HC;

    // First make sure it looks like the hardware is still present.  (This
    // will call USBPORT_INVALIDATE_CONTROLLER() if it looks like the hardware
    // is no longer present).
    //
    if (!OHCI_HardwarePresent(DeviceData, TRUE)) {
        return;
    }

    // Don't check any further if the controller is not currently in the
    // operational state.
    //
    if ((READ_REGISTER_ULONG(&hc->HcControl.ul) & HcCtrl_HCFS_MASK) !=
        HcCtrl_HCFS_USBOperational) {
        return;
    }

    // Don't check any further if we already checked once this frame (or in
    // the last few frames).
    //
    currentDeadmanFrame = READ_REGISTER_ULONG(&hc->HcFmNumber);

    lastDeadmanFrame = DeviceData->LastDeadmanFrame;

    frameDelta = (currentDeadmanFrame - lastDeadmanFrame) & HcFmNumber_MASK;

    // Might HcFmNumber erroneously read back as zero under some conditions
    // on some chipsets?  Don't check any further if HcFmNumber is zero,
    // just check later next time around.
    //
    if (currentDeadmanFrame && (frameDelta >= 5)) {

        DeviceData->LastDeadmanFrame = currentDeadmanFrame;

        switch (DeviceData->HcHCCA->HccaPad1)
        {
            case 0:
                //
                // When the HC updates HccaFrameNumber, it is supposed
                // to set HccaPad1 to zero, so this is the expected case.
                // Here we set HccaPad1 to a non-zero value to try to
                // detect situations when the HC is no longer functioning
                // correctly and accessing and updating host memory.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD1;

                break;

            case 0xBAD1:
                //
                // Apparently the HC has not updated the HCCA since the
                // last time the DPC ran.  This is probably not good.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD2;

                LOGENTRY(DeviceData, G, '_BD2', DeviceData,
                         lastDeadmanFrame,
                         currentDeadmanFrame);

                LOGENTRY(DeviceData, G, '_bd2', DeviceData,
                         DeviceData->HcHCCA->HccaFrameNumber,
                         frameDelta);

                break;

            case 0xBAD2:
                //
                // Apparently the HC has not updated the HCCA since the
                // last two times the DPC ran.  This looks even worse.
                // Assume the HC has become wedged.
                //
                DeviceData->HcHCCA->HccaPad1 = 0xBAD3;

                LOGENTRY(DeviceData, G, '_BD3', DeviceData,
                         lastDeadmanFrame,
                         currentDeadmanFrame);

                LOGENTRY(DeviceData, G, '_bd3', DeviceData,
                         DeviceData->HcHCCA->HccaFrameNumber,
                         frameDelta);

                OHCI_KdPrint((DeviceData, 0,
                              "*** Warning: OHCI HC %08X appears to be wedged!\n",
                              DeviceData));

                // Tell USBPORT to please reset the controller.
                //
                USBPORT_INVALIDATE_CONTROLLER(DeviceData,
                                              UsbMpControllerNeedsHwReset);

                break;

            case 0xBAD3:
                break;

            default:
                // Should not hit this case.
                TEST_TRAP();
                break;
        }
    }
}


VOID
OHCI_ResetController(
    PDEVICE_DATA DeviceData
    )
/*++
    Attempt to resurrect the HC after we have determined that it is dead.
--*/
{
    PHC_OPERATIONAL_REGISTER    HC;
    ULONG                       HccaFrameNumber;
    ULONG                       HcControl;
    ULONG                       HcHCCA;
    ULONG                       HcControlHeadED;
    ULONG                       HcBulkHeadED;
    ULONG                       HcFmInterval;
    ULONG                       HcPeriodicStart;
    ULONG                       HcLSThreshold;
    HC_RH_DESCRIPTOR_A          descrA;
    ULONG                       port;

    LOGENTRY(DeviceData, G, '_RHC', 0, 0, 0);

    //
    // Get the pointer to the HC Operational Registers
    //

    HC = DeviceData->HC;

    //
    // Save the last FrameNumber from the HCCA from when the HC froze
    //

    HccaFrameNumber = DeviceData->HcHCCA->HccaFrameNumber;

    //
    // Save current HC operational register values
    //

    // offset 0x04, save HcControl
    //
    HcControl       = READ_REGISTER_ULONG(&HC->HcControl.ul);

    // offset 0x18, save HcHCCA
    //
    HcHCCA          = READ_REGISTER_ULONG(&HC->HcHCCA);

    // offset 0x20, save HcControlHeadED
    //
    HcControlHeadED = READ_REGISTER_ULONG(&HC->HcControlHeadED);

    // offset 0x28, save HcBulkHeadED
    //
    HcBulkHeadED    = READ_REGISTER_ULONG(&HC->HcBulkHeadED);

    // offset 0x34, save HcFmInterval
    //
    HcFmInterval    = READ_REGISTER_ULONG(&HC->HcFmInterval.ul);

    // offset 0x40, save HcPeriodicStart
    //
    HcPeriodicStart = READ_REGISTER_ULONG(&HC->HcPeriodicStart);

    // offset 0x44, save HcLSThreshold
    //
    HcLSThreshold   = READ_REGISTER_ULONG(&HC->HcLSThreshold);


    //
    // Reset the host controller
    //
    WRITE_REGISTER_ULONG(&HC->HcCommandStatus.ul, HcCmd_HostControllerReset);
    KeStallExecutionProcessor(10);


    //
    // Restore / reinitialize HC operational register values
    //

    // offset 0x08, HcCommandStatus is set to zero on reset

    // offset 0x0C, HcInterruptStatus is set to zero on reset

    // offset 0x10, HcInterruptEnable is set to zero on reset

    // offset 0x14, HcInterruptDisable is set to zero on reset

    // offset 0x18, restore HcHCCA
    //
    WRITE_REGISTER_ULONG(&HC->HcHCCA,           HcHCCA);

    // offset 0x1C, HcPeriodCurrentED is set to zero on reset

    // offset 0x20, restore HcControlHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcControlHeadED,  HcControlHeadED);

    // offset 0x24, HcControlCurrentED is set to zero on reset

    // offset 0x28, restore HcBulkHeadED
    //
    WRITE_REGISTER_ULONG(&HC->HcBulkHeadED,     HcBulkHeadED);

    // offset 0x2C, HcBulkCurrentED is set to zero on reset

    // offset 0x30, HcDoneHead is set to zero on reset


    // It appears that writes to HcFmInterval don't stick unless the HC
    // is in the operational state.  Set the HC into the operational
    // state at this point, but don't enable any list processing yet
    // by setting any of the BLE, CLE, IE, or PLE bits.
    //
    WRITE_REGISTER_ULONG(&HC->HcControl.ul, HcCtrl_HCFS_USBOperational);


    // offset 0x34, restore HcFmInterval
    //
    WRITE_REGISTER_ULONG(&HC->HcFmInterval.ul,
                         HcFmInterval | HcFmI_FRAME_INTERVAL_TOGGLE);

    // offset 0x38, HcFmRemaining is set to zero on reset

    // offset 0x3C, restore HcFmNumber
    //
    WRITE_REGISTER_ULONG(&HC->HcFmNumber,       HccaFrameNumber);

    // offset 0x40, restore HcPeriodicStart
    //
    WRITE_REGISTER_ULONG(&HC->HcPeriodicStart,  HcPeriodicStart);

    // offset 0x44, restore HcLSThreshold
    //
    WRITE_REGISTER_ULONG(&HC->HcLSThreshold,    HcLSThreshold);

    // Power on downstream ports
    //
    WRITE_REGISTER_ULONG(&HC->HcRhStatus,
                         HcRhS_SetGlobalPower | HcRhS_SetRemoteWakeupEnable);

    descrA.ul = OHCI_ReadRhDescriptorA(DeviceData);
    OHCI_ASSERT(DeviceData, (descrA.ul) && (!(descrA.ul & HcDescA_RESERVED)));

    for (port = 0; port < descrA.s.NumberDownstreamPorts; port++)
    {
        WRITE_REGISTER_ULONG(&HC->HcRhPortStatus[port], HcRhPS_SetPortPower);
    }

    // offset 0x04, restore HcControl
    //
    HcControl &= ~(HcCtrl_HCFS_MASK);
    HcControl |= HcCtrl_HCFS_USBOperational;

    WRITE_REGISTER_ULONG(&HC->HcControl.ul,     HcControl);

    // offset 0x10, restore HcInterruptEnable (just turn everything on!)
    //
    WRITE_REGISTER_ULONG(&HC->HcInterruptEnable,
                         HcInt_MasterInterruptEnable    |   // 0x80000000
                         HcInt_OwnershipChange          |   // 0x40000000
                         HcInt_RootHubStatusChange      |   // 0x00000040
                         HcInt_FrameNumberOverflow      |   // 0x00000020
                         HcInt_UnrecoverableError       |   // 0x00000010
                         HcInt_ResumeDetected           |   // 0x00000008
                         HcInt_StartOfFrame             |   // 0x00000004
                         HcInt_WritebackDoneHead        |   // 0x00000002
                         HcInt_SchedulingOverrun            // 0x00000001
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbohci\usbohci.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbohci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef   __OHCI_H__
#define   __OHCI_H__


#define OHCI_COMMON_BUFFER_SIZE (sizeof(HCCA_BLOCK)+\
            NO_ED_LISTS*sizeof(HW_ENDPOINT_DESCRIPTOR) +\
            (17*2)*sizeof(HCD_ENDPOINT_DESCRIPTOR))

/*
    Registry Keys 
*/

// Software Branch PDO Keys 
#define SOF_MODIFY_KEY L"recommendedClocksPerFrame"

// Hardware Branch PDO Keys

/* 
    define resource consumption for endpoints types
*/
#define T_256K          0x40000
#define T_128K          0x20000
#define T_64K           0x10000
#define T_4K            0x1000


// Control:
// largest possible transfer for control is 64k 
// therefore we support up to 2 transfers of this 
// size in HW.  Most control transfers are much 
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in 
// HW since a single control transfer cannot be 
// broken up.
                                            
#define MAX_CONTROL_TRANSFER_SIZE      T_64K 
// worst case 64k control transfer 17 + status and 
// setup TD = 19 (*2 transfers)
#define TDS_PER_CONTROL_ENDPOINT          38


// Bulk:
// The most data we can move in a ms is 1200 bytes. 
// we support two 64k transfers queued to HW at a 
// a time -- we should be able to keep the bus busy 
// with this.
// NOTE: in a memory constrained system we can shrink
// this value, our max transfer size should always be
// at half the # of TDs available
                                                   
#define MAX_BULK_TRANSFER_SIZE         T_256K
// enough for 4 64 xfers, 2 128k or 1 256k
#define TDS_PER_BULK_ENDPOINT             68

// Iso:                                     
#define MAX_ISO_TRANSFER_SIZE          T_64K
#define TDS_PER_ISO_ENDPOINT              64
                                    
// Interrupt:
#define MAX_INTERRUPT_TRANSFER_SIZE     T_4K
#define TDS_PER_INTERRUPT_ENDPOINT         4


#undef PDEVICE_DATA

// Values for DeviceData.Flags
#define HMP_FLAG_SOF_MODIFY_VALUE   0x00000001
#define HMP_FLAG_SUSPENDED          0x00000002


//** flags for ED HC_STATIC_ED_DATA & HCD_ENDPOINT_DESCRIPTOR

//* these define the type of ED
#define EDFLAG_CONTROL          0x00000001
#define EDFLAG_BULK             0x00000002
#define EDFLAG_INTERRUPT        0x00000004

//*
// these define ed charateristics and state
#define EDFLAG_NOHALT           0x00000008

#define EDFLAG_REMOVED          0x00000010
#define EDFLAG_REGISTER         0x00000020


typedef struct _HC_STATIC_ED_DATA {
    // virtual address of static ED
    PHW_ENDPOINT_DESCRIPTOR HwED;
    // physical address of next ED
    HW_32BIT_PHYSICAL_ADDRESS  HwEDPhys; 
    // index in the static ED list for the 
    // next ED in the interrupt tree
    CHAR            NextIdx;

    // list of 'real EDs' associated
    // with this static ED
    LIST_ENTRY      TransferEdList;

    // Use EDFLAG_
    ULONG           EdFlags;
    // this is either an HC register or the address of the entry
    // in the HCCA area corresponding to the 'physical address'
    // of the first ed in the list
    //
    // in the case of control and bulk the physical head will be 0
    // or point to timing delay 'dummy EDs'
    //
    // in the case of interrupt the physical head will be a static 
    // ED in the onterrupt 'tree'
    PULONG          PhysicalHead;
    
    ULONG           AllocatedBandwidth;

    ULONG           HccaOffset;
    
} HC_STATIC_ED_DATA, *PHC_STATIC_ED_DATA;


//
// These values index in to the static ED list
//
#define  ED_INTERRUPT_1ms        0
#define  ED_INTERRUPT_2ms        1
#define  ED_INTERRUPT_4ms        3
#define  ED_INTERRUPT_8ms        7
#define  ED_INTERRUPT_16ms       15
#define  ED_INTERRUPT_32ms       31
#define  ED_CONTROL              63
#define  ED_BULK                 64
#define  ED_ISOCHRONOUS          0     // same as 1ms interrupt queue
#define  NO_ED_LISTS             65
#define  ED_EOF                  0xff

//
#define  SIG_HCD_DUMMY_ED       'deYD'
#define  SIG_HCD_ED             'deYH'
#define  SIG_HCD_TD             'dtYH'
#define  SIG_EP_DATA            'peYH'
#define  SIG_OHCI_TRANSFER      'rtYH'
#define  SIG_OHCI_DD            'icho'


typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_OPERATIONAL_REGISTER    HC; 
    HC_FM_INTERVAL              BIOS_Interval;
    ULONG                       SofModifyValue;
    ULONG                       FrameHighPart;
    ULONG                       NumberOfPorts;
    PHCCA_BLOCK                 HcHCCA; 
    HW_32BIT_PHYSICAL_ADDRESS   HcHCCAPhys;     
    PUCHAR                      StaticEDs; 
    HW_32BIT_PHYSICAL_ADDRESS   StaticEDsPhys; 

    USB_CONTROLLER_FLAVOR       ControllerFlavor;

    ULONG                       LastDeadmanFrame;

    struct _HCD_ENDPOINT_DESCRIPTOR    *HydraLsHsHackEd;

    HC_STATIC_ED_DATA           StaticEDList[NO_ED_LISTS];

} DEVICE_DATA, *PDEVICE_DATA;

#define TC_FLAGS_SHORT_XFER_OK           0x00000001
#define TC_FLAGS_SHORT_XFER_DONE         0x00000002

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG BytesTransferred;
    PTRANSFER_PARAMETERS TransferParameters;
    ULONG PendingTds;
    ULONG TcFlags;
    USBD_STATUS UsbdStatus;
    // first TD of the next transfer in the chain
    struct _HCD_TRANSFER_DESCRIPTOR *NextXferTd;
    struct _HCD_TRANSFER_DESCRIPTOR *StatusTd;
    struct _ENDPOINT_DATA *EndpointData;

    PMINIPORT_ISO_TRANSFER IsoTransfer;

} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)

typedef struct _HCD_ENDPOINT_DESCRIPTOR {
   HW_ENDPOINT_DESCRIPTOR     HwED;
   // make Physical Address the same as in HCD_TRANSFER_DESCRIPTOR
   ULONG                      Pad4[4];
   
   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      EdFlags;  //use EDFLAG_
   ULONG                      Win64Pad;
   
   MP_HW_POINTER              EndpointData;
   MP_HW_LIST_ENTRY           SwLink;
   
   ULONG                      PadTo128[14];
} HCD_ENDPOINT_DESCRIPTOR, *PHCD_ENDPOINT_DESCRIPTOR;

C_ASSERT((sizeof(HCD_ENDPOINT_DESCRIPTOR) == 128));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010

#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define HW_TRANSFER_DESCRIPTOR_PTR(p) ((struct _HW_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define HW_DATA_PTR(p) ((PVOID) (p).Pointer)


typedef struct _HCD_TRANSFER_DESCRIPTOR {
   HW_TRANSFER_DESCRIPTOR     HwTD;
   
   HW_32BIT_PHYSICAL_ADDRESS  PhysicalAddress;
   ULONG                      Sig;
   ULONG                      Flags;
   ULONG                      TransferCount;
   
   MP_HW_POINTER              EndpointData;
   MP_HW_POINTER              TransferContext;
   MP_HW_POINTER              NextHcdTD;

   ULONG                      FrameIndex;    

   LIST_ENTRY                 DoneLink;  
#ifdef _WIN64
   ULONG                      PadTo128[8];
#else 
   ULONG                      PadTo128[11];
#endif   
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 128));

typedef struct _SS_PACKET_CONTEXT {
    ULONG PhysHold;
    MP_HW_POINTER Td;
    MP_HW_POINTER Data;
    ULONG PadTo8Dwords[3];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

//#define EPF_HAVE_TRANSFER   0x00000001
//#define EPF_REQUEST_PAUSE   0x00000002

typedef struct _ENDPOINT_DATA {

    ULONG Sig;
    ENDPOINT_PARAMETERS Parameters;
    ULONG Flags;
//    USHORT MaxPendingTransfers;
    USHORT PendingTransfers;
    PHC_STATIC_ED_DATA StaticEd;
    PHCD_TD_LIST TdList;
    PHCD_ENDPOINT_DESCRIPTOR HcdEd;
    ULONG TdCount;
    ULONG PendingTds;
    PHCD_TRANSFER_DESCRIPTOR HcdTailP;
    PHCD_TRANSFER_DESCRIPTOR HcdHeadP;

    LIST_ENTRY DoneTdList;
    
} ENDPOINT_DATA, *PENDPOINT_DATA;


/*
    Callouts to port driver services    
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))
            
#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd));

#define USBPORT_COMPLETE_TRANSFER(dd, ep, t, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (t), \
            (status), (length));        

#define USBPORT_COMPLETE_ISO_TRANSFER(dd, ep, t, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (t), \
            (iso));               

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep));        

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep));        

#define USBPORT_RW_CONFIG_SPACE(dd, read, buffer, offset, length) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), (read), \
            (buffer), (offset), (length))

#define USBPORT_BUGCHECK(dd) \
        RegistrationPacket.USBPORTSVC_BugCheck(dd)
            

#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        { ULONG i;\
        TRANSFER_CONTEXT_PTR((td)->TransferContext) = (tc);\
        SET_FLAG((td)->Flags, TD_FLAG_XFER); \
        (td)->HwTD.CBP = 0xbaadf00d;\
        (td)->HwTD.BE = 0xf00dbaad;\
        (td)->HwTD.NextTD = 0;\
        (td)->HwTD.Asy.IntDelay = HcTDIntDelay_NoInterrupt;\
        TRANSFER_DESCRIPTOR_PTR((td)->NextHcdTD) = NULL;\
        for (i=0; i<8; i++) {\
        (td)->HwTD.Packet[i].PSW = 0;\
        }\
        }

#define SET_NEXT_TD(linkTd, nextTd) \
    (linkTd)->HwTD.NextTD = (nextTd)->PhysicalAddress;\
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = (nextTd);

#define SET_NEXT_TD_NULL(linkTd) \
    TRANSFER_DESCRIPTOR_PTR((linkTd)->NextHcdTD) = NULL;\
    (linkTd)->HwTD.NextTD = 0;    

#ifdef _WIN64
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACEDEADFACE)
#else
#define FREE_TD_CONTEXT ((PVOID) 0xDEADFACE)
#endif

#define OHCI_FREE_TD(dd, ep, td) \
    (td)->Flags = 0;\
    (td)->HwTD.NextTD = 0;\
    TRANSFER_CONTEXT_PTR((td)->TransferContext) = FREE_TD_CONTEXT;\
    (td)->DoneLink.Flink = NULL;\
    (td)->DoneLink.Blink = NULL;

#define OHCI_ALLOC_TD OHCI_AllocTd

// assuming only one bit is set this macro returns that bit
// 
#define GET_BIT_SET(d, bit) \
    {   \
        UCHAR tmp = (d);\
        (bit)=0; \
        while (!(tmp & 0x01)) {\
            (bit)++;\
            tmp >>= 1;\
        };\
    }

VOID
OHCI_EnableList(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

PHCD_TRANSFER_DESCRIPTOR
OHCI_AllocTd(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
OHCI_SubmitTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );

ULONG
OHCI_MapAsyncTransferToTd(
    PDEVICE_DATA DeviceData,
    ULONG MaxPacketSize,
    ULONG LengthMapped,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR Td, 
    PTRANSFER_SG_LIST SgList
    );    
                        
USB_MINIPORT_STATUS
OHCI_OpenEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

MP_ENDPOINT_STATE
OHCI_GetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
OHCI_SetEndpointState(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATE State
    );       

VOID
OHCI_CheckController(
    PDEVICE_DATA DeviceData
    );    

BOOLEAN
OHCI_HardwarePresent(
    PDEVICE_DATA DeviceData,
    BOOLEAN Notify
    );       

VOID
OHCI_ResetController(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
OHCI_StartController(
     PDEVICE_DATA DeviceData,
     PHC_RESOURCES HcResources
    );

BOOLEAN
OHCI_InterruptService (
     PDEVICE_DATA DeviceData
    );    

USB_MINIPORT_STATUS
OHCI_RH_GetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
OHCI_RH_GetRootHubData(
     PDEVICE_DATA DeviceData,
     PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
OHCI_RH_GetStatus(
     PDEVICE_DATA DeviceData,
     PUSHORT Status
    );  

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnable(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortPower(
     PDEVICE_DATA DeviceData,
     USHORT PortNumber
    );    

VOID
OHCI_RH_DisableIrq(
     PDEVICE_DATA DeviceData
    );
    
VOID
OHCI_RH_EnableIrq(
     PDEVICE_DATA DeviceData
    );

VOID
OHCI_InterruptDpc (
     PDEVICE_DATA DeviceData,
     BOOLEAN EnableInterrupts
    );   

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_GetHubStatus(
     PDEVICE_DATA DeviceData,
     PRH_HUB_STATUS HubStatus
    );    

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_SetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

VOID
OHCI_QueryEndpointRequirements(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_REQUIREMENTS EndpointRequirements
    );    

VOID
OHCI_CloseEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

VOID
OHCI_PollEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_ControlTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );

VOID
OHCI_ProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    );    

USB_MINIPORT_STATUS
OHCI_PokeEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_BulkOrInterruptTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PTRANSFER_SG_LIST TransferSGList
    );    

USB_MINIPORT_STATUS
OHCI_OpenBulkEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

USB_MINIPORT_STATUS
OHCI_OpenControlEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
OHCI_OpenInterruptEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );    

PHCD_TRANSFER_DESCRIPTOR
OHCI_InitializeTD(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

PHCD_ENDPOINT_DESCRIPTOR
OHCI_InitializeED(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PHCD_ENDPOINT_DESCRIPTOR Ed,
     PHCD_TRANSFER_DESCRIPTOR DummyTd,
     HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

VOID
OHCI_InsertEndpointInSchedule(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

VOID
OHCI_PollAsyncEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
OHCI_StopController(
     PDEVICE_DATA DeviceData,
     BOOLEAN HwPresent
    );

ULONG
OHCI_Get32BitFrameNumber(
     PDEVICE_DATA DeviceData
    );    

VOID
OHCI_InterruptNextSOF(
     PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
OHCI_EnableInterrupts(
     PDEVICE_DATA DeviceData
    );    

VOID
USBMPFN
OHCI_DisableInterrupts(
     PDEVICE_DATA DeviceData
    );    
    
ULONG
OHCI_FreeTds(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );

VOID
OHCI_AbortTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_CONTEXT TransferContext,
     PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
OHCI_StartSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    );   

USB_MINIPORT_STATUS
OHCI_EndSendOnePacket(
     PDEVICE_DATA DeviceData,
     PMP_PACKET_PARAMETERS PacketParameters,
     PUCHAR PacketData,
     PULONG PacketLength,
     PUCHAR WorkspaceVirtualAddress,
     HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
     ULONG WorkSpaceLength,
     USBD_STATUS *UsbdStatus
    );   
    
VOID
OHCI_PollController(
     PDEVICE_DATA DeviceData
    );

VOID
OHCI_SetEndpointDataToggle(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     ULONG Toggle
    );    

MP_ENDPOINT_STATUS
OHCI_GetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );   

VOID
OHCI_SetEndpointStatus(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     MP_ENDPOINT_STATUS Status
    );       

VOID
OHCI_Unload(
     PDRIVER_OBJECT DriverObject
    );    

USB_MINIPORT_STATUS
OHCI_OpenIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_PARAMETERS EndpointParameters,
     PENDPOINT_DATA EndpointData
    );  

ULONG
OHCI_MapIsoTransferToTd(
     PDEVICE_DATA DeviceData,
     PMINIPORT_ISO_TRANSFER IsoTransfer,
     ULONG CurrentPacket,
     PHCD_TRANSFER_DESCRIPTOR Td 
    );    

USB_MINIPORT_STATUS
OHCI_SubmitIsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    );

USB_MINIPORT_STATUS
OHCI_IsoTransfer(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData,
     PTRANSFER_PARAMETERS TransferParameters,
     PTRANSFER_CONTEXT TransferContext,
     PMINIPORT_ISO_TRANSFER IsoTransfer
    );    

VOID
OHCI_ProcessDoneIsoTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    BOOLEAN CompleteTransfer
    );

VOID
OHCI_PollIsoEndpoint(
     PDEVICE_DATA DeviceData,
     PENDPOINT_DATA EndpointData
    );    

ULONG
InitializeHydraHsLsFix(
     PDEVICE_DATA DeviceData,
     PUCHAR CommonBuffer,
     HW_32BIT_PHYSICAL_ADDRESS CommonBufferPhys
    );    

VOID
OHCI_SuspendController(
     PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
OHCI_ResumeController(
     PDEVICE_DATA DeviceData
    );    

ULONG
OHCI_ReadRhDescriptorA(
    PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

USB_MINIPORT_STATUS
OHCI_RH_ClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );    

VOID
USBMPFN
OHCI_FlushInterrupts(
    PDEVICE_DATA DeviceData
    );    
    
#endif /* __OHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\async.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   async.c

Abstract:

   miniport transfer code for control, bulk and interrupt

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-20-00 : created, jsenior

--*/

#include "pch.h"


//implements the following miniport functions:

// non paged
//UhciInsertQh
//UhciUnlinkQh
//UhciMapAsyncTransferToTds
//UhciQueueTransfer
//UhciControlTransfer
//UhciBulkOrInterruptTransfer
//UhciSetAsyncEndpointState
//UhciProcessDoneAsyncTd
//UhciPollAsyncEndpoint
//UhciAbortAsyncTransfer


VOID
UhciFixDataToggle(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PHCD_TRANSFER_DESCRIPTOR Td,
    ULONG Toggle
    )
{
    LOGENTRY(DeviceData, G, '_Fdt', EndpointData, Toggle, 0);

    //
    // Loop through all the remaining TDs for this
    // endpoint and fix the data toggle.
    //
    while (Td) {
        Td->HwTD.Token.DataToggle = Toggle;
        Toggle = !Toggle;
        Td = Td->NextTd;
    }

    EndpointData->Toggle = Toggle;
}


VOID
UhciInsertQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR LinkQh
    )
/*++

Routine Description:

   Insert an aync queue head into the HW list.

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh;
    QH_LINK_POINTER newLink;

    LOGENTRY(DeviceData, G, '_Ain', 0, FirstQh, LinkQh);
    UHCI_ASSERT(DeviceData, !TEST_FLAG(LinkQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE));

    // ASYNC QUEUE looks like this:
    //
    //
    //            |- we insert here
    //|static QH|<->|xfer QH|<->|xfer QH|<->
    //     |                              |
    //     ---------------<->--------------

    // link new qh to the current 'head' ie
    // first transfer QH
    nextQh = FirstQh->NextQh;

    LinkQh->HwQH.HLink = FirstQh->HwQH.HLink;
    LinkQh->NextQh = nextQh;
    LinkQh->PrevQh = FirstQh;

    if (nextQh) {
        nextQh->PrevQh = LinkQh;
    } else {

        // This is the last queuehead. I.e. a bulk queuehead.
        UHCI_ASSERT(DeviceData,
                    (LinkQh->HwQH.HLink.HwAddress & ~HW_LINK_FLAGS_MASK) ==
                    DeviceData->BulkQueueHead->PhysicalAddress);
        DeviceData->LastBulkQueueHead = LinkQh;
    }

    // put the new qh at the head of the queue
    newLink.HwAddress = LinkQh->PhysicalAddress;
    newLink.QHTDSelect = 1;
    UHCI_ASSERT(DeviceData, !newLink.Terminate);
    UHCI_ASSERT(DeviceData, !newLink.Reserved);
    FirstQh->HwQH.HLink = newLink;
    FirstQh->NextQh = LinkQh;

    SET_FLAG(LinkQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciUnlinkQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh
    )
/*++

Routine Description:

   Remove an async queue head from the HW list.

Arguments:


--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR nextQh, prevQh;

    UHCI_ASSERT(DeviceData,
                TEST_FLAG(Qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE) ||
                ((Qh->PrevQh == Qh) && (Qh->NextQh == Qh)));

    nextQh = Qh->NextQh;
    prevQh = Qh->PrevQh;

    // ASYNC QUEUE looks like this:
    //
    //|static QH|->|xfer QH|->|xfer QH|->
    //     |                            |
    //     -------------<----------------

    //
    // Check if this was the last bulk transfer. If so,
    // turn off the bulk bandwidth reclamation.
    //
    if (DeviceData->LastBulkQueueHead == Qh) {
        DeviceData->LastBulkQueueHead = prevQh;
    }

    // unlink
    LOGENTRY(DeviceData, G, '_Ulk', Qh, prevQh, nextQh);
    prevQh->HwQH.HLink = Qh->HwQH.HLink;
    prevQh->NextQh = nextQh;
    if (nextQh) {
        nextQh->PrevQh = prevQh;
    }

    // Protect ourselves from calling this function twice.
    Qh->NextQh = Qh->PrevQh = Qh;

    //
    // If this was a bulk QH, check if bulk bandwidth reclamation
    // is turned on. If so and there's nothing queued, then turn
    // it off. This is for the case where a device has become
    // unresponsive and the transfer is about to be aborted.
    //
    if (Qh->EndpointData->Parameters.TransferType == Bulk &&
        !DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate) {
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        BOOLEAN activeBulkTDs = FALSE;

        //
        // This loop skips the td that has been inserted for
        // the PIIX4 problem, since it starts with the qh
        // the bulk queuehead is pointing at.
        // If the bulk queuehead is not pointing at anything,
        // then we're fine too, since it will have been
        // turned off already.
        //
        for (qh = DeviceData->BulkQueueHead->NextQh;
             qh;
             qh = qh->NextQh) {
            if (!qh->HwQH.VLink.Terminate) {
                activeBulkTDs = TRUE;
                break;
            }
        }

        // qh is pointing at either the first queuehead
        // with transfers pending or the bulk queuehead.
        if (!activeBulkTDs) {
            UHCI_ASSERT(DeviceData, !qh)
            DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 1;
        }
    }

    CLEAR_FLAG(Qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciQueueTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PHCD_TRANSFER_DESCRIPTOR FirstTd,
    IN PHCD_TRANSFER_DESCRIPTOR LastTd
    )
/*++

Routine Description:

    Links a bunch of TDs into a queuehead.

Arguments:

--*/
{
    UHCI_ASSERT(DeviceData, FirstTd->PhysicalAddress & ~HW_LINK_FLAGS_MASK);
    UHCI_ASSERT(DeviceData, !(FirstTd->PhysicalAddress & HW_LINK_FLAGS_MASK));

    if (EndpointData->HeadTd) {
        PHCD_QUEUEHEAD_DESCRIPTOR qh;
        HW_32BIT_PHYSICAL_ADDRESS curTdPhys;

        // There's other transfer(s) queued. Add this one behind them.
        UHCI_ASSERT(DeviceData, EndpointData->TailTd);
        EndpointData->TailTd->NextTd = FirstTd;
        EndpointData->TailTd->HwTD.LinkPointer.HwAddress =
            FirstTd->PhysicalAddress;

        // Get the qh and current td
        qh = EndpointData->QueueHead;

        curTdPhys = qh->HwQH.VLink.HwAddress & ~HW_LINK_FLAGS_MASK;

        // If there is nothing on this queuehead, then we may have been
        // unsuccessful in queueing the transfer. Checking the active
        // bit on the td will tell us for sure.

        LOGENTRY(DeviceData, G, '_tqa', FirstTd, curTdPhys,
                 FirstTd->HwTD.Control.Active);

        LOGENTRY(DeviceData, G, '_ttd', EndpointData->TailTd,
                 EndpointData->TailTd->PhysicalAddress,
                 EndpointData->TailTd->HwTD.Control.Active);

        if (FirstTd->HwTD.Control.Active) {
            if ((curTdPhys == EndpointData->TailTd->PhysicalAddress &&
                 !EndpointData->TailTd->HwTD.Control.Active)) {
                TD_LINK_POINTER newLink;

                // Since the prior transfer had already completed when
                // we tried to queue the transfer, we need to add this td
                // directly into the hardware queuehead.

                // Note that the HC could be in the middle of updating the
                // queuehead's link pointer. That's what the second part of
                // the if statement above is for.

                // DO NOT call LOGENTRY until we set the queuehead!
                // This would cause a delay that might be bad.

                newLink.HwAddress = FirstTd->PhysicalAddress;
                newLink.Terminate = 0;
                newLink.QHTDSelect = 0;
                qh->HwQH.VLink = newLink;
                LOGENTRY(DeviceData, G, '_nlk', FirstTd, EndpointData,
                         EndpointData->HeadTd);
            }
        }

    } else {

        // There's no other transfers queued currently.
        SET_QH_TD(DeviceData, EndpointData, FirstTd);
    }
    if (EndpointData->Parameters.TransferType == Bulk) {

        // Turn bulk bandwidth reclamation back on.
        DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 0;
    }
    EndpointData->TailTd = LastTd;
}

ULONG
UhciMapAsyncTransferToTds(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_CONTEXT TransferContext,
    PHCD_TRANSFER_DESCRIPTOR *FirstDataTd,
    PHCD_TRANSFER_DESCRIPTOR *LastDataTd,
    PTRANSFER_SG_LIST SgList
    )
/*++

Routine Description:

    Maps an asynchronous transfer into the TDs
    required to complete the transfer, including
    any double buffering necessary for page boundaries.

Arguments:

Return Value:

--*/
{
    // indices and offsets
    ULONG sgIdx, sgOffset, i;
    // lengths
    ULONG lengthThisTd, bytesRemaining, mappedNextSg, lengthMapped = 0;
    USHORT maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    // structure pointers
    PTRANSFER_PARAMETERS tp = TransferContext->TransferParameters;
    PASYNC_TRANSFER_BUFFER buffer = NULL;
    PHCD_TRANSFER_DESCRIPTOR lastTd = NULL, td;
    HW_32BIT_PHYSICAL_ADDRESS address;
    UCHAR pid;

    ULONG toggle;
    BOOLEAN pageCrossing = FALSE;
    BOOLEAN ZeroLengthTransfer = (SgList->SgCount == 0 &&
                                  EndpointData->Parameters.TransferType != Control);

    if (EndpointData->Parameters.TransferType == Control) {

        // Control pipes are bi-directional. Get the direction from the
        // transfer parameters.
        if (TEST_FLAG(tp->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
            pid = InPID;
        } else {
            pid = OutPID;
        }
        // THe setup packet is Toggle 0.
        toggle = DataToggle1;
    } else {

        // All other pipes are uni-directional. Determine
        // the direction from the endpoint address.
        pid = GetPID(EndpointData->Parameters.EndpointAddress);
        // We have to continue the toggle pattern for bulk and interrupt.
        toggle = EndpointData->Toggle;
    }
    // lastTd points to the last data TD or the setup
    // if there was no data.

    for (i = 0; i<SgList->SgCount || ZeroLengthTransfer; i++) {

        LOGENTRY(DeviceData, G, '_sgc', SgList->SgCount, i, 0);

        address = SgList->SgEntry[i].LogicalAddress.Hw32;
        UHCI_ASSERT(DeviceData, address || ZeroLengthTransfer);
        bytesRemaining = SgList->SgEntry[i].Length;
        UHCI_ASSERT(DeviceData, bytesRemaining || ZeroLengthTransfer);

        LOGENTRY(DeviceData, G, '_sgX', SgList->SgEntry[i].Length, i,
            SgList->SgEntry[i].LogicalAddress.Hw32);

        if (pageCrossing) {

            // We have a page crossing here, so this one is double-buffered.
            address += mappedNextSg;
            bytesRemaining -= mappedNextSg;
        }
        mappedNextSg = 0;
        pageCrossing = FALSE;
        while (bytesRemaining || ZeroLengthTransfer) {
            ZeroLengthTransfer = FALSE;
            LOGENTRY(DeviceData, G, '_sg1', bytesRemaining, 0, 0);
            if (bytesRemaining < maxPacketSize) {
                if (i+1 < SgList->SgCount) {

                    // We have to double buffer this TD since it crosses a page
                    // boundary. We will always cross a page boundary now.
                    LOGENTRY(DeviceData, G, '_sg2', bytesRemaining, 0, 0);
                    pageCrossing = TRUE;
                    if (SgList->SgEntry[i+1].Length + bytesRemaining >= maxPacketSize) {
                        mappedNextSg = maxPacketSize - bytesRemaining;
                        lengthThisTd = maxPacketSize;
                    } else {
                        lengthThisTd = SgList->SgEntry[i+1].Length + bytesRemaining;
                        mappedNextSg = SgList->SgEntry[i+1].Length;
                    }

                    buffer = (PASYNC_TRANSFER_BUFFER)
                                UHCI_ALLOC_DB(DeviceData, EndpointData, FALSE);
                    UHCI_ASSERT(DeviceData, buffer);
                    UHCI_ASSERT(DeviceData, buffer->Sig == SIG_HCD_ADB);
                    UHCI_ASSERT(DeviceData, buffer->PhysicalAddress);
                    buffer->SystemAddress = SgList->MdlSystemAddress + lengthMapped;
                    UhciKdPrint((DeviceData, 2, "'Double buffer %x address %x offset %x\n", buffer, buffer->SystemAddress, lengthMapped));
                    buffer->Size = lengthThisTd;
                    UHCI_ASSERT(DeviceData, lengthThisTd <= MAX_ASYNC_PACKET_SIZE);
                    if (OutPID == pid) {
                        RtlCopyMemory(&buffer->Buffer[0],
                                      buffer->SystemAddress,
                                      lengthThisTd);
                    }
                    // Change the address for the TD
                    address = buffer->PhysicalAddress;
                    bytesRemaining = 0;
                } else {

                    // Last TD
                    LOGENTRY(DeviceData, G, '_sg3', bytesRemaining, 0, 0);
                    lengthThisTd = bytesRemaining;
                    bytesRemaining = 0;
                }
            } else {

                // Normal, non-buffered case.
                LOGENTRY(DeviceData, G, '_sg4', bytesRemaining, 0, 0);
                lengthThisTd = maxPacketSize;
                bytesRemaining -= lengthThisTd;

                UHCI_ASSERT(DeviceData, lengthThisTd <= SgList->SgEntry[i].Length);
            }

            TransferContext->PendingTds++;

            //
            // Allocate and initialize an async TD
            //
            td = UHCI_ALLOC_TD(DeviceData, EndpointData);
            INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

            td->HwTD.Token.Pid = pid;
            td->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(lengthThisTd);
            td->HwTD.Token.DataToggle = toggle;
            td->HwTD.Control.ShortPacketDetect = 1;
            td->HwTD.Control.ActualLength = MAXIMUM_LENGTH(0);
            td->HwTD.Buffer = address;
            if (pageCrossing) {
                SET_FLAG(td->Flags, TD_FLAG_DOUBLE_BUFFERED);
                td->DoubleBuffer = (PTRANSFER_BUFFER) buffer;
            }

            address += lengthThisTd;
            lengthMapped += lengthThisTd;

            if (lastTd) {
                SET_NEXT_TD(lastTd, td);
            } else {
                *FirstDataTd = td;
            }
            lastTd = td;
            toggle = !toggle;
        } // while
    }

    *LastDataTd = lastTd;
    EndpointData->Toggle = toggle;

    UHCI_ASSERT(DeviceData, TransferContext->TransferParameters->TransferBufferLength == lengthMapped);

    return lengthMapped;
}

USB_MINIPORT_STATUS
UhciControlTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize a control transfer

Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR lastDataTd, firstDataTd, setupTd, statusTd;
    PASYNC_TRANSFER_BUFFER setupPacket;
    ULONG lengthMapped, dataTDCount = 0;

    // we have enough tds, program the transfer

    UhciKdPrint((DeviceData, 2, "'Control transfer on EP %x\n", EndpointData));

    LOGENTRY(DeviceData, G, '_CTR', EndpointData, TransferParameters, TransferContext);

    // bugbug should check here in advance to see if there enough
    // TDs if so proceed otherwise return status_busy.
    if (EndpointData->PendingTransfers > 1) {
        DecPendingTransfers(DeviceData, EndpointData);
        return USBMP_STATUS_BUSY;
    }

    // First prepare a TD for the setup packet. Grab the dummy TD from
    // the tail of the queue.
    TransferContext->PendingTds++;
    setupTd = UHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(setupTd, TransferContext);

    // Move setup data into TD (8 chars long).
    // We use a double buffer for this.
    setupTd->DoubleBuffer = UHCI_ALLOC_DB(DeviceData, EndpointData, FALSE);
    setupPacket = (PASYNC_TRANSFER_BUFFER) setupTd->DoubleBuffer;
    RtlCopyMemory(&setupPacket->Buffer[0],
                  &TransferParameters->SetupPacket[0],
                  8);
    setupTd->HwTD.Buffer = setupPacket->PhysicalAddress;
    SET_FLAG(setupTd->Flags, TD_FLAG_DOUBLE_BUFFERED);

    setupTd->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(8);
    setupTd->HwTD.Token.Pid = SetupPID;
    // setup stage is always toggle 0
    setupTd->HwTD.Token.DataToggle = DataToggle0;

    LOGENTRY(DeviceData,
             G, '_set',
             setupTd,
             *((PLONG) &TransferParameters->SetupPacket[0]),
             *((PLONG) &TransferParameters->SetupPacket[4]));

    // allocate the status phase TD now so we can
    // point the data TDs to it
    TransferContext->PendingTds++;
    statusTd = UHCI_ALLOC_TD(DeviceData, EndpointData);
    INITIALIZE_TD_FOR_TRANSFER(statusTd, TransferContext);

    // now setup the data phase
    lastDataTd = firstDataTd = NULL;
    lengthMapped =
        UhciMapAsyncTransferToTds(DeviceData,
                                  EndpointData,
                                  TransferContext,
                                  &firstDataTd,
                                  &lastDataTd,
                                  TransferSGList);

    if (firstDataTd && firstDataTd) {

        // Join the setup to the front and the status to the end.
        SET_NEXT_TD(setupTd, firstDataTd);
        SET_NEXT_TD(lastDataTd, statusTd);
    } else {

        // Join the setup to the status. No data stage.
        SET_NEXT_TD(setupTd, statusTd);
    }

    // now do the status phase

    // no bufferQueueHead
    statusTd->HwTD.Buffer = 0;
    statusTd->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(0);
    // status stage is always toggle 1
    statusTd->HwTD.Token.DataToggle = DataToggle1;
    statusTd->HwTD.Control.InterruptOnComplete = 1;
    SET_FLAG(statusTd->Flags, TD_FLAG_STATUS_TD);

    // status phase is opposite data dirrection
    if (TEST_FLAG(TransferParameters->TransferFlags, USBD_TRANSFER_DIRECTION_IN)) {
        statusTd->HwTD.Token.Pid = OutPID;
    } else {
        statusTd->HwTD.Token.Pid = InPID;
    }

    SET_NEXT_TD_NULL(statusTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, setupTd->PhysicalAddress, setupTd);

    // Attach the setup TD to the queuehead
    UhciQueueTransfer(DeviceData, EndpointData, setupTd, statusTd);

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
UhciBulkOrInterruptTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
/*++

Routine Description:

    Initialize interrupt or bulk Transfer

Arguments:


--*/
{
    PHCD_TRANSFER_DESCRIPTOR firstTd, lastTd;
    ULONG lengthMapped;
    ULONG maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    ULONG i, numTds;

    UhciKdPrint((DeviceData, 2, "'BIT transfer on EP %x\n", EndpointData));
    UhciKdPrint((DeviceData, 2, "'BIT transfer length %d\n",
        TransferParameters->TransferBufferLength));

    LOGENTRY(DeviceData, G, '_BIT', EndpointData, TransferParameters, TransferContext);

    // Do we have enough free resources?
    for (i = 0, lengthMapped = 0; i < TransferSGList->SgCount; i++) {
        lengthMapped += TransferSGList->SgEntry[i].Length;
    }
    numTds = lengthMapped == 0 ? 1 :
        (lengthMapped + maxPacketSize - 1) / maxPacketSize;
    if (EndpointData->TdCount - EndpointData->TdsUsed < numTds) {

        // Not enough TDs to do this transfer yet.
        // Tell the port driver to wait.
        UhciKdPrint((DeviceData, 2, "'BIT must wait on EP %x. Not enough tds.\n", EndpointData));
        return USBMP_STATUS_BUSY;
    }
    if (TransferSGList->SgCount > 1 &&
        TransferSGList->SgEntry[0].Length % maxPacketSize != 0) {

        // We'll need DBs. Do we have enough?
        if (EndpointData->DbCount - EndpointData->DbsUsed <
            (lengthMapped + PAGE_SIZE - 1)/PAGE_SIZE) {

            // Not enough DBs to do this transfer yet.
            // Tell the port driver to wait.
            UhciKdPrint((DeviceData, 2, "'BIT must wait on EP %x. Not enough dbs.\n", EndpointData));
            return USBMP_STATUS_BUSY;
        }
    }

    // we have enough tds, program the transfer
    // now setup the data phase
    lastTd = firstTd = NULL;
    lengthMapped =
        UhciMapAsyncTransferToTds(DeviceData,
                                  EndpointData,
                                  TransferContext,
                                  &firstTd,
                                  &lastTd,
                                  TransferSGList);

    UHCI_ASSERT(DeviceData, lastTd && firstTd);

    lastTd->HwTD.Control.InterruptOnComplete = 1;

    SET_NEXT_TD_NULL(lastTd);

    // put the request on the hardware queue
    LOGENTRY(DeviceData, G,
        '_Tal',  TransferContext->PendingTds, firstTd->PhysicalAddress, firstTd);

    // Attach the first TD to the queuehead
    UhciQueueTransfer(DeviceData, EndpointData, firstTd, lastTd);

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciSetAsyncEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ENDPOINT_TRANSFER_TYPE epType;
    ULONG interruptQHIndex;

    LOGENTRY(DeviceData, G, '_Sas', EndpointData, State, 0);

    qh = EndpointData->QueueHead;

    epType = EndpointData->Parameters.TransferType;

    switch(State) {
    case ENDPOINT_ACTIVE:
        switch (epType) {
        case Interrupt:
            // put queue head in the schedule
            interruptQHIndex = EndpointData->Parameters.ScheduleOffset +
                QH_INTERRUPT_INDEX(EndpointData->Parameters.Period);
            UhciInsertQh(DeviceData,
                         DeviceData->InterruptQueueHeads[interruptQHIndex],
                         qh);
            break;
        case Control:
            // put queue head in the schedule
            UhciInsertQh(DeviceData, DeviceData->ControlQueueHead, qh);
            break;
        case Bulk:
            // put queue head in the schedule
            UhciInsertQh(DeviceData, DeviceData->BulkQueueHead, qh);
            break;
        default:
            TEST_TRAP()
            break;
        }
        break;

    case ENDPOINT_PAUSE:
        // remove queue head from the schedule
        switch (epType) {
        case Interrupt:
        case Bulk:
        case Control:
            //
            // Just flip the active bits at this point.
            //
            UhciUnlinkQh(DeviceData, qh);
            break;
        default:
            TEST_TRAP()
            break;
        }
        break;

    case ENDPOINT_REMOVE:
        qh->QhFlags |= UHCI_QH_FLAG_QH_REMOVED;

        switch (epType) {
        case Interrupt:
        case Bulk:
        case Control:
            // remove from the schedule and
            // free bandwidth

            // free the bw
    //        EndpointData->StaticEd->AllocatedBandwidth -=
    //            EndpointData->Parameters.Bandwidth;

            UhciUnlinkQh(DeviceData, qh);
            break;
        default:
            TEST_TRAP();
            break;
        }
        break;

    default:

        TEST_TRAP();
    }
}


VOID
UhciProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    PTRANSFER_PARAMETERS tp;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    ULONG byteCount;

    transferContext = Td->TransferContext;
    ASSERT_TRANSFER(DeviceData, transferContext);

    tp = transferContext->TransferParameters;
    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;

    if (TEST_FLAG(Td->Flags, TD_FLAG_SKIP)) {
        LOGENTRY(DeviceData, G, '_Ktd', transferContext,
                         0,
                         Td);

        goto free_it;
    }

    if (TEST_FLAG(endpointData->Flags, UHCI_EDFLAG_HALTED)) {

        // completion status for this TD?
        // since the endpoint halts on error and short packet,
        // the error bits should have been written back to the TD
        // we use these bits to dermine the error
        usbdStatus = UhciGetErrorFromTD(DeviceData,
                                        Td);
    }

    LOGENTRY(DeviceData, G, '_Dtd', transferContext,
                         usbdStatus,
                         Td);

    // Only count the bytes transferred if we were successful (as per uhcd).
    byteCount = (usbdStatus == USBD_STATUS_SUCCESS) ? ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) : 0;

    LOGENTRY(DeviceData, G, '_tln', byteCount, 0, 0);

    if (Td->HwTD.Token.Pid != SetupPID) {

        // data or status phase of a control transfer or a bulk/int
        // data transfer
        LOGENTRY(DeviceData, G, '_Idt', Td, transferContext, byteCount);

        transferContext->BytesTransferred += byteCount;

    }

    // For double buffered transfers, we now have to copy back
    // if this was an IN transfer.
    //
    if (Td->HwTD.Token.Pid == InPID &&
        TEST_FLAG(Td->Flags, TD_FLAG_DOUBLE_BUFFERED)) {
        PASYNC_TRANSFER_BUFFER buffer = &Td->DoubleBuffer->Async;
        UHCI_ASSERT(DeviceData, TEST_FLAG(buffer->Flags, DB_FLAG_BUSY));
        UhciKdPrint((DeviceData, 2, "'Copy back %x address %x\n", buffer, buffer->SystemAddress));
        RtlCopyMemory(buffer->SystemAddress,
                      buffer->Buffer,
                      buffer->Size);

        // tell usbport we double buffered so it can
        // triple buffer if necessary
        USBPORT_NOTIFY_DOUBLEBUFFER(DeviceData,
                                    tp,
                                    buffer->SystemAddress,
                                    buffer->Size);
    }

    // note that we only set transferContext->UsbdStatus
    // if we find a TD with an error this will cause us to
    // record the last TD with an error as the error for
    // the transfer.
    if (USBD_STATUS_SUCCESS != usbdStatus) {

        UhciKdPrint((DeviceData, 2, "'Error, usbdstatus %x", usbdStatus));

        // map the error to code in USBDI.H
        transferContext->UsbdStatus = usbdStatus;

        LOGENTRY(DeviceData, G, '_tER', transferContext->UsbdStatus, 0, 0);
    }

free_it:

    // mark the TD free
    UHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {

        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        DecPendingTransfers(DeviceData, endpointData);

        LOGENTRY(DeviceData, G, '_Cat',
            transferContext->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);

        UhciKdPrint((DeviceData, 2, "'Complete transfer w/ usbdstatus %x\n", transferContext->UsbdStatus));

        USBPORT_COMPLETE_TRANSFER(DeviceData,
                                  endpointData,
                                  tp,
                                  transferContext->UsbdStatus,
                                  transferContext->BytesTransferred);
    }
}


VOID
UhciPollAsyncEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete any associated transfers.

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_DESCRIPTOR td, currentTd;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    HW_QUEUE_ELEMENT_TD overlay;
    HW_32BIT_PHYSICAL_ADDRESS curTdPhys, tmpPhys;
    ULONG i, j;
    PTRANSFER_CONTEXT transferContext, tmp;
    PTRANSFER_PARAMETERS tp;
    ULONG halted, active;
    BOOLEAN processed;

    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {

        // Endpoint is halted. Don't do anything.
        return;
    }

    //  get the queue head and current td
    qh = EndpointData->QueueHead;

    curTdPhys =  qh->HwQH.VLink.HwAddress;

    curTdPhys &= ~HW_LINK_FLAGS_MASK;

    // now convert the physical 'current' to a virtual address
    currentTd = curTdPhys ? (PHCD_TRANSFER_DESCRIPTOR)
        USBPORT_PHYSICAL_TO_VIRTUAL(curTdPhys,
                                    DeviceData,
                                    EndpointData) :
        (PHCD_TRANSFER_DESCRIPTOR) NULL;

    LOGENTRY(DeviceData, G, '_ctd', curTdPhys, currentTd, EndpointData);

    // walk the TD list up to the current TD and complete
    // all those TDs

    for (td = EndpointData->HeadTd; td != currentTd && td; td = td->NextTd) {
        SET_FLAG(td->Flags, TD_FLAG_DONE);
        InsertTailList(&EndpointData->DoneTdList,
                       &td->DoneLink);

        // Is the queuehead pointing to nothing, but there are still
        // tds available to be queued?
        if (td->NextTd &&
            td->NextTd->HwTD.Control.Active) {
            if (!curTdPhys) {
                TD_LINK_POINTER newLink;

                // A transfer didn't make it onto the hardware because
                // the queuehead's td field wasn't set properly
                // in UhciQueueTransfer.

                // PERF NOTE: Because we're not making sure that the
                // transfer gets queued immediately, the transfer could
                // be delayed in making it onto the hardware. Better
                // late than never, though...

                EndpointData->HeadTd = currentTd = td->NextTd;

                LOGENTRY(DeviceData, G, '_Dly', currentTd, curTdPhys, qh);

                goto UhciPollAsyncEndpointSetNext;
            } else if (curTdPhys != td->NextTd->PhysicalAddress) {
                LOGENTRY(DeviceData, G, '_QEr', curTdPhys, td->NextTd->PhysicalAddress, td->NextTd);

                UHCI_ASSERT (DeviceData, FALSE);
            }

        }
    }

    EndpointData->HeadTd = currentTd;

    if (currentTd) {
        LOGENTRY(DeviceData, G, '_cTD', currentTd,
                 curTdPhys,
                 currentTd->TransferContext);

        // If active, get out of here.
        if (currentTd->HwTD.Control.Active) {
            ;// fall thru to completing whatever's completed;
        } else if ((currentTd->HwTD.Token.Pid           == InPID) &&
                   (currentTd->HwTD.Control.Stalled         == 1) &&
                   (currentTd->HwTD.Control.BabbleDetected  == 0) &&
                   (currentTd->HwTD.Control.NAKReceived     == 0) &&
                   (currentTd->HwTD.Control.TimeoutCRC      == 1) &&
                   (currentTd->HwTD.Control.BitstuffError   == 0) &&
                   !TEST_FLAG(currentTd->Flags, TD_FLAG_TIMEOUT_ERROR)) {

            // If this is the first time that the device or hc has been
            // unresponsive, cut it a break and try the transfer again.

            // Note that we don't check currentTd->HwTD.Control.DataBufferError
            // since a value of:
            //    1 means host controller did not respond to IN data sent by device
            //    0 means device did not NAK IN request.

            SET_FLAG(currentTd->Flags, TD_FLAG_TIMEOUT_ERROR);

            currentTd->HwTD.Control.ErrorCount = 3;

            currentTd->HwTD.Control.Stalled    = 0;
            currentTd->HwTD.Control.TimeoutCRC = 0;
            currentTd->HwTD.Control.Active     = 1;

        } else if (currentTd->HwTD.Control.Stalled ||
                   currentTd->HwTD.Control.DataBufferError ||
                   currentTd->HwTD.Control.BabbleDetected ||
                   currentTd->HwTD.Control.TimeoutCRC ||
                   currentTd->HwTD.Control.BitstuffError) {

            SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            //
            // Error. We need to flush.
            //
            // Flush all completed tds
            //
            // Complete transfer with error.
            // if the endpoint is halted we need to complete
            // the 'current' tarnsfer with an error walk all
            // the tds for the current transfer and mark
            // any that are not done as 'skipped'.

            UhciKdPrint((DeviceData, 2, "'Error on EP %x\n", EndpointData));

            LOGENTRY(DeviceData, G, '_erT', qh, currentTd, currentTd->HwTD.Control.ul);
            transferContext = currentTd->TransferContext;
            tp = transferContext->TransferParameters;

            SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
            InsertTailList(&EndpointData->DoneTdList,
                           &currentTd->DoneLink);
            // Skip all the remaining TDs in this transfer

            UHCI_ASSERT(DeviceData, td->TransferContext == transferContext);
            for (td;
                 td &&
                 td->TransferContext->TransferParameters->SequenceNumber == tp->SequenceNumber;
                 td = td->NextTd) {

                if (!TEST_FLAG(td->Flags, TD_FLAG_DONE)) {

                    LOGENTRY(DeviceData, G, '_skT', qh, 0, td);
                    SET_FLAG(td->Flags, (TD_FLAG_DONE | TD_FLAG_SKIP));
                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                }
            }

            if (EndpointData->Parameters.TransferType != Control) {

                // Loop through all the remaining TDs for this
                // endpoint and fix the data toggle.
                UhciFixDataToggle(
                    DeviceData,
                    EndpointData,
                    td,
                    currentTd->HwTD.Token.DataToggle);
            }
            SET_QH_TD(DeviceData, EndpointData, td);

        } else if (ACTUAL_LENGTH(currentTd->HwTD.Control.ActualLength) <
                   ACTUAL_LENGTH(currentTd->HwTD.Token.MaximumLength)) {

            //
            // Short packet. We need to flush.
            //
            // Flush all completed tds
            //
            // we need to walk all the tds for the current
            // transfer and mark any that are not done as
            // 'skipped'. EXCEPT if the last TD is a status
            // phase of a control transfer, in which case
            // we have to queue that one up.
            //
            tp = currentTd->TransferContext->TransferParameters;

            UhciKdPrint((DeviceData, 2, "'Short packet on EP %x\n", EndpointData));

            LOGENTRY(DeviceData, G, '_shP', qh, currentTd, currentTd->HwTD.Control.ul);

            SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
            InsertTailList(&EndpointData->DoneTdList,
                           &currentTd->DoneLink);

            // Skip all the remaining TDs in this transfer up to the status phase
            // If control transfer, queue up the status phase,
            // else go to the next transfer (if there is one).
            for (td;
                 td &&
                 td->TransferContext->TransferParameters->SequenceNumber == tp->SequenceNumber;
                 td = td->NextTd) {

                if (TEST_FLAG(td->Flags, TD_FLAG_STATUS_TD) &&
                    TEST_FLAG(tp->TransferFlags, USBD_SHORT_TRANSFER_OK)) {

                    // Queue up the status phase of the control transfer.
                    UHCI_ASSERT(DeviceData, EndpointData->Parameters.TransferType == Control);
                    break;
                }

                if (!TEST_FLAG(td->Flags, TD_FLAG_DONE)) {
                    LOGENTRY(DeviceData, G, '_skT', qh, 0, td);

                    SET_FLAG(td->Flags, (TD_FLAG_DONE | TD_FLAG_SKIP));

                    InsertTailList(&EndpointData->DoneTdList,
                                   &td->DoneLink);
                }
            }

            if (EndpointData->Parameters.TransferType != Control &&
                currentTd->NextTd) {

                // Loop through all the remaining TDs for this
                // endpoint and fix the data toggle.
                UhciFixDataToggle(
                    DeviceData,
                    EndpointData,
                    td,
                    currentTd->NextTd->HwTD.Token.DataToggle);
            }

            if (!TEST_FLAG(tp->TransferFlags, USBD_SHORT_TRANSFER_OK)) {
                SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            }

            // Next transfer or status phase of a control transfer.
            SET_QH_TD(DeviceData, EndpointData, td);

        } else {

            // Current td is not active.
            // If we're still pointing to the same td at this point in time,
            // then we're stuck and I have to manually advance the queuehead
            // to the next td.
            LOGENTRY(DeviceData, G, '_nuT', qh, currentTd, td);
            if (curTdPhys == (qh->HwQH.VLink.HwAddress & ~HW_LINK_FLAGS_MASK)) {

                // HW error. Td pointer for QH is not advancing.
                // Manually advance things.
                SET_FLAG(currentTd->Flags, TD_FLAG_DONE);
                InsertTailList(&EndpointData->DoneTdList,
                               &currentTd->DoneLink);
                                   
                EndpointData->HeadTd = currentTd->NextTd;
                qh->HwQH.VLink.HwAddress = currentTd->HwTD.LinkPointer.HwAddress;

                LOGENTRY(DeviceData, G, '_nu+', qh, currentTd, td);
            }
        }
    } else {

        // All transfers completed normally

UhciPollAsyncEndpointSetNext:
        // Flush all completed tds
        // Complete transfer

        // set the sw headp to the new current head
        // Next transfer or status phase of a control transfer.
        SET_QH_TD(DeviceData, EndpointData, currentTd);
    }
    
    // now flush all completed TDs. Do it in order of completion.

    while (!IsListEmpty(&EndpointData->DoneTdList)) {
    
        PLIST_ENTRY listEntry;
    
        listEntry = RemoveHeadList(&EndpointData->DoneTdList);
        
        
        td = (PHCD_TRANSFER_DESCRIPTOR) CONTAINING_RECORD(
                     listEntry,
                     struct _HCD_TRANSFER_DESCRIPTOR, 
                     DoneLink);
           

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            UhciProcessDoneAsyncTd(DeviceData, td);
        }
                                
    }
#if 0
    // now flush all completed TDs. Do it in order of allocation.
    for (i = (EndpointData->TdsUsed <= (EndpointData->TdLastAllocced+1)) ?
         (EndpointData->TdLastAllocced + 1) - EndpointData->TdsUsed :
         (EndpointData->TdLastAllocced + EndpointData->TdCount + 1) - EndpointData->TdsUsed, j=0;
         j < EndpointData->TdCount;
         j++, i = (i+1 < EndpointData->TdCount) ? i+1 : 0) {
        td = &EndpointData->TdList->Td[i];

        if ((td->Flags & (TD_FLAG_XFER | TD_FLAG_DONE)) ==
            (TD_FLAG_XFER | TD_FLAG_DONE)) {

            UhciProcessDoneAsyncTd(DeviceData, td);
        }
    }
#endif
    // certain types of endpoints do not halt eg control
    // we resume these endpoints here
    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_NOHALT) &&
        TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {

        LOGENTRY(DeviceData, G, '_clH', qh, 0, 0);

        UhciSetEndpointStatus(
            DeviceData,
            EndpointData,
            ENDPOINT_STATUS_RUN);

    }
}


VOID
UhciAbortAsyncTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
/*++

Routine Description:

    Aborts the specified transfer by freeing all the TDs
    associated with said transfer. The queuehead for this
    transfer will have already been removed from the
    hardware queue when a SetEndpointState (paused) was
    sent by the port driver.
    Note that if another transfer is queued on the same
    endpoint, we need to fix up the list structure. We
    will also fix up any toggle issues on bulk endpoints.

Arguments:

Return Value:

--*/

{

    PHCD_TRANSFER_DESCRIPTOR td;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR joinTd = NULL;
    BOOLEAN updateHead = FALSE;
    ULONG toggle;
    ULONG i;

    UhciKdPrint((DeviceData, 2, "'Abort async transfer on EP %x\n", EndpointData));

    qh = EndpointData->QueueHead;

    // The endpoint should not be in the schedule

    LOGENTRY(DeviceData, G, '_Aat', qh, TransferContext, 0);
    UHCI_ASSERT(DeviceData, !TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE));

    // our mission now is to remove all TDs associated with
    // this transfer

    // get the last known head, we update the head when we process
    // (AKA poll) the endpoint.

    UHCI_ASSERT(DeviceData, EndpointData->HeadTd);

    // Find the first TD in the transfer to abort
    for (td = EndpointData->HeadTd; td; td = td->NextTd) {
        if (td->TransferContext == TransferContext) {
            break;
        }
        joinTd = td;
    }
    UHCI_ASSERT(DeviceData, td);

    // Gonna have to fix up the toggle for bulk.
    toggle = td->HwTD.Token.DataToggle;

    // Was it the first transfer for this endpoint?
    if (td == EndpointData->HeadTd) {

        // This was the first queued transfer. Need to update the head.
        updateHead = TRUE;
    }

    UHCI_ASSERT(DeviceData, td->TransferContext == TransferContext);
    //
    // Loop through all the TDs for this transfer and free
    // them.
    //
    while (td) {
        if (td->TransferContext == TransferContext) {
            LOGENTRY(DeviceData, G, '_abT', qh, 0, td);

            // if the TD completed we need to track the data
            if (td->HwTD.Control.Active == 0) {
                TEST_TRAP();
                UhciProcessDoneAsyncTd(DeviceData, td);
            } else {
                UHCI_FREE_TD(DeviceData, EndpointData, td);
            }
        } else {
            // We're past the transfer to abort.
            break;
        }
        td = td->NextTd;
    }

    UhciFixDataToggle(DeviceData, EndpointData, td, toggle);

    if (updateHead) {

        // The transfer we removed was the first one.
        SET_QH_TD(DeviceData, EndpointData, td);
    } else {

        // The transfer we removed was not the first one.
        UHCI_ASSERT(DeviceData, joinTd);
        if (td) {

            // This was a middle transfer.
            SET_NEXT_TD(joinTd, td);
        } else {

            // The transfer we removed was the last one.
            EndpointData->TailTd = joinTd;
            SET_NEXT_TD_NULL(joinTd);
        }
    }

    *BytesTransferred = TransferContext->BytesTransferred;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\isoch.c ===
/*++

Copyright (c) 1999, 2000 Microsoft Corporation

Module Name:

   isoch.c

Abstract:

   miniport transfer code for Isochronous

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    8-1-00 : created, jsenior

--*/

#include "pch.h"


//implements the following miniport functions:

//non paged
//UhciIsochTransfer
//UhciProcessDoneIsochTd
//UhciPollIsochEndpoint
//UhciAbortIsochTransfer


USB_MINIPORT_STATUS
UhciIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

    Initialize all the TDs for an isochronous Transfer.
    Queue up whatever TDs we can in the current schedule.
    Whatever's left may get queued in the poll routine.

Arguments:


--*/
{
    // indices and offsets
    ULONG i, dbCount;
    // lengths
    ULONG lengthThisTd, lengthMapped = 0;
    USHORT maxPacketSize = EndpointData->Parameters.MaxPacketSize;
    // structure pointers
    PTRANSFER_PARAMETERS tp;
    PISOCH_TRANSFER_BUFFER buffer = NULL;
    PHCD_TRANSFER_DESCRIPTOR firstTd, td; //, lastTd = NULL;
    HW_32BIT_PHYSICAL_ADDRESS address;
    PMINIPORT_ISO_PACKET packet;
    BOOLEAN pageCrossing = FALSE;
    USBD_STATUS insertResult;
    USB_MINIPORT_STATUS mpStatus;
    // Isoch pipes are uni-directional. Get the
    // direction from the endpoint address.
    UCHAR pid = GetPID(EndpointData->Parameters.EndpointAddress);

    //
    // Do we have enough free resources?
    //
    if (EndpointData->TdCount - EndpointData->TdsUsed <
        IsoTransfer->PacketCount) {
        // Not enough TDs to do this transfer yet.
        // Tell the port driver to wait.
        return USBMP_STATUS_BUSY;
    }
    // We may need DBs. Do we have enough?
    for (i = 0, dbCount = 0; i < IsoTransfer->PacketCount; i++) {
        if (IsoTransfer->Packets[i].BufferPointerCount == 2) {
            dbCount++;
        }
    }
    if (EndpointData->DbCount - EndpointData->DbsUsed <
        dbCount) {
        // Not enough DBs to do this transfer yet.
        // Tell the port driver to wait.
        return USBMP_STATUS_BUSY;
    }

    UhciCleanOutIsoch(DeviceData, FALSE);

#if DBG
    {
    ULONG cf;
    cf = UhciGet32BitFrameNumber(DeviceData);
    LOGENTRY(DeviceData, G, '_iso', IsoTransfer->PacketCount, cf,
        IsoTransfer->Packets[0].FrameNumber);

    }
#endif
//    UhciKdPrint((DeviceData, 2, "'First packet frame number = %x\n", IsoTransfer->Packets[0].FrameNumber));
    IncPendingTransfers(DeviceData, EndpointData);

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_UHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = tp = TransferParameters;
    TransferContext->IsoTransfer = IsoTransfer;

    UHCI_ASSERT(DeviceData,
        EndpointData->Parameters.TransferType == Isochronous);

    LOGENTRY(DeviceData, G, '_isT', EndpointData, TransferParameters, IsoTransfer->Packets[0].FrameNumber);

    //
    // One TD per transfer.
    //
    for (i = 0; i < IsoTransfer->PacketCount; i++) {
        packet = &IsoTransfer->Packets[i];
        address = packet->BufferPointer0.Hw32;
        UHCI_ASSERT(DeviceData, address);
        UHCI_ASSERT(DeviceData, packet->BufferPointerCount == 1 ||
                    packet->BufferPointerCount == 2);

        //
        // Is this packet ok to transfer?
        //
        UhciCheckIsochTransferInsertion(DeviceData,
                                        insertResult,
                                        packet->FrameNumber);
        if (USBD_ERROR(insertResult)) {
            // Not ok to transfer. Try the next one.
            packet->UsbdStatus = insertResult;

            lengthMapped +=
                packet->BufferPointer0Length + packet->BufferPointer1Length;
            LOGENTRY(DeviceData, G, '_BSF', UhciGet32BitFrameNumber(DeviceData), IsoTransfer->Packets[i].FrameNumber, i);
            continue;
        }

        if (packet->BufferPointerCount == 1) {
            //
            // Normal, non-buffered case.
            //
            pageCrossing = FALSE;
            lengthThisTd = packet->BufferPointer0Length;
        } else {
            //
            // Page crossing. Must double buffer this transfer.
            //
            lengthThisTd = packet->BufferPointer0Length + packet->BufferPointer1Length;

            buffer = (PISOCH_TRANSFER_BUFFER)
                        UHCI_ALLOC_DB(DeviceData, EndpointData, TRUE);
            UHCI_ASSERT(DeviceData, buffer);
            UHCI_ASSERT(DeviceData, buffer->Sig == SIG_HCD_IDB);
            UHCI_ASSERT(DeviceData, buffer->PhysicalAddress);
            buffer->SystemAddress = IsoTransfer->SystemAddress + lengthMapped;
            buffer->Size = lengthThisTd;
            UHCI_ASSERT(DeviceData, lengthThisTd <= MAX_ISOCH_PACKET_SIZE);
            if (OutPID == pid) {
                RtlCopyMemory(&buffer->Buffer[0],
                              buffer->SystemAddress,
                              lengthThisTd);
            }
            // Change the address for the TD
            pageCrossing = TRUE;
            address = buffer->PhysicalAddress;
        }

        TransferContext->PendingTds++;

        td = UHCI_ALLOC_TD(DeviceData, EndpointData);
        INITIALIZE_TD_FOR_TRANSFER(td, TransferContext);

        //
        // Initialize the TD fields
        //
        td->HwTD.Token.Pid = pid;
        td->HwTD.Token.MaximumLength = MAXIMUM_LENGTH(lengthThisTd);
        td->HwTD.Token.DataToggle = DataToggle0;
        td->HwTD.Control.IsochronousSelect = 1;
        td->HwTD.Control.ShortPacketDetect = 0; // Don't care about short packets
        td->HwTD.Control.ActualLength = MAXIMUM_LENGTH(0);
        td->HwTD.Control.ErrorCount = 0;
        td->HwTD.Buffer = address;
        td->IsoPacket = packet;
        if (pageCrossing) {
            SET_FLAG(td->Flags, TD_FLAG_DOUBLE_BUFFERED);
            td->DoubleBuffer = (PTRANSFER_BUFFER) buffer;
        }
//        countIOC = countIOC + 1 == 10 ? 0 : countIOC+1;
        //
        // Request some interrupts near the end of the
        // transfer
        td->HwTD.Control.InterruptOnComplete =
            (i+1 >= IsoTransfer->PacketCount) ? 1 : 0; //!countIOC;

        address += lengthThisTd;
        lengthMapped += lengthThisTd;

        if (USBD_STATUS_SUCCESS == insertResult) {
            //
            // Put the TD in the schedule
            //
            LOGENTRY(DeviceData, G, '_qi1', td, 0, packet->FrameNumber);
            INSERT_ISOCH_TD(DeviceData, td, packet->FrameNumber);
        }
    }

    if (!TransferContext->PendingTds) {
        // Nothing got queued. Complete the transfer.
        DecPendingTransfers(DeviceData, EndpointData);

        LOGENTRY(DeviceData, G, '_cpt',
            packet->UsbdStatus,
            TransferContext,
            TransferContext->BytesTransferred);

        USBPORT_INVALIDATE_ENDPOINT(DeviceData, EndpointData);

        UhciKdPrint((DeviceData, 2, "'No tds queued for isoch tx.\n", EndpointData));
        // return error and port will complete the transfer
        mpStatus = USBMP_STATUS_FAILURE;
    } else {
        mpStatus = USBMP_STATUS_SUCCESS;
    }

    UHCI_ASSERT(DeviceData, TransferContext->TransferParameters->TransferBufferLength == lengthMapped);

    return mpStatus;
}


VOID
UhciProcessDoneIsochTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    process a completed isoch TD

Parameters

--*/
{
    PTRANSFER_CONTEXT transferContext;
    PENDPOINT_DATA endpointData;
    ULONG byteCount;
    PMINIPORT_ISO_PACKET packet;

    transferContext = Td->TransferContext;
    ASSERT_TRANSFER(DeviceData, transferContext);

    transferContext->PendingTds--;
    endpointData = transferContext->EndpointData;
    packet = Td->IsoPacket;
    UHCI_ASSERT(DeviceData, packet);

    if (!TEST_FLAG(Td->Flags, TD_FLAG_ISO_QUEUED)) {
        packet->UsbdStatus = USBD_STATUS_BAD_START_FRAME;
    } else if (Td->HwTD.Control.Active) {
        packet->UsbdStatus = USBD_STATUS_NOT_ACCESSED;
    } else {
        // completion status for this TD/packet?
        packet->UsbdStatus = UhciGetErrorFromTD(DeviceData, Td);
    }

    LOGENTRY(DeviceData, G, '_Dit', transferContext,
                         packet->UsbdStatus,
                         Td);

    byteCount = ACTUAL_LENGTH(Td->HwTD.Control.ActualLength);

    transferContext->BytesTransferred += byteCount;
    packet->LengthTransferred = byteCount;

    //
    // For double buffered transfers, we now have to copy back
    // if this was an IN transfer.
    //
    if (Td->HwTD.Token.Pid == InPID &&
        TEST_FLAG(Td->Flags, TD_FLAG_DOUBLE_BUFFERED)) {
        PISOCH_TRANSFER_BUFFER buffer = (PISOCH_TRANSFER_BUFFER)Td->DoubleBuffer;
        UHCI_ASSERT(DeviceData, TEST_FLAG(buffer->Flags, DB_FLAG_BUSY));
        RtlCopyMemory(buffer->SystemAddress,
                      &buffer->Buffer[0],
                      buffer->Size);
    }

    // mark the TD free
    // This also frees any double buffers.
    UHCI_FREE_TD(DeviceData, endpointData, Td);

    if (transferContext->PendingTds == 0) {
        // all TDs for this transfer are done
        // clear the HAVE_TRANSFER flag to indicate
        // we can take another
        DecPendingTransfers(DeviceData, endpointData);

        LOGENTRY(DeviceData, G, '_cit',
            packet->UsbdStatus,
            transferContext,
            transferContext->BytesTransferred);

        transferContext->TransferParameters->FrameCompleted =
            UhciGet32BitFrameNumber(DeviceData);

        USBPORT_COMPLETE_ISOCH_TRANSFER(
            DeviceData,
            endpointData,
            transferContext->TransferParameters,
            transferContext->IsoTransfer);
    }
}

VOID
UhciPollIsochEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Called when the endpoint 'needs attention'

    The goal here is to determine which TDs, if any,
    have completed and complete any associated transfers.

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;
    PMINIPORT_ISO_PACKET packet;
    USBD_STATUS insertResult;

    LOGENTRY(DeviceData, G, '_PiE', EndpointData, 0, 0);

    //
    // Cleanup the isoch transfers that haven't completed yet.
    //
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Flush all completed TDs and
    // queue up TDs that were pended.
    //
    // Don't care about errors.
    // Just get 'em out of here.
    //
    for (i = 0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        if (TEST_FLAG(td->Flags, TD_FLAG_XFER)) {
            if (td->IsoPacket->FrameNumber < DeviceData->LastFrameProcessed ||
                td->IsoPacket->FrameNumber - DeviceData->LastFrameProcessed > UHCI_MAX_FRAME) {
                //
                // Done, whether we like it or not.
                //
                td->Flags |= TD_FLAG_DONE;
            } else if (!TEST_FLAG(td->Flags, TD_FLAG_ISO_QUEUED)) {
                packet = td->IsoPacket;
                UhciKdPrint((DeviceData, 0, "'Late TD\n"));
                UhciCheckIsochTransferInsertion(DeviceData,
                                                insertResult,
                                                packet->FrameNumber);
                if (USBD_STATUS_SUCCESS == insertResult) {
                    //
                    // Put the TD in the schedule
                    //
                    LOGENTRY(DeviceData, G, '_qi2', td, 0, packet->FrameNumber);
                    INSERT_ISOCH_TD(DeviceData, td, packet->FrameNumber);
                }
            }

            if (TEST_FLAG(td->Flags, TD_FLAG_DONE)) {
                UhciProcessDoneIsochTd(DeviceData, td);
            }
        }
    }
}

VOID
UhciCleanOutIsoch(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN      ForceClean
    )
{
    ULONG i, currentFrame;

    if (1 != InterlockedIncrement(&DeviceData->SynchronizeIsoCleanup)) {
        InterlockedDecrement(&DeviceData->SynchronizeIsoCleanup);
        return;
    }
    //
    // Clean out the schedule, by pointing the frames
    // back to the interrupt QHs.
    //
    currentFrame = UhciGet32BitFrameNumber(DeviceData);

    if (currentFrame - DeviceData->LastFrameProcessed >= UHCI_MAX_FRAME ||
        ForceClean) {
        //
        // Schedule overrun.
        // Clean out all the frames.
        //
        UhciKdPrint((DeviceData, 2, "'Overrun L %x C %x\n", DeviceData->LastFrameProcessed, currentFrame));
        for (i = 0;
             i < UHCI_MAX_FRAME;
             i++) {
            UhciCleanFrameOfIsochTds (DeviceData, i);
        }
    } else {
        ULONG frameIndex;
        // normal cleanup of frames up to the current frame.
        frameIndex = ACTUAL_FRAME(currentFrame);
        UHCI_ASSERT(DeviceData, frameIndex < UHCI_MAX_FRAME);

        for (i = ACTUAL_FRAME(DeviceData->LastFrameProcessed);
             i != frameIndex;
             i = ACTUAL_FRAME(i+1)) {
            UhciCleanFrameOfIsochTds (DeviceData, i);
        }
    }
    DeviceData->LastFrameProcessed = currentFrame;

    InterlockedDecrement(&DeviceData->SynchronizeIsoCleanup);
}

VOID
UhciAbortIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext
    )
/*++

Routine Description:

    Aborts the specified Isoch transfer by freeing all
    the TDs associated with said transfer. The dequeuing
    of these transfers should have been done in the ISR
    where we clean out the schedule.

Arguments:

Return Value:

--*/

{

    PHCD_TRANSFER_DESCRIPTOR td;
    ULONG i;

    //
    // The endpoint should not be in the schedule
    //
    LOGENTRY(DeviceData, G, '_Ait', EndpointData, TransferContext, 0);

    UhciKdPrint((DeviceData, 2, "'Aborting isoch transfer %x\n", TransferContext));

    //
    // Cleanup the isoch transfers that haven't completed yet.
    //
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Free up all the tds in this transfer.
    //
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];
        if (td->TransferContext == TransferContext) {
            UHCI_FREE_TD(DeviceData, EndpointData, td);
        }
    }
}

VOID
UhciSetIsochEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    LOGENTRY(DeviceData, G, '_Sis', EndpointData, State, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\int.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    int.c

Abstract:

    interrupt service routine

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-26-00 : created, jsenior

--*/



#include "pch.h"


//implements the following miniport functions:

//non paged
//UhciInterruptService
//UhciInterruptDpc
//UhciDisableInterrupts
//UhciEnableInterrupts
//UhciRHDisableIrq
//UhciRHEnableIrq
//UhciInterruptNextSOF

BOOLEAN
UhciInterruptService (
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN usbInt;
    PHC_REGISTER reg;
//    USBINTR enabledIrqs;
    USBSTS irqStatus;

    reg = DeviceData->Registers;

    // assume it is not ours
    usbInt = FALSE;

    // see if we have lost the controller due to
    // a surprise remove
    if (UhciHardwarePresent(DeviceData) == FALSE) {
        return FALSE;
    }

    // get a mask of possible interrupts
//    enabledIrqs.us = READ_PORT_USHORT(&reg->UsbInterruptEnable.us);

    irqStatus.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    // just look at the IRQ status bits
    irqStatus.us &= HcInterruptStatusMask;

    // irqStatus now possibly contains bits set for any currently
    // enabled interrupts

    if (irqStatus.HostSystemError ||
        irqStatus.HostControllerProcessError) {
        UhciKdPrint((DeviceData, 0, "IrqStatus Error: %x\n", irqStatus.us));
    } else if (irqStatus.us) {
        DeviceData->HCErrorCount = 0;
    }

#if DBG
    // this usually means we have a bad TD in the schedule
    // we will need to debug this since the controller and/or
    // device will not function after this point
    if (irqStatus.HostControllerProcessError) {
        USHORT fn;

        fn = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
        UhciKdPrint((DeviceData, 0, "HostControllerProcessError: %x\n", irqStatus.us));
        UhciKdPrint((DeviceData, 0, "frame[]: %x\n", fn&0x7ff));
        {
        //UhciDumpRegs(DeviceData);
        USHORT tmp;
        tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
        UhciKdPrint((DeviceData, 0, "UsbCommand %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbStatus.us);
        UhciKdPrint((DeviceData, 0, "UsbStatus %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbInterruptEnable.us);
        UhciKdPrint((DeviceData, 0, "UsbInterruptEnable %x\n", tmp));
        tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
        UhciKdPrint((DeviceData, 0, "UsbCommand %x\n", tmp));
        }
        TEST_TRAP();
    }
#endif

    // the halted bit alone does not indicate the interrupt
    // came from the controller

    if (irqStatus.UsbInterrupt ||
        irqStatus.ResumeDetect ||
        irqStatus.UsbError ||
        irqStatus.HostSystemError ||
        irqStatus.HostControllerProcessError)  {

        DeviceData->IrqStatus = irqStatus.us;

        // Clear the condition
        WRITE_PORT_USHORT(&reg->UsbStatus.us, irqStatus.us);

#if DBG
#ifndef _WIN64
        if (irqStatus.HostSystemError) {
            // something has gone terribly wrong
            UhciKdPrint((DeviceData, 0, "HostSystemError: %x\n", irqStatus.us));
            TEST_TRAP();
        }
#endif
#endif

        // indications are that this came from the
        // USB controller
        usbInt = TRUE;

        // disable all interrupts until the DPC for ISR runs
        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, 0);

    }

    //
    // If bulk bandwidth reclamation is on and there's
    // nothing queued, then turn it off.
    //
    if (irqStatus.UsbInterrupt) {
        UhciUpdateCounter(DeviceData);
        if (!DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate) {
            PHCD_QUEUEHEAD_DESCRIPTOR qh;
            BOOLEAN activeBulkTDs = FALSE;
            // This loop skips the td that has been inserted for
            // the PIIX4 problem, since it starts with the qh
            // the bulk queuehead is pointing at.
            // If the bulk queuehead is not pointing at anything,
            // then we're fine too, since it will have been
            // turned off already.
            for (qh = DeviceData->BulkQueueHead->NextQh;
                 qh;
                 qh = qh->NextQh) {
                if (!qh->HwQH.VLink.Terminate) {
                    activeBulkTDs = TRUE;
                    break;
                }
            }

            //
            // qh is pointing at either the first queuehead
            // with transfers pending or the bulk queuehead.
            //
            if (!activeBulkTDs) {
                UHCI_ASSERT(DeviceData, !qh)
                DeviceData->LastBulkQueueHead->HwQH.HLink.Terminate = 1;
            }
        }
    }

    if (irqStatus.HostControllerProcessError) {
        //
        // Force the schedule clean.
        //
        UhciCleanOutIsoch(DeviceData, TRUE);
    } else if (irqStatus.UsbInterrupt && DeviceData->IsoPendingTransfers) {
        //
        // Something completed.
        //
        UhciCleanOutIsoch(DeviceData, FALSE);
#if 0
    } else if (!DeviceData->IsoPendingTransfers) {
        //
        // Remove the rollover interrupt.
        //
        *( ((PULONG) (DeviceData->FrameListVA)) ) = DeviceData->RollOverTd->HwTD.LinkPointer.HwAddress;
#endif
    }

    if (irqStatus.HostControllerProcessError) {
        if (DeviceData->HCErrorCount++ < UHCI_HC_MAX_ERRORS) {
            USBCMD command;

            // Attempt to recover.
            // It could just be that we overran. If so,
            // the above code that clears the schedule
            // should take care of it.
            command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
            command.RunStop = 1;
            WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
            UhciKdPrint((DeviceData, 0, "Attempted to recover from error\n"));
        }
    }

    return usbInt;
}


VOID
UhciInterruptDpc (
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN EnableInterrupts
    )
/*++

Routine Description:

    process an interrupt

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg;
    USBSTS irqStatus, tmp;
    PLIST_ENTRY listEntry;
    PENDPOINT_DATA endpointData;

    reg = DeviceData->Registers;

    // ack all status bits asserted now
    //tmp.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    tmp.us = DeviceData->IrqStatus;
    DeviceData->IrqStatus = 0;

    LOGENTRY(DeviceData, G, '_idp', tmp.us, 0, 0);

    //WRITE_PORT_USHORT(&reg->UsbStatus.us, tmp.us);

    // now process status bits aserted,
    // just look at the IRQ status bits
    irqStatus.us = tmp.us & HcInterruptStatusMask;

    if (irqStatus.UsbInterrupt ||
        irqStatus.UsbError) {
        LOGENTRY(DeviceData, G, '_iEP', irqStatus.us, 0, 0);

        USBPORT_INVALIDATE_ENDPOINT(DeviceData, NULL);
    }

    if (EnableInterrupts) {
        LOGENTRY(DeviceData, G, '_iEE', 0, 0, 0);

        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
                          DeviceData->EnabledInterrupts.us);
    }
}


VOID
USBMPFN
UhciDisableInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT legsup;
    PHC_REGISTER reg;

    UhciKdPrint((DeviceData, 2, "Disable interrupts\n"));

    LOGENTRY(DeviceData, G, '_DIn', 0, 0, 0);
    reg = DeviceData->Registers;
    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
        0);

    if (DeviceData->ControllerFlavor != UHCI_Ich2_1 &&
        DeviceData->ControllerFlavor != UHCI_Ich2_2) {
        //
        // change the state of the PIRQD routing bit
        //
        USBPORT_READ_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,
            sizeof(legsup));

        LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
        // clear the PIRQD routing bit
        legsup &= ~LEGSUP_USBPIRQD_EN;

        USBPORT_WRITE_CONFIG_SPACE(
            DeviceData,
            &legsup,
            LEGACY_BIOS_REGISTER,
            sizeof(legsup));
    }
}


VOID
UhciFlushInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    used to flush rougue interrupts from the controller
    after power events

Arguments:

Return Value:

--*/
{

    PHC_REGISTER reg;

    LOGENTRY(DeviceData, G, '_FIn', 0, 0, 0);
    UhciKdPrint((DeviceData, 2, "Enable interrupts\n"));

    reg = DeviceData->Registers;

    // before writing the PIRQD register ack any eronious interrupts
    // the controller may be asserting -- it should not be asserting
    // at all but often is
    WRITE_PORT_USHORT(&reg->UsbStatus.us, 0xFFFF);
}


VOID
USBMPFN
UhciEnableInterrupts(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT legsup;
    PHC_REGISTER reg;

    LOGENTRY(DeviceData, G, '_EIn', 0, 0, 0);
    UhciKdPrint((DeviceData, 2, "Enable interrupts\n"));

    reg = DeviceData->Registers;

    //
    // change the state of the PIrQD routing bit
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
    // clear the PIRQD routing bit
    legsup |= LEGSUP_USBPIRQD_EN;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us,
        DeviceData->EnabledInterrupts.us);

}


VOID
UhciRHDisableIrq(
    IN PDEVICE_DATA DeviceData
    )
{
    // Uhci doesn't have this IRQ
}


VOID
UhciRHEnableIrq(
    IN PDEVICE_DATA DeviceData
    )
{
    // Uhci doesn't have this IRQ
}

#define UHCI_SOF_LATENCY 2

VOID
UhciInterruptNextSOF(
    IN PDEVICE_DATA DeviceData
    )
{
    ULONG i, frame, offset, cf;
    PHCD_TRANSFER_DESCRIPTOR td;
    BOOLEAN found = FALSE;

    cf = UhciGet32BitFrameNumber(DeviceData);

    // find a TD
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        UHCI_ASSERT(DeviceData, td->Sig == SIG_HCD_SOFTD);
        // use transferconext to hold req frame
        frame = td->RequestFrame;

        if (frame == cf+UHCI_SOF_LATENCY) {
            // There's already one queued
            found = TRUE;
            break;
        }
        if (frame < cf) {

            td->RequestFrame = (cf+UHCI_SOF_LATENCY);

            LOGENTRY(DeviceData, G, '_SOF', td, td->RequestFrame, cf);
            // insert TD
            td->HwTD.LinkPointer.HwAddress = 0;
            INSERT_ISOCH_TD(DeviceData, td, td->RequestFrame);
            found = TRUE;
            break;
        }
    }

    if (!found) {
        TEST_TRAP();
    }

    // recycle any old SOF interrupt TDs
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        UHCI_ASSERT(DeviceData, td->Sig == SIG_HCD_SOFTD);
        // use transferconext to hold req frame
        frame = td->RequestFrame;

        if (frame &&
            (frame < cf ||
             frame - cf > UHCI_MAX_FRAME)) {
            td->RequestFrame = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\pch.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header file.

Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usb.h"
#include "usbhcdi.h"

#include "uhci.h"
#include "dbg.h"

#include "usbuhci.h"

#endif // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\mpinit.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   mpinit.c

Abstract:

   miniport initialization

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-17-00 : copied, jsenior

--*/

#include "pch.h"

// global registration packet for this miniport
USBPORT_REGISTRATION_PACKET RegistrationPacket;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    RegistrationPacket.DeviceDataSize = sizeof(DEVICE_DATA);
    RegistrationPacket.EndpointDataSize = sizeof(ENDPOINT_DATA);
    RegistrationPacket.TransferContextSize = sizeof(TRANSFER_CONTEXT);

    // enough for 4k frame list plus 4k of scratch space

    // enough for 4k frame list and interrupt schdule (63 nodes)
    // + static bulk + static control + pixx4 hack queue heads
    // this ends up being about 3 pages
    RegistrationPacket.CommonBufferBytes = 4096 +
        ((NO_INTERRUPT_QH_LISTS + 3) * sizeof(HCD_QUEUEHEAD_DESCRIPTOR)) + \
         (SOF_TD_COUNT * sizeof(HCD_TRANSFER_DESCRIPTOR));

    RegistrationPacket.MINIPORT_StartController = UhciStartController;
    RegistrationPacket.MINIPORT_StopController = UhciStopController;
    RegistrationPacket.MINIPORT_EnableInterrupts = UhciEnableInterrupts;
    RegistrationPacket.MINIPORT_DisableInterrupts = UhciDisableInterrupts;
    RegistrationPacket.MINIPORT_InterruptService = UhciInterruptService;
    RegistrationPacket.MINIPORT_InterruptDpc = UhciInterruptDpc;
    RegistrationPacket.MINIPORT_SuspendController = UhciSuspendController;
    RegistrationPacket.MINIPORT_ResumeController = UhciResumeController;

    //
    // Root hub control entry points
    //
    RegistrationPacket.MINIPORT_RH_DisableIrq = UhciRHDisableIrq;
    RegistrationPacket.MINIPORT_RH_EnableIrq = UhciRHEnableIrq;
    RegistrationPacket.MINIPORT_RH_GetRootHubData = UhciRHGetRootHubData;
    RegistrationPacket.MINIPORT_RH_GetStatus = UhciRHGetStatus;
    RegistrationPacket.MINIPORT_RH_GetHubStatus = UhciRHGetHubStatus;
    RegistrationPacket.MINIPORT_RH_GetPortStatus = UhciRHGetPortStatus;

    //
    // Individual root hub port entry points
    //
    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset = UhciRHSetFeaturePortReset;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable = UhciRHSetFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower = UhciRHSetFeaturePortPower;
    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend = UhciRHSetFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend = UhciRHClearFeaturePortSuspend;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable = UhciRHClearFeaturePortEnable;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower = UhciRHClearFeaturePortPower;

    // Change bits
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange = UhciRHClearFeaturePortConnectChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange = UhciRHClearFeaturePortResetChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange = UhciRHClearFeaturePortEnableChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange = UhciRHClearFeaturePortSuspendChange;
    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange = UhciRHClearFeaturePortOvercurrentChange;


    RegistrationPacket.MINIPORT_SetEndpointStatus = UhciSetEndpointStatus;
    RegistrationPacket.MINIPORT_GetEndpointStatus = UhciGetEndpointStatus;
    RegistrationPacket.MINIPORT_SetEndpointDataToggle = UhciSetEndpointDataToggle;
    RegistrationPacket.MINIPORT_OpenEndpoint = UhciOpenEndpoint;
    RegistrationPacket.MINIPORT_PokeEndpoint = UhciPokeEndpoint;
    RegistrationPacket.MINIPORT_QueryEndpointRequirements = UhciQueryEndpointRequirements;
    RegistrationPacket.MINIPORT_CloseEndpoint = UhciCloseEndpoint;
    RegistrationPacket.MINIPORT_PollEndpoint = UhciPollEndpoint;
    RegistrationPacket.MINIPORT_SetEndpointState = UhciSetEndpointState;
    RegistrationPacket.MINIPORT_GetEndpointState = UhciGetEndpointState;
    RegistrationPacket.MINIPORT_Get32BitFrameNumber = UhciGet32BitFrameNumber;
    RegistrationPacket.MINIPORT_PollController = UhciPollController;
    RegistrationPacket.MINIPORT_CheckController = UhciCheckController;
    RegistrationPacket.MINIPORT_InterruptNextSOF = UhciInterruptNextSOF;
    RegistrationPacket.MINIPORT_SubmitTransfer = UhciSubmitTransfer;
    RegistrationPacket.MINIPORT_SubmitIsoTransfer = UhciIsochTransfer;
    RegistrationPacket.MINIPORT_AbortTransfer = UhciAbortTransfer;
    RegistrationPacket.MINIPORT_StartSendOnePacket = UhciStartSendOnePacket;
    RegistrationPacket.MINIPORT_EndSendOnePacket = UhciEndSendOnePacket;
    RegistrationPacket.MINIPORT_PassThru = UhciPassThru;
    RegistrationPacket.MINIPORT_FlushInterrupts = UhciFlushInterrupts;

    RegistrationPacket.OptionFlags = USB_MINIPORT_OPT_NEED_IRQ |
                                     USB_MINIPORT_OPT_NEED_IOPORT |
                                     USB_MINIPORT_OPT_NO_IRQ_SYNC |
                                     //USB_MINIPORT_OPT_POLL_IN_SUSPEND |
                                     USB_MINIPORT_OPT_POLL_CONTROLLER;

    //
    // UHCI controller
    //
    RegistrationPacket.HciType = USB_UHCI;
    RegistrationPacket.BusBandwidth = USB_11_BUS_BANDWIDTH;

    DriverObject->DriverUnload = NULL;

    return USBPORT_RegisterUSBPortDriver(
                DriverObject,
                USB_MINIPORT_HCI_VERSION,
                &RegistrationPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\roothub.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

   roothub.c

Abstract:

   miniport root hub

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-26-00 : created, jsenior

implements the following miniport functions:

MINIPORT_RH_GetStatus
MINIPORT_RH_GetPortStatus
MINIPORT_RH_GethubStatus

MINIPORT_RH_SetFeaturePortReset
MINIPORT_RH_SetFeaturePortSuspend
MINIPORT_RH_SetFeaturePortPower

MINIPORT_RH_ClearFeaturePortEnable
MINIPORT_RH_ClearFeaturePortSuspend
MINIPORT_RH_ClearFeaturePortPower

MINIPORT_RH_ClearFeaturePortConnectChange
MINIPORT_RH_ClearFeaturePortResetChange
MINIPORT_RH_ClearFeaturePortEnableChange
MINIPORT_RH_ClearFeaturePortSuspendChange
MINIPORT_RH_ClearFeaturePortOvercurrentChange


--*/

#include "pch.h"

typedef struct _UHCI_PORT_RESET_CONTEXT {
    USHORT  PortNumber;
    BOOLEAN Completing;
} UHCI_PORT_RESET_CONTEXT, *PUHCI_PORT_RESET_CONTEXT;

VOID
UhciRHGetRootHubData(
    IN PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    )
/*++
    return info about the root hub
--*/
{
    HubData->NumberOfPorts = UHCI_NUMBER_PORTS;

    // D0,D1 (11)  - no power switching
    // D2    (0)   - not compund
    // D5, D15 (0)
    HubData->HubCharacteristics.us = 0;
    HubData->HubCharacteristics.PowerSwitchType = 3;
    HubData->HubCharacteristics.CompoundDevice = 0;
    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        // D3,D4 (01)  - overcurrent reported per port
        HubData->HubCharacteristics.OverCurrentProtection = 1;
    } else {
        // D3,D4 (11)  - no overcurrent reported
        HubData->HubCharacteristics.OverCurrentProtection = 11;
    }

    HubData->PowerOnToPowerGood = 1;
    // this value is the current consumed by the hub
    // brains, for the embeded hub this doesn't make
    // much sense.
    //
    // so we report zero
    HubData->HubControlCurrent = 0;

    LOGENTRY(DeviceData, G, '_hub', HubData->NumberOfPorts,
        DeviceData->PortPowerControl, 0);

}

////////////////////////////////////////////////////////////////////////////////
//
// Hub status
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHGetStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    )
/*++
    get the device status
--*/
{
    // the root hub is self powered
    *Status = USB_GETSTATUS_SELF_POWERED;

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHGetHubStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    )
/*++
--*/
{
    // nothing intersting for the root
    // hub to report
    HubStatus->ul = 0;

    return USBMP_STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Enable
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHPortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    USHORT Value
    )
/*++
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_spe', port.us, 0, PortNumber);

    MASK_CHANGE_BITS(port);

    // writing a 1 enables the port
    port.PortEnable = Value;
    WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortEnable (
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    )
{
    return UhciRHPortEnable(DeviceData, PortNumber, 0);
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    return UhciRHPortEnable(DeviceData, PortNumber, 1);
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Power
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHClearFeaturePortPower (
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    )
{
    // not implemented on uhci

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
--*/
{
    // not implemented on uhci

    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Status
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHGetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    )
/*++
    get the status of a partuclar port
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    portStatus->ul = 0;
    LOGENTRY(DeviceData, G, '_Pp1', PortNumber, port.us, 0);

    // map the bits to the port status structure

    portStatus->Connected           = port.PortConnect;
    portStatus->Enabled             = port.PortEnable;

    // bits 12:2 indicate the true suspend state
    // we only want to indiacte the port is suspended
    // if a device is attached.  If the device is removed
    // during suspend the enable bit will be clear
    if (port.Suspend && port.PortEnable) {
        portStatus->Suspended = 1;
    } else {
        portStatus->Suspended = 0;
    }

    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        portStatus->OverCurrent         = port.Overcurrent;
        portStatus->OverCurrentChange   = port.OvercurrentChange;
        portStatus->PowerOn             = !port.Overcurrent;
    } else {
        portStatus->OverCurrent         = 0;
        portStatus->OverCurrentChange   = 0;
        portStatus->PowerOn             = 1; // always on
    }

    portStatus->Reset               = port.PortReset;
    portStatus->LowSpeed            = port.LowSpeedDevice;
    portStatus->HighSpeed           = 0; // this is not a 2.0 HC
    portStatus->ConnectChange       = port.PortConnectChange;
    if (TEST_BIT(DeviceData->PortInReset, PortNumber-1)) {
        portStatus->EnableChange = 0;
        portStatus->ConnectChange = 0;
    } else {
        portStatus->EnableChange = port.PortEnableChange;
    }

    // these change bits must be emulated
    if (TEST_BIT(DeviceData->PortSuspendChange, PortNumber-1)) {
        portStatus->SuspendChange   = 1;
    }
    if (TEST_BIT(DeviceData->PortResetChange, PortNumber-1)) {
        portStatus->ResetChange     = 1;
    }

    LOGENTRY(DeviceData, G, '_gps',
        PortNumber, portStatus->ul, port.us);

    return USBMP_STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Reset
//
//      First, we have the VIA specific routines for REVs 0 thru 4 of the VIA
//      USB host controller. Then the regular routines follow that are run for
//      all non-broken controllers.
//
////////////////////////////////////////////////////////////////////////////////

VOID
UhciRHSetFeaturePortResetWorker(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    );

VOID
UhciViaRHPortResetComplete(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Restart the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USHORT portNumber;

    reg = DeviceData->Registers;
    portNumber = PortResetContext->PortNumber;

    // This code has been ripped out of the VIA filter driver
    // that works on Win2K.

    // Re-start the controller.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.RunStop = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Continue with the regular port reset completion stuff.
    SET_BIT(DeviceData->PortResetChange, portNumber-1);
    CLEAR_BIT(DeviceData->PortInReset, portNumber-1);

    // indicate the reset change to the hub
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}

VOID
UhciViaRHSetFeaturePortResetResume(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Resume the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    PMINIPORT_CALLBACK callback;

    reg = DeviceData->Registers;

    // Resume the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 1;
    command.EnterGlobalSuspendMode = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    //
    // Depending on whether we're in the completion case or not,
    // we'll either be starting the controller or putting the port
    // into reset.
    //
    callback = PortResetContext->Completing ?
        UhciViaRHPortResetComplete : UhciRHSetFeaturePortResetWorker;

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   callback);
}

VOID
UhciViaRHSetFeaturePortResetSuspend(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Suspend the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USBSTS status;

    reg = DeviceData->Registers;

    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
    UHCI_ASSERT(DeviceData, status.HCHalted);

    // Suspend the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciViaRHSetFeaturePortResetResume);
}

VOID
UhciViaRHSetFeaturePortResetStop(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    VIA specific hack: Stop the controller.
--*/
{
    PHC_REGISTER reg;
    USBCMD command;

    reg = DeviceData->Registers;

    // This code has been ripped out of the VIA filter driver
    // that works on Win2K.

    // Stop the controller
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.RunStop = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the HC to halt
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   20, // callback in 20 ms, as in via filter
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciViaRHSetFeaturePortResetSuspend);
}

////////////////////////////////////////////////////////////////////////////////
//
// Port Reset
//
//      Generic reset routines.
//
////////////////////////////////////////////////////////////////////////////////

VOID
UhciRHPortResetComplete(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    complete a port reset
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    USHORT portNumber;
    int i;

    reg = DeviceData->Registers;
    portNumber = PortResetContext->PortNumber;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    LOGENTRY(DeviceData, G, '_prC', port.us,
        DeviceData->PortResetChange, portNumber);

    MASK_CHANGE_BITS(port);
    // writing a 0 stops reset
    port.PortReset = 0;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    // spin for zero
    do {
        //
        // a driver may not spin in a loop waiting for a status bit change
        // without testing for hardware presence inside the loop.
        //
        if (FALSE == UhciHardwarePresent(DeviceData)) {
            return;
        }
        port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    } while (port.PortReset != 0);

    //
    // Enable the port
    //

    for (i=0; i< 10; i++) {
        //
        // Need a delay between clearing the port reset and setting
        // the port enable.  VIA suggests delaying 64 USB bit times,
        // or 43us if those are low-speed bit times....
        // BUT, we can't wait in the DPC...
        //
        KeStallExecutionProcessor(50);

        port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);

        if (port.PortEnable) {
            //
            // port is enabled
            //
            break;
        }

        port.PortEnable = 1;
        WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);
    }

    // clear port connect & enable change bits
    port.PortEnableChange = 1;
    port.PortConnectChange = 1;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    if (DeviceData->ControllerFlavor >= UHCI_VIA &&
        DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {

        PortResetContext->Completing = TRUE;
        UhciViaRHSetFeaturePortResetSuspend(DeviceData, PortResetContext);

    } else {
        SET_BIT(DeviceData->PortResetChange, portNumber-1);
        CLEAR_BIT(DeviceData->PortInReset, portNumber-1);

        // indicate the reset change to the hub
        USBPORT_INVALIDATE_ROOTHUB(DeviceData);
    }
}

VOID
UhciRHSetFeaturePortResetWorker(
    PDEVICE_DATA DeviceData,
    PUHCI_PORT_RESET_CONTEXT PortResetContext
    )
/*++
    Do the actual work to put the port in reset
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    USHORT portNumber = PortResetContext->PortNumber;

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);

    LOGENTRY(DeviceData, G, '_prw', port.us, 0, portNumber);

    UHCI_ASSERT(DeviceData, !port.PortReset);

    // writing a 1 initiates reset
    LOGENTRY(DeviceData, G, '_nhs', port.us, 0, portNumber);
    MASK_CHANGE_BITS(port);
    port.PortReset = 1;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    // schedule a callback to complete the reset.
    USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                   10, // callback in 10 ms,
                                   PortResetContext,
                                   sizeof(UHCI_PORT_RESET_CONTEXT),
                                   UhciRHPortResetComplete);
}

USB_MINIPORT_STATUS
UhciRHSetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in reset
--*/
{
    PORTSC port;
    UHCI_PORT_RESET_CONTEXT portResetContext;

    portResetContext.PortNumber = PortNumber;
    portResetContext.Completing = FALSE;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    LOGENTRY(DeviceData, G, '_spr', 0, 0, PortNumber);

    if (!TEST_BIT(DeviceData->PortInReset, PortNumber-1)) {
        SET_BIT(DeviceData->PortInReset, PortNumber-1);

        if (DeviceData->ControllerFlavor >= UHCI_VIA &&
            DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {
            UhciViaRHSetFeaturePortResetStop(DeviceData, &portResetContext);
        } else {
            UhciRHSetFeaturePortResetWorker(DeviceData, &portResetContext);
        }
    } else {
        //
        // the port is already in reset
        //
        UhciKdPrint((DeviceData, 2, "Trying to reset a port already in reset.\n"));
        return USBMP_STATUS_BUSY;
    }

    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Suspend
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHSetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Put a port in suspend.
--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_sps', port.us, 0, PortNumber);

    if (!port.Suspend) {
        //
        // write the suspend bit
        //
        if (DeviceData->ControllerFlavor == UHCI_Piix4 ||
            ANY_VIA(DeviceData)) {
            // just pretend we did it for the piix4

            LOGENTRY(DeviceData, G, '_spo', port.us, 0, PortNumber);
        } else {
            MASK_CHANGE_BITS(port);

            port.Suspend = 1;
            WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
        }

        LOGENTRY(DeviceData, G, '_sus', port.us, 0, PortNumber);
    } else {
        //
        // stall if the port is already suspended
        //
        UhciKdPrint((DeviceData, 2, "Trying to suspend an already suspended port.\n"));
    }

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciRHClearFeaturePortSuspendComplete(
    PDEVICE_DATA DeviceData,
    PVOID Context
    )
/*++
    complete a port resume.
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    PUHCI_PORT_RESET_CONTEXT portResetContext = Context;
    USHORT portNumber;

    reg = DeviceData->Registers;
    portNumber = portResetContext->PortNumber;

    port.us = READ_PORT_USHORT(&reg->PortRegister[portNumber-1].us);
    LOGENTRY(DeviceData, G, '_prC', port.us,
        DeviceData->PortSuspendChange, portNumber);

    MASK_CHANGE_BITS(port);
    // clear the bits.
    port.ResumeDetect = 0;
    port.Suspend = 0;
    WRITE_PORT_USHORT(&reg->PortRegister[portNumber-1].us, port.us);

    SET_BIT(DeviceData->PortSuspendChange, portNumber-1);

    DeviceData->PortResuming[portNumber-1] = FALSE;

    // indicate the resume change to the hub
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++
    Resume a port in suspend
--*/
{
    PHC_REGISTER reg;
    PORTSC port;
    UHCI_PORT_RESET_CONTEXT portResetContext;

    reg = DeviceData->Registers;

    UHCI_ASSERT(DeviceData, PortNumber <= UHCI_NUMBER_PORTS);

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_rps', port.us, 0, PortNumber);

    if (DeviceData->ControllerFlavor == UHCI_Piix4 ||
        ANY_VIA(DeviceData)) {

        // just pretend we did it for the piix4
      
        LOGENTRY(DeviceData, G, '_rpo', port.us, 0, PortNumber);

    } else {

        if (!DeviceData->PortResuming[PortNumber-1]) {

            DeviceData->PortResuming[PortNumber-1] = TRUE;

            if (!port.ResumeDetect) {

                // write the resume detect bit
                MASK_CHANGE_BITS(port);

                port.ResumeDetect = 1;
                WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
            }

            // Request to be called back so that we can set the resume to zero
            portResetContext.PortNumber = PortNumber;

            USBPORT_REQUEST_ASYNC_CALLBACK(DeviceData,
                                           10, // callback in 10 ms,
                                           &portResetContext,
                                           sizeof(portResetContext),
                                           UhciRHClearFeaturePortSuspendComplete);

        } else {

            // stall if the port is already resuming
            UhciKdPrint((DeviceData, 2, "Trying to resume a port already resuming.\n"));
            return USBMP_STATUS_BUSY;
        }
    }

    LOGENTRY(DeviceData, G, '_res', port.us, 0, PortNumber);
    return USBMP_STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//
// Port Change bits
//
////////////////////////////////////////////////////////////////////////////////

USB_MINIPORT_STATUS
UhciRHClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    reg = DeviceData->Registers;

    //
    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    LOGENTRY(DeviceData, G, '_pcc', port.us,
        0, PortNumber);

    // writing a 1 zeros the change bit
    if (port.PortConnectChange == 1) {
        // mask off other change bits
        MASK_CHANGE_BITS(port);
        port.PortConnectChange = 1;

        WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
    }

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

--*/
{
    PHC_REGISTER reg;
    PORTSC port;

    LOGENTRY(DeviceData, G, '_cpe', PortNumber, 0, 0);

    reg = DeviceData->Registers;

    port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
    MASK_CHANGE_BITS(port);
    port.PortEnableChange = 1;

    WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port reset condition.

--*/
{
    // UHCI doesn't have this.
    CLEAR_BIT(DeviceData->PortResetChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port suspend condition.

--*/
{
    // UHCI doesn't have this.
    CLEAR_BIT(DeviceData->PortSuspendChange, PortNumber-1);

    return USBMP_STATUS_SUCCESS;
}

USB_MINIPORT_STATUS
UhciRHClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    )
/*++

Clear the port overcurrent condition.

--*/
{
    if (DeviceData->ControllerFlavor == UHCI_Piix4) {
        PHC_REGISTER reg;
        PORTSC port;

        reg = DeviceData->Registers;

        //
        port.us = READ_PORT_USHORT(&reg->PortRegister[PortNumber-1].us);
        LOGENTRY(DeviceData, G, '_cOv', port.us, 0, PortNumber);

        // writing a 1 zeros the change bit
        if (port.OvercurrentChange == 1) {
            // mask off other change bits
            MASK_CHANGE_BITS(port);
            port.OvercurrentChange = 1;

            WRITE_PORT_USHORT(&reg->PortRegister[PortNumber-1].us, port.us);
        }
    }

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\usbuhci.c ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbuhci.c

Abstract:

    USB UHCI driver

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999, 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    7-28-2000 : created, jsenior

--*/



#include "pch.h"

typedef struct _SS_PACKET_CONTEXT {
    ULONG OldControlQH;
    MP_HW_POINTER FirstTd;
    MP_HW_POINTER Data;
    ULONG PadTo8Dwords[3];
} SS_PACKET_CONTEXT, *PSS_PACKET_CONTEXT;

//implements the following miniport functions:
//UhciStartController
//UhciStopController
//UhciStartSendOnePacket
//UhciEndSendOnePacket

VOID
UhciFixViaFIFO(
    IN PDEVICE_DATA DeviceData
    )
{
    VIAFIFO fifo;
    //
    // Disable broken fifo management.
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &fifo,
        VIA_FIFO_MANAGEMENT,
        sizeof(fifo));

    fifo |= VIA_FIFO_DISABLE;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &fifo,
        VIA_FIFO_MANAGEMENT,
        sizeof(fifo));

    UhciKdPrint((DeviceData, 2, "'Fifo management reg = 0x%x\n", fifo));
}

VOID
UhciFixViaBabbleDetect(
    IN PDEVICE_DATA DeviceData
    )
{
    VIABABBLE babble;
    //
    // Disable broken fifo management.
    //

    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &babble,
        VIA_INTERNAL_REGISTER,
        sizeof(babble));

    babble |= VIA_DISABLE_BABBLE_DETECT;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &babble,
        VIA_INTERNAL_REGISTER,
        sizeof(babble));

    UhciKdPrint((DeviceData, 2, "'Babble management reg = 0x%x\n", babble));
}

USB_MINIPORT_STATUS
UhciInitializeHardware(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

   Initializes the hardware registers for the host controller.

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg;
    USBCMD cmd;
    LARGE_INTEGER finishTime, currentTime;

    reg = DeviceData->Registers;

    if (DeviceData->ControllerFlavor == UHCI_VIA+0xE) {
        UhciFixViaFIFO(DeviceData);
    }

    if (DeviceData->ControllerFlavor <= UHCI_VIA+0x4) {
        UhciFixViaBabbleDetect(DeviceData);
    }

    // Save away the SOF modify for after resets
    DeviceData->SavedSOFModify = READ_PORT_UCHAR(&reg->StartOfFrameModify.uc);

    //
    // This hack is from the SP1 tree the QFE team must have added for some 
    // reason.  I have added to the current source to maintain consistency
    //
    // Delay an experimentally determined amount of time while the root hub port power
    // becomes good before resetting the controller so that the bus is not in reset while
    // devices are powered up.
    //
   
    USBPORT_WAIT(DeviceData, 20);


    // reset the controller
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    LOGENTRY(DeviceData, G, '_res', cmd.us, 0, 0);

    cmd.us = 0;
    cmd.GlobalReset = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    USBPORT_WAIT(DeviceData, 20);

    cmd.GlobalReset = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    //
    // 64 byte reclamation
    //
    cmd.MaxPacket = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    //
    // set the SOF modify to whatever we found before
    // the reset.
    UhciKdPrint((DeviceData, 2, "'Setting SOF Modify to %d\n", DeviceData->SavedSOFModify));
    WRITE_PORT_UCHAR(&reg->StartOfFrameModify.uc,
                     DeviceData->SavedSOFModify);

    //
    // set the enabled interrupts cache, we'll enable
    // these interrupts when asked
    //
    DeviceData->EnabledInterrupts.TimeoutCRC = 1;
    DeviceData->EnabledInterrupts.Resume = 1;
    DeviceData->EnabledInterrupts.InterruptOnComplete = 1;
    DeviceData->EnabledInterrupts.ShortPacket = 1;

    return USBMP_STATUS_SUCCESS;
}

VOID
UhciSetNextQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR SecondQh
    )
/*++

Routine Description:

   Insert an aync endpoint (queue head)
   into the HW list

Arguments:


--*/
{
    QH_LINK_POINTER newLink;

    LOGENTRY(DeviceData, G, '_snQ', 0, FirstQh, SecondQh);

    // link new qh to the current 'head' ie
    // first transfer QH
    SecondQh->PrevQh = FirstQh;

    // put the new qh at the head of the queue
    newLink.HwAddress = SecondQh->PhysicalAddress;
    newLink.QHTDSelect = 1;
    UHCI_ASSERT(DeviceData, !newLink.Terminate);
    UHCI_ASSERT(DeviceData, !newLink.Reserved);
    FirstQh->HwQH.HLink = newLink;
    FirstQh->NextQh = SecondQh;

    SET_FLAG(SecondQh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE);
}

VOID
UhciFixPIIX4(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_TRANSFER_DESCRIPTOR Td,
    IN HW_32BIT_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:


 PIIX4 hack

 we will need a dummy bulk endpoint inserted in the schedule

Arguments:

    DeviceData

Return Value:

    NT status code.

--*/
{
    UhciKdPrint((DeviceData, 2, "'Fix PIIX 4 hack.\n"));
    //
    // Set up the dummy TD.
    //
    Td->Flags = TD_FLAG_XFER;
    Td->HwTD.Buffer = 0x0badf00d;
    // point to ourselves
    Td->HwTD.LinkPointer.HwAddress = Td->PhysicalAddress = PhysicalAddress;
    Td->HwTD.Token.ul = 0;
    Td->HwTD.Token.Endpoint = 1;
    Td->HwTD.Token.DeviceAddress = 0;
    Td->HwTD.Token.MaximumLength = NULL_PACKET_LENGTH;
    Td->HwTD.Token.Pid = OutPID;
    Td->HwTD.Control.ul = 0;
    Td->HwTD.Control.Active = 0;
    Td->HwTD.Control.ErrorCount = 0;
    Td->HwTD.Control.InterruptOnComplete = 0;
    Td->HwTD.Control.IsochronousSelect = 1;
    Td->NextTd = NULL;

    UHCI_ASSERT(DeviceData, DeviceData->BulkQueueHead->HwQH.HLink.Terminate);
    //link the td to the QH
    DeviceData->BulkQueueHead->HwQH.VLink.HwAddress = Td->PhysicalAddress;
}

USB_MINIPORT_STATUS
UhciInitializeSchedule(
    IN PDEVICE_DATA DeviceData,
    IN PUCHAR StaticQHs,
    IN HW_32BIT_PHYSICAL_ADDRESS StaticQHsPhys
    )
/*++

Routine Description:

    Build the schedule of static Eds

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus;
    ULONG length;
    ULONG i;
    PHCD_QUEUEHEAD_DESCRIPTOR controlQh, bulkQh, qh;
    PHCD_TRANSFER_DESCRIPTOR td;
    QH_LINK_POINTER newLink;

    // Allocate staticly disabled QHs, and set head pointers for
    // scheduling lists
    //
    // The static ED list is contains all the static interrupt QHs (64)
    // plus the static ED for bulk and control (2)
    //
    // the array looks like this:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,
    // CONTROL
    // BULK

    // each static ED points to another static ED
    // (except for the 1ms ed) the INDEX of the next
    // ED in the StaticEDList is stored in NextIdx,
    // these values are constent
/*    CHAR nextIdxTable[63] = {
             // 0  1  2  3  4  5  6  7
     (CHAR)ED_EOF, 0, 0, 1, 1, 2, 2, 3,
             // 8  9 10 11 12 13 14 15
                3, 4, 4, 5, 5, 6, 6, 7,
             //16 17 18 19 20 21 22 23
                7, 8, 8, 9, 9,10,10,11,
             //24 25 26 27 28 29 30 31
               11,12,12,13,13,14,14,15,
             //32 33 34 35 36 37 38 39
               15,16,16,17,17,18,18,19,
             //40 41 42 43 44 45 46 47
               19,20,20,21,21,22,22,23,
             //48 49 50 51 52 53 54 55
               23,24,24,25,25,26,26,27,
             //56 57 58 59 60 61 62 63
               27,28,28,29,29,30,30
    };

/*
    Numbers are the index into the static ed table

    (31) -\
          (15)-\
    (47) -/     \
                (7 )-\
    (39) -\     /     \
          (23)-/       \
    (55) -/             \
                        (3)-\
    (35) -\             /    \
          (19)-\       /      \
    (51) -/     \     /        \
                (11)-/          \
    (43) -\     /                \
          (27)-/                  \
    (59) -/                        \
                                   (1)-\
    (33) -\                        /    \
          (17)-\                  /      \
    (49) -/     \                /        \
                (9 )-\          /          \
    (41) -\     /     \        /            \
          (25)-/       \      /              \
    (57) -/             \    /                \
                        (5)-/                  \
    (37) -\             /                       \
          (21)-\       /                         \
    (53) -/     \     /                           \
                (13)-/                             \
    (45) -\     /                                   \
          (29)-/                                     \
    (61) -/                                           \
                                                      (0)
    (32) -\                                           /
          (16)-\                                     /
    (48) -/     \                                   /
                (8 )-\                             /
    (40) -\     /     \                           /
          (24)-/       \                         /
    (56) -/             \                       /
                        (4)-\                  /
    (36) -\             /    \                /
          (20)-\       /      \              /
    (52) -/     \     /        \            /
                (12)-/          \          /
    (44) -\     /                \        /
          (28)-/                  \      /
    (60) -/                        \    /
                                   (2)-/
    (34) -\                        /
          (18)-\                  /
    (50) -/     \                /
                (10)-\          /
    (42) -\     /     \        /
          (26)-/       \      /
    (58) -/             \    /
                        (6)-/
    (38) -\             /
          (22)-\       /
    (54) -/     \     /
                (14)-/
    (46) -\     /
          (30)-/
    (62) -/
*/

    // corresponding offsets for the 32ms list heads in the
    // HCCA -- these are entries 31..62
    CHAR NextQH[] = {
        0,
        0, 0,
        1, 2, 1, 2,
        3, 4, 5, 6, 3, 4, 5, 6,
        7, 8, 9, 10, 11, 12, 13, 14, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};

    UhciKdPrint((DeviceData, 2, "'Initializing schedule.\n"));

    //
    // initailze all interrupt QHs
    // Step through all the interrupt levels:
    // 1ms, 2ms, 4ms, 8ms, 16ms, 32ms and...
    // Initialize each interrupt queuehead,
    // Set up the tree above.
    //
    for (i=0; i<NO_INTERRUPT_QH_LISTS; i++) {
        //
        // Carve QHs from the common buffer
        //
        qh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

        RtlZeroMemory(qh, sizeof(*qh));
        qh->PhysicalAddress = StaticQHsPhys;
        // this will never point to a TD
        qh->HwQH.VLink.Terminate = 1;
        qh->Sig = SIG_HCD_IQH;

        DeviceData->InterruptQueueHeads[i] = qh;

        UhciSetNextQh(
            DeviceData,
            qh,
            DeviceData->InterruptQueueHeads[NextQH[i]]);

        // next QH
        StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    //
    // allocate a QH for the Control list
    //
    controlQh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(controlQh, sizeof(*controlQh));
    controlQh->PhysicalAddress = StaticQHsPhys;

    // this will never point to a TD
    controlQh->HwQH.VLink.Terminate = 1;
    controlQh->Sig = SIG_HCD_CQH;

    // link the 1ms interrupt qh to the control qh
    UhciSetNextQh(
        DeviceData,
        DeviceData->InterruptQueueHeads[0],
        controlQh);

    DeviceData->ControlQueueHead = controlQh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

    //
    // allocate a QH for the Bulk list
    //
    bulkQh = (PHCD_QUEUEHEAD_DESCRIPTOR) StaticQHs;

    RtlZeroMemory(bulkQh, sizeof(*bulkQh));
    bulkQh->PhysicalAddress = StaticQHsPhys;

    // link to ourselves for bandwidth reclamation, but set
    // t-bit on next qh so that we don't spin taking PCI resources
    bulkQh->HwQH.HLink.HwAddress = bulkQh->PhysicalAddress; // points to itself
    bulkQh->HwQH.HLink.QHTDSelect = 1;  // this will always point to a QH
    bulkQh->HwQH.HLink.Terminate = 1;   // Must terminate this so that we don't spin

    bulkQh->Sig = SIG_HCD_BQH;

    // link the control qh to the bulk qh
    UhciSetNextQh(
        DeviceData,
        controlQh,
        bulkQh);

    DeviceData->BulkQueueHead = DeviceData->LastBulkQueueHead = bulkQh;

    //
    // NOTE: For bulk reclamation, we make a loop of all
    // the bulk queueheads, hence it needs to point to
    // itself initially, such that when other queueheads
    // are inserted, the bulkQh will point to the last one.
    //
//    bulkQh->PrevQh = bulkQh->NextQh = bulkQh;

    StaticQHs += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);

#ifdef FIXPIIX4
    UhciFixPIIX4(DeviceData, (PHCD_TRANSFER_DESCRIPTOR)StaticQHs, StaticQHsPhys);
    StaticQHs += sizeof(HCD_TRANSFER_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);

#else
    // this will never point to a TD
    bulkQh->HwQH.VLink.Terminate = 1;
#endif

    // Put the interrupt schedule in every frame
    for (i=0; i < UHCI_MAX_FRAME; i++) {
        newLink.HwAddress = DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms + MAX_INTERVAL_MASK(i)]->PhysicalAddress;
        newLink.QHTDSelect = 1;
        *( ((PULONG) (DeviceData->FrameListVA)+i) ) = newLink.HwAddress;
    }

    //
    // Allocate the rollover td.
    //
    td = (PHCD_TRANSFER_DESCRIPTOR) StaticQHs;
    RtlZeroMemory(td, sizeof(*td));
    td->PhysicalAddress = StaticQHsPhys;

    td->Sig = SIG_HCD_RTD;
    td->HwTD.Control.Active = 0;
    td->HwTD.Control.InterruptOnComplete = 1;
    td->HwTD.LinkPointer.HwAddress = DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms]->PhysicalAddress;
    td->HwTD.LinkPointer.QHTDSelect = 1;
    td->HwTD.Buffer = 0x0badf00d;

    // VIA Host Controller requires a valid PID even if the TD is inactive
    td->HwTD.Token.Pid = InPID;
    DeviceData->RollOverTd = td;

    StaticQHs += sizeof(HCD_TRANSFER_DESCRIPTOR);
    StaticQHsPhys += sizeof(HCD_TRANSFER_DESCRIPTOR);

    // sof TDs
    length = sizeof(HCD_TRANSFER_DESCRIPTOR)*8;
    DeviceData->SofTdList = (PHCD_TD_LIST) StaticQHs;
    for (i=0; i<SOF_TD_COUNT; i++) {
        td = &DeviceData->SofTdList->Td[i];

        td->Sig = SIG_HCD_SOFTD;
        // use transferconext to hold req frame
        td->RequestFrame = 0;
        td->PhysicalAddress = StaticQHsPhys;
        td->HwTD.Control.Active = 0;
        td->HwTD.Control.InterruptOnComplete = 1;
        td->HwTD.LinkPointer.HwAddress =
            DeviceData->InterruptQueueHeads[QH_INTERRUPT_32ms]->PhysicalAddress;
        td->HwTD.LinkPointer.QHTDSelect = 1;
        td->HwTD.Buffer = 0x0badf00d;

        StaticQHsPhys+=sizeof(HCD_TRANSFER_DESCRIPTOR);
    }
    StaticQHs += length;

    mpStatus = USBMP_STATUS_SUCCESS;

    return mpStatus;
}


VOID
UhciGetRegistryParameters(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    // nothing
}


VOID
USBMPFN
UhciStopController(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN HwPresent
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USBCMD cmd;
    USBSTS status;
    USHORT legsup;
    PHC_REGISTER reg = DeviceData->Registers;
    LARGE_INTEGER finishTime, currentTime;

    UhciKdPrint((DeviceData, 2, "'Stop controller.\n"));
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    UHCI_ASSERT(DeviceData, DeviceData->SynchronizeIsoCleanup == 0);

    if (cmd.us == UHCI_HARDWARE_GONE) {
        LOGENTRY(DeviceData, G, '_hwG', cmd.us, 0, 0);
        UhciKdPrint((DeviceData, 0, "'Stop controller, hardware gone.\n"));
        return;
    }

    LOGENTRY(DeviceData, G, '_stp', cmd.us, 0, 0);

    if (cmd.GlobalReset) {
        // Some bioses leave the host controller in reset, such that
        // UhciResumeController fails. In response to this, UsbPort
        // stops and restarts the controller. We therefore have to
        // make sure and turn reset off.
        cmd.GlobalReset = 0;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);
    }

    // Set host controller reset, just like on W2K.
    cmd.HostControllerReset = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

    KeQuerySystemTime(&finishTime);
    // no spec'ed time -- we will graciously grant 0.1 sec.
    //
    // figure when we quit (.1 seconds later)
    finishTime.QuadPart += 100000;

    // wait for reset bit to go to zero
    cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    while (cmd.HostControllerReset) {

        KeQuerySystemTime(&currentTime);

        if (currentTime.QuadPart >= finishTime.QuadPart) {
            // timeout
            UhciKdPrint((DeviceData, 0,
                "'UHCI controller failed to reset in .1 sec!\n"));

            TEST_TRAP();

            break;
        }

        cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    }

#if 0
    //
    // change the state of the PIrQD routing bit
    //
    USBPORT_READ_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));

    LOGENTRY(DeviceData, G, '_leg', 0, legsup, 0);
    // clear the PIRQD routing bit
    legsup &= ~LEGSUP_USBPIRQD_EN;

    USBPORT_WRITE_CONFIG_SPACE(
        DeviceData,
        &legsup,
        LEGACY_BIOS_REGISTER,
        sizeof(legsup));
#endif
}

USB_MINIPORT_STATUS
USBMPFN
UhciStartController(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_SUCCESS;
    PHC_REGISTER reg = NULL;
    USBCMD cmd;
    
    UhciKdPrint((DeviceData, 2, "'Start controller.\n"));
    
    CLEAR_FLAG(DeviceData->Flags, UHCI_DDFLAG_SUSPENDED) ;
    
    DeviceData->Sig = SIG_UHCI_DD;
    DeviceData->ControllerFlavor = HcResources->ControllerFlavor;

    // hand over the USB controller.
    mpStatus = UhciStopBIOS(DeviceData, HcResources);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // got resources and schedule
        // init the controller
        mpStatus = UhciInitializeHardware(DeviceData);
    }

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // inialize static Queue Heads
        PUCHAR staticQHs;
        HW_32BIT_PHYSICAL_ADDRESS staticQHsPhys;

        staticQHs = HcResources->CommonBufferVa;
        staticQHsPhys = HcResources->CommonBufferPhys;

        //
        // allocate a frame list
        //
        DeviceData->FrameListVA = (PHW_32BIT_PHYSICAL_ADDRESS) staticQHs;
        DeviceData->FrameListPA = staticQHsPhys;

        // Increment the buffers past the frame list.
        staticQHs += UHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);
        staticQHsPhys += UHCI_MAX_FRAME*sizeof(HW_32BIT_PHYSICAL_ADDRESS);

        // set up the schedule
        mpStatus = UhciInitializeSchedule(DeviceData,
                                          staticQHs,
                                          staticQHsPhys);
        DeviceData->SynchronizeIsoCleanup = 0;
    }

    reg = DeviceData->Registers;

    // program the frame list
    WRITE_PORT_ULONG(&reg->FrameListBasePhys.ul, DeviceData->FrameListPA);
    UhciKdPrint((DeviceData, 2, "'FLBA %x\n", DeviceData->FrameListPA));

    if (mpStatus == USBMP_STATUS_SUCCESS) {

        // start the controller
        cmd.us = READ_PORT_USHORT(&reg->UsbCommand.us);
        LOGENTRY(DeviceData, G, '_run', cmd.us, 0, 0);
        cmd.RunStop = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, cmd.us);

        // sanity check the port status bits
        // clear the suspend bit if set, sometimes it sticks
        // across a reboot.
        {
        PORTSC port;
        ULONG i;

        for (i=0; i<2; i++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[i].us);
            //mask the change bits so we don't kill them
            port.PortConnectChange = 0;

            port.Suspend = 0;
            WRITE_PORT_USHORT(&reg->PortRegister[i].us, port.us);
        }
        }

        ActivateRolloverTd(DeviceData);
    } else {

        DEBUG_BREAK(DeviceData);
    }

    return mpStatus;
}

USB_MINIPORT_STATUS
UhciOpenEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUCHAR buffer;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG i, numTds;
    ULONG bytes;
    ULONG bufferSize;
    PHCD_TRANSFER_DESCRIPTOR td;

    LOGENTRY(DeviceData, G, '_opC', 0, 0, EndpointParameters);
    UhciKdPrint((DeviceData, 2, "'Open endpoint 0x%x.\n", EndpointData));

    EndpointData->Sig = SIG_EP_DATA;
    // save a copy of the parameters
    EndpointData->Parameters = *EndpointParameters;
    EndpointData->Flags = 0;
    EndpointData->PendingTransfers = 0;

    InitializeListHead(&EndpointData->DoneTdList);
   
    EndpointData->Toggle = DataToggle0;
    // Control and isoch can not halt
    if (EndpointParameters->TransferType == Control ||
        EndpointParameters->TransferType == Isochronous) {
        SET_FLAG(EndpointData->Flags, UHCI_EDFLAG_NOHALT);
    }

    // how much did we get
    bytes = EndpointParameters->CommonBufferBytes;
    buffer = EndpointParameters->CommonBufferVa;
    phys = EndpointParameters->CommonBufferPhys;

    if (EndpointParameters->TransferType != Isochronous) {
        //
        // make the Queue Head for this async endpoint
        //
        EndpointData->QueueHead = qh = (PHCD_QUEUEHEAD_DESCRIPTOR) buffer;

        qh->PhysicalAddress = phys;
        qh->HwQH.VLink.Terminate = 1;
        qh->EndpointData = EndpointData;
        qh->Sig = SIG_HCD_QH;

        qh->NextQh = qh->PrevQh = qh;

        buffer += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        phys += sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
        bytes -= sizeof(HCD_QUEUEHEAD_DESCRIPTOR);
    }

    //
    // Make the double buffers for page boundary transfers
    //
    EndpointData->DbList = (PDOUBLE_BUFFER_LIST) buffer;
    EndpointData->DbsUsed = 0;

    switch (EndpointParameters->TransferType) {
    case Control:
        UhciQueryControlRequirements(DeviceData,
                                     EndpointParameters,
                                     &numTds,
                                     &EndpointData->DbCount);
        break;
    case Bulk:
        UhciQueryBulkRequirements(DeviceData,
                                  EndpointParameters,
                                  &numTds,
                                  &EndpointData->DbCount);
        break;
    case Interrupt:
        UhciQueryInterruptRequirements(DeviceData,
                                       EndpointParameters,
                                       &numTds,
                                       &EndpointData->DbCount);
        break;
    case Isochronous:
        UhciQueryIsoRequirements(DeviceData,
                                 EndpointParameters,
                                 &numTds,
                                 &EndpointData->DbCount);
        break;
    default:
        TEST_TRAP();
        return USBMP_STATUS_NOT_SUPPORTED;
    }

    bufferSize = (EndpointParameters->TransferType == Isochronous) ?
        sizeof(ISOCH_TRANSFER_BUFFER) :
        sizeof(ASYNC_TRANSFER_BUFFER);
    RtlZeroMemory(&EndpointData->DbList->Async[0],
                  EndpointData->DbCount*bufferSize);

    for (i=0; i<EndpointData->DbCount; i++) {
        if (EndpointParameters->TransferType == Isochronous) {
            EndpointData->DbList->Isoch[i].PhysicalAddress = phys;
            EndpointData->DbList->Isoch[i].Sig = SIG_HCD_IDB;
        } else {
            EndpointData->DbList->Async[i].PhysicalAddress = phys;
            EndpointData->DbList->Async[i].Sig = SIG_HCD_ADB;
        }

        phys += bufferSize;
    }

    buffer += EndpointData->DbCount*bufferSize;
    bytes -= EndpointData->DbCount*bufferSize;

    //
    // Make the transfer descriptors
    //
    EndpointData->TdsUsed = 0;
    EndpointData->TdList = (PHCD_TD_LIST) buffer;
    EndpointData->TdCount = bytes/sizeof(HCD_TRANSFER_DESCRIPTOR);
    RtlZeroMemory(EndpointData->TdList,
                  EndpointData->TdCount*sizeof(HCD_TRANSFER_DESCRIPTOR));
    for (i=0; i<EndpointData->TdCount; i++) {
        td = &EndpointData->TdList->Td[i];

        td->PhysicalAddress = phys;
        td->Sig = SIG_HCD_TD;
        td->TransferContext = UHCI_BAD_POINTER;

        phys += sizeof(HCD_TRANSFER_DESCRIPTOR);
    }

    // make sure we have enough
    UHCI_ASSERT(DeviceData, EndpointData->TdCount >= numTds);

    // current head, tail are NULL TD
    EndpointData->HeadTd = EndpointData->TailTd = NULL;

    return USBMP_STATUS_SUCCESS;
}


VOID
UhciCloseEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    TEST_TRAP();
}


USB_MINIPORT_STATUS
UhciPokeEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    ULONG oldBandwidth;

    LOGENTRY(DeviceData, G, '_Pok', EndpointData,
        EndpointParameters, 0);
    UhciKdPrint((DeviceData, 2, "'Poke Endpoint 0x%x.\n", EndpointData));

    qh = EndpointData->QueueHead;

    oldBandwidth = EndpointData->Parameters.Bandwidth;
    EndpointData->Parameters = *EndpointParameters;

//    qh->HwQH.EpChars.DeviceAddress = EndpointData->Parameters.DeviceAddress;

//    qh->HwQH.EpChars.MaximumPacketLength = EndpointData->Parameters.MaxPacketSize;

    return USBMP_STATUS_SUCCESS;
}


ULONG
UhciQueryControlRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for a control
    endpoint.

Arguments:

Return Value:

    control buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    *NumberOfTDs =
        EndpointParameters->MaxTransferSize/EndpointParameters->MaxPacketSize+2;

    // Add one more double buffer for the setup packet.
    *NumberOfDoubleBuffers = 1 +
        (EndpointParameters->MaxTransferSize + USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeC',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


ULONG
UhciQueryIsoRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an iso
    endpoint.

Arguments:

Return Value:

    iso buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    // we need enough TDs for two transfers of MAX_ISO_PACKETS_PER_TRANSFER
    // our max size will be set a MAX_ISOCH_TRANSFER_SIZE so we will never
    // see a transfer larger than MAX_ISOCH_TRANSFER_SIZE or more packets
    // than MAX_ISO_PACKETS_PER_TRANSFER

    // comput TDs base on number of packets per request
    *NumberOfTDs = MAX_ISO_PACKETS_PER_TRANSFER*2;

    // compute double buffers based on largest transfer
    *NumberOfDoubleBuffers =
        (MAX_ISOCH_TRANSFER_SIZE+USB_PAGE_SIZE-1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ISOCH_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeI',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);


    return minCommonBufferBytes;
}


ULONG
UhciQueryBulkRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an iso
    endpoint.

Arguments:

Return Value:

    iso buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

     //
     // Need enough for two transfers on the hardware.
     //

    *NumberOfTDs =
        2*MAX_BULK_TRANSFER_SIZE/EndpointParameters->MaxPacketSize;
    *NumberOfDoubleBuffers =
        2*(MAX_BULK_TRANSFER_SIZE + USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeB',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


ULONG
UhciQueryInterruptRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    )
/*++

Routine Description:

    computes requirents and returns the number of
    common buffer bytes required for an interrupt
    endpoint.

Arguments:

Return Value:

    interrupt buffer bytes needed

--*/
{
    ULONG minCommonBufferBytes;

    //
    // Since we now have split transfer support, we don't need to allocate
    // that many tds.
    //

    *NumberOfTDs = 2*MAX_INTERRUPT_TDS_PER_TRANSFER;
    *NumberOfDoubleBuffers =
        2*((EndpointParameters->MaxPacketSize*MAX_INTERRUPT_TDS_PER_TRANSFER) +
           USB_PAGE_SIZE - 1)/USB_PAGE_SIZE;

    minCommonBufferBytes =
        sizeof(HCD_QUEUEHEAD_DESCRIPTOR) +
        *NumberOfTDs*sizeof(HCD_TRANSFER_DESCRIPTOR) +
        *NumberOfDoubleBuffers*sizeof(ASYNC_TRANSFER_BUFFER);

    LOGENTRY(DeviceData, G, '_QeI',
        minCommonBufferBytes,
        *NumberOfTDs,
        *NumberOfDoubleBuffers);

    return minCommonBufferBytes;
}


USB_MINIPORT_STATUS
UhciQueryEndpointRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    )
/*++

Routine Description:

    compute how much common buffer we will need
    for this endpoint

Arguments:

Return Value:

--*/
{
    ULONG numTds, numDbs;

    EndpointRequirements->MaximumTransferSize =
        EndpointParameters->MaxTransferSize;

    LOGENTRY(DeviceData, G, '_Qep',
            EndpointRequirements->MaximumTransferSize,
            EndpointParameters->TransferType, 0);

    switch (EndpointParameters->TransferType) {

    case Control:
        //
        // Need enough for one full transfer.
        //
        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryControlRequirements(DeviceData,
                                         EndpointParameters,
                                         &numTds,
                                         &numDbs);
        break;

    case Interrupt:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryInterruptRequirements(DeviceData,
                                           EndpointParameters,
                                           &numTds,
                                           &numDbs);

        EndpointRequirements->MaximumTransferSize =
            EndpointParameters->MaxPacketSize*MAX_INTERRUPT_TDS_PER_TRANSFER;

        break;

    case Bulk:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryBulkRequirements(DeviceData,
                                      EndpointParameters,
                                      &numTds,
                                      &numDbs);

        EndpointRequirements->MaximumTransferSize =
            MAX_BULK_TRANSFER_SIZE;
        break;

    case Isochronous:

        EndpointRequirements->MinCommonBufferBytes =
            UhciQueryIsoRequirements(DeviceData,
                                         EndpointParameters,
                                         &numTds,
                                         &numDbs);

        EndpointRequirements->MaximumTransferSize =
            MAX_ISOCH_TRANSFER_SIZE;
        break;

    default:
        TEST_TRAP();
        return USBMP_STATUS_NOT_SUPPORTED;
    }

    LOGENTRY(DeviceData, G, '_QER',
            numTds,
            numDbs,
            EndpointRequirements->MinCommonBufferBytes);

    return USBMP_STATUS_SUCCESS;
}


VOID
UhciPollEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    switch(EndpointData->Parameters.TransferType) {

    case Control:
    case Bulk:
    case Interrupt:
        UhciPollAsyncEndpoint(DeviceData, EndpointData);
        break;

    case Isochronous:
        UhciPollIsochEndpoint(DeviceData, EndpointData);
        break;

    default:
        TEST_TRAP();

    }
}


PHCD_TRANSFER_DESCRIPTOR
UhciAllocTd(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    Allocate a TD from an endpoint's pool

Arguments:

Return Value:

--*/
{
    ULONG i,j;
    PHCD_TRANSFER_DESCRIPTOR td;

    for (i=EndpointData->TdLastAllocced, j=0;
         j<EndpointData->TdCount;
         j++, i = (i+1 < EndpointData->TdCount) ? i+1 : 0) {
        td = &EndpointData->TdList->Td[i];

        if (!TEST_FLAG(td->Flags, TD_FLAG_BUSY)) {
            SET_FLAG(td->Flags, TD_FLAG_BUSY);
            LOGENTRY(DeviceData, G, '_aTD', td, 0, 0);
            EndpointData->TdLastAllocced = i;
            EndpointData->TdsUsed++;
            return td;
        }
    }

    // we should always find one
    UHCI_ASSERT(DeviceData, FALSE);
    TRAP_FATAL_ERROR();
    return UHCI_BAD_POINTER;
}

PTRANSFER_BUFFER
UhciAllocDb(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN BOOLEAN Isoch
    )
/*++

Routine Description:

    Allocate a double buffer from an endpoint's pool

Arguments:

Return Value:

--*/
{
    ULONG i,j;
    PISOCH_TRANSFER_BUFFER idb;
    PASYNC_TRANSFER_BUFFER adb;

    for (i=EndpointData->DbLastAllocced, j=0;
         j<EndpointData->DbCount;
         j++, i = (i+1 < EndpointData->DbCount) ? i+1 : 0) {
        if (Isoch) {
            idb = &EndpointData->DbList->Isoch[i];
            if (!TEST_FLAG(idb->Flags, DB_FLAG_BUSY)) {
                SET_FLAG(idb->Flags, DB_FLAG_BUSY);
                LOGENTRY(DeviceData, G, '_iDB', idb, 0, 0);
                EndpointData->DbLastAllocced = i;
                EndpointData->DbsUsed++;
                UHCI_ASSERT(DeviceData, idb->Sig == SIG_HCD_IDB);
                return (PTRANSFER_BUFFER)idb;
            }
        } else {
            adb = &EndpointData->DbList->Async[i];
            if (!TEST_FLAG(adb->Flags, DB_FLAG_BUSY)) {
                SET_FLAG(adb->Flags, DB_FLAG_BUSY);
                LOGENTRY(DeviceData, G, '_aDB', adb, 0, 0);
                EndpointData->DbLastAllocced = i;
                EndpointData->DbsUsed++;
                UHCI_ASSERT(DeviceData, adb->Sig == SIG_HCD_ADB);
                return (PTRANSFER_BUFFER)adb;
            }
        }
    }

    // we should always find one
    UHCI_ASSERT(DeviceData, FALSE);
    TRAP_FATAL_ERROR();
    return UHCI_BAD_POINTER;
}

VOID
UhciSetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATUS Status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_REGISTER hc;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    qh = EndpointData->QueueHead;

    LOGENTRY(DeviceData, G, '_set', EndpointData, Status, 0);
    UhciKdPrint((DeviceData, 2, "'Set Endpoint 0x%x Status %x.\n",
                 EndpointData, Status));

    switch(Status) {
    case ENDPOINT_STATUS_RUN:
        if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {
            CLEAR_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED);
            // Next transfer or status phase of a control transfer.
            SET_QH_TD(DeviceData, EndpointData, EndpointData->HeadTd);
        }
        break;

    case ENDPOINT_STATUS_HALT:
        TEST_TRAP();
        break;
    }
}


MP_ENDPOINT_STATUS
UhciGetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATUS status;

    UhciKdPrint((DeviceData, 2, "'Get Endpoint status 0x%x.\n", EndpointData));
    status = ENDPOINT_STATUS_RUN;

    if (TEST_FLAG(EndpointData->Flags, UHCI_EDFLAG_HALTED)) {
        status = ENDPOINT_STATUS_HALT;
    }

    LOGENTRY(DeviceData, G, '_ges', EndpointData, status, 0);

    return status;
}


VOID
UhciSetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    LOGENTRY(DeviceData, G, '_ses', EndpointData, 0, State);

    UhciKdPrint((DeviceData, 2, "'Set Endpoint 0x%x state %x.\n", EndpointData, State));
    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Bulk:
    case Interrupt:
        UhciSetAsyncEndpointState(DeviceData,
                                  EndpointData,
                                  State);
        break;
    case Isochronous:
        UhciSetIsochEndpointState(DeviceData,
                                  EndpointData,
                                  State);

        break;
    default:
        TRAP_FATAL_ERROR();
    }

}


MP_ENDPOINT_STATE
UhciGetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    MP_ENDPOINT_STATE currentState;
    PHCD_QUEUEHEAD_DESCRIPTOR qh;

    // assume we are active
    currentState = ENDPOINT_ACTIVE;

    qh = EndpointData->QueueHead;

    // removed from schedule?
    if (!TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_IN_SCHEDULE)) {
        // yes
        currentState = TEST_FLAG(qh->QhFlags, UHCI_QH_FLAG_QH_REMOVED) ?
                ENDPOINT_REMOVE : ENDPOINT_PAUSE;
    }

    UhciKdPrint((DeviceData, 2, "'Get Endpoint 0x%x state %x.\n", EndpointData, currentState));

    LOGENTRY(DeviceData, G, '_ges', EndpointData, 0, currentState);

    return currentState;
}


ULONG
UhciGet32BitFrameNumber(
    IN PDEVICE_DATA DeviceData
    )
{
    ULONG n, fn, hp;
    PHC_REGISTER reg = NULL;

    reg = DeviceData->Registers;
    fn = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    hp = DeviceData->FrameNumberHighPart;
    n = fn | (hp + ((hp ^ fn) & 0x400));

    return n;
}

VOID
UhciUpdateCounter(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Updates the 32 bit frame counter.

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg = DeviceData->Registers;
    ULONG fn, hp;

    //
    // This code maintains the 32-bit 1 ms frame counter
    //
    fn = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    hp = DeviceData->FrameNumberHighPart;
    if ((fn & 0x7FF) != fn) {
        UhciKdPrint((DeviceData, 0, "UhciUpdateCounter framenumber gone: %x.\n", fn));
        return;
    }

    // did the sign bit change ?
    if ((hp&0X400) != (fn&0X400)) {
        // Yes
        DeviceData->FrameNumberHighPart += 0x400;
    }
    // remember the last frame number
//    DeviceData->LastFrameCounter = fn;
}

VOID
UhciPollController(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHC_REGISTER reg = NULL;
    FRNUM frameIndex;
    USHORT i, frame;
    QH_LINK_POINTER newLink;
    PLIST_ENTRY listEntry;
    PENDPOINT_DATA endpointData;


    if (TEST_FLAG(DeviceData->Flags, UHCI_DDFLAG_SUSPENDED)) {
        // indicates polling while controller is 
        // suspended but in D0
        //
        // should invalidate the root hub only if changes 
        // are detected on the root ports.
        return;
    }
    
    // this also cleans out the SOF Tds and
    // the rollover Td so we always run it
    UhciCleanOutIsoch(DeviceData, FALSE);

    //
    // Update the 32 bit frame counter here so we don't
    // need a rollover interrupt.
    //
    UhciUpdateCounter(DeviceData);

    //
    // Notify the port driver to check the ports
    // for any connects/disconnects.
    //
    USBPORT_INVALIDATE_ROOTHUB(DeviceData);
}


USB_MINIPORT_STATUS
UhciSubmitTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    )
{
    USB_MINIPORT_STATUS mpStatus = USBMP_STATUS_FAILURE;

    IncPendingTransfers(DeviceData, EndpointData);

    // init the context
    RtlZeroMemory(TransferContext, sizeof(*TransferContext));
    TransferContext->Sig = SIG_UHCI_TRANSFER;
    TransferContext->UsbdStatus = USBD_STATUS_SUCCESS;
    TransferContext->EndpointData = EndpointData;
    TransferContext->TransferParameters = TransferParameters;

    switch (EndpointData->Parameters.TransferType) {
    case Control:
        mpStatus = UhciControlTransfer(
                        DeviceData,
                        EndpointData,
                        TransferParameters,
                        TransferContext,
                        TransferSGList);
        break;
    case Interrupt:
    case Bulk:
        mpStatus = UhciBulkOrInterruptTransfer(
                        DeviceData,
                        EndpointData,
                        TransferParameters,
                        TransferContext,
                        TransferSGList);
        break;
    default:
        TEST_TRAP();
        mpStatus = USBMP_STATUS_SUCCESS;
    }

    return mpStatus;
}


VOID
UhciAbortTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    )
{
    UhciKdPrint((DeviceData, 2, "'Abort transfer 0x%x for EP 0x%x.\n", TransferContext, EndpointData));

    DecPendingTransfers(DeviceData, EndpointData);

    switch (EndpointData->Parameters.TransferType) {
    case Control:
    case Interrupt:
    case Bulk:
        UhciAbortAsyncTransfer(
            DeviceData,
            EndpointData,
            TransferContext,
            BytesTransferred);
        break;
    default:
        UhciAbortIsochTransfer(
            DeviceData,
            EndpointData,
            TransferContext);
    }
}


USB_MINIPORT_STATUS
UhciPassThru (
    IN PDEVICE_DATA DeviceData,
    IN GUID *FunctionGuid,
    IN ULONG ParameterLength,
    IN OUT PVOID Parameters
    )
{
    //TEST_TRAP();
    return USBMP_STATUS_NOT_SUPPORTED;
}


VOID
UhciSetEndpointDataToggle(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN ULONG Toggle
    )
/*++

Routine Description:

Arguments:

    Sent after a pipe reset to reset the toggle.

Return Value:

--*/

{
    PHCD_QUEUEHEAD_DESCRIPTOR qh;
    PHCD_TRANSFER_DESCRIPTOR td;

    UhciKdPrint((DeviceData, 2, "'Pipe reset. Set endpoint data toggle. EP %x\n", EndpointData));
//    TEST_TRAP();
    if (EndpointData->Parameters.TransferType == Control ||
        EndpointData->Parameters.TransferType == Isochronous) {

        // nothing to do for control and iso
        return;
    }

    qh = EndpointData->QueueHead;

    UHCI_ASSERT(DeviceData, 0 == Toggle);
    for (td = EndpointData->HeadTd; td; td = td->NextTd) {
        td->HwTD.Token.DataToggle = Toggle;
        Toggle = !Toggle;
    }
    EndpointData->Toggle = Toggle;

    LOGENTRY(DeviceData, G, '_stg', EndpointData, 0, Toggle);
}


USB_MINIPORT_STATUS
USBMPFN
UhciStartSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkspaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    insert structures to transmit a single packet -- this is for debug
    tool purposes only so we can be a little creative here.

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticControlQH;
    PHW_QUEUE_HEAD hwQH;
    ULONG hwQHPhys;
    PUCHAR pch;
    ULONG phys;
    LONG bytesRemaining;
    ULONG currentToggle;
    PHW_QUEUE_ELEMENT_TD currentTD;
    PUCHAR data;
    ULONG dataPhys;
    ULONG currentTDPhys, nextTDPhys;
    ULONG tdsPhys;
    PHW_QUEUE_ELEMENT_TD tds;
    ULONG neededTDs;
    ULONG neededBytes;
    QH_LINK_POINTER newQHLink;

    PSS_PACKET_CONTEXT context;

    //
    // Divide the workspace buffer into a context, a queuehead,
    //  transfer descriptors and the actual data.  First, calculate
    //  if we'll have enough size.  Assuming for now that all we have is
    //  a page to work with at most.
    //

    ASSERT(WorkspaceLength <= PAGE_SIZE);

    //
    // Calculate the number of transfer descriptors that might be needed.
    //  Similar support in the OHCI driver allows multiple packets to be
    //  sent in one data transmission.  That behavior should be mimiced here.
    //

    if (0 != *PacketLength) {
        neededTDs = *PacketLength/PacketParameters->MaximumPacketSize;

        if (neededTDs*PacketParameters->MaximumPacketSize < *PacketLength) {
            neededTDs++;
        }
    }
    else {
        neededTDs = 1;
    }

    neededBytes = sizeof(SS_PACKET_CONTEXT) + sizeof(HW_QUEUE_HEAD) +
                  neededTDs*sizeof(HW_QUEUE_ELEMENT_TD) + *PacketLength;

    if (neededBytes > WorkspaceLength) {
        return USBMP_STATUS_NO_RESOURCES;
    }

    //
    // Carve up the buffer.  Put the context first, followed by the TDs,
    //  the queuehead, and finally the data.  Put the queuehead after the TDs,
    //  to ensure that the queuehead is 16-byte aligned.  This also always the
    //  data size to be 8 bytes larger.
    //

    phys = WorkspacePhysicalAddress;
    pch  = WorkspaceVirtualAddress;
    bytesRemaining = WorkspaceLength;

    LOGENTRY(DeviceData, G, '_ssS', phys, 0, pch);

    //
    // The context contains any information we need in the end packet
    //  routine.
    //

    context = (PSS_PACKET_CONTEXT) pch;
    phys    += sizeof(SS_PACKET_CONTEXT);
    pch     += sizeof(SS_PACKET_CONTEXT);

    //
    // Next the TDs,
    //

    tdsPhys = phys;
    tds     = (PHW_QUEUE_ELEMENT_TD) pch;
    phys    += neededTDs*sizeof(HW_QUEUE_ELEMENT_TD);
    pch     += neededTDs*sizeof(HW_QUEUE_ELEMENT_TD);

    //
    // Now the QueueHead
    //

    hwQHPhys = phys;
    hwQH     = (PHW_QUEUE_HEAD) pch;
    phys     += sizeof(HW_QUEUE_HEAD);
    pch      += sizeof(HW_QUEUE_HEAD);

    //
    // Get the data buffer pointers if there is data to send
    //

    if (0 != *PacketLength) {
        dataPhys = phys;
        data     = pch;

        RtlCopyMemory(data, PacketData, *PacketLength);
    }
    else {
        data     = NULL;
        dataPhys = 0;
    }

    LOGENTRY(DeviceData, G, '_ssD', PacketData, *PacketLength, 0);

    //
    // Start by setting up the QueueHead.  Set the terminate bit of
    //  the horizontal pointer.  The vertical pointer should point to
    //  the td that is to be used
    //
    //

    RtlZeroMemory(hwQH, sizeof(HW_QUEUE_HEAD));

    hwQH->HLink.Terminate = 1;

    hwQH->VLink.HwAddress  = tdsPhys;
    hwQH->VLink.Terminate  = 0;
    hwQH->VLink.QHTDSelect = 0;
    hwQH->VLink.DepthBreadthSelect = 0;

    //
    // Save pointers to the transfer descriptors and the data
    //  in the context so we can retrieve them when ending this
    //  transfer.
    //

    HW_PTR(context->Data)    = data;
    HW_PTR(context->FirstTd) = (PUCHAR) tds;

    //
    // Now, setup the transfer descriptor to describe this transfer
    //

    currentTDPhys  = tdsPhys;
    currentTD      = tds;
    bytesRemaining = *PacketLength;

    currentToggle = PacketParameters->Toggle;

    LOGENTRY(DeviceData, G, '_ss2', tds, context, hwQH);
    LOGENTRY(DeviceData, G, '_ss3', dataPhys, data, *PacketLength);

    while (1) {

        nextTDPhys = currentTDPhys+sizeof(HW_QUEUE_ELEMENT_TD);

        RtlZeroMemory(currentTD, sizeof(HW_QUEUE_ELEMENT_TD));

        currentTD->Control.Active = 1;
        currentTD->Control.InterruptOnComplete = 0;
        currentTD->Control.IsochronousSelect = 0;
        currentTD->Control.LowSpeedDevice =
                                   (ss_Low == PacketParameters->Speed) ? 1 : 0;
        currentTD->Control.ErrorCount = 3;
        currentTD->Control.ShortPacketDetect = 1;

        currentTD->Token.DeviceAddress = PacketParameters->DeviceAddress;
        currentTD->Token.Endpoint      = PacketParameters->EndpointAddress;
        currentTD->Token.DataToggle    = currentToggle;

        if (bytesRemaining < PacketParameters->MaximumPacketSize) {
            currentTD->Token.MaximumLength = MAXIMUM_LENGTH(bytesRemaining);
        }
        else {
            currentTD->Token.MaximumLength =
                           MAXIMUM_LENGTH(PacketParameters->MaximumPacketSize);
        }

        switch (PacketParameters->Type) {
        case ss_Setup:
            LOGENTRY(DeviceData, G, '_ssU', 0, 0, 0);
            currentTD->Token.Pid = SetupPID;
            break;

        case ss_In:
            LOGENTRY(DeviceData, G, '_ssI', 0, 0, 0);
            currentTD->Token.Pid = InPID;
            break;

        case ss_Out:
            LOGENTRY(DeviceData, G, '_ssO', 0, 0, 0);
            currentTD->Token.Pid = OutPID;
            break;

        case ss_Iso_In:
        case ss_Iso_Out:
            break;
        }

        currentTD->Buffer = dataPhys;

        currentTD->LinkPointer.HwAddress = nextTDPhys;
        currentTD->LinkPointer.QHTDSelect = 0;
        currentTD->LinkPointer.DepthBreadthSelect = 1;

        if (bytesRemaining <= PacketParameters->MaximumPacketSize) {
            currentTD->LinkPointer.Terminate = 1;
            break;
        }
        else {
            currentTD->LinkPointer.Terminate = 0;
        }

        //
        // Setup for the next loop
        //

        currentTD++;
        currentTDPhys = nextTDPhys;
        bytesRemaining -= PacketParameters->MaximumPacketSize;
        dataPhys += PacketParameters->MaximumPacketSize;
        data     += PacketParameters->MaximumPacketSize;
        currentToggle = !currentToggle;
    }

    //
    // The queue head and all TDs have been linked together.  Add it
    //  to the schedule.  To mimic the OHCI behavior, we'll add it to
    //  the front of the control queue, saving off the previous link
    //  value.  By not linking to any other queue heads in the HLink,
    //  we are turning off the bulk transfers as well.
    //
    // In the EndPacket function, the control and bulk queues will be
    //  turned back on.
    //

    //
    //  Grab the static queuehead for the device
    //

    staticControlQH = DeviceData->ControlQueueHead;

    //
    // Create the new HLink pointer that will be needed to add
    //  to the static control queue head's hlink field
    //

    newQHLink.HwAddress = hwQHPhys;
    newQHLink.Terminate = 0;
    newQHLink.QHTDSelect = 1;
    newQHLink.Reserved  = 0;

    //
    // Perform an interlocked exchange to swap the current control list
    //  with the "special" queue list. Also save off the rest of the
    //  info in the context structure.
    //

    context->OldControlQH = InterlockedExchange((PLONG) &staticControlQH->HwQH.HLink,
                                                *((PLONG) &newQHLink));

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBMPFN
UhciEndSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PHCD_QUEUEHEAD_DESCRIPTOR staticControlQH;
    PHW_QUEUE_ELEMENT_TD tdWalk;
    PSS_PACKET_CONTEXT context;
    USBD_STATUS usbdStatus;
    ULONG bytesTransferred;
    PUCHAR  data;
    BOOLEAN walkDone;

    context = (PSS_PACKET_CONTEXT) WorkspaceVirtualAddress;

    //
    // Walk the TDs on our queuehead and looking to see if this transfer is
    //  done.  This would occur if all TDs are complete, a TD had an error,
    //  or a TD completed with a short packet.
    //

    bytesTransferred = 0;
    walkDone = FALSE;
    tdWalk = (PHW_QUEUE_ELEMENT_TD) HW_PTR(context->FirstTd);

    LOGENTRY(DeviceData, G, '_ssE', tdWalk, 0, 0);

    while (!walkDone) {

        if (tdWalk->Control.Active) {
            return (USBMP_STATUS_BUSY);
        }

        usbdStatus = UhciGetErrorFromTD(DeviceData,
                                        (PHCD_TRANSFER_DESCRIPTOR) tdWalk);

        switch (usbdStatus) {
        case USBD_STATUS_ERROR_SHORT_TRANSFER:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            usbdStatus = USBD_STATUS_SUCCESS;
            walkDone=TRUE;
            break;

        case USBD_STATUS_SUCCESS:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            if (tdWalk->LinkPointer.Terminate) {
                ASSERT(bytesTransferred == *PacketLength);
                walkDone = TRUE;
            }
            break;

        default:
            bytesTransferred += ACTUAL_LENGTH(tdWalk->Control.ActualLength);
            walkDone=TRUE;
            break;
        }

        tdWalk++;
    }

    //
    // Copy the data that was transferred back to the original buffer
    //

    *PacketLength = bytesTransferred;

    if (NULL != HW_PTR(context->Data))
    {
        RtlCopyMemory(PacketData,
                      HW_PTR(context->Data),
                      *PacketLength);
    }
    LOGENTRY(DeviceData, G, '_ssX', tdWalk-1, *PacketLength, 0);

    //
    // Restore the original queue list
    //

    staticControlQH = DeviceData->ControlQueueHead;

    InterlockedExchange((PLONG) &staticControlQH->HwQH.HLink,
                        context->OldControlQH);

    //
    // Set the appropriate usbdStatus and return successful status
    //

    *UsbdStatus = usbdStatus;

    return USBMP_STATUS_SUCCESS;

}


USBD_STATUS
UhciGetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    )
/*++

Routine Description:

    Maps the error bits in the TD to a USBD_STATUS code

Arguments:

Return Value:

--*/

{
    if (Td->HwTD.Control.ul & CONTROL_STATUS_MASK) {
        if (Td->HwTD.Control.Stalled &&
            Td->HwTD.Control.BabbleDetected) {
            LOGENTRY(DeviceData, G, '_bbl', 0, 0, 0);
            return USBD_STATUS_BUFFER_OVERRUN;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   Td->HwTD.Control.Stalled) {
            LOGENTRY(DeviceData, G, '_dnr', 0, 0, 0);
            return USBD_STATUS_DEV_NOT_RESPONDING;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) != 0) {
            LOGENTRY(DeviceData, G, '_crc', 0, 0, 0);
            return USBD_STATUS_CRC;
        } else if (Td->HwTD.Control.TimeoutCRC &&
                   ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) == 0) {
            LOGENTRY(DeviceData, G, '_crd', 0, 0, 0);
            return USBD_STATUS_DEV_NOT_RESPONDING;
        } else if (Td->HwTD.Control.DataBufferError) {
            LOGENTRY(DeviceData, G, '_dto', 0, 0, 0);
            return USBD_STATUS_DATA_OVERRUN;
        } else if (Td->HwTD.Control.Stalled) {
            LOGENTRY(DeviceData, G, '_stl', 0, 0, 0);
            return USBD_STATUS_STALL_PID;
        } else {
            LOGENTRY(DeviceData, G, '_inE', 0, 0, 0);
            return USBD_STATUS_INTERNAL_HC_ERROR;
        }
    } else {
        if ((ACTUAL_LENGTH(Td->HwTD.Control.ActualLength) <
            ACTUAL_LENGTH(Td->HwTD.Token.MaximumLength)) &&
            !Td->HwTD.Control.IsochronousSelect) {
            LOGENTRY(DeviceData, G, '_shT', 0, 0, 0);
            return USBD_STATUS_ERROR_SHORT_TRANSFER;
            // not USBD_STATUS_DATA_UNDERRUN?
        }
    }

    return USBD_STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////
//
// Power functions
//
//////////////////////////////////////////////////////////

VOID
UhciSuspendController(
    IN PDEVICE_DATA DeviceData
    )
{
    PHC_REGISTER reg;
    USBCMD command;
    USBSTS status;
    USHORT legsup;
    ULONG i;

    reg = DeviceData->Registers;
    SET_FLAG(DeviceData->Flags, UHCI_DDFLAG_SUSPENDED);

    // Check things out before we suspend.
    UhciKdPrint((DeviceData, 2, "'HC regs before suspend\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));
    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));


    // save volitile regs
    DeviceData->SuspendFrameListBasePhys.ul =
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) & (~(0x00000FFF));
    DeviceData->SuspendFrameNumber.us =
        READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;

    // Save away the command register
    DeviceData->SuspendCommandReg.us =
        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);

    // Stop the controller
    command.RunStop = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the HC to halt
    for (i = 0; i < 10; i++) {
        status.us = READ_PORT_USHORT(&reg->UsbStatus.us);
        if (status.HCHalted) {
            break;
        }
        USBPORT_WAIT(DeviceData, 1);
    }

    if (!status.HCHalted) {

        // Can't get the HCHalted bit to stick, so reset the controller.
        command.GlobalReset = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

        USBPORT_WAIT(DeviceData, 10);

        command.GlobalReset = 0;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

        // Re-enable interrupts, since they are zero'd out on reset.
        WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->EnabledInterrupts.us);

    }

    // bugbug - should we reset the frame list current index like uhcd?
/*    WRITE_PORT_USHORT(&reg->FrameNumber, 0);
    // re-initialize internal frame counters.
    DeviceData->FrameNumberHighPart =
        deviceExtension->LastFrame = 0;
*/

    // Finally, suspend the bus
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

}

USB_MINIPORT_STATUS
UhciResumeController(
    IN PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    reverse what was done in 'suspend'

Arguments:

Return Value:

    None

--*/
{
    PHC_REGISTER reg;
    USBCMD command;
    USHORT counter, oldCounter;
    USHORT legsup, tmp;
    ULONG i;
    ULONG tmpl;

    reg = DeviceData->Registers;

    // consistency check the controller to see if the BIOS
    // or power management messed us up.
    CLEAR_FLAG(DeviceData->Flags, UHCI_DDFLAG_SUSPENDED);

    tmp = READ_PORT_USHORT(&reg->UsbCommand.us);
    if (tmp == UHCI_HARDWARE_GONE) {
        UhciKdPrint((DeviceData, 0, "'Command register is toast.\n"));
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

#if 0
    // This code was added to fix a power management problem on 
    // a particular COMPAQ platform AFTER the source for Windows XP
    // was 'locked down'.  The code worked but COMPAQ
    // opted to put something into their BIOS instead (I think).
    // In any event they never pressed the issue furthur. 
    // 
    // The code restores the state of the port registers if the 
    // command register has been zero'ed out.
    
    if (tmp == 0) {
        PORTSC port;
        ULONG p;

        TEST_TRAP();
        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'1>port %d %x\n", p+1, port.us));
            port.PortConnectChange = 1;
            port.PortEnableChange = 1;
            WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'2>port %d %x\n", p+1, port.us));

            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            UhciKdPrint((DeviceData, 0, "'3>port %d %x\n", p+1, port.us));
            if (port.PortConnect) {
                port.PortEnable = 1;
                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
            }
        }

        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);     
        UhciKdPrint((DeviceData, 0, "'1> cmd %x\n", command.us));
        command.EnterGlobalSuspendMode = 1;
        command.MaxPacket = 1;
        WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);
        UhciKdPrint((DeviceData, 0, "'2> cmd %x\n", command.us));            
    }
#endif    

    // if the controller is not suspended then we'll fail the
    // resume, the BIOS probably reset the controller or the
    // bus may have lost power
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    if (!command.EnterGlobalSuspendMode) {
        UhciKdPrint((DeviceData, 0, "'RESUME> controller is toast (not in suspend).\n"));
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    //
    // The following is from UHCD_RestoreHCState
    //

    UhciKdPrint((DeviceData, 2, "'<HC regs after suspend>\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));

    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));

    // usbport will not ask to suspend if power is lost, however,
    // on suspend the chipset may lose the frame number and
    // FLBA (I don't know why) we therefore must save and  restore
    // these across suspend

    // restore the FLBA and frame counter
    UhciKdPrint((DeviceData, 2, "'restoring FLBA\n"));
    WRITE_PORT_USHORT(&reg->FrameNumber.us,
                      DeviceData->SuspendFrameNumber.us);
    WRITE_PORT_ULONG(&reg->FrameListBasePhys.ul,
                     DeviceData->SuspendFrameListBasePhys.ul);
    //WRITE_PORT_USHORT(&reg->UsbInterruptEnable.us, DeviceData->SuspendInterruptEnable.us);

    //
    // The following is from UHCD_Resume
    //
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    // Wait for the spec'd 20 ms so that the controller
    // can resume.
    USBPORT_WAIT(DeviceData, 20);

    // Done with resume.
    // Clear the suspend and resume bits.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    command.ForceGlobalResume = 0;
    command.EnterGlobalSuspendMode = 0;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);


    // Wait for the resume bit to go low.
    command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
    i = 0;
    while (command.ForceGlobalResume && i<10) {
        KeStallExecutionProcessor(50);
        command.us = READ_PORT_USHORT(&reg->UsbCommand.us);
        i++;
    }

    if (command.ForceGlobalResume) {
        TEST_TRAP();
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    // start the controller
    command = DeviceData->SuspendCommandReg;
    command.RunStop = 1;
    WRITE_PORT_USHORT(&reg->UsbCommand.us, command.us);

    //
    // Make sure that the controller is really running and if not,
    // fail the resume.
    //
    oldCounter = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    USBPORT_WAIT(DeviceData, 5);
    counter = READ_PORT_USHORT(&reg->FrameNumber.us)&0x7ff;
    if(counter == oldCounter) {
        return USBMP_STATUS_HARDWARE_FAILURE;
    }

    // clear resume bits on the ports
    if (DeviceData->ControllerFlavor != UHCI_Piix4 &&
        !ANY_VIA(DeviceData)) {
        PORTSC port;
        ULONG p;

        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            if (port.PortConnect == 0 ||
                port.PortEnable == 0) {
                port.Suspend = 0;

                MASK_CHANGE_BITS(port);

                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
                UhciKdPrint((DeviceData, 1, "'<resume port %d>\n", p));
            }
        }
    }

#if 0
    // Special hack for ICH2_2 + Samsung keyboard
    //
    // resume signalling from this keyboard is not to spec and this
    // causes problems on the ICH2, if resume signalling is generated
    // the root port will be disabled and a connect change will be 
    // indicated.
    // It might be possible to detect this case and correct it although 
    // I'm not sure of the side effects -- the code here is included 
    // for reference.
    
    if (DeviceData->ControllerFlavor == UHCI_Ich2_2) { 
        PORTSC port;
        ULONG p;

        for (p=0; p<2; p++) {
            port.us = READ_PORT_USHORT(&reg->PortRegister[p].us);
            if (port.PortConnect == 1 &&
                port.Suspend == 1 && 
                port.PortEnable == 0) {

                port.PortEnable = 1;

                WRITE_PORT_USHORT(&reg->PortRegister[p].us, port.us);
                UhciKdPrint((DeviceData, 1, "'<resume (ICH2_2) port %d>\n", p));
            }
        }
    }
#endif

    UhciKdPrint((DeviceData, 2, "'<HC regs after resume>\n"));
    UhciKdPrint((DeviceData, 2, "'cmd register = %x\n",
        READ_PORT_USHORT(&reg->UsbCommand.us) ));
    UhciKdPrint((DeviceData, 2, "'status register = %x\n",
        READ_PORT_USHORT(&reg->UsbStatus.us) ));
    UhciKdPrint((DeviceData, 2, "'interrupt enable register = %x\n",
        READ_PORT_USHORT(&reg->UsbInterruptEnable.us) ));
    UhciKdPrint((DeviceData, 2, "'frame list base = %x\n",
        READ_PORT_ULONG(&reg->FrameListBasePhys.ul) ));

    UhciKdPrint((DeviceData, 2, "'port1 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[0].us) ));
    UhciKdPrint((DeviceData, 2, "'port2 = %x\n",
        READ_PORT_USHORT(&reg->PortRegister[1].us) ));

     return USBMP_STATUS_SUCCESS;
}


BOOLEAN UhciHardwarePresent(
     PDEVICE_DATA DeviceData
     )
{
    PHC_REGISTER reg;
    USBSTS status;
    // USBCMD command;

    reg = DeviceData->Registers;

    // bits 15:6 must be zero
    status.us = READ_PORT_USHORT(&reg->UsbStatus.us);

    if (status.us == 0xffff) {

        UhciKdPrint((DeviceData, 0, "'Hardware Gone\n"));
        return FALSE;
    }

    return TRUE;

}

VOID
UhciCheckController(
    PDEVICE_DATA DeviceData
    )
{
    if (!UhciHardwarePresent(DeviceData) ||
        (DeviceData->HCErrorCount >= UHCI_HC_MAX_ERRORS)) {
        USBPORT_INVALIDATE_CONTROLLER(DeviceData, UsbMpControllerRemoved);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\uhci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    uhci.h

Abstract:

   Definitions from USB 1.0 Universal host controller specification

Environment:

    Kernel & user mode

Revision History:

    7-20-00 : created jsenior

--*/


#ifndef __UHCI_H__
#define __UHCI_H__

#include <PSHPACK4.H>
//
// Don't use <PSHPACK1.H> on shared memory data structures that should only
// be accessed using 4-byte load/store instructions (e.g use ld4 instructions
// instead of ld1 instructions on ia64 machines).
//


//
// PCI host controller hardware registers
//

#define VIA_FIFO_MANAGEMENT     0x42    // offset of VIA's fifo management bit
#define VIA_FIFO_DISABLE        0x07    // bit two disables the fifo, and
#define VIA_DISABLE_BABBLE_DETECT 0x40  // Bit to set to disable babble detect
#define VIA_INTERNAL_REGISTER   0x40    // offset of reg that enables detects babble
typedef UCHAR VIAFIFO;
typedef ULONG VIABABBLE;

#define LEGACY_BIOS_REGISTER    0xc0    // offset of legacy bios reg

#define LEGSUP_HCD_MODE     0x2000  // value to put in LEGSUP reg for normal HCD use  JMD
#define LEGSUP_BIOS_MODE    0x00BF  // value to put in LEGSUP reg for BIOS/SMI use  JMD

#define LEGSUP_USBPIRQD_EN  0x2000  // bit 13
#define LEGSUP_SMI_ENABLE   0x0010
typedef USHORT USBSETUP;

//
// Host Controler Hardware Registers as accessed in memory
//

//
// USBCMD - USB Command Register
//

typedef union _USBCMD {

    USHORT                 us;
    struct {
        USHORT              RunStop:1;                  // 0
        USHORT              HostControllerReset:1;      // 1
        USHORT              GlobalReset:1;              // 2
        USHORT              EnterGlobalSuspendMode:1;   // 3
        USHORT              ForceGlobalResume:1;        // 4
        USHORT              SoftwareDebug:1;            // 5
        USHORT              ConfigureFlag:1;            // 6
        USHORT              MaxPacket:1;                // 7
        USHORT              Reserved:8;                 // 8-15
    };

} USBCMD, *PUSBCMD;

C_ASSERT((sizeof(USBCMD) == sizeof(USHORT)));

//
// USBSTS - USB Status Register
//

#define HcInterruptStatusMask                   0x0000003F

typedef union _USBSTS {

    USHORT                  us;
    struct {
        // controller interrupt status bits
        USHORT              UsbInterrupt:1;                 // 0
        USHORT              UsbError:1;                     // 1
        USHORT              ResumeDetect:1;                 // 2
        USHORT              HostSystemError:1;              // 3
        USHORT              HostControllerProcessError:1;   // 4
        USHORT              HCHalted:1;                     // 5
        USHORT              Reserved:10;                    // 6-15

    };

} USBSTS, *PUSBSTS;

C_ASSERT((sizeof(USBSTS) == sizeof(USHORT)));


//
// USBINTR - USB Interrupt Enable Register
//

typedef union _USBINTR {

    USHORT                  us;
    struct {
        USHORT              TimeoutCRC:1;                   // 0
        USHORT              Resume:1;                       // 1
        USHORT              InterruptOnComplete:1;          // 2
        USHORT              ShortPacket:1;                  // 3
        USHORT              Reserved:12;                    // 4-15
    };

} USBINTR, *PUSBINTR;

C_ASSERT((sizeof(USBINTR) == sizeof(USHORT)));

//
// FRNUM - Frame Number Register
//

typedef union _FRNUM {

    USHORT                  us;
    struct {
        USHORT              FrameListCurrentIndex:11;      // 0-10
        USHORT              Reserved:5;                    // 11-15
    };

} FRNUM, *PFRNUM;

C_ASSERT((sizeof(FRNUM) == sizeof(USHORT)));

//
// FLBASEADD - Frame list base address register
//

typedef union _FRBASEADD {

    HW_32BIT_PHYSICAL_ADDRESS ul;
    struct {
        ULONG                 Reserved:12;                // 0-11
        ULONG                 BaseAddress:20;             // 12-31
    };

} FRBASEADD, *PFRBASEADD;

C_ASSERT((sizeof(FRBASEADD) == sizeof(ULONG)));

//
// FRNUM - Frame Number Register
//

typedef union _SOFMOD {

    UCHAR                    uc;
    struct {
        UCHAR                SOFTimingValue:7;              // 0-6
        UCHAR                Reserved:1;                    // 7
    };

} SOFMOD, *PSOFMOD;

C_ASSERT((sizeof(SOFMOD) == sizeof(UCHAR)));

//
// PORTSC - Port Status and Control Register
//

typedef union _PORTSC {

    USHORT                  us;
    struct {
        USHORT              PortConnect:1;          // 0
        USHORT              PortConnectChange:1;    // 1
        USHORT              PortEnable:1;           // 2
        USHORT              PortEnableChange:1;     // 3
        USHORT              LineStatus:2;           // 4-5
        USHORT              ResumeDetect:1;         // 6
        USHORT              Reserved1:1;            // 7
        USHORT              LowSpeedDevice:1;       // 8
        USHORT              PortReset:1;            // 9
        USHORT              Overcurrent:1;          // 10
        USHORT              OvercurrentChange:1;    // 11
        USHORT              Suspend:1;              // 12
        USHORT              Reserved3:3;            // 13-15
    };

} PORTSC, *PPORTSC;

C_ASSERT((sizeof(PORTSC) == sizeof(USHORT)));


// OPERATIONAL REGISTER

typedef struct _HC_REGISTER {

    USBCMD                          UsbCommand;         // 00-01h
    USBSTS                          UsbStatus;          // 02-03h
    USBINTR                         UsbInterruptEnable; // 04-05h
    FRNUM                           FrameNumber;      // 06-07h
    FRBASEADD                       FrameListBasePhys;  // 08-0Bh
    SOFMOD                          StartOfFrameModify; // 0Ch
    UCHAR                           Reserved[3];        // 0D-0Fh
    PORTSC                          PortRegister[2];

} HC_REGISTER, *PHC_REGISTER;


#define HcDTYPE_iTD                 0    // iterative TD
#define HcDTYPE_QH                  1    // queue head
#define HcDTYPE_siTD                2    // isochronousTD

#define HW_LINK_FLAGS_MASK          0x00000007

//
// Queue head
//

typedef union _TD_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;
   struct {
        ULONG Terminate:1;                      // 0
        ULONG QHTDSelect:1;                     // 1
        ULONG DepthBreadthSelect:1;             // 2
        ULONG Reserved:1;                       // 3
        ULONG LinkPointer:28;                   // 4-31
   };

} TD_LINK_POINTER, *PTD_LINK_POINTER;

C_ASSERT((sizeof(TD_LINK_POINTER) == sizeof(ULONG)));

typedef union _QH_LINK_POINTER {

   HW_32BIT_PHYSICAL_ADDRESS        HwAddress;
   struct {
        ULONG Terminate:1;                      // 0
        ULONG QHTDSelect:1;                     // 1
        ULONG Reserved:2;                       // 3
        ULONG LinkPointer:28;                   // 4-31
   };

} QH_LINK_POINTER, *PQh_LINK_POINTER;

C_ASSERT((sizeof(QH_LINK_POINTER) == sizeof(ULONG)));

//
// Queue Head Descriptor
//

typedef struct _HW_QUEUE_HEAD {

    QH_LINK_POINTER                 HLink;  // HC horizontal link ptr
                                            // Host Controller Read Only

    TD_LINK_POINTER volatile        VLink;  // HC Element (vertical) link ptr
                                            // Host Controller Read/Write

} HW_QUEUE_HEAD, *PHW_QUEUE_HEAD;

C_ASSERT((sizeof(HW_QUEUE_HEAD) == 8));


//
// Queue Element Transfer Descriptor
//

//
// some USB constants
//

#define InPID       0x69
#define OutPID      0xe1
#define GetPID(ad)  ((ad & 0x80) == 0x80) ? InPID : OutPID
#define SetupPID    0x2d
#define DataToggle0 0
#define DataToggle1 1

typedef ULONG HC_BUFFER_POINTER, *PHC_BUFFER_POINTER;

C_ASSERT((sizeof(HC_BUFFER_POINTER) == sizeof(ULONG)));

#define NULL_PACKET_LENGTH      0x7ff
#define MAXIMUM_LENGTH(l) ((l) == 0 ? NULL_PACKET_LENGTH : (l)-1)
#define ACTUAL_LENGTH(l) ((l) == NULL_PACKET_LENGTH ? 0 : (l)+1)

typedef union _HC_QTD_TOKEN {
    ULONG   ul;
    struct {
        ULONG Pid:8;                    // 0-7
        ULONG DeviceAddress:7;          // 8-14
        ULONG Endpoint:4;               // 15-18
        ULONG DataToggle:1;             // 19
        ULONG Reserved:1;               // 20
        ULONG MaximumLength:11;         // 21-31
    };
} HC_QTD_TOKEN, *PHC_QTD_TOKEN;

C_ASSERT((sizeof(HC_QTD_TOKEN) == sizeof(ULONG)));

#define CONTROL_STATUS_MASK 0x007E0000

typedef union _HC_QTD_CONTROL {
    ULONG   ul;
    struct {
        ULONG ActualLength:11;          // 0-10
        ULONG Reserved1:5;              // 11-15

        // status bits
        ULONG Reserved2:1;              // 16
        ULONG BitstuffError:1;          // 17
        ULONG TimeoutCRC:1;             // 18
        ULONG NAKReceived:1;            // 19
        ULONG BabbleDetected:1;         // 20
        ULONG DataBufferError:1;        // 21
        ULONG Stalled:1;                // 22
        ULONG Active:1;                 // 23

        ULONG InterruptOnComplete:1;    // 24
        ULONG IsochronousSelect:1;      // 25
        ULONG LowSpeedDevice:1;         // 26

        ULONG ErrorCount:2;             // 27-28
        ULONG ShortPacketDetect:1;      // 29
        ULONG Reserved3:2;              // 30-31
    };
} HC_QTD_CONTROL, *PHC_QTD_CONTROL;

C_ASSERT((sizeof(HC_QTD_CONTROL) == sizeof(ULONG)));

typedef struct _HW_QUEUE_ELEMENT_TD {
    TD_LINK_POINTER             LinkPointer;    // Host Controller Read Only
    HC_QTD_CONTROL    volatile  Control;        // Host Controller Read/Write
    HC_QTD_TOKEN                Token;          // Host Controller Read Only
    HC_BUFFER_POINTER           Buffer;         // Host Controller Read Only
} HW_QUEUE_ELEMENT_TD, *PHW_QUEUE_ELEMENT_TD;

C_ASSERT((sizeof(HW_QUEUE_ELEMENT_TD) == 16));

//
// General Transfer Descriptor
//

typedef union _HW_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD         qTD;
} HW_TRANSFER_DESCRIPTOR, *PHW_TRANSFER_DESCRIPTOR;

C_ASSERT((sizeof(HW_TRANSFER_DESCRIPTOR) == 16));

#include <POPPACK.H>

#endif /* __UHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\dbg.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug only functions

Environment:

    kernel mode only

Notes:

Revision History:

    10-31-00 : created

--*/

#include "stdarg.h"
#include "stdio.h"

#include "common.h"

#if DBG

ULONG
_cdecl
USB2LIB_KdPrintX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function. 

    calls the port driver print function

Arguments:

Return Value:


--*/    
{
    va_list list;
    int i;
    int arg[6];
    
    LibData.DbgPrint("'USB2LIB: ", 0, 0, 0, 0, 0, 0);
    va_start(list, Format);
    for (i=0; i<6; i++) 
        arg[i] = va_arg(list, int);
    
    LibData.DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\dbg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros for usbdlib
    
Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#if DBG

ULONG
_cdecl
USB2LIB_KdPrintX(
    PCH Format,
    ...
    );

#define TEST_TRAP()            LibData.DbgBreak()

#define DBGPRINT(_x_)          USB2LIB_KdPrintX _x_  

#else

#define TEST_TRAP()

#define DBGPRINT(_x_)

#endif /* DBG */

#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\miniport\usbuhci\usbuhci.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    usbuhci.h

Abstract:



Environment:

    Kernel & user mode

Revision History:

    1-1-00 : created

--*/

#ifndef   __USBUHCI_H__
#define   __USBUHCI_H__

#define FIXPIIX4

#define SOF_TD_COUNT    8

#define ANY_VIA(dd) ((dd)->ControllerFlavor >= UHCI_VIA)

#define MASK_CHANGE_BITS(p)\
    do {\
    (p).PortEnableChange = 0;\
    (p).PortConnectChange = 0;\
    } while (0);

/*
    define resource consumption for endpoints types
*/

#define T_64K           0x10000
#define T_16K           0x4000
#define T_4K            0x1000


// Control:
// largest possible transfer for control is 64k
// therefore we support up to 2 transfers of this
// size in HW.  Most control transfers are much
// smaller than this.
// NOTE: we MUST support at least one 64k transfer in
// HW since a single control transfer cannot be
// broken up.


//#define MAX_CONTROL_TRANSFER_SIZE       T_4K
#define MAX_ASYNC_PACKET_SIZE         64
//#define MAX_CONTROL_DOUBLE_BUFFERS      MAX_CONTROL_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_CONTROL_ENDPOINT        (MAX_CONTROL_TRANSFER_SIZE/MAX_CONTROL_PACKET_SIZE+2) // 2 EXTRA FOR SETUP AND STATUS


// Bulk:

// bugbug temprarily set to 64k
#define MAX_BULK_TRANSFER_SIZE          T_4K
//#define MAX_BULK_TRANSFER_SIZE          T_4K // T_16K // T_64K
//#define MAX_BULK_PACKET_SIZE            64
#define MAX_BULK_DOUBLE_BUFFERS         MAX_BULK_TRANSFER_SIZE/PAGE_SIZE
#define TDS_PER_BULK_ENDPOINT           (MAX_BULK_TRANSFER_SIZE/MAX_BULK_PACKET_SIZE)

// Interrupt:

//#define MAX_INTERRUPT_TRANSFER_SIZE     T_4K // T_16K
//#define MAX_INTERRUPT_PACKET_SIZE       64
//#define MAX_INTERRUPT_DOUBLE_BUFFERS    MAX_INTERRUPT_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_INTERRUPT_ENDPOINT      (MAX_INTERRUPT_TRANSFER_SIZE/MAX_INTERRUPT_PACKET_SIZE)
#define MAX_INTERRUPT_TDS_PER_TRANSFER  8

// Isochronous:
#define MAX_ISOCH_TRANSFER_SIZE     T_64K
#define MAX_ISOCH_PACKET_SIZE       1023
//#define MAX_ISOCH_DOUBLE_BUFFERS    MAX_ISOCH_TRANSFER_SIZE/PAGE_SIZE
//#define TDS_PER_ISOCH_ENDPOINT      1024

// Maximum Polling Interval we support for interrupt (ms)
#define MAX_INTERVAL                32
#define MAX_INTERVAL_MASK(i)        (i&0x1f)

// default size of frame list
#define UHCI_MAX_FRAME               1024
#define ACTUAL_FRAME(f)         ((f)&0x000003FF)

//
// These values index in to the interrupt QH list
//
#define  QH_INTERRUPT_1ms        0
#define  QH_INTERRUPT_2ms        1
#define  QH_INTERRUPT_4ms        3
#define  QH_INTERRUPT_8ms        7
#define  QH_INTERRUPT_16ms       15
#define  QH_INTERRUPT_32ms       31
#define  QH_INTERRUPT_INDEX(x) (x)-1

#define  NO_INTERRUPT_INTERVALS  6
#define  NO_INTERRUPT_QH_LISTS   63

// debug signatures
#define  SIG_HCD_IQH            'qi01'
#define  SIG_HCD_CQH            'qa01'
#define  SIG_HCD_BQH            'qb01'
#define  SIG_HCD_QH             'hq01'
#define  SIG_HCD_DQH            'qd01'
#define  SIG_HCD_TD             'dt01'
#define  SIG_HCD_RTD            'dtlr'
#define  SIG_HCD_SOFTD          'dtos'
#define  SIG_HCD_ADB            'bd01'
#define  SIG_HCD_IDB            'id01'
#define  SIG_EP_DATA            'pe01'
#define  SIG_UHCI_TRANSFER      'rt01'
#define  SIG_UHCI_DD            'ichu'

// What gets returned by READ_PORT_USHORT when hardware is surprise removed.
#define UHCI_HARDWARE_GONE 0xffff

#undef PDEVICE_DATA

typedef struct _TRANSFER_CONTEXT {

    ULONG Sig;
    ULONG PendingTds;
    PTRANSFER_PARAMETERS TransferParameters;
    USBD_STATUS UsbdStatus;
    ULONG BytesTransferred;
    struct _ENDPOINT_DATA *EndpointData;
    PMINIPORT_ISO_TRANSFER IsoTransfer;

} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;


// HCD Endpoint Descriptor (contains the HW descriptor)

// values for HCD_QUEUEHEAD_DESCRIPTOR.Flags
#define UHCI_QH_FLAG_IN_SCHEDULE        0x00000001
#define UHCI_QH_FLAG_QH_REMOVED         0x00000002

struct _ENDPOINT_DATA;

typedef struct _HCD_QUEUEHEAD_DESCRIPTOR {
   HW_QUEUE_HEAD                    HwQH;     // 2 dwords
   HW_32BIT_PHYSICAL_ADDRESS        PhysicalAddress;
   ULONG                            Sig;
   ULONG                            QhFlags;
   struct _HCD_QUEUEHEAD_DESCRIPTOR *NextQh;
   struct _HCD_QUEUEHEAD_DESCRIPTOR *PrevQh;
   struct _ENDPOINT_DATA            *EndpointData;

#ifdef _WIN64
   ULONG                            PadTo64[4];
#else
   ULONG                            PadTo64[8];
#endif
} HCD_QUEUEHEAD_DESCRIPTOR, *PHCD_QUEUEHEAD_DESCRIPTOR;

C_ASSERT((sizeof(HCD_QUEUEHEAD_DESCRIPTOR) == 64));

//
// HCD Transfer Descriptor (contains the HW descriptor)
//

#define ENDPOINT_DATA_PTR(p) ((struct _ENDPOINT_DATA *) (p).Pointer)
#define TRANSFER_CONTEXT_PTR(p) ((struct _TRANSFER_CONTEXT *) (p).Pointer)
#define TRANSFER_DESCRIPTOR_PTR(p) ((struct _HCD_TRANSFER_DESCRIPTOR *) (p).Pointer)
#define QH_DESCRIPTOR_PTR(p) ((struct _HCD_QUEUEHEAD_DESCRIPTOR *) (p).Pointer)
#define HW_PTR(p) ((UCHAR * ) (p).Pointer)


#define DB_FLAG_BUSY                0x00000001

typedef struct _TRANSFER_BUFFER_HEADER {
    HW_32BIT_PHYSICAL_ADDRESS   PhysicalAddress;
    PUCHAR                      SystemAddress;
    ULONG                       Sig;
    ULONG                       Flags;
    ULONG                       Size;
#ifdef _WIN64
    ULONG                       PadTo32[1];
#else
    ULONG                       PadTo32[3];
#endif
} TRANSFER_BUFFER_HEADER, *PTRANSFER_BUFFER_HEADER;

C_ASSERT((sizeof(TRANSFER_BUFFER_HEADER) == 32));

//
// NOTE: The buffer must go first, since the physical address
// depends on it. If not, you must change the init code.
//
typedef struct _ASYNC_TRANSFER_BUFFER {
    UCHAR Buffer[MAX_ASYNC_PACKET_SIZE];
    TRANSFER_BUFFER_HEADER;
} ASYNC_TRANSFER_BUFFER, *PASYNC_TRANSFER_BUFFER;

C_ASSERT((sizeof(ASYNC_TRANSFER_BUFFER) == 64+32));

typedef struct _ISOCH_TRANSFER_BUFFER {
    UCHAR Buffer[MAX_ISOCH_PACKET_SIZE+1]; // bump it to 1024
    TRANSFER_BUFFER_HEADER;
} ISOCH_TRANSFER_BUFFER, *PISOCH_TRANSFER_BUFFER;

C_ASSERT((sizeof(ISOCH_TRANSFER_BUFFER) == 1024+32));

typedef union _TRANSFER_BUFFER {
    ISOCH_TRANSFER_BUFFER Isoch;
    ASYNC_TRANSFER_BUFFER Async;
} TRANSFER_BUFFER, *PTRANSFER_BUFFER;

typedef struct _DOUBLE_BUFFER_LIST {
    union {
        ASYNC_TRANSFER_BUFFER  Async[1];
        ISOCH_TRANSFER_BUFFER  Isoch[1];
    };
} DOUBLE_BUFFER_LIST, *PDOUBLE_BUFFER_LIST;

// values for HCD_TRANSFER_DESCRIPTOR.Flags

#define TD_FLAG_BUSY                0x00000001
#define TD_FLAG_XFER                0x00000002
//#define TD_FLAG_CONTROL_STATUS      0x00000004
#define TD_FLAG_DONE                0x00000008
#define TD_FLAG_SKIP                0x00000010
#define TD_FLAG_DOUBLE_BUFFERED     0x00000020
#define TD_FLAG_ISO_QUEUED          0x00000040
#define TD_FLAG_SETUP_TD            0x00000100
#define TD_FLAG_DATA_TD             0x00000200
#define TD_FLAG_STATUS_TD           0x00000400
#define TD_FLAG_TIMEOUT_ERROR       0x00000800

typedef struct _HCD_TRANSFER_DESCRIPTOR {
    HW_QUEUE_ELEMENT_TD             HwTD;
    HW_32BIT_PHYSICAL_ADDRESS       PhysicalAddress;
    ULONG                           Sig;
    union {
    PTRANSFER_CONTEXT               TransferContext;
    ULONG                           RequestFrame;
    };
    PMINIPORT_ISO_PACKET            IsoPacket;
    ULONG                           Flags;
    struct _HCD_TRANSFER_DESCRIPTOR *NextTd;
    PTRANSFER_BUFFER                DoubleBuffer;
    LIST_ENTRY                      DoneLink;
#ifdef _WIN64
    ULONG                           PadTo128[12];
#else
    ULONG                           PadTo64[3];
#endif
} HCD_TRANSFER_DESCRIPTOR, *PHCD_TRANSFER_DESCRIPTOR;

#ifdef _WIN64
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 128));
#else
C_ASSERT((sizeof(HCD_TRANSFER_DESCRIPTOR) == 64));
#endif

typedef struct _HCD_TD_LIST {
    HCD_TRANSFER_DESCRIPTOR Td[1];
} HCD_TD_LIST, *PHCD_TD_LIST;

#define UHCI_EDFLAG_HALTED          0x00000001
#define UHCI_EDFLAG_SHORT_PACKET    0x00000002
#define UHCI_EDFLAG_NOHALT          0x00000004

typedef struct _ENDPOINT_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    ENDPOINT_PARAMETERS         Parameters;
    PHCD_QUEUEHEAD_DESCRIPTOR   QueueHead;
    ULONG                       PendingTransfers;
    ULONG                       MaxPendingTransfers;

    PHCD_TRANSFER_DESCRIPTOR    TailTd;
    PHCD_TRANSFER_DESCRIPTOR    HeadTd;

    //
    // Transfer descriptor cache.
    //
    PHCD_TD_LIST                TdList;
    ULONG                       TdCount;
    ULONG                       TdLastAllocced;
    ULONG                       TdsUsed;

    //
    // Double buffer cache.
    //
    PDOUBLE_BUFFER_LIST         DbList;
    ULONG                       DbCount;
    ULONG                       DbLastAllocced;
    ULONG                       DbsUsed;

    ULONG                       MaxErrorCount;

    ULONG                       Toggle;

    LIST_ENTRY                  DoneTdList;
    
} ENDPOINT_DATA, *PENDPOINT_DATA;

#define UHCI_NUMBER_PORTS               2

#define UHCI_DDFLAG_USBBIOS     0x00000001
#define UHCI_DDFLAG_SUSPENDED   0x00000002

#define UHCI_HC_MAX_ERRORS      0x10

typedef struct _DEVICE_DATA {

    ULONG                       Sig;
    ULONG                       Flags;
    PHC_REGISTER                Registers;
    ULONG                       HCErrorCount;

    // Save the command register thru power downs
    USBCMD                      SuspendCommandReg;
    FRNUM                       SuspendFrameNumber;
    FRBASEADD                   SuspendFrameListBasePhys;
    USBINTR                     SuspendInterruptEnable;

    USBINTR                     EnabledInterrupts;
    ULONG                       IsoPendingTransfers;

    //
    // Base queue head that we link all control/bulk transfer
    // queues to.
    //
    USB_CONTROLLER_FLAVOR       ControllerFlavor;

//    ULONG                       LastFrameCounter;
    ULONG                       FrameNumberHighPart;
    ULONG                       LastFrameProcessed;
    ULONG                       SynchronizeIsoCleanup;

    ULONG                       PortInReset;
    ULONG                       PortResetChange;
    ULONG                       PortSuspendChange;
    ULONG                       PortOvercurrentChange;
    BOOLEAN                     PortResuming[UHCI_NUMBER_PORTS];

    USHORT                      IrqStatus;

    USHORT                      PortPowerControl;

    PHW_32BIT_PHYSICAL_ADDRESS  FrameListVA;
    HW_32BIT_PHYSICAL_ADDRESS   FrameListPA;

    // Virtual Addresses for the control and bulk queue heads in the
    // schedule.

    PHCD_QUEUEHEAD_DESCRIPTOR   ControlQueueHead;
    PHCD_QUEUEHEAD_DESCRIPTOR   BulkQueueHead;
    PHCD_QUEUEHEAD_DESCRIPTOR   LastBulkQueueHead;

    // Virtual Addresses for the interrupt queue heads in the
    // schedule.

    PHCD_QUEUEHEAD_DESCRIPTOR   InterruptQueueHeads[NO_INTERRUPT_QH_LISTS];

    // Virtual Address for the TD that gives us an interrupt at the end
    // of every frame, so that things don't get stuck in the schedule.

    PHCD_TRANSFER_DESCRIPTOR    RollOverTd;

    UCHAR                       SavedSOFModify;

    PHCD_TD_LIST                SofTdList;

} DEVICE_DATA, *PDEVICE_DATA;


/*
    Callouts to port driver services
*/
extern USBPORT_REGISTRATION_PACKET RegistrationPacket;

#define USBPORT_DBGPRINT(dd, l, f, arg0, arg1, arg2, arg3, arg4, arg5) \
        RegistrationPacket.USBPORTSVC_DbgPrint((dd), (l), (f), (arg0), (arg1), \
            (arg2), (arg3), (arg4), (arg5))

#define USBPORT_GET_REGISTRY_KEY_VALUE(dd, branch, keystring, keylen, data, datalen) \
        RegistrationPacket.USBPORTSVC_GetMiniportRegistryKeyValue((dd), (branch), \
            (keystring), (keylen), (data), (datalen))

#define USBPORT_INVALIDATE_ROOTHUB(dd) \
        RegistrationPacket.USBPORTSVC_InvalidateRootHub((dd))

#define USBPORT_COMPLETE_TRANSFER(dd, ep, tp, status, length) \
        RegistrationPacket.USBPORTSVC_CompleteTransfer((dd), (ep), (tp), \
            (status), (length))

#define USBPORT_COMPLETE_ISOCH_TRANSFER(dd, ep, tp, iso) \
        RegistrationPacket.USBPORTSVC_CompleteIsoTransfer((dd), (ep), (tp), (iso))

#define USBPORT_INVALIDATE_ENDPOINT(dd, ep) \
        RegistrationPacket.USBPORTSVC_InvalidateEndpoint((dd), (ep))

#define USBPORT_PHYSICAL_TO_VIRTUAL(addr, dd, ep) \
        RegistrationPacket.USBPORTSVC_MapHwPhysicalToVirtual((addr), (dd), (ep))

#define USBPORT_REQUEST_ASYNC_CALLBACK(dd, t, c, cl, f) \
        RegistrationPacket.USBPORTSVC_RequestAsyncCallback((dd), (t), \
            (c), (cl), (f))

#define USBPORT_READ_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), TRUE, \
            (b), (o), (l))

#define USBPORT_WRITE_CONFIG_SPACE(dd, b, o, l) \
        RegistrationPacket.USBPORTSVC_ReadWriteConfigSpace((dd), FALSE, \
            (b), (o), (l))

#define USBPORT_INVALIDATE_CONTROLLER(dd, s) \
        RegistrationPacket.USBPORTSVC_InvalidateController((dd), (s))

#define USBPORT_WAIT(dd, t) \
        RegistrationPacket.USBPORTSVC_Wait((dd), (t))

#define USBPORT_NOTIFY_DOUBLEBUFFER(dd, tp, addr, length) \
        RegistrationPacket.USBPORTSVC_NotifyDoubleBuffer((dd), (tp), \
            (addr), (length))


#ifdef _WIN64
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABEABADBABE)
#else
#define DUMMY_TD_CONTEXT ((PVOID) 0xABADBABE)
#endif


#define UhciCheckIsochTransferInsertion(dd, r, df) {\
        ULONG cf = UhciGet32BitFrameNumber((dd));\
        if ((df) > (cf)) {\
            if ((df) < (dd)->LastFrameProcessed + UHCI_MAX_FRAME) \
                r = USBD_STATUS_SUCCESS;\
            else\
                r = USBD_STATUS_PENDING;\
        } else {\
            if ((df)-(cf) < UHCI_MAX_FRAME )\
                r = USBD_STATUS_SUCCESS;\
            else \
                r = USBD_STATUS_BAD_START_FRAME;}}

//
// This macro is protected from double queueing the TD, by using
// interlocked function. Unless the HwAddress is NULL, it won't
// replace the value.
//
#define INSERT_ISOCH_TD(dd, td, fn) \
        (td)->Flags |= TD_FLAG_ISO_QUEUED;\
        InterlockedCompareExchange(&(td)->HwTD.LinkPointer.HwAddress,\
            *( ((PULONG) ((dd)->FrameListVA)+ACTUAL_FRAME(fn)) ), 0);\
        *( ((PULONG) ((dd)->FrameListVA)+ACTUAL_FRAME(fn)) ) = \
            (td)->PhysicalAddress;

//
// Must account for both the regular and overflow cases:
//
/*#define CAN_INSERT_ISOCH_TD(fr, cfr) \
        ((fr - cfr < USBUHCI_MAX_FRAME) ||\
        ((fr + cfr < USBUHCI_MAX_FRAME) && fr < USBUHCI_MAX_FRAME))

#define INSERT_ISOCH_TD(dd, td, ep) \
        (td)->PrevTd = (PHCD_TRANSFER_DESCRIPTOR)((PULONG) ((dd)->FrameListVA) + \
            ACTUAL_FRAME((td)->IsoPacket->FrameNumber)); \
        (td)->HwTD.LinkPointer.HwAddress = (td)->PrevTd->HwTD.LinkPointer.HwAddress; \
        if (!(td)->HwTD.LinkPointer.QHTDSelect) {\
            PHCD_TRANSFER_DESCRIPTOR rtd = (PHCD_TRANSFER_DESCRIPTOR)\
                USBPORT_PHYSICAL_TO_VIRTUAL((td)->HwTD.LinkPointer.HwAddress, \
                                            (dd), \
                                            (ep));\
            rtd->PrevTd = (td);\
        }\
        (td)->PrevTd->HwTD.LinkPointer.HwAddress = td->PhysicalAddress;

#define REMOVE_ISOCH_TD(td) \
        (td)->PrevTd->HwTD.LinkPointer.HwAddress = (td)->HwTD.LinkPointer.HwAddress;
*/

// We must set the frame to the highest ULONG prior to setting the
// TD_FLAG_XFER flag, so that this TD doesn't get completed before
// we've had chance to queue it.
#define INITIALIZE_TD_FOR_TRANSFER(td, tc) \
        (td)->TransferContext = (tc);\
        (td)->Flags |= TD_FLAG_XFER; \
        (td)->HwTD.LinkPointer.HwAddress = 0;\
        (td)->HwTD.Control.ul = 0;\
        (td)->HwTD.Control.LowSpeedDevice = ((tc)->EndpointData->Parameters.DeviceSpeed == LowSpeed);\
        (td)->HwTD.Control.Active = 1;\
        (td)->HwTD.Control.ErrorCount = 3;\
        (td)->HwTD.Token.ul = 0;\
        (td)->HwTD.Token.Endpoint = (tc)->EndpointData->Parameters.EndpointAddress;\
        (td)->HwTD.Token.DeviceAddress = (tc)->EndpointData->Parameters.DeviceAddress;\
        (td)->NextTd = NULL;

#define SET_QH_TD(dd, ed, td) {\
    TD_LINK_POINTER newLink;\
    if ((td)) {\
        (ed)->HeadTd = (td);\
    } else {\
        (ed)->HeadTd = (ed)->TailTd = NULL;\
    }\
    if (!(td) || TEST_FLAG((ed)->Flags, UHCI_EDFLAG_HALTED)) {\
        newLink.HwAddress = 0;\
        newLink.Terminate = 1;\
    } else {\
        newLink.HwAddress = (td)->PhysicalAddress;\
        newLink.Terminate = 0;\
    }\
    newLink.QHTDSelect = 0;\
    LOGENTRY((dd), G, '_sqt', (td), (ed), 0);\
    (ed)->QueueHead->HwQH.VLink = newLink;}

/*#define SET_QH_TD_NULL(qh) \
    { TD_LINK_POINTER newLink;\
    newLink.HwAddress = 0;\
    newLink.Terminate = 1;\
    newLink.QHTDSelect = 0;\
    (qh)->HwQH.VLink = newLink;\
    }
  */
#define SET_NEXT_TD(linkTd, nextTd) \
    (linkTd)->HwTD.LinkPointer.HwAddress = (nextTd)->PhysicalAddress;\
    (linkTd)->HwTD.LinkPointer.Terminate = 0;\
    (linkTd)->HwTD.LinkPointer.QHTDSelect = 0;\
    (linkTd)->HwTD.LinkPointer.DepthBreadthSelect = 0;\
    (linkTd)->NextTd = (nextTd);

#define SET_NEXT_TD_NULL(linkTd) \
    (linkTd)->NextTd = NULL;\
    (linkTd)->HwTD.LinkPointer.HwAddress = 0;\
    (linkTd)->HwTD.LinkPointer.Terminate = 1;

#define PAGE_CROSSING(PhysicalAddress, length) \
    ((PhysicalAddress+length)%PAGE_SIZE < length && (PhysicalAddress+length)%PAGE_SIZE != 0)

#ifdef _WIN64
#define UHCI_BAD_POINTER ((PVOID) 0xDEADFACEDEADFACE)
#else
#define UHCI_BAD_POINTER ((PVOID) 0xDEADFACE)
#endif
#define UHCI_BAD_HW_POINTER 0x0BADF00D

// Note how we free any double buffering in here instead of relying
// on the c code to do it.
#define UHCI_FREE_TD(dd, ep, td) \
    if (TEST_FLAG((td)->Flags, TD_FLAG_DOUBLE_BUFFERED)) { \
        UHCI_FREE_DB((dd), (ep), (td)->DoubleBuffer);}\
    (ep)->TdsUsed--;\
    (td)->HwTD.LinkPointer.HwAddress = UHCI_BAD_HW_POINTER;\
    LOGENTRY((dd), G, '_fTD', (td), (ep), 0);\
    (td)->TransferContext = UHCI_BAD_POINTER;\
    (td)->Flags = 0;

#define UHCI_ALLOC_TD(dd, ep) UhciAllocTd((dd), (ep));

#define UHCI_FREE_DB(dd, ep, db) \
    LOGENTRY((dd), G, '_fDB', (db), (ep), 0);\
    (ep)->DbsUsed--;\
    if ((ep)->Parameters.TransferType == Isochronous) { (db)->Isoch.Flags = 0; }\
    else { (db)->Async.Flags = 0; }

#define UHCI_ALLOC_DB(dd, ep, i) UhciAllocDb((dd), (ep), (i));

 //  bugbug  UHCI_ASSERT((dd), (ed)->PendingTransfers);
#define DecPendingTransfers(dd, ed) \
    InterlockedDecrement(&(ed)->PendingTransfers);\
    if ((ed)->Parameters.TransferType == Isochronous)\
        InterlockedDecrement(&(dd)->IsoPendingTransfers);

#define ActivateRolloverTd(dd) \
    *( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress;

//#define IncPendingTransfers(dd, ed) \
//    InterlockedIncrement(&(ed)->PendingTransfers);\
//    if ((ed)->Parameters.TransferType == Isochronous) {\
//        if (1 == InterlockedIncrement(&(dd)->IsoPendingTransfers)) {\
//            //*( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress; \
//            (dd)->LastFrameProcessed = UhciGet32BitFrameNumber((dd));\
//    }}
//    bugbug UHCI_ASSERT((dd), (ed)->PendingTransfers);

#define IncPendingTransfers(dd, ed) \
    InterlockedIncrement(&(ed)->PendingTransfers);\
    if ((ed)->Parameters.TransferType == Isochronous) {\
        if (1 == InterlockedIncrement(&(dd)->IsoPendingTransfers)) {\
            (dd)->LastFrameProcessed = UhciGet32BitFrameNumber((dd));\
    }}
//    bugbug UHCI_ASSERT((dd), (ed)->PendingTransfers);


#define UhciCleanFrameOfIsochTds(dd, i)\
    if ((i) == 0) {\
        *( ((PULONG) ((dd)->FrameListVA)) ) = (dd)->RollOverTd->PhysicalAddress;\
    } else {\
        QH_LINK_POINTER newLink;\
        newLink.HwAddress = (dd)->InterruptQueueHeads[QH_INTERRUPT_32ms + MAX_INTERVAL_MASK((i))]->PhysicalAddress;\
        newLink.QHTDSelect = 1;\
        *( ((PULONG) ((dd)->FrameListVA)+(i)) ) = newLink.HwAddress;\
    }


#define TEST_BIT(value, bitNumber) ((value) & (1<<(bitNumber))) ? TRUE : FALSE

#define SET_BIT(value, bitNumber) ((value) |= (1<<(bitNumber)))

#define CLEAR_BIT(value, bitNumber)  ((value) &= ~(1<<(bitNumber)))


//
// Controller functions
//

USB_MINIPORT_STATUS
USBMPFN
UhciStartController(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    );

VOID
USBMPFN
UhciStopController(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN HwPresent
    );

VOID
USBMPFN
UhciSuspendController(
    IN PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciResumeController(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciPollController(
    IN PDEVICE_DATA DeviceData
    );

ULONG
USBMPFN
UhciGet32BitFrameNumber(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciInterruptNextSOF(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciUpdateCounter(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciDisableAsyncList(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciInitailizeInterruptSchedule(
    IN PDEVICE_DATA DeviceData
    );

VOID
UhciEnableAsyncList(
    IN PDEVICE_DATA DeviceData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciPassThru (
    IN PDEVICE_DATA DeviceData,
    IN GUID *FunctionGuid,
    IN ULONG ParameterLength,
    IN OUT PVOID Parameters
    );


//
// Root hub functions
//

VOID
USBMPFN
UhciRHGetRootHubData(
    IN PDEVICE_DATA DeviceData,
    OUT PROOTHUB_DATA HubData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PUSHORT Status
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetHubStatus(
    IN PDEVICE_DATA DeviceData,
    OUT PRH_HUB_STATUS HubStatus
    );

VOID
USBMPFN
UhciRHDisableIrq(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciRHEnableIrq(
    IN PDEVICE_DATA DeviceData
    );


//
// Root hub port functions
//
USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortReset(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortSuspend(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortPower(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortPower(
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHSetFeaturePortEnable(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortEnable(
    IN PDEVICE_DATA DeviceData,
    IN USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHGetPortStatus(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber,
    PRH_PORT_STATUS portStatus
    );

//
// Clear change bits for hub ports
//
USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortConnectChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortResetChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortSuspendChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortOvercurrentChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );

USB_MINIPORT_STATUS
USBMPFN
UhciRHClearFeaturePortEnableChange(
    PDEVICE_DATA DeviceData,
    USHORT PortNumber
    );


//
// Interrupt functions
//

BOOLEAN
USBMPFN
UhciInterruptService (
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciEnableInterrupts(
    IN PDEVICE_DATA DeviceData
    );

VOID
USBMPFN
UhciInterruptDpc (
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN EnableInterrupts
    );

VOID
USBMPFN
UhciDisableInterrupts(
    IN PDEVICE_DATA DeviceData
    );


//
// Endpoint functions
//

USB_MINIPORT_STATUS
USBMPFN
UhciOpenEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciPokeEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
USBMPFN
UhciQueryEndpointRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    OUT PENDPOINT_REQUIREMENTS EndpointRequirements
    );

VOID
USBMPFN
UhciCloseEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
UhciAbortTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    );

USB_MINIPORT_STATUS
USBMPFN
UhciStartSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    );

USB_MINIPORT_STATUS
USBMPFN
UhciEndSendOnePacket(
    IN PDEVICE_DATA DeviceData,
    IN PMP_PACKET_PARAMETERS PacketParameters,
    IN PUCHAR PacketData,
    IN PULONG PacketLength,
    IN PUCHAR WorkspaceVirtualAddress,
    IN HW_32BIT_PHYSICAL_ADDRESS WorkspacePhysicalAddress,
    IN ULONG WorkSpaceLength,
    IN OUT USBD_STATUS *UsbdStatus
    );

VOID
USBMPFN
UhciSetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATUS Status
    );

MP_ENDPOINT_STATUS
USBMPFN
UhciGetEndpointStatus(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

PHCD_QUEUEHEAD_DESCRIPTOR
UhciInitializeQH(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh,
    IN HW_32BIT_PHYSICAL_ADDRESS HwPhysAddress
    );

VOID
USBMPFN
UhciSetEndpointDataToggle(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN ULONG Toggle
    );

VOID
USBMPFN
UhciPollEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

MP_ENDPOINT_STATE
USBMPFN
UhciGetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
USBMPFN
UhciSetEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

VOID
UhciSetAsyncEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

USB_MINIPORT_STATUS
USBMPFN
UhciSubmitTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferUrb,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

//
// Async
//

VOID
UhciProcessDoneAsyncTd(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

VOID
UhciPollAsyncEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

USB_MINIPORT_STATUS
UhciBulkOrInterruptTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

VOID
UhciUnlinkQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR Qh
    );

VOID
UhciAbortAsyncTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext,
    OUT PULONG BytesTransferred
    );

VOID
UhciInsertQh(
    IN PDEVICE_DATA DeviceData,
    IN PHCD_QUEUEHEAD_DESCRIPTOR FirstQh,
    IN PHCD_QUEUEHEAD_DESCRIPTOR LinkQh
    );

USB_MINIPORT_STATUS
UhciControlTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferUrb,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PTRANSFER_SG_LIST TransferSGList
    );

//
// Isoch
//

USB_MINIPORT_STATUS
USBMPFN
UhciIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_PARAMETERS TransferParameters,
    IN PTRANSFER_CONTEXT TransferContext,
    IN PMINIPORT_ISO_TRANSFER IsoTransfer
    );

VOID
UhciPollIsochEndpoint(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

VOID
UhciAbortIsochTransfer(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN PTRANSFER_CONTEXT TransferContext
    );

VOID
UhciSetIsochEndpointState(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN MP_ENDPOINT_STATE State
    );

VOID
UhciCleanOutIsoch(
    IN PDEVICE_DATA DeviceData,
    IN BOOLEAN      ForceClean
    );

//
// Utility
//

USBD_STATUS
UhciGetErrorFromTD(
    PDEVICE_DATA DeviceData,
    PHCD_TRANSFER_DESCRIPTOR Td
    );

PHCD_TRANSFER_DESCRIPTOR
UhciAllocTd(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData
    );

PTRANSFER_BUFFER
UhciAllocDb(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_DATA EndpointData,
    IN BOOLEAN Isoch
    );

//
// Bios handoff and handback
//
USB_MINIPORT_STATUS
UhciStopBIOS(
    IN PDEVICE_DATA DeviceData,
    IN PHC_RESOURCES HcResources
    );

ULONG
UhciQueryControlRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryBulkRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryIsoRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

ULONG
UhciQueryInterruptRequirements(
    IN PDEVICE_DATA DeviceData,
    IN PENDPOINT_PARAMETERS EndpointParameters,
    IN OUT PULONG NumberOfTDs,
    IN OUT PULONG NumberOfDoubleBuffers
    );

BOOLEAN
UhciHardwarePresent(
    PDEVICE_DATA DeviceData
    );

VOID
UhciCheckController(
    PDEVICE_DATA DeviceData
    );

VOID
UhciFlushInterrupts(
    IN PDEVICE_DATA DeviceData
    );
/*
USB_MINIPORT_STATUS
UhciStartBIOS(
    IN PDEVICE_DATA DeviceData
    );
  */

#endif /* __USBUHCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\common.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    common.h

Abstract:

Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __COMMON_H__
#define   __COMMON_H__

#include <wdm.h>
#include "usb2lib.h"
#include "sched.h"
#include "dbg.h"

typedef struct _USB2LIB_DATA {

    PUSB2LIB_DBGPRINT DbgPrint;
    PUSB2LIB_DBGBREAK DbgBreak;
    
} USB2LIB_DATA, *PUSB2LIB_DATA;


typedef struct _USB2LIB_HC_CONTEXT {

    ULONG Sig;
    HC Hc;
    TT DummyTt;	// fake TT used for HS endpoints to get to HC struct
    
} USB2LIB_HC_CONTEXT, *PUSB2LIB_HC_CONTEXT;


typedef struct _USB2LIB_TT_CONTEXT {

    ULONG Sig;
    TT Tt;
    
} USB2LIB_TT_CONTEXT, *PUSB2LIB_TT_CONTEXT;


typedef struct _USB2LIB_ENDPOINT_CONTEXT {

    ULONG Sig;
    PVOID RebalanceContext;
    Endpoint Ep;
    
} USB2LIB_ENDPOINT_CONTEXT, *PUSB2LIB_ENDPOINT_CONTEXT;


extern USB2LIB_DATA LibData;

/*
    prototypes
*/

#endif /*  __COMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\sched.c ===
// scheduling algorithm for split periodic 

/*
 *  Allocate_time_for_endpoint - adds a new endpoint to the periodic budget tracking list
 *  Dealloate_time_for_endpoint - removes an endpoint from the budget
 *
 * Each of these routines return a list of other (previously allocated) endpoints that have had
 * their allocation changed due to the (de)allocation of an endpoint.
 *
 */


/***************** Design notes *********************
 *
 * Split transactions require three allocations (and/or budgets).
 *  1) the classic bus must count the byte times required in each classic frame.
 *     This is what a classic bus already normally does.
 *  2) a microframe patterned frame budget must be computed for each classic frame.
 *     This is used to determine what microframes require split transactions.
 *  3) the high speed bus must count the byte times required in each HS microframe.
 *     This is the HS equivalent of what is done for a (classic) bus, i.e same
 *     general allocation algorithm, just at HS and for microframes (vs. frames).
 *
 * A frame budget must be maintained for currently configured endpoints.
 * A frame budget consists of a (continuous repeating) sequence of frames.
 * Each frame consists of the endpoints that are allocated time for that frame.
 * Each frame contains the microframe patterns for each configured endpoint for
 * split transaction endpoints.  A microframe pattern consists of the microframes in a
 * frame that contain start-splits (SS) or complete-splits (CS) for an endpoint.
 *
 * The frame budget is maintained separately from any HC schedule of transactions for endpoints.
 * The two must be coherent with each other, but the budget is essentially a pattern to be used
 * to construct an HC transaction schedule as clients request data transfer.  When a new endpoint
 * is allocated, it can change the pattern of previously existing (allocated) endpoints.  This
 * requires that the corresponding HC schedule be reconciled at some point in time.  Precisely how
 * the two are reconciled is not dealt with in this algorithm.  However, some ideas are captured
 * later in these comments.
 *
 * The microframe patterns budgeted must match the order in which transactions are
 * processed on the bus by the host controller and its driver.  This makes the
 * scheduling software interdependent with the host controller and its driver.
 *
 * There are several requirements between the computed frame budget and the order in which the
 * HC visits transactions:
 *	1) (EHCI req): a large isoch transaction (> about 570 bytes?) must be first in the
 *		frame to avoid having more than 1 microframe with an SS and CS
 *		This is in lieu of having to sort the transactions into decreasing size through the frame.
 *	2) (core spec req): the order of CSs in a microframe for a set of endpoints must be
 *		identical to the order of SSs used to start the classic transactions
 *	3) (implementation requirement due to EHCI and core spec TT rules): the order of endpoints
 *		for isoch OUTs longer than 188 bytes (e.g. ones with more than one SS) must match the
 *		budgeted order so that multiple SSs are sequenced correctly across microframes for multiple
 *		endpoints.
 *
 *		Example, assume endpoint A and B
 *		are isoch OUT, with A budgeted before B and B requires 2 microframes of SS.  A must
 *		be processed before B so that the SS sequence is:
 *			microframe N:   A-SS1, B-SS1
 *			microframe N+1: B-SS2
 *
 *		if instead the processing order were allowed to be B and then A this would result in:
 *
 *			microframe N:   B-SS1, A-SS1
 *			microframe N+1: B-SS2
 *
 *		this would result in the TT seeing B-SS1, A-SS1, B-SS2.  This is not a valid order for
 * 		long isoch OUT for B.  The TT will treat B (initially) as incomplete (due to the A SS) and ignore
 *		B-SS2.
 *	4) (implementation requirement due to EHCI and core spec TT rules): The order of endpoints for
 *		isoch INs longer than 188 bytes must match the budgeted order (similar to above for OUTs).
 *	5) (core spec) Only 2^N periods are allowed.
 *	6) Classic (split) budget is based on best case times (specified by core spec), i.e. no bit stuffing.
 *		However, high speed budgets are based on worst case times, i.e. including bit stuffing.
 *	7) (EHCI req) Interrupt endpoints must be ordered in the frame from largest period to smallest period.
 *	8) (core spec and EHCI req) Interrupt endpoints have different numbers of CSs.  Ones near the end of
 *		a frame have 2, while others have 3.  EHCI requires that late endpoints DON'T have 3, so all
 *		endpoints can't be treated as having three (to try and allow unordered endpoints in a frame).
 *		It also might appear that early endpoints could be unordered, while later ones are ordered.
 *		However, as endpoints are allocated, a previously "undordered" endpoint would then need to
 *		become "ordered".  This seems to be a really hard transition, therefore all interrupt
 *		endpoints are required to be ordered in a frame.
 *
 * This scheduling algorithm depends on the HC transaction processing sequence:
 * 1) Interrupt endpoints are executed in decreasing period order (e.g. period 16 endpoint
 *    is executed before a period 8 endpoint).  Endpoints with the same period are
 *    executed in budget order.
 * 2) Interrupt endpoints are executed after all isochronous endpoints.
 * 3) Isochronous OUT endpoints longer than 188 bytes are executed in budget order.
 * 4) Isochronous IN periodic endpoints are executed in budget order. (must be so to ensure
 *    that CSs for endpoints occur in correct order, e.g. for different lengths)
 *		Note: this could be relaxed if more CSs were budgeted. 
 * 5) If there is a large isoch, it is first in the frame.
 *
 * When transactions are enqueued in the framelist HC data structures, the order
 * of the transactions must be the same as that budgeted.  This is so that when an endpoint
 * is allocated (inserted), the budget computation accurately determines the other affected endpoints.
 * The HC is required to process SSs and CSs for a set of endpoints for the same TT in the same order.
 * The act of creating the frame list ensures that this order is preserved (without
 * requiring any particular order to be explicitly created.
 * The physical framelist order from time to time can be different for interrupt endpoints,
 * but the TT is not sensitive to order.
 *
 * This algorithm computes budget order as determined in the routine OK_to_insert (below).
 *
 * Simplifying scheduling and HC assumptions:
 * a) The maximum allocation allowed is reduced by 30 (from 1157 to 1127 FS byte times)
 *    FS byte times to eliminate needing to deal with an end of frame wrap case
 *    that would require a TD back pointer.
 * b) Isoch IN transactions/endpoints longer than 1023-188-30 FS byte times are artifically
 *    processed (inserted) at the beginning of a frame.  This eliminates another
 *    end of frame wrap case.  Actually this is reduced to 1/2 a frame, since there can only be
 *	  one "large" transaction in a frame.
 * c) It is highly desirable to have the least impact on other endpoints due to an allocation.
 *
 * The isoch portion of the frame budget is maintained such that the frame time is "compacted".
 * I.e., there are no "holes" in the allocated frame time.
 *
 * In contrast, the interrupt portion of the frame budget has "holes" in the allocated frame time.
 * This is because the HC visits endpoints in the schedule in increasing period order, and we
 * must have the same SS/CS masks for all frames the endpoint is in, while a compacted budget
 * would require decreasing period order.
 *
 * The SS and CS masks used are only computed when the endpoint is configured.
 * This eliminates requiring different microframe patterns for different frames.
 * This also means that based on the presence of transactions for configured endpoints,
 * there can be "holes" in the periodic portion of the classic frame.  These holes can be
 * reclaimed and used for control and bulk classic transactions.
 *
 * Endpoints have a single "SS/CS microframe within frame" pattern for all frames
 * in which they have transfers.  This pattern is computed once when the endpoint is
 * configured.  It is also recomputed whenever other endpoints in the same frame have their
 * allocation time changed due to some other newly allocated endpoint.
 *
 * The budget frame list for FS/LS devices behind a TT, must be bound/tracked to/by
 * that TT.  A normal FS/LS frame bus time is maintained in addition to
 * the more detailed microframe pattern information.

 * Once the microframe pattern is determined, an HS allocation must be made of the
 * HS HC budget.  This HS allocation is done on a microframe basis for each SS/CS
 * that is required to support the classic device (and its TT).  The time for each
 * SS (and any data per microframe) is allocated in the appropriate microframe(s).
 * The time for each CS is allocated in the appropriate microframe(s).
 *
 * The data requirements (vs. overhead) for all classic IN endpoints for each TT should be tracked
 * for each HS microframe. The time for the data portion should never exceed 188 bytes
 * (inc. bitstuffing overhead) for CSs for all devices of a TT in a HS microframe.  SSs always
 * allocate the required time.  For CSs, the first classic device must allocate data time in
 * all microframes for all splits.  However, once the time in a HS microframe for a TT reaches
 * 188 data bytes, no more time needs to be allocated from the HS budget for data.  This is
 * because that is the most data that a classic bus can ever require.  It may take more split
 * transactions to move that data, but the amount of data can't increase.  The additional splits
 * just deal with the classic bus operation variation.
 *
 * The bus times for each period in the frame list must be updated for an endpoint. I.e.
 * multiple frame entries will need to be adjusted for periods smaller than the budgeting
 * window (i.e. MAXFRAMES).  A tree structure is used to link slower period endpoints from different
 * frames to the same endpoint of a faster period (similar to the periodic Qhead HC structure.
 * There is a tree for isoch endpoints and a separate tree for interrupt endpoints.
 * The endpoints lists rooted in each budget frame starts with a dummy SOF endpoint to make link
 * traversal easier (i.e. avoids an empty list case).
 *
 * All bus times are kept in byte time units (either HS or FS).  LS bus times are tracked
 * as appropriately scaled FS byte times.
 *
 * A general comment about processing flow in allocate and deallocate.  There are three processing
 * concepts.  All frames that an endpoint is allcoated within, must be visited to do the endpoint
 * specific processing.  However, other frames must also be visited to deal with the movement of
 * their budget times due to the changed endpoint.  Therefore all frames are always visited for
 * an allocation change.  As the frame list is walked, the "frame_bias" ranges over:
 *		(- ep->start_frame) + MAXFRAMES - 1 ... (- ep->start_frame)
 *	(frames are visited in reverse order)
 * But only in frames that are multiples of the endpoint's period are changes
 * made.  This causes some of the code "tracking" complexity.
 *
 * Comments about reconciling HC schedule and changed frame budgets:
 * When an isoch endpoint's microframe pattern is recomputed, currently pending transaction
 * requests are not manipulated.  But the new pattern does affect future transactions.
 * (Since the FS/LS device is expecting its transactions anywhere in the frame, the
 * microframe "jitter" that results is not relevant.)
 *
 * However, when an interrupt endpoint is inserted/removed in/from the middle of a frame, the
 * other endpoints (with pending/active transactions) affected must have their
 * transactions updated.  For interrupt endpoints, the split transaction masks are
 * in the queue head.  To change the interrupt masks:
 * 	1. the endpoint QH must be made inactive
 * 	2. the driver must wait for >= 1 frame time to ensure that the HC is not processing the QH
 *	3. the split masks are changed
 *	4. if the TD did an SS and didn't do a CS in the frame, the endpoint is halted to recover
 *	   (a nasty race condition, but hopefully rare)
 *	5. the QH is made active.
 *
 * To change isoch masks, the current pending/active TDs can be changed in place.
 * Existing error mechanisms can handle any race conditions with the HC.
 * 
 * There may be a corner condition in that the budget information shouldn't be used
 * (solely) to find transactions in the current schedule. If a client requests transactions
 * according to one budget and then the budget changes, and then the client wants to abort
 * the old transactions, I think the stack would normally use the budget to determine where
 * the transactions are in the schedule, but now the budget may identify "other"
 * microframes as having the transaction(s).  Coder beware!
 *
 * Classic HC allocation uses the microframe_info, microframe[0] to count the bandwidth allocation.
 *
 * History:
 *
 * 10-3-2000, JIG: fixed incorrect starting time and shift calculations for first interrupt and only large isoch
 * 10-4-2000, JIG: moved max allocation into TT and HC structs,
 *				   added inputfile ability to set TT/HC allocation_limit, TT/HC thinktime, and HC speed
 *				   made dump_budget not dump split info for classic HC
 *				   fixed duplicate thinktime addition in calc_bus_time for HS/FS nonsplit allocations
 *
 ****************************************************/

#include "common.h"


#if 0
int min (int a, int b)
{
    return (int) ((a<=b) ? a : b);
}

int max (int a, int b) 
{
    return (int) ((a>=b) ? a : b);
}
#endif

/**

	error
	
**/
error(char *s)
{
	// take some action for error, but
	// don't return to caller
	//printf("error called: %s.\n", s);
	DBGPRINT(("error called: %s.\n", s));
//	exit(1);
}

/*******

	Add_bitstuff
	
*******/

unsigned Add_bitstuff(
	unsigned bus_time)
{
	// Bit stuffing is 16.6666% extra.
	// But we'll calculate bitstuffing as 16% extra with an add of a 4bit
	// shift (i.e.  value + value/16) to avoid floats.
	return (bus_time + (bus_time>>4));
}

/*******

	Allocate_check
	
*******/

int Allocate_check(
	unsigned *used,
	unsigned newval,
	unsigned limit)
{
	int ok = 1;
	unsigned t;

	// check if this new allocation fits in the currently used amout below the limit.
	//
	t = *used + newval;
	// do allocation even if over limit.  This will be fixed/deallocated after the frame is finished.
	*used = t;

	if ( t > limit)
	{
		//printf("Allocation of %d+%d out of %d\n", *used, newval, limit);
		DBGPRINT(("Allocation of %d+%d out of %d\n", (*used-newval), newval, limit));
		error("Allocation check failed");
		ok = 0;
	}
	return ok;
}


/*******

	OK_to_Insert
	
*******/
int OK_to_insert(
	PEndpoint	curr,
	PEndpoint	newep
	)
{

	// Determine if this current endpoint in the budget frame endpoint list is the one before
	// which the new endpoint should be inserted.

	// DON'T call this routine if there is already a large isoch ep in this frame and this is a
	// large isoch ep!!

	// Called in a loop for each endpoint while walking the budget frame endpoint list in linkage order.

	// on exit when returns 1: curr points to the endpoint before which the new endpoint should be inserted.

	int insertion_OK = 0;
	/*
		There are separate endpoint budget "trees" for isoch and interrupt.  A budget tree has the same
		organization as the EHCI interrupt qhead tree.  This allows a single endpoint data structure to
		represent the allocation requirements in all frames allocated to the endpoint.

		Order of insertion in a budget frame list of endpoints is as follows for each list.

		Isoch:
		1. Endpoints in period order, largest period to smallest period
				(required to maintain endpoint linkages easily in a "Tree")
				(HC will actually enqueue isoch xacts in smallest period to largest period order)
			1a. within the same period
				newer endpoints are at the front of the sublist, older are at the end
				(Since isoch are visited by the HC in reverse order, this results in new
				 endpoints being added after older endpoints, thereby having least impact on existing
				 frame traffic)
		2. An endpoint larger than LARGEXACT bytes (only ever one possible per frame) is held separated
			from normal list
			(avoids having a long isoch that requires 2 uframes with SS and CS)
			Note that the endpoint could have a period different than 1

		Interrupt:
		1. Endpoints in period order, largest period to smallest period
				(required to maintain endpoint linkages easily in a "Tree")
			1.2 within same period, newer endpoints are at the end of the sublist, older are at the front

		Corresponding required (for this algorithm) order of transactions in HC frame list is:
		1. First, an isoch endpoint larger than LARGEXACT bytes (only ever one possible per frame)
			(avoids having a long isoch that requires 2 uframes with SS and CS)
			Note that the endpoint could have a period different than 1
		2. Isoch endpoint ITDs in INCREASING period order
			***** (NOTE: THIS IS opposite AS IN THE BUDGET LIST!!!!) *****
			2a. within the same period, oldest allocated eps are first, newest allocated are last
		3. interrupts endpoint Qheads in decreasing period order (in "tree" of qheads)
			3a. within the same period, oldest allocated (in time) eps are first, newest allocated are last
	*/

	if (newep->calc_bus_time < LARGEXACT)  // only really possible for isoch
	{
		if (curr)  // some endpoints already allocated
		{
			// This is the correct insertion point if the new ep has a period longer/larger
			// than the current ep (so put it before the current ep)

			// check if this is the correct period order
			if ( ((curr->actual_period < newep->actual_period) && newep->ep_type == interrupt) ||
				 ((curr->actual_period <= newep->actual_period) && newep->ep_type == isoch))
			{
				insertion_OK = 1;
			} else
				if (curr == newep) // we are at the current endpoint (due to inserting during a previous frame)
					insertion_OK = 1;
		} else
			insertion_OK = 1;  // if first endpoint, always "insert" at head

	} //else large xact, so this routine shouldn't be called since the large is held separately
		// This routine won't be called if there is already a large in this frame.

	return insertion_OK;
}



/*******

	Compute_last_isoch_time

********/
int Compute_last_isoch_time(
	PEndpoint ep,
	int frame
	)
{
	int t;
	PEndpoint p;

	p = ep->mytt->frame_budget[frame].isoch_ehead;  // dummy SOF
	p = p->next_ep; // potential real isoch, could be large isoch or other isoch
	if (p)
	{
		// There is an isoch, so use its start time (since it is the last isoch on the bus.
		t = p->start_time + p->calc_bus_time;
	} else // There aren't other, nonlarge isoch transactions in the frame
	{
		// If there is a large isoch, use that
		if (ep->mytt->frame_budget[frame].allocated_large)
		{
			p = ep->mytt->frame_budget[frame].allocated_large;
			t = p->start_time + p->calc_bus_time;
		} else
			// no isoch transactions
			t = FS_SOF;
	}
	return t;
}




/*******

	Compute_ep_start_time

********/
int Compute_ep_start_time(
	PEndpoint curr_ep,
	PEndpoint ep,
	PEndpoint last_ep,
	int frame
	)
{
	int t;
	PEndpoint p;

	// Given that there is a dummy SOF endpoint at the beginning of each list (always), there
	// is always a valid last_ep.  If the end of list is reached, curr_ep will be zero.

	// For isoch endpoints, the "next" ep on the list is the previous start time endpoint

	// For interrupt endpoint, the previous ep is the previous start time endpoint.
	// For interrupt endpoint, if this is the interrupt endpoint at the beginning of the int list
	// (after some isoch), the start time is the end of the isoch.

	if (curr_ep)  // we will do an insertion in the middle of the list
	{
		if (ep->ep_type == isoch)
		{
			t = curr_ep->start_time + curr_ep->calc_bus_time;
		} else // interrupt
		{
			if (last_ep == ep->mytt->frame_budget[frame].int_ehead) // new first interrupt ep
			{
				t = Compute_last_isoch_time(ep, frame);
			} else
				t = last_ep->start_time + last_ep->calc_bus_time;
		}
	} else  // empty list or have run off end of budget list
	{
		if (ep->ep_type == isoch)
		{
			if (ep->mytt->frame_budget[frame].allocated_large)
			{
				p = ep->mytt->frame_budget[frame].allocated_large;
				t = p->start_time + p->calc_bus_time;
			} else
				t = FS_SOF;
		} else  // interrupt
		{
			if (last_ep != ep->mytt->frame_budget[frame].int_ehead)  // is the last ep not the dummy SOF?
			{
				// non empty list, ran off end of interrupt list,
				// this is the last transaction in the frame
				t = last_ep->start_time + last_ep->calc_bus_time;
			} else  // was empty interrupt list
				t = Compute_last_isoch_time(ep, frame);
		}
	} // end if for first endpoint on list

	return t;
}




/*******

	Compute_nonsplit_overhead

********/
int Compute_nonsplit_overhead(
	PEndpoint	ep)
{
	PHC hc;

	hc = ep->mytt->myHC;

	if (ep->speed == HSSPEED)
	{
		if (ep->direction == OUTDIR)
		{
			if (ep->ep_type == isoch)
			{
				return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			} else // interrupt
			{
				return HS_TOKEN_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD +
					HS_HANDSHAKE_OVERHEAD + hc->thinktime;
			}
		} else
		{ // IN
			if (ep->ep_type == isoch)
			{
				return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
				
			} else // interrupt
			{
				return HS_TOKEN_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD +
					HS_HANDSHAKE_OVERHEAD + hc->thinktime;
			}
		}  // end of IN overhead calculations
	} else  if (ep->speed == FSSPEED)
	{
		if (ep->ep_type == isoch)
		{
			return FS_ISOCH_OVERHEAD + hc->thinktime;
		} else // interrupt
		{
			return FS_INT_OVERHEAD + hc->thinktime;
		}
	} else  // LS
	{
		return LS_INT_OVERHEAD + hc->thinktime;
	}
}





/*******

	Compute_HS_Overheads

********/
Compute_HS_Overheads(
	PEndpoint	ep,
	int			*HS_SS,
	int			*HS_CS)
{
	PHC hc;

	hc = ep->mytt->myHC;

	if (ep->direction == OUTDIR)
	{
		if (ep->ep_type == isoch)
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = 0;
		} else // interrupt
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + HS_DATA_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_HANDSHAKE_OVERHEAD + hc->thinktime;
		}
	} else
	{ // IN
		if (ep->ep_type == isoch)
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
			
		} else // interrupt
		{
			*HS_SS = HS_SPLIT_SAME_OVERHEAD + hc->thinktime;
			*HS_CS = HS_SPLIT_TURN_OVERHEAD + HS_DATA_TURN_OVERHEAD + hc->thinktime;
		}
	}  // end of IN overhead calculations
}





/*******

	Deallocate_HS

********/
Deallocate_HS(
	PEndpoint	ep,
	int			frame_bias)
{

	// 1.   Calculate last microframe for a nominal complete split
	// 2.   Calculate HS overheads
	// 3.   Deallocate HS split overhead time
	// 4.   Deallocate separate HS data bus time

	
	unsigned i, t, f, HS_SSoverhead, HS_CSoverhead, lastcs, min_used;
	int m;
	PHC hc;

	hc = ep->mytt->myHC;
	
	//***
	//*** 1. Calculate last microframe for a nominal complete split
	//***



	// determine last microframe for complete split (isoch in particular)
	//lastcs = floor( (ep->start_time + ep->calc_bus_time) / (float) FS_BYTES_PER_MICROFRAME) + 1;
    lastcs =  ( (ep->start_time + ep->calc_bus_time) /  FS_BYTES_PER_MICROFRAME) + 1;

	//***
	//*** 2. Calculate HS overheads
	//***



	Compute_HS_Overheads(ep, &HS_SSoverhead, &HS_CSoverhead);


	//***
	//*** 3. Deallocate HS split overhead time for this frame
	//***


	// Deallocate HS time for SS and CS overhead, but treat data differently

	// Deallocate HS start split bus time
	
	m = ep->start_microframe;
	f = ep->start_frame + frame_bias;

	if (m == -1)
	{
		m = 7;
		if (f == 0)
			f = MAXFRAMES - 1;
		else
			f--;
	}

	for (i=0;i < ep->num_starts; i++)
	{
		hc->HS_microframe_info[f][m].time_used -= HS_SSoverhead;

		ep->mytt->num_starts[f][m]--;

		m++;
		if (m > 7) {
			m = 0;
			f = (f + 1) % MAXFRAMES;
		}
	}


	// Deallocate HS complete split bus time
	if (ep->num_completes > 0)
	{
		m = ep->start_microframe + ep->num_starts + 1;
		f = ep->start_frame + frame_bias;

		for (i = 0; i < ep->num_completes; i++)
		{
			hc->HS_microframe_info[f][m].time_used -= HS_CSoverhead;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	}


	//***
	//*** 4. Deallocate separate HS data bus time
	//***



	// Deallocate HS data part of split bus time
	if (ep->direction) // OUT
	{
		// Deallocate full portion of data time in each microframe for OUTs

		m = ep->start_microframe;
		f = ep->start_frame + frame_bias;

		if (m == -1)
		{
			m = 7;
			if (f == 0)
				f = MAXFRAMES - 1;
			else
				f--;
		}

		for (i=0; i < ep->num_starts; i++) {
			min_used = min(
				FS_BYTES_PER_MICROFRAME,
			    Add_bitstuff(ep->max_packet) - FS_BYTES_PER_MICROFRAME * i);

			hc->HS_microframe_info[f][m].time_used -= min_used;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	} else // IN
	{
		// Only deallocate at most 188 bytes for all devices behind a TT in
		// each microframe.
		if (ep->num_completes > 0)
		{
			m = ep->start_microframe + ep->num_starts + 1;
			f = ep->start_frame + frame_bias;

			for (i=0; i < ep->num_completes; i++)
			{
				// update total HS bandwith due to devices behind this tt
				// This is used to determine when to deallocate HS bus time.
				ep->mytt->HS_split_data_time[f][m] -=
					min(Add_bitstuff(ep->max_packet), FS_BYTES_PER_MICROFRAME);

				// calculate remaining bytes this endpoint contributes
				// to 188 byte limit per microframe and (possible) HS deallocation.

				if (ep->mytt->HS_split_data_time[f][m] < FS_BYTES_PER_MICROFRAME)
				{
					// find adjustment to HS allocation for data
					t = min(
						// 
					    FS_BYTES_PER_MICROFRAME - ep->mytt->HS_split_data_time[f][m],
						Add_bitstuff(ep->max_packet));

					hc->HS_microframe_info[f][m].time_used -= t;
				}


				m++;
				if (m > 7) {
					m = 0;
					f = (f + 1) % MAXFRAMES;
				}
			}
		}
	}
}



/*******

	Allocate_HS

********/
int Allocate_HS(
	PEndpoint	ep,
	int			frame_bias)
{

	// 1.   Calculate start microframe
	// 2.   Calculate last microframe for a nominal complete split
	// 3.   Calculate number of SSs, CSs and HS overheads
	// 4.   Allocate HS split overhead time
	// 5.   Allocate separate HS data bus time

	
	unsigned i, t, f, HS_SSoverhead, HS_CSoverhead, lastcs, min_used;
	int m, retv;
	PHC hc;

	retv = 1;

	hc = ep->mytt->myHC;
	
	//***
	//*** 1. Calculate start microframe
	//***

	if (frame_bias == 0)
		// only update endpoint for first frame since other frames will simply
		// reference this endpoint (which has already had its information computed)

		//ep->start_microframe = floor(ep->start_time / (float) FS_BYTES_PER_MICROFRAME) - 1;
        ep->start_microframe = (ep->start_time /  FS_BYTES_PER_MICROFRAME) - 1;


	//***
	//*** 2. Calculate last microframe for a nominal complete split
	//***



		// determine last microframe for complete split (isoch in particular)
	//lastcs = floor( (ep->start_time + ep->calc_bus_time) / (float) FS_BYTES_PER_MICROFRAME) + 1;
    lastcs = ( (ep->start_time + ep->calc_bus_time) / FS_BYTES_PER_MICROFRAME) + 1;

	//***
	//*** 3. Calculate number of SSs, CSs and HS overheads
	//***


	Compute_HS_Overheads(ep, &HS_SSoverhead, &HS_CSoverhead);


	// determine number of splits (starts and completes)
	if (ep->direction == OUTDIR)
	{
		if (ep->ep_type == isoch)
		{
			if (frame_bias == 0) {
				ep->num_starts = (ep->max_packet / FS_BYTES_PER_MICROFRAME) + 1;
				ep->num_completes = 0;
			}
		} else // interrupt
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = 2;
				if (ep->start_microframe + 1 < 6)
					ep->num_completes++;
			}
			}
	} else
	{ // IN
		if (ep->ep_type == isoch)
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = lastcs - (ep->start_microframe + 1);
				if (lastcs <= 6)
				{
					if ((ep->start_microframe + 1) == 0)
						ep->num_completes++;
					else
						ep->num_completes += 2;  // this can cause one CS to be in the next frame
				}
				else if (lastcs == 7)
				{
					if ((ep->start_microframe + 1) != 0)
						ep->num_completes++;  // only one more CS if late in the frame.
				}
			}
			
		} else // interrupt
		{
			if (frame_bias == 0) {
				ep->num_starts = 1;
				ep->num_completes = 2;
				if (ep->start_microframe + 1 < 6)
					ep->num_completes++;
			}
		}
	}  // end of IN


	//***
	//*** 4. Allocate HS split overhead time for this frame
	//***


	// check avail time for HS splits
	// allocate HS time for SS and CS overhead, but treat data differently

	// allocate HS start split bus time
	
	m = ep->start_microframe;
	f = ep->start_frame + frame_bias;

	if (m == -1)
	{
		m = 7;
		if (f == 0)
			f = MAXFRAMES - 1;
		else
			f--;
	}

	for (i=0;i < ep->num_starts; i++)
	{
		// go ahead and do the allocations even if the checks fail.  This will be deallocated after the
		// frame is finished.
		if (!Allocate_check(
				&hc->HS_microframe_info[f][m].time_used,
				HS_SSoverhead,
				HS_MAX_PERIODIC_ALLOCATION))
			retv = 0;

		// Check for >16 SS in a microframe to one TT?  Maybe not needed in practice.
		if (ep->mytt->num_starts[f][m] + 1 > 16) {
			error("too many SSs in microframe");
			retv = 0;
		}

		ep->mytt->num_starts[f][m]++;

		m++;
		if (m > 7) {
			m = 0;
			f = (f + 1) % MAXFRAMES;
		}
	}


	// allocate HS complete split bus time
	if (ep->num_completes > 0)
	{
		m = ep->start_microframe + ep->num_starts + 1;
		f = ep->start_frame + frame_bias;

		for (i = 0; i < ep->num_completes; i++)
		{
			if (!Allocate_check(
					&hc->HS_microframe_info[f][m].time_used,
					HS_CSoverhead,
					HS_MAX_PERIODIC_ALLOCATION))
				retv = 0;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	}


	//***
	//*** 5. Allocate separate HS data bus time
	//***



	// allocate HS data part of split bus time
	if (ep->direction) // OUT
	{
		// allocate full portion of data time in each microframe for OUTs

		m = ep->start_microframe;
		f = ep->start_frame + frame_bias;

		if (m == -1)
		{
			m = 7;
			if (f == 0)
				f = MAXFRAMES - 1;
			else
				f--;
		}

		for (i=0; i < ep->num_starts; i++) {
			min_used = min(
				FS_BYTES_PER_MICROFRAME,
			    Add_bitstuff(ep->max_packet) - FS_BYTES_PER_MICROFRAME * i);

			if (! Allocate_check(
					&hc->HS_microframe_info[f][m].time_used,
					min_used,
					HS_MAX_PERIODIC_ALLOCATION))
				retv = 0;

			m++;
			if (m > 7) {
				m = 0;
				f = (f + 1) % MAXFRAMES;
			}
		}
	} else // IN
	{
		// Only allocate at most 188 bytes for all devices behind a TT in
		// each microframe.
		if (ep->num_completes > 0)
		{
			m = ep->start_microframe + ep->num_starts + 1;
			f = ep->start_frame + frame_bias;

			for (i=0; i < ep->num_completes; i++)
			{
				//calculate remaining bytes this endpoint contributes
				// to 188 byte limit per microframe and new (possible) HS allocation.

				if (ep->mytt->HS_split_data_time[f][m] < FS_BYTES_PER_MICROFRAME)
				{
					// find minimum required new contribution of this device:
					// either remaining bytes of maximum for TT or the bus time the
					// device can contribute
					t = min(
						// find maximum remaining bytes in this microframe for this tt.
						// Don't let it go to negative, which it could when device bus time
						// is greater than bytes per microframe (188)
						max(
						  FS_BYTES_PER_MICROFRAME -
						    ep->mytt->HS_split_data_time[f][m],
						  0),
						Add_bitstuff(ep->max_packet));

					if (! Allocate_check(
							&hc->HS_microframe_info[f][m].time_used,
							t,
							HS_MAX_PERIODIC_ALLOCATION))
						retv = 0;
				}

				// update total HS bandwith due to devices behind this tt
				// This is used in remove device to determine when to deallocate HS
				// bus time.
				ep->mytt->HS_split_data_time[f][m] +=
					min(Add_bitstuff(ep->max_packet), FS_BYTES_PER_MICROFRAME);

				m++;
				if (m > 7) {
					m = 0;
					f = (f + 1) % MAXFRAMES;
				}
			}
		}
	}
	return retv;
}



/*******

	Move_ep

********/
int Move_ep(
	PEndpoint	curr_ep,
	int			shift_time,
	PEndpoint	changed_ep_list[],
	int			*changed_eps,
	int			max_changed_eps,
	int			*err)
{
	int i, f;

	*err = 1;
	// Adjust endpoint allocation, if we haven't already done so.
	// This endpoint is adjusted to its new time.

	// For interrupt endpoints that are being moved due to deallocation, an endpoint can be moved more than once.
	// This can happen when recomputing the adjustment in some previous frame didn't allow the full movement to take place
	// because some later frame hadn't yet been recomputed (so it was inconsistent).  The later move brings it closer to
	// consistency.

	// check if we already have this endpoint from some previous frame
//	for (i = 0; i < *changed_eps; i++)
	for (i = 0; changed_ep_list[i] != 0; i++)
		//if ((changed_ep_list[i] == curr_ep) && (curr_ep->moved_this_req))
		if (changed_ep_list[i] == curr_ep) 
			break;

//	if ((i >= *changed_eps) ||  // haven't seen this endpoint before
//		((i < *changed_eps) && !curr_ep->moved_this_req) || // have seen this endpoint this pass
		if ((changed_ep_list[i] == 0) ||  // haven't seen this endpoint before
		((changed_ep_list[i] != 0) && !curr_ep->moved_this_req) || // have seen this endpoint this pass
		((curr_ep->ep_type == interrupt) && (shift_time < 0)) )
	{	// Update NEW changed endpoint

		// newly moved endpoints must have their HS bus time deallocated in all period frames in the budget window
		// (since the start_time can't be changed without affecting all frames the endpoint is in) 
		// then their start_time can be changed and the bus time reallocated for all period frames in the budget window
		for (f=0; (f + curr_ep->start_frame) < MAXFRAMES; f += curr_ep->actual_period)
			Deallocate_HS(curr_ep, f);

		curr_ep->start_time += shift_time;

		if ((curr_ep->start_time + curr_ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
		{
			error("end of new xact too late");
			*err = 0;
		}

		curr_ep->moved_this_req = 1;
		if (changed_ep_list[i] == 0)
		{

			// don't overrun bounds of array if too small
			if (i < max_changed_eps)
			{ 
				changed_ep_list[i] = curr_ep;
				changed_ep_list[i + 1] = 0; // zero terminated list
			} else
			{
				error("too many changed eps");
				*err = 0;
				// will be fixed after the frame is finished
			}

		} // already have this endpoint on the change list

		for (f=0; (f + curr_ep->start_frame) < MAXFRAMES; f += curr_ep->actual_period)
			if (! Allocate_HS(curr_ep, f))
				*err = 0;

		return 1;
	} else
		return 0;
}


/*******

	Common_frames

********/
int Common_frames(PEndpoint a, PEndpoint b)
{
	PEndpoint maxep, minep;

	/* Determine if the two endpoints are present in the same frames based on their
	*	start_frame and actual_period.
	*/

	if ((a->actual_period == 1) || (b->actual_period == 1))
		return 1;

	if (a->actual_period >= b->actual_period)
	{
		maxep = a;
		minep = b;
	}
	else
	{
		maxep = b;
		minep = a;
	}

	if ((maxep->start_frame % minep->actual_period) == minep->start_frame)
		return 1;
	else
		return 0;
}



/*******

	Deallocate_endpoint_budget

********/
int Deallocate_endpoint_budget(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps,			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	int partial_frames)				// number of partial frames that have been allocated
									// Normally MAXFRAMES, but this function is also used to unwind partial
									// allocations.
{
	/*

	 1. For each frame that endpoint is in:
	 2.		Deallocate HS bus time for this endpoint
	 3. 	Deallocate classic bus time
	 4.		Find where endpoint is
	 5.		Unlink this endpoint
	 6. 	For isoch:
	 7.			Compute gap
	 8.			For previous (larger/eq period) endpoint in this frame list
	 9.				move endpoint its new earlier position in the frame
						(skipping same period endpoints that have already been moved)
	10.			Setup to move interrupt endpoints
	11.		For interrupt:
	12.			For next (smaller/eq period) endpoint in this frame list
	13.				Compute gap
	14.				if ep is same period as gap, move it earlier
	15.				else  "ep has faster period"
	16.					check for gap in "sibling" dependent frames of ep
	17.					if gap in all, move ep earlier
	18.				if moved, do next ep

	*/

	int frame_bias, shift_time, changed_eps, moved, move_status;
	unsigned frame_cnt, gap_start, gap_end, i, j, siblings, gap_period;
	PEndpoint curr_ep, last_ep, p, head, gap_ep;

	// check that this endpoint is already allocated
	if (! ep->calc_bus_time)
	{
		error("endpoint not allocated");
		return 0;
	}

	// handle nonsplit HS deallocation
	if ((ep->speed == HSSPEED) && (ep->mytt->myHC->speed == HSSPEED))
	{
		for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
			i < MAXFRAMES*MICROFRAMES_PER_FRAME;
			i += ep->actual_period)
		{
			ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
				i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;
		}
		ep->calc_bus_time = 0;
		return 1;
	} else  // split and nonsplit FS/LS deallocation
	{
		if ((ep->speed != HSSPEED) && (ep->mytt->myHC->speed != HSSPEED))
		{
			// do classic (nonsplit) deallocation for classic HC
			for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period)
				ep->mytt->myHC->HS_microframe_info[i][0].time_used -= ep->calc_bus_time;
			ep->calc_bus_time = 0;
			return 1;
		}
	}


	changed_eps = 0;

	while (changed_ep_list[changed_eps])  // reset indicators of endpoints changed this pass.
	{
		changed_ep_list[changed_eps]->moved_this_req = 0;
		changed_eps++;
	}
	// this allows appending changed endpoints onto the current change list.
	
	frame_bias = ep->start_frame;
	frame_bias = (- frame_bias) + (partial_frames - 1);

	for (frame_cnt=partial_frames; frame_cnt > 0; frame_cnt--)
	{


	//***
	//*** 2. Deallocate HS bus time
	//***

		// Only do deallocation handling for frames this endpoint is located in
		if ((frame_bias % ep->actual_period) == 0)
		{
			Deallocate_HS(ep, frame_bias);


	//***
	//*** 3. Deallocate classic bus time
	//***


			ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used -= ep->calc_bus_time;

		}



	//***
	//*** 4. Find where endpoint is
	//***


		// endpoint may not be in a particular frame since we process all frames, and the endpoint
		// can have a period greater than 1.  We process all frames, since the allocated times in a
		// frame can be affected by endpoint allocations in other frames.

		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past SOF endpoint
		} else
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint
		}


		// if this is not a large transaction, then search for it.
		if (ep->calc_bus_time <= LARGEXACT)
		{
			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				if (OK_to_insert(curr_ep, ep))
					break;
				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// The isoch search will stop at the beginning of the same period sublist.  The endpoint to be removed
			// could be further in the sublist, we need to check for that if the ep to be removed isn't the first
			// on the list.  However, if it turns out that the ep isn't in the list, we can't lose the initial
			// location

			if ((ep->ep_type == isoch) && curr_ep)
			{
				p = last_ep;

				while ((curr_ep->actual_period == ep->actual_period) && (curr_ep != ep))
				{
					last_ep = curr_ep;
					curr_ep = curr_ep->next_ep;
					if (curr_ep == 0)
					{
						// didn't find endpoint in list, so restore pointers back to initial location
						last_ep = p;
						curr_ep = last_ep->next_ep;
						break;
					}
				}
			}

		} else  // large transaction, so just get to the end of the isoch list to set up curr_ep and last_ep
		{
			while (curr_ep)
			{
				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// now set up curr_ep to point to the large endpoint, but leave last_ep pointing to the end of the isoch list
			curr_ep = ep;
		}


	//***
	//*** 5. Unlink endpoint
	//***

		// only unlink if the endpoint is in this frame
		if ((frame_bias % ep->actual_period) == 0)
		{

			if (ep->calc_bus_time <= LARGEXACT)
			{

//				if ((curr_ep == 0) && ((frame_bias % ep->actual_period) == 0))
				if (curr_ep != 0)
				{
					last_ep->next_ep = curr_ep->next_ep;
					curr_ep = curr_ep->next_ep;
				}
			} else
				ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large = 0;

		}  // processing of frames this endpoint is in

		gap_ep = ep;
		gap_period = gap_ep->actual_period;



	//***
	//*** 6. For isoch
	//***


		if (ep->ep_type == isoch)
		{

			// For isoch, when we find the deallocated endpoint in a frame, all isoch endpoints after it must
			// be compacted (moved earlier).  Since the isoch portion of the frame is kept in increasing period
			// order and is compacted, a deallocation results in a recompacted budget.


	//***
	//*** 7. Compute gap
	//***


			head = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;

			gap_start = ep->start_time;
			gap_end = gap_start + ep->calc_bus_time;

			// If the deallocated endpoint is the large one and not period 1, we must check for siblings before
			// compacting, since large allocations in other frames can prevent a compaction

			if ((ep->calc_bus_time > LARGEXACT) && (ep->actual_period != 1))
			{
				for (i = 0; i < ep->actual_period; i++)
				{
					if (i != ep->start_frame)
					{
						p = ep->mytt->frame_budget[i].allocated_large;
						if (p)
							if (p->start_time + p->calc_bus_time - 1 > gap_start)
							{
								gap_start = p->start_time + p->calc_bus_time;
								if (gap_end - gap_start <= 0)
									break;
							}
					}
				}
			}



	//***
	//*** 8. For previous (larger/eq period) endpoint in this frame list
	//***


			if (gap_end - gap_start > 0)
			{
				// if large isoch is the one deallocated, update gap period based on the period of the last isoch
				// in this frame
				if ((ep->calc_bus_time > LARGEXACT) && (last_ep->actual_period < gap_period))
					gap_period = last_ep->actual_period;

				while (last_ep != head)
				{

					// The isoch list is "backwards", so curr_ep is earlier in the frame and last_ep is later.
					// Compute the gap accordingly.

					// curr_ep and last_ep are normally valid endpoints, but there are some corner conditions:
					// a) curr_ep can be null when the ep isn't found, but we won't be here if that's true.
					// b) last_ep can be dummy_sof when ep is newest, slowest period endpoint, but that will be
					//		handled as part of the interrupt ep handling initial conditions (and we won't get here)


	//***
	//*** 9.				move endpoint its new earlier position in the frame
	//***					(skipping same period endpoints that have already been moved)
	//***


					shift_time = gap_end - gap_start;

					if (shift_time > 0)
					{
						moved = Move_ep(
							last_ep,
							- shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);
						if (! move_status)
							error("deallocation move failure!!");  //<<few things can go wrong here, but num eps could >>

						if (! moved)
							break;	// since we have found the part of the frame tree that has already been moved
									// previous frames.
					}

					// rewalk isoch list until we get to "previous" endpoint in list/frame.
					// This will be a little nasty since the isoch tree is linked in the opposite order that we
					// really need to walk the frame to "compact".  Simply re-walk the isoch tree for this frame
					// from the head until we get to the previous. This is mostly ok since the isoch tree is
					// extremely likely to be normally very short so the processing hit of rewalking the list will
					// normally be small.

					p = last_ep;
					last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
					curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

					// This test always terminates since we can't run off the end of the list due to the entry
					// condition of the last_ep not being the (dummy) head.
					while (curr_ep != p)
					{
						last_ep = curr_ep;
						curr_ep = curr_ep->next_ep;
					}

				} // end of isoch endpoints in frame
			}  // end of shift handling



	//***
	//*** 10.			Setup to move interrupt endpoints
	//***


			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			// if there is an isoch endpoint, use the last one as the last_ep for interrupt budget
			// processing to allow correct computation of the previous transaction end time.
			// if there is a non-large isoch endpoint, use it other if there is a large isoch use that
			// otherwise, leave the dummy sof interrupt endpoint as last
			if (ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep;
			else if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;

		} // end isoch



	//***
	//*** 11.		For interrupt
	//***


		// The interrupt frame budget can have "holes" of unallocated time in a frame.  These holes
		// can be caused by some endpoint in one frame forcing an endpoint in another frame to be later
		// in the frame to avoid collisions.  In order to compact after a deallocation, we have to ensure
		// that the gap exists in all frames of an endpoint that is a candidate to move.

		// An endpoint that has an end time that is greater than ep's start time (but less than the
		// end time) advances the gap start time to the (previous) endpoint's end time.
		// An endpoint that has a start time that is less than the ep's end time (but greater than the
		// start time) reduces the end time to the (later) endpoint's start time.
		//
		// If the gap end time is greater than the gap start time, we have to move affected endpoints by that
		// amount.  Otherwise, no endpoints are affected by the removal in this frame.


		// if this is the first interrupt on the endpoint list, fixup the last_ep pointer for the gap computation
		if ((ep->ep_type == interrupt) && (last_ep == ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead))
		{
			if (ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead->next_ep;
			else if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;
		}


	//***
	//*** 12.			For next (smaller/eq period) endpoint in this frame list 
	//***


		while (curr_ep)
		{



	//***
	//*** 13.				Compute gap				 
	//***


			gap_start = last_ep->start_time + last_ep->calc_bus_time;
			gap_end = curr_ep->start_time;

			moved = 0;

	//***
	//*** 14.				if ep is same or larger period than gap, move it earlier 
	//***


			if ((gap_period <= curr_ep->actual_period) && (gap_ep->start_frame == curr_ep->start_frame))
			{
				shift_time = gap_end - gap_start;

				if (shift_time > 0)
				{
					moved = Move_ep(
						curr_ep,
						- shift_time,
						changed_ep_list,
						&changed_eps,
						*max_changed_eps,
						&move_status);
					if (! move_status)
						error("deallocate move failure 2");  // <<few things, but num eps could fail here>>
				}
			} else // move candidate has a smaller interrupt period or has a different start_frame
			{


	//***
	//*** 15.				else  "ep has faster period or different start_frame"
	//***



	//***
	//*** 16.					check for gap in "sibling" dependent frames of ep
	//***

				// siblings are the other frames that the curr_ep is dependent upon.  E.g. if curr period
				// is 1 and gap_period is 8, there are 7 other frames that need to be checked for a gap
				if (Common_frames(curr_ep, ep))
					siblings = (gap_period / curr_ep->actual_period);
				else // move candidate is not in frames occupied by deleted endpoint
					siblings = MAXFRAMES / curr_ep->actual_period;

				j = curr_ep->start_frame;

				for (i = 0; i < siblings; i++)
				{
					// find curr_ep in new sibling frame to check gap
					// We only look in frames that we know the curr_ep is in.
					// We can look in frames that aren't affected by the deleted ep, but don't optimize for now.

					// skip the gap start frame since we already know it has a gap
					if (j != gap_ep->start_frame) {
						
						last_ep = ep->mytt->frame_budget[j].int_ehead;
						p = last_ep->next_ep;

						// fixup last_ep if this is the first interrupt ep in the frame after some isoch.
						if (ep->mytt->frame_budget[j].isoch_ehead->next_ep)
							last_ep = ep->mytt->frame_budget[j].isoch_ehead->next_ep;
						else if (ep->mytt->frame_budget[j].allocated_large)
							last_ep = ep->mytt->frame_budget[j].allocated_large;
						
						while (p && (p != curr_ep))
						{
							last_ep = p;
							p = p->next_ep;
						}

						if (last_ep->start_time + last_ep->calc_bus_time - 1 > gap_start)
						{
							gap_start = last_ep->start_time + last_ep->calc_bus_time;
							if (gap_end - gap_start <= 0)
								break;
						}
					}
					j += curr_ep->actual_period;
				}


	//***
	//*** 17.					if gap in all, move ep earlier
	//***


				shift_time = gap_end - gap_start;

				if (shift_time > 0)
				{
					moved = Move_ep(
						curr_ep,
						- shift_time,
						changed_ep_list,
						&changed_eps,
						*max_changed_eps,
						&move_status);
					if (! move_status)
						error("deallocate move failure 3"); //  << few things, but num eps could fail here>>
				}
			}  // end of faster period interrupt endpoint move candidate


	//***
	//*** 18.				if moved, do next ep
	//***


			if (!moved)
				break;

			gap_ep = curr_ep;
			if (gap_period > curr_ep->actual_period)
				gap_period = curr_ep->actual_period;

			last_ep = curr_ep;
			curr_ep = curr_ep->next_ep;
		} // end interrupt endpoints in frame

		frame_bias--;
	}  // end for all frames


	ep->calc_bus_time = 0;

	return 1;
}






/*******

	Allocate_time_for_endpoint

********/
int Allocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be configured (bus time allocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	)
{
	int shift_time, frame_bias, moved, retv, move_status;
	unsigned t, overhead, changed_eps, i, min_used, latest_start, frame_cnt;
	PEndpoint curr_ep, last_ep, p;

	changed_eps = 0;

	retv = 1;

	// OVERVIEW of algorithm steps:
	//  1. Determine starting frame # for period
	//  2. Calculate classic time required
	//  3. For all period frames, find the latest starting time so we can check the classic allocation later
	//  4. Process each frame data structure for endpoint period in budget window
	//  5.   Now check allocation for each frame using shift adjustment based on latest start time
	//  6a.  Now move isoch endpoints, insert new isoch and then move interrupt endpoints
	//  6b.	 Now insert new interrupt and move rest of interrupt endpoints
	//	7.   Allocate HS bus time
	//  8.   Allocate classic bus time


	//***
	//*** 1. Determine starting frame # for period
	//***



	// Also remember the maximum frame time allocation since it will be used to pass the allocation check.

	// Find starting frame number for reasonable balance of all classic frames

	ep->start_frame = 0;
	ep->start_microframe = 0;
	ep->num_completes = 0;
	ep->num_starts = 0;

	// check that this endpoint isn't already allocated
	if (ep->calc_bus_time)
	{
		error("endpoint already allocated");
		return 0;
	}

	// handle nonsplit HS allocation
//	if ((ep->speed == HSSPEED) && (ep->mytt->myHC->speed == HSSPEED)) {
	if (ep->speed == HSSPEED) {

		min_used = ep->mytt->myHC->HS_microframe_info[0][0].time_used;

		if (ep->period > MAXFRAMES*MICROFRAMES_PER_FRAME)
			ep->actual_period = MAXFRAMES*MICROFRAMES_PER_FRAME;
		else
			ep->actual_period = ep->period;

		// Look at all candidate frames for this period to find the one with min
		// allocated bus time.  
		//
		for (i=1; i < ep->actual_period; i++)
		{
			if (ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used < min_used)
			{
				min_used = ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][i % MICROFRAMES_PER_FRAME].time_used;
				ep->start_frame = i/MICROFRAMES_PER_FRAME;
				ep->start_microframe = i % MICROFRAMES_PER_FRAME;
			}
		}

		// compute and allocate HS bandwidth
		ep->calc_bus_time = Compute_nonsplit_overhead(ep) + Add_bitstuff(ep->max_packet);
		for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
			i < MAXFRAMES*MICROFRAMES_PER_FRAME;
			i += ep->actual_period)
		{
			if (! Allocate_check(
				&(ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
						i % MICROFRAMES_PER_FRAME].time_used),
				ep->calc_bus_time,
				HS_MAX_PERIODIC_ALLOCATION))
			  retv = 0;
		}
		if (! retv)  // if allocation failed, deallocate
		{
			for (i = (ep->start_frame*MICROFRAMES_PER_FRAME) + ep->start_microframe;
				i < MAXFRAMES*MICROFRAMES_PER_FRAME;
				i += ep->actual_period)
			{
				ep->mytt->myHC->HS_microframe_info[i/MICROFRAMES_PER_FRAME][
					i % MICROFRAMES_PER_FRAME].time_used -= ep->calc_bus_time;
			}
		}
		return retv;
	} else  {
		// split or nonsplit FS/LS speed allocation
		// classic allocation
		if ((ep->speed != HSSPEED) && (ep->mytt->myHC->speed != HSSPEED)) {
			min_used = ep->mytt->myHC->HS_microframe_info[0][0].time_used;

			if (ep->period > MAXFRAMES)
				ep->actual_period = MAXFRAMES;
			else
				ep->actual_period = ep->period;

			// Look at all candidate frames for this period to find the one with min
			// allocated bus time.  
			//
			for (i=1; i < ep->actual_period ; i++)
			{
				if (ep->mytt->myHC->HS_microframe_info[i][0].time_used < min_used)
				{
					min_used = ep->mytt->myHC->HS_microframe_info[i][0].time_used;
					ep->start_frame = i;
				}
			}

			// compute and allocate FS/LS bandwidth
			ep->calc_bus_time = Compute_nonsplit_overhead(ep) +
				Add_bitstuff((ep->speed?1:8) * ep->max_packet);

			for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period) {
				t = ep->mytt->myHC->HS_microframe_info[i][0].time_used;  // can't take address of bitfield (below)
				if (! Allocate_check( &t, ep->calc_bus_time, FS_MAX_PERIODIC_ALLOCATION))
				  retv = 0;
				ep->mytt->myHC->HS_microframe_info[i][0].time_used =	t;
			}
			if (! retv) {
				for (i = ep->start_frame; i < MAXFRAMES; i += ep->actual_period)
					ep->mytt->myHC->HS_microframe_info[i][0].time_used -= ep->calc_bus_time;
			}
			return retv;
		} else {
			// split allocation
			min_used = ep->mytt->frame_budget[0].time_used;

			if (ep->period > MAXFRAMES)
				ep->actual_period = MAXFRAMES;
			else
				ep->actual_period = ep->period;

			// Look at all candidate frames for this period to find the one with min
			// allocated bus time.  
			//
			for (i=1; i < ep->actual_period ; i++) {
				if (ep->mytt->frame_budget[i].time_used < min_used) {
					min_used = ep->mytt->frame_budget[i].time_used;
					ep->start_frame = i;
				}
			}
		}
	}

	// above handles all speeds, the rest of this code is for split transaction processing



	// There could be multiple frames with a minimum already allocated bus time.
	// If there is a frame where this ep would be added at the end of the frame,
	// we can avoid doing an insert (which requires other endpoints to be adjusted).
	// Currently we don't look for that optimization.  It would involve checking the
	// frame endpoint list to see if the new endpoint would be the last and if not
	// going back to see if there is another candidate frame and trying again (until
	// there are no more candidate frames).  We could also keep track of the candidate
	// frame that had the least affect on other endpoints (for the case where there
	// is a frame that makes the new endpoint closest to last).

	// <<attempt later maybe>>??



	//***
	//*** 2. Calculate classic time required
	//***

	// Calculate classic overhead
	if (ep->ep_type == isoch)
	{
		if (ep->speed == FSSPEED)
			overhead = FS_ISOCH_OVERHEAD + ep->mytt->think_time;
		else
		{
			error("low speed isoch illegal"); // illegal, LS isoch
			return 0;
		}
	} else
	{ // interrupt
		if (ep->speed == FSSPEED)
			overhead = FS_INT_OVERHEAD + ep->mytt->think_time;
		else
			overhead = LS_INT_OVERHEAD + ep->mytt->think_time;
	}

	// Classic bus time, NOT including bitstuffing overhead (in FS byte times) since we do best case budget
	ep->calc_bus_time = ep->max_packet * (ep->speed?1:8) + overhead;



	//***
	//*** 3. For all period frames, find the latest starting time so we can check the classic allocation later.
	//***

	//	Checking the classic allocation takes two passes through the frame/endpoint lists.
	//	Or else we would have to remember the last/curr ep pointers for each period frame and loop back
	//	through that list the second time. (<<Future optimization?>>)

	//	To find the start time to use for the new endpoint: for each frame, find the insertion point and use
	//	the "previous" endpoint in the FRAME. Use the previous endpoint end time as a possible start time
	//	for this new endpoint. Use the end time instead of the insertion point start time since there can
	//	before endpoints and we want to allocate as contiguously as possible.  Using this time, find the latest
	//	start be unallocated time time across all frames (this keeps the early part of the frame as allocated as
	//	possible to avoid having to worry about fragmentation of	time (and even more complexity).
	//
	//	Once the final start time is known, then for each frame, check the allocation required in each frame.
	//	The total frame allocation is actually the time of the ending of the last transaction in the frame.
	//	It is possible that a new allocation can fit in an unallocated "gap" between two other allocated
	//	endpoints of slower periods. The new allocation is therefore any shift required of later endpoints in
	//	the frame.
	//
	//	The shift is computed as:
	//		shift = (final_start_time + new.calc_bus_time) - curr.start_time
	//	If shift is positive, later endpoints must be moved by the shift amount, otherwise later endpoints
	//	(and the frame allocation) aren't affected.

	latest_start = FS_SOF + HUB_FS_ADJ;  // initial start time must be after the SOF transaction

	// find latest start
	for (i=0; ep->start_frame + i < MAXFRAMES; i += ep->actual_period)
	{
		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + i].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past SOF endpoint
		} else
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + i].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint
		}

		// if this frame has a large transaction endpoint, make sure we don't allocate another one
		if (ep->mytt->frame_budget[ep->start_frame + i].allocated_large)
		{
			if (ep->calc_bus_time >= LARGEXACT)
			{
				error("too many large xacts");  // only one large transaction allowed in a frame.
				return 0;
			}
		}

		while (curr_ep)  // walk endpoint list for this frame to find where to insert new endpoint
		{
			// Note: the actual insertion will be done later
			//

			if (OK_to_insert(curr_ep, ep))
			{
				break;
			}
			last_ep = curr_ep;
			curr_ep = curr_ep->next_ep;
		}

		t = Compute_ep_start_time(curr_ep, ep, last_ep, ep->start_frame + i);

		// update latest start time as required
		if (t > latest_start)
			latest_start = t;
	} // end of for loop looking for latest start time


	// Set the start time for the new endpoint
	ep->start_time = latest_start;
	
	if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
	{
//		error("start time %d past end of frame", ep->start_time + ep->calc_bus_time);
		ep->calc_bus_time = 0;
		return 0;
	}


	//***
	//*** 4.  Process each frame data structure for endpoint period in budget window
	//***


	changed_eps = 0;	// Track number of endpoints that will need to be updated.

	while (changed_ep_list[changed_eps])  // reset indicators of endpoints changed this pass.
	{
		changed_ep_list[changed_eps]->moved_this_req = 0;
		changed_eps++;
	}
	// this allows appending changed endpoints onto the current change list.

	// We have to check the allocation of this new endpoint in each frame.  We also have to move any
	// later endpoints in the frame to their new start times (and adjust their SS/CS allocations as
	// appropriate).
	//
	// Doing this is tricky since:
	//	A. The actual isoch portion of the frame is organized in reverse order in the budget list
	//	B. If a large isoch transaction exists in this frame, it is first in the frame
	//
	// For a new isoch ep:
	//	We have to find the shift for this endpoint.
	//	We have to move isoch endpoints up to (but not including) the isoch insertion point endpoint
	//  We also have to move all interrupt endpoints (to the end of the list and frame) after we
	//	finish the isoch endpoints.
	//
	// For a new interrupt ep:
	//	skip to the insertion point without doing anything
	//	then move the start times of the rest of the interrupt endpoints until the end of the list (and frame)
	//

	// Allocate time in each frame of the endpoint period in the budgeting window.
	//
	// Since the interrupt frame budget is ordered with decreasing period (with holes in the budget),
	// we must process all frames in the budget window to correctly move any smaller period interrupt
	// endpoints that are affected by this new enpoint, even though the new endpoint is only added in
	// its period frames

	frame_bias = ep->start_frame;
	frame_bias = - frame_bias;

	for (frame_cnt=0; frame_cnt < MAXFRAMES; frame_cnt++)
	{


	//***
	//*** 5. Now check allocation for each frame using shift adjustment based on latest start time
	//***

		if (ep->ep_type == isoch)
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			p = last_ep;  // save the starting point so we can start over after finding the shift time

			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				// Note: the actual insertion will be done later, this just does the allocation check
				//

				if (OK_to_insert(curr_ep, ep))
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			//	shift = (final_start_time + new.calc_bus_time) - curr.start_time
			// for isoch the last_ep is the endpoint before which the new one is inserted, i.e. it is "curr"
			if (last_ep != ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead)
				// This is somewhere in the "middle" of the list
				shift_time = (latest_start + ep->calc_bus_time) - last_ep->start_time;
			else
			{
				if (curr_ep)
				{
					// There is only one endpoint on the list, so must use 1st (non dummy SOF) int endpoint as
					// next ep in frame (if there is one)
					if (ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead->next_ep)
						shift_time = (latest_start + ep->calc_bus_time) -
										ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead->next_ep->start_time;
					else  // no int endpoints
						shift_time = 0;
				} else
					// There are no endpoints on the isoch list
					shift_time = ep->calc_bus_time;
			}

			//
			// Check classic allocation
			//

			// check that if new ep is at end of frame, it will fit in the frame
			//if ((ep->start_time + ep->calc_bus_time) > FS_MAX_PERIODIC_ALLOCATION)
			//{
			//	error("new xact too late in frame");
			//	Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt);
			//	return 0;
			//}

			// check classic allocation with adjusted start time before proceeding
			if (shift_time > 0)
			{
				// worst frame test to stop remaining processing as early as possible.
				t = ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used;
				if ( ! Allocate_check(&t, shift_time, FS_MAX_PERIODIC_ALLOCATION))
				{
					Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt);
					return 0;
				}
			}


	//***
	//*** 6a. Now move isoch endpoints, insert new isoch and then move interrupt endpoints
	//***


			last_ep = p;
			curr_ep = last_ep->next_ep;

			// Walk endpoint list for this frame to find where to insert new isoch endpoint.
			// This time we move later isoch endpoints in frame (early endpoints on budget list)
			while (curr_ep)
			{

				if (! OK_to_insert(curr_ep, ep))
				{
					if (shift_time > 0) {
						moved = Move_ep(
							curr_ep,
							shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);

						if (! move_status)
							retv = 0;

						if (! moved)  // already have visited the endpoints from here on in this frame
							break;
					}
				} else  // insert new endpoint here
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			// Don't insert endpoint if its already been inserted and processed due to a previous endpoint
			//
			if (curr_ep != ep) {
				if ((frame_bias % ep->actual_period) == 0)
				// Only allocate new endpoint in its period frames 
				{
					// insert new endpoint
					if (ep->calc_bus_time >= LARGEXACT)
					{
						// save the large ep pointer
						ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large = ep;
				
						// we don't link the large onto any other endpoints
					} else
					{  // not large, so link the endpoint onto the list
						if (frame_bias == 0)
							ep->next_ep = curr_ep;
						last_ep->next_ep = ep;
					}
				}

				// now move all interrupt endpoints
				// find end of last isoch ep and check if it is after start of first interrupt, if so, interrupt
				// eps must be shifted

				p = ep->mytt->frame_budget[ep->start_frame + frame_bias].isoch_ehead; // sof

				if (p->next_ep)
					p = p->next_ep;  // last actual isoch , could be null when no isoch allocated in this frame
				else
					if (ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large)
						p = ep->mytt->frame_budget[ep->start_frame + frame_bias].allocated_large;
					
				last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
				curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

				if (curr_ep) {  // only move interrupt endpoints that are there

					if ((p->start_time + p->calc_bus_time) > curr_ep->start_time) {
			

						// Compute the shift time for all following interrupt endpoints ONCE.  Then
						// apply it to all endpoints.  This ensures that any gaps between endpoints are
						// preserved without compression.
						shift_time = p->start_time + p->calc_bus_time - curr_ep->start_time;

						while (curr_ep)
						{
							// Note: this doesn't do any insertion, just adjusts start times of interrupt eps
							// we haven't seen yet

							//  << this can exit once it finds an ep we have already seen>>
							moved = Move_ep(
								curr_ep,
								shift_time,
								changed_ep_list,
								&changed_eps,
								*max_changed_eps,
								&move_status);
							if (! move_status)
								retv = 0;

							if (! moved)
								break;

							last_ep = curr_ep;
							curr_ep = curr_ep->next_ep;
						}
					}
				}
			}

		} else  // interrupt
		{
			last_ep = ep->mytt->frame_budget[ep->start_frame + frame_bias].int_ehead;
			curr_ep = last_ep->next_ep;  // get past dummy SOF endpoint

			// walk endpoint list for this frame to find where to insert new endpoint
			while (curr_ep)
			{
				// Note: the actual insertion will be done later, this just does the allocation check
				//

				if (OK_to_insert(curr_ep, ep))
					break;

				last_ep = curr_ep;
				curr_ep = curr_ep->next_ep;
			}

			//	shift = (final_start_time + new.calc_bus_time) - curr.start_time
			if (curr_ep)
				shift_time = (latest_start + ep->calc_bus_time) - curr_ep->start_time;
			else
				shift_time = ep->calc_bus_time;


			// only change endpoints in frame if the new interrupt endpoint is in this frame
			if ((frame_bias % ep->actual_period) == 0)
			{
				shift_time = 0;
			}


			//
			// Check classic allocation
			//

			// check classic allocation with adjusted start time before proceeding
			if (shift_time > 0)
			{
				// worst frame test to stop remaining processing as early as possible.
				t = ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used;
				if ( ! Allocate_check(&t, shift_time, FS_MAX_PERIODIC_ALLOCATION))
					retv = 0;
			}


	//***
	//*** 6b. Now insert new interrupt endpoint and move rest of interrupt endpoints
	//***


			// insert new endpoint
			if (curr_ep != ep) {
				if ((frame_bias % ep->actual_period) == 0) {
					// Only allocate new endpoint in its period frames 
					if (frame_bias == 0)
						ep->next_ep = curr_ep;

					last_ep->next_ep = ep;
					last_ep = ep;
				}

				if (shift_time > 0) {
					while (curr_ep)
					{
						// Move the rest of the interrupt endpoints
						//

						moved = Move_ep(
							curr_ep,
							shift_time,
							changed_ep_list,
							&changed_eps,
							*max_changed_eps,
							&move_status);
						if (! move_status)
							retv = 0;

						if (! moved)
							break;

						last_ep = curr_ep;
						curr_ep = curr_ep->next_ep;
					}
				}
			}
		} // end of interrupt insertion handling


	//***
	//*** 7. Allocate HS bus time for endpoint
	//***

		if (frame_bias % ep->actual_period == 0)  // Only allocate new endpoint in its period frames
		{
			if (! Allocate_HS(ep, frame_bias))
				retv = 0;

	//***
	//*** 8. Allocate classic bus time
	//***


			ep->mytt->frame_budget[ep->start_frame + frame_bias].time_used += ep->calc_bus_time;
		}

		if (!retv)
		{
			// some error in this frame, so do partial deallocation and exit
			Deallocate_endpoint_budget(ep, changed_ep_list, max_changed_eps, frame_cnt + 1);
			return 0;
		}

		frame_bias++;

	} // end of "for each frame in budget window"

	return retv;
}





/*******

	Deallocate_time_for_endpoint

********/
void
Deallocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	)
{
	// Deallocate all frames of information
	Deallocate_endpoint_budget(ep, changed_ep_list,max_changed_eps, MAXFRAMES);
}










/*******

	Set_endpoint()

********/
Set_endpoint(
	PEndpoint	ep,
	eptype		t,
	unsigned	d,
	unsigned	s,
	unsigned	p,
	unsigned	m,
	TT			*thistt
	)
{
	ep->ep_type = t;
	ep->direction = d;
	ep->speed = s;
	ep->period = p;
	ep->max_packet = m;
	ep->mytt = thistt;
	ep->calc_bus_time = 0;
	ep->start_frame = 0;
	ep->start_microframe = 0;
	ep->start_time = 0;
	ep->num_starts = 0;
	ep->num_completes = 0;
	ep->actual_period = 0;
	ep->next_ep = 0;
	ep->saved_period = 0;
	ep->promoted_this_time = 0;
	ep->id = 0;  // not needed for real budgeter
}

void
init_hc(PHC myHC)
{
	int i,j;
	PEndpoint ep;

	// allocate at TT to test with
	//myHC.tthead = (PTT) malloc(sizeof(TT));
	myHC->thinktime = HS_HC_THINK_TIME;
	myHC->allocation_limit = HS_MAX_PERIODIC_ALLOCATION;
	myHC->speed = HSSPEED;

	for (i=0; i<MAXFRAMES; i++)
	{

		for (j=0; j < MICROFRAMES_PER_FRAME; j++)
		{
			myHC->HS_microframe_info[i][j].time_used = 0;
		}

	}
}


void
init_tt(PHC myHC, PTT myTT)
{
	int i,j;
	PEndpoint ep;

	myTT->think_time = 1;
	myTT->myHC = myHC;
	myTT->allocation_limit = FS_MAX_PERIODIC_ALLOCATION;

	for (i=0; i<MAXFRAMES; i++)
	{

		myTT->frame_budget[i].time_used = FS_SOF + HUB_FS_ADJ;
		myTT->frame_budget[i].allocated_large = 0;

		for (j=0; j < MICROFRAMES_PER_FRAME; j++)
		{
			myTT->HS_split_data_time[i][j] = 0;
			myTT->num_starts[i][j] = 0;
		}
		
		ep = &myTT->isoch_head[i];
		myTT->frame_budget[i].isoch_ehead = ep; 

		//  SOF at the beginning of each frame
		Set_endpoint(ep, isoch, OUTDIR, FSSPEED, MAXFRAMES, 0, myTT);
		ep->calc_bus_time = FS_SOF + HUB_FS_ADJ;
		ep->actual_period = MAXFRAMES;
		ep->start_microframe = -1;
		ep->start_frame = i;
		
		ep = &myTT->int_head[i];
		myTT->frame_budget[i].int_ehead = ep;

		// dummy SOF at the beginning of each int frame budget list
		Set_endpoint(ep, interrupt, OUTDIR, FSSPEED, MAXFRAMES, 0, myTT);
		ep->calc_bus_time = FS_SOF + HUB_FS_ADJ;
		ep->actual_period = MAXFRAMES;
		ep->start_microframe = -1;
		ep->start_frame = i;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\sched.h ===
// scheduling algorithm for split periodic 

#ifndef   __SCHED_H__
#define   __SCHED_H__

#define MAXCEPS 30

// all times are in units of bytes
#define	FS_BYTES_PER_MICROFRAME 188
#define MICROFRAMES_PER_FRAME	8
#define FS_SOF 6  // number of byte times allocated to an SOF packet at the beginning of a frame
//#define	MAXFRAMES	8	// scheduling window for budget tracking, periods longer than
#define	MAXFRAMES	32	// scheduling window for budget tracking, periods longer than
				// this are reduced to this.  Also impacts space required for
				// tracking data structures.  Otherwise fairly arbitrary.

#define	MAXMICROFRAMES	(MAXFRAMES * 8)	

// 4 byte sync, 4 byte split token, 1 byte EOP, 11 byte ipg, plus
// 4 byte sync, 3 byte regular token, 1 byte EOP, 11 byte ipg
#define HS_SPLIT_SAME_OVERHEAD 39
// 4 byte sync, 4 byte split token, 1 byte EOP, 11 byte ipg, plus
// 4 byte sync, 3 byte regular token, 1 byte EOP, 1 byte bus turn
#define HS_SPLIT_TURN_OVERHEAD 29
// 4 byte sync, 1 byte PID, 2 bytes CRC16, 1 byte EOP, 11 byte ipg
#define HS_DATA_SAME_OVERHEAD 19
// 4 byte sync, 1 byte PID, 2 bytes CRC16, 1 byte EOP, 1 byte bus turn
#define HS_DATA_TURN_OVERHEAD 9
// 4 byte sync, 1 byte PID, 1 byte EOP, 1 byte bus turn
#define HS_HANDSHAKE_OVERHEAD 7
//#define HS_MAX_PERIODIC_ALLOCATION	6000	// floor(0.8*7500)
#define HS_MAX_PERIODIC_ALLOCATION	7000	// floor(0.8*7500)

// This could actually be a variable based on an HC implementation
// some measurements have shown 3?us between transactions or about 3% of a microframe
// which is about 200+ byte times.  We'll use about half that for budgeting purposes.
#define HS_HC_THINK_TIME 100

// 4 byte sync, 3 byte regular token, 1 byte EOP, 11 byte ipg
#define HS_TOKEN_SAME_OVERHEAD 19
// 4 byte sync, 3 byte regular token, 1 byte EOP, 1 byte bus turn
#define HS_TOKEN_TURN_OVERHEAD 9

// TOKEN: 1 byte sync, 3 byte token, 3 bit EOP, 1 byte ipg
// DATA: 1 byte sync, 1 byte PID, 2 bytes CRC16, 3 bit EOP, 1 byte ipg
// HANDSHAKE: 1 byte sync, 1 byte PID, 3 bit EOP, 1 byte ipg
#define	FS_ISOCH_OVERHEAD 9
#define FS_INT_OVERHEAD 13
//#define LS_INT_OVERHEAD (19*8)
#define LS_INT_OVERHEAD ((14 *8) + 5)
#define HUB_FS_ADJ 30 // periodic allocation at beginning of frame for use by hubs, maximum allowable is 60 bytes
#define FS_MAX_PERIODIC_ALLOCATION	(1157)	// floor(0.9*1500/1.16)
#define FS_BS_MAX_PERIODIC_ALLOCATION 1350 // floor(0.9*1500), includes bitstuffing allowance (for HC classic allocation)

// byte time to qualify as a large FS isoch transaction
//   673 = 1023/1.16 (i.e. 881) - 1microframe (188) - adj (30) or
//   1/2 of max allocation in this case 
// #define LARGEXACT (881-FS_BYTES_PER_MICROFRAME)
#define LARGEXACT (579)

typedef struct _Endpoint *PEndpoint;

typedef struct _frame_rec
{
	unsigned  time_used:16;		// The number of bytes that are budgeted for all endpoints in this frame
	PEndpoint allocated_large;	// endpoint if xact over LARGEXACT bytes is allocated in this frame
	PEndpoint isoch_ehead;		// many frames can point to the same endpoint. endpoints are linked
	PEndpoint int_ehead;		// in longest to shortest period.
		//
		// NOTE: always start with a "dummy" endpoint for SOF on the lists to avoid empty list corner condition
		//
} frame_rec;

typedef struct _HC *PHC;
typedef struct _TT *PTT;

typedef enum {bulk, control, interrupt, isoch} eptype;

#define	HSSPEED 2
#define FSSPEED 1
#define LSSPEED 0
#define INDIR 0
#define OUTDIR 1
typedef struct _Endpoint
{
	unsigned	type;

	// These fields have static information that is valid/constant as long as an
	// endpoint is configured
	unsigned 	max_packet:16;	// maximum number of data bytes allowed for this
                        		// endpoint. 0-8 for LS_int, 0-64 for FS_int,
                        		// 0-1023 for FS_isoch.
	unsigned 	period:16;       // desired period of transactions, assumed to be a power of 2
	eptype		ep_type:4;
	unsigned	direction:1;
	unsigned	speed:2;
	unsigned	moved_this_req:1;	// 1 when this endpoint has been changed during this allocation request
	PTT			mytt;			// the TT that roots this classic device.

	// These fields hold dynamically calculated information that changes as (other)
	// endpoints are added/removed.

	unsigned calc_bus_time:16;	// bytes of FS/LS bus time this endpoint requires
                        		// including overhead. This can be calculated once.

	unsigned start_time:16;		// classic bus time at which this endpoint is budgeted to occupy the classic bus

	unsigned actual_period:16;	// requested period can be modified:
								// 1. when period is greater than scheduling window (MAXFRAMES)
								// 2. if period is reduced (not currently done by algorithm)

	unsigned start_frame:8;		// first bus frame that is allocated to this endpoint.
	int	start_microframe:8;		// first bus microframe (in a frame) that can have a
                        		// start-split for this ep.
                        		// Complete-splits always start 2 microframes after a
                        		// start-split.
	unsigned num_starts:4;		// the number of start splits.
	unsigned num_completes:4;	// the number of complete splits.
	/* The numbers above could be (better?) represented as bitmasks. */

	/* corner conditions above: coder beware!!
	   patterns can have the last CS in the "next" frame
	     This is indicated in this design when:
		(start_microframe + num_completes + 1) > 7
	   patterns can have the first SS in the previous frame
             This is indicated in this design when:
                start_microframe = -1
	*/

	PEndpoint next_ep;			// pointer to next (faster/equal period) endpoint in budget

	int	id:16;						// not needed for real budgeter
	unsigned saved_period:16;	// used during period promotion to hold original period
	unsigned promoted_this_time:1;

} Endpoint;

typedef	struct _TT
{
	unsigned	HS_split_data_time[MAXFRAMES][MICROFRAMES_PER_FRAME]; // HS data bytes used for split completes
	// the above time tracks the data time for all devices rooted in this TT.
	// when the time is below 188 in a microframe, that time is allocated in the
	// HS microframe (in the HS HC budget).  When the time is greater than 188
	// only 188 byte times (bit stuffed) is allocated on the HS microframe budget.

	unsigned	num_starts[MAXFRAMES][MICROFRAMES_PER_FRAME];

	frame_rec frame_budget[MAXFRAMES];

	PHC	myHC;

	unsigned	think_time;	// TT reports it inter transaction "think" time.  Keep it here.
	unsigned	allocation_limit;	// maximum allocation allowed for this TT's classic bus

	struct _Endpoint isoch_head[MAXFRAMES];
	struct _Endpoint int_head[MAXFRAMES];
} TT;

typedef struct _microframe_rec
{
	unsigned	time_used;
	
} microframe_rec;

typedef struct _HC
{
	microframe_rec HS_microframe_info[MAXFRAMES][MICROFRAMES_PER_FRAME];	// HS bus time allocated to
								//this host controller
	PTT tthead;					// head of list of TTs attached to this HC
	unsigned thinktime;
	unsigned allocation_limit;	// maximum allocation allowed for this HC
	int	speed;					// HS or FS

} HC;

#if 0
typedef struct _command {
    char cmd_code;
    int  endpoint_number;
} Cmd_t;
#endif


/* protoypes */
void init_hc(PHC myHC);

Set_endpoint(
    PEndpoint	ep,
    eptype		t,
    unsigned	d,
    unsigned	s,
	unsigned	p,
	unsigned	m,
	TT			*thistt
	);

int Allocate_time_for_endpoint(
	PEndpoint ep,					
	PEndpoint changed_ep_list[],	
									
	int	*max_changed_eps			
									
	);

void
init_tt(PHC myHC, PTT myTT);	

void
Deallocate_time_for_endpoint(
	PEndpoint ep,					// endpoint that needs to be removed (bus time deallocated)
	PEndpoint changed_ep_list[],	// pointer to array to set (on return) with list of
									// changed endpoints
	int	*max_changed_eps			// input: maximum size of (returned) list
									// on return: number of changed endpoints
	);

#endif //   __SCHED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\usb2lib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usb2lib.h

Abstract:

    interface to the usb2 library
    
Environment:

    Kernel & user mode

Revision History:

    10-31-00 : created

--*/

#ifndef   __USB2LIB_H__
#define   __USB2LIB_H__

#define PUSB2LIB_HC_CONTEXT PVOID
#define PUSB2LIB_ENDPOINT_CONTEXT PVOID
#define PUSB2LIB_TT_CONTEXT PVOID

#define Budget_Iso          0
#define Budget_Interrupt    1        

#define Budget_In           0
#define Budget_Out          1

#define Budget_LowSpeed     0
#define Budget_FullSpeed    1
#define Budget_HighSpeed    2

#define SIG_LIB_HC              'chbl'  //lbhc
#define SIG_LIB_TT              'ttbl'  //lbtt
#define SIG_LIB_EP              'pebl'  //lbep    

typedef struct _REBALANCE_LIST {

    PVOID RebalanceContext[0];

} REBALANCE_LIST, *PREBALANCE_LIST;


typedef struct _USB2LIB_BUDGET_PARAMETERS {

    /* input */

    UCHAR TransferType;     // Budget_Iso
    UCHAR Speed;            // Budget_Interrupt
    UCHAR Direction;        // Budget_FullSpeed, Budget_HighSpeed, Budget_LowSpeed
    UCHAR Pad1;             // Round out to dword
    
    ULONG MaxPacket;        // MaxPacketSize

    /* input, output */
    
    // period is specified in frames for FS, LS
    // or microframes for HS, period is set to 
    // the actual period assigned (may be less
    // than requested)
    ULONG Period;

} USB2LIB_BUDGET_PARAMETERS, *PUSB2LIB_BUDGET_PARAMETERS;


#define USBP2LIBFN __stdcall

/* 
    client entry points
*/        

/* 
VOID
USB2LIB_DbgPrint(
    PCH Format,
    PVOID Arg0,
    PVOID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4,
    PVOID Arg5
    );

*/

typedef VOID
    (USBP2LIBFN *PUSB2LIB_DBGPRINT) (
        PCHAR,
        int, 
        int,
        int,
        int,
        int,
        int
    );

/* 
VOID
USB2LIB_DbgBreak(
    );

*/

typedef VOID
    (USBP2LIBFN *PUSB2LIB_DBGBREAK) (
    );    



/* LIB interface functions */

VOID
USB2LIB_InitializeLib(
    PULONG HcContextSize,
    PULONG EndpointContextSize,
    PULONG TtContextSize,
    PUSB2LIB_DBGPRINT Usb2LibDbgPrint,
    PUSB2LIB_DBGBREAK Usb2LibDbgBreak
    );

VOID
USB2LIB_InitController(
    PUSB2LIB_HC_CONTEXT HcContext
    );    

VOID
USB2LIB_InitTt(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext
    );    

BOOLEAN
USB2LIB_AllocUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,				// Host Controller Context
    PUSB2LIB_TT_CONTEXT TtContext,				// Transaction Translater Context
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,	// Endpoint Context
    PUSB2LIB_BUDGET_PARAMETERS BudgetParameters,	// Budget Parameters
    PVOID RebalanceContext,						// Driver Endpoint Context
    PVOID RebalanceList,						// List of endpoints to be rebalanced
    PULONG  RebalanceListEntries				// Number of endpoints to be rebalanced
    );    

VOID
USB2LIB_FreeUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    );    

UCHAR
USB2LIB_GetSMASK(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetCMASK(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetStartMicroFrame(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetStartFrame(PUSB2LIB_ENDPOINT_CONTEXT Context);

UCHAR
USB2LIB_GetPromotedThisTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

UCHAR
USB2LIB_GetNewPeriod(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

ULONG
USB2LIB_GetScheduleOffset(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

ULONG
USB2LIB_GetAllocedBusTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

PVOID
USB2LIB_GetNextEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

// Debug only
PVOID
USB2LIB_GetEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext);

#undef PUSB2LIB_HC_CONTEXT 
#undef PUSB2LIB_ENDPOINT_CONTEXT 
#undef PUSB2LIB_TT_CONTEXT 

#endif /* __USB2LIB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usb2lib\usb2lib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    usb2lib.c

Abstract:

    interface to usb2lib, usb2 low/full speed scheduling algorithms

Environment:

    kernel or user mode only

Notes:

Revision History:

    10-31-00 : created

--*/

#include "common.h"

USB2LIB_DATA LibData;


VOID
USB2LIB_InitializeLib(
    PULONG HcContextSize,
    PULONG EndpointContextSize,
    PULONG TtContextSize,
    PUSB2LIB_DBGPRINT Usb2LibDbgPrint,
    PUSB2LIB_DBGBREAK Usb2LibDbgBreak
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    *HcContextSize = sizeof(USB2LIB_HC_CONTEXT);
    *TtContextSize = sizeof(USB2LIB_TT_CONTEXT);
    *EndpointContextSize = sizeof(USB2LIB_ENDPOINT_CONTEXT);

    LibData.DbgPrint = Usb2LibDbgPrint;
    LibData.DbgBreak = Usb2LibDbgBreak;
}


VOID
USB2LIB_InitController(
    PUSB2LIB_HC_CONTEXT HcContext
    )
/*++

Routine Description:

    Called at init time for an instance of the USB 2
    controller

Arguments:

Return Value:

--*/
{
    DBGPRINT(("USB2LIB_InitController %x\n", HcContext));

    HcContext->Sig = SIG_LIB_HC;
    init_hc(&HcContext->Hc);
    init_tt(&HcContext->Hc, &HcContext->DummyTt);  // set up dummy TT for use by HS endpoints
}


VOID
USB2LIB_InitTt(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    DBGPRINT(("USB2LIB_InitTt %x %x\n", HcContext, TtContext));

    TtContext->Sig = SIG_LIB_TT;
    init_tt(&HcContext->Hc, &TtContext->Tt);
}


#if  1
void Shift_to_list_end(
	int			move_ep,
	PEndpoint	RebalanceList[]
	)
{
//	int i;
	PEndpoint ep = RebalanceList[move_ep];

	move_ep++;
	while (RebalanceList[move_ep])
	{
		RebalanceList[move_ep-1] = RebalanceList[move_ep];
		move_ep++;
	}
	RebalanceList[move_ep-1] = ep;
}
#endif




BOOLEAN
Promote_endpoint_periods(
	PEndpoint	ep,
    PEndpoint	RebalanceList[],
    PULONG		RebalanceListEntries
	)
{
	int unwind = 0, check_ep;
	unsigned result;

	if ((ep->actual_period != 1) && (ep->ep_type == interrupt) && (ep->start_microframe > 2))
	{
    	DBGPRINT((">Period Promotion of allocated endpoint\n"));

	// To promote an endpoint period:
	// 0) unwind = false
	// 1) deallocate original endpoint
	// 2) change new ep period to 1
	// 3) (re)allocate new endpoint (with new period 1)
	// 4) if successful
	// 5)	check endpoints in change list for need of period promotion
	// 6)		deallocate endpoint, move to end of change list, change period to 1, reallocate
	// 7)		if unsuccessful
	// 8)			unwind = true; break
	// 9)		next ep
	//10)	if unwind
	//11)		deallocate orginal ep
	//12)		check change list for promotion endpoint(s)
	//13)			if promoted ep
	//14)				deallocate ep, change back to original period, allocate
	//15)			next ep
	//16)		return false
	//17)	else return true
	//18) else return false

	/*
	//  On return, change list will have promoted endpoints in order of reallocation, but it is possible
	//	to have other endpoints interspersed with the promoted endpoints.  The corresponding schedule of endpoints
	//	must be adjusted to match the order of the promoted endpoints (since they are reinserted into the budget).
	//	The promoted endpoints (except the original endpoint) are moved to the end of the change list as the
	//	promotion reallocations are done to ensure that they are in the change list in the order of insertion
	//	into the budget.  This allows the scheduler to derive the new schedule/budget order from the order the
	//	promoted endpoints appear in the change list.
	//
	//	This algorithm (critically) depends on the Allocate/Deallocate "appending"/reusing an existing change list
	//	as the "final" change list is composed during the period promotion processing is performed.
	*/

	    Deallocate_time_for_endpoint(ep,
	                                 RebalanceList,
	                                 RebalanceListEntries);

		ep->saved_period = ep->period;
		ep->period = 1;

		// 3) (re)allocate new endpoint (with new period 1)
	    result = Allocate_time_for_endpoint(ep,
	                                        RebalanceList,
	                                        RebalanceListEntries);
		if (!result) {
			ep->period = ep->saved_period;
			ep->saved_period = 0;
			ep->promoted_this_time = 0;
			return 0;  // failed period promotion of original endpoint
		}
	}

	check_ep = 0;
	while (RebalanceList[check_ep])
	{
		RebalanceList[check_ep]->promoted_this_time = 0;
		check_ep++;
	}

	check_ep = 0;
	while (RebalanceList[check_ep])
	{
		if ((RebalanceList[check_ep]->actual_period != 1) &&
			(RebalanceList[check_ep]->ep_type == interrupt) &&
			(RebalanceList[check_ep]->start_microframe > 2))
		{

	// 6)		deallocate endpoint, move to end of change list, change period to 1, reallocate

    		DBGPRINT((">Period Promoting endpoint\n"));

			Deallocate_time_for_endpoint(
				RebalanceList[check_ep],
                RebalanceList,
                RebalanceListEntries);

			// Shift_to_list_end(check_ep, RebalanceList);

			RebalanceList[check_ep]->promoted_this_time = 1;

			RebalanceList[check_ep]->saved_period = RebalanceList[check_ep]->period;
			RebalanceList[check_ep]->period = 1;

			result = Allocate_time_for_endpoint(
					RebalanceList[check_ep],
                    RebalanceList,
                    RebalanceListEntries);
			if (!result)
			{
				unwind = 1;
				break;
			}
		}
		check_ep++;
	}

	if (unwind)
	{

    	DBGPRINT((">Unwinding Promoted endpoints\n"));

	//11)		deallocate orginal ep
		Deallocate_time_for_endpoint(
			ep,
	        RebalanceList,
               RebalanceListEntries);

		ep->period = ep->saved_period;
		ep->saved_period = 0;

	//12)		check change list for promotion endpoint(s)

		check_ep = 0;

		while (RebalanceList[check_ep])
		{

	//13)			if promoted ep

			if (RebalanceList[check_ep]->promoted_this_time)
			{

	//14)				deallocate ep, change back to original period, allocate

    	DBGPRINT((">Reallocating Unpromoted endpoint\n"));

				if(RebalanceList[check_ep]->calc_bus_time != 0)
					Deallocate_time_for_endpoint(
						RebalanceList[check_ep],
						RebalanceList,
						RebalanceListEntries);

				RebalanceList[check_ep]->period = RebalanceList[check_ep]->saved_period;
				RebalanceList[check_ep]->saved_period = 0;

				// Leave the promoted flag set since order could have changed.
				// schedule must be reconciled accordingly by the HC code.
				//RebalanceList[check_ep]->promoted_this_time = 0;

				result = Allocate_time_for_endpoint(
					RebalanceList[check_ep],
					RebalanceList,
					RebalanceListEntries);
			}
			check_ep++;
		}

		return 0;
	} else {
		return 1;
	}

}



BOOLEAN
USB2LIB_AllocUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PUSB2LIB_BUDGET_PARAMETERS Budget,
    PVOID RebalanceContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    eptype endpointType;
    unsigned direction, speed;
    //PEndpoint changed_ep_list[];
    unsigned result;
    //unsigned changed_eps;
    PEndpoint ep;
    BOOLEAN alloced;
    ULONG ilop;
    PREBALANCE_LIST rbl;
    PTT tt;

    ep = &EndpointContext->Ep;
    EndpointContext->Sig = SIG_LIB_EP;
    EndpointContext->RebalanceContext = RebalanceContext;

    //changed_ep_list = RebalanceList;

    switch (Budget->TransferType) {
    case Budget_Iso:
        DBGPRINT((">Iso \n"));
        endpointType = isoch;
        break;
    case Budget_Interrupt:
        DBGPRINT((">Interrupt \n"));
        endpointType = interrupt;
        break;
    default:
        TEST_TRAP();
    }

    if (Budget->Direction == Budget_In) {
        DBGPRINT((">In \n"));
        direction = INDIR;
    } else {
        DBGPRINT((">Out \n"));
        direction = OUTDIR;
    }

    switch (Budget->Speed) {
    case Budget_FullSpeed:
        DBGPRINT((">FullSpeed \n"));
        speed = FSSPEED;
        tt = &TtContext->Tt;
        break;
    case Budget_HighSpeed:
        DBGPRINT((">HighSpeed \n"));
        speed = HSSPEED;
        tt = &HcContext->DummyTt;	// set endpoint to dummy TT so HC can be reached
        break;
    case Budget_LowSpeed:
        DBGPRINT((">LowSpeed \n"));
        speed = LSSPEED;
        tt = &TtContext->Tt;
        break;
    default:
    	DBGPRINT(("BAD SPEED\n"));
    }

    DBGPRINT((">Period %d\n", Budget->Period));

	if(Budget->Speed == Budget_HighSpeed) {
		// This value should be a power of 2, so we don't have to check
		// but limit its value to MAXFRAMES * 8
		if(Budget->Period > MAXMICROFRAMES) {
			Budget->Period = MAXMICROFRAMES;
		}
	} else {
		// We are full / low speed endpoint
		//
		// Round down the period to the nearest power of two (if it isn't already)
		//
		for(ilop = MAXFRAMES; ilop >= 1; ilop = ilop >> 1) {
			if(Budget->Period >= ilop) {
				break;
			}
		}
		Budget->Period = ilop;
	}

    DBGPRINT((">MaxPacket %d\n", Budget->MaxPacket));
    DBGPRINT((">Converted Period %d\n", Budget->Period));
    DBGPRINT((">RebalanceListEntries %d\n", *RebalanceListEntries));

    Set_endpoint(
        ep,
        endpointType,
        direction,
        speed,
        Budget->Period,
        Budget->MaxPacket,
        tt);

    // ask John Garney to do the math
    DBGPRINT((">alloc (ep) %x \n", ep));
    result = Allocate_time_for_endpoint(ep,
                                        RebalanceList,
                                        RebalanceListEntries);

	// check if successful, period != 1, interrupt, and "late" in frame,
	//   then need to promote period to 1
   	// DBGPRINT((">Executing Promote_endpoint_periods (ep) %x \n", ep));
	if (result)
	{
		result = Promote_endpoint_periods(ep,
	                                      RebalanceList,
										  RebalanceListEntries);
	}

    // nonzero indicates success
    if (result) {
        // set return parameters
        DBGPRINT((">Results\n"));
        DBGPRINT((">num_starts %d \n", ep->num_starts));
        DBGPRINT((">num_completes %d \n", ep->num_completes));
        DBGPRINT((">start_microframe %d \n", ep->start_microframe));
        // this is the schedule offset
        DBGPRINT((">start_frame %d \n", ep->start_frame));
        // period awarded, may be less than requested
        DBGPRINT((">actual_period %d \n", ep->actual_period));
        DBGPRINT((">start_time %d \n", ep->start_time));
        DBGPRINT((">calc_bus_time %d \n", ep->calc_bus_time));
        DBGPRINT((">promoted_this_time %d \n", ep->promoted_this_time));

        alloced = TRUE;
    } else {
        alloced = FALSE;
    }

    // fix up rebalance list
    rbl = RebalanceList;
	ilop = 0;
    while (rbl->RebalanceContext[ilop]) {
        PUSB2LIB_ENDPOINT_CONTEXT endpointContext;
        PEndpoint rep;

        DBGPRINT((">rb[%d] %x\n", ilop, rbl->RebalanceContext[ilop]));
        endpointContext = CONTAINING_RECORD(rbl->RebalanceContext[ilop],
                                            struct _USB2LIB_ENDPOINT_CONTEXT,
                                            Ep);

        rep = &endpointContext->Ep;

        DBGPRINT((">rb Results\n"));
        DBGPRINT((">rb num_starts %d \n", rep->num_starts));
        DBGPRINT((">rb num_completes %d \n", rep->num_completes));
        DBGPRINT((">rb start_microframe %d \n", rep->start_microframe));
        // this is the schedule offset
        DBGPRINT((">rb start_frame %d \n", rep->start_frame));
        // period awarded, may be less than requested
        DBGPRINT((">rb actual_period %d \n", rep->actual_period));
        DBGPRINT((">rb start_time %d \n", rep->start_time));
        DBGPRINT((">rb calc_bus_time %d \n", rep->calc_bus_time));
        DBGPRINT((">rb promoted_this_time %d \n", rep->promoted_this_time));

        rbl->RebalanceContext[ilop] = endpointContext->RebalanceContext;
		ilop++;
    }

    DBGPRINT((">Change List Size =  %d RBE = %d\n", ilop, *RebalanceListEntries));

    *RebalanceListEntries = ilop;
    return alloced;
}


VOID
USB2LIB_FreeUsb2BusTime(
    PUSB2LIB_HC_CONTEXT HcContext,
    PUSB2LIB_TT_CONTEXT TtContext,
    PUSB2LIB_ENDPOINT_CONTEXT EndpointContext,
    PVOID RebalanceList,
    PULONG  RebalanceListEntries
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    unsigned result;
    PEndpoint ep;
    PREBALANCE_LIST rbl;
    ULONG i;

//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);
    ep = &EndpointContext->Ep;

    DBGPRINT((">dealloc ep Context = 0x%x (ep) %x \n", EndpointContext, ep));
    DBGPRINT((">RebalanceListEntries  %d \n", *RebalanceListEntries));

    Deallocate_time_for_endpoint(ep,
                                 RebalanceList,
                                 RebalanceListEntries);

    // fix up rebalance list
    rbl = RebalanceList;
	i = 0;
    while (rbl->RebalanceContext[i]) {
        PUSB2LIB_ENDPOINT_CONTEXT endpointContext;

        DBGPRINT((">rb[%d] %x\n", i, rbl->RebalanceContext[i]));
        endpointContext = CONTAINING_RECORD(rbl->RebalanceContext[i],
                                            struct _USB2LIB_ENDPOINT_CONTEXT,
                                            Ep);
        rbl->RebalanceContext[i] = endpointContext->RebalanceContext;
		i++;
    }
    DBGPRINT((">Change List Size =  %d RBE = %d\n", i, *RebalanceListEntries));

    *RebalanceListEntries = i;
}

VOID
ConvertBtoHFrame(UCHAR BFrame, UCHAR BUFrame, PUCHAR HFrame, PUCHAR HUFrame)
{
	// The budgeter returns funky values that we have to convert to something
	// that the host controller understands.
	// If bus micro frame is -1, that means that the start split is scheduled
	// in the last microframe of the previous bus frame.
	// to convert to hframes, you simply change the microframe to 0 and
	// keep the bus frame (see one of the tables in the host controller spec
	// eg 4-17.
	if(BUFrame == 0xFF) {
		*HUFrame = 0;
		*HFrame = BFrame;
	}

	// if the budgeter returns a value in the range from 0-6
	// we simply add one to the bus micro frame to get the host
	// microframe
	if(BUFrame >= 0 && BUFrame <= 6) {
		*HUFrame = BUFrame + 1;
		*HFrame = BFrame;
	}

	// if the budgeter returns a value of 7 for the bframe
	// then the HUframe = 0 and the HUframe = buframe +1
	if(BUFrame == 7) {
		*HUFrame = 0;
		*HFrame = BFrame + 1;
	}
}

UCHAR
USB2LIB_GetSMASK(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint 	Ep;
	UCHAR 		tmp = 0;

    Ep = &EndpointContext->Ep;
  //  ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	if(Ep->speed == HSSPEED) {
//DBGPRINT(("in GetSMASK StartUFrame on High Speed Endpoint = 0x%x\n", Ep->start_microframe));
	 	tmp |= 1 << Ep->start_microframe;
	} else {
		ULONG 		ilop;
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint
		// For Full and Low Speed Endpoints
		// the budgeter returns a bframe. Convert to HUFrame to get SMASK
		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe, &HFrame, &HUFrame);

		for(ilop = 0; ilop < Ep->num_starts; ilop++) {
		 	tmp |= 1 << HUFrame++;
		}
	}

	return tmp;
}

//
// I'm too brain dead to calculate this so just do table lookup
//
// Calculated by 1 << Start H Frame + 2. If Start H Frame + 2 > 7 wrap the bits
// to the lower part of the word
// eg. hframe 0 +2 means cmask in frames 2,3,4 ==> cmask 0x1c
// eg. hframe 5 + 2 means cmasks in frames 7, 8, 9 which means cmask 0x83
#define SIZE_OF_CMASK 8
static UCHAR CMASKS [SIZE_OF_CMASK] =
{		0x1c, 		// Start HUFRAME 0
		0x38,		// Start HUFRAME 1
		0x70,		// Start HUFRAME 2
		0xE0,		// Start HUFRAME 3
		0xC1,		// Start HUFRAME 4
		0x83,		// Start HUFRAME 5
		0x07,		// Start HUFRAME 6
		0x0E,		// Start HUFRAME 7
};


UCHAR
USB2LIB_GetCMASK(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint Ep;

   	Ep = &EndpointContext->Ep;
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	if(Ep->speed == HSSPEED) {
		return 0;
	} else if(Ep->ep_type == interrupt) {
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint

		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe,
			&HFrame, &HUFrame);

		return CMASKS[HUFrame];
	} else {
		// Split ISO!
		UCHAR 		HFrame; 		// H (Host) frame for endpoint
		UCHAR 		HUFrame;		// H (Host) micro frame for endpoint
		UCHAR 		tmp = 0;
		ULONG 		NumCompletes;

		if(Ep->direction == OUTDIR) {
			// Split iso out -- NO complete splits
			return 0;
		}
		ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe,
			&HFrame, &HUFrame);

		HUFrame += 2;
		NumCompletes = Ep->num_completes;

//		ASSERT(NumCompletes > 0);

		//
		//  Set all CMASKS bits to be set at the end of the frame
		//
		for(;  HUFrame < 8; HUFrame++) {
			tmp |= 1 <<  HUFrame;
			NumCompletes--;
			if(!NumCompletes){
				break;
			}
		}

		//
		// Now set all CMASKS bits to be set at the end of the
		// frame I.E. for the next frame wrap condition
		//
		while(NumCompletes) {
			tmp |= 1 << (HUFrame - 8);
			NumCompletes--;
		}

//DBGPRINT(("in GetCMASK HFRAME = 0x%x HUFRAME 0x%x\n", HFrame, HUFrame));
		return tmp;
	}
}

UCHAR
USB2LIB_GetStartMicroFrame(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint 	Ep;
	UCHAR 		HFrame; 		// H (Host) frame for endpoint
	UCHAR 		HUFrame;		// H (Host) micro frame for endpoint

    Ep = &EndpointContext->Ep;
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	ConvertBtoHFrame((UCHAR)Ep->start_frame, (UCHAR)Ep->start_microframe,
		&HFrame, &HUFrame);

	return HUFrame;
}

UCHAR
USB2LIB_GetPromotedThisTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	PEndpoint Ep;
	UCHAR Promoted = 0;

    Ep = &EndpointContext->Ep;
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

	Promoted = (UCHAR) Ep->promoted_this_time;

	Ep->promoted_this_time = 0;

	return Promoted;
}

UCHAR
USB2LIB_GetNewPeriod(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep;
//    ASSERT(EndpointContext->Sig == SIG_LIB_EP);

    return (UCHAR) Ep->actual_period;
}


ULONG
USB2LIB_GetScheduleOffset(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep;
//    assert(EndpointContext->Sig == SIG_LIB_EP);

    return Ep->start_frame;
}

PVOID
USB2LIB_GetEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
	return &(EndpointContext->Ep);
}



ULONG
USB2LIB_GetAllocedBusTime(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep;

    Ep = &EndpointContext->Ep;
//    assert(EndpointContext->Sig == SIG_LIB_EP);

    return Ep->calc_bus_time;
}


PVOID
USB2LIB_GetNextEndpoint(PUSB2LIB_ENDPOINT_CONTEXT EndpointContext)
{
    PEndpoint Ep, nextEp;
    PUSB2LIB_ENDPOINT_CONTEXT nextContext;

    Ep = &EndpointContext->Ep;
    nextEp = Ep->next_ep;

    if (nextEp) {

        nextContext = CONTAINING_RECORD(nextEp,
                                        struct _USB2LIB_ENDPOINT_CONTEXT,
                                        Ep);
//    assert(EndpointContext->Sig == SIG_LIB_EP);
        return nextContext->RebalanceContext;
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\cancel.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    core.c

Abstract:

    We maintain two lists for Transfer Irps

    (1)
    PendingTransferIrps - transfers on the endpoint pending List
    protected by PendingIrpLock

    (2)
    ActiveTransferIrps  - transfers on the enpoint ACTIVE, CANCEL list 
                            or on the MapTransfer List
    protected by ActiveIrpLock                            

    each list has its own cancel and completion routine   

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_QueuePendingTransferIrp
// USBPORT_CancelPendingTransferIrp
// USBPORT_InsertIrpInTable
// USBPORT_RemoveIrpFromTable
// USBPORT_FindIrpInTable

VOID
USBPORT_InsertIrpInTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == NULL) {
                t->Irps[i] = Irp; 
                return;
            }
        }            
    } while (t->NextTable);

    // no room, grow the table and recurse

    ALLOC_POOL_Z(t->NextTable, NonPagedPool,
                 sizeof(USBPORT_IRP_TABLE));

    if (t->NextTable != NULL) {
        USBPORT_InsertIrpInTable(FdoDeviceObject, t->NextTable, Irp);
    } else {
        // we should handle this more gracefully
        // you can hit this in a low resource scenario
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0); 
    }
    
    return;
}   


PIRP
USBPORT_RemoveIrpFromTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == Irp) {
                t->Irps[i] = NULL; 
                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmIP', i, Irp, IrpTable);
                return Irp;
            }
        }            
    } while (t->NextTable);

    return NULL;
}   


PIRP
USBPORT_FindUrbInIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,    
    PUSBPORT_IRP_TABLE IrpTable,
    PTRANSFER_URB Urb,
    PIRP InputIrp
    )
/*++

Routine Description:

    Given and table urb we scan for it in the the irp table
    if we find it it means the client has submitted the same 
    urb twice.

    This function is used to validate client drivers, there is
    a small perf hit taken here but probably worth it.

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   
    PIRP tIrp = NULL;
    PTRANSFER_URB urb;
    PIO_STACK_LOCATION irpStack;

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fndU', t, Urb, 0);

    do {
        t = t->NextTable;
        for (i=0; i<IRP_TABLE_LENGTH; i++) {
            tIrp = t->Irps[i];
            if (tIrp != NULL) {           
                irpStack = IoGetCurrentIrpStackLocation(tIrp);
                urb = irpStack->Parameters.Others.Argument1;
                if (urb == Urb) {
                    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fkkX', tIrp, urb, InputIrp);
                    if (tIrp == InputIrp) {
                        // this is a double submit by the client driver, that 
                        // is the irp is still pending
                        BUGCHECK(USBBUGCODE_DOUBLE_SUBMIT, (ULONG_PTR) tIrp, 
                                (ULONG_PTR) urb, 0);
                    } else {
                        // this is the case where the URB is attached to 
                        // another irp
                        BUGCHECK(USBBUGCODE_BAD_URB, (ULONG_PTR) tIrp, (ULONG_PTR) InputIrp,
                                (ULONG_PTR) urb);
                    }     
                }
            }                    

        }            
    } while (t->NextTable);

    return tIrp;
}   


PIRP
USBPORT_FindIrpInTable(
    PDEVICE_OBJECT FdoDeviceObject,    
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG i;
    PUSBPORT_IRP_TABLE t = IrpTable;   

    USBPORT_ASSERT(IrpTable != NULL);

    t = (PUSBPORT_IRP_TABLE) &IrpTable; 

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fIPT', t, Irp, 0);

    do {
        t = t->NextTable;
        for (i = 0; i<IRP_TABLE_LENGTH; i++) {
            if (t->Irps[i] == Irp) {
                return Irp;
            }
        }            
    } while (t->NextTable);

    return NULL;
}   


VOID
USBPORT_QueuePendingTransferIrp(
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    KIRQL cancelIrql, irql;
    PDEVICE_OBJECT fdoDeviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION devExt;
    PTRANSFER_URB urb;

    // on entry the urb is not cancelable ie
    // no cancel routine
    
    // extract the urb;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    urb = irpStack->Parameters.Others.Argument1;

    ASSERT_TRANSFER_URB(urb);
    transfer = urb->pd.HcdTransferContext;
    endpoint = transfer->Endpoint;    

    fdoDeviceObject = endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'tIRP', transfer, endpoint, 0);
            
    USBPORT_ASSERT(Irp == transfer->Irp);
    USBPORT_ASSERT(Irp != NULL);
    
    Irp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(Irp);

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);

    IoSetCancelRoutine(Irp, USBPORT_CancelPendingTransferIrp);

    if (Irp->Cancel && 
        IoSetCancelRoutine(Irp, NULL)) {

        // irp was canceled and our cancel routine
        // did not run
        RELEASE_PENDING_IRP_LOCK(devExt, irql);                
        
        USBPORT_CompleteTransfer(urb,
                                 USBD_STATUS_CANCELED);
    } else {
    
        // cancel routine is set 
        USBPORT_InsertPendingTransferIrp(fdoDeviceObject, Irp);

        USBPORT_QueuePendingUrbToEndpoint(endpoint, urb);

        RELEASE_PENDING_IRP_LOCK(devExt, irql);
    }
        
}


VOID
USBPORT_CancelPendingTransferIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;
    
    // release cancel spinlock 
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'canP', fdoDeviceObject, CancelIrp, 0);

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);    

    irp = USBPORT_RemovePendingTransferIrp(fdoDeviceObject, CancelIrp);

    if (irp) {
        PTRANSFER_URB urb;
    
        // found it 
        irpStack = IoGetCurrentIrpStackLocation(CancelIrp);
        urb = irpStack->Parameters.Others.Argument1;

        ASSERT_TRANSFER_URB(urb);
        transfer = urb->pd.HcdTransferContext;
        endpoint = transfer->Endpoint;    
        
        USBPORT_ASSERT(fdoDeviceObject == endpoint->FdoDeviceObject);

        ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'Le10');
       
        // remove request from the endpoint,
        // it will be on the pending list
#if DBG
        USBPORT_ASSERT(
            USBPORT_FindUrbInList(urb, &endpoint->PendingList));
#endif
        RemoveEntryList(&transfer->TransferLink);
        transfer->TransferLink.Flink = NULL;
        transfer->TransferLink.Blink = NULL;

        RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'Ue10');
    }        


    RELEASE_PENDING_IRP_LOCK(devExt, irql);           

    // noone nows about this irp anymore
    // complete it with status canceled
    if (irp) {
        USBPORT_CompleteTransfer(transfer->Urb,
                                 USBD_STATUS_CANCELED);
    }
}                


VOID
USBPORT_CancelActiveTransferIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

    Cancels come in on the root hub Pdo

Arguments:

Return Value:

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'canA', fdoDeviceObject, CancelIrp, 0);

    // when we have the fdo we can release the global cancel lock
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);    

    irp = USBPORT_FindActiveTransferIrp(fdoDeviceObject, CancelIrp);

    // if irp is not on our list then we have already completed it.
    if (irp) {
        
        PTRANSFER_URB urb;

        USBPORT_ASSERT(irp == CancelIrp);
        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'CANA', fdoDeviceObject, irp, 0);
        // found it 
        // mark the transfer so it will be canceled the next 
        // time we process the endpoint.
        irpStack = IoGetCurrentIrpStackLocation(irp);
        urb = irpStack->Parameters.Others.Argument1;

        ASSERT_TRANSFER_URB(urb);
        transfer = urb->pd.HcdTransferContext;
        endpoint = transfer->Endpoint;    
        
        USBPORT_ASSERT(fdoDeviceObject == endpoint->FdoDeviceObject);

        ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'LeI0');

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT)) {
            KIRQL tIrql;
            PLIST_ENTRY listEntry;
            PHCD_TRANSFER_CONTEXT childTransfer;

            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED);

            ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);

            // mark all children as cancelled
            GET_HEAD_LIST(transfer->SplitTransferList, listEntry);

            while (listEntry &&
                   listEntry != &transfer->SplitTransferList) {
           
                childTransfer =  (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                                     listEntry,
                                     struct _HCD_TRANSFER_CONTEXT, 
                                     SplitLink);

                ASSERT_TRANSFER(childTransfer); 
            
                SET_FLAG(childTransfer->Flags, USBPORT_TXFLAG_CANCELED);

                listEntry = childTransfer->SplitLink.Flink; 
            }

            RELEASE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);

        } else {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED);
        }            
        RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'UeI0');        

        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
        // if we canceled a transfer then
        // this endpoint needs attention
        USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                   endpoint,
                                   IEP_SIGNAL_WORKER);
    } else {
    
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);  
        
    }        

}


PIRP
USBPORT_FindActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'fnAC', 0, Irp, 0);
    
    return USBPORT_FindIrpInTable(FdoDeviceObject,
                                  devExt->ActiveTransferIrpTable, 
                                  Irp);
}


PIRP
USBPORT_RemoveActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmAC', 0, Irp, 0);
    
    return USBPORT_RemoveIrpFromTable(FdoDeviceObject,
                                      devExt->ActiveTransferIrpTable, 
                                      Irp);
    
}


PIRP
USBPORT_RemovePendingTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'rmPN', 0, Irp, 0);
    
    return USBPORT_RemoveIrpFromTable(FdoDeviceObject,
                                      devExt->PendingTransferIrpTable, 
                                      Irp);
}


VOID
USBPORT_FreeIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE BaseIrpTable
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBPORT_IRP_TABLE tmp;
    
    while (BaseIrpTable != NULL) {
        tmp = BaseIrpTable->NextTable;
        FREE_POOL(FdoDeviceObject, BaseIrpTable);
        BaseIrpTable = tmp;
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\common.h ===
#ifndef   __COMMON_H__
#define   __COMMON_H__

#include "wdm.h"
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#endif
#include <initguid.h>
#include <wdmguid.h>

#include "..\USB2LIB\usb2lib.h"

#include "usb.h"
#include "usbhcdi.h"
#include "dbg.h"

// <begin> special debug defines
//#define ISO_LOG
//#define TRACK_IRPS
// <end> special debug defines

// include all bus interfaces
#include "usbbusif.h"
#include "hubbusif.h"

// inclulde ioctl defs for port drivers
#include "usbkern.h"
#include "usbuser.h"

// include iodefs for client drivers
#include "usbdrivr.h"

#include "usbport.h"
#include "prototyp.h"

#include "enumlog.h"


#endif //__COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\cmnbuf.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cmnbuf.c

Abstract:

    Code to manage common buffer -- hardware addressable memory

    a common buffer block looks like this

start    ------------ <- address returned from the hal
         padding
         ------------ <- address returned to the miniport
         mp data 
         ------------ <- ptr to header 
         header
end      ------------

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_HalAllocateCommonBuffer)
#endif

// non paged functions


PUSBPORT_COMMON_BUFFER
USBPORT_HalAllocateCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG NumberOfBytes
    )

/*++

Routine Description:

    Allocates common buffer directly from the hal. 
    The common buffer is passed to the miniport, we
    always allocate a multiple of PAGE_SIZE so the 
    always starts on a page_boundry. This ensures 
    proper alignement of the TDs used by the miniport
    

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    returns Virtual Address of common buffer or NULL if 
    unsuccessful.

--*/

{
    PDEVICE_EXTENSION devExt;
    PUSBPORT_COMMON_BUFFER header;
    PUCHAR virtualAddress, mpBuffer, baseVa;
    PHYSICAL_ADDRESS logicalAddress;
    ULONG headerLength;
    ULONG n, basePhys, mpBufferPhys, pageCount, extra;

    PAGED_CODE();

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'acm>', 0, 0, NumberOfBytes);
   
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // NULL initialize the return value in case the allocation fails
    //
    header = NULL;

    headerLength = sizeof(USBPORT_COMMON_BUFFER);

    // compute number min of pages we will need to satisfy 
    // the request
    
    n = NumberOfBytes+headerLength;
    pageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(0, n);
    
#if DBG   
    {
    ULONG pc;
    // compute number of pages we will need
    pc = n / PAGE_SIZE;
    if ((n % PAGE_SIZE)) {
        pc++;
    }
    USBPORT_ASSERT(pc == pageCount);
    }
#endif    
    
    extra = (pageCount*PAGE_SIZE)-n;
    n = (pageCount*PAGE_SIZE);
    
    USBPORT_KdPrint((1,"'ALLOC(%d) extra %d bytes\n", n, extra));

    virtualAddress = 
        HalAllocateCommonBuffer(devExt->Fdo.AdapterObject,
                                n, 
                                &logicalAddress,
                                TRUE);
#if DBG
    if (virtualAddress == NULL) {
        USBPORT_KdPrint((0,"'HalAllocateCommonBuffer failed\n"));  
        USBPORT_KdPrint((0,"'alloced bytes %d\n"));  
        DEBUG_BREAK();
    }
#endif    

    if (virtualAddress != NULL) {

        devExt->Fdo.StatCommonBufferBytes += n;
        
        basePhys = logicalAddress.LowPart & ~(PAGE_SIZE-1);
        baseVa = PAGE_ALIGN(virtualAddress);
        // hal should have given us a page aligned address since 
        // we asked for a multiple of PAGE_SIZE, 
        // i trust NT but not Win9x
        USBPORT_ASSERT(virtualAddress == baseVa);
        
        // client ptrs
        mpBuffer = baseVa;
        mpBufferPhys = basePhys;

        header = (PUSBPORT_COMMON_BUFFER) (mpBuffer+NumberOfBytes+extra);
        USBPORT_ASSERT(n == NumberOfBytes+extra+headerLength);
        // USB controllers only support 32 bit phys addresses
        // for control structures
        USBPORT_ASSERT(logicalAddress.HighPart == 0);
        
#if DBG
        RtlFillMemory(virtualAddress, n, 'x');
#endif        
        // init the header
        header->Sig = SIG_CMNBUF;
        header->Flags = 0;
        header->TotalLength = n; 
        header->LogicalAddress = logicalAddress;
        header->VirtualAddress = virtualAddress; 
        header->BaseVa = baseVa;
        header->BasePhys = basePhys;
        
        header->MiniportLength = NumberOfBytes+extra;
        header->MiniportVa = mpBuffer;
        header->MiniportPhys = mpBufferPhys;
        // zero the client part
        RtlZeroMemory(header->MiniportVa, header->MiniportLength);

    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'acm<', mpBuffer, mpBufferPhys, header);
   
    return header;
}


VOID
USBPORT_HalFreeCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_COMMON_BUFFER CommonBuffer
    )

/*++

Routine Description:

    Free a common buffer for the miniport

Arguments:

Return Value:

    returns Virtual Address of common buffer or NULL if 
    unsuccessful.

--*/

{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);    
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(CommonBuffer != NULL);
    ASSERT_COMMON_BUFFER(CommonBuffer);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'hFCB', 
            CommonBuffer, CommonBuffer->TotalLength, 
            CommonBuffer->MiniportVa);

    devExt->Fdo.StatCommonBufferBytes -= 
        CommonBuffer->TotalLength;
    
    HalFreeCommonBuffer(devExt->Fdo.AdapterObject,
                        CommonBuffer->TotalLength, 
                        CommonBuffer->LogicalAddress,
                        CommonBuffer->MiniportVa,
                        TRUE);
}


PUCHAR
USBPORTSVC_MapHwPhysicalToVirtual(
    HW_32BIT_PHYSICAL_ADDRESS HwPhysicalAddress,
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData    
    )

/*++

Routine Description:

    given a physical address return the corresponding
    virtual address.

Arguments:

    if the phys address is associated with an endpoint 
    the endpoint is passed in.

Return Value:

    Virtual Address, NULL if not found

--*/

{
    PDEVICE_EXTENSION devExt;
    PUCHAR virtualAddress;
    PHCD_ENDPOINT endpoint;
    ULONG offset;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mapP', HwPhysicalAddress, 0, 
             EndpointData);

    if (EndpointData == NULL) {
        TEST_TRAP();
    } else {
        PUSBPORT_COMMON_BUFFER cb;

        ENDPOINT_FROM_EPDATA(endpoint, EndpointData);
        ASSERT_ENDPOINT(endpoint);

        cb = endpoint->CommonBuffer;
        
        // mask off base physical address
        offset = HwPhysicalAddress - cb->BasePhys; 
        virtualAddress = cb->BaseVa+offset;

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mpPV', HwPhysicalAddress, offset, 
                  cb->BaseVa);

        USBPORT_ASSERT(HwPhysicalAddress >= cb->BasePhys && 
            HwPhysicalAddress < cb->BasePhys+cb->MiniportLength);                  

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'mapV', HwPhysicalAddress, 0, 
                  virtualAddress);

        return virtualAddress;
    }


    // probably a bug in the miniport
    DEBUG_BREAK();
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\busif.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    busif.c

Abstract:

    bus interface for the usbport driver

    this is where we export the routines that create
    and remove devices on the bus for use by the hub
    driver.

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_GetBusInterface)
#pragma alloc_text(PAGE, USBPORT_BusInterfaceReference)
#pragma alloc_text(PAGE, USBPORT_BusInterfaceDereference)
#pragma alloc_text(PAGE, USBPORTBUSIF_CreateUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_InitializeUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_GetUsbDescriptors)
#pragma alloc_text(PAGE, USBPORTBUSIF_RemoveUsbDevice)
#pragma alloc_text(PAGE, USBPORTBUSIF_RestoreUsbDevice)
#endif

// non paged functions
//

PDEVICE_OBJECT
USBPORT_PdoFromBusContext(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{   
    PTRANSACTION_TRANSLATOR transactionTranslator = BusContext;
    
    if (transactionTranslator->Sig == SIG_TT) {
        return transactionTranslator->PdoDeviceObject;
    } else {
        return BusContext; 
    }        
}


VOID
USBPORT_BusInterfaceReference(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);

    PAGED_CODE();

    TEST_TRAP();
}


VOID
USBPORT_BusInterfaceDereference(
    PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);

    PAGED_CODE();

    TEST_TRAP();
}


NTSTATUS
USBPORT_GetBusInterface(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    PVOID interfaceData;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested version = %d\n",
            requestedVersion));
    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested size = %d\n",
            requestedSize));
    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - interface data = %x\n",
            irpStack->Parameters.QueryInterface.InterfaceSpecificData));
            
    interfaceData = irpStack->Parameters.QueryInterface.InterfaceSpecificData;

    // assume success
    ntStatus = STATUS_SUCCESS;

    // validate version, size and GUID
    if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
                         &USB_BUS_INTERFACE_HUB_GUID,
                         sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBPORT_GetBusInterfaceHub(FdoDeviceObject,
                                              PdoDeviceObject,
                                              Irp);
    } else if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
               &USB_BUS_INTERFACE_USBDI_GUID,
               sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBPORT_GetBusInterfaceUSBDI(FdoDeviceObject,
                                                PdoDeviceObject,
                                                interfaceData,
                                                Irp);
    } else {

        //
        // Don't change the status of an IRP that isn't understand.
        //
        ntStatus = Irp->IoStatus.Status;
    }

    return ntStatus;
}


NTSTATUS
USBPORT_GetBusInterfaceHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;


    if (requestedVersion >= USB_BUSIF_HUB_VERSION_0) {

        PUSB_BUS_INTERFACE_HUB_V0 busInterface0;

        busInterface0 = (PUSB_BUS_INTERFACE_HUB_V0)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface0->BusContext =
            PdoDeviceObject;
        busInterface0->InterfaceReference =
            USBPORT_BusInterfaceReference;
        busInterface0->InterfaceDereference =
            USBPORT_BusInterfaceDereference;

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_HUB_V0);
        busInterface0->Version = USB_BUSIF_HUB_VERSION_0;
    }

    if (requestedVersion >= USB_BUSIF_HUB_VERSION_1) {

        PUSB_BUS_INTERFACE_HUB_V1 busInterface1;

        busInterface1 = (PUSB_BUS_INTERFACE_HUB_V1)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface1->CreateUsbDevice =
            USBPORTBUSIF_CreateUsbDevice;
        busInterface1->InitializeUsbDevice =
            USBPORTBUSIF_InitializeUsbDevice;
        busInterface1->GetUsbDescriptors =
            USBPORTBUSIF_GetUsbDescriptors;
        busInterface1->RemoveUsbDevice =
            USBPORTBUSIF_RemoveUsbDevice;
        busInterface1->RestoreUsbDevice =
            USBPORTBUSIF_RestoreUsbDevice;
        busInterface1->QueryDeviceInformation =
            USBPORTBUSIF_BusQueryDeviceInformation;

        busInterface1->Size = sizeof(USB_BUS_INTERFACE_HUB_V1);
        busInterface1->Version = USB_BUSIF_HUB_VERSION_1;
    }

    // note that version 2 is a superset of version 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_2) {

        PUSB_BUS_INTERFACE_HUB_V2 busInterface2;

        busInterface2 = (PUSB_BUS_INTERFACE_HUB_V2)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface2->GetControllerInformation =
            USBPORTBUSIF_GetControllerInformation;
        busInterface2->ControllerSelectiveSuspend =
            USBPORTBUSIF_ControllerSelectiveSuspend;
        busInterface2->GetExtendedHubInformation =
            USBPORTBUSIF_GetExtendedHubInformation;
        busInterface2->GetRootHubSymbolicName =
            USBPORTBUSIF_GetRootHubSymbolicName;
        busInterface2->GetDeviceBusContext =
            USBPORTBUSIF_GetDeviceBusContext;
        busInterface2->Initialize20Hub = 
            USBPORTBUSIF_InitailizeUsb2Hub;            

        busInterface2->Size = sizeof(USB_BUS_INTERFACE_HUB_V2);
        busInterface2->Version = USB_BUSIF_HUB_VERSION_2;
    }

    // note that version 3 is a superset of version 2 & 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_3) {

        PUSB_BUS_INTERFACE_HUB_V3 busInterface3;

        busInterface3 = (PUSB_BUS_INTERFACE_HUB_V3)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface3->RootHubInitNotification = 
            USBPORTBUSIF_RootHubInitNotification;                 

        busInterface3->Size = sizeof(USB_BUS_INTERFACE_HUB_V3);
        busInterface3->Version = USB_BUSIF_HUB_VERSION_3;
    }

     // note that version 4 is a superset of version 3,2 & 1
    if (requestedVersion >= USB_BUSIF_HUB_VERSION_4) {

        PUSB_BUS_INTERFACE_HUB_V4 busInterface4;

        busInterface4 = (PUSB_BUS_INTERFACE_HUB_V4)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface4->FlushTransfers = 
            USBPORTBUSIF_FlushTransfers;   

                       
            
        busInterface4->Size = sizeof(USB_BUS_INTERFACE_HUB_V4);
        busInterface4->Version = USB_BUSIF_HUB_VERSION_4;
        
    }

    if (requestedVersion >= USB_BUSIF_HUB_VERSION_5) {

        PUSB_BUS_INTERFACE_HUB_V5 busInterface5;

        busInterface5 = (PUSB_BUS_INTERFACE_HUB_V5)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface5->SetDeviceHandleData = 
            USBPORTBUSIF_SetDeviceHandleData;               
            
        busInterface5->Size = sizeof(USB_BUS_INTERFACE_HUB_V5);
        busInterface5->Version = USB_BUSIF_HUB_VERSION_5;
        
    }


    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_CreateUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE *NewDeviceHandle,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_CreateDevice(&deviceHandle,
                             rhDevExt->HcFdoDeviceObject,
                             HubDeviceHandle,
                             PortStatus,
                             PortNumber);

    *NewDeviceHandle = (PUSB_DEVICE_HANDLE) deviceHandle;

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RootHubInitNotification(
    PVOID BusContext,
    PVOID CallbackContext,
    PRH_INIT_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    This is where we hold the enumeration of the CC root hubs until
    the USB 2.0 controller has initialized.

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION rhDevExt, devExt;
    KIRQL irql;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // remember the callback
    KeAcquireSpinLock(&devExt->Fdo.HcSyncSpin.sl, &irql);
    rhDevExt->Pdo.HubInitContext = CallbackContext;
    rhDevExt->Pdo.HubInitCallback = CallbackRoutine;
    KeReleaseSpinLock(&devExt->Fdo.HcSyncSpin.sl, irql);
     
    return STATUS_SUCCESS;
}


NTSTATUS
USBPORTBUSIF_InitailizeUsb2Hub(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, rhDevExt->HcFdoDeviceObject, 
        LOG_MISC, 'i2hb', BusContext, HubDeviceHandle, TtCount);

    ntStatus =
        USBPORT_InitializeHsHub(rhDevExt->HcFdoDeviceObject,
                                HubDeviceHandle,
                                TtCount);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_InitializeUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_InitializeDevice(DeviceHandle,
                                 rhDevExt->HcFdoDeviceObject);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetUsbDescriptors(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PUCHAR DeviceDescriptorBuffer,
    PULONG DeviceDescriptorBufferLength,
    PUCHAR ConfigDescriptorBuffer,
    PULONG ConfigDescriptorBufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    // assume success
    ntStatus = STATUS_SUCCESS;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    // Use the cached device descriptor instead of bothering the device with
    // another request for it.  You would be surprised by how many devices
    // get confused if you ask for descriptors too often back to back.
    //
    if (DeviceDescriptorBuffer && *DeviceDescriptorBufferLength) {

        USBPORT_ASSERT(*DeviceDescriptorBufferLength ==
                       sizeof(USB_DEVICE_DESCRIPTOR));

        USBPORT_ASSERT(deviceHandle->DeviceDescriptor.bLength >=
                       sizeof(USB_DEVICE_DESCRIPTOR));

        if (*DeviceDescriptorBufferLength > sizeof(USB_DEVICE_DESCRIPTOR)) {
            *DeviceDescriptorBufferLength = sizeof(USB_DEVICE_DESCRIPTOR);
        }

        RtlCopyMemory(DeviceDescriptorBuffer,
                      &deviceHandle->DeviceDescriptor,
                      *DeviceDescriptorBufferLength);
    }

    if (NT_SUCCESS(ntStatus)) {
        ntStatus =
            USBPORT_GetUsbDescriptor(DeviceHandle,
                                     rhDevExt->HcFdoDeviceObject,
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     ConfigDescriptorBuffer,
                                     ConfigDescriptorBufferLength);
    }

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RemoveUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    ULONG Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus =
        USBPORT_RemoveDevice(deviceHandle,
                             rhDevExt->HcFdoDeviceObject,
                             Flags);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_RestoreUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE OldDeviceHandle,
    PUSB_DEVICE_HANDLE NewDeviceHandle
    )
/*++

Routine Description:

    This function clones the configuration from the 'OldDeviceHandle'
    to the 'NewDevicehandle' iff the device has the same VID/PID .
    On completion the 'old' device handle is feed

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_EXTENSION rhDevExt;

    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    ntStatus = USBPORT_CloneDevice(rhDevExt->HcFdoDeviceObject,
                                   OldDeviceHandle,
                                   NewDeviceHandle);

    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_BusQueryDeviceInformation(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PVOID DeviceInformationBuffer,
    ULONG DeviceInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    ULONG need;
    PUSBD_CONFIG_HANDLE cfgHandle;
    ULONG i, j;
    PUSB_DEVICE_INFORMATION_0 level_0 = DeviceInformationBuffer;
    PUSB_LEVEL_INFORMATION levelInfo = DeviceInformationBuffer;
    ULONG numberOfPipes = 0;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;

    PAGED_CODE();

    *LengthOfDataCopied = 0;

    if (DeviceInformationBufferLength < sizeof(*levelInfo)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (levelInfo->InformationLevel > 0) {
        // only support level 0
        return STATUS_NOT_SUPPORTED;
    }

    // figure out how much room we need
    cfgHandle = deviceHandle->ConfigurationHandle;
    if (cfgHandle != NULL) {

        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

         // walk the list
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);
            numberOfPipes += iHandle->InterfaceDescriptor.bNumEndpoints;

            listEntry = iHandle->InterfaceLink.Flink;
        }

    }

    need = (numberOfPipes-1) * sizeof(USB_PIPE_INFORMATION_0) +
            sizeof(USB_DEVICE_INFORMATION_0);


    if (DeviceInformationBufferLength < need) {
        // report how much space if possible
        levelInfo->ActualLength = need;
        *LengthOfDataCopied = sizeof(*levelInfo);
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlZeroMemory(level_0, need);

    //
    // enough room, fill in the buffer
    //

    level_0->InformationLevel = 0;
    level_0->ActualLength = need;
    level_0->DeviceAddress = deviceHandle->DeviceAddress;
    level_0->DeviceDescriptor = deviceHandle->DeviceDescriptor;
    level_0->DeviceSpeed = deviceHandle->DeviceSpeed;

    switch(level_0->DeviceSpeed) {
    case UsbFullSpeed:
    case UsbLowSpeed:
        level_0->DeviceType = Usb11Device;
        break;
    case UsbHighSpeed:
        level_0->DeviceType = Usb20Device;
        break;
    }

//    level_0->PortNumber = xxx;
    level_0->NumberOfOpenPipes = numberOfPipes;
    // default to 'unconfigured'
    level_0->CurrentConfigurationValue = 0;
    // get the pipe information
    if (cfgHandle) {

        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

        level_0->CurrentConfigurationValue =
            cfgHandle->ConfigurationDescriptor->bConfigurationValue;

         // walk the list
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        j = 0;
        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);
            for (i=0; i<iHandle->InterfaceDescriptor.bNumEndpoints; i++) {

                if (TEST_FLAG(iHandle->PipeHandle[i].PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
                    level_0->PipeList[j].ScheduleOffset = 1;
                } else {
                    level_0->PipeList[j].ScheduleOffset =
                       iHandle->PipeHandle[i].Endpoint->Parameters.ScheduleOffset;
                }

                RtlCopyMemory(&level_0->PipeList[j].EndpointDescriptor,
                              &iHandle->PipeHandle[i].EndpointDescriptor,
                              sizeof(USB_ENDPOINT_DESCRIPTOR));
                j++;
            }
            listEntry = iHandle->InterfaceLink.Flink;
        }
    }

    *LengthOfDataCopied = need;

    // dump the level data returned
    USBPORT_KdPrint((1, "  USBD level 0 Device Information:\n"));
    USBPORT_KdPrint((1, "  InformationLevel %d\n",
        level_0->InformationLevel));
    USBPORT_KdPrint((1, "  ActualLength %d\n",
        level_0->ActualLength));
    USBPORT_KdPrint((1, "  DeviceSpeed %d\n",
        level_0->DeviceSpeed));
    USBPORT_KdPrint((1, "  DeviceType %d\n",
        level_0->DeviceType));
    USBPORT_KdPrint((1, "  PortNumber %d\n",
        level_0->PortNumber));
    USBPORT_KdPrint((1, "  CurrentConfigurationValue %d\n",
        level_0->CurrentConfigurationValue));
    USBPORT_KdPrint((1, "  DeviceAddress %d\n",
        level_0->DeviceAddress));
    USBPORT_KdPrint((1, "  NumberOfOpenPipes %d\n",
        level_0->NumberOfOpenPipes));

    for (i=0; i<level_0->NumberOfOpenPipes; i++) {
        USBPORT_KdPrint((1, "  ScheduleOffset[%d] %d\n", i,
            level_0->PipeList[i].ScheduleOffset));
        USBPORT_KdPrint((1, "  MaxPacket %d\n",
            level_0->PipeList[i].EndpointDescriptor.wMaxPacketSize));
        USBPORT_KdPrint((1, "  Interval %d\n",
            level_0->PipeList[i].EndpointDescriptor.bInterval));
//        USBD_KdPrint(1, ("' \n", level_0->));
//        USBD_KdPrint(1, ("' \n", level_0->));
    }

    return STATUS_SUCCESS;
}


PVOID
USBPORTBUSIF_GetDeviceBusContext(
    IN PVOID HubBusContext,
    IN PVOID DeviceHandle
    )
/*++

Routine Description:

    Retun the device relative bus context

Arguments:

Return Value:


--*/
{
    PDEVICE_OBJECT pdoDeviceObject = 
        USBPORT_PdoFromBusContext(HubBusContext);
    PDEVICE_EXTENSION rhDevExt;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    return USBPORT_GetDeviceBusContext(rhDevExt->HcFdoDeviceObject,
                                       DeviceHandle,
                                       HubBusContext);
}               


PVOID
USBPORT_GetDeviceBusContext(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PVOID HubBusContext 
    )
/*++

Routine Description:

    Return the device relative bus context

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION devExt;
    
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // if this is not USB2 just return the hubs bus 
    // context passed in as the device relative context,
    // ie there are no virtual 1.1 buses. Otherwise 
    // return the tt handle for this device
    
    if (USBPORT_IS_USB20(devExt)) {
        return DeviceHandle->Tt;
    } else {
        return HubBusContext;
    }
    
}


BOOLEAN
USBPORT_IsDeviceHighSpeed(
    PVOID BusContext
    )
/*++

Routine Description:

    return the speed of the given device

Arguments:

Return Value:

    speed
--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PTRANSACTION_TRANSLATOR transactionTranslator = BusContext;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);

    if (transactionTranslator->Sig != SIG_TT) {
        // return true if bus is high speed
        if (USBPORT_IS_USB20(devExt)) {
            return TRUE; 
        }            
    }       

    return FALSE;
}    


NTSTATUS
USBPORT_BusQueryBusInformation(
    PVOID BusContext,
    ULONG Level,
    PVOID BusInformationBuffer,
    PULONG BusInformationBufferLength,
    PULONG BusInformationActulaLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    switch (Level) {
    case 0:
        {
        PUSB_BUS_INFORMATION_LEVEL_0 level_0;

        level_0 =  BusInformationBuffer;
        LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'lev1', 0, level_0, 0);

        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = sizeof(*level_0);
        }

        if (*BusInformationBufferLength >= sizeof(*level_0)) {
            *BusInformationBufferLength = sizeof(*level_0);

            // BUGBUG
            TEST_TRAP();
            level_0->TotalBandwidth = 
                USBPORT_ComputeTotalBandwidth(fdoDeviceObject,
                                              BusContext);
            level_0->ConsumedBandwidth =
                USBPORT_ComputeAllocatedBandwidth(fdoDeviceObject,
                                                  BusContext);

            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        }
        break;

    case 1:
        {
        PUSB_BUS_INFORMATION_LEVEL_1 level_1;
        ULONG need;

        level_1 =  BusInformationBuffer;
        LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'lev1', 0, level_1, 0);

        need = sizeof(*level_1) + devExt->SymbolicLinkName.Length;

        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = need;
        }

        if (*BusInformationBufferLength >= need) {
            *BusInformationBufferLength = need;

            level_1->TotalBandwidth = 
                USBPORT_ComputeTotalBandwidth(fdoDeviceObject,
                                              BusContext);
            level_1->ConsumedBandwidth =
                USBPORT_ComputeAllocatedBandwidth(fdoDeviceObject,
                                                  BusContext);
            level_1->ControllerNameLength =
                devExt->SymbolicLinkName.Length;

            RtlCopyMemory(level_1->ControllerNameUnicodeString,
                          devExt->SymbolicLinkName.Buffer,
                          level_1->ControllerNameLength);

            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        }
    }

    return ntStatus;
}


NTSTATUS
USBPORT_GetBusInterfaceUSBDI(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    PVOID usbBusContext;
    PDEVICE_EXTENSION rhDevExt;
    
    PAGED_CODE();

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    if (DeviceHandle == NULL) {
        DeviceHandle = &rhDevExt->Pdo.RootHubDeviceHandle;
    }
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gbi1', FdoDeviceObject, 
        DeviceHandle, 0);
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;

    if (requestedVersion >= USB_BUSIF_USBDI_VERSION_0) {

        PUSB_BUS_INTERFACE_USBDI_V0 busInterface0;

        busInterface0 = (PUSB_BUS_INTERFACE_USBDI_V0)
            irpStack->Parameters.QueryInterface.Interface;

        usbBusContext = PdoDeviceObject;
        // if the device handle is for a device attched to a TT
        // the the bus context is a TT not the root hub Pdo
        if (DeviceHandle->Tt != NULL) {
            usbBusContext = DeviceHandle->Tt;    
        }            
        
        busInterface0->BusContext = usbBusContext;
        busInterface0->InterfaceReference =
            USBPORT_BusInterfaceReference;
        busInterface0->InterfaceDereference =
            USBPORT_BusInterfaceDereference;
        busInterface0->GetUSBDIVersion =
            USBPORT_BusGetUSBDIVersion;
        busInterface0->QueryBusTime =
            USBPORT_BusQueryBusTime;
        busInterface0->QueryBusInformation =
            USBPORT_BusQueryBusInformation;

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_USBDI_V0);
        busInterface0->Version = USB_BUSIF_USBDI_VERSION_0;
    }

    
    if (requestedVersion >= USB_BUSIF_USBDI_VERSION_1) {

        PUSB_BUS_INTERFACE_USBDI_V1 busInterface1;

        busInterface1 = (PUSB_BUS_INTERFACE_USBDI_V1)
            irpStack->Parameters.QueryInterface.Interface;

        // add version 1 extensions
        busInterface1->IsDeviceHighSpeed =
            USBPORT_IsDeviceHighSpeed;
            
        busInterface1->Size = sizeof(USB_BUS_INTERFACE_USBDI_V1);
        busInterface1->Version = USB_BUSIF_USBDI_VERSION_1;
    }

     if (requestedVersion >= USB_BUSIF_USBDI_VERSION_2) {

        PUSB_BUS_INTERFACE_USBDI_V2 busInterface2;

        busInterface2 = (PUSB_BUS_INTERFACE_USBDI_V2)
            irpStack->Parameters.QueryInterface.Interface;

        // add version 2 extensions
        busInterface2->EnumLogEntry =
            USBPORT_BusEnumLogEntry;
            
        busInterface2->Size = sizeof(USB_BUS_INTERFACE_USBDI_V2);
        busInterface2->Version = USB_BUSIF_USBDI_VERSION_2;
    }

    return ntStatus;
}


VOID
USBPORT_BusGetUSBDIVersion(
    PVOID BusContext,
    PUSBD_VERSION_INFORMATION VersionInformation,
    PULONG HcdCapabilities
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(HcdCapabilities != NULL);

    *HcdCapabilities = 0;

    if (VersionInformation != NULL) {
        VersionInformation->USBDI_Version = USBDI_VERSION;

        if (USBPORT_IS_USB20(devExt)) {
            VersionInformation->Supported_USB_Version = 0x0200;
        } else {
            VersionInformation->Supported_USB_Version = 0x0110;
        }
    }

//    if (deviceExtensionUsbd->HcdSubmitIsoUrb != NULL) {
//        *HcdCapabilities = USB_HCD_CAPS_SUPPORTS_RT_THREADS;
//    }
}


NTSTATUS
USBPORT_BusQueryBusTime(
    PVOID BusContext,
    PULONG CurrentFrame
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(CurrentFrame != NULL);

    MP_Get32BitFrameNumber(devExt, *CurrentFrame);

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'biCF', 0,
        CurrentFrame, *CurrentFrame);

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_BusEnumLogEntry(
    PVOID BusContext,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_EnumLogEntry(fdoDeviceObject,
                         DriverTag,
                         EnumTag,
                         P1,
                         P2);

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_BusSubmitIsoOutUrb(
    PVOID BusContext,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    TEST_TRAP();

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBPORTBUSIF_GetControllerInformation(
    PVOID BusContext,
    PVOID ControllerInformationBuffer,
    ULONG ControllerInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    ULONG len;
    PUSB_CONTROLLER_INFORMATION_0 level_0 = ControllerInformationBuffer;
    PUSB_LEVEL_INFORMATION levelInfo = ControllerInformationBuffer;
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    PAGED_CODE();

    *LengthOfDataCopied = 0;

    if (ControllerInformationBufferLength < sizeof(*levelInfo)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *LengthOfDataCopied = sizeof(*levelInfo);

    switch (levelInfo->InformationLevel) {
    // level 0
    case 0:
        len = sizeof(*level_0);
        level_0->ActualLength = len;

        if (ControllerInformationBufferLength >= len) {
            *LengthOfDataCopied = len;
            level_0->SelectiveSuspendEnabled =
                TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND) ?
                    TRUE : FALSE;
        }

        *LengthOfDataCopied = sizeof(*level_0);
        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBPORTBUSIF_ControllerSelectiveSuspend(
    PVOID BusContext,
    BOOLEAN Enable
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    ULONG disableSelectiveSuspend, keyLen;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);


    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    PAGED_CODE();

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_DISABLE_SS)) {
        // if SS diabled by hardware then we will not allow UI 
        // to enable it
        return STATUS_SUCCESS;
    }

    if (Enable) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        disableSelectiveSuspend = 0;
    } else {
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        disableSelectiveSuspend = 1;
    }

    keyLen = sizeof(DISABLE_SS_KEY);
    ntStatus = USBPORT_SetRegistryKeyValueForPdo(
                            devExt->Fdo.PhysicalDeviceObject,
                            USBPORT_SW_BRANCH,
                            REG_DWORD,
                            DISABLE_SS_KEY,
                            keyLen,
                            &disableSelectiveSuspend,
                            sizeof(disableSelectiveSuspend));


    if (NT_SUCCESS(ntStatus)) {
        if (Enable) {
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        } else {
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        }
    }
    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetExtendedHubInformation(
    PVOID BusContext,
    PDEVICE_OBJECT HubPhysicalDeviceObject,
    PVOID HubInformationBuffer,
    ULONG HubInformationBufferLength,
    PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    ULONG i;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // is this the root hub PDO, if so we'll report values from the 
    // registry

    if (HubPhysicalDeviceObject == pdoDeviceObject) {
        // root hub PDO

        if (HubInformationBufferLength < sizeof(USB_EXTHUB_INFORMATION_0))  {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            *LengthOfDataCopied = 0;    
        } else {
            PUSB_EXTHUB_INFORMATION_0 extendedHubInfo = HubInformationBuffer;

            extendedHubInfo->NumberOfPorts = NUMBER_OF_PORTS(rhDevExt);

            for (i=0; i< extendedHubInfo->NumberOfPorts; i++) {

                // set up the defaults
                extendedHubInfo->Port[i].PhysicalPortNumber = i+1;
                extendedHubInfo->Port[i].PortLabelNumber = i+1;
                extendedHubInfo->Port[i].VidOverride = 0;
                extendedHubInfo->Port[i].PidOverride = 0;
                extendedHubInfo->Port[i].PortAttributes = 0;
            

                if (USBPORT_IS_USB20(devExt)) {
                    RH_PORT_STATUS portStatus;
                    USB_MINIPORT_STATUS mpStatus;
                    
                    extendedHubInfo->Port[i].PortAttributes |= 
                        USB_PORTATTR_SHARED_USB2;   
                                        
                    MPRH_GetPortStatus(devExt, 
                                       (USHORT)(i+1),
                                       &portStatus,
                                       mpStatus);     

                    if (portStatus.OwnedByCC) {
                        extendedHubInfo->Port[i].PortAttributes |= 
                            USB_PORTATTR_OWNED_BY_CC;   
                    }
                } else {
                    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC) && 
                        USBPORT_FindUSB2Controller(fdoDeviceObject)) {

                        extendedHubInfo->Port[i].PortAttributes |= 
                            USB_PORTATTR_NO_OVERCURRENT_UI;   
                    }
                }
            }

            // get optional registry parameters that describe port 
            // attributes
            for (i=0; i < extendedHubInfo->NumberOfPorts; i++) {
                WCHAR key[64];
                ULONG portAttr, keyLen;
                
                RtlCopyMemory(key, 
                              PORT_ATTRIBUTES_KEY, 
                              sizeof(PORT_ATTRIBUTES_KEY));

                key[8] = '1'+i;

                keyLen = sizeof(key);
                portAttr = 0;
                USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_HW_BRANCH,
                                          key,
                                          keyLen,
                                          &portAttr,
                                          sizeof(portAttr));  

                USBPORT_KdPrint((1, "  Registry PortAttribute[%d] %x \n", i+1, portAttr));                                              

                // augment with registry value
                extendedHubInfo->Port[i].PortAttributes |= portAttr;                
            }


#if DBG
           for (i=0; i < extendedHubInfo->NumberOfPorts; i++) {
                USBPORT_KdPrint((1, "  PortAttribute[%d] %x \n", i+1, 
                         extendedHubInfo->Port[i].PortAttributes));   
            }                         

#endif
            // execute the control method to see if ACPI knows about
            // any extended attributes here
        
            *LengthOfDataCopied =  sizeof(USB_EXTHUB_INFORMATION_0);
            ntStatus = STATUS_SUCCESS;
        }            
        
    } else {
        // not supporting extended attributes for ports other than the 
        // root hub at this time

        // if the BIOS supports the ACPI methods we will execute the 
        // method here

        *LengthOfDataCopied = 0;
        ntStatus = STATUS_NOT_SUPPORTED;
    }
    
    return ntStatus;
}


NTSTATUS
USBPORTBUSIF_GetRootHubSymbolicName(
    PVOID BusContext,
    PVOID HubSymNameBuffer,
    ULONG HubSymNameBufferLength,
    PULONG HubSymNameActualLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    NTSTATUS ntStatus;
    UNICODE_STRING hubNameUnicodeString;

    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((1, "  HubSymNameBuffer %x \n", HubSymNameBuffer));
    USBPORT_KdPrint((1, "  HubSymNameBufferLength x%x \n", HubSymNameBufferLength));
    USBPORT_KdPrint((1, "  HubSymNameActualLength x%x \n", HubSymNameBufferLength));


    ntStatus = USBPORT_GetSymbolicName(fdoDeviceObject,
                                       devExt->Fdo.RootHubPdo,
                                       &hubNameUnicodeString);

    // copy what we can
    if (HubSymNameBufferLength >= hubNameUnicodeString.Length) {
        RtlCopyMemory(HubSymNameBuffer,
                      hubNameUnicodeString.Buffer,
                      hubNameUnicodeString.Length);
    } else {
        // too small return a NULL
        RtlZeroMemory(HubSymNameBuffer,
                      sizeof(UNICODE_NULL));
    }
    *HubSymNameActualLength = hubNameUnicodeString.Length;

    USBPORT_KdPrint((1, " hubNameUnicodeString.Buffer  %x l %d\n",
        hubNameUnicodeString.Buffer,
        hubNameUnicodeString.Length));

    USBPORT_KdPrint((1, "  HubSymNameActualLength x%x \n", *HubSymNameActualLength));

    RtlFreeUnicodeString(&hubNameUnicodeString);

    // note we always return status success, in order to be backward
    // compaible with the original IOCTL

    return ntStatus;
}


VOID
USBPORTBUSIF_FlushTransfers(
    PVOID BusContext,
    PVOID DeviceHandle
    )
/*++

Routine Description:

    Flushes any outstanding tranfers for a device handle plus the bad request 
    list.
    if no device handle is given just all tranfers on the bad request list
    are flushed.

    The purpose of this function is to complete any tranfers that may be pening 
    by client drivers that are about to unload.

Arguments:

Return Value:

    

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_BadRequestFlush(fdoDeviceObject, TRUE);     

    return;
}


VOID
USBPORTBUSIF_SetDeviceHandleData(
    PVOID BusContext,
    PVOID DeviceHandle,
    PDEVICE_OBJECT UsbDevicePdo
    )
/*++

Routine Description:

    Assocaites a particular PDO with a device handle for use 
    in post mortem debugging situaltions

    This routine must be called at passive level.
    
Arguments:

Return Value:

    

--*/
{
    PDEVICE_OBJECT pdoDeviceObject = USBPORT_PdoFromBusContext(BusContext);
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt, rhDevExt;
    PUSBD_DEVICE_HANDLE deviceHandle = DeviceHandle;
    
    GET_DEVICE_EXT(rhDevExt, pdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    //USBPORT_ASSERT(UsbDevicePdo != NULL);
    //USBPORT_ASSERT(deviceHandle != NULL);

    USBPORT_KdPrint((1, "  SetDeviceHandleData (PDO) %x dh (%x)\n", 
        UsbDevicePdo, deviceHandle));

    if (UsbDevicePdo != NULL && 
        deviceHandle != NULL) {

        PDEVICE_OBJECT fdo;
        // get driver name from device object.
       
        deviceHandle->DevicePdo = UsbDevicePdo;

        // walk up one location for the FDO
        // note: this may be verifier but we 
        // need to know this a well
        fdo = UsbDevicePdo->AttachedDevice;
        USBPORT_KdPrint((1, "  SetDeviceHandleData (FDO) %x \n", 
            fdo));

        // there may be no FDO if the client driver necer attached
        
        if (fdo != NULL &&
            fdo->DriverObject != NULL ) { 

            PDRIVER_OBJECT driverObject;
            ULONG len, i;
            PWCHAR pwch;

            driverObject = fdo->DriverObject;

            pwch = driverObject->DriverName.Buffer;

            // driver name length is in bytes, len is char count
            len = (driverObject->DriverName.Length/sizeof(WCHAR)) > USB_DRIVER_NAME_LEN ? 
                USB_DRIVER_NAME_LEN : 
                driverObject->DriverName.Length/sizeof(WCHAR);
            
            // grab the first 8 chars of the driver name
            for (i=0; i<len && pwch; i++) {
                deviceHandle->DriverName[i] = 
                    *pwch;
                pwch++;                                    
            }
        }            
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\dbg.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Debug functions and services

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "stdarg.h"
#include "stdio.h"

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//USBPORT_GetGlobalDebugRegistryParameters
//USBPORT_AssertFailure
//USBPORT_KdPrintX

// 
ULONG USBPORT_LogMask = (LOG_MINIPORT |
                         LOG_XFERS |
                         LOG_PNP |
                         LOG_MEM |
                         LOG_POWER |
                         LOG_RH |
                         LOG_URB |
                         LOG_MISC |
                         LOG_IRPS |
                         LOG_ISO);

//ULONG USBPORT_LogMask = (
//                         LOG_IRPS |
//                         LOG_URB);                         

ULONG USBPORT_DebugLogEnable =
#if DBG
    1;
#else 
    1;
#endif

ULONG USBPORT_CatcTrapEnable = 0;

#if DBG
/******
DEBUG
******/

#define  DEFAULT_DEBUG_LEVEL    0

#ifdef DEBUG1
#undef DEFAULT_DEBUG_LEVEL
#define  DEFAULT_DEBUG_LEVEL    1
#endif

#ifdef DEBUG2
#undef DEFAULT_DEBUG_LEVEL
#define  DEFAULT_DEBUG_LEVEL    2
#endif

ULONG USBPORT_TestPath = 0;
ULONG USBPORT_W98_Debug_Trace = 0;
ULONG USBPORT_Debug_Trace_Level = DEFAULT_DEBUG_LEVEL;
ULONG USBPORT_Client_Debug = 0;
ULONG USBPORT_BreakOn = 0;


VOID
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    if (USBPORT_Debug_Trace_Level) {
        DbgPrint(Format, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5);
    }        
}

VOID
USB2LIB_DbgBreak(
    VOID
    )
{
    DbgPrint("<Break in USB2LIB>\n");
    DbgBreakPoint();
}


VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{

    if (USBPORT_Debug_Trace_Level >= Level) {
        if (Level <= 1) {
            // dump line to debugger
            if (USBPORT_W98_Debug_Trace) {
                DbgPrint("xMP.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'xMP.SYS: ");
            }
        } else {
            // dump line to NTKERN buffer
            DbgPrint("'xMP.SYS: ");
            if (USBPORT_W98_Debug_Trace) {
                *Format = 0x27;
            }
        }

        DbgPrint(Format, Arg0, Arg1, Arg2, Arg3, Arg4, Arg5);
    }
}


VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    )
{
    DEBUG_BREAK();
}


VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    USBPORT_AssertFailure(
        FailedAssertion,
        FileName,
        LineNumber,
        Message);
}


NTSTATUS
USBPORT_GetGlobalDebugRegistryParameters(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#define MAX_KEYS    8
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[MAX_KEYS];
    PWCHAR usb = L"usb";
    ULONG k = 0;

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // spew level - 0
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LEVEL_KEY;
    QueryTable[k].EntryContext = &USBPORT_Debug_Trace_Level;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_Debug_Trace_Level;
    QueryTable[k].DefaultLength = sizeof(USBPORT_Debug_Trace_Level);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // use ntkern trace buffer - 1
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_WIN9X_KEY;
    QueryTable[k].EntryContext = &USBPORT_W98_Debug_Trace;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_W98_Debug_Trace;
    QueryTable[k].DefaultLength = sizeof(USBPORT_W98_Debug_Trace);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // break on start - 2
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_BREAK_ON;
    QueryTable[k].EntryContext = &USBPORT_BreakOn;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_BreakOn;
    QueryTable[k].DefaultLength = sizeof(USBPORT_BreakOn);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    // log mask - 3
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LOG_MASK;
    QueryTable[k].EntryContext = &USBPORT_LogMask;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_LogMask;
    QueryTable[k].DefaultLength = sizeof(USBPORT_LogMask);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);


    // log mask - 4
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_CLIENTS;
    QueryTable[k].EntryContext = &USBPORT_Client_Debug;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_Client_Debug;
    QueryTable[k].DefaultLength = sizeof(USBPORT_LogMask);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

     // log enable - 5
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_LOG_ENABLE;
    QueryTable[k].EntryContext = &USBPORT_DebugLogEnable;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_DebugLogEnable;
    QueryTable[k].DefaultLength = sizeof(USBPORT_DebugLogEnable);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

     // catc trap enable - 6
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = DEBUG_CATC_ENABLE;
    QueryTable[k].EntryContext = &USBPORT_CatcTrapEnable;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &USBPORT_CatcTrapEnable;
    QueryTable[k].DefaultLength = sizeof(USBPORT_CatcTrapEnable);
    k++;
    USBPORT_ASSERT(k < MAX_KEYS);

    //
    // Stop
    //
    QueryTable[k].QueryRoutine = NULL;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         USBPORT_KdPrint((1, "'Debug Trace Level Set: (%d)\n", USBPORT_Debug_Trace_Level));

        if (USBPORT_W98_Debug_Trace) {
            USBPORT_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            USBPORT_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (USBPORT_DebugLogEnable) {
            USBPORT_KdPrint((1, "'DEBUG-LOG is ON\n"));
        } else {
            USBPORT_KdPrint((1, "'DEBUG-LOG is OFF\n"));
        }

        if (USBPORT_BreakOn) {
            USBPORT_KdPrint((1, "'DEBUG BREAK is ON\n"));
        }

        USBPORT_KdPrint((1, "'DEBUG Log Mask is 0x%08.8x\n", USBPORT_LogMask));

        if (USBPORT_Debug_Trace_Level > 0) {
            ULONG USBPORT_Debug_Asserts = 1;
        }

        if (USBPORT_Client_Debug) {
            USBPORT_KdPrint((1, "'DEBUG CLIENTS (verifier) is ON\n"));
        }

        if (USBPORT_CatcTrapEnable) {
            USBPORT_KdPrint((0, "'DEBUG ANALYZER TRIGGER is ON\n"));
        }
    }

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

VOID
USBPORT_AssertTransferUrb(
    PTRANSFER_URB Urb
    )
{
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);

    USBPORT_ASSERT(transfer->Urb == Urb);

    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    fdoDeviceObject = endpoint->FdoDeviceObject;
    LOGENTRY(NULL, fdoDeviceObject, LOG_URB, 'Aurb', Urb, transfer, 0);

    USBPORT_ASSERT(Urb->pd.UrbSig == URB_SIG);
}


VOID
USBPORT_AssertFailure(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function.

    on NT the debugger does this for us but on win9x it does not.
    so we have to do it ourselves.

Arguments:

Return Value:


--*/
{

    // this makes the compiler generate a ret
    ULONG stop = 0;

assert_loop:

    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it

    DbgBreakPoint();
    if (stop) {
        goto assert_loop;
    }

    return;
}


ULONG
_cdecl
USBPORT_DebugClientX(
    PCH Format,
    ...
    )
/*++

Routine Description:

    Special debug print function for debugging client USB drivers.

    if the client debug mode is set then this function will print a
    message and break in the debugger.  This is the embedded USBPORT
    equivalent of Verifier.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (USBPORT_Debug_Trace_Level > 1 ||
        USBPORT_Client_Debug) {
        DbgPrint(" *** USBPORT(VERIFIER) - CLIENT DRIVER BUG:\n");
        DbgPrint(" * ");
        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
        DbgPrint(" ***\n ");

        DbgBreakPoint();
    }

    return 0;
}


ULONG
_cdecl
USBPORT_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
/*++

Routine Description:

    Debug Print function.

    Prints based on the value of the USBPORT_DEBUG_TRACE_LEVEL

    Also if USBPORT_W98_Debug_Trace is set then all debug messages
    with a level greater than one are modified to go in to the
    ntkern trace buffer.

    It is only valid to set USBPORT_W98_Debug_Trace on Win9x
    becuse the static data segments for drivers are marked read-only
    by the NT OS.

Arguments:

Return Value:


--*/
{
    va_list list;
    int i;
    int arg[6];

    if (USBPORT_Debug_Trace_Level >= l) {
        if (l <= 1) {
            // dump line to debugger
            if (USBPORT_W98_Debug_Trace) {
                DbgPrint("USBPORT.SYS: ");
                *Format = ' ';
            } else {
                DbgPrint("'USBPORT.SYS: ");
            }
        } else {
            // dump line to NTKERN buffer
            DbgPrint("'USBPORT.SYS: ");
            if (USBPORT_W98_Debug_Trace) {
                *Format = 0x27;
            }
        }
        va_start(list, Format);
        for (i=0; i<6; i++)
            arg[i] = va_arg(list, int);

        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);
    }

    return 0;
}


VOID
USBPORT_DebugTransfer_LogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PTRANSFER_URB Urb,
    PIRP Irp,
    NTSTATUS IrpStatus
    )
/*++

Routine Description:

    Adds an entry to transfer log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->TransferLog.LogStart == 0) {
        return;
    }

    USBPORT_AddLogEntry(
        &devExt->TransferLog,
        0xFFFFFFFF,
        '1rfx',
        (ULONG_PTR) Endpoint,
        (ULONG_PTR) Irp,
        (ULONG_PTR) Urb,
        FALSE);

    // decode some info about the transfer and log it as well

    USBPORT_AddLogEntry(
        &devExt->TransferLog,
        0xFFFFFFFF,
        '2rfx',
        (ULONG_PTR) Urb->Hdr.Function,
        IrpStatus,
        (ULONG_PTR) Urb->TransferBufferLength,
        FALSE);
}


#else

/********
RETAIL
 ********/

VOID
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    // nop
}

VOID
USB2LIB_DbgBreak(
    VOID
    )
{
    // nop
}


VOID
USBPORTSVC_DbgPrint(
    PDEVICE_DATA DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    )
{
    // nop
}

VOID
USBPORTSVC_AssertFailure(
    PDEVICE_DATA DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    // nop
}

VOID
USBPORTSVC_TestDebugBreak(
    PDEVICE_DATA DeviceData
    )
{
    // nop
}

#endif /* DBG */

/********
LOG CODE
    enabled in both retail and debug builds
*********/


VOID
USBPORTSVC_LogEntry(
    PDEVICE_DATA DeviceData,
    ULONG Mask,
    ULONG Sig,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3
    )
/*++

Routine Description:

    Service for miniport to add log entries.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEBUG_LOG l;
    extern ULONG USBPORT_DebugLogEnable;\
    extern ULONG USBPORT_LogMask;\
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    
    if (USBPORT_DebugLogEnable && 
        devExt->Log.LogStart != NULL && 
        (LOG_MINIPORT & USBPORT_LogMask)) {
        l = &devExt->Log;
        USBPORT_AddLogEntry(l, LOG_MINIPORT, Sig, Info1, Info2, Info3, TRUE);
    }
}


VOID
USBPORT_LogAlloc(
    PDEBUG_LOG Log,
    ULONG Pages
    )
/*++

Routine Description:

    Init the debug log -
    remember interesting information in a circular buffer

Arguments:

Return Value:

    None.

--*/
{
    ULONG logSize = 4096*Pages;

    if (USBPORT_DebugLogEnable) {

        // we won't track the mem we alloc for the log
        // we will let the verifier do that
        ALLOC_POOL_Z(Log->LogStart,
                     NonPagedPool,
                     logSize);

        if (Log->LogStart) {
            Log->LogIdx = 0;
            Log->LogSizeMask = (logSize/sizeof(LOG_ENTRY));
            Log->LogSizeMask-=1;
            // Point the end (and first entry) 1 entry from the end
            // of the segment
            Log->LogEnd = Log->LogStart +
                (logSize / sizeof(struct LOG_ENTRY)) - 1;
        } else {
            DEBUG_BREAK();
        }
    }

    return;
}


VOID
USBPORT_LogFree(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEBUG_LOG Log
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{

    if (Log->LogStart != NULL) {
        // log the free of the log in order to debug
        // verifier bugs
        FREE_POOL(FdoDeviceObject, Log->LogStart);
        // this will indicate that we have freed the 
        // log, other log pointers will remain intact
        Log->LogStart = NULL;
    }

    return;
}

/*
     Transmit the analyzer trigger packet 
*/

VOID
USBPORT_BeginTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    UCHAR data[4];
    
    USBPORT_KdPrint((1, "'USBPORT_TransmitTriggerPacket\n"));

    ASSERT_PASSIVE();
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'TRIG', &mpPacket, 0, 
       0);

    // build up request for miniport
    
    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

    mpPacket.DeviceAddress = 127;
    mpPacket.EndpointAddress = 8;
    mpPacket.MaximumPacketSize = 64;
    mpPacket.Type = ss_Out; 
    mpPacket.Speed = ss_Full;
    mpPacket.Toggle = ss_Toggle0;

    data[0] = 'G';
    data[1] = 'O'; 
    data[2] = 'A';
    data[3] = 'T';
     
    mpData = &data[0];
    mpDataLength = sizeof(data);
    
    MP_StartSendOnePacket(devExt,
                          &mpPacket,
                          mpData,
                          &mpDataLength,
                          va,
                          phys,
                          length,
                          &usbdStatus,
                          mpStatus);

}    


VOID
USBPORT_EndTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    UCHAR data[4];
    
    USBPORT_KdPrint((1, "'USBPORT_TransmitTriggerPacket\n"));

    ASSERT_PASSIVE();
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
      
    mpData = &data[0];
    mpDataLength = sizeof(data);

    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

   
    USBPORT_Wait(FdoDeviceObject, 10);
            
    MP_EndSendOnePacket(devExt,
                        &mpPacket,
                        mpData,
                        &mpDataLength,
                        va,
                        phys,
                        length,
                        &usbdStatus,
                        mpStatus);


    USBPORT_KdPrint((1, "'<ANALYZER TRIGER FIRED>\n"));
    DbgBreakPoint();
    
}    


VOID
USBPORT_CatcTrap(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {
        USBPORT_BeginTransmitTriggerPacket(FdoDeviceObject);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CATC_TRAP);
    } else {
        TEST_TRAP();
        USBPORT_BeginTransmitTriggerPacket(FdoDeviceObject);
        USBPORT_EndTransmitTriggerPacket(FdoDeviceObject);
    }        
}    


VOID
USBPORT_EnumLogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    )
/*++

Routine Description:

    Enumeration Log, this is where any USB device driver may log a failure 
    to track failure causes

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->EnumLog.LogStart == 0) {
        return;
    }

    USBPORT_AddLogEntry(
        &devExt->EnumLog,
        0xFFFFFFFF,
        EnumTag,
        (ULONG_PTR) DriverTag,
        (ULONG_PTR) P1,
        (ULONG_PTR) P2,
        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\core.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    core.c

Abstract:

    core endpoint transfer code for the port driver

    The core of the driver is EndpointWorker.  This function
    checks the given STATE of the endpoint and takes appropriate
    action.  In some cases it moves the endpoint to a new state.

    the endpointer worker functions job is to process transfers 
    on the active list

    NOTE:
    All transfers are queued to the endpoint. The EndpointWorker 
    function is not reentrant for the same endpoint.


    Transfer Queues: 
        transfers are held in one of these queues
    
        PendingTransfers - Transfers that have not been mapped or handed
            to the miniport
            
        ActiveTransfers - Transfers that have been passed to miniport ie
                        on the HW
        
        CanceledTransfers - transfers that need to be completed as canceled                
                        these are previously 'active' transfers that are on 
                        the HW

    We INSERT at the tail and remove from the head

    Endpoint States:
        the endpoints have states, the only functions that should transition
        an endpoint state is the worker

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"


#define CW_SKIP_BUSY_TEST       0x00000001

//#define TIMEIO   

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_AllocTransfer
// USBPORT_QueueTransferUrb
// USBPORT_QueuePendingUrbToEndpoint
// USBPORT_QueueActiveUrbToEndpoint
// USBPORT_FreeTransfer
// USBPORT_CancelTransfer
// USBPORT_DoneTransfer
// USBPORT_CompleteTransfer
// USBPORT_FlushCancelList
// USBPORT_SetEndpointState
// USBPORT_GetEndpointState
// USBPORT_CoreEndpointWorker
// USBPORT_FlushMapTransferList
// USBPORT_FlushPendingList
// USBPORT_MapTransfer
// USBPORTSVC_InavlidateEndpoint
// USBPORT_PollEndpoint
// USBPORT_FlushDoneTransferList
// USBPORT_QueueDoneTransfer
// USBPORT_SignalWorker
// USBPORT_Worker
// USBPORT_FindUrbInList
// USBPORT_AbortEndpoint
// USBPORT_FlushAbortList


BOOLEAN
USBPORT_CoreEndpointWorker(
    PHCD_ENDPOINT Endpoint,
    ULONG Flags
    )
/*++

Routine Description:

    Core Worker .  The endpointer worker function is not
    re-entrant for the same endpoint.  This function checks 
    the endpoint busy flag and if busy defers processing 
    until a later time.

    In theory this function should only be called if we KNOW
    the endpoint has work.

    This is where the state change requests occur, in processing 
    an endpoint we determine if a new state is needed and request 
    the change.  The one exception in the CloseEndpoint routine
    which also requests a state change and synchronizes with
    this function via the BUSY flag.

    This is the ONLY place we should initiate state changes from.

    THIS ROUTINE RUNS AT DISPATCH LEVEL

Arguments:

Return Value:

    None.

--*/
{
    LONG busy;
    MP_ENDPOINT_STATE currentState;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    BOOLEAN isBusy = FALSE;

    USBPORT_ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'corW', 0, Endpoint, 0);

    // we check the busy flag separately so that we don't 
    // end up waiting on any spinlocks, if the endpoint is
    // 'busy' we want to exit this routine and move to 
    // another endpoint.
    // The BUSY flag is initialized to -1 if incremeted to
    // a non-zero value we bypass this endpoint
    if (TEST_FLAG(Flags, CW_SKIP_BUSY_TEST)) {
        busy = 0;
    } else {
        busy = InterlockedIncrement(&Endpoint->Busy);
    }        
    
    if (busy) {
    
        InterlockedDecrement(&Endpoint->Busy);
        // defer processing
        LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'BUSY', 0, Endpoint, 0);

        isBusy = TRUE;
        
    } else { 
    
        LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'prEP', 0, Endpoint, 0);

        // not busy
        ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le20');

        if (USBPORT_GetEndpointState(Endpoint) == ENDPOINT_CLOSED) {

            // nothing to do if closed, we even skip the poll
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'CLOS', 0, Endpoint, 0);

            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue23');

            InterlockedDecrement(&Endpoint->Busy);
            return isBusy;              
        }

        // poll the endpoint first to flush
        // out any done transfers
        USBPORT_PollEndpoint(Endpoint);

        // put the endpoint on the closed list 
        // if it is the REMOVED state
        currentState = USBPORT_GetEndpointState(Endpoint);
        LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'eps1', 0, currentState, 0);

        if (currentState == ENDPOINT_REMOVE) {

            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'rmEP', 0, Endpoint, 0);

            // set the state to 'CLOSED' so we don't put it on the 
            // the closed list again.
            ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint);                
            Endpoint->CurrentState = Endpoint->NewState = ENDPOINT_CLOSED;
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint);   
            
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue22');

            KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'CLO+', 0, Endpoint, 0);

            // it is OK to be on the attention list and the closed 
            // list

            USBPORT_ASSERT(Endpoint->ClosedLink.Flink == NULL);
            USBPORT_ASSERT(Endpoint->ClosedLink.Blink == NULL);

            ExInterlockedInsertTailList(&devExt->Fdo.EpClosedList, 
                                        &Endpoint->ClosedLink,
                                        &devExt->Fdo.EpClosedListSpin.sl);  
                                    
            KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
            InterlockedDecrement(&Endpoint->Busy);
            return isBusy;                                        
        }
            
        // see if we really have work
        if (IsListEmpty(&Endpoint->PendingList) &&
            IsListEmpty(&Endpoint->CancelList) && 
            IsListEmpty(&Endpoint->ActiveList)) {

            // no real work to do
            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'noWK', 0, Endpoint, 0);
        
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue20');

            InterlockedDecrement(&Endpoint->Busy);

            // we may still have some aborts around if the client 
            // sent them with no transfers flush them now.
            USBPORT_FlushAbortList(Endpoint);

            // no locks held flush done transfers
            return isBusy;
        }   

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue21');

        // no locks held flush done transfers
        //USBPORT_FlushDoneTransferList(fdoDeviceObject, FALSE);

        currentState = USBPORT_GetEndpointState(Endpoint);
        LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'eps2', 0, currentState, 0);

        ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
        if (currentState != Endpoint->NewState) {
            // we are in state transition defer processing 
            // until we reach the desired state. 
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'stCH', 
                currentState, Endpoint, Endpoint->NewState);
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint);                 
            InterlockedDecrement(&Endpoint->Busy);
            return TRUE;
        }
        RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 

        // call the specific worker function
        Endpoint->EpWorkerFunction(Endpoint);

        // worker may wave completed abort requests so we flush
        // the abort list here.
        USBPORT_FlushAbortList(Endpoint);

        InterlockedDecrement(&Endpoint->Busy);        
    }

    return isBusy;
}


#if DBG
BOOLEAN
USBPORT_FindUrbInList(
    PTRANSFER_URB Urb,
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE if found

--*/
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;

    listEntry = ListHead;
    
    if (!IsListEmpty(listEntry)) {
        listEntry = ListHead->Flink;
    }

    while (listEntry != ListHead) {

        PHCD_TRANSFER_CONTEXT transfer;
            
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);

                                    
        listEntry = transfer->TransferLink.Flink;

        if (transfer->Urb == Urb) {
            found = TRUE;
            break;
        }
    }                        

    return found;
}
#endif

PHCD_TRANSFER_CONTEXT
USBPORT_UnlinkTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    disassociates a transfer structure from a URB

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;

    USBPORT_ASSERT(TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_TRANSFER_ALLOCATED))

    transfer = Urb->pd.HcdTransferContext;
    Urb->pd.HcdTransferContext = USB_BAD_PTR;
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ULtr', transfer, 0, 0);

    return transfer;
}  


USBD_STATUS
USBPORT_AllocTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp,
    PKEVENT CompleteEvent,
    ULONG MillisecTimeout
    )
/*++

Routine Description:

    Allocate and initialize a transfer context.

Arguments:

    FdoDeviceObject - pointer to a device object

    Urb - a transfer request

    Irp - pointer to an I/O Request Packet
     (optional)

    CompleteEvent - event to signal on completion
     (optional)

    MillisecondTimeout - 0 indicates no timeout     

Return Value:

    USBD status code

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    ULONG sgCount;
    PUCHAR currentVa;
    ULONG privateLength, sgListSize, isoListSize;
    
    // allocate a transfer context and initialize it

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(Urb != NULL);
    
    pipeHandle = Urb->UsbdPipeHandle;
    ASSERT_PIPE_HANDLE(pipeHandle);

    USBPORT_ASSERT(!TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_TRANSFER_ALLOCATED))

    // see how much space we will need for the sg list
    if (Urb->TransferBufferLength) {
        currentVa = 
            MmGetMdlVirtualAddress(Urb->TransferBufferMDL);
        sgCount = USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K(currentVa, Urb->TransferBufferLength);
    } else {
        // zero length transfer
        currentVa = NULL;
        sgCount = 0;
    }

    // sizeof <transfer> + <sgList>
    sgListSize = sizeof(HCD_TRANSFER_CONTEXT) +
                 sizeof(TRANSFER_SG_ENTRY32)*sgCount;
    
    // if this is an iso transfer we need to alloc the 
    // packet structure as well
    if (Urb->Hdr.Function == URB_FUNCTION_ISOCH_TRANSFER) {
        isoListSize = 
            sizeof(MINIPORT_ISO_TRANSFER) +
            sizeof(MINIPORT_ISO_PACKET)*Urb->u.Isoch.NumberOfPackets;
    } else {
        isoListSize = 0;
    }

    privateLength = sgListSize + isoListSize;
                    
    LOGENTRY(pipeHandle->Endpoint,
        FdoDeviceObject, LOG_XFERS, 'TRcs', 
        REGISTRATION_PACKET(devExt).TransferContextSize,
        privateLength, 
        sgCount);
        
    ALLOC_POOL_Z(transfer, 
                 NonPagedPool, 
                 privateLength +                
                 REGISTRATION_PACKET(devExt).TransferContextSize);

    if (transfer != NULL) {
        PUCHAR pch;
        ULONG i;
        
        LOGENTRY(pipeHandle->Endpoint,
            FdoDeviceObject, LOG_XFERS, 'alTR', transfer, Urb, Irp);

        // init the transfer context
        transfer->Sig = SIG_TRANSFER;
        transfer->Flags = 0;
        transfer->MillisecTimeout = MillisecTimeout;
        transfer->Irp = Irp;
        transfer->Urb = Urb;        
        transfer->CompleteEvent = CompleteEvent;
        //point to the master transfer for a set
        transfer->Transfer = transfer; 
        ASSERT_ENDPOINT(pipeHandle->Endpoint);
        transfer->Endpoint = pipeHandle->Endpoint;
        transfer->MiniportContext = (PUCHAR) transfer;
        transfer->MiniportContext += privateLength;
        transfer->PrivateLength = privateLength;
        KeInitializeSpinLock(&transfer->Spin);
        InitializeListHead(&transfer->DoubleBufferList);
        
        if (isoListSize) {
            pch = (PUCHAR) transfer;
            pch += sgListSize;
            transfer->IsoTransfer = (PMINIPORT_ISO_TRANSFER) pch;
        } else {
            transfer->IsoTransfer = NULL;
        }

        transfer->TotalLength = privateLength +                
             REGISTRATION_PACKET(devExt).TransferContextSize;

        transfer->SgList.SgCount = 0;

        // we don't know the direction yet
        transfer->Direction = NotSet;

        if (DeviceHandle == NULL) {
            // no oca data available for internal function
            transfer->DeviceVID = 0xFFFF;
            transfer->DevicePID = 0xFFFF;
            for (i=0; i<USB_DRIVER_NAME_LEN; i++) {
                transfer->DriverName[i] = '?'; 
            }            
        } else {
            // no oca data available for internal function
            transfer->DeviceVID = DeviceHandle->DeviceDescriptor.idVendor;
            transfer->DevicePID = DeviceHandle->DeviceDescriptor.idProduct;
            for (i=0; i<USB_DRIVER_NAME_LEN; i++) {
                transfer->DriverName[i] = DeviceHandle->DriverName[i]; 
            }  
        }
       
        if (isoListSize) {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO);
        }            

        SET_FLAG(Urb->Hdr.UsbdFlags,  USBPORT_TRANSFER_ALLOCATED);
        usbdStatus = USBD_STATUS_SUCCESS;                    
    } else {
        usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
    }

    Urb->pd.HcdTransferContext = transfer;
    Urb->pd.UrbSig = URB_SIG;

    return usbdStatus;                            
}


VOID
USBPORT_QueueTransferUrb(
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Queues a transfer, either internal (no irp) or external
    irp

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;
    MP_ENDPOINT_STATUS epStatus;
    PUSBD_DEVICE_HANDLE deviceHandle;

    // on entry the urb is not cancelable ie
    // no cancel routine
    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);

    if (TEST_FLAG(Urb->TransferFlags, USBD_DEFAULT_PIPE_TRANSFER)) {
        // to maintain backward compatibility munge the urb function
        // code for control transfers that use the default pipe, just like 
        // usbd did.
        Urb->Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;
    }        
    
    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    InterlockedIncrement(&endpoint->EndpointRef);

    fdoDeviceObject = endpoint->FdoDeviceObject;
    LOGENTRY(endpoint,
        fdoDeviceObject, LOG_XFERS, 'quTR', transfer, endpoint, Urb);

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'LeN0');
    CLEAR_FLAG(endpoint->Flags, EPFLAG_VIRGIN);
    // update the status of the endpoint before releasing the lock
    epStatus = USBPORT_GetEndpointStatus(endpoint);
    RELEASE_ENDPOINT_LOCK(endpoint, fdoDeviceObject, 'UeN0');   

    // copy the transfer parameters from the URB 
    // to our structure
    transfer->Tp.TransferBufferLength = 
        Urb->TransferBufferLength;
    transfer->Tp.TransferFlags = 
        Urb->TransferFlags;            
    transfer->TransferBufferMdl = 
        Urb->TransferBufferMDL;
    transfer->Tp.MiniportFlags = 0;
    
    if (endpoint->Parameters.TransferType == Control) {         
        RtlCopyMemory(&transfer->Tp.SetupPacket[0],
                      &Urb->u.SetupPacket[0],
                      8);
    }   

    // we should know the direction by now
    if (Urb->TransferFlags & USBD_TRANSFER_DIRECTION_IN) {
        transfer->Direction = ReadData;
    } else {
        transfer->Direction = WriteData;
    }
    
    // assign a sequence number
    transfer->Tp.SequenceNumber = 
        InterlockedIncrement(&devExt->Fdo.NextTransferSequenceNumber);

    // set URB bytes transferred to zero bytes transferred
    // when this urb completes this value should contain 
    // actual bytes transferred -- this will ensure we return
    // zero in the event of a cancel
    Urb->TransferBufferLength = 0;

    // Historical Note:
    // The UHCD driver failed requests to endpoints that were halted
    // we need to preserve this behavior because transfer queued to a 
    // halted endpoint will not complete unless the endpoint is resumed
    // or canceled. Some clients (HIDUSB) rely on this behavior when 
    // canceling requests as part of an unplug event.
// bugbug the miniports need to be fixed to correctly refilect the 
// ep status (USBUHCI)
//    if (epStatus == ENDPOINT_STATUS_HALT) {
//        TEST_TRAP();
//    }

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    ASSERT_DEVICE_HANDLE(deviceHandle);
    
    if (transfer->Irp) {
        // client request attached to irp, this 
        // function will queue the urb to the 
        // endpoint after dealing with cancel stuff.
        USBPORT_QueuePendingTransferIrp(transfer->Irp);
        
    } else {
        // internal, no irp just queue it directly
        USBPORT_QueuePendingUrbToEndpoint(endpoint,
                                          Urb);
    }

    // the transfer is queued to the ep so we no longer 
    // need a ref for it on the device handle
    InterlockedDecrement(&deviceHandle->PendingUrbs);        


    // we have queued one new transfer, attempt to 
    // flush more to the hardware
    USBPORT_FlushPendingList(endpoint, -1);

    // allow endpoint to be deleted
    InterlockedDecrement(&endpoint->EndpointRef);
}


VOID
USBPORT_QueuePendingUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Puts a transfer on the endpoint 'pending' queue 

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;

    // on entry the urb is not cancelable ie
    // no cancel routine

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);
    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'p2EP', transfer, Endpoint, 0);
            
    // take the endpoint spinlock
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le30');
    
    // put the irp on the PENDING list
    InsertTailList(&Endpoint->PendingList, &transfer->TransferLink);
    Urb->Hdr.Status = USBD_STATUS_PENDING;
    
    // release the endpoint lists
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue30');
}


BOOLEAN
USBPORT_QueueActiveUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    )
/*++

Routine Description:

    Either puts the urb on the map list or the ATIVE list 
    for an endpoint

    ACTIVE irp lock is held

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN mapped = FALSE;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_TRANSFER_CONTEXT transfer;    

    transfer = Urb->pd.HcdTransferContext;
    ASSERT_TRANSFER(transfer);        
    ASSERT_ENDPOINT(Endpoint);
    
    fdoDeviceObject = Endpoint->FdoDeviceObject;        
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    LOGENTRY(Endpoint, 
        fdoDeviceObject, LOG_XFERS, 'a2EP', transfer, Endpoint, 0);    
    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le40');

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {
    
        // special case check of the endpoint state.  If the 
        // endpoint is 'nuked' then it does not exist on the 
        // HW we can therefore complete the request with 
        // device_no_longer_exists immediatly.  This will occur
        // if the device is removed while the controller is 
        // 'off'.

        InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);                    
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue42');

    } else if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED)) {
                
        InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);                    
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue42');
        
    } else if (transfer->Tp.TransferBufferLength != 0 && 
              (Endpoint->Flags & EPFLAG_MAP_XFERS)) {
        KIRQL mapirql;

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue40');

        USBPORT_AcquireSpinLock(fdoDeviceObject,
                                &devExt->Fdo.MapTransferSpin, 
                                &mapirql);
        
        InsertTailList(&devExt->Fdo.MapTransferList, 
                       &transfer->TransferLink);

        // this prevents the devhandle from being freed while 
        // a transfer is on the mapped list
        // 328555
        REF_DEVICE(transfer->Urb);
                       
        USBPORT_ReleaseSpinLock(fdoDeviceObject,
                                &devExt->Fdo.MapTransferSpin, 
                                mapirql);                               
                                 
        mapped = TRUE;
    } else {
        // don't need to map zero length transfers
        // or endpoints that don't need mapping
        LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'a2EL', transfer, Endpoint, 0);


        if (TEST_FLAG(Endpoint->Flags, EPFLAG_VBUS) &&
            transfer->Tp.TransferBufferLength != 0) {
            // prep the transfer for vbus
            TEST_TRAP();
            transfer->SgList.MdlVirtualAddress = 
                MmGetMdlVirtualAddress(transfer->TransferBufferMdl);            
        }
        InsertTailList(&Endpoint->ActiveList, 
                       &transfer->TransferLink);

        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue41');                                
    }

    return mapped;
}


VOID
USBPORT_TransferFlushDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

    This DPC is queued whenever a transfer is completed by 
    the miniport it flushes a queue of completed transfers

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;
    ULONG cf;
    
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MP_Get32BitFrameNumber(devExt, cf);          
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 
        'trf+', cf, 0, 0); 
     
    USBPORT_FlushDoneTransferList(fdoDeviceObject);

    MP_Get32BitFrameNumber(devExt, cf);              
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 
        'trf-', cf, 0, 0); 

}


VOID
USBPORT_QueueDoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer,
    USBD_STATUS CompleteCode
    )    
/*++

Routine Description:

    Called when a transfer is completed by hardware
    this function only completes active transfers
    ie transfers on the ACTIVE list

    Note that this function must be called while the 
    endpoint lock is held.

Arguments:

Return Value:

--*/
{
    PHCD_ENDPOINT endpoint;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    endpoint = Transfer->Endpoint;    
    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    ASSERT_ENDPOINT_LOCKED(endpoint);
    
    // the transfer should be in the ACTIVE list
    RemoveEntryList(&Transfer->TransferLink); 


    // error set when transfer is completed to client
    //SET_USBD_ERROR(Transfer->Urb, CompleteCode);
    Transfer->UsbdStatus = CompleteCode;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(endpoint, 
        fdoDeviceObject, LOG_XFERS, 'QDnT', 0, endpoint, Transfer);
    
    ExInterlockedInsertTailList(&devExt->Fdo.DoneTransferList, 
                                &Transfer->TransferLink,
                                &devExt->Fdo.DoneTransferSpin.sl);          

    // queue a DPC to flush the list
    KeInsertQueueDpc(&devExt->Fdo.TransferFlushDpc,
                     0,
                     0);
}    


VOID
USBPORT_DoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer
    )    
/*++

Routine Description:

    Called when a transfer is completed by hardware
    this function only completes active transfers

Arguments:

Return Value:

--*/
{
    PTRANSFER_URB urb;
    PHCD_ENDPOINT endpoint;
    KIRQL irql;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_TRANSFER(Transfer);
    urb = Transfer->Urb;
    ASSERT_TRANSFER_URB(urb);

    USBPORT_ASSERT(Transfer == 
                   urb->pd.HcdTransferContext);
                   
    endpoint = Transfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    LOGENTRY(endpoint,
        fdoDeviceObject, 
        LOG_XFERS, 
        'DonT', 
        urb, 
        endpoint, 
        Transfer);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
    // if we get here the request has already been removed
    // from the endpoint lists, we just have to synchronize
    // with the cancel routine before completeing
        
    irp = Transfer->Irp;
    LOGENTRY(endpoint, 
            fdoDeviceObject, 
            LOG_XFERS, 'DIRP', 
            irp, 
            endpoint, 
            Transfer);

    // we had last reference so complete the irp
    // if the cancel routine runs it will stall on
    // the ACTIVE_IRP_LOCK lock
    
    if (irp) {
        KIRQL cancelIrql;
        
        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);
         
        irp = USBPORT_RemoveActiveTransferIrp(fdoDeviceObject, irp);
        // cancel routine may be running but will not find
        // the irp on the list
        USBPORT_ASSERT(irp != NULL);

        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);  
    } else {
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
    }

    // the irp is exclusively ours now.
    SET_USBD_ERROR(Transfer->Urb, Transfer->UsbdStatus);
    USBPORT_CompleteTransfer(urb,
                             urb->Hdr.Status);

    
}


VOID
USBPORT_CompleteTransfer(
    PTRANSFER_URB Urb,
    USBD_STATUS CompleteCode
    )    
/*++

Routine Description:

    all transfer completions come thru here -- this is where 
    we actually comlete the irp.

    We assume all fields are set in the URB for completion
    except the status.
    
Arguments:

Return Value:

--*/    
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PKEVENT event;
    NTSTATUS ntStatus;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject, pdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    KIRQL oldIrql, statIrql;
    ULONG i;
    PUSBD_ISO_PACKET_DESCRIPTOR usbdPak;
    ULONG flushLength;
#ifdef TIMEIO
    ULONG cf1, cf2, cfTot = 0;
#endif 
#ifdef LOG_OCA_DATA
    OCA_DATA ocaData;
#endif    
 
    ASSERT_TRANSFER_URB(Urb);
    transfer = Urb->pd.HcdTransferContext;

    // make sure we have the correct transfer
    USBPORT_ASSERT(transfer->Urb == Urb) 
    
    endpoint = transfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    
    irp = transfer->Irp;
    event = transfer->CompleteEvent;
    fdoDeviceObject = endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(endpoint, 
             fdoDeviceObject, 
             LOG_IRPS, 
             'cptU', 
             Urb,
             CompleteCode, 
             transfer);    

    pdoDeviceObject = devExt->Fdo.RootHubPdo;

    Urb->TransferBufferLength = transfer->MiniportBytesTransferred;
    transfer->UsbdStatus = CompleteCode;
    ntStatus =                                   
         SET_USBD_ERROR(Urb, CompleteCode);  

    // bytes transferred is set in the URB based on bytes received
    // or sent, update our counters before completion
    KeAcquireSpinLock(&devExt->Fdo.StatCounterSpin.sl, &statIrql);
    switch(endpoint->Parameters.TransferType) {
    case Bulk:
        devExt->Fdo.StatBulkDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    case Control:
        devExt->Fdo.StatControlDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    case Isochronous:
        devExt->Fdo.StatIsoDataBytes += Urb->TransferBufferLength;
        flushLength = 0;
        for (i = 0; i < Urb->u.Isoch.NumberOfPackets; i++) {
            usbdPak = &Urb->u.Isoch.IsoPacket[i];
            if (usbdPak->Length != 0) {
                flushLength = usbdPak->Offset + usbdPak->Length;
            }
        }
        break;
    case Interrupt:
        devExt->Fdo.StatInterruptDataBytes += Urb->TransferBufferLength;
        flushLength = Urb->TransferBufferLength;
        break;
    }      
    KeReleaseSpinLock(&devExt->Fdo.StatCounterSpin.sl, statIrql);                                   

    // if we have an irp remove it from our internal lists
    LOGENTRY(endpoint, 
             fdoDeviceObject, 
             LOG_IRPS, 
             'CptX', 
             irp, 
             CompleteCode, 
             ntStatus);

    // free any DMA resources associated with this transfer
    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_MAPPED)) {
        
        BOOLEAN write = transfer->Direction == WriteData ? TRUE : FALSE; 
        PUCHAR currentVa;
        BOOLEAN flushed;

        USBPORT_ASSERT(transfer->Direction != NotSet); 
        currentVa = 
            MmGetMdlVirtualAddress(Urb->TransferBufferMDL);
            
        // IoFlushAdapterBuffers() should only be called once per call
        // to IoAllocateAdapterChannel()
        //
#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(endpoint,
                 fdoDeviceObject, LOG_IRPS, 'iPF1', 
                 0, 
                 cf1,
                 0); 
#endif          
        flushed = IoFlushAdapterBuffers(devExt->Fdo.AdapterObject,
                                         Urb->TransferBufferMDL,
                                         transfer->MapRegisterBase,
                                         currentVa,
                                         flushLength,
                                         write);
        
        USBPORT_FlushAdapterDBs(fdoDeviceObject,
                                transfer);

        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'dmaF',
                 transfer->MapRegisterBase, 
                 flushLength, 
                 flushed);
                
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
        //
        // IoFreeMapRegisters() must be called at DISPATCH_LEVEL

        IoFreeMapRegisters(devExt->Fdo.AdapterObject,
                            transfer->MapRegisterBase,
                            transfer->NumberOfMapRegisters);

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(endpoint,
                 fdoDeviceObject, LOG_IRPS, 'iPF2', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot+=(cf2-cf1);   

        if (cf2-cf1 > 2) {
            TEST_TRAP();
        }
#endif

         KeLowerIrql(oldIrql);
    }

    if (TEST_FLAG(Urb->Hdr.UsbdFlags, USBPORT_REQUEST_MDL_ALLOCATED)) {
        IoFreeMdl(transfer->TransferBufferMdl);
    }
    
#if DBG 
        
    USBPORT_DebugTransfer_LogEntry(
                fdoDeviceObject,
                endpoint,
                transfer,
                Urb,
                irp,
                ntStatus);

#endif

    // free the context before we loose the irp
    USBPORT_UnlinkTransfer(fdoDeviceObject, Urb);
    
    if (irp) {

        // deref the PDO device object since thisis what the
        // 'irp' was passed to
        DECREMENT_PENDING_REQUEST_COUNT(pdoDeviceObject, irp);

        irp->IoStatus.Status      = ntStatus;
        irp->IoStatus.Information = 0;

        LOGENTRY(endpoint, 
                 fdoDeviceObject, 
                 LOG_IRPS, 
                 'irpC', 
                 irp,
                 ntStatus,
                 Urb);
#if DBG        
        {
        LARGE_INTEGER t;            
        KeQuerySystemTime(&t);        
        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'tIPC', 0, 
                t.LowPart, 0);
        }                
#endif    


        // put some information on the stack about this driver in the event 
        // we crash attempting to complete their IRP
        USBPORT_RecordOcaData(fdoDeviceObject, &ocaData, transfer, irp);


        //LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'irql', 0, 0,  KeGetCurrentIrql());
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

/* use to test OCA data logging */
//#if 0
//{
//static int crash = 0;
//crash++;
//if (crash > 1000) {
//RtlZeroMemory(irp, sizeof(irp));          
//}
//}
//#endif
        IoCompleteRequest(irp, 
                          IO_NO_INCREMENT);                       

        KeLowerIrql(oldIrql);
        
        //LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'irql', 0, 0,  KeGetCurrentIrql());
                              
    }        

    // if we have an event associated with this transfer 
    // signal it
    
    if (event) {
        LOGENTRY(endpoint, fdoDeviceObject, LOG_XFERS, 'sgEV', event, 0, 0);

        KeSetEvent(event,
                   1,
                   FALSE);

    }

    // free the transfer now that we are done with it
    LOGENTRY(endpoint, 
        fdoDeviceObject, LOG_XFERS, 'freT', transfer, transfer->MiniportBytesTransferred, 0);
    UNSIG(transfer);        
    FREE_POOL(fdoDeviceObject, transfer);
    
}


IO_ALLOCATION_ACTION
USBPORT_MapTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PVOID MapRegisterBase,
    PVOID Context 
    )
/*++

Routine Description:

    Begin a DMA transfer -- this is the adapter control routine called
    from IoAllocateAdapterChannel.

    loop calling iomap transfer and build up an sg list
    to pass to the miniport.

Arguments:

Return Value:

    see IoAllocateAdapterChannel

--*/
{
    PHCD_ENDPOINT endpoint; 
    PHCD_TRANSFER_CONTEXT transfer = Context;
    PTRANSFER_URB urb;
    PTRANSFER_SG_LIST sgList;
    PDEVICE_EXTENSION devExt;
    PUCHAR currentVa;
    ULONG length, lengthMapped;
    PHYSICAL_ADDRESS logicalAddress, baseLogicalAddress;
    PHYSICAL_ADDRESS logicalSave;
    LIST_ENTRY splitTransferList;
#ifdef TIMEIO
    ULONG cf1, cf2, cfTot = 0;
#endif 
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_TRANSFER(transfer);
    endpoint = transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);
    
    // allow more dma operations now
    InterlockedDecrement(&devExt->Fdo.DmaBusy);     
    LOGENTRY(endpoint, FdoDeviceObject, 
        LOG_XFERS, 'DMA-', devExt->Fdo.DmaBusy, 0, 0);
        
    transfer->MapRegisterBase = MapRegisterBase;
    
    urb = transfer->Urb;
    ASSERT_TRANSFER_URB(urb);
    
    currentVa = 
        MmGetMdlVirtualAddress(urb->TransferBufferMDL);

    length = transfer->Tp.TransferBufferLength;

    USBPORT_ASSERT(!(transfer->Flags & USBPORT_TXFLAG_MAPPED));

    sgList = &transfer->SgList;
    sgList->SgCount = 0;
    sgList->MdlVirtualAddress = currentVa;

    // attempt to map a system address for the MDL in case 
    // the miniport needs to double buffer
    urb->TransferBufferMDL->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    sgList->MdlSystemAddress = 
        MmGetSystemAddressForMdl(urb->TransferBufferMDL);
    if (sgList->MdlSystemAddress == NULL) {
        TEST_TRAP();
        // bugbug map failure we will need to fail this transfer
        LOGENTRY(endpoint,
            FdoDeviceObject, LOG_XFERS, 'MPSf', 0, 0, 0);             
    }
    urb->TransferBufferMDL->MdlFlags &= ~MDL_MAPPING_CAN_FAIL;
    
    LOGENTRY(endpoint, 
        FdoDeviceObject, LOG_XFERS, 'MAPt', 
        sgList, transfer, transfer->Tp.TransferBufferLength);   
    lengthMapped = 0;
    
    //
    // keep calling IoMapTransfer until we get Logical Addresses 
    // for the entire client buffer
    //
    
    logicalSave.QuadPart = 0;
    sgList->SgFlags = 0;
    
    do {    
        BOOLEAN write = transfer->Direction == WriteData ? TRUE : FALSE; 
        ULONG used, lengthThisPage, offsetMask;

        USBPORT_ASSERT(transfer->Direction != NotSet); 
        sgList->SgEntry[sgList->SgCount].StartOffset =
            lengthMapped;
        
        // first map the transfer buffer

        // note that iomaptransfer maps the buffer into sections
        // represented by physically contiguous pages 
        // also the page size is platfor specific ie different on 
        // 64bit platforms
        //
        // the miniport sg list is broken in to into discrete 
        // 4k USB 'pages'.
        
        // The reason for this is the somewhat complicated scheme
        // ohci uses to support scatter gather. Breaking the transfer 
        // up in this way makes the TD transfer mapping code 
        // considerably simpler in the OHCI miniport and reduces 
        // the risks due to controller HW problems.

        LOGENTRY(endpoint,
            FdoDeviceObject, LOG_XFERS, 'IOMt', length, currentVa, 0);

#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(endpoint,
                 FdoDeviceObject, LOG_XFERS, 'iPF1', 
                 0, 
                 cf1,
                 0); 
#endif 
        logicalAddress =         
            IoMapTransfer(devExt->Fdo.AdapterObject,
                          urb->TransferBufferMDL,
                          MapRegisterBase,
                          currentVa,
                          &length,
                          write); 

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(endpoint,
                 FdoDeviceObject, LOG_XFERS, 'iPF2', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot+=(cf2-cf1);  

        if (cf2-cf1 > 2) {
            TEST_TRAP();
        }
#endif
        // remember what we got from IoMapTransfer                           
        baseLogicalAddress = logicalAddress;
        used = length;

        offsetMask = 0x00000FFF;

        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_XFERS, 'MPbr', length, logicalAddress.LowPart, 
                    logicalAddress.HighPart);
        
        do {
        // compute the distance to the next page
            lengthThisPage = 
                USB_PAGE_SIZE - (logicalAddress.LowPart & offsetMask);

            LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MPsg', 
                sgList->SgCount, used, lengthThisPage);   
             
            // if we don't go to the end just use the length from
            // iomaptransfer
            if (lengthThisPage > used) {
                lengthThisPage = used;
            }
            
            sgList->SgEntry[sgList->SgCount].LogicalAddress.Hw64 = 
                logicalAddress;
            
            sgList->SgEntry[sgList->SgCount].Length = 
                lengthThisPage;

            LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MAPe', 
                sgList->SgCount, lengthThisPage, logicalAddress.LowPart);   

            logicalAddress.LowPart += lengthThisPage;

            sgList->SgEntry[sgList->SgCount].StartOffset =
                lengthMapped + length - used;
                
            used -= lengthThisPage;                    
                
            sgList->SgCount++;                                    

        } while (used);

        // check for special case where the MDL entries
        // all map to the same physical page
        if (logicalSave.QuadPart == baseLogicalAddress.QuadPart) {
            SET_FLAG(sgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE);
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'l=lg', 0, 
                logicalAddress.LowPart, logicalSave.LowPart);
      
        } 
        logicalSave.QuadPart = baseLogicalAddress.QuadPart;
        
        lengthMapped += length;    
        currentVa += length;                                          

        USBPORT_KdPrint((2, "'IoMapTransfer length = 0x%x log address = 0x%x\n", 
            length, logicalAddress.LowPart));

        length = transfer->Tp.TransferBufferLength - lengthMapped;
        
    } while (lengthMapped != transfer->Tp.TransferBufferLength);

#if DBG
    {
    // spew for xfers
    ULONG i;
    USBPORT_KdPrint((2, "'--- xfer length %x\n",
        transfer->Tp.TransferBufferLength));
    for (i=0; i<sgList->SgCount; i++) {
        USBPORT_KdPrint((2, "'SG[%d] length %d offset %d phys %x\n",
         i, 
         sgList->SgEntry[i].Length,
         sgList->SgEntry[i].StartOffset,
         sgList->SgEntry[i].LogicalAddress));
    }
    }
            
    if (TEST_FLAG(sgList->SgFlags, USBMP_SGFLAG_SINGLE_PHYSICAL_PAGE)) {
        USBPORT_KdPrint((2, "'*** All Phys Same\n")); 
//        TEST_TRAP();
    }
    USBPORT_KdPrint((2, "'--- \n"));
    
    currentVa = 
        MmGetMdlVirtualAddress(urb->TransferBufferMDL);

    USBPORT_ASSERT(sgList->SgCount <= 
        USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K(currentVa, transfer->Tp.TransferBufferLength));
#endif

    if (endpoint->Parameters.DeviceSpeed == HighSpeed) {
        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_HIGHSPEED);
    }        

    // if this is an iso transfer we need to set up the iso
    // data structures as well.
    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO)) {
        USBPORT_InitializeIsoTransfer(FdoDeviceObject,
                                      urb,
                                      transfer);
    }        

    SET_FLAG(transfer->Flags, USBPORT_TXFLAG_MAPPED);

    ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le60');

    // transfer is mapped, perform the split operation
    // if necessary
    USBPORT_SplitTransfer(FdoDeviceObject,
                          endpoint,
                          transfer,
                          &splitTransferList); 
    

    // transfer is now mapped, put it on the endpoint active 
    // list for calldown to the miniport

    while (!IsListEmpty(&splitTransferList)) {

        PLIST_ENTRY listEntry;
        PHCD_TRANSFER_CONTEXT splitTransfer;
        
        listEntry = RemoveHeadList(&splitTransferList);
            
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            
        LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'MP>A', 
            splitTransfer, endpoint, 0);
    
        InsertTailList(&endpoint->ActiveList, 
                       &splitTransfer->TransferLink);
                       
    }

    // deref the transfer on the device handle now that the transfer is queued
    // to the endpoint
    // 328555
    DEREF_DEVICE(transfer->Urb);

//#if DBG
//    if (!IsListEmpty(&transfer->SplitTransferList)) {
//        TEST_TRAP();
//    }
//#endif
    
    RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Ue60');

    // run the worker for this endpoint to 
    // put the transfer on the hardware

    if (USBPORT_CoreEndpointWorker(endpoint, 0)) {
        // if endpoint is busy we will check it later
//USBPERF - request interrupt instead?       
        USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                                   endpoint, 
                                   IEP_SIGNAL_WORKER);
    }

#ifdef TIMEIO  
    LOGENTRY(endpoint,
             FdoDeviceObject, LOG_XFERS, 'iPF3', 
             cfTot, 
             0,
             0); 
#endif

    LOGENTRY(endpoint, FdoDeviceObject, 
        LOG_XFERS, 'iomX', 0, 0, 0);

    
    return DeallocateObjectKeepRegisters;
}


VOID
USBPORT_FlushPendingList(
    PHCD_ENDPOINT Endpoint,
    ULONG Count
    )
/*++

Routine Description:

    Put as many transfers as we can on the Hardware.

    This function moves transfers from the pending list 
    to the hardware if mapping is necessary they are 
    moved to the mapped list and then flushed to the HW.

Arguments:

    Count is a maximimum number of transfers to flush 
    on this call

Return Value:

    None.

--*/
{
    PLIST_ENTRY listEntry;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;
    BOOLEAN mapped;
    BOOLEAN busy, irql;

    // we are done when there are no transfers in the 
    // pending list or the miniport becomes full
    BOOLEAN done = FALSE;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

flush_again:

    mapped = FALSE;
    transfer = NULL;

    ACQUIRE_PENDING_IRP_LOCK(devExt, irql);    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le70');

    LOGENTRY(Endpoint,
        fdoDeviceObject, LOG_XFERS, 'flPE', 0, Endpoint, 0);

    // the controller should not be off or suspended
    if (TEST_FDO_FLAG(devExt, 
        (USBPORT_FDOFLAG_OFF | USBPORT_FDOFLAG_SUSPENDED))) {
        // the controller should not be off or suspended
        // if we are off or suspended we just leave transfers
        // in the pending state
        done = TRUE;
        
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue70');         
        RELEASE_PENDING_IRP_LOCK(devExt, irql);

        goto USBPORT_FlushPendingList_Done;
    }
    
    // move some transfers to the active list
    // if necessary map them

    // first scan the active list, if any transfers
    // are not called down the skip this step
    busy = FALSE;

    if (!TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {    
        GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

        while (listEntry && 
               listEntry != &Endpoint->ActiveList) {
            
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
                        
            LOGENTRY(Endpoint, 
                fdoDeviceObject, LOG_XFERS, 'cACT', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            // we found a transfer that has not been called 
            // down yet, this means the miniport is full 
            if (!(transfer->Flags & USBPORT_TXFLAG_IN_MINIPORT)) {
                busy = TRUE;
                break;
            }
            listEntry = transfer->TransferLink.Flink;
        }         
    }
    
    if (busy) {
        // busy
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue70');         
        RELEASE_PENDING_IRP_LOCK(devExt, irql);

        done = TRUE;
        // busy
    } else {
        // not busy
        // we push as many transfers as we can to the HW
        GET_HEAD_LIST(Endpoint->PendingList, listEntry);

        if (listEntry) {     

            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
                    
            ASSERT_TRANSFER(transfer);

            // if cancel routine is not running then this
            // opertion will return a ptr
            //
            // once called the pending cancel routine will not run
            
            if (transfer->Irp &&
                IoSetCancelRoutine(transfer->Irp, NULL) == NULL) {
                // pending Irp cancel routine is running or has run
                transfer = NULL;
                // if we encounter a cenceled irp bail in the unlikely
                // event that the cancel routine has been prempted
                done = TRUE;
            } 

            if (transfer) { 
                // transfer
                // cancel routine is not running and cannot run
            
                PTRANSFER_URB urb;
                PIRP irp;

                irp = transfer->Irp;
                urb = transfer->Urb;
                ASSERT_TRANSFER_URB(urb);

                // remove from the head of the endpoint 
                // pending list 
                
                RemoveEntryList(&transfer->TransferLink);
                transfer->TransferLink.Flink = 
                    transfer->TransferLink.Blink = NULL;
                
                if (irp) {
                    irp = USBPORT_RemovePendingTransferIrp(fdoDeviceObject, irp);
                        
                    USBPORT_ASSERT(irp != NULL);
                }

                
                RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue71');
                RELEASE_PENDING_IRP_LOCK(devExt, irql);
                
                // we now have a new 'ACTIVE' transfer to 
                // deal with.
                // It has been safely removed from the 'PENDING' 
                // state and can no longer be canceled.
        
                // if the transfer is marked aborted it will be 
                // handled by when it is queued to the endpoint
                
                ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);              

                // now if we have an irp insert it in the 
                // ActiveIrpList
                if (irp) {
                    // irp
                    USBPORT_ASSERT(transfer->Irp == irp);
                    
                    IoSetCancelRoutine(irp, USBPORT_CancelActiveTransferIrp);

                    if (irp->Cancel && 
                        IoSetCancelRoutine(irp, NULL)) {

                        // irp was canceled and our cancel routine
                        // did not run
                        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);                
        
                        USBPORT_CompleteTransfer(urb,
                                                 USBD_STATUS_CANCELED);
                                                                         
                    } else {
                        // put on our 'ACTIVE' list
                        // this function will verify that we don't already 
                        // have it on the list tied to another irp.
                        USBPORT_CHECK_URB_ACTIVE(fdoDeviceObject, urb, irp);
                        
                        USBPORT_InsertActiveTransferIrp(fdoDeviceObject, irp);

                        mapped = USBPORT_QueueActiveUrbToEndpoint(Endpoint,
                                                                  urb);
                        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);                                                                                               
                    }
                    // irp
                } else {
                    // no irp
                    mapped = USBPORT_QueueActiveUrbToEndpoint(Endpoint,
                                                              urb);
                    RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql); 
                    // no irp
                }
                // transfer                
            } else {
                // no transfer, it is being canceled
                RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue72');                                
                RELEASE_PENDING_IRP_LOCK(devExt, irql);
                // no transfer
            }
            // pending entry     
        } else {
            // no pending entries
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue73');    
            RELEASE_PENDING_IRP_LOCK(devExt, irql);
            // no pending entries

            done = TRUE;
        }
        // not busy        
    } 

USBPORT_FlushPendingList_Done:

    if (mapped) {
        USBPORT_FlushMapTransferList(fdoDeviceObject);
    } else {
        KIRQL oldIrql;

        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

        busy = USBPORT_CoreEndpointWorker(Endpoint, 0);

        KeLowerIrql(oldIrql);

        if (busy) {
            // if worker is busy we need to check the endpoint later
            // this puts the endpoint on our work queue
            USBPORT_InvalidateEndpoint(fdoDeviceObject, 
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
        }
    }

    if (!done) {
        LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'flAG', 0, Endpoint, 0);
        goto flush_again;
    }

} 


VOID
USBPORT_FlushMapTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    pull transfers off the map list and try to map
    them

    please do not call this while holding an 
    endpoint spinlock

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql, oldIrql;    
    LONG dmaBusy;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
#ifdef TIMEIO  
    ULONG cf1, cf2, cfTot;
#endif

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'fMAP',0 ,0 ,0);
    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    
map_another:

    dmaBusy = InterlockedIncrement(&devExt->Fdo.DmaBusy);
    LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'dma+', devExt->Fdo.DmaBusy, 0, 0);

    transfer = NULL;

    if (dmaBusy) {
        // defer processing
        InterlockedDecrement(&devExt->Fdo.DmaBusy);            
        LOGENTRY(NULL, FdoDeviceObject, 
        LOG_XFERS, 'dma-', devExt->Fdo.DmaBusy, 0, 0);
        KeLowerIrql(oldIrql);
        return;
    }

    USBPORT_AcquireSpinLock(FdoDeviceObject, 
                            &devExt->Fdo.MapTransferSpin, 
                            &irql);

    if (IsListEmpty(&devExt->Fdo.MapTransferList)) {
    
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.MapTransferSpin, 
                                irql);
        InterlockedDecrement(&devExt->Fdo.DmaBusy);
        LOGENTRY(NULL, FdoDeviceObject, 
            LOG_XFERS, 'dm1-', devExt->Fdo.DmaBusy, 0, 0);
    
    } else {
        PTRANSFER_URB urb;
        PVOID currentVa;
        NTSTATUS ntStatus;
         
        listEntry = RemoveHeadList(&devExt->Fdo.MapTransferList);
        
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
                    
        ASSERT_TRANSFER(transfer);
    
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.MapTransferSpin, 
                                irql);

        urb = transfer->Urb;
        ASSERT_TRANSFER_URB(urb);
        // we have a transfer, try to map it...
        // although it is removed from the list it is still 
        // referenced, the reason is we will put it on the 
        // active list as soon as it is mapped

        // we should not be mapping zero length xfers            
        USBPORT_ASSERT(transfer->Tp.TransferBufferLength != 0);

        // IoMapTransfer need lots of info about the 
        // transfer
        currentVa = 
            MmGetMdlVirtualAddress(
                urb->TransferBufferMDL);

        // save the number of map registers in our work area
        transfer->NumberOfMapRegisters = 
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                currentVa,
                transfer->Tp.TransferBufferLength);                                                            

#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf1);          
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'iPF3', 
                 cf1, 
                 0,
                 0);
#endif
        USBPORT_ASSERT(transfer->Direction != NotSet); 
        // for PAE systems       
        KeFlushIoBuffers(urb->TransferBufferMDL,
                         transfer->Direction == ReadData ? TRUE : FALSE,
                         TRUE);   
#ifdef TIMEIO  
        MP_Get32BitFrameNumber(devExt, cf2);          
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'iPF4', 
                 cf1, 
                 cf2,
                 cf2-cf1);
        cfTot=(cf2-cf1);  

        if (cf2-cf1 >= 2) {
            TEST_TRAP();
        }
#endif

        // first we'll need to map the MDL for this transfer
        LOGENTRY(transfer->Endpoint,
                FdoDeviceObject, LOG_XFERS, 'AChn', transfer, 
                 0, urb);

#ifdef TIMEIO
        MP_Get32BitFrameNumber(devExt, transfer->IoMapStartFrame);
#endif        
        
        ntStatus = 
            IoAllocateAdapterChannel(devExt->Fdo.AdapterObject,
                                     FdoDeviceObject,
                                     transfer->NumberOfMapRegisters,
                                     USBPORT_MapTransfer,
                                     transfer);
        
        if (!NT_SUCCESS(ntStatus)) {
            // complete the transfer with an error

            TEST_TRAP();
        }

        // transfer structure and URB may be gone at this point
        LOGENTRY(NULL,
                FdoDeviceObject, LOG_XFERS, 'mpAN', 0, 0, 0);
        goto map_another;
    }

    KeLowerIrql(oldIrql);

}             


VOID
USBPORT_FlushCancelList(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    complete any transfers on the cancel list.
    
    This functions locks the endpoint, removes 
    canceled transfers and completes them. 

    This routine is the only way a transfer on the 
    cancel list will be completed 
    ie a transfer is only place on the cancel list 
    if it cannot be completed by the miniport or
    another function

    NOTE: irps on the Cancel list are considred 'ACTIVE'
    ie they are on the ACTIVE irp list and have the 
    CancelActiveIrp cancel routine set.
    

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer = NULL;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql, cancelIrql;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le80');

    LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'flCA', Endpoint, 0 , 0);

    while (!IsListEmpty(&Endpoint->CancelList)) {
         
        listEntry = RemoveHeadList(&Endpoint->CancelList);
        
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_TRANSFER_CONTEXT, 
                TransferLink);
                
        ASSERT_TRANSFER(transfer);

        // complete the transfer, if there is an irp
        // remove it from our active list
        irp = transfer->Irp;
        if (irp) {
            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(transfer->Irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);
            // we should always find it
            irp = USBPORT_RemoveActiveTransferIrp(fdoDeviceObject, irp);
            USBPORT_ASSERT(irp != NULL);
        }
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue80');
        RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     
        
        // no more references to this irp in 
        // our lists, cancel routine cannot find it
        
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'CANt', Endpoint, transfer , 0);

        if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {
            USBPORT_CompleteTransfer(transfer->Urb,
                                     USBD_STATUS_DEVICE_GONE);
        } else {
            USBD_STATUS usbdStatus = USBD_STATUS_CANCELED; 
            
            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_DEVICE_GONE)) {   
                usbdStatus = USBD_STATUS_DEVICE_GONE;
            }
            USBPORT_CompleteTransfer(transfer->Urb,
                                     usbdStatus);
        }
        ACQUIRE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);    
        ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le81');                                         
    }
    
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue81');
    RELEASE_ACTIVE_IRP_LOCK(fdoDeviceObject, devExt, irql);     

    // see if the clients have any abort requests hanging around
    USBPORT_FlushAbortList(Endpoint);

}


VOID
USBPORT_FlushDoneTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    complete any transfers on the done list.
    
    The done list is a list of active tarnsfers
    that need completing

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'flDT', 0, 0, 0); 
        
    while (1) {
        transfer = NULL;
        LOGENTRY(NULL,
                 FdoDeviceObject, LOG_XFERS, 'lpDT', transfer, 0, 0); 
            
        USBPORT_AcquireSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.DoneTransferSpin, 
                                &irql);

        if (IsListEmpty(&devExt->Fdo.DoneTransferList)) {
            USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                    &devExt->Fdo.DoneTransferSpin, 
                                    irql);
            break;
        } else {
             
            listEntry = RemoveHeadList(&devExt->Fdo.DoneTransferList);
            
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);

            LOGENTRY(transfer->Endpoint,
                FdoDeviceObject, LOG_XFERS, 'ulDT', transfer, 0, 0); 
            
            ASSERT_TRANSFER(transfer);
        }
        
        USBPORT_ReleaseSpinLock(FdoDeviceObject, 
                                &devExt->Fdo.DoneTransferSpin, 
                                irql);

        if (transfer) {
            PHCD_ENDPOINT endpoint;

            endpoint = transfer->Endpoint;
            ASSERT_ENDPOINT(endpoint);
            // we have a completed transfer
            // take proper action based on transfer type
#if DBGPERF     
            // check for significant delay between the 
            // completion frame and when we complete the 
            // irp to the client
            {
            ULONG cf;                
            MP_Get32BitFrameNumber(devExt, cf);          
            LOGENTRY(endpoint,
                     FdoDeviceObject, LOG_XFERS, 'perf', 
                     transfer->MiniportFrameCompleted, 
                     cf,
                     transfer); 
            if (transfer->MiniportFrameCompleted &&
                cf - transfer->MiniportFrameCompleted > 3) {
                BUG_TRAP();
            }
            }
#endif
            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD)) {
                USBPORT_DoneSplitTransfer(transfer);
            } else {
                USBPORT_DoneTransfer(transfer);
            }

            // we have completed a transfer, request an 
            // interrupt to process the endpoint for more 
            // transfers
            USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                                       endpoint,
                                       IEP_REQUEST_INTERRUPT);
            
        }           
    }

}


VOID
USBPORT_SetEndpointState(
    PHCD_ENDPOINT Endpoint,
    MP_ENDPOINT_STATE State
    )
/*++

Routine Description:

    Request a particular endpoint state. Call the request down to the 
    miniport then wait for an SOF  

    NOTE we assume the endpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT_LOCKED(Endpoint);

    ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
    // this means we are in the middle of another state change
    // which is not good 
    USBPORT_ASSERT(Endpoint->CurrentState ==
        Endpoint->NewState);
    
    USBPORT_ASSERT(Endpoint->CurrentState !=
                   State);

    // make sure we do not go REMOVE->ACTIVE etc.. as this is invalid
    USBPORT_ASSERT(!(Endpoint->CurrentState == ENDPOINT_REMOVE && 
                     Endpoint->NewState != ENDPOINT_REMOVE));          

    if (Endpoint->Flags & EPFLAG_ROOTHUB) {
        // root hub data structures are internal 
        // so we don't need to wait to change state
        Endpoint->NewState =
            Endpoint->CurrentState = State;    
        // if we entered the remove state just put it directly
        // on the closed list, we don't need to wait 
        if (Endpoint->CurrentState == 
            ENDPOINT_REMOVE) {
            LOGENTRY(Endpoint,
                fdoDeviceObject, LOG_XFERS, 'ivRS', Endpoint, 0, 0);    
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            // for state changes signal the worker thread
            USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
                
        } else {
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
        }
        
    } else {
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'setS', Endpoint, 0, State); 

        if (TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {

            // If the endpoint is nuked this must be the case where the host
            // controller has been powered off and then powered back on and
            // now an endpoint is being closed closed or paused.  
            // However since the the miniport has no reference to it on 
            // the hw we can execute the state change immediatly without
            // calling down to the miniport.

            LOGENTRY(Endpoint,
                fdoDeviceObject, LOG_XFERS, 'nukS', Endpoint, 0, State); 

            Endpoint->CurrentState = 
                Endpoint->NewState = State; 
                
            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            // endpoint needs to be checked, signal 
            // the PnP worker since this a PnP scenario
            USBPORT_InvalidateEndpoint(fdoDeviceObject,
                                       Endpoint,
                                       IEP_SIGNAL_WORKER);
                
        } else {


            RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
            //
            // set the endpoint to the requested state
            //
            MP_SetEndpointState(devExt, Endpoint, State);
        

            Endpoint->NewState = State;
            USBPORT_ASSERT(Endpoint->CurrentState != 
                Endpoint->NewState);            
            // once removed we should never change the state again            
            USBPORT_ASSERT(Endpoint->CurrentState != ENDPOINT_REMOVE);            
                
            MP_Get32BitFrameNumber(devExt, Endpoint->StateChangeFrame);    

            // insert the endpoint on our list
            
            ExInterlockedInsertTailList(&devExt->Fdo.EpStateChangeList,
                                        &Endpoint->StateLink,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);

            // request an SOF so we know when we reach the desired state
            MP_InterruptNextSOF(devExt);

        }            
    }
    
}         


MP_ENDPOINT_STATE
USBPORT_GetEndpointState(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request the state of an endpoint. 

    We assume the enpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATE state;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ACQUIRE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 
    state = Endpoint->CurrentState;
    
    if (Endpoint->CurrentState != Endpoint->NewState) {
        state = ENDPOINT_TRANSITION;
    }

    // generates noise
    LOGENTRY(Endpoint,
        fdoDeviceObject, LOG_NOISY, 'Geps', state, Endpoint, 
        Endpoint->CurrentState); 
        
    RELEASE_STATECHG_LOCK(fdoDeviceObject, Endpoint); 


    return state;
}         


VOID
USBPORT_PollEndpoint(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request a particular endpoint state.    

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(Endpoint, 
            fdoDeviceObject, LOG_XFERS, 'Pol>', Endpoint, 0, 0); 
 
    if (!(Endpoint->Flags & EPFLAG_ROOTHUB) && 
        !(Endpoint->Flags & EPFLAG_NUKED)) {
        LOGENTRY(Endpoint,
            fdoDeviceObject, LOG_XFERS, 'PolE', Endpoint, 0, 0); 
        MP_PollEndpoint(devExt, Endpoint)
    }

}         


VOID
USBPORT_InvalidateEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    ULONG IEPflags
    )
/*++

Routine Description:

    internal function, called to indicate an
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (Endpoint == NULL) {
        // check all endpoints
    
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Iall', 0, 0, 0); 
#if DBG        
        {
        LARGE_INTEGER t;            
        KeQuerySystemTime(&t);        
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'tIVE', Endpoint, 
                t.LowPart, 0);
        }                
#endif                
        
        // now walk thru and add all endpoints to the 
        // attention list
        GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

        while (listEntry && 
               listEntry != &devExt->Fdo.GlobalEndpointList) {
//            BOOLEAN check;
            
            Endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    GlobalLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckE+', Endpoint, 0, 0);                    
            ASSERT_ENDPOINT(Endpoint);                    
//xxx
//            check = TRUE;
//            if (IsListEmpty(&Endpoint->PendingList) &&
                //
//                IsListEmpty(&Endpoint->CancelList) && 
//                IsListEmpty(&Endpoint->ActiveList)) {
                
//                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckN+', Endpoint, 0, 0);
//                check = FALSE;
//            }
            
            if (!IS_ON_ATTEND_LIST(Endpoint) && 
                USBPORT_GetEndpointState(Endpoint) != ENDPOINT_CLOSED) {

                // if we are not on the list these 
                // link pointers should be NULL
                USBPORT_ASSERT(Endpoint->AttendLink.Flink == NULL);
                USBPORT_ASSERT(Endpoint->AttendLink.Blink == NULL);

                LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'at2+', Endpoint, 
                    &devExt->Fdo.AttendEndpointList, 0);      
                InsertTailList(&devExt->Fdo.AttendEndpointList, 
                               &Endpoint->AttendLink);
                               
            }                                

            listEntry = Endpoint->GlobalLink.Flink;              
        }
        
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
    
    } else {
    
        ASSERT_ENDPOINT(Endpoint);

        // insert endpoint on the 
        // 'we need to check it list'

        LOGENTRY(Endpoint,
            FdoDeviceObject, LOG_XFERS, 'IVep', Endpoint, 0, 0); 
        
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        if (!IS_ON_ATTEND_LIST(Endpoint) && 
            USBPORT_GetEndpointState(Endpoint) != ENDPOINT_CLOSED) {

            USBPORT_ASSERT(Endpoint->AttendLink.Flink == NULL);
            USBPORT_ASSERT(Endpoint->AttendLink.Blink == NULL);

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'att+', Endpoint, 
                &devExt->Fdo.AttendEndpointList, 0);  
            InsertTailList(&devExt->Fdo.AttendEndpointList, 
                           &Endpoint->AttendLink);
                           
        }    

        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
    }        

#ifdef USBPERF
    // signal or interrupt based on flags
    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        IEPflags = IEP_SIGNAL_WORKER;
    }
    
    switch (IEPflags) {
    case IEP_SIGNAL_WORKER:
        USBPORT_SignalWorker(devExt->HcFdoDeviceObject); 
        break;
    case IEP_REQUEST_INTERRUPT:        
        // skip signal and allow ISR will process the ep
        MP_InterruptNextSOF(devExt);
        break;
    }
#else 
    // note that the flags are used only in the PERF mode 
    // that reduces thread activity.
    USBPORT_SignalWorker(devExt->HcFdoDeviceObject);
#endif    
}         


VOID
USBPORTSVC_InvalidateEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    )
/*++

Routine Description:

    called by miniport to indacte a particular
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    PHCD_ENDPOINT endpoint;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    if (EndpointData == NULL) {
        // check all endpoints
        USBPORT_InvalidateEndpoint(fdoDeviceObject, NULL, IEP_REQUEST_INTERRUPT);
    } else {
        ENDPOINT_FROM_EPDATA(endpoint, EndpointData);
        USBPORT_InvalidateEndpoint(fdoDeviceObject, endpoint, IEP_REQUEST_INTERRUPT);
    }
}


VOID
USBPORTSVC_CompleteTransfer(
    PDEVICE_DATA DeviceData,
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    USBD_STATUS UsbdStatus,
    ULONG BytesTransferred
    )
/*++

Routine Description:

    called to complete a transfer

    ** Must be called in the context of PollEndpoint


Arguments:

Return Value:

    None.

--*/
{   
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PTRANSFER_URB urb;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    // spew for xfers
    USBPORT_KdPrint((2, "'--- xfer length %x (Complete)\n", 
        BytesTransferred));
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cmpT', BytesTransferred, 
        UsbdStatus, TransferParameters); 

    TRANSFER_FROM_TPARAMETERS(transfer, TransferParameters);        
    ASSERT_TRANSFER(transfer);

    SET_FLAG(transfer->Flags, USBPORT_TXFLAG_MPCOMPLETED);
   
    urb = transfer->Urb;
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cmpU', 0, 
        transfer, urb); 
    ASSERT_TRANSFER_URB(urb);
    
    transfer->MiniportBytesTransferred = 
            BytesTransferred;
        
    // insert the transfer on to our
    // 'done list' and signal the worker
    // thread

    // check for short split, if it is a short mark all 
    // transfers not called down yet 

    if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD) &&
        BytesTransferred < transfer->Tp.TransferBufferLength) {
    
        PLIST_ENTRY listEntry;
        KIRQL tIrql;
        PHCD_TRANSFER_CONTEXT tmpTransfer;
        PHCD_TRANSFER_CONTEXT splitTransfer;

        // get the parent
        splitTransfer = transfer->Transfer;
        
        ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, splitTransfer, tIrql);     
        // walk the list 

        GET_HEAD_LIST(splitTransfer->SplitTransferList, listEntry);

        while (listEntry && 
               listEntry != &splitTransfer->SplitTransferList) {
           
            tmpTransfer =  (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        SplitLink);
            ASSERT_TRANSFER(tmpTransfer); 
            
            if (!TEST_FLAG(tmpTransfer->Flags, USBPORT_TXFLAG_IN_MINIPORT)) {
                SET_FLAG(tmpTransfer->Flags, USBPORT_TXFLAG_KILL_SPLIT);
            }                

            listEntry = tmpTransfer->SplitLink.Flink; 
        
        } /* while */

        RELEASE_TRANSFER_LOCK(fdoDeviceObject, splitTransfer, tIrql);
    }

#ifdef USBPERF
    USBPORT_QueueDoneTransfer(transfer,
                              UsbdStatus);

#else 
    USBPORT_QueueDoneTransfer(transfer,
                              UsbdStatus);

    USBPORT_SignalWorker(devExt->HcFdoDeviceObject);
#endif
}    


VOID
USBPORT_Worker(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    This the 'main' passive worker function for the controller.
    From this function we process endpoints, complete transfers 
    etc.

    BUGBUG - this needs more fine tunning


Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL oldIrql;
    LIST_ENTRY busyList;

    ASSERT_PASSIVE();
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
#define IS_ON_BUSY_LIST(ep) \
    (BOOLEAN) ((ep)->BusyLink.Flink != NULL \
    && (ep)->BusyLink.Blink != NULL)

    
    MP_CheckController(devExt);

    InitializeListHead(&busyList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Wrk+', 0, 0, 
                KeGetCurrentIrql());

    // flush transfers to the hardware before calling the 
    // coreworker function, core worker only deals with 
    // active transfers so this will make sure all endpoints
    // have work to do
    USBPORT_FlushAllEndpoints(FdoDeviceObject);
    
    // now process the 'need attention' list, this is our queue 
    // of endpoints that need processing, if the endpoint is 
    // busy we will skip it.

next_endpoint:

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
    
    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'attL',
        &devExt->Fdo.AttendEndpointList, 0, 0);
    
    if (!IsListEmpty(&devExt->Fdo.AttendEndpointList)) {

        BOOLEAN busy;
        
        listEntry = RemoveHeadList(&devExt->Fdo.AttendEndpointList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    AttendLink);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'att-', endpoint, 0, 0);
        
        ASSERT_ENDPOINT(endpoint);
        endpoint->AttendLink.Flink = 
            endpoint->AttendLink.Blink = NULL;    

        KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

        busy = USBPORT_CoreEndpointWorker(endpoint, 0);  

// bugbug this causes us to reenter
        //if (!busy) {
        //    // since we polled we will want to flush complete transfers
        //    LOGENTRY(endpoint, FdoDeviceObject, LOG_XFERS, 'Wflp', endpoint, 0, 0);
        //    USBPORT_FlushDoneTransferList(FdoDeviceObject, TRUE);
        //    // we may have new transfers to map
        //   USBPORT_FlushPendingList(endpoint);
        //}            

        KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

        if (busy && !IS_ON_BUSY_LIST(endpoint)) { 
            // the enpoint was busy...
            // place it on the tail of the temp list, we will 
            // re-insert it after we process all endpoints on
            // the 'attention' list.  Note that we add these 
            // endpoints back after the process loop on the way out 
            // of the routine since it may be a while before we can 
            // process them.
            
            LOGENTRY(endpoint, 
                FdoDeviceObject, LOG_XFERS, 'art+', endpoint, 0, 0);
            InsertTailList(&busyList,                
                           &endpoint->BusyLink);
        } 

        KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);
        KeLowerIrql(oldIrql);
        
        goto next_endpoint;
    }   

    // now put all the busy endpoints back on the attention list
    while (!IsListEmpty(&busyList)) {

        listEntry = RemoveHeadList(&busyList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    BusyLink);

        endpoint->BusyLink.Flink = NULL;
        endpoint->BusyLink.Blink = NULL;
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'bus-', endpoint, 0, 0);
        
        ASSERT_ENDPOINT(endpoint);

        if (!IS_ON_ATTEND_LIST(endpoint)) {

            USBPORT_ASSERT(endpoint->AttendLink.Flink == NULL);
            USBPORT_ASSERT(endpoint->AttendLink.Blink == NULL);

            LOGENTRY(endpoint,
                FdoDeviceObject, LOG_XFERS, 'at3+', endpoint, 
                &devExt->Fdo.AttendEndpointList, 0);  
            InsertTailList(&devExt->Fdo.AttendEndpointList, 
                           &endpoint->AttendLink);
                           
            // tell worker to run again                           
            USBPORT_SignalWorker(FdoDeviceObject);
                           
        }                           
    }

    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    KeLowerIrql(oldIrql);

    USBPORT_FlushClosedEndpointList(FdoDeviceObject);

    ASSERT_PASSIVE();

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Wrk-', 0, 0, 
        KeGetCurrentIrql());
    
}


VOID
USBPORT_AbortEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PIRP Irp
    )
/*++

Routine Description:

    Abort all transfers currently queued to an endpoint.
    We lock the lists and mark all transfers in the queues
    as needing 'Abort', this will allow new transfers to be
    queued even though we are in the abort process.

    When enpointWorker encouters transfers that need to be
    aborted it takes appropriate action.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;    
    PHCD_TRANSFER_CONTEXT transfer;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // this tends to be the thread tha waits
    LOGENTRY(Endpoint, 
             FdoDeviceObject, LOG_URB, 'Abr+', Endpoint, Irp, 
             KeGetCurrentThread());

    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeB0');

    if (Irp != NULL) {
        InsertTailList(&Endpoint->AbortIrpList, 
                       &Irp->Tail.Overlay.ListEntry);
    }                               

    // mark all transfers in the queues as aborted

    // walk pending list
    GET_HEAD_LIST(Endpoint->PendingList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->PendingList) {
           
        // extract the urb that is currently on the pending 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'aPND', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    // all pending transfers are now marked aborted

    // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {
           
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'aACT', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        if (TEST_FLAG(Endpoint->Flags, EPFLAG_DEVICE_GONE)) {
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_DEVICE_GONE);
        }            
       
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    LOGENTRY(Endpoint, FdoDeviceObject, LOG_URB, 'aBRm', 0, 0, 0);    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeB0');

    // since we may need to change state, request an interrupt 
    // to start the process
    USBPORT_InvalidateEndpoint(FdoDeviceObject, 
                               Endpoint, 
                               IEP_REQUEST_INTERRUPT);

    // call the endpoint worker function
    // to process transfers for this endpoint,
    // this will flush them to the cancel list
    USBPORT_FlushPendingList(Endpoint, -1);

    USBPORT_FlushCancelList(Endpoint);

}


ULONG
USBPORT_KillEndpointActiveTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Abort all transfers marked 'active' for an endpoint.  This function
    is used to flush any active transfers still on the hardware before
    suspending the controller or turning it off.

    Note that pending tranfers are still left queued.

Arguments:

Return Value:

    returns a count of transfers flushed

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;    
    PHCD_TRANSFER_CONTEXT transfer;
    ULONG count = 0;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
 
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'KIL+', Endpoint, 0, 0);

    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeP0');

    // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {

        count++;
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'kACT', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'KILm', 0, 0, 0);    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeP0');

    USBPORT_FlushPendingList(Endpoint, -1);
    
    USBPORT_FlushCancelList(Endpoint);    

    return count;
}


VOID
USBPORT_FlushController(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Flush all active tranfers off the hardware 

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    ULONG count;
    LIST_ENTRY tmpList;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    do {

        count = 0;
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Kall', 0, 0, 0); 

        InitializeListHead(&tmpList);

        // copy the global list
        GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

        while (listEntry && 
               listEntry != &devExt->Fdo.GlobalEndpointList) {
            MP_ENDPOINT_STATE currentState;
            
            endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    GlobalLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'xxE+', endpoint, 0, 0);                    
            ASSERT_ENDPOINT(endpoint);                    

            currentState = USBPORT_GetEndpointState(endpoint);
            if (currentState != ENDPOINT_REMOVE && 
                currentState != ENDPOINT_CLOSED) {
                // skip removed endpoints as these will be going away

                // this will stall future attempts to close the 
                // endpoint
                InterlockedIncrement(&endpoint->Busy);
                InsertTailList(&tmpList, &endpoint->KillActiveLink);
            }                

            listEntry = endpoint->GlobalLink.Flink;      
         
        }

        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

        while (!IsListEmpty(&tmpList)) {

            listEntry = RemoveHeadList(&tmpList);
        
            endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    KillActiveLink);
                      
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'kiE+', endpoint, 0, 0);                    
            ASSERT_ENDPOINT(endpoint);                    

            count += USBPORT_KillEndpointActiveTransfers(FdoDeviceObject,
                                                         endpoint);

            InterlockedDecrement(&endpoint->Busy);
        }

        if (count != 0) {
            USBPORT_Wait(FdoDeviceObject, 100);        
        }
        
    } while (count != 0);
    
}


VOID
USBPORT_FlushAbortList(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Complete any pending abort requests we have 
    if no transfers are marked for aborting.
    

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer = NULL;
    PLIST_ENTRY listEntry;
    PDEVICE_OBJECT fdoDeviceObject;
    BOOLEAN abortsPending = FALSE;
    PIRP irp;
    LIST_ENTRY tmpList;
    NTSTATUS ntStatus;
    PURB urb;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'fABr', Endpoint, 0, 0);

    InitializeListHead(&tmpList);

    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'LeC0');

    if (!IsListEmpty(&Endpoint->AbortIrpList)) {

        GET_HEAD_LIST(Endpoint->PendingList, listEntry);
    
        while (listEntry && 
            listEntry != &Endpoint->PendingList) {
           
            // extract the urb that is currently on the pending 
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'cPND', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            if (transfer->Flags & USBPORT_TXFLAG_ABORTED) {
                abortsPending = TRUE;
            }
            
            listEntry = transfer->TransferLink.Flink; 
            
        } /* while */

        // walk active list
        GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

        while (listEntry && 
               listEntry != &Endpoint->ActiveList) {
               
            // extract the urb that is currently on the active 
            transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
            LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'cACT', transfer, 0, 0);                    
            ASSERT_TRANSFER(transfer);                    

            if (transfer->Flags & USBPORT_TXFLAG_ABORTED) {
                LOGENTRY(Endpoint, fdoDeviceObject, LOG_IRPS, 'aACT', transfer, 0, 0);
                abortsPending = TRUE;
            }
            
            listEntry = transfer->TransferLink.Flink; 
            
        } /* while */

    }

    if (abortsPending == FALSE) {

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'abrP', 0, 0, 0); 
        
        while (!IsListEmpty(&Endpoint->AbortIrpList)) {
        
            listEntry = RemoveHeadList(&Endpoint->AbortIrpList);

            irp = (PIRP) CONTAINING_RECORD(
                    listEntry,
                    struct _IRP, 
                    Tail.Overlay.ListEntry);                                    

            // put it on our list to complete
            InsertTailList(&tmpList, 
                           &irp->Tail.Overlay.ListEntry);

        }
    }

    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeC0');

    // now complete the requests
    while (!IsListEmpty(&tmpList)) {
        PUSBD_DEVICE_HANDLE deviceHandle;
        
        listEntry = RemoveHeadList(&tmpList);

        irp = (PIRP) CONTAINING_RECORD(
                listEntry,
                struct _IRP, 
                Tail.Overlay.ListEntry);         

        urb = USBPORT_UrbFromIrp(irp);                    

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'aaIP', irp, 0, urb); 

        ntStatus = SET_USBD_ERROR(urb, USBD_STATUS_SUCCESS);   

        GET_DEVICE_HANDLE(deviceHandle, urb);
        ASSERT_DEVICE_HANDLE(deviceHandle);
        InterlockedDecrement(&deviceHandle->PendingUrbs);

        LOGENTRY(NULL, fdoDeviceObject, LOG_IRPS, 'abrC', irp, 0, 0);             
        USBPORT_CompleteIrp(devExt->Fdo.RootHubPdo, irp, ntStatus, 0);                        
                
    }

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'abrX', 0, 0, 0); 
    
}


BOOLEAN
USBPORT_EndpointHasQueuedTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Returns TRUE if endpoint has transfers queued
    
Arguments:

Return Value:

    True if endpoint has transfers queued

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN hasTransfers = FALSE;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
 
    ASSERT_ENDPOINT(Endpoint);

    // lock the endpoint 

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeI0');

    if (!IsListEmpty(&Endpoint->PendingList)) {
        hasTransfers = TRUE;
    }

    if (!IsListEmpty(&Endpoint->ActiveList)) {
        hasTransfers = TRUE;
    }
    
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeI0');

    return hasTransfers;
}


MP_ENDPOINT_STATUS
USBPORT_GetEndpointStatus(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Request the state of an endpoint. 

    We assume the enpoint lock is held

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATUS status;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    ASSERT_ENDPOINT_LOCKED(Endpoint);

    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        status = ENDPOINT_STATUS_RUN;
    } else {
        MP_GetEndpointStatus(devExt, Endpoint, status);
    }        
    
    Endpoint->CurrentStatus = status;            

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'Gept', status, Endpoint, 
        0); 

    return status;
}         


VOID
USBPORT_NukeAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    internal function, called to indicate an
    endpoint needs attention

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

  // check all endpoints
    
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'Nall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'ckN+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        // this endpoins HW context has 
        // been lost
        if (!TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            SET_FLAG(endpoint->Flags, EPFLAG_NUKED);
        }            

        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

}    


VOID
USBPORT_TimeoutAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Called from deadman DPC, processes timeouts for all 
    endpoints in the system.

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    LIST_ENTRY tmpList;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    // local down the global list while we build the temp list
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
    
    InitializeListHead(&tmpList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Tall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->TimeoutLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->TimeoutLink.Blink == NULL);

        if (USBPORT_GetEndpointState(endpoint) != ENDPOINT_CLOSED) {
            InsertTailList(&tmpList, &endpoint->TimeoutLink);                    
        }            
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    while (!IsListEmpty(&tmpList)) {
    
        listEntry = RemoveHeadList(&tmpList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    TimeoutLink);

        endpoint->TimeoutLink.Flink = 
            endpoint->TimeoutLink.Blink = NULL;
            
        USBPORT_EndpointTimeout(FdoDeviceObject, endpoint);
       
    }

}    


VOID
USBPORT_FlushAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    LIST_ENTRY tmpList;
    BOOLEAN flush;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // check all endpoints

    // local down the global list while we build the temp list
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
    
    InitializeListHead(&tmpList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'Fall', 0, 0, 0); 
    
    // now walk thru and add all endpoints to the 
    // attention list
    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->FlushLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->FlushLink.Blink == NULL);

        if (USBPORT_GetEndpointState(endpoint) != ENDPOINT_CLOSED) {
            InsertTailList(&tmpList, &endpoint->FlushLink);                    
        }            
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    while (!IsListEmpty(&tmpList)) {
    
        listEntry = RemoveHeadList(&tmpList);
        
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    FlushLink);

        endpoint->FlushLink.Flink = 
            endpoint->FlushLink.Blink = NULL;

        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le70');
        flush = !IsListEmpty(&endpoint->PendingList);
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le70');

        if (flush) {                            
            USBPORT_FlushPendingList(endpoint, -1);
        }            
       
    }
}    


VOID
USBPORT_EndpointTimeout(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Checks tinmeout status for pending requests

Arguments:

Return Value:

    None.

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PLIST_ENTRY listEntry;
    BOOLEAN timeout = FALSE;
    
    // on entry the urb is not cancelable ie
    // no cancel routine

    ASSERT_ENDPOINT(Endpoint);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'toEP', 0, Endpoint, 0);
            
    // take the endpoint spinlock
    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 0);

     // walk active list
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {

        LARGE_INTEGER systemTime;
        
        // extract the urb that is currently on the active 
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'ckTO', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        KeQuerySystemTime(&systemTime);

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_IN_MINIPORT) &&
            transfer->MillisecTimeout != 0 &&
            systemTime.QuadPart > transfer->TimeoutTime.QuadPart) {

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'txTO', transfer, 0, 0); 
            DEBUG_BREAK();
            
            // mark the transfer as aborted
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED);
            SET_FLAG(transfer->Flags, USBPORT_TXFLAG_TIMEOUT);
        
            // set the millisec timeout to zero so we 
            // don't time it out again.
            transfer->MillisecTimeout = 0;
            timeout = TRUE;
        }    
        
        listEntry = transfer->TransferLink.Flink; 
        
    } /* while */

    // release the endpoint lists
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 0);

    if (timeout) {
        USBPORT_InvalidateEndpoint(FdoDeviceObject,
                                   Endpoint,
                                   IEP_SIGNAL_WORKER);
    }                                           
}


VOID
USBPORT_DpcWorker(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    This worker function is called in the context of the ISRDpc
    it is used to process high priority endpoints.

    THIS ROUTINE RUNS AT DISPATCH LEVEL

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL irql;
    LIST_ENTRY workList;
    BOOLEAN process;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    InitializeListHead(&workList);

    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'DPw+', 0, 0, 0);

    // loop thru all the endpoints and find candidates for 
    // priority processing
    
    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    GET_HEAD_LIST(devExt->Fdo.GlobalEndpointList, listEntry);

    while (listEntry && 
           listEntry != &devExt->Fdo.GlobalEndpointList) {

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                listEntry,
                struct _HCD_ENDPOINT, 
                GlobalLink);
                  
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'wkE+', endpoint, 0, 0);                    
        ASSERT_ENDPOINT(endpoint);                    

        USBPORT_ASSERT(endpoint->PriorityLink.Flink == NULL); 
        USBPORT_ASSERT(endpoint->PriorityLink.Blink == NULL);

        busy = InterlockedIncrement(&endpoint->Busy);
    
        if (USBPORT_GetEndpointState(endpoint) == ENDPOINT_ACTIVE && 
            (endpoint->Parameters.TransferType == Isochronous ||
             endpoint->Parameters.TransferType == Interrupt ||
             endpoint->Parameters.TransferType == Bulk ||
             endpoint->Parameters.TransferType == Control) &&
             busy == 0 && 
             !TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            
            InsertTailList(&workList, &endpoint->PriorityLink);                    
        }  else {   
            // endpoint is busy leave it for now
            InterlockedDecrement(&endpoint->Busy);
        }
        
        listEntry = endpoint->GlobalLink.Flink;              
        
    }


    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.EndpointListSpin.sl);

    // work list conatins endpoints that need processing 
    
    while (!IsListEmpty(&workList)) {

        listEntry = RemoveHeadList(&workList);

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    PriorityLink);

        endpoint->PriorityLink.Flink = NULL;
        endpoint->PriorityLink.Blink = NULL;
        
        ASSERT_ENDPOINT(endpoint);

        // we have a candidate, see if we really need to process it
        process = TRUE;
        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Le20');

  
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Ue23');

        if (process) {

            // run the worker routine -- this posts new
            // transfers to the hardware and polls the 
            // enpoint

            USBPORT_CoreEndpointWorker(endpoint, CW_SKIP_BUSY_TEST);  

            // flush more transfers to the hardware, this will 
            // call CoreWorker a second time
            USBPORT_FlushPendingList(endpoint, -1);
        }
    }  

    // now flush done transfers, since we are in 
    // the context of a hardware interrrupt we 
    // should have some completed transfers. Although
    // a DPC was queued we want to flush now

    USBPORT_FlushDoneTransferList(FdoDeviceObject);
}

#ifdef LOG_OCA_DATA
VOID
USBPORT_RecordOcaData(
    PDEVICE_OBJECT FdoDeviceObject,
    POCA_DATA OcaData,
    PHCD_TRANSFER_CONTEXT Transfer,
    PIRP Irp
    )
/*++

Routine Description:

    Record some data on the stack we can use for crash analysis
    in a minidump

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG i;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    OcaData->OcaSig1 = SIG_USB_OCA1;

    OcaData->Irp = Irp;

    for (i=0; i< USB_DRIVER_NAME_LEN; i++) {
        OcaData->AnsiDriverName[i] = (UCHAR) Transfer->DriverName[i];
    }
    
    OcaData->DeviceVID = Transfer->DeviceVID;
    OcaData->DevicePID = Transfer->DevicePID;

    // probably need vid/pid/rev for HC as well
    OcaData->HcFlavor = devExt->Fdo.HcFlavor;
        
    OcaData->OcaSig2 = SIG_USB_OCA2;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\config.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    config.c

Abstract:

    handles configuration and interface URBs

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, USBPORT_SelectInterface)
#pragma alloc_text(PAGE, USBPORT_SelectConfiguration)
#pragma alloc_text(PAGE, USBPORT_InitializeConfigurationHandle)
#pragma alloc_text(PAGE, USBPORT_InternalOpenInterface)
#pragma alloc_text(PAGE, USBPORT_InternalCloseConfiguration)
#pragma alloc_text(PAGE, USBPORT_InternalParseConfigurationDescriptor)
#pragma alloc_text(PAGE, USBPORT_InternalGetInterfaceLength)
#endif

// non paged functions

USBD_PIPE_TYPE PipeTypes[4] = {UsbdPipeTypeControl, UsbdPipeTypeIsochronous,
                                    UsbdPipeTypeBulk, UsbdPipeTypeInterrupt};


NTSTATUS
USBPORT_SelectInterface(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Select an alternate interface for a USB device.  The orginal 
    USBD code only supported selecting a single alternate interface
    so we will as well.

    Client will(should) pass in a URB buffer that looks like this:

    +------------------------------+
    |Hdr                           |
    |(_URB_HEADER)                 |
    |    - <caller inputs>         |
    |      Function                |
    |      Length                  |
    |      UsbdDeviceHandle        |
    |                              |
    |    - <port outputs>          |
    |        Status                |
    +------------------------------+
    |    - <caller inputs>         |
    |      ConfigurationHandle     |
    +------------------------------+
    |Interface                     |
    |(USBD_INTERFACE_INFORMATION)  |
    |    - <caller inputs>         |
    |      Length                  |
    |      InterfaceNumber         |  
    |      AlternateSetting        |
    |                              |
    |    - <port  outputs>         |
    |      InterfaceHandle         |
    |      NumberOfPipes           |
    |      SubClass                |
    |      Class                   |
    |      Protocol                |
    +------------------------------+
    |Pipes[0]                      | one of these for each pipe in the
    |(USBD_PIPE_INFORMATION)       | interface
    |    - <caller inputs>         |
    |      PipeFlags               |      
    |      MaximumPacketSize (opt) |
    |                              |
    |    - <port outputs>          |
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+ 

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    ULONG i;
    PDEVICE_EXTENSION devExt;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PUSBD_INTERFACE_INFORMATION interfaceI;
    PUSBD_INTERFACE_HANDLE_I iHandle, iHandleNew;
    USHORT tmp;
    USBD_STATUS usbdStatus;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    LOCK_DEVICE(deviceHandle, FdoDeviceObject);

    // validate the configuration handle input    
    configHandle = Urb->UrbSelectInterface.ConfigurationHandle;
    ASSERT_CONFIG_HANDLE(configHandle);

    //
    // will are interested in the alt setting of a specific 
    // interface based on the interface number.
    //

    iHandle = NULL;
    interfaceI = &Urb->UrbSelectInterface.Interface;

    // validate the Length field in the Urb header, we can
    // figure out the correct value based on the interface 
    // information passed in
    tmp = interfaceI->Length + sizeof(struct _URB_HEADER)
        + sizeof(configHandle);

    if (tmp != Urb->UrbHeader.Length) {
        // client passed in bogus total length, warn if in 
        // 'verifier' mode.
        
        USBPORT_DebugClient(
                ("client driver passed invalid Urb.Header.Length\n"));

        // generally cleints mess up the header length so 
        // we will override with the length we calculated 
        // from the interface-information.

        Urb->UrbHeader.Length = tmp;
    }

    // validate the interfaceI structure passed to us by the client
    usbdStatus = USBPORT_InitializeInterfaceInformation(FdoDeviceObject,
                                                        interfaceI,
                                                        configHandle);
    
    if (usbdStatus == USBD_STATUS_SUCCESS) {

        // find the interface handle for the interface we are 
        // interested in, if it is currently open we will need
        // to close it.

        iHandle = USBPORT_GetInterfaceHandle(FdoDeviceObject,
                                             configHandle,
                                             interfaceI->InterfaceNumber);

        if (iHandle != NULL) {

            // unlink this handle
            RemoveEntryList(&iHandle->InterfaceLink);

            // we have a handle

            ASSERT_INTERFACE(iHandle);     

            // close the pipes in this interface, note that we 
            // force the pipes closed unlike past versions of 
            // USBD and force the client driver to deal with the
            // consequences if it has transfers outstanding.

            // attempt to close all endpoints in this interface
            for (i=0; i < iHandle->InterfaceDescriptor.bNumEndpoints; i++) {

                USBPORT_ClosePipe(deviceHandle,
                                  FdoDeviceObject,
                                  &iHandle->PipeHandle[i]);
            }
        }

        //
        // Now open the new interface with the new alternate setting
        //

        iHandleNew = NULL;
        usbdStatus = USBPORT_InternalOpenInterface(Urb,
                                                   deviceHandle,
                                                   FdoDeviceObject,
                                                   configHandle,
                                                   interfaceI,
                                                   &iHandleNew,
                                                   TRUE);
    }

    if (usbdStatus == USBD_STATUS_SUCCESS) {

        //
        // successfully opened the new interface,
        // we can free the old handle now if we 
        // had one.
        //
        if (iHandle != NULL ) {
#if DBG
            // all pipes should be closed
            for (i=0; i < iHandle->InterfaceDescriptor.bNumEndpoints; i++) {
                USBPORT_ASSERT(iHandle->PipeHandle[i].ListEntry.Flink == NULL &&
                               iHandle->PipeHandle[i].ListEntry.Blink == NULL);
            }
#endif
            FREE_POOL(FdoDeviceObject, iHandle);
            iHandle = NULL;
        }            

        // return the 'new' handle
        interfaceI->InterfaceHandle = iHandleNew;

        // associate it with this configuration
        InsertTailList(&configHandle->InterfaceHandleList,
                       &iHandleNew->InterfaceLink);

    } else {

        //
        // selecting the aternate interface failed.
        // Possible reasons:
        //
        // 1. we didn't have enough BW
        // 2. the device stalled the set_interface request
        // 3. The set_interface request failed because the
        //      device is gone
        // 4. USBPORT_InitializeInterfaceInformation() failed due
        //      bad parameters.

        // attempt to re-open the original alt-interface so that 
        // the client still has the bandwidth

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'slI!', 
            usbdStatus,
            0,
            0);  
            
        if (usbdStatus == USBD_STATUS_NO_BANDWIDTH) {

            // HISTORICAL NOTE:
            // The 2k USBD driver attempted to re-open the original
            // alt-setting on a failure to allocate bw.  This would 
            // leave the client with the bw it had when calling in
            // to select the new interface.   
            //
            // I don't beleive that any drivers use this feature 
            // and many drivers attempt to allocate BW in a loop 
            // until they succeed.  
            //
            // So as a performance optimization we will return 
            // with no bandwidth allocated to the caller -- the 
            // pipe handles will be invalid. 
            // This should speed things up since the realloc of
            // the old bandwidth takes time.
            interfaceI->InterfaceHandle = USBPORT_BAD_HANDLE;
        
        } else {
            // case 2,3 we just fail the request and set the interface 
            // handle to 'bad handle'
            interfaceI->InterfaceHandle = USBPORT_BAD_HANDLE;
        }

        // client has no reference to it and we closed it 
        // free the structure here
        if (iHandle != NULL ) {
#if DBG
            // all pipes should be closed
            for (i=0; i < iHandle->InterfaceDescriptor.bNumEndpoints; i++) {
                USBPORT_ASSERT(iHandle->PipeHandle[i].ListEntry.Flink == NULL &&
                               iHandle->PipeHandle[i].ListEntry.Blink == NULL);
            }
#endif
            FREE_POOL(FdoDeviceObject, iHandle);
            iHandle = NULL;
        }            
        
    }
    
    UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

    ntStatus = SET_USBD_ERROR(Urb, usbdStatus);   
    
    return ntStatus;

}


NTSTATUS
USBPORT_SelectConfiguration(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Open a configuration for a USB device.

    Client will(should) pass in a URB buffer that looks like this:

    +------------------------------+
    |Hdr                           |
    |(_URB_HEADER)                 |
    |    - <caller inputs>         |
    |      Function                |
    |      Length                  |
    |      UsbdDeviceHandle        |
    |                              |
    |    - <port outputs>          |
    |       Status                 |
    +------------------------------+
    |    - <caller inputs>         |
    |      ConfigurationDescriptor |
    |    - <port outputs>          |
    |      ConfigurationHandle     |
    +------------------------------+
    |Interface(0)                  |
    |(USBD_INTERFACE_INFORMATION)  |
    |    - <caller inputs>         |
    |      Length                  |
    |      InterfaceNumber         |  
    |      AlternateSetting        |
    |                              |
    |    - <port  outputs>         |
    |      InterfaceHandle         |
    |      NumberOfPipes           |
    |      SubClass                |
    |      Class                   |
    |      Protocol                |
    +------------------------------+
    |Pipes[0]                      | one of these for each pipe in the
    |(USBD_PIPE_INFORMATION)       | interface
    |    - <caller inputs>         |
    |                              |      
    |    - <port outputs>          |
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+ 
    | Interface(1)                 | one of these for each interface in 
    |                              | the configuration
    +------------------------------+
    |Pipes[1]                      |
    +------------------------------+
    |....                          |
    +------------------------------+
    |Pipes[n]                      |
    +------------------------------+
    
    On input:
    The ConfigurationDescriptor must specify the number of interfaces
    in the configuration.

    The InterfaceInformation will specify a specific alt setting to be 
    selected for each interface.

    1. First we look at the configuration descriptor for the
        requested configuration and validate the client
        input buffer agianst it.

    2. We open the interfaces for the requested configuration
        and open the pipes within those interfaces, setting
        alt settings were appropriate.

    3. We set the configuration for the device with the
        appropriate control request.

Arguments:

    DeviceObject -

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceInformation;
    PUCHAR pch;
    ULONG i;
    PDEVICE_EXTENSION devExt;
    ULONG numInterfaces;
    PUCHAR end;
    PUSBD_DEVICE_HANDLE deviceHandle;
    USBD_STATUS usbdStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    PAGED_CODE();
    USBPORT_KdPrint((2, "' enter USBPORT_SelectConfiguration\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    GET_DEVICE_HANDLE(deviceHandle, Urb);
    LOCK_DEVICE(deviceHandle, FdoDeviceObject);

    ntStatus = STATUS_BOGUS;

    // BUGBUG 
    // flush all current transfers or fail?

    //
    // dump old configuration data if we have any
    //

    if (deviceHandle->ConfigurationHandle) {
    
        // This is where we close the old configuration
        // handle, all pipes and all interfaces.

        USBPORT_InternalCloseConfiguration(deviceHandle,
                                           FdoDeviceObject,
                                           0);
    }

    // now set up the new configuration
    
    configurationDescriptor =
        Urb->UrbSelectConfiguration.ConfigurationDescriptor;

    //
    // if null pased in set configuration to 0
    // 'unconfigured'
    //

    if (configurationDescriptor == NULL) {

        // device needs to be in the unconfigured state

        //
        // NOTE:
        // this may fail if the configuration is being
        // closed as the result of the device being unplugged
        // so we ignore the error
        //

        USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                0, // wValue
                0, // wIndex
                0); // wLength
        
        USBPORT_SendCommand(deviceHandle,
                           FdoDeviceObject,
                           &setupPacket,
                           NULL,
                           0,
                           NULL,
                           NULL);

        ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);                           

        goto USBD_SelectConfiguration_Done;
        
    } else {
        // validate the config descriptor by accessing it 
        //
        // Note: that we we will still crash here if the config 
        // descriptor is invalid. However is will be easiser to 
        // debug this way.
        //
        // 
        // 
        
        PUCHAR tmp;
        UCHAR ch;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'vCNF', 
            configurationDescriptor,
            0,
            0);                           
                   
        // first a quick sanity check, it must be non-zero
        if (configurationDescriptor->wTotalLength == 0) {
            // this is bogus
            ntStatus = SET_USBD_ERROR(Urb, 
                USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR);
                
            goto USBD_SelectConfiguration_Done;        
            
        } else {
            // touch first and last byte, this wil fault if invalid.
            
            tmp = (PUCHAR) configurationDescriptor;
            ch = *tmp;
            tmp += configurationDescriptor->wTotalLength-1;
            ch = *tmp;
            
        } 

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'CFok', 
            configurationDescriptor,
            0,
            0); 
    }

    //
    // count the number of interfaces to process in this
    // request
    //

    pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
    numInterfaces = 0;
    end = ((PUCHAR) Urb) + Urb->UrbSelectConfiguration.Hdr.Length;

    do {
        numInterfaces++;

        interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;
        pch+=interfaceInformation->Length;

    } while (pch < end);

    USBPORT_KdPrint((2, "'USBD_SelectConfiguration -- %d interfaces\n", 
        numInterfaces));

    // sanity check the config descriptor with the URB request
    if (numInterfaces != configurationDescriptor->bNumInterfaces ||
        numInterfaces == 0) {
        //
        // driver is broken, config request does not match
        // config descriptor passed in!!!
        //
        USBPORT_DebugClient((
            "config request does not match config descriptor\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR);             

        TC_TRAP();             
        
        goto USBD_SelectConfiguration_Done;        
    }

    //
    // Allocate a configuration handle and
    // verify there is enough room to store
    // all the information in the client buffer.
    //

    configHandle = USBPORT_InitializeConfigurationHandle(deviceHandle,
                                                         FdoDeviceObject,
                                                         configurationDescriptor);
    if (configHandle == NULL) {
        USBPORT_DebugClient((
            "failed to allocate config handle\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_INSUFFICIENT_RESOURCES);             
        
        goto USBD_SelectConfiguration_Done;      
    }

    //
    // Send the 'set configuration' command
    //

    USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                configurationDescriptor->bConfigurationValue, // wValue
                0, // wIndex
                0); // wLength
      

    USBPORT_SendCommand(deviceHandle,
                       FdoDeviceObject,
                       &setupPacket,
                       NULL,
                       0,
                       NULL,
                       &usbdStatus);

    USBPORT_KdPrint((2,"' SendCommand, SetConfiguration returned 0x%x\n", usbdStatus));
                        
    if (USBD_ERROR(usbdStatus)) {
        USBPORT_DebugClient((
            "failed to 'set' the configuration\n"));
        ntStatus = SET_USBD_ERROR(Urb, 
            USBD_STATUS_SET_CONFIG_FAILED);             
        TC_TRAP();             
        goto USBD_SelectConfiguration_Done;      
    }

    USBPORT_ASSERT(ntStatus == STATUS_BOGUS);

    // we have "configured" the device in the USB sense.

    //
    // User buffer checks out and we have 'configured' 
    // the device.
    // Now parse thru the configuration descriptor  
    // and open the interfaces.
    //
    // The URB contains a set of INTERFACE_INFORMATION
    // structures these give us the information we need
    // to open the pipes
    /*        
    
    _USBD_INTERFACE_INFORMATION 
    client should have filled in:
    
    USHORT Length;     
    UCHAR InterfaceNumber;
    UCHAR AlternateSetting;

    we fill in :
    UCHAR Class;
    UCHAR SubClass;
    UCHAR Protocol;
    UCHAR Reserved;

    USBD_INTERFACE_HANDLE InterfaceHandle;
    ULONG NumberOfPipes; 

    */
    
    pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
    
    for (i=0; i<numInterfaces; i++) {
        PUSBD_INTERFACE_HANDLE_I interfaceHandle;
        // open the interface
        
        interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;

        usbdStatus = USBPORT_InitializeInterfaceInformation(
                        FdoDeviceObject,
                        interfaceInformation,
                        configHandle);
                        
        interfaceHandle = NULL;
        if (usbdStatus == USBD_STATUS_SUCCESS) {
            
            // this function allocates the actual 'handle'
            usbdStatus = USBPORT_InternalOpenInterface(Urb,
                                                       deviceHandle,
                                                       FdoDeviceObject,
                                                       configHandle,
                                                       interfaceInformation,
                                                       &interfaceHandle,
                                                       TRUE);
            USBPORT_KdPrint((2, "' InternalOpenInterface returned(USBD) 0x%x\n", 
                usbdStatus));
        }
        
        pch+=interfaceInformation->Length;

        // if we got back a handle add it to the list
        if (interfaceHandle != NULL) {
            InsertTailList(&configHandle->InterfaceHandleList,
                           &interfaceHandle->InterfaceLink);
        }

        if (!USBD_SUCCESS(usbdStatus)) {
            
            ntStatus = SET_USBD_ERROR(Urb, usbdStatus);
            
            // we have an error opening the interface
            DEBUG_BREAK();
            TC_TRAP();
            goto USBD_SelectConfiguration_Done;
        }
    }

    //
    // interfaces were successfully set up then return success.
    //
    
    ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);   

USBD_SelectConfiguration_Done:

    if (NT_SUCCESS(ntStatus)) { 

        USBPORT_ASSERT(Urb->UrbSelectConfiguration.Hdr.Status == 
            USBD_STATUS_SUCCESS);

        Urb->UrbSelectConfiguration.ConfigurationHandle = 
            configHandle;
        
        // remember the current configuration
        deviceHandle->ConfigurationHandle = configHandle;

    } else {

        //
        // something failed, clean up before we return an error.
        //

        if (configHandle) {

            TC_TRAP();
            ASSERT_DEVICE_HANDLE(deviceHandle);
            
            //
            // if we have a configHandle then we need to free it
            deviceHandle->ConfigurationHandle =
                configHandle;

            //
            // attempt to close it
            //
            
            USBPORT_InternalCloseConfiguration(deviceHandle,
                                               FdoDeviceObject,
                                               0);

            deviceHandle->ConfigurationHandle = NULL;
        }

        // make sure we return an error in the URB.
        USBPORT_ASSERT(Urb->UrbSelectConfiguration.Hdr.Status != 
            USBD_STATUS_SUCCESS);
        USBPORT_KdPrint((2, "'Failing SelectConfig\n"));
    }

    UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

    USBPORT_KdPrint((2, "'exit SelectConfiguration 0x%x\n", ntStatus));

    return ntStatus;
}


PUSBD_CONFIG_HANDLE
USBPORT_InitializeConfigurationHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++

Routine Description:

    Initialize the configuration handle structure.

    Given a (hopefully) valid configuration descriptor
    and a count of the interfaces create the configuration
    handle for the device

Arguments:

Return Value:


--*/
{
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    ULONG i;
    PUCHAR pch;

    PAGED_CODE();
    USBPORT_ASSERT(ConfigurationDescriptor->bNumInterfaces > 0);
    
    USBPORT_KdPrint((2, "' enter InitializeConfigurationHandle\n"));
    
    // get enough space for each interface
    ALLOC_POOL_Z(configHandle, 
                 NonPagedPool,
                 sizeof(USBD_CONFIG_HANDLE) +
                 ConfigurationDescriptor->wTotalLength);

    pch = (PUCHAR)configHandle;

    if (configHandle) {

        //
        // Initilaize the interface handle list
        //

        InitializeListHead(&configHandle->InterfaceHandleList);

        configHandle->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)
                              (pch + sizeof(USBD_CONFIG_HANDLE));

        // copy the config descriptor to our handle
        
        RtlCopyMemory(configHandle->ConfigurationDescriptor,
                      ConfigurationDescriptor,
                      ConfigurationDescriptor->wTotalLength);
                      
        configHandle->Sig = SIG_CONFIG_HANDLE;

    }        

    USBPORT_KdPrint((2, "' exit InitializeConfigurationHandle 0x%x\n", 
        configHandle));

    return configHandle;
}


USBD_STATUS
USBPORT_InternalOpenInterface(
    PURB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigHandle,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    PUSBD_INTERFACE_HANDLE_I *InterfaceHandle,
    BOOLEAN SendSetInterfaceCommand
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    DeviceHandle - USBD device handle for this device.

    ConfigHandle - USBD configuration handle.

    InterfaceInformation - pointer to USBD interface information structure
        passed in by the client.
        
        We use the InterfaceNumber and AlternateSetting specified 
        in this structure to select the interface.
        
        On success the .Length field is filled in with the actual length
        of the interface_information structure and the Pipe[] fields are filled
        in with the handles for the opened pipes.

    InterfaceHandle - pointer to an interface handle pointer, filled in
        with the allocated interface handle structure if NULL, otherwise the
        structure passed in is used.

    SendSetInterfaceCommand - indicates if the set_interface command should be
        sent.

Return Value:


--*/
{
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    BOOLEAN hasAlternateSettings;
    PUSBD_INTERFACE_HANDLE_I interfaceHandle = NULL;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUCHAR pch;
    ULONG i;
    BOOLEAN allocated = FALSE;
    PUSB_COMMON_DESCRIPTOR descriptor;
    USHORT need;
    ULONG numEndpoints;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    PAGED_CODE();

    ASSERT_CONFIG_HANDLE(ConfigHandle);

    if (*InterfaceHandle != NULL) {
        // using a previously allocated interface handle
        ASSERT_INTERFACE_HANDLE(*InterfaceHandle);
        TEST_TRAP();
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'opIF', 
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting,
        *InterfaceHandle);

    USBPORT_KdPrint((2, "' enter InternalOpenInterface\n"));
    USBPORT_KdPrint((2, "' Interface %d Altsetting %d\n",
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting));

    //
    // Find the interface descriptor we are interested in inside
    // the configuration descriptor.
    //

    interfaceDescriptor =
        USBPORT_InternalParseConfigurationDescriptor(ConfigHandle->ConfigurationDescriptor,
                                          InterfaceInformation->InterfaceNumber,
                                          InterfaceInformation->AlternateSetting,
                                          &hasAlternateSettings);

    // we already validated this, if it is NULL 
    // the function has a bug.
    USBPORT_ASSERT(interfaceDescriptor != NULL);
    if (interfaceDescriptor == NULL) {
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, (ULONG_PTR) DeviceHandle, 0, 0);
        // keep prefix scanner happy
        return USBD_STATUS_SUCCESS;        
    }
    
    //
    // We got the interface descriptor, now try
    // to open all the pipes.
    //

    // found the requested interface in the configuration descriptor.


    numEndpoints = interfaceDescriptor->bNumEndpoints;
    need = (USHORT) (((numEndpoints-1) * sizeof(USBD_PIPE_INFORMATION) +
            sizeof(USBD_INTERFACE_INFORMATION)));
            
    // we should have already validated this
    USBPORT_ASSERT(InterfaceInformation->Length == need);

    if (hasAlternateSettings && 
        SendSetInterfaceCommand) {

        NTSTATUS ntStatus;
        //
        // If we have alternate settings we need
        // to send the set interface command.
        //

        USBPORT_INIT_SETUP_PACKET(setupPacket,
            USB_REQUEST_SET_INTERFACE, // bRequest
            BMREQUEST_HOST_TO_DEVICE, // Dir
            BMREQUEST_TO_INTERFACE, // Recipient
            BMREQUEST_STANDARD, // Type
            InterfaceInformation->AlternateSetting, // wValue
            InterfaceInformation->InterfaceNumber, // wIndex
            0); // wLength
  

        ntStatus = USBPORT_SendCommand(DeviceHandle,
                           FdoDeviceObject,
                           &setupPacket,
                           NULL,
                           0,
                           NULL,
                           &usbdStatus);

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'seIF', 
            ntStatus,
            InterfaceInformation->AlternateSetting,
            InterfaceInformation->InterfaceNumber);                           
                           
        if (USBD_ERROR(usbdStatus)) {                               
            DEBUG_BREAK();
            goto USBPORT_InternalOpenInterface_Done;    
        }

        USBPORT_ASSERT(ntStatus == STATUS_SUCCESS);
        
    }

    //
    // we successfully selected the alternate interface
    // initialize the interface handle and open the pipes
    //

    if (*InterfaceHandle == NULL) {
    
        ULONG privateLength = sizeof(USBD_INTERFACE_HANDLE_I) +
                              sizeof(USBD_PIPE_HANDLE_I) * numEndpoints;

        // allow space for a copy of the USBD_INTERFACE_INFORMATION
        // that is returned to the client
        ALLOC_POOL_Z(interfaceHandle, 
                     NonPagedPool,
                     privateLength);
                              
        if (interfaceHandle != NULL) {
            // initialize the pipe handles to a known state
            for (i=0; i<numEndpoints; i++) {
                interfaceHandle->PipeHandle[i].Endpoint = NULL;
                interfaceHandle->PipeHandle[i].Sig = SIG_PIPE_HANDLE;
                interfaceHandle->PipeHandle[i].PipeStateFlags = 
                    USBPORT_PIPE_STATE_CLOSED;
                //interfaceHandle->PipeHandle[i].ListEntry.Flink = NULL;
                //interfaceHandle->PipeHandle[i].ListEntry.Blink = NULL;    
            }        
            allocated = TRUE;
        } else {
            
            usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;                    
                 
            goto USBPORT_InternalOpenInterface_Done;
        }
        
    } else {
        // using old handle
        interfaceHandle = *InterfaceHandle;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'ihIF', 
            interfaceHandle,
            0,
            0);   

    USBPORT_ASSERT(interfaceHandle != NULL);
    
    interfaceHandle->Sig = SIG_INTERFACE_HANDLE;
    interfaceHandle->HasAlternateSettings = hasAlternateSettings;

    InterfaceInformation->NumberOfPipes = 
        interfaceDescriptor->bNumEndpoints;
    InterfaceInformation->Class =
        interfaceDescriptor->bInterfaceClass;
    InterfaceInformation->SubClass =
        interfaceDescriptor->bInterfaceSubClass;
    InterfaceInformation->Protocol =
        interfaceDescriptor->bInterfaceProtocol;
    InterfaceInformation->Reserved = 0;
    
    // start with first endpoint
    // skip over any non-endpoint descriptors
    pch = (PUCHAR) (interfaceDescriptor) +
        interfaceDescriptor->bLength;

    // initialize the pipe fields for this interfacae

    // assume success
    usbdStatus = USBD_STATUS_SUCCESS;       

    interfaceHandle->InterfaceDescriptor = *interfaceDescriptor;
    for (i=0; i<numEndpoints; i++) {
        USB_HIGH_SPEED_MAXPACKET muxPacket;
        
        descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        while (descriptor->bDescriptorType != 
               USB_ENDPOINT_DESCRIPTOR_TYPE) {
            if (descriptor->bLength == 0) {
                break; // Don't loop forever
            }
            pch += descriptor->bLength;
            descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        }

        endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
        USBPORT_ASSERT(endpointDescriptor->bDescriptorType ==
            USB_ENDPOINT_DESCRIPTOR_TYPE);

        // initial state is CLOSED
        interfaceHandle->PipeHandle[i].PipeStateFlags = 
            USBPORT_PIPE_STATE_CLOSED;
        interfaceHandle->PipeHandle[i].Endpoint = NULL;                 

        // init pipe flags
        interfaceHandle->PipeHandle[i].UsbdPipeFlags = 
            InterfaceInformation->Pipes[i].PipeFlags;
        
        if (InterfaceInformation->Pipes[i].PipeFlags &
            USBD_PF_CHANGE_MAX_PACKET) {
            // client wants to override original max_packet
            // size in endpoint descriptor
             endpointDescriptor->wMaxPacketSize =
                InterfaceInformation->Pipes[i].MaximumPacketSize;

            USBPORT_KdPrint((2,
                "'new bMaxPacket 0x%x\n", endpointDescriptor->wMaxPacketSize));
        }

        //
        // copy the endpoint descriptor into the
        // pipe handle structure.
        //

        RtlCopyMemory(&interfaceHandle->PipeHandle[i].EndpointDescriptor,
                      pch,
                      sizeof(interfaceHandle->PipeHandle[i].EndpointDescriptor) );

        // advance to next endpoint
        // first field in endpoint descriptor is length
        pch += endpointDescriptor->bLength;

        //
        // return information about the pipe
        //
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'ipIF', 
            interfaceHandle,
            i,
            &interfaceHandle->PipeHandle[i]);  

        InterfaceInformation->Pipes[i].EndpointAddress =
            endpointDescriptor->bEndpointAddress;
        InterfaceInformation->Pipes[i].PipeType =
            PipeTypes[endpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK];
        muxPacket.us = endpointDescriptor->wMaxPacketSize;            
        InterfaceInformation->Pipes[i].MaximumPacketSize =
             muxPacket.MaxPacket * (muxPacket.HSmux+1);
        InterfaceInformation->Pipes[i].Interval =
            endpointDescriptor->bInterval;

        InterfaceInformation->Pipes[i].PipeHandle = 
            USBPORT_BAD_HANDLE;

    } /* end for numEndpoints */

    if (usbdStatus != USBD_STATUS_SUCCESS) {
        // if we got an error bail now
        // we will return with the structure
        // initailized but no open pipes
        goto USBPORT_InternalOpenInterface_Done;
    }

    // all pipe handle fields initialized and
    // urb structure has been filled in 

    // now loop thru and open the pipes
    for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {
        NTSTATUS ntStatus;
        
        ntStatus = USBPORT_OpenEndpoint(DeviceHandle,
                                        FdoDeviceObject,
                                        &interfaceHandle->PipeHandle[i],
                                        &usbdStatus,
                                        FALSE);

        if (NT_SUCCESS(ntStatus)) {

            // if success set the pipe handle for client
            InterfaceInformation->Pipes[i].PipeHandle = 
                &interfaceHandle->PipeHandle[i];
            USBPORT_KdPrint((2, "'pipe handle = 0x%x\n", 
                InterfaceInformation->Pipes[i].PipeHandle ));

        } else {
                
            USBPORT_KdPrint((1,
                "'error opening one of the pipes in interface (%x)\n", usbdStatus));
            ntStatus = SET_USBD_ERROR(Urb, usbdStatus);
            break;
        }                                                    
    }


USBPORT_InternalOpenInterface_Done:

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'oIFd', 
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting,
        usbdStatus);

    if (USBD_SUCCESS(usbdStatus)) {

        //
        // successfully opened the interface, return the handle
        // to it
        //

        *InterfaceHandle =
            InterfaceInformation->InterfaceHandle = interfaceHandle;

        //
        // set the length properly, the value we already
        // calculated
        //

        InterfaceInformation->Length = (USHORT) need;

    } else {

        //
        // had a problem, go back thru and close anything we opened.
        //

        if (interfaceHandle) {

            for (i=0; i<numEndpoints; i++) {
            
                USBPORT_KdPrint((2, "'open interface cleanup -- closing endpoint %x\n",
                              &interfaceHandle->PipeHandle[i]));

                // fortunately this cannot fail
                USBPORT_ClosePipe(DeviceHandle,
                                  FdoDeviceObject,
                                  &interfaceHandle->PipeHandle[i]);

            }

            if (allocated) {
                FREE_POOL(FdoDeviceObject, interfaceHandle);
                interfaceHandle = NULL;
            }
            
        }            
    }

    USBPORT_KdPrint((3, "' exit InternalOpenInterface 0x%x\n", usbdStatus));

    return usbdStatus;
}


VOID
USBPORT_InternalCloseConfiguration(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Closes the current configuration for a device.

Arguments:


Return Value:

    this function cannot fail


--*/
{
    ULONG i, j;
    PUSBD_CONFIG_HANDLE configHandle = NULL;
    BOOLEAN retry = TRUE;
    ULONG interfaceCount;

    PAGED_CODE();

    // device handle MUST be valid
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    configHandle = DeviceHandle->ConfigurationHandle;

    if (configHandle == NULL) {
        // device is not configured      
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'nCFG', 0, 0, DeviceHandle);
        goto USBPORT_InternalCloseConfiguration_Done;
    }
    
    ASSERT_CONFIG_HANDLE(configHandle);
    interfaceCount = configHandle->ConfigurationDescriptor->bNumInterfaces;

    LOGENTRY(NULL, FdoDeviceObject, 
            LOG_PNP, 'cCFG', interfaceCount, 0, configHandle);
    
    // we ensure that all transfers are aborted for the device handle
    // before calling this function so the close configuration will 
    // not fail


    // do the cleanup
    
    while (!IsListEmpty(&configHandle->InterfaceHandleList)) {

        //
        // found an open interface, close it
        //

        PUSBD_INTERFACE_HANDLE_I iHandle;
        ULONG endpointCount; 
        PLIST_ENTRY listEntry;
        
        listEntry = RemoveHeadList(&configHandle->InterfaceHandleList);
        iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_INTERFACE_HANDLE_I, 
                    InterfaceLink);
        
        ASSERT_INTERFACE(iHandle);

        endpointCount = iHandle->InterfaceDescriptor.bNumEndpoints;

        LOGENTRY(NULL, FdoDeviceObject, 
            LOG_PNP, 'cIFX', iHandle, 0, configHandle);
            
        USBPORT_KdPrint((2, "'%d endpoints to close\n", endpointCount));

        for (j=0; j<endpointCount; j++) {
        
            PUSBD_PIPE_HANDLE_I pipeHandle;
            
            // if the pipe is open, close it

            pipeHandle = &iHandle->PipeHandle[j];
            
            USBPORT_KdPrint((2, "'close config -- closing pipe %x\n",
                &iHandle->PipeHandle[j]));
                
            USBPORT_ClosePipe(DeviceHandle,
                              FdoDeviceObject,
                              pipeHandle);

            USBPORT_ASSERT(pipeHandle->ListEntry.Flink == NULL &&
                           pipeHandle->ListEntry.Blink == NULL);
        }

        // all pipes are now closed
        FREE_POOL(FdoDeviceObject, iHandle);
    }

    // NOTE: this also frees 
    // configHandle->ConfigurationDescriptor since it 
    // is in the same block allocated for the confighandle
    FREE_POOL(FdoDeviceObject, configHandle);
    // device is not 'unconfigured'
    DeviceHandle->ConfigurationHandle = NULL;

USBPORT_InternalCloseConfiguration_Done:

    USBPORT_KdPrint((2, "'current configuration closed\n"));

}


PUSB_INTERFACE_DESCRIPTOR
USBPORT_InternalParseConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    UCHAR InterfaceNumber,
    UCHAR AlternateSetting,
    PBOOLEAN HasAlternateSettings
    )
/*++

Routine Description:

    Get the configuration descriptor for a given device.

Arguments:

    DeviceObject -

    DeviceData -

    Urb -

    ConfigurationDescriptor -

Return Value:


--*/
{
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptorSetting = NULL;
    PUCHAR pch = (PUCHAR) ConfigurationDescriptor, end;
    ULONG i;
    PUSB_COMMON_DESCRIPTOR commonDescriptor;

    PAGED_CODE();
    if (HasAlternateSettings) {
        *HasAlternateSettings = FALSE;
    }

    commonDescriptor =
        (PUSB_COMMON_DESCRIPTOR) (pch + ConfigurationDescriptor->bLength);

    while (commonDescriptor->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) {
        if (commonDescriptor->bLength == 0) {
            break; // Don't loop forever
        }
        ((PUCHAR)(commonDescriptor))+= commonDescriptor->bLength;
    }

    interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) commonDescriptor;
    USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);

    end = pch + ConfigurationDescriptor->wTotalLength;

    //
    // First find the matching InterfaceNumber
    //
    while (pch < end && interfaceDescriptor->bInterfaceNumber != InterfaceNumber) {
        pch = (PUCHAR) interfaceDescriptor;
        pch += USBPORT_InternalGetInterfaceLength(interfaceDescriptor, end);

        // point to the next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif //MAX_DEBUG
    }

//#ifdef MAX_DEBUG
//    if (pch >= end) {
//        USBD_KdPrint(3, ("'Interface %x alt %x not found!\n", InterfaceNumber,
//            AlternateSetting));
//        TEST_TRAP();
//    }
//#endif //MAX_DEBUG

    i = 0;
    // Now find the proper alternate setting
    while (pch < end && interfaceDescriptor->bInterfaceNumber == InterfaceNumber) {

        if (interfaceDescriptor->bAlternateSetting == AlternateSetting) {
            interfaceDescriptorSetting = interfaceDescriptor;
        }

        pch = (PUCHAR) interfaceDescriptor;
        pch += USBPORT_InternalGetInterfaceLength(interfaceDescriptor, end);

        // point to next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            USBPORT_ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif
        i++;
    }

    if (i>1 && HasAlternateSettings) {
        *HasAlternateSettings = TRUE;
        USBPORT_KdPrint((2, "'device has alternate settings!\n"));
    }

    return interfaceDescriptorSetting;
}


ULONG
USBPORT_InternalGetInterfaceLength(
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    PUCHAR End
    )
/*++

Routine Description:

    Initialize the configuration handle structure.

Arguments:

    InterfaceDescriptor - pointer to usb interface descriptor
        followed by endpoint descriptors

Return Value:

    Length of the interface plus endpoint descriptors and class specific
    descriptors in bytes.

--*/
{
    PUCHAR pch = (PUCHAR) InterfaceDescriptor;
    ULONG i, numEndpoints;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_COMMON_DESCRIPTOR usbDescriptor;

    PAGED_CODE();
    USBPORT_ASSERT(InterfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);
    i = InterfaceDescriptor->bLength;
    numEndpoints = InterfaceDescriptor->bNumEndpoints;

    // advance to the first endpoint
    pch += i;

    while (numEndpoints) {

        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        while (usbDescriptor->bDescriptorType !=
                USB_ENDPOINT_DESCRIPTOR_TYPE) {
            if (usbDescriptor->bLength == 0) {
                break; // Don't loop forever
            }
            i += usbDescriptor->bLength;
            pch += usbDescriptor->bLength;
            usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        }

        endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
        USBPORT_ASSERT(endpointDescriptor->bDescriptorType ==
            USB_ENDPOINT_DESCRIPTOR_TYPE);
        i += endpointDescriptor->bLength;
        pch += endpointDescriptor->bLength;
        numEndpoints--;
    }

    while (pch < End) {
        // see if we are pointing at an interface
        // if not skip over the other junk
        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        if (usbDescriptor->bDescriptorType ==
            USB_INTERFACE_DESCRIPTOR_TYPE) {
            break;
        }

        USBPORT_ASSERT(usbDescriptor->bLength != 0);
        if (usbDescriptor->bLength == 0) {
            break; // Don't loop forever
        }
        i += usbDescriptor->bLength;
        pch += usbDescriptor->bLength;
    }


    return i;
}


BOOLEAN
USBPORT_ValidateConfigurtionDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdStatus
    )   
/*++

Routine Description:

    Validate a configuration descriptor

Arguments:

    ConfigurationDescriptor -

    Urb -

Return Value:

    TRUE if it looks valid

--*/
{
    BOOLEAN valid = TRUE;

    if (ConfigurationDescriptor->bDescriptorType != 
        USB_CONFIGURATION_DESCRIPTOR_TYPE) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }        

    if (ConfigurationDescriptor->bLength != 
        sizeof(USB_CONFIGURATION_DESCRIPTOR)) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }   
    
    return valid;            
    
}            


PUSBD_INTERFACE_HANDLE_I
USBPORT_GetInterfaceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigurationHandle,
    UCHAR InterfaceNumber
    )
/*++

Routine Description:

   Walks the list of interfaces attached to the configuration
   handle and returns the one with the matching InterfaceNumber

Arguments:


Return Value:

    interface handle


--*/
{
    PLIST_ENTRY listEntry;
    PUSBD_INTERFACE_HANDLE_I iHandle;
    
     // walk the list
    GET_HEAD_LIST(ConfigurationHandle->InterfaceHandleList, listEntry);

    while (listEntry && 
           listEntry != &ConfigurationHandle->InterfaceHandleList) {
           
        // extract the handle from this entry 
        iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_INTERFACE_HANDLE_I, 
                    InterfaceLink);
                    
        ASSERT_INTERFACE(iHandle);                    

        // is this the one we want?
        if (iHandle->InterfaceDescriptor.bInterfaceNumber == 
            InterfaceNumber) {

            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'gfh1', iHandle, 0, 0);  
            return iHandle;
        }

        listEntry = iHandle->InterfaceLink.Flink; 
        
    } /* while */

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'gfh2', 0, 0, 0);  
    return NULL;
}


USBD_STATUS
USBPORT_InitializeInterfaceInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    PUSBD_CONFIG_HANDLE ConfigHandle
    )
/*++

Routine Description:

    validates and initializes the interface information structure
    passed by the client

Arguments:

Return Value:


--*/
{
    ULONG need, i;
    ULONG numEndpoints;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    BOOLEAN hasAlternateSettings;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    
    interfaceDescriptor =
        USBPORT_InternalParseConfigurationDescriptor(
                                          ConfigHandle->ConfigurationDescriptor,
                                          InterfaceInformation->InterfaceNumber,
                                          InterfaceInformation->AlternateSetting,
                                          &hasAlternateSettings);

    // we know we need at least this much
    need = sizeof(USBD_PIPE_INFORMATION) + sizeof(USBD_INTERFACE_INFORMATION);
    
    if (interfaceDescriptor == NULL) {
        usbdStatus = USBD_STATUS_INTERFACE_NOT_FOUND;
        TEST_TRAP();  
        goto USBPORT_InitializeInterfaceInformation_Done;
    }
    
    // Here is where we verify there is enough room in the client
    // buffer since we know how many pipes we'll need based on the
    // interface descriptor.
    //
    // we need space for pipe_info for each endpoint plus the 
    // interface_info

    
    numEndpoints = interfaceDescriptor->bNumEndpoints;
    need = (USHORT) (((numEndpoints-1) * sizeof(USBD_PIPE_INFORMATION) +
                sizeof(USBD_INTERFACE_INFORMATION)));

    USBPORT_KdPrint((2, "'Interface.Length = %d need = %d\n", 
        InterfaceInformation->Length, need));

    if (InterfaceInformation->Length < need) {
        // the client has indicated that the buffer
        // is smaller than what we need
        
        usbdStatus = USBD_STATUS_BUFFER_TOO_SMALL;
        TC_TRAP();             
    }                      

    if (usbdStatus == USBD_STATUS_SUCCESS) {
        // initialize all fields not set by caller to zero 

        InterfaceInformation->Class = 0;
        InterfaceInformation->SubClass = 0;
        InterfaceInformation->Protocol = 0;
        InterfaceInformation->Reserved = 0;
        InterfaceInformation->InterfaceHandle = NULL;
        InterfaceInformation->NumberOfPipes = 
            numEndpoints;

        for (i=0; i< numEndpoints; i++) {
            InterfaceInformation->Pipes[i].EndpointAddress = 0;
            InterfaceInformation->Pipes[i].Interval = 0;
            InterfaceInformation->Pipes[i].PipeType = 0;
            InterfaceInformation->Pipes[i].PipeHandle = NULL;

            // attempt to detect bad flags
            // if any unused bits are set we assume that the pipeflags 
            // field is uninitialized.
            if (InterfaceInformation->Pipes[i].PipeFlags & ~USBD_PF_VALID_MASK) {
                // client driver is passing bad flags
                USBPORT_DebugClient(("client driver is passing bad pipe flags\n"));
                
                usbdStatus = USBD_STATUS_INAVLID_PIPE_FLAGS;                    
                TC_TRAP();         
            }

            // note: if USBD_PF_CHANGE_MAX_PACKET is set then 
            // maxpacket size is passed in as a parameter so 
            // we don't initialize it
            
            if (!TEST_FLAG(InterfaceInformation->Pipes[i].PipeFlags,  
                           USBD_PF_CHANGE_MAX_PACKET)) {
                InterfaceInformation->Pipes[i].MaximumPacketSize = 0;                           
            }                           
        }
    }
    
USBPORT_InitializeInterfaceInformation_Done:

    // set length to the correct value regardless 
    // of error
    InterfaceInformation->Length = need;

    return usbdStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\dma.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dma.c

Abstract:

    functions for processing ennpoints that use DMA to 
    process transfers

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_DmaEndpointWorker
// USBPORT_DmaEndpointPaused
// USBPORT_DmaEndpointActive


MP_ENDPOINT_STATE
USBPORT_DmaEndpointActive(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    process the active state

    returns the next needed state if we
    discover the need for a transition

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATE currentState;
    PLIST_ENTRY listEntry;
    MP_ENDPOINT_STATE nextState;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);
    currentState = USBPORT_GetEndpointState(Endpoint);
    LOGENTRY(Endpoint, 
        FdoDeviceObject, LOG_XFERS, 'dmaA', 0, Endpoint, currentState);
    USBPORT_ASSERT(currentState == ENDPOINT_ACTIVE);
    
    ASSERT_ENDPOINT_LOCKED(Endpoint);
    
    // BUGBUG
    //nextState = ENDPOINT_IDLE;
    nextState = ENDPOINT_ACTIVE;

    // now walk thru and process active requests
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {
        
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'pACT', transfer, 0, 0);                    
        ASSERT_TRANSFER(transfer);                    

        USBPORT_ASSERT(transfer->Tp.TransferBufferLength <= 
            EP_MAX_TRANSFER(Endpoint));

        // process the transfer
        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_KILL_SPLIT)) {
            
            USBPORT_QueueDoneTransfer(transfer,
                                      STATUS_SUCCESS);
            break;
            
        } else if (!TEST_FLAG(transfer->Flags,USBPORT_TXFLAG_IN_MINIPORT) && 
            !TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {
        
            USB_MINIPORT_STATUS mpStatus;
            
            // transfer has not been called down yet
            // call it down now

            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO)) {
                LOGENTRY(Endpoint, FdoDeviceObject, LOG_ISO, 'subI', mpStatus, Endpoint, transfer);
                MP_SubmitIsoTransfer(devExt, Endpoint, transfer, mpStatus);
            } else {
                MP_SubmitTransfer(devExt, Endpoint, transfer, mpStatus);
            }                
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'subm', mpStatus, Endpoint, transfer);

            if (mpStatus == USBMP_STATUS_SUCCESS) {
            
                LARGE_INTEGER timeout;
                
                SET_FLAG(transfer->Flags, USBPORT_TXFLAG_IN_MINIPORT);

                // miniport took it -- set the timeout

                KeQuerySystemTime(&transfer->TimeoutTime);

                timeout.QuadPart = transfer->MillisecTimeout;
                // convert to 100ns units
                timeout.QuadPart = timeout.QuadPart * 10000;
                transfer->TimeoutTime.QuadPart += timeout.QuadPart;
                
            } else if (mpStatus == USBMP_STATUS_BUSY) {
                // miniport busy try later
                break;
            } else {
                // an error, we will need to complete
                // this transfer for the miniport
                LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'tERR', 
                        transfer, 
                        mpStatus, 
                        0);
                        
                if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO)) {
                    LOGENTRY(Endpoint, FdoDeviceObject, LOG_ISO, 'iERR', 
                        transfer, 
                        mpStatus, 
                        0);
                                            
                    USBPORT_ErrorCompleteIsoTransfer(FdoDeviceObject, 
                                                     Endpoint, 
                                                     transfer);
                } else {
                    TEST_TRAP();
                }
                break;
            }

            // go active
            nextState = ENDPOINT_ACTIVE;
        } 

        // if we find a canceled 'active' transfer we need to pause 
        // the enpoint so we can flush it out
        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED) ||
            TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED) ) {
            // we need to pause the endpoint
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'inAC', transfer, Endpoint,
                transfer->Flags);

            nextState = ENDPOINT_PAUSE;
            break;
        }

        listEntry = transfer->TransferLink.Flink;       
    }
    
USBPORT_DmaEndpointActive_Done:

    return nextState;

} 


MP_ENDPOINT_STATE
USBPORT_DmaEndpointPaused(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    process the paused state

    endpoint is paused, cancel any transfers that need 
    canceling 

Arguments:

Return Value:

    None.

--*/
{
    MP_ENDPOINT_STATE currentState;
    MP_ENDPOINT_STATE nextState;
    PLIST_ENTRY listEntry;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);        
    
    currentState = USBPORT_GetEndpointState(Endpoint);
    LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'dmaP', 0, Endpoint, currentState);
    USBPORT_ASSERT(currentState == ENDPOINT_PAUSE);

    nextState = currentState;
    
    // now walk thru and process active requests
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    while (listEntry && 
           listEntry != &Endpoint->ActiveList) {
        // extract the urb that is currently on the active 
        // list, there should only be one
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT, 
                    TransferLink);
        LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'pPAU', transfer, Endpoint, 0);                    
        ASSERT_TRANSFER(transfer);                    

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_CANCELED) ||
            TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ABORTED)) {

            if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO) &&
                TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_IN_MINIPORT) &&
                !TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {

                ULONG cf, lastFrame;
                PTRANSFER_URB urb;

                LOGENTRY(Endpoint,
                    FdoDeviceObject, LOG_XFERS, 'drn+', transfer, 0, 0); 

                urb = transfer->Urb;
                ASSERT_TRANSFER_URB(urb);
                // iso transfer in the miniport, we need to let the 
                // iso TDs drain out, before doing an abort.
                lastFrame = 
                    urb->u.Isoch.StartFrame + urb->u.Isoch.NumberOfPackets;
                
                // get the current frame 
                MP_Get32BitFrameNumber(devExt, cf);    
                
                if (cf < lastFrame + 1) {
                    LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'drne', transfer, 0, 0); 
                    goto stay_paused;
                }
            }
        
            if ( TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_IN_MINIPORT) &&
                !TEST_FLAG(Endpoint->Flags, EPFLAG_NUKED)) {

                ULONG bytesTransferred = 0;
                // abort the transfer
                LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'inMP', transfer, 0, 0); 

                MP_AbortTransfer(devExt, Endpoint, transfer, bytesTransferred);

                // make sure we indicate any data that has been transferred 
                // prior to abort
                if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_ISO)) {
                    USBPORT_FlushIsoTransfer(FdoDeviceObject,
                                             &transfer->Tp,
                                             transfer->IsoTransfer);
                } else {
                    transfer->MiniportBytesTransferred = bytesTransferred;
                }                    
                
                LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'abrL', 0, 
                    transfer, bytesTransferred); 
    
                // pick up the next ptr
                listEntry = transfer->TransferLink.Flink; 
                // no more references, put this transfer on the
                // cancel list
                RemoveEntryList(&transfer->TransferLink); 

                if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD)) {
                    USBPORT_CancelSplitTransfer(FdoDeviceObject, transfer);
                } else {
                    InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);
                }                    
                
            } else {

                // transfer not in miniport, put it on the 
                // cancel list since it can not be completed
                // by the miniport.

                LOGENTRY(Endpoint, 
                    FdoDeviceObject, LOG_XFERS, 'niMP', transfer, 0, 0); 

                // pick up the next ptr
                listEntry = transfer->TransferLink.Flink;                     
                RemoveEntryList(&transfer->TransferLink); 

                if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD)) {
                    USBPORT_CancelSplitTransfer(FdoDeviceObject, transfer);
                } else {                    
                    InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);
                }                    
            }
            
        } else {
            listEntry = transfer->TransferLink.Flink; 
        }
        
    } /* while */

    // cancel routine will bump us back to 
    // the active state
    nextState = ENDPOINT_ACTIVE;    
    
stay_paused:

    return nextState;
} 


VOID
USBPORT_DmaEndpointWorker(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    endpoints that need transfers mapped come thru here

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    MP_ENDPOINT_STATE currentState;
    MP_ENDPOINT_STATE nextState;
    BOOLEAN invalidate = FALSE;
    
    ASSERT_ENDPOINT(Endpoint);
    
    fdoDeviceObject = Endpoint->FdoDeviceObject;
    LOGENTRY(Endpoint, fdoDeviceObject, LOG_XFERS, 'dmaW', 0, Endpoint, 0);
    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Le90');

    // we should be in the last requested state
    currentState = USBPORT_GetEndpointState(Endpoint);
    
    switch(currentState) {
    case ENDPOINT_PAUSE:
        nextState = 
            USBPORT_DmaEndpointPaused(
                    fdoDeviceObject, 
                    Endpoint); 
        break;
    case ENDPOINT_ACTIVE:
        nextState = 
            USBPORT_DmaEndpointActive(
                fdoDeviceObject,
                Endpoint);            
        break;
    default:
        // state not handled
        // this is a bug
        TEST_TRAP();
    }

    // release the endpoint lists
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'Ue90');
    
    // flush out canceled requests
    USBPORT_FlushCancelList(Endpoint);

    // endpoint has now been processed, if we were paused all canceled
    // transfers were removed.
    // We were either 
    //      1. paused and need to stay paused (for iso drain)
    //      2. paused and need to go active
    //      3. active and need to pause
    //      4. active and need to stay active
    //
    
    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'LeJ0');
    // set to new endpoint state if necessary
    if (nextState != currentState) {
        // case 2, 3
        USBPORT_SetEndpointState(Endpoint, nextState);
    } else if (nextState == currentState && 
               nextState == ENDPOINT_PAUSE) {
        invalidate = TRUE;               
    }
    RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeJ0');

    if (invalidate) {
        // state change, defer this to the worker
        USBPORT_InvalidateEndpoint(fdoDeviceObject, Endpoint, IEP_SIGNAL_WORKER);
    }        

}

typedef struct _USBPORT_DB_HANDLE {
    ULONG Sig;
    LIST_ENTRY DbLink;
    PVOID DbSystemAddress;
    ULONG DbLength;
    PUCHAR DbData;    
} USBPORT_DB_HANDLE, *PUSBPORT_DB_HANDLE;


VOID
USBPORTSVC_NotifyDoubleBuffer(
    PDEVICE_DATA DeviceData,
    PTRANSFER_PARAMETERS TransferParameters,
    PVOID DbSystemAddress,
    ULONG DbLength
    )

/*++

Routine Description:

    Notify the port driver that double buffering has occured,
    port driver will create a node for use during a subsequent
    adapter flush.

Arguments:

Return Value:

    none

--*/

{
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    PUSBPORT_DB_HANDLE dbHandle;
    ULONG length;
    BOOLEAN write;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'NOdb', 0, 
        0, TransferParameters); 

    TRANSFER_FROM_TPARAMETERS(transfer, TransferParameters);        
    ASSERT_TRANSFER(transfer);

    write = transfer->Direction == WriteData ? TRUE : FALSE; 

    // allocate a node and add it to the list, we don't care if it is a 
    // write
   
    if (!write && transfer->MapRegisterBase != NULL) {
        PUCHAR pch;
        
        length = sizeof(USBPORT_DB_HANDLE) + DbLength;

        ALLOC_POOL_Z(pch, 
                     NonPagedPool,
                     length);

        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'db++', DbSystemAddress, 
            DbLength, transfer); 

        dbHandle = (PUSBPORT_DB_HANDLE) pch;
        pch += sizeof(USBPORT_DB_HANDLE);
        dbHandle->Sig = SIG_DB;
        dbHandle->DbSystemAddress = DbSystemAddress;
        dbHandle->DbLength = DbLength;
        dbHandle->DbData = pch;

        RtlCopyMemory(pch, 
                      DbSystemAddress,
                      DbLength);

        if (TEST_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD)) {
            ASSERT_TRANSFER(transfer->Transfer);
            InsertTailList(&transfer->Transfer->DoubleBufferList, 
                           &dbHandle->DbLink);
        } else {
            InsertTailList(&transfer->DoubleBufferList, 
                           &dbHandle->DbLink);
        }
    }                               
   
}


VOID
USBPORT_FlushAdapterDBs(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_TRANSFER_CONTEXT Transfer
    )

/*++

Routine Description:

Arguments:

Return Value:

    none

--*/

{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PUSBPORT_DB_HANDLE dbHandle;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_TRANSFER(Transfer);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'flDB', Transfer, 
            0, 0); 
// dump the 4 dwords of the transfer buffer
//{
//    PULONG p;
//
//    p = (PULONG) Transfer->SgList.MdlVirtualAddress;
//    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'dmp1', *(p), 
//            *(p+1), *(p+2)); 
//}

    while (!IsListEmpty(&Transfer->DoubleBufferList)) {
        
        listEntry = RemoveHeadList(&Transfer->DoubleBufferList);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'flle', Transfer, 
            listEntry, 0); 
            
        dbHandle = (PUSBPORT_DB_HANDLE) CONTAINING_RECORD(
                   listEntry,
                   struct _USBPORT_DB_HANDLE, 
                   DbLink);                                    

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'DBHf', Transfer, 
            dbHandle, 0); 
        ASSERT_DB_HANDLE(dbHandle);

        // flush to the system address
        RtlCopyMemory(dbHandle->DbSystemAddress,
                      dbHandle->DbData,
                      dbHandle->DbLength);

        FREE_POOL(FdoDeviceObject, dbHandle);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\dmtimer.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dmtimer.c

Abstract:

    This module implements our 'deadman' timer DPC.
    This is our general purpose timer we use to deal with
    situations where the controller is not giving us
    interrupts.

    examples:
        root hub polling.
        dead controller detection

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_StartDM_Timer)
#endif

// non paged functions
// USBPORT_DM_TimerDpc
// USBPORT_StopDM_Timer


VOID
USBPORT_DM_TimerDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;
    BOOLEAN setTimer;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

#if DBG
    {
    LARGE_INTEGER t;

    KeQuerySystemTime(&t);
    LOGENTRY(NULL, fdoDeviceObject, LOG_NOISY, 'dmTM', fdoDeviceObject,
        t.LowPart, 0);
    }
#endif

    // if stop fires it will stall here
    // if stop is running we stall here
    USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
#ifdef XPSE
    // poll while suspended
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED) &&
        TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_POLL_IN_SUSPEND)) {

        MP_CheckController(devExt);

        if (!TEST_FDO_FLAG(devExt,USBPORT_FDOFLAG_CONTROLLER_GONE)) {
            MP_PollController(devExt);
        }
    }
#endif

    USBPORT_SynchronizeControllersStart(fdoDeviceObject);

    // skip timer is set when we are in low power
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK)) {
        // some work we should always do

        // for an upcomming bug fix
        USBPORT_BadRequestFlush(fdoDeviceObject, FALSE);
    } else {

        MP_CheckController(devExt);

        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_POLL_CONTROLLER) &&
            !TEST_FDO_FLAG(devExt,USBPORT_FDOFLAG_CONTROLLER_GONE)) {
            MP_PollController(devExt);
        }

        // call the ISR worker here in the event that the controller
        // is unable to generate interrupts

        USBPORT_IsrDpcWorker(fdoDeviceObject, FALSE);

        USBPORT_TimeoutAllEndpoints(fdoDeviceObject);

        // invalidate all isochronous endpoints

        // flush async requests
        USBPORT_BadRequestFlush(fdoDeviceObject, FALSE);
    }

    setTimer = TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_ENABLED);

    USBPORT_RELEASE_DM_LOCK(devExt, irql);

    if (setTimer) {

        ULONG timerIncerent;
        LONG dueTime;

        timerIncerent = KeQueryTimeIncrement() - 1;

        // round up to the next highest timer increment
        dueTime= -1 *
            (MILLISECONDS_TO_100_NS_UNITS(devExt->Fdo.DM_TimerInterval) + timerIncerent);

        KeSetTimer(&devExt->Fdo.DM_Timer,
                   RtlConvertLongToLargeInteger(dueTime),
                   &devExt->Fdo.DM_TimerDpc);

        INCREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
    }

    // this timer is done
    DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
}


// BUGBUG HP ia64 fix
VOID
USBPORT_DoRootHubCallback(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT Usb2Fdo
    )
/*++

Routine Description:

    Execute the root hub notifaction callback -- called from the
    worker thread

Arguments:

    FdoDeviceObject - FDO device object for a USB 1.1 controller
                    that may be a CC

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    PRH_INIT_CALLBACK cb;
    PVOID context;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    KeAcquireSpinLock(&devExt->Fdo.HcSyncSpin.sl, &irql);

    USBPORT_ASSERT(rhDevExt->Pdo.HubInitCallback != NULL);

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'syCB', rhDevExt, 0, 0);

    context = rhDevExt->Pdo.HubInitContext;
    cb = rhDevExt->Pdo.HubInitCallback;

    rhDevExt->Pdo.HubInitCallback = NULL;
    rhDevExt->Pdo.HubInitContext = NULL;

    KeReleaseSpinLock(&devExt->Fdo.HcSyncSpin.sl, irql);

    // root hub list should be empty
#if DBG
    {
    PHCD_ENDPOINT ep = rhDevExt->Pdo.RootHubInterruptEndpoint;

    USBPORT_ASSERT(IsListEmpty(&ep->ActiveList));
    USBPORT_ASSERT(IsListEmpty(&ep->PendingList));
    }
#endif

    // perform High speed chirp now. The EHCI driver is started and the CC
    // must also be started since the root hub has registered a callback
    // this will prevent the controller from going into suspend right away
    // for lack of devices.

    if (Usb2Fdo) {

        PDEVICE_EXTENSION usb2DevExt;

        GET_DEVICE_EXT(usb2DevExt, Usb2Fdo);
        ASSERT_FDOEXT(usb2DevExt);

        // note in .NET this function takes the CC FDO
        // and aquires the CC lock

        // the USB 2 controller may already be in suspend if the CC root hub is
        // being added later, for this case we skip the chirp.
        if (!TEST_FDO_FLAG(usb2DevExt, USBPORT_FDOFLAG_SUSPENDED)) {
            USBPORT_RootHub_PowerAndChirpAllCcPorts(FdoDeviceObject);
        }
    }

    cb(context);


}


VOID
USBPORT_SynchronizeControllersStart(
    PDEVICE_OBJECT FdoDeviceObject
    )

/*++

Routine Description:

    see if it is OK to start a controllers root hub

Arguments:

    FdoDeviceObject - FDO device object for a USB 1.1 controller
                    that may be a CC

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    KIRQL irql;
    PRH_INIT_CALLBACK cb;
    PVOID context;
    BOOLEAN okToStart;
    PDEVICE_OBJECT usb2Fdo = NULL;
    PDEVICE_EXTENSION usb2DevExt;


    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // skip if we don't have a root hub
    if (devExt->Fdo.RootHubPdo == NULL) {
        return;
    }

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    // if no callback registered skip the whole process
    if (rhDevExt->Pdo.HubInitCallback == NULL) {
        return;
    }

    // if callback pending on worker thread skip
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SIGNAL_RH)) {
        return;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'syn1', FdoDeviceObject, 0, 0);
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC)) {

        okToStart = FALSE;
        //
        // we need to find the 2.0 master controller,
        // if the hub has started then it is OK to
        // start.

        usb2Fdo = USBPORT_FindUSB2Controller(FdoDeviceObject);
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'syn2', 0, 0, usb2Fdo);

        if (usb2Fdo != NULL) {
            GET_DEVICE_EXT(usb2DevExt, usb2Fdo);
            ASSERT_FDOEXT(usb2DevExt);

            if (TEST_FLAG(usb2DevExt->PnpStateFlags, USBPORT_PNP_STARTED)) {
                LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'syn3', 0, 0, usb2Fdo);
                okToStart = TRUE;
            }
        }

        // is companion but check if OK to bypass the wait
        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_ENUM_OK)) {
            okToStart = TRUE;
        }

    } else {
        // not a CC, it is OK to start immediatly
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'syn4', 0, 0, 0);
        okToStart = TRUE;
    }

    // check for a start-hub callback notification. If we have
    // one then notify the hub that it is OK

    if (okToStart) {
        if (usb2Fdo) {

            GET_DEVICE_EXT(usb2DevExt, usb2Fdo);
            // signal the worker to chirp and do the callback
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_SIGNAL_RH);
            InterlockedIncrement(&usb2DevExt->Fdo.PendingRhCallback);
            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'prh+', 0, 0,
                usb2DevExt->Fdo.PendingRhCallback);
            USBPORT_SignalWorker(FdoDeviceObject);
        } else {
            // no 2.0 controller just callback now
            USBPORT_DoRootHubCallback(FdoDeviceObject, NULL);
        }
    }

}


VOID
USBPORT_BadRequestFlush(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN ForceFlush
    )

/*++

Routine Description:

    Asynchronously flush bad requests from client drivers

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // The purpose of this async flush is to emulate the Win2k
    // behavior where we put tranfers on the HW to devices that
    // had been removed and let them time out.
    //
    // origanlly I used 5 here to fix problems with hid drivers
    // on win2k+usb20, we may need to change this depending on
    // which OS we are running on, we want use a smaller value on
    // XP since HID (the major offender) has been fixed and many
    // of our other in house class drivers support hot remove
    // better.
#define BAD_REQUEST_FLUSH   0

    devExt->Fdo.BadRequestFlush++;
    if (devExt->Fdo.BadRequestFlush > devExt->Fdo.BadReqFlushThrottle ||
        ForceFlush) {
        devExt->Fdo.BadRequestFlush = 0;
        // flush and complete any 'bad parameter' requests

        ACQUIRE_BADREQUEST_LOCK(FdoDeviceObject, irql);
        while (1) {
            PLIST_ENTRY listEntry;
            PIRP irp;
            PUSB_IRP_CONTEXT irpContext;
            NTSTATUS ntStatus;

            if (IsListEmpty(&devExt->Fdo.BadRequestList)) {
                break;
            }

            listEntry = RemoveHeadList(&devExt->Fdo.BadRequestList);

            //irp = (PIRP) CONTAINING_RECORD(
            //        listEntry,
            //        struct _IRP,
            //        Tail.Overlay.ListEntry);

            irpContext = (PUSB_IRP_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _USB_IRP_CONTEXT,
                    ListEntry);

            ASSERT_IRP_CONTEXT(irpContext);
            irp = irpContext->Irp;

            if (irp->Cancel) {
                ntStatus = STATUS_CANCELLED;
            } else {
                ntStatus = STATUS_DEVICE_NOT_CONNECTED;
            }

            RELEASE_BADREQUEST_LOCK(FdoDeviceObject, irql);

            // cancel routine did not run
            LOGENTRY(NULL, FdoDeviceObject, LOG_IRPS, 'cpBA', irp, irpContext, 0);
            USBPORT_CompleteIrp(devExt->Fdo.RootHubPdo, irp,
                ntStatus, 0);

            FREE_POOL(FdoDeviceObject, irpContext);

            ACQUIRE_BADREQUEST_LOCK(FdoDeviceObject, irql);
        }
        RELEASE_BADREQUEST_LOCK(FdoDeviceObject, irql);
    }
}


VOID
USBPORT_StartDM_Timer(
    PDEVICE_OBJECT FdoDeviceObject,
    LONG MillisecondInterval
    )

/*++

Routine Description:

    Inialize and start the timer

Arguments:

    FdoDeviceObject - DeviceObject of the controller to stop

    MillisecondInterval -

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    LONG dueTime;
    ULONG timerIncerent;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    timerIncerent = KeQueryTimeIncrement() - 1;

    // remember interval for repeated use
    devExt->Fdo.DM_TimerInterval = MillisecondInterval;

    // round up to the next highest timer increment
    dueTime= -1 * (MILLISECONDS_TO_100_NS_UNITS(MillisecondInterval) +
        timerIncerent);

    USBPORT_KdPrint((1, "  DM timer (100ns) = %d\n", dueTime));

    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_ENABLED);

    // we consider the timer a pending request while it is
    // scheduled
    INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);

    KeInitializeTimer(&devExt->Fdo.DM_Timer);
    KeInitializeDpc(&devExt->Fdo.DM_TimerDpc,
                    USBPORT_DM_TimerDpc,
                    FdoDeviceObject);

    KeSetTimer(&devExt->Fdo.DM_Timer,
               RtlConvertLongToLargeInteger(dueTime),
               &devExt->Fdo.DM_TimerDpc);

    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_INIT);
}


VOID
USBPORT_StopDM_Timer(
    PDEVICE_OBJECT FdoDeviceObject
    )

/*++

Routine Description:

    stop the timer

Arguments:

    FdoDeviceObject - DeviceObject of the controller to stop

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN inQueue;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_INIT)) {
        // timer never started so bypass the stop
        return;
    }

    // if timer fires it will stall here
    // if timer is running we will stall here
    USBPORT_ACQUIRE_DM_LOCK(devExt, irql);

    USBPORT_ASSERT(TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_ENABLED));
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'kilT', FdoDeviceObject, 0, 0);
    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_ENABLED);

    // timer will no longer re-schedule
    USBPORT_RELEASE_DM_LOCK(devExt, irql);

    // if there is a timer in the queue, remove it
    inQueue = KeCancelTimer(&devExt->Fdo.DM_Timer);
    if (inQueue) {
        // it was queue, so dereference now
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'klIQ', FdoDeviceObject, 0, 0);
        DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
    }

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_DM_TIMER_INIT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    debug macros

Environment:

    Kernel & user mode

Revision History:

    6-20-99 : created

--*/

#ifndef   __DBG_H__
#define   __DBG_H__

#define USBPORT_TAG          'pbsu'        //"USBP"


#if DBG
/**********
DUBUG
***********/

#define UNSIG(x) (x)->Sig = SIG_FREE

// this is a code coverage test trap -- we use them to determine
// if our tests are covering a particular code path.
#define TC_TRAP()


//
// Triggers a break in the debugger iff the registry key
// debugbreakOn is set.  These breakpoints are useful for
// debugging hardware/client software problems
//
// they are not on by default, do not comment them out
//

#define DEBUG_BREAK()  do {\
                            extern ULONG USBPORT_BreakOn;\
                            if (USBPORT_BreakOn) {\
                                DbgPrint("<USB DEBUG BREAK> %s, line %d\n",\
                                    __FILE__, __LINE__);\
                                DbgBreakPoint();\
                            }\
                        } while (0)

//
// This Breakpoint means we either need to test the code path
// somehow or the code is not implemented.  ie either case we
// should not have any of these when the driver is finished
// and tested
//

#define TEST_TRAP()         {\
                            DbgPrint("<TEST_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }

//
// This trap is triggered in the event that something non-fatal
// has occurred that we will want to 'debug'.
//

#define BUG_TRAP()         {\
                            DbgPrint("<BUG_TRAP> %s, line %d\n", __FILE__, __LINE__);\
                            DbgBreakPoint();\
                            }


//
// This trap means something very bad has happened, the system will crash
//

#define BUGCHECK(bc, p2, p3, p4)         {\
                            DbgPrint("<USB BUGCHECK> %s, line %d\n", __FILE__, __LINE__);\
                            KeBugCheckEx(BUGCODE_USB_DRIVER, (bc), (p2), (p3), (p4)); \
                            }


#define CATC_TRAP(d) USBPORT_CatcTrap((d))

#define CATC_TRAP_ERROR(d, e) \
    do {\
    extern ULONG USBPORT_CatcTrapEnable;\
    if (!NT_SUCCESS((e) && USBPORT_CatcTrapEnable)) { \
        USBPORT_CatcTrap((d));\
    }\
    }\
    while(0)

ULONG
_cdecl
USBPORT_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

ULONG
_cdecl
USBPORT_DebugClientX(
    PCH Format,
    ...
    );

#define   USBPORT_KdPrint(_x_) USBPORT_KdPrintX _x_
#define   USBPORT_DebugClient(_x_) USBPORT_DebugClientX _x_

VOID
USBPORT_AssertFailure(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define USBPORT_ASSERT( exp ) \
    if (!(exp)) {\
        USBPORT_AssertFailure( #exp, __FILE__, __LINE__, NULL );\
    }


#define ASSERT_PDOEXT(de)  USBPORT_ASSERT((de)->Sig == ROOTHUB_DEVICE_EXT_SIG)
#define ASSERT_FDOEXT(de)  USBPORT_ASSERT((de)->Sig == USBPORT_DEVICE_EXT_SIG)

#define ASSERT_DEVICE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_DEVICE_HANDLE)
#define ASSERT_CONFIG_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_CONFIG_HANDLE)
#define ASSERT_PIPE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_PIPE_HANDLE)
#define ASSERT_INTERFACE_HANDLE(d) USBPORT_ASSERT((d)->Sig == SIG_INTERFACE_HANDLE)
#define ASSERT_ENDPOINT(d) USBPORT_ASSERT((d)->Sig == SIG_ENDPOINT)
#define ASSERT_TRANSFER(d) USBPORT_ASSERT((d)->Sig == SIG_TRANSFER)
#define ASSERT_COMMON_BUFFER(d) USBPORT_ASSERT((d)->Sig == SIG_CMNBUF)
#define ASSERT_INTERFACE(d) USBPORT_ASSERT((d)->Sig == SIG_INTERFACE_HANDLE)
#define ASSERT_TT(tt) USBPORT_ASSERT((tt)->Sig == SIG_TT)
#define ASSERT_DB_HANDLE(db) USBPORT_ASSERT((db)->Sig == SIG_DB)
#define ASSERT_IRP_CONTEXT(ic) USBPORT_ASSERT((ic)->Sig == SIG_IRPC)
#define ASSERT_REG_CACHE(re) USBPORT_ASSERT((re)->Sig == SIG_REG_CACHE)

#define ASSERT_ENDPOINT_LOCKED(ep) USBPORT_ASSERT((ep)->LockFlag == 1)

#define ASSERT_TRANSFER_URB(u) USBPORT_AssertTransferUrb((u))

NTSTATUS
USBPORT_GetGlobalDebugRegistryParameters(
    VOID
    );

#define GET_GLOBAL_DEBUG_PARAMETERS() \
    USBPORT_GetGlobalDebugRegistryParameters();

#define ASSERT_PASSIVE() \
    do {\
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "EX: code not expecting high irql %d\n", KeGetCurrentIrql() )); \
        USBPORT_ASSERT(FALSE); \
    }\
    } while(0)

// test failure paths
#define FAILED_GETRESOURCES              1
#define FAILED_LOWER_START               2
#define FAILED_REGISTERUSBPORT           3
#define FAILED_USBPORT_START             4
#define FAILED_NEED_RESOURCE             5

#define TEST_PATH(status, pathname) \
    { \
    extern USBPORT_TestPath;\
    if ((pathname) == USBPORT_TestPath) {\
        status = STATUS_UNSUCCESSFUL;\
    }\
    }

#define USBPORT_AcquireSpinLock(fdo, sl, oir) USBPORT_DbgAcquireSpinLock((fdo), (sl), (oir))

#define USBPORT_ReleaseSpinLock(fdo, sl, nir) USBPORT_DbgReleaseSpinLock((fdo), (sl), (nir))

#define USBPORT_ENUMLOG(fdo, etag, p1, p2)\
        USBPORT_EnumLogEntry((fdo), USBDTAG_USBPORT, etag, (ULONG) p1, (ULONG) p2)

#else
/**********
RETAIL
***********/

// debug macros for retail build

#define TEST_TRAP()
#define TRAP()
#define BUG_TRAP()

#define GET_GLOBAL_DEBUG_PARAMETERS()
#define ASSERT_PASSIVE()

#define ASSERT_PDOEXT(de)
#define ASSERT_FDOEXT(de)

#define ASSERT_DEVICE_HANDLE(d)
#define ASSERT_CONFIG_HANDLE(d)
#define ASSERT_PIPE_HANDLE(d)
#define ASSERT_INTERFACE_HANDLE(d)
#define ASSERT_ENDPOINT(d)
#define ASSERT_TRANSFER(d)
#define ASSERT_COMMON_BUFFER(d)
#define ASSERT_INTERFACE(d)
#define ASSERT_TRANSFER_URB(u)
#define ASSERT_TT(tt)
#define ASSERT_DB_HANDLE(tt)
#define ASSERT_IRP_CONTEXT(ic)
#define ASSERT_REG_CACHE(re)

#define ASSERT_ENDPOINT_LOCKED(ep)

#define DEBUG_BREAK()
#define TC_TRAP()

#define BUGCHECK(bc, p2, p3, p4)  {\
                    KeBugCheckEx(BUGCODE_USB_DRIVER, (bc), (p2), (p3), (p4)); \
                    }

#define CATC_TRAP(d)

#define CATC_TRAP_ERROR(d, e)

#define   USBPORT_KdPrint(_x_)
#define   USBPORT_DebugClient(_x_)

#define USBPORT_ASSERT(exp)

#define TEST_PATH(status, path)

#define UNSIG(x)

#define USBPORT_AcquireSpinLock(fdo, sl, oir) \
    KeAcquireSpinLock((PKSPIN_LOCK)(sl), (oir))

#define USBPORT_ReleaseSpinLock(fdo, sl, nir) \
    KeReleaseSpinLock((PKSPIN_LOCK)(sl), (nir))


#define USBPORT_ENUMLOG(fdo, etag, p1, p2)

#endif /* DBG */

/*************
RETAIL & DEBUG
**************/

VOID USBP2LIBFN
USB2LIB_DbgPrint(
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    );

VOID USBP2LIBFN
USB2LIB_DbgBreak(
    VOID
    );

VOID
USBPORTSVC_DbgPrint(
    PVOID DeviceData,
    ULONG Level,
    PCH Format,
    int Arg0,
    int Arg1,
    int Arg2,
    int Arg3,
    int Arg4,
    int Arg5
    );

VOID
USBPORTSVC_TestDebugBreak(
    PVOID DeviceData
    );

VOID
USBPORTSVC_AssertFailure(
    PVOID DeviceData,
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

/*
    since log entries may hold pointers the size of a log struct
    varies with the platform
*/

#ifdef _WIN64
#define LOG_ENTRY LOG_ENTRY64
#define PLOG_ENTRY PLOG_ENTRY64
#else
#define LOG_ENTRY LOG_ENTRY32
#define PLOG_ENTRY PLOG_ENTRY32
#endif

typedef struct LOG_ENTRY64 {
    ULONG        le_sig;          // Identifying string
    ULONG        pad;
    ULONG64      le_info1;        // entry specific info
    ULONG64      le_info2;        // entry specific info
    ULONG64      le_info3;        // entry specific info
} LOG_ENTRY64, *PLOG_ENTRY64; /* LOG_ENTRY */

typedef struct LOG_ENTRY32 {
    ULONG        le_sig;          // Identifying string
    ULONG        le_info1;        // entry specific info
    ULONG        le_info2;        // entry specific info
    ULONG        le_info3;        // entry specific info
} LOG_ENTRY32, *PLOG_ENTRY32; /* LOG_ENTRY */


/* This structure is 64 bytes regardless of platform */

struct XFER_LOG_ENTRY {
    ULONG        xle_sig;          // Identifying string
    ULONG        Unused1;

    ULONG        BytesRequested;
    ULONG        BytesTransferred;

    ULONG        UrbStatus;
    ULONG        IrpStatus;

    USHORT       DeviceAddress;
    USHORT       EndpointAddress;
    ULONG        TransferType;

    ULONG64      Irp;
    ULONG64      Urb;
    ULONG64      le_info0;
    ULONG64      le_info1;
}; /* XFER_LOG_ENTRY */


typedef struct _DEBUG_LOG {
    ULONG LogIdx;
    ULONG LogSizeMask;
    PLOG_ENTRY LogStart;
    PLOG_ENTRY LogEnd;
} DEBUG_LOG, *PDEBUG_LOG;


VOID
USBPORT_DebugTransfer_LogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    struct _HCD_ENDPOINT *Endpoint,
    struct _HCD_TRANSFER_CONTEXT *Transfer,
    struct _TRANSFER_URB *Urb,
    PIRP Irp,
    NTSTATUS IrpStatus
    );


// log noisy is for entries that tend
// to fill up the log and we genrally
// don' use
#define LOG_NOISY       0x00000001
#define LOG_MINIPORT    0x00000002
#define LOG_XFERS       0x00000004
#define LOG_PNP         0x00000008
#define LOG_MEM         0x00000010
#define LOG_SPIN        0x00000020
#define LOG_POWER       0x00000040
#define LOG_RH          0x00000080
#define LOG_URB         0x00000100
#define LOG_MISC        0x00000200
#define LOG_ISO         0x00000400
#define LOG_IRPS        0x00000800


VOID
USBPORT_LogAlloc(
    PDEBUG_LOG Log,
    ULONG Pages
    );

VOID
USBPORT_LogFree(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEBUG_LOG Log
    );

VOID
USBPORT_AddLogEntry(
    PDEBUG_LOG Log,
    ULONG Mask,
    ULONG Sig,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3,
    BOOLEAN Miniport
    );

typedef union _LOGSIG {
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    } b;
    ULONG l;
} LOGSIG, *PLOGSIG;

#define LOGENTRY(ep, fdo, lmask, lsig, linfo1, linfo2, linfo3)  \
    do {\
    PDEVICE_EXTENSION delog;\
    PDEBUG_LOG llog;\
    extern ULONG USBPORT_DebugLogEnable;\
    extern ULONG USBPORT_LogMask;\
    GET_DEVICE_EXT(delog, (fdo));\
    ASSERT_FDOEXT(delog);\
    if (USBPORT_DebugLogEnable && \
        delog->Log.LogStart != NULL && \
        ((lmask) & USBPORT_LogMask)) {\
        llog = &delog->Log;\
        USBPORT_AddLogEntry(llog, (lmask), (lsig), (linfo1), (linfo2), (linfo3), FALSE);\
    }\
    } while(0);

#define USBPORT_AddLogEntry(log, mask, insig, i1, i2, i3, mp) \
    {\
    PLOG_ENTRY lelog;\
    ULONG ilog;\
    LOGSIG siglog, rsiglog;\
    siglog.l = (insig);\
    rsiglog.b.Byte0 = siglog.b.Byte3;\
    rsiglog.b.Byte1 = siglog.b.Byte2;\
    rsiglog.b.Byte2 = siglog.b.Byte1;\
    rsiglog.b.Byte3 = siglog.b.Byte0;\
    ASSERT((insig) != 0);\
    ilog = InterlockedDecrement(&(log)->LogIdx);\
    ilog &= (log)->LogSizeMask;\
    lelog = (log)->LogStart+ilog;\
    ASSERT(lelog <= (log)->LogEnd);\
    if ((mp)) rsiglog.b.Byte0 = '_';\
    lelog->le_sig = rsiglog.l;\
    lelog->le_info1 = (ULONG_PTR) (i1);\
    lelog->le_info2 = (ULONG_PTR) (i2);\
    lelog->le_info3 = (ULONG_PTR) (i3);\
    };

VOID
USBPORT_EnumLogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    );

/***********
USB BUGCODES

Parameter 1 to the USB bugcheck is always the USBBUGCODE_
************/


//
// USBBUGCODE_INTERNAL_ERROR
// An internal error has occurred in the USB stack
// -- we will eventually never throw these instead
// -- we will find a more graceful way to handle them
//

#define USBBUGCODE_INTERNAL_ERROR    1

//
// USBBUGCODE_BAD_URB
// The USB client driver has submitted a URB that is
// already attached to another irp pending in the bus
// driver.
//
// parameter 2 = address of Pending IRP urb is attached
// parameter 3 = address of  IRP passed in
// parameter 4 = address URB that caused the error
//

#define USBBUGCODE_BAD_URB           2

//
// USBBUGCODE_MINIPORT_ERROR
// The USB miniport driver has generated a bugcheck.
// This is usually in response to catastrophic hardware
// failure.
//
// parameter 2 = PCI Vendor,Product id for the controller
// parameter 3 = pointer to usbport.sys debug log
//

#define USBBUGCODE_MINIPORT_ERROR    3

//
// USBBUGCODE_DOUBLE_SUBMIT
// The USB client driver has submitted a URB that is
// already attached to another irp pending in the bus
// driver.
//
// parameter 2 = address of IRP
// parameter 3 = address URB that caused the error
//

#define USBBUGCODE_DOUBLE_SUBMIT    4

//
// USBBUGCODE_MINIPORT_ERROR_EX
// The USB miniport driver has generated a bugcheck.
// This is usually in response to catastrophic hardware
// failure.
//
// parameter 2 = PCI Vendor,Product id for the controller
// parameter 3 = pointer to usbport.sys driver log
// parameter 4 = miniport defined parameter
//

//#define USBBUGCODE_MINIPORT_ERROR_EX  5


#endif /* __DBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\errata.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    errata.h

Abstract:

    Attempt to document usb device errata.

    Note that we currently only document production devices here, not 
    prototypes.
    
Environment:

    Kernel & user mode

Revision History:

    11-15-01 : created

--*/

#ifndef   __ERRATA_H__
#define   __ERRATA_H__


/*
    VID_045E PID_009 USB Intellimouse

    This device has problems with nultiple packets per frame, it will return 
    a truncated config descriptor and stall error randomly.  This is seen
    on OHCI and EHCI controllers.
*/

/*
    VID_04A6 PID_0180 Nokia Monitor hub
    VID_04A6 PID_0181 Nokia Monitor Hid controls

    This device will not function downstream of a USB 2.0 hub.  The device 
    requests time out probably due to a device response time (ACK) that is 
    not within spec.  Enumeration is erratic or it does enumerate at all.
*/

/*  
    VID_049F PID_000E Samsung (Compaq) composite keyboard

    This devices resume signalling is not within spec (according to 
    Compaq/Intel).  This casues the device to 'disconnect' when signalling 
    resume (AKA remote wake) on some Intel ICH4 chipsets.
*/

/*
    Vid_0738&Pid_4420 Andretti Racing Wheel

    This device has problems with enumeration speed -- ie how quickly the 
    requests are sent following a reset

    This device will also fail the MS OS descriptor request in such a way 
    as to require a reset -- which fails due to reasons above.
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\device.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module creates "Devices" on the bus for
    bus emuerators like the hub driver

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_FreeUsbAddress)
#pragma alloc_text(PAGE, USBPORT_AllocateUsbAddress)
#pragma alloc_text(PAGE, USBPORT_SendCommand)
#endif

// non paged functions
//USBPORT_ValidateDeviceHandle
//USBPORT_RemoveDeviceHandle
//USBPORT_AddDeviceHandle
//USBPORT_ValidatePipeHandle
//USBPORT_OpenEndpoint
//USBPORT_CloseEndpoint
//USBPORT_CreateDevice
//USBPORT_RemoveDevice
//USBPORT_InitializeDevice
//USBPORT_RemovePipeHandle
//USBPORT_AddPipeHandle
//USBPORT_LazyCloseEndpoint
//USBPORT_FlushClosedEndpointList


/*
    Handle validation routines, we keep a list
    of valid handles and match the ones passed
    in with our list.

    Access to the device handle list for

    //USBPORT_CreateDevice
    //USBPORT_RemoveDevice
    //USBPORT_InitializeDevice

    is serialized with a global semaphore so we don't
    need a spinlock.

    BUGBUG
    We may be able to use try/except block
    here but I'm not sure it works at all IRQL
    and on all platforms
*/

BOOLEAN
USBPORT_ValidateDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    BOOLEAN ReferenceUrb
    )
/*++

Routine Description:

    returns true if a device handle is valid

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&devExt->Fdo.DevHandleListSpin.sl, &irql);

    if (DeviceHandle == NULL) {
        // NULL is obviously not valid
        goto USBPORT_ValidateDeviceHandle_Done;
    }

    listEntry = &devExt->Fdo.DeviceHandleList;

    if (!IsListEmpty(listEntry)) {
        listEntry = devExt->Fdo.DeviceHandleList.Flink;
    }

    while (listEntry != &devExt->Fdo.DeviceHandleList) {

        PUSBD_DEVICE_HANDLE nextHandle;

        nextHandle = (PUSBD_DEVICE_HANDLE) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_DEVICE_HANDLE,
                    ListEntry);


        listEntry = nextHandle->ListEntry.Flink;

        if (nextHandle == DeviceHandle) {
            found = TRUE;
            if (ReferenceUrb) {
                InterlockedIncrement(&DeviceHandle->PendingUrbs);
            }
            break;
        }
    }

USBPORT_ValidateDeviceHandle_Done:

#if DBG
    if (!found) {
//        USBPORT_KdPrint((1, "'bad device handle %x\n", DeviceHandle));
        DEBUG_BREAK();
    }
#endif

    KeReleaseSpinLock(&devExt->Fdo.DevHandleListSpin.sl, irql);

    return found;
}


VOID
USBPORT_RemoveDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL,
        FdoDeviceObject, LOG_MISC, 'remD', DeviceHandle, 0, 0);

    // synchronize with the validation function,
    // NOTE: we don't synchornize with the ADD function becuause it
    // is already serialized
    USBPORT_InterlockedRemoveEntryList(&DeviceHandle->ListEntry,
                                       &devExt->Fdo.DevHandleListSpin.sl);


}


ULONG
USBPORT_GetDeviceCount(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    counts devices on the BUS

Arguments:

Return Value:

    number of devices (including the root hub)

--*/
{
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    ULONG deviceCount = 0;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&devExt->Fdo.DevHandleListSpin.sl, &irql);

    listEntry = &devExt->Fdo.DeviceHandleList;

    if (!IsListEmpty(listEntry)) {
        listEntry = devExt->Fdo.DeviceHandleList.Flink;
    }

    while (listEntry != &devExt->Fdo.DeviceHandleList) {

        PUSBD_DEVICE_HANDLE nextHandle;

        nextHandle = (PUSBD_DEVICE_HANDLE) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_DEVICE_HANDLE,
                    ListEntry);

        deviceCount++;

        listEntry = nextHandle->ListEntry.Flink;

    }

    KeReleaseSpinLock(&devExt->Fdo.DevHandleListSpin.sl, irql);

    return deviceCount;

}


VOID
USBPORT_AddDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    adds a device handle to our internal list

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    PDEVICE_EXTENSION devExt;

    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'addD', DeviceHandle, 0, 0);

    InsertTailList(&devExt->Fdo.DeviceHandleList,
        &DeviceHandle->ListEntry);

}


VOID
USBPORT_RemovePipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    Removes a pipe handle from our list of 'valid handles'

Arguments:

Return Value:

    none

--*/
{
    USBPORT_ASSERT(PipeHandle->ListEntry.Flink != NULL &&
                   PipeHandle->ListEntry.Blink != NULL);

    RemoveEntryList(&PipeHandle->ListEntry);
    PipeHandle->ListEntry.Flink = NULL;
    PipeHandle->ListEntry.Blink = NULL;
}


VOID
USBPORT_AddPipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    adds a pipe handle to our internal list

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    USBPORT_ASSERT(PipeHandle->ListEntry.Flink == NULL &&
                   PipeHandle->ListEntry.Blink == NULL);

    InsertTailList(&DeviceHandle->PipeHandleList,
        &PipeHandle->ListEntry);
}


BOOLEAN
USBPORT_ValidatePipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    returns true if a device handle is valid

Arguments:

Return Value:

    TRUE is handle is valid

--*/
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY listEntry;

    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;

    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;

        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I,
                    ListEntry);


        listEntry = nextHandle->ListEntry.Flink;

        if (nextHandle == PipeHandle) {
            found = TRUE;
            break;
        }
    }

#if DBG
    if (!found) {
        USBPORT_KdPrint((1, "'bad pipe handle %x\n", PipeHandle));
        DEBUG_BREAK();
    }
#endif

    return found;
}


NTSTATUS
USBPORT_SendCommand(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PVOID Buffer,
    ULONG BufferLength,
    PULONG BytesReturned,
    USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    Send a standard USB command on the default pipe.

    essentially what we do here is build a control
    transfer and queue it directly

Arguments:

    DeviceHandle - ptr to USBPORT device structure the command will be sent to

    DeviceObject -

    RequestCode -

    WValue - wValue for setup packet

    WIndex - wIndex for setup packet

    WLength - wLength for setup packet

    Buffer - Input/Output Buffer for command

    BufferLength - Length of Input/Output buffer.

    BytesReturned - pointer to ulong to copy number of bytes
                    returned (optional)

    UsbStatus - USBPORT status code returned in the URB.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PTRANSFER_URB urb = NULL;
    PUSBD_PIPE_HANDLE_I defaultPipe = &(DeviceHandle->DefaultPipe);
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    KEVENT event;

    PAGED_CODE();
    USBPORT_KdPrint((2, "'enter USBPORT_SendCommand\n"));

    ASSERT_DEVICE_HANDLE(DeviceHandle);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT((USHORT)BufferLength == SetupPacket->wLength);

    LOGENTRY(defaultPipe->Endpoint,
        FdoDeviceObject, LOG_MISC, 'SENc', 0, 0, 0);


    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    ALLOC_POOL_Z(urb, NonPagedPool,
                 sizeof(struct _TRANSFER_URB));

    if (urb) {
        InterlockedIncrement(&DeviceHandle->PendingUrbs);

        ntStatus = STATUS_SUCCESS;
        usbdStatus = USBD_STATUS_SUCCESS;

        urb->Hdr.Length = sizeof(struct _TRANSFER_URB);
        urb->Hdr.Function = URB_FUNCTION_CONTROL_TRANSFER;

        RtlCopyMemory(urb->u.SetupPacket,
                      SetupPacket,
                      8);

        urb->TransferFlags = USBD_SHORT_TRANSFER_OK;
        urb->UsbdPipeHandle = defaultPipe;
        urb->Hdr.UsbdDeviceHandle = DeviceHandle;
        urb->Hdr.UsbdFlags = 0;

        // USBPORT is responsible for setting the transfer direction
        //
        // TRANSFER direction is implied in the command

        if (SetupPacket->bmRequestType.Dir ==  BMREQUEST_DEVICE_TO_HOST) {
            USBPORT_SET_TRANSFER_DIRECTION_IN(urb->TransferFlags);
        } else {
            USBPORT_SET_TRANSFER_DIRECTION_OUT(urb->TransferFlags);
        }

        urb->TransferBufferLength = BufferLength;
        urb->TransferBuffer = Buffer;
        urb->TransferBufferMDL = NULL;

        if (urb->TransferBufferLength != 0) {

            if ((urb->TransferBufferMDL =
                 IoAllocateMdl(urb->TransferBuffer,
                               urb->TransferBufferLength,
                               FALSE,
                               FALSE,
                               NULL)) == NULL) {
                usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
                // map the error
                ntStatus = USBPORT_SetUSBDError(NULL, usbdStatus);
            } else {
                SET_FLAG(urb->Hdr.UsbdFlags, USBPORT_REQUEST_MDL_ALLOCATED);
                MmBuildMdlForNonPagedPool(
                    urb->TransferBufferMDL);
            }

        }

        LOGENTRY(defaultPipe->Endpoint, FdoDeviceObject,
                    LOG_MISC, 'sndC',
                        urb->TransferBufferLength,
                        SetupPacket->bmRequestType.B,
                        SetupPacket->bRequest);
        USBPORT_KdPrint((2,
            "'SendCommand cmd = 0x%x  0x%x buffer = 0x%x length = 0x%x direction = 0x%x\n",
                         SetupPacket->bmRequestType.B,
                         SetupPacket->bRequest,
                         urb->TransferBuffer,
                         urb->TransferBufferLength,
                         urb->TransferFlags));

        // queue the transfer
        if (NT_SUCCESS(ntStatus)) {

            usbdStatus = USBPORT_AllocTransfer(FdoDeviceObject,
                                               urb,
                                               NULL,
                                               NULL,
                                               &event,
                                               5000);

            if (USBD_SUCCESS(usbdStatus)) {
                // do the transfer, 5 second timeout

                // match the decrement in queue transferurb
                InterlockedIncrement(&DeviceHandle->PendingUrbs);
                USBPORT_QueueTransferUrb(urb);

                LOGENTRY(NULL, FdoDeviceObject,
                    LOG_MISC, 'sWTt', 0, 0, 0);

                // wait for completion
                KeWaitForSingleObject(&event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                LOGENTRY(NULL, FdoDeviceObject,
                    LOG_MISC, 'sWTd', 0, 0, 0);
                // map the error
                usbdStatus = urb->Hdr.Status;
            }

            ntStatus =
                SET_USBD_ERROR(urb, usbdStatus);

            if (BytesReturned) {
                *BytesReturned = urb->TransferBufferLength;
            }

            if (UsbdStatus) {
                *UsbdStatus = usbdStatus;
            }
        }
        // free the transfer URB

        InterlockedDecrement(&DeviceHandle->PendingUrbs);
        FREE_POOL(FdoDeviceObject, urb);

    } else {
        if (UsbdStatus) {
            *UsbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
            ntStatus = USBPORT_SetUSBDError(NULL, *UsbdStatus);
        } else {
            ntStatus = USBPORT_SetUSBDError(NULL, USBD_STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    //LOGENTRY(defaultPipe->Endpoint,
    //    FdoDeviceObject, LOG_MISC, 'SENd', 0, ntStatus, usbdStatus);

    USBPORT_KdPrint((2, "'exit USBPORT_SendCommand 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPORT_PokeEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    This function closes an existing endpoint in the miniport,
    frees the common buffer the reopens it with new requirements
    and parameters.

    This function is synchronous and assumes no active transfers
    are pending for the endpoint.

    This function is currently used to grow the transfer parameters
    on interrupt and control endpoints and to change the address of
    the default control endpoint

    NOTES:
        1. for now we assume no changes to bw allocation
        2. new parameters are set before the call in the endpoint
            structure

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    ENDPOINT_REQUIREMENTS requirements;
    USB_MINIPORT_STATUS mpStatus;
    PDEVICE_EXTENSION devExt;
    PUSBPORT_COMMON_BUFFER commonBuffer;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // close the endpoint in the miniport

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'poke', Endpoint, 0, 0);

    // mark the endpoint busy so that we don't poll it until
    // we open it again
    do {
        busy = InterlockedIncrement(&Endpoint->Busy);

        if (!busy) {
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'pNby', 0, Endpoint, busy);
            break;
        }

        // defer processing
        InterlockedDecrement(&Endpoint->Busy);
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'pbsy', 0, Endpoint, busy);
        USBPORT_Wait(FdoDeviceObject, 1);

    } while (busy != 0);

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'Ley0');
    MP_SetEndpointState(devExt, Endpoint, ENDPOINT_REMOVE);
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'Uey0');

    USBPORT_Wait(FdoDeviceObject, 2);
    // enpoint should now be out of the schedule

    // zero miniport data
    RtlZeroMemory(&Endpoint->MiniportEndpointData[0],
                  REGISTRATION_PACKET(devExt).EndpointDataSize);


    // free the old miniport common buffer
    if (Endpoint->CommonBuffer) {
        USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                    Endpoint->CommonBuffer);
        Endpoint->CommonBuffer = NULL;
    }

    MP_QueryEndpointRequirements(devExt,
                                 Endpoint,
                                 &requirements);

    // alloc new common buffer
    // save the requirements

    USBPORT_ASSERT(Endpoint->Parameters.TransferType != Bulk);
    USBPORT_ASSERT(Endpoint->Parameters.TransferType != Isochronous);

    USBPORT_KdPrint((1, "'(POKE) miniport requesting %d bytes\n",
        requirements.MinCommonBufferBytes));

    // allocate common buffer for this endpoint

    if (requirements.MinCommonBufferBytes) {
        commonBuffer =
            USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,
                                            requirements.MinCommonBufferBytes);
    } else {
        commonBuffer = NULL;
    }

    if (commonBuffer == NULL &&
        requirements.MinCommonBufferBytes) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        Endpoint->CommonBuffer = NULL;

    } else {
        Endpoint->CommonBuffer = commonBuffer;
        ntStatus = STATUS_SUCCESS;
    }

    // this check is redundant but it keeps
    // prefast happy
    if (Endpoint->CommonBuffer &&
        commonBuffer) {

        Endpoint->Parameters.CommonBufferVa =
             commonBuffer->MiniportVa;
        Endpoint->Parameters.CommonBufferPhys =
             commonBuffer->MiniportPhys;
        Endpoint->Parameters.CommonBufferBytes =
             commonBuffer->MiniportLength;
    }

    if (NT_SUCCESS(ntStatus)) {
        MP_OpenEndpoint(devExt, Endpoint, mpStatus);

        // in this UNIQUE situation this API is not allowed
        // (and should not) fail
        USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

        // we need to sync the endpoint state with
        // the miniport, when first opened the miniport
        // puts the endpoint in status HALT.

        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeK0');
        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, Endpoint);
        if (Endpoint->CurrentState == ENDPOINT_ACTIVE) {
            RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint);
            MP_SetEndpointState(devExt, Endpoint, ENDPOINT_ACTIVE);
        } else {
            RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint);
        }
        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeK0');
    }

    InterlockedDecrement(&Endpoint->Busy);

    return ntStatus;

}


VOID
USBPORT_WaitActive(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
{
    MP_ENDPOINT_STATE currentState;

    ASSERT_ENDPOINT(Endpoint);

    do {
        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeH0');

        currentState = USBPORT_GetEndpointState(Endpoint);

        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeH0');

        LOGENTRY(Endpoint,
                FdoDeviceObject, LOG_XFERS, 'watA', Endpoint,
                    currentState, 0);

        if (currentState == ENDPOINT_ACTIVE) {
            // quick release
            break;
        }

        ASSERT_PASSIVE();
        USBPORT_Wait(FdoDeviceObject, 1);

    } while (currentState != ENDPOINT_ACTIVE);

}


NTSTATUS
USBPORT_OpenEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle,
    OUT USBD_STATUS *ReturnUsbdStatus,
    BOOLEAN IsDefaultPipe
    )
/*++

Routine Description:

    open an endpoint on a USB device.

    This function creates (initializes) endpoints and
    hooks it to a pipehandle

Arguments:

    DeviceHandle - data describes the device this endpoint is on.

    DeviceObject - USBPORT device object.

    ReturnUsbdStatus - OPTIONAL

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    PHCD_ENDPOINT endpoint;
    USBD_STATUS usbdStatus;
    ULONG siz;
    BOOLEAN gotBw;
    USB_HIGH_SPEED_MAXPACKET muxPacket;
    extern ULONG USB2LIB_EndpointContextSize;

    // this function is not pagable because we raise irql

    // we should be at passive level
    ASSERT_PASSIVE();

    // devhandle should have been validated
    // before we get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    siz = sizeof(*endpoint) + REGISTRATION_PACKET(devExt).EndpointDataSize;

    if (USBPORT_IS_USB20(devExt)) {
        siz += USB2LIB_EndpointContextSize;
    }

    LOGENTRY(NULL, FdoDeviceObject,
             LOG_PNP, 'opE+', PipeHandle, siz,
             REGISTRATION_PACKET(devExt).EndpointDataSize);

    // allocate the endoint

    // * begin special case
    // check for a no bandwidth endpoint ie max_oacket = 0
    // if so return success and set the endpoint pointer
    // in the pipe handle to a dummy value

    if (PipeHandle->EndpointDescriptor.wMaxPacketSize == 0) {

        USBPORT_AddPipeHandle(DeviceHandle,
                              PipeHandle);

        PipeHandle->Endpoint = USB_BAD_PTR;
        ntStatus = STATUS_SUCCESS;
        SET_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW);
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);

        goto USBPORT_OpenEndpoint_Done;
    }

    // * end special case

    ALLOC_POOL_Z(endpoint, NonPagedPool, siz);

    if (endpoint) {

        endpoint->Sig = SIG_ENDPOINT;
        endpoint->Flags = 0;
        endpoint->EndpointRef = 0;
        endpoint->Busy = -1;
        endpoint->FdoDeviceObject = FdoDeviceObject;
        endpoint->DeviceHandle = DeviceHandle;

//        USBPORT_ResetEndpointIdle(endpoint);

        endpoint->Tt = DeviceHandle->Tt;
        if (endpoint->Tt != NULL) {
            ASSERT_TT(endpoint->Tt);
            ExInterlockedInsertTailList(&DeviceHandle->Tt->EndpointList,
                                        &endpoint->TtLink,
                                        &devExt->Fdo.TtEndpointListSpin.sl);
        }

        if (USBPORT_IS_USB20(devExt)) {
            PUCHAR pch;

            pch = (PUCHAR) &endpoint->MiniportEndpointData[0];
            pch += REGISTRATION_PACKET(devExt).EndpointDataSize;

            endpoint->Usb2LibEpContext = pch;
        } else {
            endpoint->Usb2LibEpContext = USB_BAD_PTR;
        }

#if DBG
        USBPORT_LogAlloc(&endpoint->Log, 1);
#endif
        LOGENTRY(endpoint, FdoDeviceObject,
             LOG_PNP, 'ope+', PipeHandle, siz,
             REGISTRATION_PACKET(devExt).EndpointDataSize);

        // initialize the endpoint
        InitializeListHead(&endpoint->ActiveList);
        InitializeListHead(&endpoint->CancelList);
        InitializeListHead(&endpoint->PendingList);
        InitializeListHead(&endpoint->AbortIrpList);

        USBPORT_InitializeSpinLock(&endpoint->ListSpin, 'EPL+', 'EPL-');
        USBPORT_InitializeSpinLock(&endpoint->StateChangeSpin, 'SCL+', 'SCL-');

        // extract some information from the
        // descriptor
        endpoint->Parameters.DeviceAddress =
            DeviceHandle->DeviceAddress;

        if (endpoint->Tt != NULL) {
            ASSERT_TT(endpoint->Tt);
            endpoint->Parameters.TtDeviceAddress =
                endpoint->Tt->DeviceAddress;
        } else {
            endpoint->Parameters.TtDeviceAddress = 0xFFFF;
        }

        endpoint->Parameters.TtPortNumber =
            DeviceHandle->TtPortNumber;

        muxPacket.us = PipeHandle->EndpointDescriptor.wMaxPacketSize;
        endpoint->Parameters.MuxPacketSize =
            muxPacket.MaxPacket;
        endpoint->Parameters.TransactionsPerMicroframe =
            muxPacket.HSmux+1;
        endpoint->Parameters.MaxPacketSize =
            muxPacket.MaxPacket * (muxPacket.HSmux+1);

        endpoint->Parameters.EndpointAddress =
            PipeHandle->EndpointDescriptor.bEndpointAddress;

        if ((PipeHandle->EndpointDescriptor.bmAttributes &
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
#ifdef ISO_LOG
            USBPORT_LogAlloc(&endpoint->IsoLog, 4);
#endif
            endpoint->Parameters.TransferType = Isochronous;
        } else if ((PipeHandle->EndpointDescriptor.bmAttributes &
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_BULK) {
            endpoint->Parameters.TransferType = Bulk;
        } else if ((PipeHandle->EndpointDescriptor.bmAttributes &
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_INTERRUPT) {
            endpoint->Parameters.TransferType = Interrupt;
        } else {
            USBPORT_ASSERT((PipeHandle->EndpointDescriptor.bmAttributes &
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_CONTROL);
            endpoint->Parameters.TransferType = Control;
        }

        // check for low speed
        endpoint->Parameters.DeviceSpeed = DeviceHandle->DeviceSpeed;

        // Set max transfer size based on transfer type
        //
        // Note: that the MaximumTransferSize set by the
        // client driver in the pipe information structure
        // is no longer used.
        switch(endpoint->Parameters.TransferType) {
        case Interrupt:
            // this allows clients to put down larger
            // interrupt buffers if they want without
            // taking a perf hit. For some reason
            // printers do this.

            // bugbug research the praticality of splitting
            // interrupt transfers for the miniports this may
            // significantly reduce the memory allocated by
            // he uhci miniport
            endpoint->Parameters.MaxTransferSize = 1024;
                 //endpoint->Parameters.MaxPacketSize;
            break;
        case Control:
            // 4k
            // node that the old win2k 4k usb stack does not actually
            // handle transfers larger than this correctly.
            endpoint->Parameters.MaxTransferSize = 1024*4;

            // set the default to 64k if this is not the control endpoint
            if (endpoint->Parameters.EndpointAddress != 0) {
                // the COMPAQ guys test this

                endpoint->Parameters.MaxTransferSize = 1024*64;
            }
            break;
        case Bulk:
            // 64k default
            endpoint->Parameters.MaxTransferSize = 1024*64;
            break;
        case Isochronous:
            // there is no reason to have a limit here
            // choose a really large default
            endpoint->Parameters.MaxTransferSize = 0x01000000;
            break;
        }

        endpoint->Parameters.Period = 0;

        // compute period required
        if (endpoint->Parameters.TransferType == Interrupt) {

            UCHAR tmp;
            UCHAR hsInterval;

            if (endpoint->Parameters.DeviceSpeed == HighSpeed) {
                // normalize the high speed period to microframes
                // for USB 20 the period specifies a power of 2
                // ie period = 2^(hsInterval-1)
                hsInterval = PipeHandle->EndpointDescriptor.bInterval;
                if (hsInterval) {
                    hsInterval--;
                }
                // hsInterval must be 0..5
                if (hsInterval > 5) {
                    hsInterval = 5;
                }
                tmp = 1<<hsInterval;
            } else {
                tmp = PipeHandle->EndpointDescriptor.bInterval;
            }
            // this code finds the first interval
            // <= USBPORT_MAX_INTEP_POLLING_INTERVAL
            // valid intervals are:
            // 1, 2, 4, 8, 16, 32(USBPORT_MAX_INTEP_POLLING_INTERVAL)

            // Initialize Period, may be adjusted down

            endpoint->Parameters.Period = USBPORT_MAX_INTEP_POLLING_INTERVAL;

            if ((tmp != 0) && (tmp < USBPORT_MAX_INTEP_POLLING_INTERVAL)) {

                // bInterval is in range.  Adjust Period down if necessary.

                if ((endpoint->Parameters.DeviceSpeed == LowSpeed) &&
                    (tmp < 8)) {

                    // bInterval is not valid for LowSpeed, cap Period at 8

                    endpoint->Parameters.Period = 8;

                } else {

                    // Adjust Period down to greatest power of 2 less than or
                    // equal to bInterval.

                    while ((endpoint->Parameters.Period & tmp) == 0) {
                        endpoint->Parameters.Period >>= 1;
                    }
                }
            }

//!!!
//if (endpoint->Parameters.DeviceSpeed == LowSpeed) {
//    TEST_TRAP();
//    endpoint->Parameters.Period = 1;
//}
//!!!

            endpoint->Parameters.MaxPeriod =
                endpoint->Parameters.Period;
        }

        if (endpoint->Parameters.TransferType == Isochronous) {
            endpoint->Parameters.Period = 1;
        }

        if (IS_ROOT_HUB(DeviceHandle)) {
            SET_FLAG(endpoint->Flags, EPFLAG_ROOTHUB);
        }

        if (USB_ENDPOINT_DIRECTION_IN(
            PipeHandle->EndpointDescriptor.bEndpointAddress)) {
            endpoint->Parameters.TransferDirection = In;
        } else {
            endpoint->Parameters.TransferDirection = Out;
        }

        if (USBPORT_IS_USB20(devExt)) {
            // call the engine and attempt to allocate the necessary
            // bus time for this endoint
            gotBw = USBPORT_AllocateBandwidthUSB20(FdoDeviceObject, endpoint);
//!!!
//if (endpoint->Parameters.DeviceSpeed == LowSpeed) {
//    TEST_TRAP();
//    endpoint->Parameters.InterruptScheduleMask = 0x10; //sMask;
//    endpoint->Parameters.SplitCompletionMask = 0xc1; //cMask;
//}
//!!!

        } else {
            // * USB 1.1

            endpoint->Parameters.Bandwidth =
                USBPORT_CalculateUsbBandwidth(FdoDeviceObject, endpoint);

            // caclualte the best schedule position
            gotBw = USBPORT_AllocateBandwidthUSB11(FdoDeviceObject, endpoint);
        }

        if (gotBw) {

            if (IsDefaultPipe ||
                endpoint->Parameters.TransferType == Isochronous) {
                // iso and default pipes do not halt on errors
                // ie they do not require a resetpipe
                endpoint->Parameters.EndpointFlags |= EP_PARM_FLAG_NOHALT;
            }

            ntStatus = STATUS_SUCCESS;
        } else {
            LOGENTRY(endpoint,
                FdoDeviceObject, LOG_PNP, 'noBW', endpoint, 0, 0);

            // no bandwidth error
            ntStatus = USBPORT_SetUSBDError(NULL, USBD_STATUS_NO_BANDWIDTH);
            if (ReturnUsbdStatus != NULL) {
                *ReturnUsbdStatus = USBD_STATUS_NO_BANDWIDTH;
            }
        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(ntStatus)) {

        // now do the open

        if (TEST_FLAG(endpoint->Flags, EPFLAG_ROOTHUB)) {
            PDEVICE_EXTENSION rhDevExt;

            GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
            ASSERT_PDOEXT(rhDevExt);

            // opens for the root hub device
            // are not passed to the miniport
            usbdStatus = USBD_STATUS_SUCCESS;

            endpoint->EpWorkerFunction =
                USBPORT_RootHub_EndpointWorker;

            // successful open the enpoint defaults
            // to active
            endpoint->NewState =
                endpoint->CurrentState = ENDPOINT_ACTIVE;

            // track the hub interrupt endpoint
            if (endpoint->Parameters.TransferType == Interrupt) {
                rhDevExt->Pdo.RootHubInterruptEndpoint =
                    endpoint;
            }

        } else {

            USB_MINIPORT_STATUS mpStatus;
            PUSBPORT_COMMON_BUFFER commonBuffer;
            ENDPOINT_REQUIREMENTS requirements;
            ULONG ordinal;

            // find out what we will need from the
            // miniport for this endpoint

            MP_QueryEndpointRequirements(devExt,
                endpoint, &requirements);

            // adjust maxtransfer based on miniport
            // feedback.
            switch (endpoint->Parameters.TransferType) {
            case Bulk:
            case Interrupt:
                LOGENTRY(endpoint,
                    FdoDeviceObject, LOG_MISC, 'MaxT', endpoint,
                    requirements.MaximumTransferSize, 0);

                EP_MAX_TRANSFER(endpoint) =
                    requirements.MaximumTransferSize;
                break;
            }

            ordinal = USBPORT_SelectOrdinal(FdoDeviceObject,
                                            endpoint);

            USBPORT_KdPrint((1, "'miniport requesting %d bytes\n",
                requirements.MinCommonBufferBytes));

            // allocate common buffer for this endpoint
            if (requirements.MinCommonBufferBytes) {
                commonBuffer =
                   USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,
                           requirements.MinCommonBufferBytes);
            } else {
                commonBuffer = NULL;
            }


            if (commonBuffer == NULL &&
                requirements.MinCommonBufferBytes) {

                mpStatus = USBMP_STATUS_NO_RESOURCES;
                endpoint->CommonBuffer = NULL;

            } else {

                ULONG mpOptionFlags;

                mpOptionFlags = REGISTRATION_PACKET(devExt).OptionFlags;

                endpoint->CommonBuffer = commonBuffer;
                if (commonBuffer != NULL) {
                    endpoint->Parameters.CommonBufferVa =
                        commonBuffer->MiniportVa;
                    endpoint->Parameters.CommonBufferPhys =
                        commonBuffer->MiniportPhys;
                    endpoint->Parameters.CommonBufferBytes =
                        commonBuffer->MiniportLength;
                }
                endpoint->Parameters.Ordinal = ordinal;

                // call open request to minport
                MP_OpenEndpoint(devExt, endpoint, mpStatus);

                // note that once we call open this enpoint
                // may show up on the Attention list

                // set our internal flags based on what the
                // miniport passed back
//                if (endpoint->Parameters.EndpointFlags & EP_PARM_FLAG_DMA) {
                SET_FLAG(endpoint->Flags, EPFLAG_MAP_XFERS);

                if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
                    // no mapping for the virtual bus
                    CLEAR_FLAG(endpoint->Flags, EPFLAG_MAP_XFERS);
                    SET_FLAG(endpoint->Flags, EPFLAG_VBUS);
                }
                SET_FLAG(endpoint->Flags, EPFLAG_VIRGIN);
                endpoint->EpWorkerFunction =
                        USBPORT_DmaEndpointWorker;
//                } else {
                    // non-dma endpoint
//                    TEST_TRAP();
//                }
            }

            // successful open the enpoint defaults
            // to pause, we need to move it to active

            if (mpStatus == USBMP_STATUS_SUCCESS) {
                ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeF0');
                // initialize endpoint state machine
                endpoint->CurrentState = ENDPOINT_PAUSE;
                endpoint->NewState = ENDPOINT_PAUSE;
                endpoint->CurrentStatus = ENDPOINT_STATUS_RUN;
                USBPORT_SetEndpointState(endpoint, ENDPOINT_ACTIVE);
                RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeF0');

                // Wait for endpoint to go active. The reason here
                // is that an iso driver (usbaudio) will immediatly
                // send transfers to the endpoint, these tranfers are
                // marked with a transmission frame on submission but
                // will have to wait until the endpoint is active to
                // be programmed, hence they arrive in the miniport
                // too late on slower systems.
                USBPORT_WaitActive(FdoDeviceObject,
                                   endpoint);
            }

            usbdStatus = MPSTATUS_TO_USBSTATUS(mpStatus);
        }

        // convert usb status to nt status
        ntStatus = USBPORT_SetUSBDError(NULL, usbdStatus);
        if (ReturnUsbdStatus != NULL) {
            *ReturnUsbdStatus = usbdStatus;
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        USBPORT_AddPipeHandle(DeviceHandle,
                              PipeHandle);

        // track the endpoint
        ExInterlockedInsertTailList(&devExt->Fdo.GlobalEndpointList,
                                    &endpoint->GlobalLink,
                                    &devExt->Fdo.EndpointListSpin.sl);

        PipeHandle->Endpoint = endpoint;
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);

    } else {
        if (endpoint) {
            if (endpoint->Tt != NULL) {
                ASSERT_TT(endpoint->Tt);
                USBPORT_InterlockedRemoveEntryList(&endpoint->TtLink,
                                                   &devExt->Fdo.TtEndpointListSpin.sl);
            }
            USBPORT_LogFree(FdoDeviceObject, &endpoint->Log);
            UNSIG(endpoint);
            FREE_POOL(FdoDeviceObject, endpoint);
        }
    }

USBPORT_OpenEndpoint_Done:

    return ntStatus;
}


VOID
USBPORT_CloseEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Close an Endpoint

Arguments:

    DeviceHandle - ptr to USBPORT device data structure.

    DeviceObject - USBPORT device object.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = 0;
    PURB urb;
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    KIRQL irql;
    BOOLEAN stallClose;
    LONG busy;

    // should have been validated before we
    // get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should have no requests queued to the
    // endpoint
    LOGENTRY(Endpoint, FdoDeviceObject,
                LOG_MISC, 'clEP', Endpoint, 0, 0);

//    USBPORT_ResetEndpointIdle(Endpoint);

    // remove from our 'Active' lists
    KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

    if (TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB) &&
        Endpoint->Parameters.TransferType == Interrupt) {

        KIRQL rhIrql;
        PDEVICE_EXTENSION rhDevExt;

        // remove references to th eroot hub

        ACQUIRE_ROOTHUB_LOCK(FdoDeviceObject, rhIrql);

        // we should have a root hub pdo since we are closing
        // an endpoint associated with it.

        USBPORT_ASSERT(devExt->Fdo.RootHubPdo != NULL);

        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);

        rhDevExt->Pdo.RootHubInterruptEndpoint = NULL;

        RELEASE_ROOTHUB_LOCK(FdoDeviceObject, rhIrql);

    }

    KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

    // The client is locked out at this point ie he can't access the
    // pipe tied to the endpoint.  We need to wait for any outstanding
    // stuff to complete -- including any state changes, after which
    // we can ask the coreworker to remove the endpoint.

    // the endpoint lock protects the lists -- which need to be
    // empty

    do {

        stallClose = FALSE;
        ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeD1');

        if (!IsListEmpty(&Endpoint->PendingList)) {
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'stc1', Endpoint, 0, 0);
            stallClose = TRUE;
        }

        if (!IsListEmpty(&Endpoint->ActiveList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc2', Endpoint, 0, 0);
            stallClose = TRUE;
        }

        if (!IsListEmpty(&Endpoint->CancelList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc3', Endpoint, 0, 0);
            stallClose = TRUE;
        }

        if (!IsListEmpty(&Endpoint->AbortIrpList)) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc4', Endpoint, 0, 0);
            stallClose = TRUE;
        }

        if (Endpoint->EndpointRef) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc6', Endpoint, 0, 0);
            stallClose = TRUE;
        }

        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, Endpoint);
        if (Endpoint->CurrentState !=
            Endpoint->NewState) {
            LOGENTRY(Endpoint, FdoDeviceObject, LOG_XFERS, 'stc5', Endpoint, 0, 0);
            stallClose = TRUE;
        }
        RELEASE_STATECHG_LOCK(FdoDeviceObject, Endpoint);
        RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeD1');

        // last check...
        // synchronize with worker
        // we just need to wait for worker to finish if it is running
        // it should not pick up and run again unless it has stuff to
        // do -- in which case stallClose will already be set.
        busy = InterlockedIncrement(&Endpoint->Busy);
        if (busy) {
            // defer processing
            LOGENTRY(Endpoint,
                FdoDeviceObject, LOG_XFERS, 'clby', 0, Endpoint, 0);
            stallClose = TRUE;
        }
        InterlockedDecrement(&Endpoint->Busy);

        if (stallClose) {
            LOGENTRY(Endpoint,
                FdoDeviceObject, LOG_XFERS, 'stlC', 0, Endpoint, 0);
            USBPORT_Wait(FdoDeviceObject, 1);
        }

    } while (stallClose);

    LOGENTRY(Endpoint,
        FdoDeviceObject, LOG_XFERS, 'CLdn', 0, Endpoint, 0);

    // unlink ref to device handle since it will be removed when
    // all endpoints are closed
    Endpoint->DeviceHandle = NULL;

    // lock the endpoint & set the state to remove and
    // free the bw
    if (USBPORT_IS_USB20(devExt)) {
        PTRANSACTION_TRANSLATOR tt;

        USBPORT_FreeBandwidthUSB20(FdoDeviceObject, Endpoint);

        KeAcquireSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, &irql);
        tt = Endpoint->Tt;
        if (tt != NULL) {
            ASSERT_TT(tt);

            USBPORT_ASSERT(Endpoint->TtLink.Flink != NULL);
            USBPORT_ASSERT(Endpoint->TtLink.Blink != NULL);
            RemoveEntryList(&Endpoint->TtLink);
            Endpoint->TtLink.Flink = NULL;
            Endpoint->TtLink.Blink = NULL;
            if (TEST_FLAG(tt->TtFlags, USBPORT_TTFLAG_REMOVED) &&
                IsListEmpty(&tt->EndpointList)) {

                ULONG i, bandwidth;

                USBPORT_UpdateAllocatedBwTt(tt);
                // alloc new
                bandwidth = tt->MaxAllocedBw;
                for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
                    devExt->Fdo.BandwidthTable[i] += bandwidth;
                }

                // last endpoint free the TT if it is marked gone
                FREE_POOL(FdoDeviceObject, tt);

            }
        }
        KeReleaseSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, irql);

    } else {
        USBPORT_FreeBandwidthUSB11(FdoDeviceObject, Endpoint);
    }

    ACQUIRE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'LeD0');
    USBPORT_SetEndpointState(Endpoint, ENDPOINT_REMOVE);
    RELEASE_ENDPOINT_LOCK(Endpoint, FdoDeviceObject, 'UeD0');

    // the endpoint will be freed when it reaches the 'REMOVE'
    // state
    // endpointWorker will be signalled when a frame has passed
    // at that time the endpoint will be moved to the closed list
    // and the worker thread will be signalled to flush the closed
    // endpoints ie free the common buffer.

    USBPORT_SignalWorker(FdoDeviceObject);

    return;
}


VOID
USBPORT_ClosePipe(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle
    )
/*++

Routine Description:

    Close a USB pipe and the endpoint associated with it

    This is a synchronous operation that waits for all
    transfers associated with the pipe to be completed.

Arguments:

    DeviceHandle - ptr to USBPORT device data structure.

    DeviceObject - USBPORT device object.

    PipeHandle - USBPORT pipe handle associated with the endpoint.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = 0;
    PDEVICE_EXTENSION devExt;

    // should have beed validated before we
    // get here
    ASSERT_DEVICE_HANDLE(DeviceHandle);
    ASSERT_PIPE_HANDLE(PipeHandle);

    LOGENTRY(NULL, FdoDeviceObject,
                LOG_MISC, 'clPI', PipeHandle, 0, 0);

    if (PipeHandle->PipeStateFlags & USBPORT_PIPE_STATE_CLOSED) {
        // already closed
        // generally when a pertially open interface needs to
        // be closed due to an error
        USBPORT_ASSERT(PipeHandle->ListEntry.Flink == NULL &&
                   PipeHandle->ListEntry.Blink == NULL);

        return;
    }

    // invalidate the pipe
    USBPORT_RemovePipeHandle(DeviceHandle,
                             PipeHandle);

    SET_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_STATE_CLOSED);

    // at this point the client will be unable to queue
    // any transfers to this pipe or endpoint

    // BUGBUG flush tranfers and wait, this also includes waiting
    // for any state changes to complete

    LOGENTRY(NULL, FdoDeviceObject,
                LOG_MISC, 'pipW', PipeHandle, 0, 0);

//    KeWait(PipeEvent) {
//    }

    // now 'close' the endpoint
    if (TEST_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
        CLEAR_FLAG(PipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW);
    } else {
        USBPORT_CloseEndpoint(DeviceHandle,
                              FdoDeviceObject,
                              PipeHandle->Endpoint);
    }
}


VOID
USBPORT_FlushClosedEndpointList(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    walk the "closed" endpoint list and close any endpoints
    that are ready.

    endpoints are placed on the 'closed' list when they reach the
    removed state.

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    KIRQL irql;
    BOOLEAN closed = TRUE;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject,
                LOG_NOISY, 'fCLO', FdoDeviceObject, 0, 0);

    // stall any closes
    KeAcquireSpinLock(&devExt->Fdo.EpClosedListSpin.sl, &irql);

    while (!IsListEmpty(&devExt->Fdo.EpClosedList) &&
            closed) {

        listEntry = RemoveHeadList(&devExt->Fdo.EpClosedList);

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                            listEntry,
                            struct _HCD_ENDPOINT,
                            ClosedLink);

        LOGENTRY(NULL, FdoDeviceObject,
                LOG_PNP, 'fclo', endpoint, 0, 0);

        ASSERT_ENDPOINT(endpoint);
        USBPORT_ASSERT(endpoint->CurrentState == ENDPOINT_CLOSED);
        endpoint->ClosedLink.Flink = NULL;
        endpoint->ClosedLink.Blink = NULL;

        KeReleaseSpinLock(&devExt->Fdo.EpClosedListSpin.sl, irql);

        // if we are unable to close now we must bail so the
        // worker function can run
        closed = USBPORT_LazyCloseEndpoint(FdoDeviceObject, endpoint);

        KeAcquireSpinLock(&devExt->Fdo.EpClosedListSpin.sl, &irql);

    }

    KeReleaseSpinLock(&devExt->Fdo.EpClosedListSpin.sl, irql);


}


BOOLEAN
USBPORT_LazyCloseEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Close an Endpoint. Put the endpoint on our list
    of endpoints-to-close and wakeup the worker thread.

Arguments:

Return Value:

    returns true if closed

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN closed;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject,
                LOG_XFERS, 'frEP', Endpoint, 0, 0);

    // endpoint is no longer on the global list, now we just need
    // to make sure no one has a reference to it before we delete
    // it.
    // The endpoint may have been invalidated ie on the Attention
    // List before being removed from the global list to avoid this
    // potential conlict we check here until both the busy flag is
    // -1 (meaning coreworker is thru) AND AttendLink is NULL
    // if it is busy we put it back on the closed list

    if (IS_ON_ATTEND_LIST(Endpoint) ||
        Endpoint->Busy != -1) {
        // still have work to do, put the endpoint back on
        // the close list
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'CLOr', 0, Endpoint, 0);

        // it is OK to be on the attention list and the closed
        // list

        USBPORT_ASSERT(Endpoint->ClosedLink.Flink == NULL);
        USBPORT_ASSERT(Endpoint->ClosedLink.Blink == NULL);

        ExInterlockedInsertTailList(&devExt->Fdo.EpClosedList,
                                    &Endpoint->ClosedLink,
                                    &devExt->Fdo.EpClosedListSpin.sl);

        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);
        closed = FALSE;

    } else {

        // remove from global list
        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
        RemoveEntryList(&Endpoint->GlobalLink);
        Endpoint->GlobalLink.Flink = NULL;
        Endpoint->GlobalLink.Blink = NULL;
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

        // free endpoint memory
        if (Endpoint->CommonBuffer) {
            USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                        Endpoint->CommonBuffer);
        }

        USBPORT_LogFree(FdoDeviceObject, &Endpoint->Log);
#ifdef ISO_LOG
        USBPORT_LogFree(FdoDeviceObject, &Endpoint->IsoLog);
#endif
        UNSIG(Endpoint);
        FREE_POOL(FdoDeviceObject, Endpoint);
        closed = TRUE;
    }

    return closed;
}


VOID
USBPORT_FreeUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT DeviceAddress
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PDEVICE_EXTENSION devExt;
    USHORT address = 0, i, j;
    ULONG bit;

    PAGED_CODE();

    // we should never see a free to device address 0

    USBPORT_ASSERT(DeviceAddress != 0);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {
            address = (USHORT)(j*32+i);
            if (address == DeviceAddress) {
                devExt->Fdo.AddressList[j] &= ~bit;
                goto USBPORT_FreeUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

USBPORT_FreeUsbAddress_Done:

    USBPORT_KdPrint((3, "'USBPORT free Address %d\n", address));

}


USHORT
USBPORT_AllocateUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PDEVICE_EXTENSION devExt;
    USHORT address, i, j;
    ULONG bit;

    PAGED_CODE();
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    address = 0;

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {

            if (!(devExt->Fdo.AddressList[j] & bit)) {
                devExt->Fdo.AddressList[j] |= bit;
                address = (USHORT)(j*32+i);
                goto USBPORT_AllocateUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

    // no free addresses?
    USBPORT_ASSERT(0);

 USBPORT_AllocateUsbAddress_Done:

    USBPORT_KdPrint((3, "'USBPORT assigning Address %d\n", address));

    return address;
}


NTSTATUS
USBPORT_InitializeHsHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    This service initializes a high speed hub

Arguments:

    HubDeviceHandle - DeviceHandle for the creating USB Hub

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    ULONG i;

    LOGENTRY(NULL, FdoDeviceObject,
        LOG_MISC, 'ihsb', 0, HubDeviceHandle, TtCount);

    // hub driver might pass us NULL if it could not
    // retrieve a device handle
    if (HubDeviceHandle == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT_DEVICE_HANDLE(HubDeviceHandle)
    USBPORT_ASSERT(HubDeviceHandle->DeviceSpeed == HighSpeed);

    if (IS_ROOT_HUB(HubDeviceHandle)) {
        // no TTs for the root hub yet
        return STATUS_SUCCESS;
    }

    USBPORT_ASSERT(HubDeviceHandle->DeviceDescriptor.bDeviceClass ==
                        USB_DEVICE_CLASS_HUB);
    USBPORT_ASSERT(TEST_FLAG(HubDeviceHandle->DeviceFlags,
                        USBPORT_DEVICEFLAG_HSHUB));

    for (i=0; i< TtCount; i++) {
        ntStatus = USBPORT_InitializeTT(FdoDeviceObject,
                                        HubDeviceHandle,
                                        (USHORT)i+1);

        if(!NT_SUCCESS(ntStatus)) {
            break;
        }
    }

    HubDeviceHandle->TtCount = TtCount;

    return ntStatus;
}


NTSTATUS
USBPORT_CreateDevice(
    PUSBD_DEVICE_HANDLE *DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each new device on the USB bus, this function sets
    up the internal data structures we need to keep track of the
    device and assigns it an address.

Arguments:

    DeviceHandle - ptr to return the ptr to the new device structure
                created by this routine

    DeviceObject - USBPORT device object for the USB bus this device is on.

    HubDeviceHandle - DeviceHandle for the creating USB Hub

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    PDEVICE_EXTENSION devExt;
    ULONG bytesReturned = 0;
    PUCHAR data = NULL;
    BOOLEAN open = FALSE;
    ULONG dataSize;
    PTRANSACTION_TRANSLATOR tt = NULL;
    USHORT ttPort;

    PAGED_CODE();
    USBPORT_KdPrint((2, "'CreateDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    //
    // first validate the deviceHandle for the creating hub, we need
    // this information for USB 1.1 devices behind a USB 2.0 hub.
    //

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'crD>', HubDeviceHandle,
        PortNumber, PortStatus);

    // NOTE: this actually locks all device handles
    LOCK_DEVICE(HubDeviceHandle, FdoDeviceObject);

    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      HubDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub driver
        DEBUG_BREAK();

        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);
        // fail the create if the hubs device handle is bugus
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    // start at the port for this device,
    // if this is a 1.1 device in a 1.1 hub
    // downstream of a 2.0 hub then we need
    // the port number from the 1.1 hub
    ttPort = PortNumber;
    // port status tells us the type of device we are dealing with
    if (USBPORT_IS_USB20(devExt) &&
        !TEST_FLAG(PortStatus, PORT_STATUS_HIGH_SPEED)) {
        // walk upstream until we reach a USB 2.0 hub
        // this hub will conatin the appropriate TT
        tt = USBPORT_GetTt(FdoDeviceObject,
                           HubDeviceHandle,
                           &ttPort);
    }

    UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    ALLOC_POOL_Z(deviceHandle, NonPagedPool,
                 sizeof(USBD_DEVICE_HANDLE));

    *DeviceHandle = NULL;
    if (deviceHandle == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        LOGENTRY(NULL,
          FdoDeviceObject, LOG_MISC, 'CRED', 0, 0, deviceHandle);

        deviceHandle->PendingUrbs = 0;
        deviceHandle->HubDeviceHandle = HubDeviceHandle;
        deviceHandle->ConfigurationHandle = NULL;
        deviceHandle->DeviceAddress = USB_DEFAULT_DEVICE_ADDRESS;
        //deviceHandle->DeviceBandwidth = 0;

        if (PortStatus & PORT_STATUS_LOW_SPEED) {
            deviceHandle->DeviceSpeed = LowSpeed;
        } else if (PortStatus & PORT_STATUS_HIGH_SPEED) {
            deviceHandle->DeviceSpeed = HighSpeed;
        } else {
            deviceHandle->DeviceSpeed = FullSpeed;
        }

        deviceHandle->Sig = SIG_DEVICE_HANDLE;

        // port number is maps to a specific tt but hub fw
        // has to make sense of this.
        deviceHandle->TtPortNumber = ttPort;
        deviceHandle->Tt = tt;

        LOCK_DEVICE(deviceHandle, FdoDeviceObject);

        // buffer for our descriptor, one packet
        data = (PUCHAR) &deviceHandle->DeviceDescriptor;
        dataSize = sizeof(deviceHandle->DeviceDescriptor);

        // **
        // We need to talk to the device, first we open the default pipe
        // using the defined max packet size (defined by USB spec as 8
        // bytes until device receives the GET_DESCRIPTOR (device) command).
        // We set the address get the device descriptor then close the pipe
        // and re-open it with the correct max packet size.
        // **
#define USB_DEFAULT_LS_MAX_PACKET   8
        //
        // open the default pipe for the device
        //
        defaultPipe = &deviceHandle->DefaultPipe;
        if (deviceHandle->DeviceSpeed == LowSpeed) {
            INITIALIZE_DEFAULT_PIPE(*defaultPipe, USB_DEFAULT_LS_MAX_PACKET);
        } else {
            INITIALIZE_DEFAULT_PIPE(*defaultPipe, USB_DEFAULT_MAX_PACKET);
        }
        InitializeListHead(&deviceHandle->PipeHandleList);
        InitializeListHead(&deviceHandle->TtList);

        ntStatus = USBPORT_OpenEndpoint(deviceHandle,
                                        FdoDeviceObject,
                                        defaultPipe,
                                        NULL,
                                        TRUE);
        open = NT_SUCCESS(ntStatus);

        bytesReturned = 0;

        if (NT_SUCCESS(ntStatus)) {

            //
            // Configure the default pipe for this device and assign the
            // device an address
            //
            // NOTE: if this operation fails it means that we have a device
            // that will respond to the default endpoint and we can't change
            // it.
            // we have no choice but to disable the port on the hub this
            // device is attached to.
            //


            //
            // Get information about the device
            //
            USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
            PUCHAR tmpDevDescBuf;

            // Would you believe that there exist some devices that get confused
            // if the very first Get Device Descriptor request does not have a
            // wLength value of 0x40 even though the device only has a 0x12 byte
            // Device Descriptor to return?  Any change to the way devices have
            // always been enumerated since the being of USB 1.0 time can cause
            // bizarre consequences.  Use a wLength value of 0x40 for the very
            // first Get Device Descriptor request.

            ALLOC_POOL_Z(tmpDevDescBuf, NonPagedPool,
                         USB_DEFAULT_MAX_PACKET);

            if (tmpDevDescBuf == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                // setup packet for get device descriptor

                USBPORT_INIT_SETUP_PACKET(setupPacket,
                                          USB_REQUEST_GET_DESCRIPTOR, // bRequest
                                          BMREQUEST_DEVICE_TO_HOST, // Dir
                                          BMREQUEST_TO_DEVICE, // Recipient
                                          BMREQUEST_STANDARD, // Type
                                          USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(USB_DEVICE_DESCRIPTOR_TYPE, 0), //  wValue
                                          0, // wIndex
                                          USB_DEFAULT_MAX_PACKET); // wLength

                ntStatus = USBPORT_SendCommand(deviceHandle,
                                               FdoDeviceObject,
                                               &setupPacket,
                                               tmpDevDescBuf,
                                               USB_DEFAULT_MAX_PACKET,
                                               &bytesReturned,
                                               NULL);

                // NOTE:
                // at this point we only have the first 8 bytes of the
                // device descriptor.

                RtlCopyMemory(data, tmpDevDescBuf, dataSize);

                FREE_POOL(FdoDeviceObject, tmpDevDescBuf);
            }
        }

        // some devices babble so we ignore the error
        // on this transaction if we got enough data
        if (bytesReturned == 8 && !NT_SUCCESS(ntStatus)) {
            USBPORT_KdPrint((1,
                "'Error returned from get device descriptor -- ignored\n"));
            ntStatus = STATUS_SUCCESS;
        }

        // validate the max packet value and descriptor
        // we need at least eight bytes a value of zero
        // in max packet is bogus

        if (NT_SUCCESS(ntStatus) &&
            (bytesReturned >= 8) &&
            (deviceHandle->DeviceDescriptor.bLength >= sizeof(USB_DEVICE_DESCRIPTOR)) &&
            (deviceHandle->DeviceDescriptor.bDescriptorType == USB_DEVICE_DESCRIPTOR_TYPE) &&
            ((deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x08) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x10) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x20) ||
             (deviceHandle->DeviceDescriptor.bMaxPacketSize0 == 0x40))) {

            USBPORT_AddDeviceHandle(FdoDeviceObject, deviceHandle);

            *DeviceHandle = deviceHandle;

        } else {

            PUCHAR p = (PUCHAR)&deviceHandle->DeviceDescriptor;

            // print a big debug message
            USBPORT_KdPrint((0, "'CREATEDEVICE failed enumeration %08X %02X\n",
                             ntStatus, bytesReturned));

            USBPORT_KdPrint((0, "'%02X %02X %02X %02X %02X %02X %02X %02X"
                                " %02X %02X %02X %02X %02X %02X %02X %02X"
                                " %02X %02X\n",
                             p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],
                             p[8],p[9],p[10],p[11],p[12],p[13],p[14],p[15],
                             p[16],p[17]));

            USBPORT_DebugClient((
                "Bad Device Detected\n"));
            DEBUG_BREAK();
            //
            // something went wrong, if we assigned any resources to
            // the default pipe then we free them before we get out.
            //

            // we need to signal to the parent hub that this
            // port is to be be disabled we will do this by
            // returning an error.
            ntStatus = STATUS_DEVICE_DATA_ERROR;

            // if we opened a pipe close it
            if (open) {

                USBPORT_ClosePipe(deviceHandle,
                                  FdoDeviceObject,
                                  defaultPipe);
            }

        }
        UNLOCK_DEVICE(deviceHandle, FdoDeviceObject);

        if (!NT_SUCCESS(ntStatus)) {
            UNSIG(deviceHandle);
            FREE_POOL(FdoDeviceObject, deviceHandle);
        }
    }

USBPORT_CreateDevice_Done:

    CATC_TRAP_ERROR(FdoDeviceObject, ntStatus);

    LOGENTRY(NULL,
        FdoDeviceObject, LOG_MISC, 'creD', 0, 0, ntStatus);
    USBPORT_ENUMLOG(FdoDeviceObject, 'cdev', ntStatus, 0);

    return ntStatus;
}


NTSTATUS
USBPORT_RemoveDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be removed.
    This routine frees the device handle and the address assigned
    to the device.

    Some new tricks here:

    When this function is called it is asumed the client driver has
    received the REMOVE irp and passed it on to the bus driver. We
    remove the device handle from our list, this will cause any new
    transfers submitted by the driver to be failed.  Any current
    transfers the driver has will be completed with error.

    Once all transfer are flushed for all the endpoints we will close
    the endpoints and free the device handle (ie) noone has any references
    to it anymore.

    This should -- in theory -- prevent bad drivers from crashing in usbport
    or the miniport if they send requests after a remove.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

    Flags -
        USBD_KEEP_DEVICE_DATA
        USBD_MARK_DEVICE_BUSY   - we don't use this one



Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    USBD_STATUS usbdStatus;

    if (Flags & USBD_KEEP_DEVICE_DATA) {
        // keep data means keep the handle valid
        return STATUS_SUCCESS;
    }

    if (Flags & USBD_MARK_DEVICE_BUSY) {
        // This means stop accepting requests.  Only used by USBHUB when
        // handling a IOCTL_INTERNAL_USB_RESET_PORT request??  Need to do
        // anything special here??  Need to keep the handle valid since it
        // will be used to restore the device after the reset.
        //
        // GlenS note to JD: review this.
        //
        return STATUS_SUCCESS;
    }

    GET_DEVICE_EXT(devExt, FdoDeviceObject);

    // assume success
    ntStatus = STATUS_SUCCESS;

    LOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      DeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub
        // driver
        DEBUG_BREAK();

        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    LOGENTRY(NULL,
        FdoDeviceObject, LOG_PNP, 'REMV', DeviceHandle, 0, 0);

    // handle is no longer on our lists so all attempts
    // to submit urbs by the client driver will now fail

    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               DeviceHandle);

    SET_FLAG(DeviceHandle->DeviceFlags,
             USBPORT_DEVICEFLAG_REMOVED);


    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              DeviceHandle);

    // wait for any refs from non-transfer URBs to drain
    while (InterlockedDecrement(&DeviceHandle->PendingUrbs) >= 0) {
        LOGENTRY(NULL,
          FdoDeviceObject, LOG_PNP, 'dPUR', DeviceHandle, 0,
            DeviceHandle->PendingUrbs);

        InterlockedIncrement(&DeviceHandle->PendingUrbs);
        USBPORT_Wait(FdoDeviceObject, 100);
    }

    //
    // make sure and clean up any open pipe handles
    // the device may have
    //

    if (DeviceHandle->ConfigurationHandle) {

        USBPORT_InternalCloseConfiguration(DeviceHandle,
                                           FdoDeviceObject,
                                           0);

    }

    defaultPipe = &DeviceHandle->DefaultPipe;

    // we should aways have a default pipe, this will free
    // the endpoint
    USBPORT_ClosePipe(DeviceHandle,
                      FdoDeviceObject,
                      defaultPipe);

    if (DeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
        USBPORT_FreeUsbAddress(FdoDeviceObject, DeviceHandle->DeviceAddress);
    }

    //
    // free any Tt handles associated with this device handle
    //
    while (!IsListEmpty(&DeviceHandle->TtList)) {

        PTRANSACTION_TRANSLATOR tt;
        PLIST_ENTRY listEntry;
        KIRQL irql;


        listEntry = RemoveHeadList(&DeviceHandle->TtList);
        tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR,
                        TtLink);
        ASSERT_TT(tt);

        KeAcquireSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, &irql);
        SET_FLAG(tt->TtFlags, USBPORT_TTFLAG_REMOVED);

        if (IsListEmpty(&tt->EndpointList)) {
            ULONG i, bandwidth;

            USBPORT_UpdateAllocatedBwTt(tt);
            // alloc new
            bandwidth = tt->MaxAllocedBw;
            for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
                devExt->Fdo.BandwidthTable[i] += bandwidth;
            }

            FREE_POOL(FdoDeviceObject, tt);
        }

        KeReleaseSpinLock(&devExt->Fdo.TtEndpointListSpin.sl, irql);
    }
    UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    if (!IS_ROOT_HUB(DeviceHandle)) {
        ASSERT_DEVICE_HANDLE(DeviceHandle);
        FREE_POOL(FdoDeviceObject, DeviceHandle);
    }

    return ntStatus;
}


NTSTATUS
USBPORT_InitializeDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be initialized.
    This routine allocates an address and assigns it to the device.

    NOTE: on entry the the device descriptor in DeviceHandle is expected to
        contain at least the first 8 bytes of the device descriptor, this
        information is used to open the default pipe.

    On Error the DeviceHandle structure is freed.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                from a call to USBPORT_CreateDevice.

    DeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    USHORT address;
    PDEVICE_EXTENSION devExt;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    PAGED_CODE();

    USBPORT_KdPrint((2, "'InitializeDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    USBPORT_ASSERT(DeviceHandle != NULL);

    LOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    defaultPipe = &DeviceHandle->DefaultPipe;

    // assume success
    ntStatus = STATUS_SUCCESS;

    //
    // Assign Address to the device
    //

    address = USBPORT_AllocateUsbAddress(FdoDeviceObject);

    USBPORT_KdPrint((2, "'SetAddress, assigning 0x%x address\n", address));
    LOGENTRY(NULL,
        FdoDeviceObject, LOG_MISC, 'ADRa', DeviceHandle, 0, address);

    USBPORT_ASSERT(DeviceHandle->DeviceAddress == USB_DEFAULT_DEVICE_ADDRESS);

    // setup packet for set_address
    USBPORT_INIT_SETUP_PACKET(setupPacket,
            USB_REQUEST_SET_ADDRESS, // bRequest
            BMREQUEST_HOST_TO_DEVICE, // Dir
            BMREQUEST_TO_DEVICE, // Recipient
            BMREQUEST_STANDARD, // Type
            address, // wValue
            0, // wIndex
            0); // wLength


    ntStatus = USBPORT_SendCommand(DeviceHandle,
                                   FdoDeviceObject,
                                   &setupPacket,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);

    DeviceHandle->DeviceAddress = address;

    if (NT_SUCCESS(ntStatus)) {

        USB_MINIPORT_STATUS mpStatus;

        //
        // done with addressing process...
        //
        // poke the endpoint zero to the new address and
        // the true max packet size for the default control.
        // endpoint.
        //
        defaultPipe->Endpoint->Parameters.MaxPacketSize =
            DeviceHandle->DeviceDescriptor.bMaxPacketSize0;
        defaultPipe->Endpoint->Parameters.DeviceAddress = address;

        //MP_PokeEndpoint(devExt, defaultPipe->Endpoint, mpStatus);
        //ntStatus = MPSTATUS_TO_NTSTATUS(mpStatus);
        ntStatus = USBPORT_PokeEndpoint(FdoDeviceObject, defaultPipe->Endpoint);
    }

    if (NT_SUCCESS(ntStatus)) {

        ULONG bytesReturned;
        USB_DEFAULT_PIPE_SETUP_PACKET setupPacket2;

        // 10ms delay to allow devices to respond after
        // the setaddress command
        USBPORT_Wait(FdoDeviceObject, 10);

        //
        // Fetch the device descriptor again, this time
        // get the whole thing.
        //

        // setup packet for get device descriptor
        USBPORT_INIT_SETUP_PACKET(setupPacket2,
            USB_REQUEST_GET_DESCRIPTOR, // bRequest
            BMREQUEST_DEVICE_TO_HOST, // Dir
            BMREQUEST_TO_DEVICE, // Recipient
            BMREQUEST_STANDARD, // Type
            USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(USB_DEVICE_DESCRIPTOR_TYPE, 0), // wValue
            0, // wIndex
            sizeof(DeviceHandle->DeviceDescriptor)); // wLength

        ntStatus =
            USBPORT_SendCommand(DeviceHandle,
                            FdoDeviceObject,
                            &setupPacket2,
                            (PUCHAR) &DeviceHandle->DeviceDescriptor,
                            sizeof(DeviceHandle->DeviceDescriptor),
                            &bytesReturned,
                            NULL);

        if (NT_SUCCESS(ntStatus) &&
            (bytesReturned != sizeof(USB_DEVICE_DESCRIPTOR)) ||
            (DeviceHandle->DeviceDescriptor.bLength < sizeof(USB_DEVICE_DESCRIPTOR)) ||
            (DeviceHandle->DeviceDescriptor.bDescriptorType != USB_DEVICE_DESCRIPTOR_TYPE) ||
            ((DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x08) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x10) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x20) &&
             (DeviceHandle->DeviceDescriptor.bMaxPacketSize0 != 0x40))) {
            // print a big debug message
            USBPORT_KdPrint((0, "'InitializeDevice failed enumeration\n"));

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }
    }


    if (NT_SUCCESS(ntStatus)) {

        if (DeviceHandle->DeviceSpeed == HighSpeed &&
            DeviceHandle->DeviceDescriptor.bDeviceClass ==
                        USB_DEVICE_CLASS_HUB) {
            // note that this is a hs hub, these require special
            // handling because of the TTs
            SET_FLAG(DeviceHandle->DeviceFlags, USBPORT_DEVICEFLAG_HSHUB);
        }

        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

    } else {

        //
        // something went wrong, if we assigned any resources to
        // the default pipe then we free them before we get out.
        //

        // we need to signal to the parent hub that this
        // port is to be be disabled we will do this by
        // returning an error.

        // if we got here then we know the default
        // endpoint is open

        DEBUG_BREAK();

        USBPORT_ClosePipe(DeviceHandle,
                          FdoDeviceObject,
                          defaultPipe);

        if (DeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
            USBPORT_FreeUsbAddress(FdoDeviceObject, DeviceHandle->DeviceAddress);
        }

        UNLOCK_DEVICE(DeviceHandle, FdoDeviceObject);

        // this device handle is no longer valid
        USBPORT_RemoveDeviceHandle(FdoDeviceObject, DeviceHandle);

        FREE_POOL(FdoDeviceObject, DeviceHandle);
    }

    LOGENTRY(NULL,
        FdoDeviceObject, LOG_MISC, 'iniD', DeviceHandle, 0, ntStatus);
    CATC_TRAP_ERROR(FdoDeviceObject, ntStatus);

    USBPORT_ENUMLOG(FdoDeviceObject, 'idev', ntStatus, 0);

    return ntStatus;
}


NTSTATUS
USBPORT_GetUsbDescriptor(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    UCHAR DescriptorType,
    PUCHAR DescriptorBuffer,
    PULONG DescriptorBufferLength
    )
/*++

Routine Description:

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                from a call to USBPORT_CreateDevice.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    PDEVICE_EXTENSION devExt;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    USBPORT_INIT_SETUP_PACKET(setupPacket,
        USB_REQUEST_GET_DESCRIPTOR, // bRequest
        BMREQUEST_DEVICE_TO_HOST, // Dir
        BMREQUEST_TO_DEVICE, // Recipient
        BMREQUEST_STANDARD, // Type
        USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(DescriptorType, 0), // wValue
        0, // wIndex
        *DescriptorBufferLength); // wLength


    ntStatus =
        USBPORT_SendCommand(DeviceHandle,
                        FdoDeviceObject,
                        &setupPacket,
                        DescriptorBuffer,
                        *DescriptorBufferLength,
                        DescriptorBufferLength,
                        NULL);


    return ntStatus;
}


BOOLEAN
USBPORT_DeviceHasQueuedTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    Returns TRUE device has queued transfers

Arguments:

Return Value:

    True if device has transfers queued transfers

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN hasTransfers = FALSE;
    PLIST_ENTRY listEntry;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;

    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;

        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I,
                    ListEntry);

        ASSERT_PIPE_HANDLE(nextHandle);

        listEntry = nextHandle->ListEntry.Flink;

        if (!TEST_FLAG(nextHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW) &&
            USBPORT_EndpointHasQueuedTransfers(FdoDeviceObject,
                                               nextHandle->Endpoint)) {
            hasTransfers = TRUE;
            break;
        }
    }

    return hasTransfers;
}


VOID
USBPORT_AbortAllTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

    abort all pending transfers associated with a device handle.

    This function is synchronous -- it is called after the device
    handle is removed from our tables so no new transfers can be
    posted.

    The idea here is to complete any transfers that may still be
    pending when the device is removed in case the client driver
    neglected to.

    On entry to this function the device is locked.

Arguments:

    DeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    PLIST_ENTRY listEntry;

    ASSERT_DEVICE_HANDLE(DeviceHandle);

    listEntry = &DeviceHandle->PipeHandleList;

    if (!IsListEmpty(listEntry)) {
        listEntry = DeviceHandle->PipeHandleList.Flink;
    }

    while (listEntry != &DeviceHandle->PipeHandleList) {

        PUSBD_PIPE_HANDLE_I nextHandle;

        nextHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I,
                    ListEntry);

        ASSERT_PIPE_HANDLE(nextHandle);

        listEntry = nextHandle->ListEntry.Flink;

        if (!TEST_FLAG(nextHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
            SET_FLAG(nextHandle->Endpoint->Flags, EPFLAG_DEVICE_GONE);
            USBPORT_AbortEndpoint(FdoDeviceObject,
                                  nextHandle->Endpoint,
                                  NULL);
            USBPORT_FlushMapTransferList(FdoDeviceObject);
        }
    }

    // This gaurantees that no transfers are in our lists or
    // in the miniport when we remove the device.

    // NOTE: If a driver passed a remove with transfers still pending
    // we still may crash but this should happen in the offending
    // driver.

    // NOTE 2: The whistler hub driver will remove the device early
    // (on connect change) so this code will be hit legit-ly in
    // this case.

    // now wait for queues to empty

    while (USBPORT_DeviceHasQueuedTransfers(FdoDeviceObject, DeviceHandle)) {
        // wait, then check again
        USBPORT_Wait(FdoDeviceObject, 100);
    }

}


NTSTATUS
USBPORT_CloneDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE OldDeviceHandle,
    PUSBD_DEVICE_HANDLE NewDeviceHandle
    )
/*++

Routine Description:

    Service exported for use by the hub driver




Arguments:

    NewDeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    OldDeviceHandle - ptr to device data structure created by class driver
                in USBPORT_CreateDevice.

    FdoDeviceObject - USBPORT device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    USBD_STATUS usbdStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);

    // assume success
    ntStatus = STATUS_SUCCESS;

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Cln>',
        OldDeviceHandle, NewDeviceHandle, 0);

    USBPORT_KdPrint((1,"'Cloning Device\n"));
    DEBUG_BREAK();
    LOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);

    // make sure we have two valid device handles

    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      OldDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub
        // driver
        DEBUG_BREAK();

        UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      NewDeviceHandle,
                                      FALSE)) {
        // this is most likely a bug in the hub
        // driver
        DEBUG_BREAK();

        UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);
        // chances are that the device handle is bad becuse the
        // device is gone.
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Cln+',
        OldDeviceHandle, NewDeviceHandle, 0);


    // There are two cases where this API is called:

    // case 1 - the device driver has requested a reset of the device.
    // In this event the device has returned to the unconfigured state
    // and has been re-addressed with the 'NewDeviceHandle'
    //
    // case 2 - the controller has been shut off -- thanks to power
    // management.  In this case the device is also in the unconfigured
    // state and associated with the 'NewDeviceHandle' device handle

    // make sure the 'new device' is unconfigured
    USBPORT_ASSERT(NewDeviceHandle->ConfigurationHandle == NULL);

#ifdef XPSE
    // before performing the clone operation remove the device handle
    // and wait for any pending URBs to drain
    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               OldDeviceHandle);

    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              OldDeviceHandle);

      // wait for any refs from non-transfer URBs to drain
    while (InterlockedDecrement(&OldDeviceHandle->PendingUrbs) >= 0) {
        LOGENTRY(NULL,
          FdoDeviceObject, LOG_PNP, 'dPR2', OldDeviceHandle, 0,
            OldDeviceHandle->PendingUrbs);

        InterlockedIncrement(&OldDeviceHandle->PendingUrbs);
        USBPORT_Wait(FdoDeviceObject, 100);
    }
#endif

    // make sure we are dealing with the same device
    if (RtlCompareMemory(&NewDeviceHandle->DeviceDescriptor,
                         &OldDeviceHandle->DeviceDescriptor,
                         sizeof(OldDeviceHandle->DeviceDescriptor)) !=
                         sizeof(OldDeviceHandle->DeviceDescriptor)) {

        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBPORT_CloneDevice_FreeOldDevice;
    }

    // clone the config
    NewDeviceHandle->ConfigurationHandle =
        OldDeviceHandle->ConfigurationHandle;

    if (OldDeviceHandle->ConfigurationHandle != NULL) {

        // set the device to the previous configuration,
        // Send the 'set configuration' command.

        USBPORT_INIT_SETUP_PACKET(setupPacket,
                USB_REQUEST_SET_CONFIGURATION, // bRequest
                BMREQUEST_HOST_TO_DEVICE, // Dir
                BMREQUEST_TO_DEVICE, // Recipient
                BMREQUEST_STANDARD, // Type
                NewDeviceHandle->ConfigurationHandle->\
                    ConfigurationDescriptor->bConfigurationValue, // wValue
                0, // wIndex
                0); // wLength


        USBPORT_SendCommand(NewDeviceHandle,
                            FdoDeviceObject,
                            &setupPacket,
                            NULL,
                            0,
                            NULL,
                            &usbdStatus);

        USBPORT_KdPrint((2,"' SendCommand, SetConfiguration returned 0x%x\n", usbdStatus));

        if (USBD_ERROR(usbdStatus)) {

            USBPORT_KdPrint((1, "failed to 'set' the configuration on a clone\n"));

            //
            // the set_config failed, this can happen if the device has been
            // removed or if the device has lost its brains.
            // We continue with the cloning process for the endpoints so they
            // will be properly freed when the 'new' device handle is
            // eventually removed.
            //

            ntStatus = SET_USBD_ERROR(NULL, usbdStatus);

        }
    }

    // clone any alternate interface settings, since we restore the pipes to
    // the state at the time of hibernate they may be associated with
    // particular alternate interfaces

    // walk the interface chain
    if (OldDeviceHandle->ConfigurationHandle != NULL &&
        NT_SUCCESS(ntStatus)) {

        PUSBD_CONFIG_HANDLE cfgHandle;
        PLIST_ENTRY listEntry;
        PUSBD_INTERFACE_HANDLE_I iHandle;

        cfgHandle = NewDeviceHandle->ConfigurationHandle;
        GET_HEAD_LIST(cfgHandle->InterfaceHandleList, listEntry);

        while (listEntry &&
               listEntry != &cfgHandle->InterfaceHandleList) {

            // extract the handle from this entry
            iHandle = (PUSBD_INTERFACE_HANDLE_I) CONTAINING_RECORD(
                        listEntry,
                        struct _USBD_INTERFACE_HANDLE_I,
                        InterfaceLink);

            ASSERT_INTERFACE(iHandle);

            // see if we currently have an alt setting selected
            if (iHandle->HasAlternateSettings) {

                NTSTATUS status;
                //
                // If we have alternate settings we need
                // to send the set interface command.
                //

                USBPORT_INIT_SETUP_PACKET(setupPacket,
                    USB_REQUEST_SET_INTERFACE, // bRequest
                    BMREQUEST_HOST_TO_DEVICE, // Dir
                    BMREQUEST_TO_INTERFACE, // Recipient
                    BMREQUEST_STANDARD, // Type
                    iHandle->InterfaceDescriptor.bAlternateSetting, // wValue
                    iHandle->InterfaceDescriptor.bInterfaceNumber, // wIndex
                    0); // wLength

                status = USBPORT_SendCommand(NewDeviceHandle,
                                             FdoDeviceObject,
                                             &setupPacket,
                                             NULL,
                                             0,
                                             NULL,
                                             &usbdStatus);

                LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'sIF2',
                    0,
                    iHandle->InterfaceDescriptor.bAlternateSetting,
                    iHandle->InterfaceDescriptor.bInterfaceNumber);

            }

            listEntry = iHandle->InterfaceLink.Flink;
        }
    }

    // clone the TT and TT related data
    if (TEST_FLAG(NewDeviceHandle->DeviceFlags, USBPORT_DEVICEFLAG_HSHUB)) {

        // remove the TT entries from the old handle and add them
        // to the new handle

        while (!IsListEmpty(&OldDeviceHandle->TtList)) {
            PTRANSACTION_TRANSLATOR tt;
            PLIST_ENTRY listEntry;

            listEntry = RemoveTailList(&OldDeviceHandle->TtList);
            USBPORT_ASSERT(listEntry != NULL);

            tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR,
                        TtLink);
            ASSERT_TT(tt);

            tt->DeviceAddress = NewDeviceHandle->DeviceAddress;
            InsertHeadList(&NewDeviceHandle->TtList, &tt->TtLink);
        }

        NewDeviceHandle->TtCount = OldDeviceHandle->TtCount;
    }

    // copy the pipe handle list, for each pipe we  will need to re-open
    // the endpoint or re-init the endpoint.
    //
    // if the device did not loose its brains then all we need to do
    // is update the host controllers idea of what the endpoint address is.
    // this has the added advantage of allowing a reset even when transfers
    // are queued to the HW although we don't allow that.

    while (!IsListEmpty(&OldDeviceHandle->PipeHandleList)) {

        PHCD_ENDPOINT endpoint;
        PLIST_ENTRY listEntry = OldDeviceHandle->PipeHandleList.Flink;
        PUSBD_PIPE_HANDLE_I pipeHandle;
        PTRANSACTION_TRANSLATOR transactionTranslator = NULL;

        // see if we are dealing with a TT
        if (NewDeviceHandle->Tt != NULL) {
            transactionTranslator = NewDeviceHandle->Tt;
            ASSERT_TT(transactionTranslator);
        }

        pipeHandle = (PUSBD_PIPE_HANDLE_I) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_PIPE_HANDLE_I,
                    ListEntry);

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'CLNE', pipeHandle, 0, 0);
        ASSERT_PIPE_HANDLE(pipeHandle);

        USBPORT_RemovePipeHandle(OldDeviceHandle,
                                 pipeHandle);

        // we need to special case the default pipe because it
        // is embedded in the DeviceHandle.
        //
        // Since NewDeviceHandle is a newly created device
        // the endpoint associated with it is valid, so is
        // the one for the 'OldDeviceHandle'

        if (pipeHandle != &OldDeviceHandle->DefaultPipe) {

            USB_MINIPORT_STATUS mpStatus;

            USBPORT_AddPipeHandle(NewDeviceHandle, pipeHandle);

            // skip re-init for sero bw endpoints becuase we have
            // no endpoint structure -- these are ghost endpoints
            if (!TEST_FLAG(pipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {

                endpoint = pipeHandle->Endpoint;
                ASSERT_ENDPOINT(endpoint);

                endpoint->DeviceHandle = NewDeviceHandle;

                endpoint->Parameters.DeviceAddress =
                        NewDeviceHandle->DeviceAddress;

                if (TEST_FLAG(endpoint->Flags, EPFLAG_NUKED)) {
                    // re-open
                    ENDPOINT_REQUIREMENTS requirements;

                    if (transactionTranslator != NULL) {
                        endpoint->Parameters.TtDeviceAddress =
                            transactionTranslator->DeviceAddress;
                    }

                    // call open request to minport, all the endpoint
                    // structures are still valid we just need to re-add
                    // it to the schedule.

                    RtlZeroMemory(&endpoint->MiniportEndpointData[0],
                                  REGISTRATION_PACKET(devExt).EndpointDataSize);
                    RtlZeroMemory(endpoint->Parameters.CommonBufferVa,
                                  endpoint->Parameters.CommonBufferBytes);

                    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'clRO', pipeHandle,
                        endpoint, 0);

                    // query requirements (although they should not change)
                    // just in case the miniport does some initialization here
                    MP_QueryEndpointRequirements(devExt,
                        endpoint, &requirements);

                    MP_OpenEndpoint(devExt, endpoint, mpStatus);
                    // in this UNIQUE situation this API is not allowed
                    // (and should not) fail
                    USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

                    CLEAR_FLAG(endpoint->Flags, EPFLAG_NUKED);
                    // gone flag is set when we abort transfers
                    CLEAR_FLAG(endpoint->Flags, EPFLAG_DEVICE_GONE);

                    // we need to sync the endpoint state with
                    // the miniport, when first opened the miniport
                    // puts the endpoint in status HALT.

                    ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeK0');
                    // initialize endpoint state machine
                    //if (endpoint->CurrentStatus == ENDPOINT_STATUS_RUN) {
                    //    MP_SetEndpointStatus(devExt, endpoint, ENDPOINT_STATUS_RUN);
                    //}

                    if (endpoint->CurrentState == ENDPOINT_ACTIVE) {
                        MP_SetEndpointState(devExt, endpoint, ENDPOINT_ACTIVE);
                    }
                    RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeK0');


                } else {

                    // if this device has an associated TT then
                    // we will need to do a little more here
                    if (transactionTranslator != NULL) {
                        endpoint->Parameters.TtDeviceAddress =
                            transactionTranslator->DeviceAddress;
                    }

                    // this endpoint is already in the schedule,
                    // poke-it with the new address.

                    MP_PokeEndpoint(devExt, endpoint, mpStatus);

                    // in this UNIQUE situation this API is not allowed
                    // (and should not) fail
                    USBPORT_ASSERT(mpStatus == USBMP_STATUS_SUCCESS);

                    // The endpoint on the device should have had its data
                    // toggle reset back to Data0 so reset the data toggle
                    // on the host endpoint to match.
                    //
                    MP_SetEndpointDataToggle(devExt, endpoint, 0);

                    // clear halt status
                    MP_SetEndpointStatus(devExt, endpoint, ENDPOINT_STATUS_RUN);

                }
            }
        }
    }

    // the pipes and config have been cloned, the final step is to free the
    // 'OldDeviceData' ie the old handle.

    // put the old 'default' pipe back on the list before
    // we close it
    USBPORT_AddPipeHandle(OldDeviceHandle,
                          &OldDeviceHandle->DefaultPipe);

USBPORT_CloneDevice_FreeOldDevice:

#ifndef XPSE
    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               OldDeviceHandle);

    USBPORT_AbortAllTransfers(FdoDeviceObject,
                              OldDeviceHandle);
#endif
    // we should aways have a default pipe, this will free
    // the endpoint
    USBPORT_ClosePipe(OldDeviceHandle,
                      FdoDeviceObject,
                      &OldDeviceHandle->DefaultPipe);

    if (OldDeviceHandle->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
        USBPORT_FreeUsbAddress(FdoDeviceObject, OldDeviceHandle->DeviceAddress);
    }

    UNLOCK_DEVICE(NewDeviceHandle, FdoDeviceObject);

    FREE_POOL(FdoDeviceObject, OldDeviceHandle);

    return ntStatus;
}


PTRANSACTION_TRANSLATOR
USBPORT_GetTt(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    PUSHORT PortNumber
    )
/*++

Routine Description:

    Walk upstream until we find the first high speed device

Arguments:

Return Value:

    ttDeviceAddress

--*/
{
    PDEVICE_EXTENSION devExt;
    PTRANSACTION_TRANSLATOR tt = NULL;
    PLIST_ENTRY listEntry;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    do {
        if (HubDeviceHandle->DeviceSpeed == UsbHighSpeed) {

            if (HubDeviceHandle->TtCount > 1) {

                GET_HEAD_LIST(HubDeviceHandle->TtList, listEntry);

                while (listEntry != NULL &&
                       listEntry != &HubDeviceHandle->TtList) {

                    tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                            listEntry,
                            struct _TRANSACTION_TRANSLATOR,
                            TtLink);
                    ASSERT_TT(tt);

                    if (tt->Port == *PortNumber) {
                        break;
                    }

                    listEntry = tt->TtLink.Flink;
                    tt = NULL;
                }

            } else {
                // single TT, use the one tt structure regardless of port
                GET_HEAD_LIST(HubDeviceHandle->TtList, listEntry);
                tt = (PTRANSACTION_TRANSLATOR) CONTAINING_RECORD(
                        listEntry,
                        struct _TRANSACTION_TRANSLATOR,
                        TtLink);
                ASSERT_TT(tt);
            }

            // we should have selected a tt
            USBPORT_ASSERT(tt != NULL);
            break;
        } else {
            *PortNumber = HubDeviceHandle->TtPortNumber;
        }
        HubDeviceHandle = HubDeviceHandle->HubDeviceHandle;
        ASSERT_DEVICE_HANDLE(HubDeviceHandle);
    } while (HubDeviceHandle != NULL);

    USBPORT_KdPrint((1, "TtPortNumber %d\n",
        *PortNumber));

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gTTa', HubDeviceHandle,
        *PortNumber, tt);

    return tt;
}


NTSTATUS
USBPORT_InitializeTT(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT Port
    )
/*++

Routine Description:

    Initialze the TT table used to track this hub

Arguments:

Return Value:

    nt status code

--*/
{
    PDEVICE_EXTENSION devExt;
    PTRANSACTION_TRANSLATOR transactionTranslator;
    USHORT siz;
    extern ULONG USB2LIB_TtContextSize;
    NTSTATUS ntStatus;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(USBPORT_IS_USB20(devExt));

    siz = sizeof(TRANSACTION_TRANSLATOR) +
          USB2LIB_TtContextSize;

    ALLOC_POOL_Z(transactionTranslator, NonPagedPool, siz);

    if (transactionTranslator != NULL) {
        ULONG i;
        ULONG bandwidth;

        transactionTranslator->Sig = SIG_TT;
        transactionTranslator->DeviceAddress =
            HubDeviceHandle->DeviceAddress;
        transactionTranslator->Port = Port;
        transactionTranslator->PdoDeviceObject =
            devExt->Fdo.RootHubPdo;
        // each translator is a virtual 1.1 bus
        transactionTranslator->TotalBusBandwidth =
            USB_11_BUS_BANDWIDTH;
        InitializeListHead(&transactionTranslator->EndpointList);

        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            transactionTranslator->BandwidthTable[i] =
                transactionTranslator->TotalBusBandwidth -
                transactionTranslator->TotalBusBandwidth/10;
        }

        // reserve the basic 10% from the parent bus
        USBPORT_UpdateAllocatedBwTt(transactionTranslator);
        // alloc new
        bandwidth = transactionTranslator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] -= bandwidth;
        }

        USB2LIB_InitTt(devExt->Fdo.Usb2LibHcContext,
                       &transactionTranslator->Usb2LibTtContext);

        InsertTailList(&HubDeviceHandle->TtList,
                       &transactionTranslator->TtLink);

        ntStatus = STATUS_SUCCESS;
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\ioctl.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Port driver for USB host controllers

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"
#ifdef DRM_SUPPORT
#include <ksdrmhlp.h>
#endif

#include "usbpriv.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_FdoDeviceControlIrp)
#pragma alloc_text(PAGE, USBPORT_PdoDeviceControlIrp)
#pragma alloc_text(PAGE, USBPORT_LegacyGetUnicodeName)
#pragma alloc_text(PAGE, USBPORT_GetSymbolicName)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, USBPORT_PdoSetContentId)
#endif
#endif

// non paged functions
// USBPORT_FdoInternalDeviceControlIrp
// USBPORT_PdoInternalDeviceControlIrp
// USBPORT_UserSendOnePacket

BOOLEAN
USBPORT_CheckLength(
    PUSBUSER_REQUEST_HEADER Header,
    ULONG ParameterLength
    )
/*++

Routine Description:

    Checks Length of user supplied buffer based on api

Arguments:

Return Value:

    FALSE if buffer too small

--*/
{
    ULONG length;
    BOOLEAN retCode = TRUE;

    length = sizeof(*Header) + ParameterLength;

    Header->ActualBufferLength = length;

    if (length > Header->RequestBufferLength) {
        //TEST_TRAP();
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
        retCode = FALSE;
    }

    return retCode;
}


NTSTATUS
USBPORT_FdoDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for DEVICE_CONTROL Irps sent to the FDO for the HC.

    NOTE: These are user mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;
    ULONG information = 0;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_USB_DIAGNOSTIC_MODE_ON:
        USBPORT_KdPrint((2, "'IOCTL_USB_DIAGNOSTIC_MODE_ON\n"));
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE); 
        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_USB_DIAGNOSTIC_MODE_OFF:
        USBPORT_KdPrint((2, "'IOCTL_USB_DIAGNOSTIC_MODE_OFF\n"));
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE); 
        ntStatus = STATUS_SUCCESS;;
        break;

    case IOCTL_GET_HCD_DRIVERKEY_NAME:

        USBPORT_KdPrint((2, "'IOCTL_GET_HCD_DRIVERKEY_NAME\n"));
        ntStatus = USBPORT_LegacyGetUnicodeName(FdoDeviceObject,
                                                Irp,
                                                &information);
        break;

    case IOCTL_USB_GET_ROOT_HUB_NAME:

        USBPORT_KdPrint((2, "'IOCTL_USB_GET_ROOT_HUB_NAME\n"));
        ntStatus = USBPORT_LegacyGetUnicodeName(FdoDeviceObject,
                                                Irp,
                                                &information);
        break;

    case IOCTL_USB_USER_REQUEST:

        USBPORT_KdPrint((2, "'IOCTL_USB_USER_REQUEST\n"));
        ntStatus = USBPORT_UsbFdoUserIoctl(FdoDeviceObject,
                                           Irp,
                                           &information);
        break;

// old IOCTLS no longer supported
//    case IOCTL_USB_HCD_GET_STATS_2:
//    case IOCTL_USB_HCD_GET_STATS_1:

    default:
        // bugbug pass on to PDO or complete with error?

        USBPORT_KdPrint((2, "'INVALID DEVICE CONTROL\n"));
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)

    USBPORT_CompleteIrp(FdoDeviceObject, Irp, ntStatus, information);
    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


#ifdef DRM_SUPPORT

NTSTATUS
USBPORT_PdoSetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG ContentId;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION fdoDevExt;
    PUSBPORT_REGISTRATION_PACKET registrationPacket;
    PVOID *pHandlers;
    ULONG numHandlers;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    devExt = ioStackLocation->DeviceObject->DeviceExtension;
    fdoDeviceObject = devExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(fdoDevExt, fdoDeviceObject);
    registrationPacket = &REGISTRATION_PACKET(fdoDevExt);
    pHandlers = (PVOID *)&registrationPacket->MINIPORT_OpenEndpoint;
    numHandlers = (ULONG)((((ULONG_PTR)&registrationPacket->MINIPORT_PassThru -
                    (ULONG_PTR)&registrationPacket->MINIPORT_OpenEndpoint) /
                   sizeof(PVOID)) + 1);

    ContentId = pvData->ContentId;
    // Context = pKsProperty->Context;

    // Since there is a private interface between USBPORT.SYS and the miniports,
    // we give DRM a list of function pointers in the miniport for validation,
    // in place of a device object, since the miniport does not handle IRP
    // requests.

    // If at some future time a miniport is ever written that acts as a bridge
    // to another bus or device stack, this may have to be modified such that
    // DRM is notified of that driver that the data is forwarded to.

    ntStatus = pKsProperty->DrmAddContentHandlers(ContentId, pHandlers, numHandlers);

    return ntStatus;
}

#endif


NTSTATUS
USBPORT_PdoDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for DEVICE_CONTROL Irps sent to the PDO for the Root Hub.

    NOTE: These are user mode requests

Arguments:

    DeviceObject - Pdo for USB Root Hub

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION rhDevExt;
    ULONG information = 0;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

#ifdef DRM_SUPPORT

    case IOCTL_KS_PROPERTY:
        USBPORT_KdPrint((2, "'IOCTL_KS_PROPERTY\n"));
        ntStatus = KsPropertyHandleDrmSetContentId(Irp, USBPORT_PdoSetContentId);
        break;

#endif

    default:
        USBPORT_KdPrint((2, "'INVALID DEVICE CONTROL\n"));
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)

    USBPORT_CompleteIrp(PdoDeviceObject, Irp, ntStatus, information);
    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


NTSTATUS
USBPORT_FdoInternalDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for INTERNAL_DEVICE_CONTROL Irps sent to
    the FDO for the HC.

    NOTE: These are kernel mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;

    USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    // bugbug pass on to PDO or complete with error?

    USBPORT_KdPrint((2, "'INVALID INTERNAL DEVICE CONTROL\n"));
    DEBUG_BREAK();
    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USBPORT_CompleteIrp(FdoDeviceObject, Irp, ntStatus, 0);

    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //

    return ntStatus;
}


NTSTATUS
USBPORT_PdoInternalDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for INTERNAL_DEVICE_CONTROL Irps sent to
    the PDO for the Root Hub.

    NOTE: These are kernel mode requests

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION rhDevExt;

    USBPORT_KdPrint((2, "'INTERNAL_DEVICE_CONTROL\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_INTERNAL_USB_SUBMIT_URB:

        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_SUBMIT_URB\n"));

        {
        PURB urb;
        //
        // all URBs are eventually passed to the root hub PDO
        // this is where we service cleint requests
        //

        // extract the urb;
        urb = irpStack->Parameters.Others.Argument1;

        // call the main urb control function
        ntStatus = USBPORT_ProcessURB(PdoDeviceObject,
                                      rhDevExt->HcFdoDeviceObject,
                                      Irp,
                                      urb);
        }                                      
        goto USBPORT_PdoInternalDeviceControlIrp_Done;
        break;
           
    case IOCTL_INTERNAL_USB_GET_HUB_COUNT:

        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_GET_HUB_COUNT\n"));
        
        {
        PULONG count;

        //
        // bump the count and complete the Irp
        //
        count = irpStack->Parameters.Others.Argument1;

        ASSERT(count != NULL);
        (*count)++;
        ntStatus = STATUS_SUCCESS;
        }
        break;

    case IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE:

        {
        PUSBD_DEVICE_HANDLE *deviceHandle;
        
        deviceHandle = irpStack->Parameters.Others.Argument1;
        *deviceHandle = &rhDevExt->Pdo.RootHubDeviceHandle;

        ntStatus = STATUS_SUCCESS;
        }
        
        break;        

    case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:
    
        ntStatus = 
            USBPORT_IdleNotificationRequest(PdoDeviceObject, Irp);

        goto USBPORT_PdoInternalDeviceControlIrp_Done;            
        break;
            
    case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
    
        USBPORT_KdPrint((2, "'IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO\n"));

        // this api is called by the hub driver to get the 
        // PDO for he root hub.  
        // Since the hub may be loaded on a PDO enumerated by 
        // another hub it uses this api to get the 'fastest path'
        // to the HCD for URB requests by client drivers.
        {
        PDEVICE_OBJECT *rootHubPdo, *hcdTopOfStackDeviceObject;
        
        rootHubPdo = irpStack->Parameters.Others.Argument1;
        hcdTopOfStackDeviceObject =
            irpStack->Parameters.Others.Argument2;

        USBPORT_ASSERT(hcdTopOfStackDeviceObject != NULL);
        USBPORT_ASSERT(rootHubPdo != NULL);

        *rootHubPdo = PdoDeviceObject;
        // the original USBD was somewhat screwy in the layout 
        // of the HCD device objects in the case of the port 
        // driver all requests should go to to the root hub PDO
        *hcdTopOfStackDeviceObject =
             PdoDeviceObject;

        ntStatus = STATUS_SUCCESS;
        }

        break;

#if 0
     case IOCTL_INTERNAL_USB_GET_HUB_NAME:
        TEST_TRAP();
        ntStatus = STATUS_NOT_SUPPORTED;
        break;
#endif
    default:

        USBPORT_KdPrint((2, "'INVALID INTERNAL DEVICE CONTROL %x\n",
            irpStack->Parameters.DeviceIoControl.IoControlCode)); 
        DEBUG_BREAK();
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    //
    // DO NOT TOUCH THE IRP FROM THIS POINT ON
    //
    USBPORT_CompleteIrp(PdoDeviceObject, Irp, ntStatus, 0);

USBPORT_PdoInternalDeviceControlIrp_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_UsbFdoUserIoctl(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    )
/*++

Routine Description:

    The goal here is to have all user mode APIS
    pass thru this routine so that the parameter
    validation is handled in one place.

    We define user APIS supported by the PORT FDO
    thru this single IOCTL.

    The USUSER APIs use the same buffer for input and output,
    hence the InputBufferLength and the OutputbufferLength must
    always be equal.


    We get here if the client sends the IOCTL_USB_USER_REQUEST.
    We only return NTSTATUS failure if the header portion of the
    buffer is invalid.



Arguments:

    DeviceObject - Fdo for USB HC

    BytesRetrned - ptr to bytes to return to caller, initially zero

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PUSBUSER_REQUEST_HEADER header;
    PDEVICE_EXTENSION devExt;
    PUCHAR ioBufferO;
    ULONG inputBufferLength, outputBufferLength, allocLength;
    ULONG ioBufferLength;
    PUCHAR myIoBuffer;
    BOOLEAN alloced;

    USBPORT_KdPrint((2, "'USBPORT_FdoUserIoctl\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    USBPORT_ASSERT(irpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_USB_USER_REQUEST);

    ioBufferO = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // one bug that the driver verifier does not catch is if we trash the
    // iobuffer passed to us.
    //
    // We shadow this buffer to one we allocate, this way DV should catch
    // us if we trash memory.
    // We do this in retail even though this a perf hit since the NT guys
    // tend to favor stability more than perf and this is not a hot-path.
    //
    // If DV is ever modified to do this for us we cann remove this code.
    //

    allocLength = max(inputBufferLength, outputBufferLength);

    if (allocLength) {
        ALLOC_POOL_Z(myIoBuffer, NonPagedPool, allocLength);
    } else {
        myIoBuffer = NULL;
    }

    if (myIoBuffer != NULL) {
        alloced = TRUE;
        RtlCopyMemory(myIoBuffer,
                      ioBufferO,
                      inputBufferLength);
    } else {
        // if alloc fails just fall back to the original
        alloced = FALSE;
        myIoBuffer = ioBufferO;
    }

    ioBufferLength = inputBufferLength;

    USBPORT_KdPrint((2,  "'ioBuffer = %x - %x\n", ioBufferO, myIoBuffer));
    USBPORT_KdPrint((2,  "'inputBufferLength %d\n", inputBufferLength));
    USBPORT_KdPrint((2,  "'outputBufferLength %d\n", outputBufferLength));
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'uIOC', ioBufferO, inputBufferLength,
            outputBufferLength);

    // some initial parameter validation

    // bogus buffer lengths
    if (inputBufferLength != outputBufferLength) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // must have at least enough for a header
    if (ioBufferLength < sizeof(USBUSER_REQUEST_HEADER)) {

        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // no _try _except needed here since we are using method buffered and
    // we already validate the length

    //__try {
    //    UCHAR ch;
    //     // check the buffer
    //        
    //   ch = *ioBufferO;
    //    ch = *(ioBufferO+sizeof(USBUSER_REQUEST_HEADER));
    //
    //} __except(EXCEPTION_EXECUTE_HANDLER) {

    //   USBPORT_KdPrint((0,"'EXCEPTION USBPORT_UsbFdoUserIoctl\n"));
    //   ntStatus = GetExceptionCode();
    //   TEST_TRAP();
    //   goto USBPORT_UsbFdoUserIoctl_Done;
    // }


    // header buffer is valid, at this point we return
    // STATUS_SUCCESS to the caller and fill in the header
    // with the appropriate error code
    ntStatus = STATUS_SUCCESS;

    // validate the header buffer parameters

    header = (PUSBUSER_REQUEST_HEADER) myIoBuffer;

    // assume success, set return values
    header->UsbUserStatusCode = UsbUserSuccess;
    *BytesReturned =
        header->ActualBufferLength = sizeof(*header);

    // length set in header should be the same
    // as length passed in the ioctl
    if (header->RequestBufferLength != ioBufferLength) {

        header->UsbUserStatusCode =
            UsbUserInvalidHeaderParameter;
        goto USBPORT_UsbFdoUserIoctl_Done;
    }

    // we have a valid header and cleint buffer, attempt to execute
    // the api

    // validate rules for Api codes
    // is this an API that only works when the root hub is disabled?
    {
    ULONG mask;
    mask = (USBUSER_OP_MASK_DEVONLY_API | USBUSER_OP_MASK_HCTEST_API);
    if ((header->UsbUserRequest & mask) && 
        devExt->Fdo.RootHubPdo != NULL) {
        // root hub only api and we have a root hub, make sure it 
        // is disabled
        PDEVICE_EXTENSION rhDevExt;

        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);

        if (!(TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_REMOVED) || 
              SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DIAG_MODE))) {
            header->UsbUserStatusCode = UsbUserFeatureDisabled;   
            ntStatus = STATUS_UNSUCCESSFUL;
            goto USBPORT_UsbFdoUserIoctl_Done;
        }
        
    }        
    }

    switch (header->UsbUserRequest) {
    case USBUSER_OP_SEND_ONE_PACKET:
        if (USBPORT_CheckLength(header, sizeof(PACKET_PARAMETERS))) {
            // DCA api
            USBPORT_UserSendOnePacket(FdoDeviceObject, header,
                        (PPACKET_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_RAW_RESET_PORT:
        if (USBPORT_CheckLength(header, sizeof(RAW_RESET_PORT_PARAMETERS))) {
            // DCA api
            USBPORT_UserRawResetPort(FdoDeviceObject, header,
                        (PRAW_RESET_PORT_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_SET_ROOTPORT_FEATURE:
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_FEATURE))) {
            // DCA api
            USBPORT_UserSetRootPortFeature(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_FEATURE) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_CLEAR_ROOTPORT_FEATURE:
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_FEATURE))) {
            // DCA api
            USBPORT_UserClearRootPortFeature(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_FEATURE) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_GET_ROOTPORT_STATUS:
        // DCA api
        if (USBPORT_CheckLength(header, sizeof(RAW_ROOTPORT_PARAMETERS))) {
            USBPORT_GetRootPortStatus(FdoDeviceObject, header,
                        (PRAW_ROOTPORT_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_OPEN_RAW_DEVICE:
        // DCA api
        if (USBPORT_CheckLength(header, sizeof(USB_OPEN_RAW_DEVICE_PARAMETERS))) {
            USBPORT_UserOpenRawDevice(FdoDeviceObject, header,
                        (PUSB_OPEN_RAW_DEVICE_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_CLOSE_RAW_DEVICE:
        // DCA api
        if (USBPORT_CheckLength(header, sizeof(USB_CLOSE_RAW_DEVICE_PARAMETERS))) {
            USBPORT_UserCloseRawDevice(FdoDeviceObject, header,
                        (PUSB_CLOSE_RAW_DEVICE_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }
        break;

    case USBUSER_OP_SEND_RAW_COMMAND:
        // DCA api
        if (USBPORT_CheckLength(header, sizeof(USB_SEND_RAW_COMMAND_PARAMETERS))) {
            USBPORT_UserSendRawCommand(FdoDeviceObject, header, 
                        (PUSB_SEND_RAW_COMMAND_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }                        
        break;         
        
    case USBUSER_GET_CONTROLLER_INFO_0:        
        if (USBPORT_CheckLength(header, sizeof(USB_CONTROLLER_INFO_0))) {
            USBPORT_UserGetControllerInfo_0(FdoDeviceObject, header, 
                        (PUSB_CONTROLLER_INFO_0) (myIoBuffer+sizeof(*header)));
        }                        
        break;  
        
    case USBUSER_GET_CONTROLLER_DRIVER_KEY:  
        if (USBPORT_CheckLength(header, sizeof(USB_UNICODE_NAME))) {
            USBPORT_UserGetControllerKey(FdoDeviceObject, header, 
                        (PUSB_UNICODE_NAME) (myIoBuffer+sizeof(*header)));
        }                        
        break;
        
    case USBUSER_GET_ROOTHUB_SYMBOLIC_NAME:  
        if (USBPORT_CheckLength(header, sizeof(USB_UNICODE_NAME))) {
            USBPORT_UserGetRootHubName(FdoDeviceObject, header, 
                        (PUSB_UNICODE_NAME) (myIoBuffer+sizeof(*header)));
        }                        
        break;        
        
    case USBUSER_PASS_THRU:  
        if (USBPORT_CheckLength(header, sizeof(USB_PASS_THRU_PARAMETERS))) {
            USBPORT_UserPassThru(FdoDeviceObject, header, 
                        (PUSB_PASS_THRU_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }  
        break;       
        
    case USBUSER_GET_BANDWIDTH_INFORMATION:  
        if (USBPORT_CheckLength(header, sizeof(USB_BANDWIDTH_INFO))) {
            USBPORT_UserGetBandwidthInformation(FdoDeviceObject, header, 
                        (PUSB_BANDWIDTH_INFO) (myIoBuffer+sizeof(*header)));
        }  
        break;               
        
    case USBUSER_GET_POWER_STATE_MAP:  
        if (USBPORT_CheckLength(header, sizeof(USB_POWER_INFO))) {
            USBPORT_UserPowerInformation(FdoDeviceObject, header, 
                        (PUSB_POWER_INFO) (myIoBuffer+sizeof(*header)));
        }  
        break; 

    case USBUSER_GET_BUS_STATISTICS_0:  
        if (USBPORT_CheckLength(header, sizeof(USB_BUS_STATISTICS_0))) {
            USBPORT_UserGetBusStatistics0(FdoDeviceObject, header, 
                        (PUSB_BUS_STATISTICS_0) (myIoBuffer+sizeof(*header)));
        }  
        break;
        
//    case USBUSER_GET_BUS_STATISTICS_0_AND_RESET:  
//        if (USBPORT_CheckLength(header, sizeof(USB_BUS_STATISTICS_0))) {
//            USBPORT_UserGetBusStatistics0(FdoDeviceObject, header, 
//                        (PUSB_BUS_STATISTICS_0) (myIoBuffer+sizeof(*header)),
//                        TRUE);
//        }  
//        break;        
        
    case USBUSER_GET_USB_DRIVER_VERSION:  
        if (USBPORT_CheckLength(header, sizeof(USB_DRIVER_VERSION_PARAMETERS))) {
            USBPORT_UserGetDriverVersion(FdoDeviceObject, header, 
                        (PUSB_DRIVER_VERSION_PARAMETERS) (myIoBuffer+sizeof(*header)));
        }          
        break;                 
        
    default:
        
        header->UsbUserStatusCode = UsbUserInvalidRequestCode;
    }

    // this will be at least the size of the header
    
    if (header->RequestBufferLength > header->ActualBufferLength) {
        // if the packet buffer is larger then just return 'actual length'
        *BytesReturned = 
            header->ActualBufferLength;
    } else {
        // packet buffer is smaller -- return the size of the 
        // packet buffer passed in 
        *BytesReturned = header->RequestBufferLength;
    }

USBPORT_UsbFdoUserIoctl_Done: 

    if (alloced) {
        // copy the data no matter what we put in it
        // USBPORT_ASSERT(outputBufferLength == inputBufferLength);
        RtlCopyMemory(ioBufferO,
                      myIoBuffer,
                      outputBufferLength);
        FREE_POOL(FdoDeviceObject, myIoBuffer);
    }
    
    return ntStatus;
}    

VOID
USBPORT_UserSendOnePacket(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PPACKET_PARAMETERS PacketParameters
    )
/*++

Routine Description:

    Execute a single step transaction
   
Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    HW_32BIT_PHYSICAL_ADDRESS phys;
    PUCHAR va, mpData;
    ULONG length, mpDataLength;
    MP_PACKET_PARAMETERS mpPacket;
    USBD_STATUS usbdStatus;
    USB_USER_ERROR_CODE usbUserStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserSendOnePacket\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // limit single packet to 64k 
    if (PacketParameters->DataLength > 0x10000) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tbts', 0, 0, 
            PacketParameters->DataLength);
        Header->UsbUserStatusCode = UsbUserInvalidParameter;    
        return;        
    }

    if (PacketParameters->Timeout >= 21474) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;   
        return;  
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
        return;
    }
    

    // extra length check is needed since we 
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(PACKET_PARAMETERS) - 4 + 
                PacketParameters->DataLength;

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0, 
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;    
        return;
    } 
                
    Header->ActualBufferLength = length;

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssPK', &mpPacket, 0, 
        PacketParameters);

    // dump the PacketParameters
    USBPORT_KdPrint((1, "'DeviceAddress %d\n", PacketParameters->DeviceAddress));
    USBPORT_KdPrint((1, "'EndpointAddress %d\n", PacketParameters->EndpointAddress));
    USBPORT_KdPrint((1, "'MaximumPacketSize %d\n", PacketParameters->MaximumPacketSize));
    USBPORT_KdPrint((1, "'Flags %08.8x\n", PacketParameters->Flags));
    USBPORT_KdPrint((1, "'ErrorCount %d\n", PacketParameters->ErrorCount));

    // build up request for miniport
    
    length = devExt->Fdo.ScratchCommonBuffer->MiniportLength;
    va = devExt->Fdo.ScratchCommonBuffer->MiniportVa;
    phys = devExt->Fdo.ScratchCommonBuffer->MiniportPhys;

    mpPacket.DeviceAddress = PacketParameters->DeviceAddress;
    mpPacket.EndpointAddress = PacketParameters->EndpointAddress;
    mpPacket.MaximumPacketSize = PacketParameters->MaximumPacketSize;
    if (PacketParameters->Flags & USB_PACKETFLAG_SETUP) {
        mpPacket.Type = ss_Setup;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ASYNC_IN) {
        USBPORT_KdPrint((1, "'Async In\n"));
        mpPacket.Type = ss_In; 
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ASYNC_OUT) {
        USBPORT_KdPrint((1, "'Async Out\n"));
        mpPacket.Type = ss_Out; 
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ISO_IN) {
        USBPORT_KdPrint((1, "'Iso In\n"));
        mpPacket.Type = ss_Iso_In;         
    } else if (PacketParameters->Flags & USB_PACKETFLAG_ISO_OUT) {
        USBPORT_KdPrint((1, "'Iso Out\n"));
        mpPacket.Type = ss_Iso_Out; 
    } else {
        usbUserStatus = UsbUserInvalidParameter;
    }       
    
    if (PacketParameters->Flags & USB_PACKETFLAG_LOW_SPEED) { 
        USBPORT_KdPrint((1, "'LowSpeed\n"));
        mpPacket.Speed = ss_Low;
        mpPacket.HubDeviceAddress = PacketParameters->HubDeviceAddress;
        mpPacket.PortTTNumber = PacketParameters->PortTTNumber;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_FULL_SPEED) { 
        USBPORT_KdPrint((1, "'FullSpeed\n"));
        mpPacket.Speed = ss_Full;
        mpPacket.HubDeviceAddress = PacketParameters->HubDeviceAddress;
        mpPacket.PortTTNumber = PacketParameters->PortTTNumber;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_HIGH_SPEED) {
        USBPORT_KdPrint((1, "'HighSpeed\n"));
        mpPacket.Speed = ss_High;
    } else {
         usbUserStatus = UsbUserInvalidParameter;
    }

    if (PacketParameters->Flags & USB_PACKETFLAG_TOGGLE0) {        
        USBPORT_KdPrint((1, "'Toggle0\n"));
        mpPacket.Toggle = ss_Toggle0;
    } else if (PacketParameters->Flags & USB_PACKETFLAG_TOGGLE1) {
        USBPORT_KdPrint((1, "'Toggle1\n"));
        mpPacket.Toggle = ss_Toggle1;
    } else {
        usbUserStatus = UsbUserInvalidParameter;
    }

    if (usbUserStatus == UsbUserSuccess) {
        mpData = &PacketParameters->Data[0];
        mpDataLength = PacketParameters->DataLength;
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssDT', mpData, mpDataLength, 0);

        
        MP_StartSendOnePacket(devExt,
                              &mpPacket,
                              mpData,
                              &mpDataLength,
                              va,
                              phys,
                              length,
                              &usbdStatus,
                              mpStatus);

        if (USBMP_STATUS_SUCCESS != mpStatus) {
            usbUserStatus = UsbUserMiniportError;
            goto USBPORT_UserSendOnePacket_Exit;
        }

        do {
            // wait 10 ms
            USBPORT_Wait(FdoDeviceObject, 10);
                
            // wait a user specified time
            if (PacketParameters->Timeout) {
                USBPORT_Wait(FdoDeviceObject, PacketParameters->Timeout);
            }   
                
            MP_EndSendOnePacket(devExt,
                                &mpPacket,
                                mpData,
                                &mpDataLength,
                                va,
                                phys,
                                length,
                                &usbdStatus,
                                mpStatus);

        } while (USBMP_STATUS_BUSY == mpStatus);

        // allow one frame to pass before continuing
        USBPORT_Wait(FdoDeviceObject, 1);

        PacketParameters->DataLength = mpDataLength;        
        PacketParameters->UsbdStatusCode = usbdStatus;

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ssDE', mpData, mpDataLength, 
            PacketParameters);
    }            

USBPORT_UserSendOnePacket_Exit:

    Header->UsbUserStatusCode = usbUserStatus;
    
}    




VOID
USBPORT_UserRawResetPort(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_RESET_PORT_PARAMETERS Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port
   
Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    RH_PORT_STATUS portStatus;
    ULONG loopCount;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort, %x\n", devExt));

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrsp', 0, 0, Parameters->PortNumber);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode =
            usbUserStatus = UsbUserInvalidParameter;
        return;
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Setting port power\n"));

    // power the port
    devExt->Fdo.MiniportDriver->
        RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);

    //
    // Wait the required time for the port power to stabilize.
    //
    //  512ms --> Max port power to power good time for root hub
    //  100ms --> Max time for device to have power stabilize
    //
    // After this time, the device must have signalled connect on the device
    //

    USBPORT_Wait( FdoDeviceObject, 612 );

    MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
            &portStatus, mpStatus);

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Port status = %x\n",
                    portStatus ));
    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs1', 0, 0,
             (ULONG_PTR) portStatus.ul);

    //
    // Device should have signalled connect, if not, it's an error.
    //

    if ( portStatus.Connected )
    {
        //
        // Provide another 100ms for debounce interval.
        //

        USBPORT_Wait( FdoDeviceObject, 100 );

        //
        // Reset the device
        //

        USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Setting port reset\n"));

        // attempt a reset
        mpStatus = devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);

        //
        // wait for reset change, this process is drive by the
        // HC root hub hardware or miniport
        //

        loopCount = 0;

        USBPORT_Wait( FdoDeviceObject, 20 );

        MPRH_GetPortStatus(devExt,
                    (USHORT)(Parameters->PortNumber), &portStatus, mpStatus);

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs2', 0, 0,
             (ULONG_PTR) portStatus.ul);

        //
        // Some hubs seem to be taking longer than 20 ms to signal reset change
        // This is a loop to give it up to another 20ms.
        //

        while ( !portStatus.ResetChange && loopCount < 20 )
        {
            loopCount++;

            USBPORT_Wait( FdoDeviceObject, 1 );

            MPRH_GetPortStatus(devExt,
                    (USHORT)(Parameters->PortNumber), &portStatus, mpStatus);
        }

        USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: loopCount = %d\n",
                         loopCount));

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs3', 0, loopCount,
             (ULONG_PTR) portStatus.ul);

        if ( portStatus.ResetChange )
        {
            USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Clearing reset "
                                 "change\n"));

            // clear the change bit
            mpStatus = devExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange(
                                                    devExt->Fdo.MiniportDeviceData,
                                                    Parameters->PortNumber);

            MPRH_GetPortStatus( devExt,
                                (USHORT) (Parameters->PortNumber),
                                &portStatus,
                                mpStatus );

            LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs4', 0, 0,
             (ULONG_PTR) portStatus.ul);

            USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort: Port status = %x\n",
                            portStatus ));

            //
            // Wait an additional 10 seconds for device reset recovery
            //

            USBPORT_Wait( FdoDeviceObject, 10 );
        }
        else
        {
            USBPORT_KdPrint((2,
                        "'USBPORT_UserRawResetPort: reset change not set\n"
                        "'PortStatus = 0x%x\n", portStatus.ul));

            TEST_TRAP();
        }

    } else {
        usbUserStatus = UsbUserNoDeviceConnected;
    }

    // status is low 16 bits
    Parameters->PortStatus = (USHORT) portStatus.ul;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Rrs>', 0, portStatus.ul,
                                                        usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}


VOID
USBPORT_GetRootPortStatus(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_PARAMETERS Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USBPRIV_ROOTPORT_STATUS portStatusInfo;

    USBPORT_KdPrint((2, "'USBPORT_GetRootPortStatus\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gRPs', 0, 0, Parameters->PortNumber);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode = 
            usbUserStatus = UsbUserInvalidParameter;
        return;            
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    portStatusInfo.PortNumber = (USHORT) Parameters->PortNumber;
    portStatusInfo.PortStatus.ul = 0;

    MP_PassThru(devExt,
                (LPGUID) &GUID_USBPRIV_ROOTPORT_STATUS,
                sizeof(portStatusInfo),
                &portStatusInfo, // Info,
                mpStatus);

    if (USBMP_STATUS_NOT_SUPPORTED == mpStatus) {
        MPRH_GetPortStatus(devExt, portStatusInfo.PortNumber,
                            &(portStatusInfo.PortStatus), mpStatus);
    }

    // status is low 16 bits
    Parameters->PortStatus = (USHORT) portStatusInfo.PortStatus.ul;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gRP>', 0, 0, usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}

VOID
USBPORT_UserGetControllerInfo_0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CONTROLLER_INFO_0 ControllerInfo_0
    )
/*++

Routine Description:

    Execute a single step transaction
   
Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    ROOTHUB_DATA hubData;
    RH_HUB_CHARATERISTICS rhChars;
    
    USBPORT_KdPrint((2, "'USBPORT_UserGetControllerInfo_0\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ControllerInfo_0->HcFeatureFlags = 0;

    MPRH_GetRootHubData(devExt, &hubData);    

    ControllerInfo_0->NumberOfRootPorts =         
             hubData.NumberOfPorts;
        
    rhChars.us = hubData.HubCharacteristics.us;
        
    if (rhChars.PowerSwitchType == USBPORT_RH_POWER_SWITCH_PORT) {
            ControllerInfo_0->HcFeatureFlags |= 
                USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING;    
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND)) {
        ControllerInfo_0->HcFeatureFlags |= 
            USB_HC_FEATURE_FLAG_SEL_SUSPEND;    
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_BIOS)) {
        ControllerInfo_0->HcFeatureFlags |= 
            USB_HC_FEATURE_LEGACY_BIOS;    
    }
    
    ControllerInfo_0->PciVendorId = 
        devExt->Fdo.PciVendorId;
        
    ControllerInfo_0->PciDeviceId = 
        devExt->Fdo.PciDeviceId;
        
    ControllerInfo_0->PciRevision = 
        (UCHAR) devExt->Fdo.PciRevisionId;
    
    ControllerInfo_0->ControllerFlavor = 
        devExt->Fdo.HcFlavor;        

    Header->UsbUserStatusCode = 
        UsbUserSuccess;
}


VOID
USBPORT_UserGetControllerKey(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME ControllerKey
    )
/*++

Routine Description:

    Returns the Driver key associated with this symbolic link for the
    host controller.

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength;
    
    USBPORT_KdPrint((2, "'USBPORT_UserGetControllerKey\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unl;ess this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_UNICODE_NAME)+sizeof(*Header));

    // userlength
    userLength = Header->RequestBufferLength - sizeof(*Header) 
        - sizeof(USB_UNICODE_NAME);

    // note: this will cause us to return a NULL terminated 
    // key
    RtlZeroMemory(ControllerKey, userLength);
    
    ntStatus = IoGetDeviceProperty(
        devExt->Fdo.PhysicalDeviceObject,
        DevicePropertyDriverKeyName,
        userLength, 
        &ControllerKey->String[0],
        &actualLength);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'dKEY', &ControllerKey->String[0], userLength, 
            actualLength);                

    if (NT_SUCCESS(ntStatus)) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        ControllerKey->Length = actualLength + sizeof(UNICODE_NULL);
    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
    } else {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
    }

    Header->ActualBufferLength = 
        actualLength+sizeof(*Header)+sizeof(USB_UNICODE_NAME);

}


VOID
USBPORT_UserGetRootHubName(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME RootHubName
    )
/*++

Routine Description:

    Returns the Driver key associated with this symbolic link for the
    host controller.

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength;
    UNICODE_STRING hubNameUnicodeString;
    
    USBPORT_KdPrint((2, "'USBPORT_UserGetRootHubName\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unl;ess this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_UNICODE_NAME)+sizeof(*Header));

    // userlength
    userLength = Header->RequestBufferLength - sizeof(*Header) 
        - sizeof(USB_UNICODE_NAME);

    // note: this will cause us to return a NULL terminated 
    // key
    RtlZeroMemory(RootHubName, userLength);

    ntStatus = USBPORT_GetSymbolicName(FdoDeviceObject,
                                       devExt->Fdo.RootHubPdo,
                                       &hubNameUnicodeString);
    actualLength = 0;
    
    if (NT_SUCCESS(ntStatus)) {
        ULONG n;
        
        actualLength = hubNameUnicodeString.Length;
        n = hubNameUnicodeString.Length;
        if (n > userLength) {
            n = userLength;
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        if (n) {
            RtlCopyMemory(&RootHubName->String[0],
                          hubNameUnicodeString.Buffer,  
                          n);
        }                          
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Huns', 
            &hubNameUnicodeString, 0, 0);
                    
        RtlFreeUnicodeString(&hubNameUnicodeString);                      
    } 

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gHNM', ntStatus, userLength, 
            actualLength);                

    if (NT_SUCCESS(ntStatus)) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        RootHubName->Length = actualLength + sizeof(UNICODE_NULL);
    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;
    } else {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;
    }

    Header->ActualBufferLength = 
        actualLength+sizeof(*Header)+sizeof(USB_UNICODE_NAME);

}


VOID
USBPORT_UserPassThru(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_PASS_THRU_PARAMETERS PassThru
    )
/*++

Routine Description:

   Handles pass-thru apis for the Miniport

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    ULONG userLength, actualLength, length;
    USB_MINIPORT_STATUS mpStatus;
    ULONG parameterLength;
    
    USBPORT_KdPrint((2, "'USBPORT_UserPassThru\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we should not get here unless this hold true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_PASS_THRU_PARAMETERS)+sizeof(*Header));

    // limit pass thru blocks to 64k
    if (PassThru->ParameterLength > 0x10000) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;    
        return;
    }

    // extra length check is needed since we 
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(USB_PASS_THRU_PARAMETERS) - 4 + 
                PassThru->ParameterLength;

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0, 
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;    
        return;
    } 

    // userlength
    parameterLength = PassThru->ParameterLength; 

    Header->ActualBufferLength = 
        sizeof(*Header)+sizeof(USB_PASS_THRU_PARAMETERS) + 
            parameterLength;

    // call the miniport
    MP_PassThru(devExt, 
                &PassThru->FunctionGUID, 
                parameterLength,
                &PassThru->Parameters,
                mpStatus);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        Header->UsbUserStatusCode = UsbUserSuccess;
        USBPORT_KdPrint((1, "'USBPORT_UserPassThru Success\n"));
    } else {
        Header->UsbUserStatusCode = UsbUserMiniportError;        
        USBPORT_KdPrint((1, "'USBPORT_UserPassThru Error\n"));            
    }                

}


WDMUSB_POWER_STATE
WdmUsbSystemPowerState(
    SYSTEM_POWER_STATE SystemPowerState
    )
/*++

Routine Description:

Arguments:

Return Value: 

    WDMUSB_POWER_STATE that matches the WDM power state passed in
--*/
{
    switch(SystemPowerState) {
    case PowerSystemWorking:
        return WdmUsbPowerSystemWorking;
    case PowerSystemSleeping1:
        return WdmUsbPowerSystemSleeping1;
    case PowerSystemSleeping2:
        return WdmUsbPowerSystemSleeping2; 
    case PowerSystemSleeping3:
        return WdmUsbPowerSystemSleeping3;
    case PowerSystemHibernate:
        return WdmUsbPowerSystemHibernate;
    case PowerSystemShutdown:
        return WdmUsbPowerSystemShutdown;
    }

    return WdmUsbPowerNotMapped;    
}


WDMUSB_POWER_STATE
WdmUsbDevicePowerState(
    DEVICE_POWER_STATE DevicePowerState
    )
/*++

Routine Description:

Arguments:

Return Value: 

    WDMUSB_POWER_STATE that matches the WDM power state passed in
--*/
{
    switch(DevicePowerState) {
    case PowerDeviceUnspecified:
        return WdmUsbPowerDeviceUnspecified;
    case PowerDeviceD0:
        return WdmUsbPowerDeviceD0;
    case PowerDeviceD1:
        return WdmUsbPowerDeviceD1;
    case PowerDeviceD2:
        return WdmUsbPowerDeviceD2;
    case PowerDeviceD3:
        return WdmUsbPowerDeviceD3;
    }

    return WdmUsbPowerNotMapped;
}


VOID
USBPORT_MapPowerStateInformation(
    PDEVICE_OBJECT FdoDeviceObject,    
    PUSB_POWER_INFO PowerInformation,
    PDEVICE_CAPABILITIES HcCaps,
    PDEVICE_CAPABILITIES RhCaps
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.
--*/
{
    PHC_POWER_STATE hcPowerState = NULL;
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    PowerInformation->RhDeviceWake =
        WdmUsbDevicePowerState(RhCaps->DeviceWake);
    PowerInformation->RhSystemWake =
        WdmUsbSystemPowerState(RhCaps->SystemWake);
    PowerInformation->HcDeviceWake =
        WdmUsbDevicePowerState(HcCaps->DeviceWake);
    PowerInformation->HcSystemWake =
        WdmUsbSystemPowerState(HcCaps->SystemWake);
        
    switch (PowerInformation->SystemState) {
    case WdmUsbPowerSystemWorking:
        PowerInformation->RhDevicePowerState = 
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemWorking]);    
        PowerInformation->HcDevicePowerState = 
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemWorking]);             
//        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject, 
//            PowerSystemWorking);
        break;
        
    case WdmUsbPowerSystemSleeping1:
        PowerInformation->RhDevicePowerState = 
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping1]);    
        PowerInformation->HcDevicePowerState = 
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping1]);             
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl, 
                                               PowerSystemSleeping1);
        break;
        
    case WdmUsbPowerSystemSleeping2:
        PowerInformation->RhDevicePowerState = 
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping2]);    
        PowerInformation->HcDevicePowerState = 
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping2]);             
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject, 
                                               &devExt->Fdo.HcPowerStateTbl, 
                                               PowerSystemSleeping2);
        break;
        
    case WdmUsbPowerSystemSleeping3:
        PowerInformation->RhDevicePowerState = 
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemSleeping3]);    
        PowerInformation->HcDevicePowerState = 
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemSleeping3]);             
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject, 
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemSleeping3);
        break;
        
     case WdmUsbPowerSystemHibernate:
        PowerInformation->RhDevicePowerState = 
            WdmUsbDevicePowerState(RhCaps->DeviceState[PowerSystemHibernate]);    
        PowerInformation->HcDevicePowerState = 
            WdmUsbDevicePowerState(HcCaps->DeviceState[PowerSystemHibernate]);             
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject, 
                                               &devExt->Fdo.HcPowerStateTbl,
                                               PowerSystemHibernate);
        break;
    }   
    

    if (hcPowerState != NULL) {
        switch(hcPowerState->Attributes) {
        case HcPower_Y_Wakeup_Y:
            PowerInformation->CanWakeup = 1;
            PowerInformation->IsPowered = 1;                
            break;
        case HcPower_N_Wakeup_N:
            PowerInformation->CanWakeup = 0;
            PowerInformation->IsPowered = 0;  
            break;
        case HcPower_Y_Wakeup_N:
            PowerInformation->CanWakeup = 0;
            PowerInformation->IsPowered = 1;  
            break;
        case HcPower_N_Wakeup_Y:
            PowerInformation->CanWakeup = 1;
            PowerInformation->IsPowered = 0;  
            break;
        }
    } else {
        PowerInformation->CanWakeup = 0;
        PowerInformation->IsPowered = 0;  
    }

    PowerInformation->LastSystemSleepState =
        WdmUsbSystemPowerState(devExt->Fdo.LastSystemSleepState);
}


VOID
USBPORT_UserPowerInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_POWER_INFO PowerInformation
    )
/*++

Routine Description:

   Handles power info API

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    PDEVICE_CAPABILITIES hcDeviceCaps, rhDeviceCaps;
     
    USBPORT_KdPrint((2, "'USBPORT_UserPowerInformation\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    // BUGBUG this api should fail if we are not started
    if (!TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_STARTED)) {
  
        Header->ActualBufferLength = 
            sizeof(*Header)+sizeof(USB_POWER_INFO);
        Header->UsbUserStatusCode = UsbUserDeviceNotStarted;
        return;
    }        
    
    rhDeviceCaps = &rhDevExt->DeviceCapabilities;
    hcDeviceCaps = &devExt->DeviceCapabilities;
    
    // we should not get here unless this holds true
    USBPORT_ASSERT(Header->RequestBufferLength >=
                   sizeof(USB_POWER_INFO)+sizeof(*Header));

    USBPORT_MapPowerStateInformation(
        FdoDeviceObject,    
        PowerInformation,
        hcDeviceCaps,
        rhDeviceCaps);
        
    Header->ActualBufferLength = 
        sizeof(*Header)+sizeof(USB_POWER_INFO);

}


VOID
USBPORT_UserOpenRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_OPEN_RAW_DEVICE_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USHORT portStatus;

    USBPORT_KdPrint((2, "'USBPORT_OpenRawDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        usbUserStatus = UsbUserFeatureDisabled;
        goto USBPORT_UserOpenRawDevice_Done;
    }

    // fail request if open
    if (devExt->Fdo.RawDeviceHandle) {
        usbUserStatus = UsbUserInvalidParameter;
        goto USBPORT_UserOpenRawDevice_Done;
    }

    // fabricate port status
    portStatus = Parameters->PortStatus;  

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'oRAW', 0, 0, portStatus);

    // we assume that a device is connected here, we just create 
    // a raw handle to it, nothing more.
    //
    // everything else must be handled by the caller.

    ntStatus = USBPORT_CreateDevice(&devExt->Fdo.RawDeviceHandle,
                                    FdoDeviceObject,
                                    NULL,                               
                                    portStatus,
                                    0);

    if (NT_SUCCESS(ntStatus)) {
        // mark this device handle as 'special'
        SET_FLAG(devExt->Fdo.RawDeviceHandle->DeviceFlags, 
            USBPORT_DEVICEFLAG_RAWHANDLE);

        Parameters->MaxPacketEp0 = 
            devExt->Fdo.RawDeviceHandle->DeviceDescriptor.bMaxPacketSize0;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'oRAs', 0, 0, ntStatus);

    
    usbUserStatus = 
        USBPORT_NtStatus_TO_UsbUserStatus(ntStatus);

USBPORT_UserOpenRawDevice_Done:

    Header->UsbUserStatusCode = usbUserStatus;
}    


VOID
USBPORT_UserCloseRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CLOSE_RAW_DEVICE_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    NTSTATUS ntStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserCloseRawDevice\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        usbUserStatus = UsbUserFeatureDisabled;
        goto USBPORT_UserCloseRawDevice_Done;
    }
    
    // fail request if closed
    if (devExt->Fdo.RawDeviceHandle == NULL) {
        usbUserStatus = UsbUserInvalidParameter;
        goto USBPORT_UserCloseRawDevice_Done;
    }


    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'cRAW', 0, 0, 0);

    ntStatus = 
        USBPORT_RemoveDevice(devExt->Fdo.RawDeviceHandle,
                             FdoDeviceObject,
                             0);

    devExt->Fdo.RawDeviceHandle = NULL;
    
    // in this particular case the API should not fail
    
    USBPORT_ASSERT(ntStatus == STATUS_SUCCESS);                             
    
USBPORT_UserCloseRawDevice_Done:

    Header->UsbUserStatusCode = usbUserStatus;
}    


VOID
USBPORT_UserSendRawCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_SEND_RAW_COMMAND_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    PUSBD_PIPE_HANDLE_I defaultPipe;
    NTSTATUS ntStatus;
    ULONG length;

    USBPORT_KdPrint((2, "'USBPORT_UserSendRawCommand\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'sRAW', 0, 0, 0);

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }
    
    // fail request if closed
    if (devExt->Fdo.RawDeviceHandle == NULL) {
        Header->UsbUserStatusCode = UsbUserInvalidParameter;    
        return; 
    }

    // a control transfer can be up 0 to 64k
    if (Parameters->DataLength > 0x10000) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tbts', 0, 0, 
            Parameters->DataLength);
        Header->UsbUserStatusCode = UsbUserInvalidParameter;    
        return;        
    }

    // extra length check is needed sinve we 
    // have embedded data
    // if we get here we know packet parameters are valid
    length = sizeof(*Header) + sizeof(USB_SEND_RAW_COMMAND_PARAMETERS) - 4 + 
                Parameters->DataLength;

    // length is the area of the buffer we may reference                

    if (length > Header->RequestBufferLength) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'Tsma', length, 0, 
            Header->RequestBufferLength);
        Header->UsbUserStatusCode = UsbUserBufferTooSmall;    
        return;
    } 

    Header->ActualBufferLength = length;

    setupPacket.bmRequestType.B = Parameters->Usb_bmRequest;
    setupPacket.bRequest = Parameters->Usb_bRequest;
    setupPacket.wValue.W = Parameters->Usb_wVlaue;
    setupPacket.wIndex.W = Parameters->Usb_wIndex;
    setupPacket.wLength = Parameters->Usb_wLength;

    // if address is different then we will need to 
    // poke the endpoint

    defaultPipe = &devExt->Fdo.RawDeviceHandle->DefaultPipe;
    
    defaultPipe->Endpoint->Parameters.MaxPacketSize = 
        Parameters->MaximumPacketSize;
    defaultPipe->Endpoint->Parameters.DeviceAddress = 
        Parameters->DeviceAddress;
        
    MP_PokeEndpoint(devExt, defaultPipe->Endpoint, mpStatus);
    
    ntStatus = USBPORT_SendCommand(devExt->Fdo.RawDeviceHandle,
                                   FdoDeviceObject,
                                   &setupPacket,
                                   &Parameters->Data[0],
                                   Parameters->DataLength,
                                   &Parameters->DataLength,
                                   &Parameters->UsbdStatusCode);
    usbUserStatus = 
        USBPORT_NtStatus_TO_UsbUserStatus(ntStatus);
    
    Header->UsbUserStatusCode = usbUserStatus;
}    


VOID
USBPORT_UserGetBandwidthInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BANDWIDTH_INFO BandwidthInfo
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG asyncBW;
    
    USBPORT_KdPrint((2, "'USBPORT_UserGetBandwidthInformation\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gBWi', 0, 0, 0);

    BandwidthInfo->DeviceCount = 
        USBPORT_GetDeviceCount(FdoDeviceObject);
    BandwidthInfo->TotalBusBandwidth = 
        devExt->Fdo.TotalBusBandwidth;
        
    // return allocation based on 32 sec
    // segment of bus time
    BandwidthInfo->Total32secBandwidth = 
        devExt->Fdo.TotalBusBandwidth * 32;
        
    asyncBW = BandwidthInfo->TotalBusBandwidth/10;
    BandwidthInfo->AllocedBulkAndControl = 
        asyncBW * 32;

    BandwidthInfo->AllocedIso =
        devExt->Fdo.AllocedIsoBW*32;
    BandwidthInfo->AllocedInterrupt_1ms =
        devExt->Fdo.AllocedInterruptBW[0]*32;
    BandwidthInfo->AllocedInterrupt_2ms =
        devExt->Fdo.AllocedInterruptBW[1]*16;
    BandwidthInfo->AllocedInterrupt_4ms =
        devExt->Fdo.AllocedInterruptBW[2]*8;
    BandwidthInfo->AllocedInterrupt_8ms =
        devExt->Fdo.AllocedInterruptBW[3]*4;
    BandwidthInfo->AllocedInterrupt_16ms =
        devExt->Fdo.AllocedInterruptBW[4]*2;        
    BandwidthInfo->AllocedInterrupt_32ms =
        devExt->Fdo.AllocedInterruptBW[5]*1;

    Header->ActualBufferLength = 
        sizeof(*Header)+sizeof(USB_BANDWIDTH_INFO);        
}    


VOID
USBPORT_UserGetBusStatistics0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BUS_STATISTICS_0 BusStatistics0
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt, rhDevExt;
    KIRQL irql;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (devExt->Fdo.RootHubPdo != NULL) {
        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);
    } else {
        rhDevExt = NULL;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gBus', rhDevExt, 
        BusStatistics0, 0);

    BusStatistics0->DeviceCount =
        USBPORT_GetDeviceCount(FdoDeviceObject);

    KeQuerySystemTime(&BusStatistics0->CurrentSystemTime);

    MP_Get32BitFrameNumber(devExt, 
                           BusStatistics0->CurrentUsbFrame);

    // lock the stat counters while we read them
    KeAcquireSpinLock(&devExt->Fdo.StatCounterSpin.sl, &irql);
   
    BusStatistics0->BulkBytes = 
        devExt->Fdo.StatBulkDataBytes;
    BusStatistics0->IsoBytes = 
        devExt->Fdo.StatIsoDataBytes;
    BusStatistics0->InterruptBytes = 
        devExt->Fdo.StatInterruptDataBytes;
    BusStatistics0->ControlDataBytes = 
        devExt->Fdo.StatControlDataBytes;

    BusStatistics0->RootHubDevicePowerState = 4;
    BusStatistics0->RootHubEnabled = FALSE;

    BusStatistics0->WorkerSignalCount = 
        devExt->Fdo.StatWorkSignalCount;
    BusStatistics0->HardResetCount = 
        devExt->Fdo.StatHardResetCount;
    BusStatistics0->WorkerIdleTimeMs = 
        devExt->Fdo.StatWorkIdleTime; 

    BusStatistics0->CommonBufferBytes = 
        devExt->Fdo.StatCommonBufferBytes;
    
    
    if (rhDevExt != NULL) {
        BusStatistics0->RootHubEnabled = TRUE;
        switch(rhDevExt->CurrentDevicePowerState) {
        case PowerDeviceD0:
            BusStatistics0->RootHubDevicePowerState = 0;
            break;            
        case PowerDeviceD1:
            BusStatistics0->RootHubDevicePowerState = 1;
            break;          
        case PowerDeviceD2:
            BusStatistics0->RootHubDevicePowerState = 2;
            break;          
        case PowerDeviceD3:
            BusStatistics0->RootHubDevicePowerState = 3;
            break;          
        }
    }
    
    BusStatistics0->PciInterruptCount = 
        devExt->Fdo.StatPciInterruptCount;        

//    if (ResetCounters) {
//        devExt->Fdo.StatControlDataBytes = 
//        devExt->Fdo.StatInterruptBytes = 
//        devExt->Fdo.StatIsoBytes = 
//        devExt->Fdo.StatBulkBytes = 
//        devExt->Fdo.PciInterruptCount = 0;
//    }

    KeReleaseSpinLock(&devExt->Fdo.StatCounterSpin.sl, irql);

    Header->ActualBufferLength = 
        sizeof(*Header)+sizeof(USB_BUS_STATISTICS_0);    
}    

// This was taken from usbioctl.h
//
#include <pshpack1.h>
typedef struct _USB_HCD_DRIVERKEY_NAME {
    ULONG ActualLength;     
    WCHAR DriverKeyName[1]; // names are returned NULL terminated
} USB_HCD_DRIVERKEY_NAME, *PUSB_HCD_DRIVERKEY_NAME;
#include <poppack.h>

NTSTATUS
USBPORT_LegacyGetUnicodeName(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    )
/*++

Routine Description:

    Handles the old style IOCTL to fetch the USB host controllers
    driver key name.

    NOTE: This function may be removed  if we ever fix the UI to use the 
    newer APIs.


Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    NT status code
    
--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PUSBUSER_CONTROLLER_UNICODE_NAME request;
    NTSTATUS ntStatus;
    ULONG need;
    PUSB_HCD_DRIVERKEY_NAME ioBufferO;
    PIO_STACK_LOCATION irpStack;
    ULONG outputBufferLength;
    ULONG ioCtl;

    PAGED_CODE();
    
    *BytesReturned = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ioCtl = irpStack->Parameters.DeviceIoControl.IoControlCode;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    USBPORT_ASSERT(ioCtl == IOCTL_GET_HCD_DRIVERKEY_NAME ||
                   ioCtl == IOCTL_USB_GET_ROOT_HUB_NAME);

    USBPORT_KdPrint((1,"'WARNING: Caller using obsolete user mode IOCTL\n"));

    ioBufferO = Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    
    // Bail immediately if the output buffer is too small
    //
    if (outputBufferLength < sizeof(USB_HCD_DRIVERKEY_NAME)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // first get the driver key name using the standard API

    need = sizeof(USBUSER_CONTROLLER_UNICODE_NAME);

retry:

    ALLOC_POOL_Z(request, 
                 PagedPool, need);

    if (request != NULL) {

        request->Header.RequestBufferLength = need;
        if (ioCtl == IOCTL_GET_HCD_DRIVERKEY_NAME) {            
            request->Header.UsbUserRequest =
                USBUSER_GET_CONTROLLER_DRIVER_KEY;
            USBPORT_UserGetControllerKey(
                FdoDeviceObject,
                &request->Header,
                &request->UnicodeName);                           
        } else {
            request->Header.UsbUserRequest =
                USBUSER_GET_ROOTHUB_SYMBOLIC_NAME;
            USBPORT_UserGetRootHubName(
                FdoDeviceObject,
                &request->Header,
                &request->UnicodeName);                  
        }

        if (request->Header.UsbUserStatusCode == 
            UsbUserBufferTooSmall) {
                
            need = request->Header.ActualBufferLength;
                
            FREE_POOL(FdoDeviceObject, request);
            goto retry;
            
        } else if (request->Header.UsbUserStatusCode ==
                            UsbUserSuccess) {

            // map the result into the callers buffer
                
            // note: actual length is the size of the request structure
            // plus the name.
            ioBufferO->ActualLength = request->UnicodeName.Length + 
                                      sizeof(ULONG);

            if (outputBufferLength >= ioBufferO->ActualLength) {
                // we can return the name
                RtlCopyMemory(&ioBufferO->DriverKeyName[0],
                              &request->UnicodeName.String[0],
                              request->UnicodeName.Length);

                *BytesReturned = ioBufferO->ActualLength;

            } else {
                ioBufferO->DriverKeyName[0] =  L'\0';
                *BytesReturned = sizeof(USB_HCD_DRIVERKEY_NAME);
            }

            ntStatus = STATUS_SUCCESS;

            FREE_POOL(FdoDeviceObject, request);
            
        } else {
            ntStatus = STATUS_UNSUCCESSFUL;    
        }
        
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gUNN', ntStatus, ioBufferO, 
        *BytesReturned);

    return ntStatus;
}    


NTSTATUS
USBPORT_GetSymbolicName(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT DeviceObject,
    PUNICODE_STRING SymbolicNameUnicodeString
    )
/*++

Routine Description:

    Return the symbolic name for the device object with leading  
    \xxx\ removed

Arguments:

    DeviceObject - Fdo OR Pdo for USB HC

Return Value:

    none
    
--*/
{
    PDEVICE_EXTENSION fdoDevExt;
    PDEVICE_EXTENSION devExt;
    ULONG length, offset = 0;
    WCHAR *pwch, *buffer;
    NTSTATUS ntStatus = STATUS_BOGUS;
    ULONG bufferLength;
    PUNICODE_STRING tmpUnicodeString;

    PAGED_CODE();

    GET_DEVICE_EXT(fdoDevExt, FdoDeviceObject);
    ASSERT_FDOEXT(fdoDevExt);

    GET_DEVICE_EXT(devExt, DeviceObject);

    tmpUnicodeString =
        &devExt->SymbolicLinkName;

    //
    // make sure there is enough room for the length,
    // string and the NULL
    //
    
    // assuming the string is \xxx\name strip of '\xxx\' where
    // x is zero or more chars

    pwch = &tmpUnicodeString->Buffer[0];

    // Under NT, if the controller is banged out in DeviceManager,
    // this will be NULL.

    if (pwch == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    
    bufferLength = tmpUnicodeString->Length;

    ALLOC_POOL_Z(buffer, 
                 PagedPool, bufferLength);

    if (buffer != NULL) {
    
        USBPORT_ASSERT(*pwch == '\\');
        if (*pwch == '\\') {
            pwch++;
            while (*pwch != '\\' && *pwch) {
                pwch++;
            }
            USBPORT_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
            }
            offset = (ULONG)((PUCHAR)pwch -
                (PUCHAR)&tmpUnicodeString->Buffer[0]);
        }

        length = tmpUnicodeString->Length - offset;

        RtlCopyMemory(buffer,
                      &tmpUnicodeString->Buffer[offset/2],
                      length);
                      
        RtlInitUnicodeString(SymbolicNameUnicodeString,
                             buffer);                      
                             
        ntStatus = STATUS_SUCCESS;
                             
    } else {

        // init to null so subsequent free will not crash
        RtlInitUnicodeString(SymbolicNameUnicodeString,
                             NULL);                      
    
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        
    }
    
    return ntStatus;
}


VOID
USBPORT_UserGetDriverVersion(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_DRIVER_VERSION_PARAMETERS Parameters
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    
    USBPORT_KdPrint((2, "'USBPORT_UserGetDriverVersion\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'gDrv', 0, 0, 0);

    Parameters->DriverTrackingCode = USBPORT_TRACKING_ID;
    /* USBDI Api set supported */
    Parameters->USBDI_Version = USBDI_VERSION;
    /* USB USER Api Set supported */
    Parameters->USBUSER_Version = USBUSER_VERSION;

    /* set to true if checked vesrion(s) on 
       the stack are loaded 
    */      
#if DBG    
    Parameters->CheckedPortDriver = TRUE;
    Parameters->CheckedMiniportDriver = TRUE;
#else 
    Parameters->CheckedPortDriver = FALSE;
    Parameters->CheckedMiniportDriver = FALSE;
#endif

    Header->ActualBufferLength = 
        sizeof(*Header)+sizeof(USB_DRIVER_VERSION_PARAMETERS);        
}    

BOOLEAN
USBPORT_ValidateRootPortApi(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG PortNumber
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.
    
--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    ROOTHUB_DATA hubData;
    
    USBPORT_KdPrint((2, "'USBPORT_ValidateRootPortApi\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MPRH_GetRootHubData(devExt, &hubData);    
    if (PortNumber > hubData.NumberOfPorts ||
        PortNumber == 0) {
        return FALSE;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        return FALSE;
    }

    return TRUE;
}

/*
    Determine if direct controller access is enabled in registry.
*/

BOOLEAN
USBPORT_DCA_KeyEnabled(
    PDEVICE_OBJECT FdoDeviceObject
    )
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb = L"usb";
    ULONG k = 0;
    ULONG dca = 0;

    PAGED_CODE();

    // bios hacks
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = ENABLE_DCA;
    QueryTable[k].EntryContext = &dca;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = &dca;
    QueryTable[k].DefaultLength = sizeof(dca);
    k++;

    // stop
    QueryTable[k].QueryRoutine = NULL;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment


    return NT_SUCCESS(ntStatus) && dca == 1;
}


/*
    Determine if direct controller access is enabled in registry.
    Also validate that the caller has load driver privilige.
*/

BOOLEAN
USBPORT_DCA_Enabled(
    PDEVICE_OBJECT FdoDeviceObject
    )
{
    if (USBPORT_DCA_KeyEnabled(FdoDeviceObject)) {
        // verify privilage
        // enable this code if the security APIs ever get 
        // added to WDM
#if 0       
        LUID securityLuid;
        
        // first check for correct permissions
        securityLuid = RtlConvertLongToLuid(SE_LOAD_DRIVER_PRIVILEGE);

        return SeSinglePrivilegeCheck(securityLuid, UserMode); 
 #endif
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\int.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    int.c

Abstract:

    code to handle adapter interrupts

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_InterruptService
// USBPORT_IsrDpc
// USBPORT_DisableInterrupts
// USBPORT_IsrDpcWorker


BOOLEAN
USBPORT_InterruptService(
    PKINTERRUPT Interrupt,
    PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the PORT driver.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_OBJECT fdoDeviceObject = Context;
    PDEVICE_EXTENSION devExt;
    BOOLEAN usbInt = FALSE;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // by definition, if we are in any other power state than D0 then
    // the interrupt could not be from the controller.  To handle this 
    // case we use our internal flag that indicates interrupts are 
    // disabled
    
    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_EN)) {
        return FALSE;
    }

    // if the controller is gone then the interrupt cannot  
    // be from USB
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CONTROLLER_GONE)) {
        return FALSE;
    }
    
    // check flag and calldown to miniport
    if (devExt->Fdo.MpStateFlags & MP_STATE_STARTED) {
        MP_InterruptService(devExt, usbInt);        
    } 
//#if DBG 
//      else {
//        // interrupt before we have started,
//        // it had better not be ours
//        DEBUG_BREAK();
//    }  
//#endif    

    if (usbInt) {
         devExt->Fdo.StatPciInterruptCount++;

         KeInsertQueueDpc(&devExt->Fdo.IsrDpc,
                          NULL,
                          NULL);
    } 
    
    return usbInt;
}       


VOID
USBPORT_IsrDpcWorker(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN HcInterrupt
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    This routine dous our 'ISR Work' it can be called as a result
    of an interrupt or from the Deadman DPC timer.

    This function is not reentrant

    This function does not directly signal the worker thread 
    instead we leave this to invalidate endpoint.

Arguments:

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    LONG busy;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);    

    busy = InterlockedIncrement(&devExt->Fdo.WorkerDpc);
    if (busy) {
        InterlockedDecrement(&devExt->Fdo.WorkerDpc);
        return;
    }

    // noisy becuse it is called via timer
#if DBG
    {
    ULONG cf;
    MP_Get32BitFrameNumber(devExt, cf);

    if (HcInterrupt) {
        LOGENTRY(NULL, 
            FdoDeviceObject, LOG_NOISY, 'iDW+', FdoDeviceObject, cf, HcInterrupt);
    } else {
         LOGENTRY(NULL, 
            FdoDeviceObject, LOG_NOISY, 'idw+', FdoDeviceObject, cf, HcInterrupt);
    }
    }
#endif        
    // check the state list for any endpoints
    // that have changed state
    //
    // We add elements to the tail so the ones at
    // the head should be the oldest and ready 
    // for processing.
    // if we hit one that is not ready then we know
    // the others are not ready either so we bail.
    
    listEntry = 
        ExInterlockedRemoveHeadList(&devExt->Fdo.EpStateChangeList,
                                    &devExt->Fdo.EpStateChangeListSpin.sl);

    while (listEntry != NULL) {
    
        PHCD_ENDPOINT endpoint;
        ULONG frameNumber;
    
        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_ENDPOINT, 
                        StateLink);

        ASSERT_ENDPOINT(endpoint);

        // lock the endpoint before changing its state
        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeG0');
        
        // see if it is time 
        MP_Get32BitFrameNumber(devExt, frameNumber);

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'chgS', endpoint, frameNumber, 
            endpoint->StateChangeFrame);

        if (frameNumber <= endpoint->StateChangeFrame &&
            !TEST_FLAG(endpoint->Flags, EPFLAG_NUKED)) {
            // not time yet, put it back (on the head) and bail
            RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeG1'); 

            ExInterlockedInsertHeadList(&devExt->Fdo.EpStateChangeList,
                                        &endpoint->StateLink,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);

            // request an SOF just in case
            MP_InterruptNextSOF(devExt);
            break;                                        
        }

        // this endpoint is ripe, change its state
        //
        // note: we should never move into the unknown state
        //
        // IT IS CRITICAL that this is the only place an endpoint state
        // may be changed.
        // there is one exception and that is cahnging the state to 
        // CLOSED
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeG0');       


        ACQUIRE_STATECHG_LOCK(FdoDeviceObject, endpoint); 
        USBPORT_ASSERT(endpoint->NewState != ENDPOINT_TRANSITION);
        endpoint->CurrentState = endpoint->NewState;
        RELEASE_STATECHG_LOCK(FdoDeviceObject, endpoint); 

        // endpoint needs to be checked,
        // since we are in DPC context we will be processing
        // all endpoints
        USBPORT_InvalidateEndpoint(FdoDeviceObject,
                                   endpoint,
                                   0);

        listEntry = 
            ExInterlockedRemoveHeadList(&devExt->Fdo.EpStateChangeList,
                                        &devExt->Fdo.EpStateChangeListSpin.sl);
    }

//#ifdef USBPERF
//    // always run the DPC worker from the timer to compensate for 
//    // reduced thread activity
//     USBPORT_DpcWorker(FdoDeviceObject);
//#else 
    if (HcInterrupt) {
        USBPORT_DpcWorker(FdoDeviceObject);
    } 
//#endif    

#if DBG    
    if (HcInterrupt) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'iDW-', 0, 
                0, 0);
    } else {
        LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'idw-', 0, 
                0, 0);
    }
#endif    

    InterlockedDecrement(&devExt->Fdo.WorkerDpc);
}


VOID
USBPORT_IsrDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    If the controller was the source of the interrupt this 
    routine will be called.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies the DeviceObject.

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    BOOLEAN enableIrq;

    fdoDeviceObject = (PDEVICE_OBJECT) DeferredContext;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);    

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'iDP+', fdoDeviceObject, 0, 0);

    KeAcquireSpinLockAtDpcLevel(&devExt->Fdo.IsrDpcSpin.sl);
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'DPlk', fdoDeviceObject, 0, 0);
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_EN)) {
        enableIrq = TRUE;
    } else {        
        enableIrq = FALSE;
    }        
    MP_InterruptDpc(devExt, enableIrq);        
    KeReleaseSpinLockFromDpcLevel(&devExt->Fdo.IsrDpcSpin.sl);
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'DPuk', fdoDeviceObject, 0, 0);

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        // if we take an interrupt while 'suspended' we treat 
        // this as a wakeup event.
        USBPORT_KdPrint((1, "  HC Wake Event\n"));
        USBPORT_CompletePdoWaitWake(fdoDeviceObject);
    } else {
        USBPORT_IsrDpcWorker(fdoDeviceObject, TRUE);   
    }            
    
    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'iDP-', 0, 
            0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\prototyp.h ===
/*++

Copyright (c) 1999, 2000  Microsoft Corporation

Module Name:

    prototyp.h

Abstract:

    put all the prototypes in one header

Environment:

    Kernel & user mode

Revision History:

    2-25-00 : created

--*/

#ifndef   __PROTOTYP_H__
#define   __PROTOTYP_H__

#define FRAME_COUNT_WAIT 5

PUSBPORT_MINIPORT_DRIVER
USBPORT_FindMiniport(
    PDRIVER_OBJECT DriverObject
    );

VOID
USBPORT_Unload(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
USBPORT_CreateDeviceObject(
    PDRIVER_OBJECT DriverObject,
    PUSBPORT_MINIPORT_DRIVER MiniportDriver,
    OUT PDEVICE_OBJECT *DeviceObject,
    PUNICODE_STRING DeviceNameUnicodeString
    );

NTSTATUS
USBPORT_PnPAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
USBPORT_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
USBPORT_PdoPnPIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_FdoPnPIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

VOID
USBPORT_CompleteIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    NTSTATUS ntStatus,
    ULONG_PTR Information
    );

NTSTATUS
USBPORT_DeferredStartDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_StopDevice(
     PDEVICE_OBJECT FdoDeviceObject,
     BOOLEAN HardwarePresent
     );

NTSTATUS
USBPORT_StartDevice(
     PDEVICE_OBJECT FdoDeviceObject,
     PHC_RESOURCES HcResources
     );

BOOLEAN
USBPORT_ValidateDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    BOOLEAN ReferenceUrb
    );

BOOLEAN
USBPORT_ValidatePipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    );

NTSTATUS
USBPORT_SetUSBDError(
    PURB Urb,
    USBD_STATUS UsbdStatus
    );

NTSTATUS
USBPORT_PassIrp(
    PDEVICE_OBJECT DeviceObject,
    PIO_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    BOOLEAN InvokeOnSuccess,
    BOOLEAN InvokeOnError,
    BOOLEAN InvokeOnCancel,
    PIRP Irp
    );

NTSTATUS
USBPORT_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION DevExt,
    PDEVICE_OBJECT PhysicalDeviceObject,
    LPGUID Guid
    );

NTSTATUS
USBPORT_SetRegistryKeyValueForPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    ULONG Type,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    );

NTSTATUS
USBPORT_GetRegistryKeyValueForPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    );

VOID
USBPORT_CancelSplitTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_TRANSFER_CONTEXT SplitTransfer
    );

NTSTATUS
USBPORT_CreateRootHubPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT *RootHubPdo
    );

NTSTATUS
USBPORT_BusQueryBusTime(
    PVOID BusContext,
    PULONG CurrentFrame
    );

NTSTATUS
USBPORT_BusSubmitIsoOutUrb(
    PVOID BusContext,
    PURB Urb
    );

VOID
USBPORT_BusGetUSBDIVersion(
    PVOID BusContext,
    PUSBD_VERSION_INFORMATION VersionInformation,
    PULONG HcdCapabilities
    );

NTSTATUS
USBPORT_MakeRootHubPdoName(
    PDEVICE_OBJECT FdoDeviceObject,
    PUNICODE_STRING PdoNameUnicodeString,
    ULONG Index
    );

NTSTATUS
USBPORT_MakeHcdDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString,
    ULONG Idx
    );

PWCHAR
USBPORT_GetIdString(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Vid,
    USHORT Pid,
    USHORT Rev
    );

USBD_STATUS
USBPORT_AllocTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp,
    PKEVENT CompleteEvent,
    ULONG MillisecTimeout
    );

VOID
USBPORT_QueueTransferUrb(
    PTRANSFER_URB Urb
    );

VOID
USBPORT_FreeUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT DeviceAddress
    );

USHORT
USBPORT_AllocateUsbAddress(
    PDEVICE_OBJECT FdoDeviceObject
    );

NTSTATUS
USBPORT_SendCommand(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PVOID Buffer,
    ULONG BufferLength,
    PULONG BytesReturned,
    USBD_STATUS *UsbdStatus
    );

USBD_STATUS
USBPORT_MiniportStatus_TO_USBDStatus(
    USB_MINIPORT_STATUS mpStatus
    );
#define MPSTATUS_TO_USBSTATUS(s) USBPORT_MiniportStatus_TO_USBDStatus((s))

NTSTATUS
USBPORT_MiniportStatus_TO_NtStatus(
    USB_MINIPORT_STATUS mpStatus
    );
#define MPSTATUS_TO_NTSTATUS(s) USBPORT_MiniportStatus_TO_NtStatus((s))

RHSTATUS
USBPORT_MiniportStatus_TO_RHStatus(
    USB_MINIPORT_STATUS mpStatus
    );
#define MPSTATUS_TO_RHSTATUS(s) USBPORT_MiniportStatus_TO_RHStatus((s))

USBD_STATUS
USBPORT_RHStatus_TO_USBDStatus(
    USB_MINIPORT_STATUS rhStatus
    );
#define RHSTATUS_TO_USBDSTATUS(s) USBPORT_RHStatus_TO_USBDStatus((s))


NTSTATUS
USBPORT_FdoDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_PdoDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_FdoInternalDeviceControlIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_PdoInternalDeviceControlIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

#ifdef DRM_SUPPORT

NTSTATUS
USBPORT_PdoSetContentId(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
);

#endif

NTSTATUS
USBPORT_ProcessURB(
    PDEVICE_OBJECT PdoDeviceObject,
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PURB Urb
    );

VOID
USBPORT_TrackPendingRequest(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP           Irp,
    BOOLEAN        AddToList
    );

NTSTATUS
USBPORT_GetConfigValue(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
    );

VOID
USBPORT_CancelTransfer(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
USBPORT_CompleteTransfer(
    PTRANSFER_URB Urb,
    USBD_STATUS CompleteCode
    );

BOOLEAN
USBPORT_InterruptService(
    PKINTERRUPT Interrupt,
    PVOID Context
    );

VOID
USBPORT_HalFreeCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_COMMON_BUFFER CommonBuffer
    );

PUSBPORT_COMMON_BUFFER
USBPORT_HalAllocateCommonBuffer(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG NumberOfBytes
    );

USB_MINIPORT_STATUS
USBPORTSVC_GetMiniportRegistryKeyValue(
    PDEVICE_DATA DeviceData,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    );

USB_MINIPORT_STATUS
USBPORTSVC_ReadWriteConfigSpace(
    PDEVICE_DATA DeviceData,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
USBPORT_InternalOpenInterface(
    PURB Urb,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigHandle,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    OUT PUSBD_INTERFACE_HANDLE_I *InterfaceHandle,
    BOOLEAN SendSetInterfaceCommand
    );

PUSBD_CONFIG_HANDLE
USBPORT_InitializeConfigurationHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
USBPORT_SelectConfiguration(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PURB Urb
    );

VOID
USBPORT_InternalCloseConfiguration(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    );

PUSB_INTERFACE_DESCRIPTOR
USBPORT_InternalParseConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    UCHAR InterfaceNumber,
    UCHAR AlternateSetting,
    PBOOLEAN HasAlternateSettings
    );

NTSTATUS
USBPORT_OpenEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle,
    USBD_STATUS *UsbdStatus,
    BOOLEAN IsDefaultPipe
    );

VOID
USBPORT_CloseEndpoint(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT DeviceObject,
    PHCD_ENDPOINT Endpoint
    );

ULONG
USBPORT_InternalGetInterfaceLength(
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    PUCHAR End
    );

VOID
USBPORT_RootHub_EndpointWorker(
    PHCD_ENDPOINT Endpoint
    );

NTSTATUS
USBPORT_RootHub_CreateDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    );

VOID
USBPORT_RootHub_RemoveDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    );

RHSTATUS
USBPORT_RootHub_Endpoint0(
    PHCD_TRANSFER_CONTEXT Transfer
    );

RHSTATUS
USBPORT_RootHub_Endpoint1(
    PHCD_TRANSFER_CONTEXT Transfer
    );

VOID
USBPORT_PollEndpoint(
    PHCD_ENDPOINT Endpoint
    );

RHSTATUS
USBPORT_RootHub_ClassCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PUCHAR Buffer,
    PULONG BufferLength
    );

RHSTATUS
USBPORT_RootHub_StandardCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PUCHAR Buffer,
    PULONG BufferLength
    );

NTSTATUS
USBPORT_QueryCapabilities(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_CAPABILITIES DeviceCapabilities
    );

VOID
USBPORT_AddDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    );

VOID
USBPORT_AddPipeHandle(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PUSBD_PIPE_HANDLE_I PipeHandle
    );

VOID
USBPORT_FlushCancelList(
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_SetEndpointState(
    PHCD_ENDPOINT Endpoint,
    MP_ENDPOINT_STATE State
    );

MP_ENDPOINT_STATE
USBPORT_GetEndpointState(
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_IsrDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
USBPORT_DoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer
    );

VOID
USBPORTSVC_CompleteIsoTransfer(
    PDEVICE_DATA DeviceData,
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

VOID
USBPORTSVC_RequestAsyncCallback(
    PDEVICE_DATA DeviceData,
    ULONG MilliSeconds,
    PVOID Context,
    ULONG ContextLength,
    PMINIPORT_CALLBACK CallbackFunction
    );

VOID
USBPORT_QueueDoneTransfer(
    PHCD_TRANSFER_CONTEXT Transfer,
    USBD_STATUS CompleteCode
    );

VOID
USBPORT_FlushDoneTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    );

BOOLEAN
USBPORT_CoreEndpointWorker(
    PHCD_ENDPOINT Endpoint,
    ULONG Flags
    );

NTSTATUS
USBPORT_GetBusInterface(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_GetBusInterfaceHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

VOID
USBPORT_FlushAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_UserGetDriverVersion(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_DRIVER_VERSION_PARAMETERS Parameters
    );

NTSTATUS
USBPORTBUSIF_CreateUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE *NewDeviceHandle,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    );

NTSTATUS
USBPORTBUSIF_RemoveUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    ULONG Flags
    );

NTSTATUS
USBPORT_InitializeDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_BusInterfaceReference(
    PVOID BusContext
    );

VOID
USBPORT_BusInterfaceDereference(
    PVOID BusContext
    );

NTSTATUS
USBPORT_CreateDevice(
    PUSBD_DEVICE_HANDLE *DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT PortStatus,
    USHORT PortNumber
    );

NTSTATUS
USBPORT_DeferIrpCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
USBPORTSVC_InvalidateRootHub(
    PDEVICE_DATA DeviceData
    );

RHSTATUS
USBPORT_RootHub_PortRequest(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PORT_OPERATION PortOperation
    );

VOID
USBPORT_ComputeRootHubDeviceCaps(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    );

VOID
USBPORT_FlushMapTransferList(
    PDEVICE_OBJECT FdoDeviceObject
    );

NTSTATUS
USBPORT_FdoPowerIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_PdoPowerIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

VOID
USBPORT_DmaEndpointWorker(
    PHCD_ENDPOINT Endpoint
    );

NTSTATUS
USBPORT_CreateLegacyFdoSymbolicLink(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_DpcWorker(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_TransferFlushDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
USBPORT_InvalidateController(
    PDEVICE_OBJECT FdoDeviceObject,
    USB_CONTROLLER_STATE ControllerState
    );

VOID
USBPORT_FlushPendingList(
    PHCD_ENDPOINT Endpoint,
    ULONG Count
    );

ULONG
USBPORT_CalculateUsbBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_SurpriseRemoveDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
USBPORT_HcResetDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
USBPORTSVC_CompleteTransfer(
    PDEVICE_DATA DeviceData,
    PDEVICE_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    USBD_STATUS UsbdStatus,
    ULONG BytesTransferred
    );

VOID
USBPORTSVC_InvalidateEndpoint(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

NTSTATUS
USBPORTBUSIF_InitializeUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle
    );

NTSTATUS
USBPORTBUSIF_GetUsbDescriptors(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PUCHAR DeviceDescriptorBuffer,
    PULONG DeviceDescriptorBufferLength,
    PUCHAR ConfigDescriptorBuffer,
    PULONG ConfigDescriptorBufferLength
    );

VOID
USBPORT_QueuePendingUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    );

NTSTATUS
USBPORT_GetUsbDescriptor(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    UCHAR DescriptorType,
    PUCHAR DescriptorBuffer,
    PULONG DescriptorBufferLength
    );

VOID
USBPORT_Wait(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Milliseconds
    );

VOID
USBPORT_Worker(
    PDEVICE_OBJECT FdoDeviceObject
    );

BOOLEAN
USBPORT_FindUrbInList(
    PTRANSFER_URB Urb,
    PLIST_ENTRY ListHead
    );

VOID
USBPORT_SignalWorker(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORTSVC_LogEntry(
    PDEVICE_DATA DeviceData,
    ULONG Mask,
    ULONG Sig,
    ULONG_PTR Info1,
    ULONG_PTR Info2,
    ULONG_PTR Info3
    );

VOID
USBPORT_QueuePendingTransferIrp(
    PIRP Irp
    );

VOID
USBPORT_CancelPendingTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP CancelIrp
    );

VOID
USBPORT_QueuePendingUrbToEndpoint(
    PHCD_ENDPOINT Endpoint,
    PTRANSFER_URB Urb
    );

VOID
USBPORT_CancelActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP CancelIrp
    );

VOID
USBPORT_InsertIrpInTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    );

PIRP
USBPORT_RemoveIrpFromTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PIRP Irp
    );

PIRP
USBPORT_RemovePendingTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

PIRP
USBPORT_RemoveActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

VOID
USBPORT_FreeIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE BaseIrpTable
    );

PUCHAR
USBPORTSVC_MapHwPhysicalToVirtual(
    HW_32BIT_PHYSICAL_ADDRESS HwPhysicalAddress,
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData
    );

PURB
USBPORT_UrbFromIrp(
    PIRP Irp
    );

VOID
USBPORT_FlushAbortList(
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_AbortEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PIRP Irp
    );

BOOLEAN
USBPORT_LazyCloseEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

NTSTATUS
USBPORT_RemoveDevice(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Flags
    );

VOID
USBPORT_AbortAllTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    );

NTSTATUS
USBPORT_CreateWorkerThread(
    PDEVICE_OBJECT FdoDeviceObject
    );


#define IEP_SIGNAL_WORKER       0x00000001
#define IEP_REQUEST_INTERRUPT   0x00000002

VOID
USBPORT_InvalidateEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    ULONG IEPflags
    );

VOID
USBPORT_TerminateWorkerThread(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_FlushClosedEndpointList(
    PDEVICE_OBJECT FdoDeviceObject
    );

PIRP
USBPORT_FindActiveTransferIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_ReadWriteConfigSpace(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
USBPORT_UsbFdoUserIoctl(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    );

VOID
USBPORT_UserSendOnePacket(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PPACKET_PARAMETERS PacketParameters
    );

NTSTATUS
USBPORT_CreatePortFdoSymbolicLink(
    PDEVICE_OBJECT FdoDeviceObject
    );

#define USBPORT_ReadConfigSpace(fdo, buffer, offset, length) \
    USBPORT_ReadWriteConfigSpace((fdo), TRUE, (buffer), (offset), (length))

#define USBPORT_WriteConfigSpace(fdo, buffer, offset, length) \
    USBPORT_ReadWriteConfigSpace((fdo), FALSE, (buffer), (offset), (length))

BOOLEAN
USBPORT_ValidateConfigurtionDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdStatus
    );


VOID
USBPORT_UserGetControllerInfo_0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CONTROLLER_INFO_0 ControllerInfo_0
    );

VOID
USBPORT_UserRawResetPort(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_RESET_PORT_PARAMETERS Parameters
    );

VOID
USBPORT_GetRootPortStatus(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_PARAMETERS Parameters
    );

VOID
USBPORT_UserSetRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    );

VOID
USBPORT_UserClearRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    );

VOID
USBPORT_StartDM_Timer(
    PDEVICE_OBJECT FdoDeviceObject,
    LONG MillisecondInterval
    );

VOID
USBPORT_IsrDpcWorker(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN HcInterrupt
    );

VOID
USBPORT_InvalidateRootHub(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_HcQueueWakeDpc(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_HcWakeDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
USBPORT_StopDM_Timer(
    PDEVICE_OBJECT FdoDeviceObject
    );

BOOLEAN
USBPORT_EndpointHasQueuedTransfers(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

USB_USER_ERROR_CODE
USBPORT_NtStatus_TO_UsbUserStatus(
    NTSTATUS NtStatus
    );

VOID
USBPORT_UserGetControllerKey(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME ControllerKey
    );

VOID
USBPORT_UserPassThru(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_PASS_THRU_PARAMETERS PassThru
    );

VOID
USBPORT_CancelPendingWakeIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    );

VOID
USBPORT_TurnControllerOff(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_TurnControllerOn(
     PDEVICE_OBJECT FdoDeviceObject
     );

PHC_POWER_STATE
USBPORT_GetHcPowerState(
    PDEVICE_OBJECT FdoDeviceObject,
    PHC_POWER_STATE_TABLE HcPowerStateTbl,
    SYSTEM_POWER_STATE SystemState
    );

VOID
USBPORT_ComputeHcPowerStates(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_CAPABILITIES HcDeviceCaps,
    PHC_POWER_STATE_TABLE HcPowerStateTbl
    );

NTSTATUS
USBPORTBUSIF_RestoreUsbDevice(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE OldDeviceHandle,
    PUSB_DEVICE_HANDLE NewDeviceHandle
    );

MP_ENDPOINT_STATUS
USBPORT_GetEndpointStatus(
    PHCD_ENDPOINT Endpoint
    );

NTSTATUS
USBPORT_CloneDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE OldDeviceHandle,
    PUSBD_DEVICE_HANDLE NewDeviceHandle
    );

VOID
USBPORT_SuspendController(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_NukeAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_RemoveDeviceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle
    );

VOID
USBPORT_StopRootHubPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    );

VOID
USBPORT_ResumeController(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_UserPowerInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_POWER_INFO PowerInformation
    );

PHCD_TRANSFER_CONTEXT
USBPORT_UnlinkTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb
    );

VOID
USBPORT_UserOpenRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_OPEN_RAW_DEVICE_PARAMETERS Parameters
    );

VOID
USBPORT_UserCloseRawDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_CLOSE_RAW_DEVICE_PARAMETERS Parameters
    );

 VOID
USBPORT_UserSendRawCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_SEND_RAW_COMMAND_PARAMETERS Parameters
    );

VOID
USBPORT_InitializeIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb,
    PHCD_TRANSFER_CONTEXT Transfer
    );

BOOLEAN
USBPORT_InTextmodeSetup(
    VOID
    );

NTSTATUS
USBPORT_IsCompanionController(
    PDEVICE_OBJECT FdoDeviceObject,
    PBOOLEAN       ReturnResult
    );

USB_CONTROLLER_FLAVOR
USBPORT_GetHcFlavor(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT PciVendorId,
    USHORT PciProductId,
    UCHAR PciRevision
    );

VOID
USBPORT_ClosePipe(
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_PIPE_HANDLE_I PipeHandle
    );

PUSBD_INTERFACE_HANDLE_I
USBPORT_GetInterfaceHandle(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_CONFIG_HANDLE ConfigurationHandle,
    UCHAR InterfaceNumber
    );

USBD_STATUS
USBPORT_InitializeInterfaceInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    PUSBD_CONFIG_HANDLE ConfigHandle
    );

NTSTATUS
USBPORT_GetBusInterfaceUSBDI(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PIRP Irp
    );

PVOID
USBPORT_GetDeviceBusContext(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE DeviceHandle,
    PVOID HubBusContext
    );

PVOID
USBPORTBUSIF_GetDeviceBusContext(
    IN PVOID HubBusContext,
    IN PVOID DeviceHandle
    );

ULONG
USBPORT_ComputeTotalBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PVOID BusContext
    );

USB_MINIPORT_STATUS
USBPORT_NtStatus_TO_MiniportStatus(
    NTSTATUS NtStatus
    );

BOOLEAN
USBPORT_AllocateBandwidthUSB11(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

BOOLEAN
USBPORT_AllocateBandwidthUSB20(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_FreeBandwidthUSB11(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_FreeBandwidthUSB20(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_UserGetBandwidthInformation(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BANDWIDTH_INFO BandwidthInfo
    );

PTRANSACTION_TRANSLATOR
USBPORT_GetTt(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    PUSHORT PortNumber
    );

NTSTATUS
USBPORT_InitializeTT(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    USHORT Port
    );

VOID
USBPORTSVC_Wait(
    PDEVICE_DATA DeviceData,
    ULONG MillisecondsToWait
    );

ULONG
USBPORT_GetDeviceCount(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_UserGetBusStatistics0(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_BUS_STATISTICS_0 BusStatistics0
    );

ULONG
USBPORT_ComputeAllocatedBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PVOID BusContext
    );

VOID
USBPORT_EndpointTimeout(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_TimeoutAllEndpoints(
    PDEVICE_OBJECT FdoDeviceObject
    );

NTSTATUS
USBPORT_LegacyGetUnicodeName(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PULONG BytesReturned
    );

USHORT
USBPORT_GetTtDeviceAddress(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle
    );

NTSTATUS
USBPORT_GetSymbolicName(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT DeviceObject,
    PUNICODE_STRING SymbolicNameUnicodeString
    );

VOID
USBPORT_UserGetRootHubName(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PUSB_UNICODE_NAME RootHubName
    );

NTSTATUS
USBPORTBUSIF_BusQueryDeviceInformation(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE DeviceHandle,
    PVOID DeviceInformationBuffer,
    ULONG DeviceInformationBufferLength,
    PULONG LengthOfDataCopied
    );

NTSTATUS
USBPORT_IdleNotificationRequest(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    );

VOID
USBPORT_CompletePdoWaitWake(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_CompletePendingIdleIrp(
    PDEVICE_OBJECT PdoDeviceObject
    );

VOID
USBPORT_FlushController(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_SubmitHcWakeIrp(
    PDEVICE_OBJECT FdoDeviceObject
    );

BOOLEAN
USBPORT_RootHubEnabledForWake(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_RestoreController(
     PDEVICE_OBJECT FdoDeviceObject
     );

VOID
USBPORT_ErrorCompleteIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoiint,
    PHCD_TRANSFER_CONTEXT Transfer
    );

BOOLEAN
USBPORT_SelectiveSuspendEnabled(
    PDEVICE_OBJECT FdoDeviceObject
    );

PIRP
USBPORT_FindUrbInIrpTable(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_IRP_TABLE IrpTable,
    PTRANSFER_URB Urb,
    PIRP InputIrp
    );

PUSBD_DEVICE_HANDLE
USBPORT_GetDeviceHandle(
    PHCD_ENDPOINT Endpoint
    );

//VOID
//USBPORT_CancelHcWakeIrp(
//    PDEVICE_OBJECT FdoDeviceObject
//    );

VOID
USBPORT_DoneSplitTransfer(
    PHCD_TRANSFER_CONTEXT SplitTransfer
    );

VOID
USBPORT_AssertTransferUrb(
    PTRANSFER_URB Urb
    );

VOID
USBPORT_SplitTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PLIST_ENTRY TransferList
    );

VOID
USBPORTSVC_InvalidateController(
    PDEVICE_DATA DeviceData,
    USB_CONTROLLER_STATE ControllerState
    );

VOID
USBPORTSVC_BugCheck(
    PDEVICE_DATA DeviceData
    );

VOID
USBPORT_DbgAcquireSpinLock(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_SPIN_LOCK  SpinLock,
    PKIRQL OldIrql
    );

VOID
USBPORT_DbgReleaseSpinLock(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_SPIN_LOCK  SpinLock,
    KIRQL NewIrql
    );

VOID
USBPORT_InitializeSpinLock (
    PUSBPORT_SPIN_LOCK SpinLock,
    LONG SigA,
    LONG SigR
    );

VOID
USBPORT_PowerFault(
    PDEVICE_OBJECT FdoDeviceObject,
    PUCHAR MessageText
    );

NTSTATUS
USBPORTBUSIF_GetControllerInformation(
    PVOID BusContext,
    PVOID ControllerInformationBuffer,
    ULONG ControllerInformationBufferLength,
    PULONG LengthOfDataCopied
    );

NTSTATUS
USBPORTBUSIF_ControllerSelectiveSuspend(
    PVOID BusContext,
    BOOLEAN Enable
    );

NTSTATUS
USBPORTBUSIF_GetRootHubSymbolicName(
    PVOID BusContext,
    PVOID HubSymNameBuffer,
    ULONG HubSymNameBufferLength,
    PULONG LengthOfDataCopied
    );

NTSTATUS
USBPORTBUSIF_GetExtendedHubInformation(
    PVOID BusContext,
    PDEVICE_OBJECT HubPhysicalDeviceObject,
    PVOID HubInformationBuffer,
    ULONG HubInformationBufferLength,
    PULONG LengthOfDataCopied
    );

VOID
USBPORT_BeginTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_EndTransmitTriggerPacket(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_CatcTrap(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_RebalanceEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PLIST_ENTRY EndpointList
    );

NTSTATUS
USBPORT_GetDefaultBIOS_X(
     PDEVICE_OBJECT FdoDeviceObject,
     PULONG BiosX,
     PULONG GlobalDisableSS,
     PULONG GlobalDisableCCDetect,
     PULONG EnIdleEndpointSupport
     );

VOID
USBPORT_ApplyBIOS_X(
     PDEVICE_OBJECT FdoDeviceObject,
     PDEVICE_CAPABILITIES DeviceCaps,
     ULONG BiosX
     );

NTSTATUS
USBPORT_InitializeHsHub(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBD_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    );

NTSTATUS
USBPORTBUSIF_InitailizeUsb2Hub(
    PVOID BusContext,
    PUSB_DEVICE_HANDLE HubDeviceHandle,
    ULONG TtCount
    );

VOID
USBPORTSVC_NotifyDoubleBuffer(
    PDEVICE_DATA DeviceData,
    PTRANSFER_PARAMETERS TransferParameters,
    PVOID DbSystemAddress,
    ULONG DbLength
    );

VOID
USBPORT_FlushAdapterDBs(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_TRANSFER_CONTEXT Transfer
    );

BOOLEAN
USBPORT_IsDeviceHighSpeed(
    PVOID BusContext
    );

VOID
USBPORT_UpdateAllocatedBw(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_UpdateAllocatedBwTt(
    PTRANSACTION_TRANSLATOR Tt
    );

VOID
USBPORT_BadRequestFlush(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN ForceFlush
    );

VOID
USBPORTBUSIF_FlushTransfers(
    PVOID BusContext,
    PVOID DeviceHandle
    );

USBD_STATUS
USBPORT_FlushIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    );

USBPORT_OS_VERSION
USBPORT_DetectOSVersion(
     PDEVICE_OBJECT FdoDeviceObject
     );

VOID
USBPORT_DoSetPowerD0(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_QueuePowerWorkItem(
    PDEVICE_OBJECT FdoDeviceObject
    );

NTSTATUS
USBPORTBUSIF_RootHubInitNotification(
    PVOID BusContext,
    PVOID CallBackContext,
    PRH_INIT_CALLBACK CallbackRoutine
    );

VOID
USBPORT_SynchronizeControllersStart(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_SynchronizeControllersResume(
    PDEVICE_OBJECT FdoDeviceObject
    );

PDEVICE_OBJECT
USBPORT_FindUSB2Controller(
    PDEVICE_OBJECT CcFdoDeviceObject
    );

VOID
USBPORT_RegisterUSB2fdo(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_RegisterUSB1fdo(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_DeregisterUSB2fdo(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_DeregisterUSB1fdo(
    PDEVICE_OBJECT FdoDeviceObject
    );

PDEVICE_RELATIONS
USBPORT_FindCompanionControllers(
    PDEVICE_OBJECT Usb2FdoDeviceObject,
    BOOLEAN ReferenceObjects,
    BOOLEAN ReturnFdo
    );

VOID
USBPORT_UserSetRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    );

VOID
USBPORT_UserClearRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    );

ULONG
USBPORT_SelectOrdinal(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    );

VOID
USBPORT_WriteHaction(
     PDEVICE_OBJECT Usb2FdoDeviceObject,
     ULONG Haction
     );

USB_MINIPORT_STATUS
USBPORT_RootHub_PowerUsb2Port(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Port
    );

NTSTATUS
USBPORT_BusEnumLogEntry(
    PVOID BusContext,
    ULONG DriverTag,
    ULONG EnumTag,
    ULONG P1,
    ULONG P2
    );

BOOLEAN
USBPORT_ValidateRootPortApi(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG PortNumber
    );

BOOLEAN
USBPORT_DCA_Enabled(
    PDEVICE_OBJECT FdoDeviceObject
    );

USB_MINIPORT_STATUS
USBPORT_RootHub_PowerUsbCcPort(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Port
    );

USB_MINIPORT_STATUS
USBPORT_RootHub_PowerAndChirpAllCcPorts(
    PDEVICE_OBJECT FdoDeviceObject
    );

#ifdef LOG_OCA_DATA

VOID
USBPORTBUSIF_SetDeviceHandleData(
    PVOID BusContext,
    PVOID DeviceHandle,
    PDEVICE_OBJECT UsbDevicePdo
    );

VOID
USBPORT_RecordOcaData(
    PDEVICE_OBJECT FdoDeviceObject,
    POCA_DATA OcaData,
    PHCD_TRANSFER_CONTEXT Transfer,
    PIRP Irp
    );
#endif

RHSTATUS
USBPORT_RootHub_HubRequest(
    PDEVICE_OBJECT FdoDeviceObject,
    PORT_OPERATION PortOperation
    );

NTSTATUS
USBPORT_ProcessHcWakeIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    );

NTSTATUS
USBPORT_HcWakeIrp_Io_Completion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
USBPORT_HcWakeIrp_Po_Completion(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE DeviceState,
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus
    );

VOID
USBPORT_DisarmHcForWake(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_ArmHcForWake(
    PDEVICE_OBJECT FdoDeviceObject
    );

VOID
USBPORT_FlushCahcedRegistryKeys(
    PDEVICE_OBJECT FdoDeviceObject
    );

NTSTATUS
USBPORT_GetCachedRegistryKeyValueForPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    );

VOID
USBPORT_DoRootHubCallback(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT Usb2Fdo
    );

#endif /* __PROTOTYP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\iso.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    iso.c

Abstract:

    Constructs and handle iso transfers.  

Environment:

    kernel mode only

Notes:

Revision History:

    1-1-00 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// non paged functions

MP_HW_PHYSICAL_ADDRESS
USBPORT_GetPhysicalAddressFromOffset(
    PTRANSFER_SG_LIST SgList,
    ULONG Offset,
    PULONG Idx
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PTRANSFER_SG_ENTRY32 sg;
    ULONG i;
    MP_HW_PHYSICAL_ADDRESS p;
    ULONG c = SgList->SgCount-1;

    for(i=0; i < SgList->SgCount; i++) {

        if (Offset >= SgList->SgEntry[i].StartOffset &&
            Offset < SgList->SgEntry[i].StartOffset +
                SgList->SgEntry[i].Length) {
            break;
        }
        
    }
    
    // i = idx of sg entry that this packet falls in   
    sg = &SgList->SgEntry[i];

    // the 'offset' of the packet minus the start offset of the
    // sg entry is the offset into this  sg entry that the packet
    // starts
    
    //   {.sgN...}{.sgN+1.}{.sgN+2.}{.sgN+3.}     sg entries
    //      b--------------------------->e        client buffer
    //       <p0><p1><p2><p3><p4><p5><p6>         urb 'packets' 
    //   x--------x--------x--------x--------x    physical pages
    //       <m0><m1><m2><m3><m4><m5><m6>

    *Idx = i;

    USBPORT_ASSERT(Offset >= sg->StartOffset);

    p = sg->LogicalAddress;
    p.Hw32 += (Offset - sg->StartOffset);

    return p;
}

VOID
USBPORT_InitializeIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_URB Urb,
    PHCD_TRANSFER_CONTEXT Transfer
    )
/*++

Routine Description:

    Initialize the iso transfer structure from the 
    orginal client URB and SG list



       {.sgN...}{.sgN...}{..sgN..}              sg entries
          b--------------------------->e        client buffer
           <p0><p1><p2><p3><p4><p5><p6>         urb 'packets' 
       x--------x--------x--------x--------x    physical pages
           <m0><m1><m2><m3><m4><m5><m6>


    The sg entries are not that useful to the USB controller
    HW since the HW deals in usb packets so we create a structure
    that describes the physical addresses assocaited with each 
    packet.

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION devExt;
    PMINIPORT_ISO_TRANSFER isoTransfer;
    PUSBD_ISO_PACKET_DESCRIPTOR usbdPak;
    PMINIPORT_ISO_PACKET mpPak;
    PTRANSFER_SG_LIST sgList;
    ULONG p, i, cf, j;
    ULONG sgIdx_Start, sgIdx_End, offset;
    PUCHAR va;
    MP_HW_PHYSICAL_ADDRESS b0, b1;
    ULONG b1Idx, b0Idx;
    BOOLEAN highSpeed;
    
    ASSERT_TRANSFER(Transfer);
    highSpeed = TEST_FLAG(Transfer->Flags, USBPORT_TXFLAG_HIGHSPEED);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
   
    isoTransfer = Transfer->IsoTransfer;
    sgList = &Transfer->SgList;

    LOGENTRY(Transfer->Endpoint, 
        FdoDeviceObject, LOG_ISO, 'iISO', Urb, Transfer, isoTransfer);

    isoTransfer->Sig = SIG_ISOCH;
    isoTransfer->PacketCount = Urb->u.Isoch.NumberOfPackets;
    isoTransfer->SystemAddress = sgList->MdlSystemAddress;

    // note: proper start frame was computed when the transfer 
    // was queued.

    // check the current frame if it is too late to transmit any
    // packets set the appropriate errors in the URB

    MP_Get32BitFrameNumber(devExt, cf);    

    LOGENTRY(Transfer->Endpoint, 
        FdoDeviceObject, LOG_ISO, 'isCf', cf, 
            Urb->u.Isoch.StartFrame, isoTransfer);

    if (highSpeed) {
        // for high speed we are dealing with microframes
        // (8 packest per frame) 
        // BUGBUG this needs to be failed
        USBPORT_ASSERT((isoTransfer->PacketCount % 8) == 0);
        for (i = Urb->u.Isoch.StartFrame;
             i < Urb->u.Isoch.StartFrame + Urb->u.Isoch.NumberOfPackets/8;
             i++) {

            if (i <= cf) {
                p = (i - Urb->u.Isoch.StartFrame)*8;
                for (j=0; j<8; j++) {
                    usbdPak = &Urb->u.Isoch.IsoPacket[p+j];

                    if (usbdPak->Status == USBD_STATUS_NOT_SET) {
                        usbdPak->Status = USBD_STATUS_ISO_NA_LATE_USBPORT;

                        LOGENTRY(Transfer->Endpoint, 
                            FdoDeviceObject, LOG_ISO, 'late', cf, i, Transfer);
                    }
                }                    
            }
        }     
    } else {
        for (i = Urb->u.Isoch.StartFrame;
             i < Urb->u.Isoch.StartFrame + Urb->u.Isoch.NumberOfPackets;
             i++) {

            if (i <= cf) {
                p = i - Urb->u.Isoch.StartFrame;
                usbdPak = &Urb->u.Isoch.IsoPacket[p];

                if (usbdPak->Status == USBD_STATUS_NOT_SET) {
                    usbdPak->Status = USBD_STATUS_ISO_NA_LATE_USBPORT;

                    LOGENTRY(Transfer->Endpoint, 
                        FdoDeviceObject, LOG_ISO, 'late', cf, i, Transfer);
                }
            }
        }             
    }    
    // initialize the packets 
    
    for (p=0; p< isoTransfer->PacketCount; p++) {
    
        ULONG n;
        
        usbdPak = &Urb->u.Isoch.IsoPacket[p];
        mpPak = &isoTransfer->Packets[p];

        // first Zero the mp packet
        RtlZeroMemory(mpPak, sizeof(*mpPak));

        // each packet has an 'offset' from the start 
        // of the client buffer we need to find the sg
        // entry associated with this packet based on 
        // this 'offset' and get the physical address 
        // for the satrt of the packet

        b0 = USBPORT_GetPhysicalAddressFromOffset(sgList, 
                                                   usbdPak->Offset,
                                                   &b0Idx);
                                                   
        LOGENTRY(NULL, FdoDeviceObject, LOG_ISO, 'ib0=', 
            usbdPak->Offset, b0Idx, p);

        // length is implied by the offset specified in the 
        // usbd packet, the length is the difference between the 
        // current packet start offset and the next packet start 
        // offset.

        if (p == isoTransfer->PacketCount - 1) {
            n = Transfer->Tp.TransferBufferLength;
        } else { 
            n = Urb->u.Isoch.IsoPacket[p+1].Offset;
        }
        mpPak->Length = n - usbdPak->Offset;
        if (highSpeed) {    
            mpPak->FrameNumber = Urb->u.Isoch.StartFrame+p/8;
            mpPak->MicroFrameNumber = p%8;
        } else {
            mpPak->FrameNumber = Urb->u.Isoch.StartFrame+p;
        }            

        // get the sg entry associated with the last byte of the packet
        b1 = USBPORT_GetPhysicalAddressFromOffset(sgList, 
                                                   usbdPak->Offset + 
                                                     mpPak->Length -1,
                                                   &b1Idx);                                                   
       
        LOGENTRY(NULL, FdoDeviceObject, LOG_ISO, 'ib1=', 
            usbdPak->Offset, b1Idx, usbdPak->Offset + mpPak->Length);

        USBPORT_ASSERT(b1Idx - b0Idx < 2);

        if (b0Idx == b1Idx) {                
            // this packet is contained by a single sg entry
            mpPak->BufferPointer0 = b0;
            mpPak->BufferPointer0Length = mpPak->Length;
            mpPak->BufferPointerCount = 1;
            
        } else {
            PTRANSFER_SG_ENTRY32 sg;
            
            // this packet crosses an sg entry...
            mpPak->BufferPointer0 = b0;
            // since this packet bumps in to the end
            // of a page the length is page_size minus
            // phys offset

            mpPak->BufferPointer0Length = 0x1000;
            mpPak->BufferPointer0Length -= (b0.Hw32 & 0xFFF);

            // since we crossed an sg entry on this packet
            // the start address will be the phys address 
            // of the sg entry
            sg = &sgList->SgEntry[b1Idx];
            mpPak->BufferPointer1 = sg->LogicalAddress;
            mpPak->BufferPointer1Length = mpPak->Length - 
                mpPak->BufferPointer0Length;
            
            mpPak->BufferPointerCount = 2;
        }
        
        USBPORT_ASSERT(mpPak->BufferPointerCount != 0);

    }
    
}


VOID
USBPORT_ErrorCompleteIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint, 
    PHCD_TRANSFER_CONTEXT Transfer
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PTRANSFER_URB urb;
    USBD_STATUS usbdStatus;
    PMINIPORT_ISO_TRANSFER isoTransfer;
    ULONG bytesTransferred, p;
    
    ASSERT_TRANSFER(Transfer);
    isoTransfer = Transfer->IsoTransfer;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);
    
    usbdStatus = USBD_STATUS_ISOCH_REQUEST_FAILED;
    urb = Transfer->Urb;
    LOGENTRY(Endpoint, FdoDeviceObject, LOG_ISO, 'cpLi', 0, 
        Transfer, urb); 
    ASSERT_TRANSFER_URB(urb);

    USBPORT_KdPrint((1, "  ISO (USBD_STATUS_ISOCH_REQUEST_FAILED) - packets %d\n",
        isoTransfer->PacketCount));
    // do some conversion on the isoTransfer data
    bytesTransferred = 0;
    urb->u.Isoch.ErrorCount = isoTransfer->PacketCount;
    
    for (p=0; p<isoTransfer->PacketCount; p++) {
    
        urb->u.Isoch.IsoPacket[p].Status = 
            isoTransfer->Packets[p].UsbdStatus;
                
    }

    urb->TransferBufferLength = bytesTransferred;
        
    // insert the transfer on to our
    // 'done list', this riutine initaites 
    // a DPC to complete the transfers
#ifdef USBPERF
    USBPORT_QueueDoneTransfer(Transfer,
                              usbdStatus);
#else
    USBPORT_QueueDoneTransfer(Transfer,
                              usbdStatus);

    USBPORT_SignalWorker(FdoDeviceObject);            
#endif    
}


USBD_STATUS
USBPORT_FlushIsoTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

    called to complete a transfer.

    ** Must be called in the context of PollEndpoint

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PTRANSFER_URB urb;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    ULONG bytesTransferred, p;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);        
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'cpTi', 0, 
        TransferParameters->FrameCompleted, 
        TransferParameters); 

    TRANSFER_FROM_TPARAMETERS(transfer, TransferParameters);        
    ASSERT_TRANSFER(transfer);

    urb = transfer->Urb;
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'cpUi', 0, 
        transfer, urb); 
    ASSERT_TRANSFER_URB(urb);

    transfer->MiniportFrameCompleted = 
        TransferParameters->FrameCompleted;

    // do some conversion on the isoTransfer data
    bytesTransferred = 0;

    urb->u.Isoch.ErrorCount = 0;
    
    for (p=0; p<IsoTransfer->PacketCount; p++) {
    
        bytesTransferred += IsoTransfer->Packets[p].LengthTransferred;

        urb->u.Isoch.IsoPacket[p].Status = 
            IsoTransfer->Packets[p].UsbdStatus;

        // note:
        // in an effort to create some consistency we handle the buffer 
        // underrun case here.  
        // That is:
        //      if the SHORT_XFER_OK flag is set AND
        //      the error is USBD_STATUS_DATA_UNDERRUN
        //      then
        //      ignore the error

        // NOTE: The OHCI controllers report USBD_STATUS_DATA_UNDERRUN
        // for short iso packets

        if (/*urb->TransferFlags & USBD_SHORT_TRANSFER_OK && */
            urb->u.Isoch.IsoPacket[p].Status == USBD_STATUS_DATA_UNDERRUN) {
            urb->u.Isoch.IsoPacket[p].Status = USBD_STATUS_SUCCESS;
            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'igER', 
                    urb->u.Isoch.IsoPacket[p].Status, 
                    transfer, 
                    urb);         
        }            
        
        if (urb->u.Isoch.IsoPacket[p].Status != USBD_STATUS_SUCCESS) {
            urb->u.Isoch.ErrorCount++;
        }

        if (transfer->Direction == ReadData) {                    
            urb->u.Isoch.IsoPacket[p].Length = 
                IsoTransfer->Packets[p].LengthTransferred;
        }        

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'isoP', 
            urb->u.Isoch.IsoPacket[p].Length, 
            urb->u.Isoch.IsoPacket[p].Status, 
            0);

    }

    if (urb->u.Isoch.ErrorCount == 
        IsoTransfer->PacketCount) {
        // all errors set global status in urb
        usbdStatus = USBD_STATUS_ISOCH_REQUEST_FAILED;
    }        

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'isoD', 0, 
        bytesTransferred, urb->u.Isoch.ErrorCount);

    transfer->MiniportBytesTransferred = 
            bytesTransferred;

    return usbdStatus;        
}    


VOID
USBPORTSVC_CompleteIsoTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PMINIPORT_ISO_TRANSFER IsoTransfer
    )
/*++

Routine Description:

    called to complete a transfer.

    ** Must be called in the context of PollEndpoint

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PHCD_TRANSFER_CONTEXT transfer;
    PDEVICE_OBJECT fdoDeviceObject;
    USBD_STATUS usbdStatus;
    ULONG bytesTransferred, p;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);

    fdoDeviceObject = devExt->HcFdoDeviceObject;

    TRANSFER_FROM_TPARAMETERS(transfer, TransferParameters);        
    ASSERT_TRANSFER(transfer);

    SET_FLAG(transfer->Flags, USBPORT_TXFLAG_MPCOMPLETED);
           
    usbdStatus = USBPORT_FlushIsoTransfer(fdoDeviceObject,
                                          TransferParameters,
                                          IsoTransfer);

    // insert the transfer on to our
    // 'done list' and signal the worker
    // thread
#ifdef USBPERF   
    USBPORT_QueueDoneTransfer(transfer,
                              usbdStatus);
#else 
    USBPORT_QueueDoneTransfer(transfer,
                              usbdStatus);
                              
    USBPORT_SignalWorker(devExt->HcFdoDeviceObject);
#endif    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\power.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    power.c

Abstract:

    the power code

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_ComputeRootHubDeviceCaps)
#pragma alloc_text(PAGE, USBPORT_ComputeHcPowerStates)
#endif

// non paged functions
//USBPORT_PdoPowerIrp
//USBPORT_FdoPowerIrp
//USBPORT_SystemPowerState
//USBPORT_DevicePowerState
//USBPORT_PoRequestCompletion
//USBPORT_CancelPendingWakeIrp

#if DBG

PUCHAR
S_State(
    SYSTEM_POWER_STATE S
    )
{
    switch (S) {
    case PowerSystemUnspecified:
        return "SystemUnspecified S?";
    case PowerSystemWorking:
        return "SystemWorking S0";
    case PowerSystemSleeping1:
        return "SystemSleeping1 S1";
    case PowerSystemSleeping2:
        return "SystemSleeping2 S2";
    case PowerSystemSleeping3:
        return "SystemSleeping3 S3";
    case PowerSystemHibernate:
        return "SystemHibernate";
    case PowerSystemShutdown:
        return "SystemShutdown";
    case PowerSystemMaximum:
        return "SystemMaximum";
    }

    return "???";
}

PUCHAR
D_State(
    DEVICE_POWER_STATE D
    )
{
    switch (D) {
    case PowerDeviceUnspecified:
        return "D?";
    case PowerDeviceD0:
        return "D0";
    case PowerDeviceD1:
        return "D1";
    case PowerDeviceD2:
        return "D2";
    case PowerDeviceD3:
        return "D3";
    case PowerDeviceMaximum:
        return "DX";
    }

    return "??";
}

#endif


PHC_POWER_STATE
USBPORT_GetHcPowerState(
    PDEVICE_OBJECT FdoDeviceObject,
    PHC_POWER_STATE_TABLE HcPowerStateTbl,
    SYSTEM_POWER_STATE SystemState
    )
/*++

Routine Description:

    For a given system power state return a pointer to
    the hc power state stored in the device extension.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION devExt;
    PHC_POWER_STATE powerState;
    ULONG i;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    powerState = NULL;

    for (i=0; i<USBPORT_MAPPED_SLEEP_STATES; i++) {

        if (HcPowerStateTbl->PowerState[i].SystemState ==
            SystemState) {

            powerState = &HcPowerStateTbl->PowerState[i];
            break;
        }
    }

    USBPORT_ASSERT(powerState != NULL);

    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'ghcP', 0, powerState, 0);

    return powerState;
}


VOID
USBPORT_ComputeHcPowerStates(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_CAPABILITIES HcDeviceCaps,
    PHC_POWER_STATE_TABLE HcPowerStateTbl
    )
/*++

Routine Description:

    Using the HC capabilities reported by the parent bus compute
    the host controllers power attributes.

    Power attributes are defined as follows:

                                   {     attributes      }
     | SystemState |  DeviceState  |  Powered?  |  Wake? |
     +-------------+---------------+------------+--------+
           S1-S4          D0-D3          Y/N        Y/N

    The table includes entries for every possible system sleep state
    the OS may ask us to enter.

    (S1) PowerSystemSleeping1
    (S2) PowerSystemSleeping2
    (S3) PowerSystemSleeping3
    (S4) PowerSystemHibernate

    We have four possible cases for each sleep state:

             Powered?   Wake?
    case 1      Y         Y
    case 2      N         N
    case 3      Y         N
    *case 4      N         Y

    currently we only support cases 1 & 2 but we recognize all 4
    in the event we need to support them all.
    In reality there exists a lot of case 3 but we currently have
    no way to detect it.



Arguments:

Return Value:

    none

--*/
{
    SYSTEM_POWER_STATE s;
    ULONG i;
    SYSTEM_POWER_STATE systemWake;
    DEVICE_POWER_STATE deviceWake;

    PAGED_CODE();

    systemWake = HcDeviceCaps->SystemWake;
    deviceWake = HcDeviceCaps->DeviceWake;

    // The HC can wake the system for any sleep state lighter (<=)
    // systemWake

    // iniialize the table
    s = PowerSystemSleeping1;

    for (i=0; i<USBPORT_MAPPED_SLEEP_STATES; i++) {

        HcPowerStateTbl->PowerState[i].SystemState = s;
        HcPowerStateTbl->PowerState[i].DeviceState =
            HcDeviceCaps->DeviceState[s];

        // it follows that if the map indicates that the DeviceState
        // is D3 but the system state is still <= SystemWake then the
        // hc is still powered

        if (s <= systemWake) {
            if (HcDeviceCaps->DeviceState[s] == PowerDeviceUnspecified) {
                // for unspecified we go with case 2, ie no power
                // case 2
                HcPowerStateTbl->PowerState[i].Attributes =
                    HcPower_N_Wakeup_N;
            } else {
                // case 1
                HcPowerStateTbl->PowerState[i].Attributes =
                    HcPower_Y_Wakeup_Y;
            }
        } else {
            if (HcDeviceCaps->DeviceState[s] == PowerDeviceD3 ||
                HcDeviceCaps->DeviceState[s] == PowerDeviceUnspecified) {
                // case 2
                HcPowerStateTbl->PowerState[i].Attributes =
                    HcPower_N_Wakeup_N;
            } else {
                //
                // case 3
                HcPowerStateTbl->PowerState[i].Attributes =
                    HcPower_Y_Wakeup_N;
            }
        }

        // 330157
        // disable wake from s4 since we do not support it yet
        //if (s == PowerSystemHibernate) {
        //    HcPowerStateTbl->PowerState[i].Attributes =
        //            HcPower_N_Wakeup_N;
        //}

        s++;
    }

    USBPORT_ASSERT(s == PowerSystemShutdown);
}


VOID
USBPORT_ComputeRootHubDeviceCaps(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    Attempt to create the root hub

    Power Summary:

    <Gloassary>

    Lightest - PowerDeviceD0, PowerSystemWorking
    Deepest - PowerDeviceD3, PowerSystemHibernate

    SystemWake - this is defined to be the 'deepest' System state in which
                 the hardware can wake the system.
    DeviceWake -

    DeviceState[] - map of system states and the corresponding D states
                    these are the states the HW is in for any given
                    System Sleep state.

    HostControllerPowerAttributes - we define our own structure to describe
                    the attributes of a host comtroller -- this allows us to
                    map all possible controller scenarios on to the messed
                    up WDM power rules.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_CAPABILITIES hcDeviceCaps, rhDeviceCaps;
    PDEVICE_EXTENSION rhDevExt, devExt;
    BOOLEAN wakeupSupport;
    SYSTEM_POWER_STATE s;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    hcDeviceCaps = &devExt->DeviceCapabilities;
    rhDeviceCaps = &rhDevExt->DeviceCapabilities;

    // do we wish to support wakeup?

    // if the USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE flag NOT is set
    // then wakeup is disabled and the HC power attributes have been
    // modified to reflect this.

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE)) {
        wakeupSupport = TRUE;
    } else {
        // wakeup is disabled
        USBPORT_KdPrint((1, " USB SYSTEM WAKEUP is Disabled\n"));
        wakeupSupport = FALSE;
    }

#if DBG
    if (wakeupSupport) {
        USBPORT_KdPrint((1, " USB SYSTEM WAKEUP is Supported\n"));
    } else {
        USBPORT_KdPrint((1, " USB SYSTEM WAKEUP is NOT Supported\n"));
    }
#endif

    // clone capabilities from the HC
    RtlCopyMemory(rhDeviceCaps,
                  hcDeviceCaps,
                  sizeof(DEVICE_CAPABILITIES));

    // construct the root hub device capabilities

    // root hub is not removable
    rhDeviceCaps->Removable=FALSE;
    rhDeviceCaps->UniqueID=FALSE;
    rhDeviceCaps->Address = 0;
    rhDeviceCaps->UINumber = 0;

    // for the root hub D2 translates to 'USB suspend'
    // so we always indicate we can wake from D2
    rhDeviceCaps->DeviceWake = PowerDeviceD2;
    rhDeviceCaps->WakeFromD0 = TRUE;
    rhDeviceCaps->WakeFromD1 = FALSE;
    rhDeviceCaps->WakeFromD2 = TRUE;
    rhDeviceCaps->WakeFromD3 = FALSE;

    rhDeviceCaps->DeviceD2 = TRUE;
    rhDeviceCaps->DeviceD1 = FALSE;

    // generate the root hub power capabilities from the
    // HC Power Attributes plus a little magic
    USBPORT_ASSERT(rhDeviceCaps->SystemWake >= PowerSystemUnspecified &&
                   rhDeviceCaps->SystemWake <= PowerSystemMaximum);

    rhDeviceCaps->SystemWake =
        (PowerSystemUnspecified == rhDeviceCaps->SystemWake) ?
        PowerSystemWorking :
        rhDeviceCaps->SystemWake;

    for (s=PowerSystemSleeping1; s<=PowerSystemHibernate; s++) {

        PHC_POWER_STATE hcPowerState;

        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               s);

        if (hcPowerState != NULL) {
            switch (hcPowerState->Attributes) {
            case HcPower_Y_Wakeup_Y:
                rhDeviceCaps->DeviceState[s] = PowerDeviceD2;
                break;
            case HcPower_N_Wakeup_N:
            case HcPower_Y_Wakeup_N:
            case HcPower_N_Wakeup_Y:
                rhDeviceCaps->DeviceState[s] = PowerDeviceD3;
                break;
            }
        }
    }

}


NTSTATUS
USBPORT_PoRequestCompletion(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE PowerState,
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Called when the Device Power State Irp we requested is completed.
    this is where we Call down the systemPowerIrp

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    DevicePowerState - The Dx that we are in/tagetted.

    Context - Driver defined context.

    IoStatus - The status of the IRP.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject = Context;
    NTSTATUS ntStatus = IoStatus->Status;

    // a call to this function basically tells us
    // that we are now in the requested D-state
    // we now finish the whole process by calling
    // down the original SysPower request to our
    // PDO

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((1,
            "PoRequestComplete fdo(%x) MN_SET_POWER DEV(%s)\n",
            fdoDeviceObject, D_State(PowerState.DeviceState)));

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'PwCp', ntStatus,
             devExt->CurrentDevicePowerState, PowerState.DeviceState);

    // note that if the SetD0 has failed we do not attempt
    // to re-start the controller

    if (NT_SUCCESS(ntStatus)) {

        if (PowerState.DeviceState == PowerDeviceD0) {

#ifdef XPSE
            {
            LARGE_INTEGER t, dt;
            // compute time to D0
            KeQuerySystemTime(&t);
            dt.QuadPart = t.QuadPart - devExt->Fdo.D0ResumeTimeStart.QuadPart;

            devExt->Fdo.D0ResumeTime = (ULONG) (dt.QuadPart/10000);

            KeQuerySystemTime(&devExt->Fdo.ThreadResumeTimeStart);

            USBPORT_KdPrint((1, "  D0ResumeTime %d ms %x %x\n",
                devExt->Fdo.D0ResumeTime,
                t.HighPart, t.LowPart));
            }
#endif

            // defer start to our worker thread or workitem
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_NEED_SET_POWER_D0);
            MP_FlushInterrupts(devExt);

            if (USBPORT_IS_USB20(devExt)) {
                MP_TakePortControl(devExt);
            }

            USBPORT_SignalWorker(fdoDeviceObject);
            // enable sligthtly faster completion of S irps
            USBPORT_QueuePowerWorkItem(fdoDeviceObject);
            // on completion of this function the controller is
            // in D0, we may not have powered up yet though.
            devExt->CurrentDevicePowerState = PowerDeviceD0;

        } else {

            // we should not receive another power irp until
            // we make a call to PoStartNextPowerIrp so there
            // is no protection here.
            irp = devExt->SystemPowerIrp;
            devExt->SystemPowerIrp = NULL;
            USBPORT_ASSERT(irp != NULL);

            IoCopyCurrentIrpStackLocationToNext(irp);
            PoStartNextPowerIrp(irp);
            DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, irp);
            PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                         irp);

            devExt->CurrentDevicePowerState = PowerState.DeviceState;

        }
    } else {

        // try to complete the irp with an error but don't attempt
        // to power the bus
        irp = devExt->SystemPowerIrp;
        devExt->SystemPowerIrp = NULL;
        USBPORT_ASSERT(irp != NULL);

        IoCopyCurrentIrpStackLocationToNext(irp);
        PoStartNextPowerIrp(irp);
        DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, irp);

        // According to adriano 'S IRP should be immediately completed with
        // the same status as the D IRP in the failure case'
        // Since the method of handling this is not documented anywhere we will
        // go with what Adrian says.
        //
        // The fact that this request has failed will probably cause other
        // complaints

        irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(irp,
                          IO_NO_INCREMENT);
        //PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
        //             irp);

        // set the system irp status
        // note that the current power state is now undefined

    }

    // Note that the status returned here does not matter, this routine
    // is called by the kernel (PopCompleteRequestIrp) when the irp
    // completes to PDO and this function ignores the returned status.
    // PopCompleteRequestIrp also immediatly frees the irp so we need
    // take care not to reference it after this routine has run.

    return ntStatus;
}


NTSTATUS
USBPORT_FdoSystemPowerState(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Handle SystemPowerState Messages for the HC FDO

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    POWER_STATE powerState;
    SYSTEM_POWER_STATE requestedSystemState;
    PHC_POWER_STATE hcPowerState;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    USBPORT_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    USBPORT_ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

    requestedSystemState = irpStack->Parameters.Power.State.SystemState;

    USBPORT_KdPrint((1,
            "MJ_POWER HC fdo(%x) MN_SET_POWER SYS(%s)\n",
            FdoDeviceObject, S_State(requestedSystemState)));

    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'RspS', 0,
        FdoDeviceObject, requestedSystemState);

    // ** begin special case
    // OS may send us a power irps even if we are not 'started'. In this
    // case we just pass them on with 'STATUS_SUCCESS' since we don't
    // really need to do anything.

     if (!TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED)) {
        // we should probably be in an 'Unspecified' power state.
        ntStatus = STATUS_SUCCESS;
        goto USBPORT_FdoSystemPowerState_Done;
     }
     // ** end special case

    // compute the appropriate D-state

    // remember the last 'sleep' system state we entered
    // for debugging
    if (requestedSystemState != PowerSystemWorking) {
        devExt->Fdo.LastSystemSleepState = requestedSystemState;
    }

    switch (requestedSystemState) {
    case PowerSystemWorking:
        //
        // go to 'ON'
        //
        powerState.DeviceState = PowerDeviceD0;
#ifdef XPSE
        KeQuerySystemTime(&devExt->Fdo.S0ResumeTimeStart);
#endif
        break;

    case PowerSystemShutdown:

        USBPORT_KdPrint((1, " >Shutdown HC Detected\n"));

        // For this driver this will always map to D3.
        //
        // this driver will only run on Win98gold or Win98se
        // to support USB2 controllers that don't have Legacy
        // BIOS.
        //
        // For Win98 Millenium or Win2k it doesn't matter if
        // the controllers have a BIOS since we never hand
        // control back to DOS.

        // not sure yet if it is legitimate to 'Wake' from shutdown
        // or how we are supposed to handle this. Some BIOSes Falsely
        // report that they can do this.

        powerState.DeviceState = PowerDeviceD3;

        USBPORT_TurnControllerOff(FdoDeviceObject);

        break;

    case PowerSystemHibernate:

        USBPORT_KdPrint((1, " >Hibernate HC Detected\n"));
//        powerState.DeviceState = PowerDeviceD3;
//
//        USBPORT_TurnControllerOff(FdoDeviceObject);
//        break;

    case PowerSystemSleeping1:
    case PowerSystemSleeping2:
    case PowerSystemSleeping3:

        {
        PDEVICE_EXTENSION rhDevExt;

        USBPORT_ASSERT(devExt->Fdo.RootHubPdo != NULL);
        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);

        USBPORT_KdPrint((1, " >Sleeping Detected\n"));
        //
        // Take action based on what happens to the controller
        // in the requested S state.  This minimizes the chance
        // of confusing the Hub driver or other USB devices/drivers.
        // It also speeds up the resume process.

        // get our power info summary
        hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                               &devExt->Fdo.HcPowerStateTbl,
                                               requestedSystemState);
        // keep lint tools happy.
        if (hcPowerState == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        // get the current power state of the root hub
        if (rhDevExt->CurrentDevicePowerState == PowerDeviceD2 ||
            rhDevExt->CurrentDevicePowerState == PowerDeviceD1) {

            USBPORT_ASSERT(hcPowerState->Attributes == HcPower_Y_Wakeup_Y ||
                           hcPowerState->Attributes == HcPower_Y_Wakeup_N);

            // take action on the controller
            USBPORT_SuspendController(FdoDeviceObject);

            // it is 'impure' for the controller to interrupt while in a
            // low power state so if we suspended it we disable interrupts now.
            // The presence of a wake IRP should enable the PME that wakes
            // the system.
            // **We disable here so that we don't take a resume interrupt from
            // the controller while going into suspend

            if (hcPowerState->DeviceState != PowerDeviceD0) {
                MP_DisableInterrupts(FdoDeviceObject, devExt);
            }

            // select the D state for the HC
            powerState.DeviceState = hcPowerState->DeviceState;


            // if the root hub is enabled for wakeup and this this
            // system state supports it then mark the controller as
            // 'enabled' for wake.

            if (USBPORT_RootHubEnabledForWake(FdoDeviceObject) &&
                hcPowerState->Attributes == HcPower_Y_Wakeup_Y) {

                DEBUG_BREAK();
                SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_WAKE_ENABLED);

                if (hcPowerState->DeviceState == PowerDeviceD0) {
                    USBPORT_ArmHcForWake(FdoDeviceObject);
                    USBPORT_Wait(FdoDeviceObject, 100);
                }
            }

        } else {

            // if the controller remains powered then it is optimal
            // to 'suspend' otherwise we must turn it off

            // always 'suspend' the USB 2 controller, this will hopefuly
            // keep us from restting the CC in the case where a device
            // on the CC is enabled for wake for a the 20 controller is
            // not

            if ((hcPowerState->Attributes == HcPower_Y_Wakeup_Y ||
                 hcPowerState->Attributes == HcPower_Y_Wakeup_N ||
                 USBPORT_IS_USB20(devExt)) &&
                !TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_REMOVED)) {

                USBPORT_SuspendController(FdoDeviceObject);
                powerState.DeviceState = hcPowerState->DeviceState;

                if (USBPORT_IS_USB20(devExt) &&
                    powerState.DeviceState == PowerDeviceUnspecified) {
                    // if no state specified go to D3
                    powerState.DeviceState = PowerDeviceD3;
                }

                // clear the IRQ enabled flag since it is invalid for
                // the hardware to interrupt in any state but D0

                // it is 'impure' for the controller to interrupt while in a
                // low power state so if we suspended it we disable interrupts now.
                // The presence of a wake IRP should enable the PME that wakes
                // the system.
                // **We disable here so that we don't take a resume interrupt from
                // the controller while going into suspend

                MP_DisableInterrupts(FdoDeviceObject, devExt);

            } else {

                USBPORT_TurnControllerOff(FdoDeviceObject);
                powerState.DeviceState = PowerDeviceD3;

            }
        }

        } // PowerSystemSleepingX
        break;

    default:
        // This is the case where the requested system state is unkown
        // to us. It not clear what to do here.
        // Vince sez try to ignore it so we will
        powerState.DeviceState = devExt->CurrentDevicePowerState;
        //powerState.DeviceState = PowerDeviceD3;
        //USBPORT_TurnControllerOff(FdoDeviceObject);
        DEBUG_BREAK();
    }

    //
    // now based on the D state request a Power irp
    // if necessary
    //

    //
    // are we already in this state?
    //
    // Note: if we get a D3 request before we are started
    // we don't need to pass the irp down to turn us off
    // we consider the controller initially off until we
    // get start.
    //
    if (devExt->CurrentDevicePowerState != powerState.DeviceState) {

        // No,
        // now allocate another irp and use PoCallDriver
        // to send it to ourselves
        IoMarkIrpPending(Irp);

        // remember the system power irp, we should
        // not receive another power irp until we
        // make a call to PoStartNextPowerIrp so there
        // is no protection here.
        USBPORT_ASSERT(devExt->SystemPowerIrp == NULL);
        devExt->SystemPowerIrp = Irp;

        USBPORT_KdPrint((1, " >Requesting HC D-State - %s\n",
            D_State(powerState.DeviceState)));

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'RqPw', FdoDeviceObject,
                 devExt->CurrentDevicePowerState, powerState.DeviceState);

#ifdef XPSE
        KeQuerySystemTime(&devExt->Fdo.D0ResumeTimeStart);
#endif

        ntStatus =
            PoRequestPowerIrp(devExt->Fdo.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBPORT_PoRequestCompletion,
                              FdoDeviceObject,
                              NULL);

        // hardcode STATUS_PENDING so that it is is returned
        // by the Dispatch routine

        // can we rely on what PoRequestPowerIrp returns?
        ntStatus = STATUS_PENDING;

    } else {

        // Yes,
        // We are already in the requested D state
        // just pass this irp along

        if (powerState.DeviceState == PowerDeviceD0) {
            MP_EnableInterrupts(devExt);
        }
        ntStatus = STATUS_SUCCESS;

    }

USBPORT_FdoSystemPowerState_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_FdoDevicePowerState(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Handle DevicePowerState Messages for the HC FDO

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

    returning STATUS_PENDING indicates that the Irp should
    not be called down to the PDO yet.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    POWER_STATE powerState;
    DEVICE_POWER_STATE requestedDeviceState;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    USBPORT_ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    USBPORT_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    requestedDeviceState = irpStack->Parameters.Power.State.SystemState;

    USBPORT_KdPrint((1,
            "MJ_POWER HC fdo(%x) MN_SET_POWER DEV(%s)\n",
            FdoDeviceObject, D_State(requestedDeviceState)));

    switch (requestedDeviceState) {
    case PowerDeviceD0:
        // we cannot enter D0 until we pass the power irp
        // down to our parent BUS. return success here - we
        // will turn the controller on from the completion
        // routine of the original request for this power
        // irp
        ntStatus = STATUS_SUCCESS;
        break;

    case PowerDeviceD1:
    case PowerDeviceD2:
    case PowerDeviceD3:
        // we took action when we received the SystemPowerMessage
        // because thats when we know what the state of the HW will be.

        // it is 'impure' for the controller to interrupt while in a
        // low power state so if we suspended it we disable interrupts now.
        // The presence of a wake IRP should enable the PME that wakes
        // the system.
        MP_DisableInterrupts(FdoDeviceObject, devExt);

        //
        if (USBPORT_IS_USB20(devExt)) {
            PDEVICE_RELATIONS devR;
            // set magic count to number of CCs plus usb2 controller
            devR = USBPORT_FindCompanionControllers(FdoDeviceObject,
                                                    FALSE,
                                                    FALSE);
            devExt->Fdo.DependentControllers = 0;
            if (devR) {
                devExt->Fdo.DependentControllers = devR->Count + 1;
                FREE_POOL(FdoDeviceObject, devR);
            }
        }

        // if wakeup is enabled (on the root hub PDO) then we will
        // enable on the platform before entering the low
        // power state.
        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_WAKE_ENABLED)) {
             USBPORT_ArmHcForWake(FdoDeviceObject);
        }

        ntStatus = STATUS_SUCCESS;
        break;

    case PowerDeviceUnspecified:
        // for unspecified we will turn the HW off -- I'm not sure we
        // will ever see this since the D messages originate from us.
        USBPORT_TurnControllerOff(FdoDeviceObject);
        ntStatus = STATUS_SUCCESS;
        break;

    default:
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}


NTSTATUS
USBPORT_FdoPowerIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the FDO for the host
    controller.

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'fPow', irpStack->MinorFunction,
        FdoDeviceObject, devExt->CurrentDevicePowerState);
    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'fpow',
             irpStack->Parameters.Others.Argument1,     // WAIT_WAKE: PowerState
             irpStack->Parameters.Others.Argument2,     // SET_POWER: Type
             irpStack->Parameters.Others.Argument3);    // SET_POWER: State

    // map system state to D state
    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:

        USBPORT_KdPrint((1,
            "MJ_POWER HC fdo(%x) MN_WAIT_WAKE\n",
            FdoDeviceObject));
        ntStatus = USBPORT_ProcessHcWakeIrp(FdoDeviceObject, Irp);
        goto USBPORT_FdoPowerIrp_Done;

        break;

    case IRP_MN_SET_POWER:

        if (irpStack->Parameters.Power.Type == SystemPowerState) {
            ntStatus = USBPORT_FdoSystemPowerState(FdoDeviceObject, Irp);
        } else {
            ntStatus = USBPORT_FdoDevicePowerState(FdoDeviceObject, Irp);
        }

        if (ntStatus == STATUS_PENDING) {
            // we deferred to a completion routine
            // returned STATUS_PENDING and bail.

            goto USBPORT_FdoPowerIrp_Done;
        }

        break;

    case IRP_MN_QUERY_POWER:

        // we succeed all requests to enter low power
        // states for the HC fdo
        Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'QpFD', 0, 0, ntStatus);

        USBPORT_KdPrint((1,
            "MJ_POWER HC fdo(%x) MN_QUERY_POWER\n",
            FdoDeviceObject));
        break;

    default:

        USBPORT_KdPrint((1,
            "MJ_POWER HC fdo(%x) MN_%d not handled\n",
            FdoDeviceObject,
            irpStack->MinorFunction));

    } /* irpStack->MinorFunction */


    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // All PNP_POWER POWER messages get passed to the
    // top of the PDO stack we attached to when loaded
    //
    // In some cases we finish processing in a completion
    // routine
    //

    // pass on to our PDO
    DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, Irp);
    PoStartNextPowerIrp(Irp);
    ntStatus =
        PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                     Irp);

USBPORT_FdoPowerIrp_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_PdoPowerIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for Power Irps sent to the PDO for the root hub.

    NOTE:
        irps sent to the PDO are always completed by the bus driver

Arguments:

    DeviceObject - Pdo for the root hub

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    // use whatever status is in the IRP by default
    ntStatus = Irp->IoStatus.Status;

    // PNP messages for the PDO created for the root hub
    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'pPow',
        irpStack->MinorFunction, PdoDeviceObject, ntStatus);
    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'ppow',
             irpStack->Parameters.Others.Argument1,     // WAIT_WAKE: PowerState
             irpStack->Parameters.Others.Argument2,     // SET_POWER: Type
             irpStack->Parameters.Others.Argument3);    // SET_POWER: State

    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
         USBPORT_KdPrint((1,
            "MJ_POWER RH pdo(%x) MN_WAIT_WAKE\n",
            PdoDeviceObject));

        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE)) {

            KIRQL irql;
            PDRIVER_CANCEL cr;

            // we only support one wait_wake irp pending
            // in the root hub -- basically we have a pending
            // irp table with one entry

            ACQUIRE_WAKEIRP_LOCK(fdoDeviceObject, irql);

            cr = IoSetCancelRoutine(Irp, USBPORT_CancelPendingWakeIrp);
            USBPORT_ASSERT(cr == NULL);

            if (Irp->Cancel &&
                IoSetCancelRoutine(Irp, NULL)) {

                // irp was canceled and our cancel routine
                // did not run
                RELEASE_WAKEIRP_LOCK(fdoDeviceObject, irql);

                ntStatus = STATUS_CANCELLED;

                // no postartnextpowerIrp for waitwake
                goto USBPORT_PdoPowerIrp_Complete;

            } else {

                // cancel routine is set, if irp is canceled
                // the cancel routine will stall on the
                // WAKE_IRP_LOCK

                if (rhDevExt->Pdo.PendingWaitWakeIrp == NULL) {

                    // keep the irp in our table, we take no
                    // other action until we actully enter a
                    // low power state.

                    IoMarkIrpPending(Irp);
                    rhDevExt->Pdo.PendingWaitWakeIrp = Irp;
                    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'pWWi',
                        Irp, 0, 0);

                    ntStatus = STATUS_PENDING;

                    RELEASE_WAKEIRP_LOCK(fdoDeviceObject, irql);

                    goto USBPORT_PdoPowerIrp_Done;

                } else {

                    // we already have a wake irp, complete this
                    // one with STATUS_BUSY.
                    // note that since it is not in our table if
                    // the cancel routine is running (ie stalled
                    // on the WAKEIRP_LOCK it will ignore the irp
                    // when we release the lock.

                    if (IoSetCancelRoutine(Irp, NULL) != NULL) {
                        ntStatus = STATUS_DEVICE_BUSY;
                    } else {

                        // let the cancel routine complete it.
                        RELEASE_WAKEIRP_LOCK(fdoDeviceObject, irql);
                        goto USBPORT_PdoPowerIrp_Done;
                    }
                }

                RELEASE_WAKEIRP_LOCK(fdoDeviceObject, irql);
            }

        } else {
            ntStatus = STATUS_NOT_SUPPORTED;
            // no postartnextpowerIrp for waitwake
            goto USBPORT_PdoPowerIrp_Complete;
        }
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'RqrP', 0, 0, ntStatus);

        USBPORT_KdPrint((1,
            "MJ_POWER RH pdo(%x) MN_QUERY_POWER\n",
            PdoDeviceObject));
        break;

    case IRP_MN_SET_POWER:

        LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'RspP', 0, 0,
            irpStack->Parameters.Power.Type);

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:

            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'RspS', 0, 0,
                irpStack->Parameters.Power.Type);

            //
            // since the fdo driver for the root hub pdo is our own
            // hub driver and it is well behaved, we don't expect to see
            // a system message where the power state is still undefined
            //
            // we just complete this with success
            //
            ntStatus = STATUS_SUCCESS;

            USBPORT_KdPrint((1,
                "MJ_POWER RH pdo(%x) MN_SET_POWER SYS(%s))\n",
                PdoDeviceObject,
                S_State(irpStack->Parameters.Power.State.SystemState)));

            break;

        case DevicePowerState:

            {
            DEVICE_POWER_STATE deviceState =
                irpStack->Parameters.Power.State.DeviceState;

            USBPORT_KdPrint((1,
                "MJ_POWER RH pdo(%x) MN_SET_POWER DEV(%s)\n",
                PdoDeviceObject,
                D_State(deviceState)));

            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'RspD', deviceState, 0,
                irpStack->Parameters.Power.Type);

            // Handle D states for the ROOT HUB Pdo:
            //
            // NOTE:
            // if the root hub is placed in D3 then it is considered OFF.
            //
            // if the root hub is placed in D2 or D1 then it is 'suspended',
            // the hub driver should not do this unless all the ports have
            // been selectively suspended first
            //
            // if the root hub is placed in D0 it is on
            //

            // We are not required to take any action here, however
            // this is where 'selective suspend' of the bus is handled
            //
            // For D1 - D3 we can tweak the host controller, ie stop
            // the schedule disable ints, etc. since it won't be in use
            // while the root hub PDO is suspended.
            //
            // Whatever we do to the controller here we need to be able to
            // recognize resume signalling.

            // assume success
            ntStatus = STATUS_SUCCESS;

            switch (deviceState) {

            case PowerDeviceD0:
                // re-activate controller if idle

                if (devExt->CurrentDevicePowerState != PowerDeviceD0) {
                    // trap the condition in case this is our bug
                    USBPORT_PowerFault(fdoDeviceObject,
                           "controller not powered");

                    // fail the request
                    ntStatus = STATUS_UNSUCCESSFUL;
                } else {

                    while (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_NEED_SET_POWER_D0)) {
                        // wait for the driver thread to finsih
                        // D0 processing
                        USBPORT_Wait(fdoDeviceObject, 10);
                    }

                    USBPORT_ResumeController(fdoDeviceObject);
                    rhDevExt->CurrentDevicePowerState = deviceState;

//662596
                    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK) &&
                        USBPORT_IS_USB20(devExt)) {

                        USBPORT_KdPrint((1, " power 20 (release)\n"));
                        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK);
                        KeReleaseSemaphore(&devExt->Fdo.CcLock,
                                           LOW_REALTIME_PRIORITY,
                                           1,
                                           FALSE);
                    }
//662596

                    USBPORT_CompletePdoWaitWake(fdoDeviceObject);

                    // if we have an idle irp, complete it now
                    USBPORT_CompletePendingIdleIrp(PdoDeviceObject);
                }
                break;

            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:
                // suspend/idle the controller

                // The controller is only turned off and on by power
                // action to the FDO, suspend and resume are tied
                // to the root hub PDO.
                USBPORT_SuspendController(fdoDeviceObject);
                rhDevExt->CurrentDevicePowerState = deviceState;
                break;

            case PowerDeviceUnspecified:
                // do nothing
                break;
            }

            }
            break;
        }
        break;

    default:
        //
        // default behavior for an unhandled Power irp is to return the
        // status currently in the irp
        // is this true for power?

        USBPORT_KdPrint((1,
            "MJ_POWER RH pdo(%x) MN_%d not handled\n",
            PdoDeviceObject,
            irpStack->MinorFunction));

    } /* switch, POWER minor function */


    // NOTE: for some reason we don't call PoStartnextPowerIrp for
    // WaitWake Irps -- I guess they are not power irps
    PoStartNextPowerIrp(Irp);

USBPORT_PdoPowerIrp_Complete:

    USBPORT_CompleteIrp(PdoDeviceObject,
                        Irp,
                        ntStatus,
                        0);

USBPORT_PdoPowerIrp_Done:

    return ntStatus;
}


BOOLEAN
USBPORT_RootHubEnabledForWake(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    True if the root hub has been enabled for wake via
    a waitwake irp.

--*/
{
    BOOLEAN wakeEnabled;
    PDEVICE_EXTENSION rhDevExt, devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    ACQUIRE_WAKEIRP_LOCK(FdoDeviceObject, irql);

    wakeEnabled = rhDevExt->Pdo.PendingWaitWakeIrp != NULL ? TRUE: FALSE;

    RELEASE_WAKEIRP_LOCK(FdoDeviceObject, irql);

    return wakeEnabled;
}


VOID
USBPORT_CancelPendingWakeIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

    Handle Cancel for the root hub wake irp

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    // release cancel spinlock immediatly,
    // we are protected by the WAKEIRP_LOCK
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'cnWW', fdoDeviceObject, CancelIrp, 0);

    ACQUIRE_WAKEIRP_LOCK(fdoDeviceObject, irql);

    USBPORT_ASSERT(rhDevExt->Pdo.PendingWaitWakeIrp == CancelIrp);
    rhDevExt->Pdo.PendingWaitWakeIrp = NULL;

    RELEASE_WAKEIRP_LOCK(fdoDeviceObject, irql);

    USBPORT_CompleteIrp(PdoDeviceObject,
                        CancelIrp,
                        STATUS_CANCELLED,
                        0);

}


VOID
USBPORT_CancelPendingIdleIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP CancelIrp
    )
/*++

Routine Description:

    Handle Cancel for the root hub wake irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    // release cancel spinlock immediatly,
    // we are protected by the IDLEIRP_LOCK
    IoReleaseCancelSpinLock(CancelIrp->CancelIrql);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'cnIR', fdoDeviceObject, CancelIrp, 0);

    ACQUIRE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    USBPORT_ASSERT(rhDevExt->Pdo.PendingIdleNotificationIrp == CancelIrp);
    rhDevExt->Pdo.PendingIdleNotificationIrp = NULL;
    CLEAR_PDO_FLAG(rhDevExt, USBPORT_PDOFLAG_HAVE_IDLE_IRP);

    RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    USBPORT_CompleteIrp(PdoDeviceObject,
                        CancelIrp,
                        STATUS_CANCELLED,
                        0);

}


VOID
USBPORT_TurnControllerOff(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    When we say OFF we mean OFF.

    This is similar to a stop -- the mniport does not
    know the difference.  The port however does and
    does not free the miniports resources

    This function may be called multiple times ie even
    if controller is already off with no ill effects.

Arguments:

    DeviceObject - DeviceObject of the controller to turn off

Return Value:

    this is NON FAILABLE.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF)) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'Coff', 0, 0, 0);

        USBPORT_KdPrint((1, " >Turning Controller OFF\n"));
        DEBUG_BREAK();

        // tell the DM tiner not to poll the controller
        USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
        USBPORT_RELEASE_DM_LOCK(devExt, irql);

        if (TEST_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED)) {

            MP_DisableInterrupts(FdoDeviceObject, devExt);
            CLEAR_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED);

            MP_StopController(devExt, TRUE);
        }

        USBPORT_NukeAllEndpoints(FdoDeviceObject);

        // Off overrides suspended
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED);
        CLEAR_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_SUSPENDED);

        USBPORT_AcquireSpinLock(FdoDeviceObject,
                                &devExt->Fdo.CoreFunctionSpin, &irql);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF);
        USBPORT_ReleaseSpinLock(FdoDeviceObject,
                                &devExt->Fdo.CoreFunctionSpin, irql);
    }
}


VOID
USBPORT_RestoreController(
     PDEVICE_OBJECT FdoDeviceObject
     )

/*++

Routine Description:

    Turns the controller back on to the 'suspended' state after a
    power event.

Arguments:

    DeviceObject - DeviceObject of the controller to turn off

Return Value:

    none.

--*/

{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    PIRP irp;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'REST', devExt->SystemPowerIrp, 0, 0);

    // call down the orginal system Power request

    // no protection since we haven't
    // called PoStartNextPowerIrp
    irp = devExt->SystemPowerIrp;
    devExt->SystemPowerIrp = NULL;

    // we are now in D0, we must set the flag here
    // because the PoCallDriver will initiate the
    // power up for the root hub which checks the
    // power state of the controller.
    devExt->CurrentDevicePowerState = PowerDeviceD0;
    MP_EnableInterrupts(devExt);

    // we may not have a system power irp if the power
    // up requested originated from wake completion so
    // in this case we don't need to cal it down.
    if (irp != NULL) {
        IoCopyCurrentIrpStackLocationToNext(irp);
        PoStartNextPowerIrp(irp);
        DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, irp);
        PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                     irp);
    }

}


VOID
USBPORT_TurnControllerOn(
     PDEVICE_OBJECT FdoDeviceObject
     )

/*++

Routine Description:

    Similar to start -- but we already have our resources.
    NOTE that the miniport activates as if it the system
    was booted normally.

    We only get here after the Set D0 request has been passed
    to the parent bus.

Arguments:

    DeviceObject - DeviceObject of the controller to turn off

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION devExt;
    PHC_RESOURCES hcResources;
    USB_MINIPORT_STATUS mpStatus;
    PIRP irp;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    hcResources = &devExt->Fdo.HcResources;

    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'C_on', 0, 0, 0);

    DEBUG_BREAK();

     // zero the controller extension
    RtlZeroMemory(devExt->Fdo.MiniportDeviceData,
                  devExt->Fdo.MiniportDriver->RegistrationPacket.DeviceDataSize);

    // zero miniport common buffer
    RtlZeroMemory(hcResources->CommonBufferVa,
                  REGISTRATION_PACKET(devExt).CommonBufferBytes);

    // attempt to re-start the miniport
    MP_StartController(devExt, hcResources, mpStatus);
    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'mpRS', mpStatus, 0, 0);

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // controller started, set flag and begin passing
        // interrupts to the miniport
        SET_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED);
        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'rIRQ', mpStatus, 0, 0);
        MP_EnableInterrupts(devExt);

        USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_FAIL_URBS);
        USBPORT_RELEASE_DM_LOCK(devExt, irql);

    } else {
        // failure on re-start?

        TEST_TRAP();
    }

    // we are now in D0,
    //
    // since we don't hook the completion of the
    // system power irp we will consider ourselves
    // on at this point since we have already received
    // the D0 completion.
    devExt->CurrentDevicePowerState = PowerDeviceD0;
    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF);

    // call down the orginal system Power request

    // no protection since we haven't
    // called PoStartNextPowerIrp
    irp = devExt->SystemPowerIrp;
    devExt->SystemPowerIrp = NULL;

    // we may not have a system power irp if the power
    // up requested originated from wake completion so
    // in this case we don't need to cal it down.
    if (irp != NULL) {
        IoCopyCurrentIrpStackLocationToNext(irp);
        PoStartNextPowerIrp(irp);
        DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, irp);
        PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                     irp);
    }
}


VOID
USBPORT_SuspendController(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Suspends the USB Host controller

Arguments:

    DeviceObject - DeviceObject of the controller to turn off

Return Value:

    this is NON FAILABLE.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // There should be no transfers on the HW at time of suspend.
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_FAIL_URBS);

    USBPORT_FlushController(FdoDeviceObject);

    // Our job here is to 'idle' controller and twiddle the
    // appropriate bits to allow it to recognize resume signalling

    USBPORT_ASSERT(!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF));

    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'Csus', 0, 0, 0);

        USBPORT_KdPrint((1, " >SUSPEND controller\n"));
        DEBUG_BREAK();

        // tell the DM timer not to poll the controller
        USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
        USBPORT_RELEASE_DM_LOCK(devExt, irql);

        if (TEST_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED)) {

            SET_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_SUSPENDED);

            // introduce a 10ms wait here to allow any
            // port suspends to finish
            USBPORT_Wait(FdoDeviceObject, 10);
// BUGBUG HP ia64 fix
            // we cannot suspend until we finish notifying the companions
            // that it is OK to start

            if (USBPORT_IS_USB20(devExt)) {

                // we cannot suspend until we finish notifying the companions
                // that it is OK to start

                InterlockedDecrement(&devExt->Fdo.PendingRhCallback);
                while (devExt->Fdo.PendingRhCallback) {
                    USBPORT_Wait(FdoDeviceObject, 10);
                }

                // reset the counter for the next time through
                devExt->Fdo.PendingRhCallback = 1;

                KeWaitForSingleObject(&devExt->Fdo.CcLock,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK);
            }

            MP_SuspendController(devExt);

            if (USBPORT_IS_USB20(devExt)) {
                CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK);
                KeReleaseSemaphore(&devExt->Fdo.CcLock,
                                   LOW_REALTIME_PRIORITY,
                                   1,
                                   FALSE);
            }


        }

        USBPORT_AcquireSpinLock(FdoDeviceObject,
                                &devExt->Fdo.CoreFunctionSpin, &irql);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED);

        USBPORT_ReleaseSpinLock(FdoDeviceObject,
                                &devExt->Fdo.CoreFunctionSpin, irql);
    }

}


VOID
USBPORT_ResumeController(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Suspends the USB Host controller

Arguments:

    DeviceObject - DeviceObject of the controller to turn off

Return Value:

    this is NON FAILABLE.

--*/

{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'Cres', 0, 0, 0);

        USBPORT_KdPrint((1, " >RESUME controller\n"));
        DEBUG_BREAK();

        USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_FAIL_URBS);
        USBPORT_RELEASE_DM_LOCK(devExt, irql);

        USBPORT_ASSERT(!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF));
        if (TEST_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_SUSPENDED)) {

            USB_MINIPORT_STATUS mpStatus;

            CLEAR_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_SUSPENDED);

            MP_ResumeController(devExt, mpStatus);

            if (mpStatus != USBMP_STATUS_SUCCESS) {

                USBPORT_KdPrint((1, " >controller failed resume, re-start\n"));

                USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
                SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
                USBPORT_RELEASE_DM_LOCK(devExt, irql);

                MP_DisableInterrupts(FdoDeviceObject, devExt);
                MP_StopController(devExt, TRUE);
                USBPORT_NukeAllEndpoints(FdoDeviceObject);

                // zero the controller extension
                RtlZeroMemory(devExt->Fdo.MiniportDeviceData,
                              devExt->Fdo.MiniportDriver->RegistrationPacket.DeviceDataSize);

                // zero miniport common buffer
                RtlZeroMemory(devExt->Fdo.HcResources.CommonBufferVa,
                              REGISTRATION_PACKET(devExt).CommonBufferBytes);

                devExt->Fdo.HcResources.Restart = TRUE;
                MP_StartController(devExt, &devExt->Fdo.HcResources, mpStatus);
                devExt->Fdo.HcResources.Restart = FALSE;
                if (mpStatus == USBMP_STATUS_SUCCESS) {
                    // don't need to enable interrupts if start failed
                    MP_EnableInterrupts(devExt);

                    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC)) {
                        // if this is a CC then power the ports here
                        USBPORT_KdPrint((1, " >power CC ports\n"));

                        USBPORT_RootHub_PowerAndChirpAllCcPorts(
                            FdoDeviceObject);
                    }

                }
                USBPORT_ACQUIRE_DM_LOCK(devExt, irql);
                CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SKIP_TIMER_WORK);
                CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_FAIL_URBS);
                USBPORT_RELEASE_DM_LOCK(devExt, irql);

            }

            // wait 100 after bus resume before allowing drivers to talk
            // to the device.  Unfortuantely many USB devices are busted
            // and will not respond if accessed immediately after resume.
            USBPORT_Wait(FdoDeviceObject, 100);
        }

        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED);
    }
}


VOID
USBPORT_DoIdleNotificationCallback(
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

   Our mission here is to do the 'IdleNotification' callback if we have
   an irp.  The trick is to synchronize the callback with the cancel
   routine ie we don't want the hub driver to cancel the irp and unload
   while we are calling it back.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    KIRQL irql;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // cancel routine will stall here,
    // if cancel is running we will stall here
    ACQUIRE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    // remove the irp from the table so that the
    // cancel routine cannot find it
    irp = rhDevExt->Pdo.PendingIdleNotificationIrp;
    rhDevExt->Pdo.PendingIdleNotificationIrp = NULL;

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'idCB', irp, 0, 0);

    RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    // do the callback if we have an irp

    if (irp != NULL) {
        idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
            IoGetCurrentIrpStackLocation(irp)->\
                Parameters.DeviceIoControl.Type3InputBuffer;


        USBPORT_ASSERT(idleCallbackInfo && idleCallbackInfo->IdleCallback);

        if (idleCallbackInfo && idleCallbackInfo->IdleCallback) {
            USBPORT_KdPrint((1, "-do idle callback\n"));
            // the hub driver expects this to happen at passive level
            ASSERT_PASSIVE();
            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'doCB', irp, 0, 0);

            idleCallbackInfo->IdleCallback(idleCallbackInfo->IdleContext);
        }

        // put the irp back in the table, if the cancel routine
        // has run the IRP will be marked canceled

        ACQUIRE_IDLEIRP_LOCK(fdoDeviceObject, irql);

        if (irp->Cancel) {

            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'caCB', irp, 0, 0);

            CLEAR_PDO_FLAG(rhDevExt, USBPORT_PDOFLAG_HAVE_IDLE_IRP);
            RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

            USBPORT_CompleteIrp(PdoDeviceObject,
                                irp,
                                STATUS_CANCELLED,
                                0);

        } else {
            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'rsCB', irp, 0, 0);

            rhDevExt->Pdo.PendingIdleNotificationIrp = irp;
            RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);
        }
    }
}


NTSTATUS
USBPORT_IdleNotificationRequest(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Request by the hub driver to go 'idle' is suspend.

    If we call the callback the hub will request a D2 power irp.
    If we do not call the callback, now poer irp will be sent and
    the bus will noy enter UsbSuspend.

    We are required to sit on the Irp until canceled. We permit only
    one 'selective suspend' IRP in the driver at a time.

    NOTE: a possible optimization is to have the hub driver simply
    not issue this IOCTL since it doesn't actualy do anything.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_BOGUS;
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;
    PDRIVER_CANCEL cr;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'iNOT', PdoDeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND)) {
        // NOTE: This is where we override selective suspend
        // ifthe HW (controller)
        LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'noSS', PdoDeviceObject, Irp, 0);
        ntStatus = STATUS_NOT_SUPPORTED;

        goto USBPORT_IdleNotificationRequest_Complete;
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CONTROLLER_GONE)) {
        LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'gone', PdoDeviceObject, Irp, 0);
        ntStatus = STATUS_DEVICE_NOT_CONNECTED;

        goto USBPORT_IdleNotificationRequest_Complete;
    }

    // we only support one idle irp pending
    // in the root hub -- basically we have a pending
    // irp table with one entry

    ACQUIRE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    cr = IoSetCancelRoutine(Irp, USBPORT_CancelPendingIdleIrp);
    USBPORT_ASSERT(cr == NULL);

    if (Irp->Cancel &&
        IoSetCancelRoutine(Irp, NULL)) {

        // irp was canceled and our cancel routine
        // did not run
        RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

        ntStatus = STATUS_CANCELLED;

        goto USBPORT_IdleNotificationRequest_Complete;

    } else {

        // cancel routine is set, if irp is canceled
        // the cancel routine will stall on the
        // IDLE_IRP_LOCK which we are holding

        if (!TEST_PDO_FLAG(rhDevExt, USBPORT_PDOFLAG_HAVE_IDLE_IRP)) {

            // keep the irp in our table

            IoMarkIrpPending(Irp);
            rhDevExt->Pdo.PendingIdleNotificationIrp = Irp;
            SET_PDO_FLAG(rhDevExt, USBPORT_PDOFLAG_HAVE_IDLE_IRP);

            LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'pNOT', PdoDeviceObject, Irp, 0);
            ntStatus = STATUS_PENDING;

            RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

            goto USBPORT_IdleNotificationRequest_Done;

        } else {

            // we already have a wake irp, complete this
            // one with STATUS_BUSY.
            // note that since it is not in our table if
            // the cancel routine is running (ie stalled
            // on the IDLEIRP_LOCK it will ignore the irp
            // when we release the lock.

            if (IoSetCancelRoutine(Irp, NULL) != NULL) {

                // cancel routine did not run
                ntStatus = STATUS_DEVICE_BUSY;

            } else {

                // let the cancel routine complete it.
                IoMarkIrpPending(Irp);
                ntStatus = STATUS_PENDING;
                RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);
                goto USBPORT_IdleNotificationRequest_Done_NoCB;
            }
        }

        RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);
    }

    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'cpNT', PdoDeviceObject, Irp, ntStatus);

USBPORT_IdleNotificationRequest_Complete:

    USBPORT_CompleteIrp(PdoDeviceObject,
                        Irp,
                        ntStatus,
                        0);

USBPORT_IdleNotificationRequest_Done:

    // now issue the callback immediatly if we have an irp
    USBPORT_DoIdleNotificationCallback(PdoDeviceObject);

USBPORT_IdleNotificationRequest_Done_NoCB:

    return ntStatus;

}


VOID
USBPORT_CompletePdoWaitWake(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    called when the root hub pdo has 'woke up'

Arguments:

Return Value:

    none

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION rhDevExt, devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    ACQUIRE_WAKEIRP_LOCK(FdoDeviceObject, irql);
    irp = rhDevExt->Pdo.PendingWaitWakeIrp;

    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'WAKi', FdoDeviceObject, irp, 0);

    if (irp != NULL &&
        IoSetCancelRoutine(irp, NULL)) {

        // we have an irp and the cancel routine has not
        // run, complete the irp.
        rhDevExt->Pdo.PendingWaitWakeIrp = NULL;

        RELEASE_WAKEIRP_LOCK(FdoDeviceObject, irql);

        // since this irp was sent to the PDO we
        // complete it to the PDO
        USBPORT_KdPrint((1, " Complete PDO Wake Irp %x\n", irp));
        DEBUG_BREAK();

        USBPORT_CompleteIrp(devExt->Fdo.RootHubPdo,
                            irp,
                            STATUS_SUCCESS,
                            0);

    } else {

        RELEASE_WAKEIRP_LOCK(FdoDeviceObject, irql);
    }

}


VOID
USBPORT_CompletePendingIdleIrp(
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    If we have one complete the idle notification request
    irp

Arguments:

Return Value:

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);
    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // cancel routine will stall here,
    // if cancel is running we will stall here
    ACQUIRE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    // remove the irp from the table so that the
    // cancel routine cannot find it

    irp = rhDevExt->Pdo.PendingIdleNotificationIrp;
    LOGENTRY(NULL, fdoDeviceObject, LOG_POWER, 'idCP', irp, 0, 0);

    rhDevExt->Pdo.PendingIdleNotificationIrp = NULL;
    if (irp != NULL) {
        CLEAR_PDO_FLAG(rhDevExt, USBPORT_PDOFLAG_HAVE_IDLE_IRP);
    }

    RELEASE_IDLEIRP_LOCK(fdoDeviceObject, irql);

    // do the callback if we have an irp

    if (irp != NULL) {

        // we need to complete this Irp
        IoSetCancelRoutine(irp, NULL);
        USBPORT_KdPrint((1, "-complete idle irp\n"));
        USBPORT_CompleteIrp(PdoDeviceObject,
                            irp,
                            STATUS_SUCCESS,
                            0);
    }

}


NTSTATUS
USBPORT_ProcessHcWakeIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Process the HC wake irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    USBHC_WAKE_STATE oldWakeState;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    devExt->Fdo.HcPendingWakeIrp = Irp;
    // Advance the state if the armed if we are to proceed
    oldWakeState = InterlockedCompareExchange( (PULONG) &devExt->Fdo.HcWakeState,
                                                HCWAKESTATE_ARMED,
                                                HCWAKESTATE_WAITING );

     if (oldWakeState == HCWAKESTATE_WAITING_CANCELLED) {
         // We got disarmed, finish up and complete the IRP
         devExt->Fdo.HcWakeState = HCWAKESTATE_COMPLETING;

         DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, Irp);

         Irp->IoStatus.Status = STATUS_CANCELLED;
         IoCompleteRequest( Irp, IO_NO_INCREMENT );

         return STATUS_CANCELLED;
     }
     // We went from WAITING to ARMED. Set a completion routine and forward
     // the IRP. Note that our completion routine might complete the IRP
     // asynchronously, so we mark the IRP pending
     IoMarkIrpPending(Irp);
     IoCopyCurrentIrpStackLocationToNext( Irp );
     IoSetCompletionRoutine( Irp,
                             USBPORT_HcWakeIrp_Io_Completion,
                             NULL,
                             TRUE,
                             TRUE,
                             TRUE);

     DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, Irp);
     PoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                  Irp);

     return STATUS_PENDING;

}


NTSTATUS
USBPORT_HcWakeIrp_Io_Completion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    Called when the HC wake irp completes we use this to hook completion
    so we can handle the cancel

    This routine runs before the USBPORT_USBPORT_HcWakeIrp_Po_Completion

Arguments:

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION devExt;
    USBHC_WAKE_STATE oldWakeState;

    GET_DEVICE_EXT(devExt, DeviceObject);
    ASSERT_FDOEXT(devExt);

    // Advance the state to completing
    oldWakeState = InterlockedExchange( (PULONG) &devExt->Fdo.HcWakeState,
                                        HCWAKESTATE_COMPLETING );

    if (oldWakeState == HCWAKESTATE_ARMED) {
        // Normal case, IoCancelIrp isnt being called. Note that we already

        // marked the IRP pending in our dispatch routine
        return STATUS_SUCCESS;
    } else {
        ASSERT(oldWakeState == HCWAKESTATE_ARMING_CANCELLED);
        // IoCancelIrp is being called RIGHT NOW. The disarm code will try
        // to put back the WAKESTATE_ARMED state. It will then see our
        // WAKESTATE_COMPLETED value, and complete the IRP itself!

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
}


NTSTATUS
USBPORT_HcWakeIrp_Po_Completion(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE DeviceState,
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for the controller

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - stalls completion of the irp.

--*/
{
    NTSTATUS poNtStatus;
    PDEVICE_EXTENSION devExt = Context;
    KIRQL irql;
    POWER_STATE powerState;

    USBPORT_KdPrint((1,
            "HcWakeIrpCompletion (%x)\n", IoStatus->Status));

    LOGENTRY(NULL, devExt->HcFdoDeviceObject, LOG_POWER, 'WAKc',
        devExt, IoStatus->Status, 0);

    //
    // Zero already freed IRP pointer (not necessary, but nice when debugging)
    //
    devExt->Fdo.HcPendingWakeIrp = NULL;
    //
    // Restore state (old state will have been completing)
    //
    devExt->Fdo.HcWakeState = HCWAKESTATE_DISARMED;

    if (IoStatus->Status == STATUS_SUCCESS) {
        LOGENTRY(NULL, devExt->HcFdoDeviceObject, LOG_POWER, 'WAK0', 0, 0, 0);

        // a successful completion of the wake Irp means something
        // generated resume signalling

        // The idea here is that we won't have a wake irp down
        // unless we are in some D state other than D0.  Remember
        // this is the controller FDO not the root hub.

        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RESUME_SIGNALLING);

        // we canceled the wake irp when entering D0 so we should
        // not see any completions unless we are in a low power
        // state
        //USBPORT_ASSERT(devExt->CurrentDevicePowerState != PowerDeviceD0);

        // we must now attempt to put the controller in D0
        powerState.DeviceState = PowerDeviceD0;
        USBPORT_KdPrint((1, " >Wakeup Requesting HC D-State - %s\n",
                D_State(powerState.DeviceState)));

        poNtStatus =
            PoRequestPowerIrp(devExt->Fdo.PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBPORT_PoRequestCompletion,
                              devExt->HcFdoDeviceObject,
                              NULL);

    } else {
        // some other error, means we f'up probably with the
        // help of the ACPI BIOS

        if (IoStatus->Status == STATUS_CANCELLED) {
            LOGENTRY(NULL, devExt->HcFdoDeviceObject, LOG_POWER, 'WAK1',
                     0, 0, 0);
            USBPORT_KdPrint((1, " >Wakeup Irp Completed with cancel %x\n",
                    IoStatus->Status));


        } else {
            LOGENTRY(NULL, devExt->HcFdoDeviceObject, LOG_POWER, 'WAK2',
                     0, 0, 0);
            USBPORT_KdPrint((0, " >Wakeup Irp Completed with error %x\n",
                    IoStatus->Status));
            // if status is STATUS_INVALID_DEVICE_STATE then you need
            // to complain to the ACPI guys about your system not waking
            // from USB.  This is likely due to a bad Device Capability
            // structure.
            if (IoStatus->Status == STATUS_INVALID_DEVICE_STATE) {
                 BUG_TRAP();
            }
        }
    }

    DECREMENT_PENDING_REQUEST_COUNT(devExt->HcFdoDeviceObject, NULL);

    // Note that the status returned here does not matter, this routine
    // is called by the kernel (PopCompleteRequestIrp) when the irp
    // completes to PDO and this function ignores the returned status.
    // PopCompleteRequestIrp also immediatly frees the irp so we need
    // take care not to reference it after this routine has run.

    KeSetEvent(&devExt->Fdo.HcPendingWakeIrpEvent,
               1,
               FALSE);

    return IoStatus->Status;
}


VOID
USBPORT_ArmHcForWake(
    PDEVICE_OBJECT FdoDeviceObject
    )

/*++

Routine Description:

    ArmHcforWake

    Allocate and submit a 'WaitWake' Irp to the host controllers PDO
    (usually owned by PCI).  This will enable the PME event needed to
    wake the system.

    Note: We only post the wake irp if the root hub PDO is 'enabled'
    for wakeup AND the host controller supports it.

Arguments:


Return Value:

    none.

--*/

{
    PIRP irp;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN post = FALSE;
    POWER_STATE powerState;
    NTSTATUS ntStatus, waitStatus;
    USBHC_WAKE_STATE oldWakeState;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_WAKE_ENABLED));

    // this check just prevents us from posting a wake irp when we
    // already have one pending, although I'm not sure how we might
    // get into this situation.
    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWW>',
        0, 0, 0);


    while (1) {
        oldWakeState = InterlockedCompareExchange((PULONG)&devExt->Fdo.HcWakeState,
                                                  HCWAKESTATE_WAITING,
                                                  HCWAKESTATE_DISARMED);

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWWx', oldWakeState, 0, 0);

        if (oldWakeState == HCWAKESTATE_DISARMED) {
            break;
        }

        if ((oldWakeState == HCWAKESTATE_ARMED) ||
            (oldWakeState == HCWAKESTATE_WAITING)) {
            // The device is already arming
            return;
        }

        // wait for previous wake irp to finish
        USBPORT_DisarmHcForWake(FdoDeviceObject);
    }

    // current state is HCWAKESTATE_WAITING
    // set flag for tracking purposes only
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_HCPENDING_WAKE_IRP);

    // wait for wake irp to finish

    waitStatus = KeWaitForSingleObject(
                &devExt->Fdo.HcPendingWakeIrpEvent,
                Suspended,
                KernelMode,
                FALSE,
                NULL);


    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWWp',
            0, 0, 0);

    // According to the NTDDK this should be systemwake
    powerState.DeviceState = devExt->DeviceCapabilities.SystemWake;

    // send the wake irp to our PDO, since it is not our
    // responsibility to free the irp we don't keep track
    // of it
    ntStatus = PoRequestPowerIrp(devExt->Fdo.PhysicalDeviceObject,
                                 IRP_MN_WAIT_WAKE,
                                 powerState,
                                 USBPORT_HcWakeIrp_Po_Completion,
                                 devExt,
                                 NULL);

    INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);

    if (ntStatus != STATUS_PENDING) {

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'WAKp',
            FdoDeviceObject, 0, ntStatus);

        devExt->Fdo.HcWakeState = HCWAKESTATE_DISARMED;
        KeSetEvent(&devExt->Fdo.HcPendingWakeIrpEvent,
                   1,
                   FALSE);

        DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);

    } else {

        USBPORT_KdPrint((1, ">HC enabled for wakeup (%x) \n",  ntStatus));
        DEBUG_BREAK();
    }
}

#ifdef IA64
__forceinline
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}
#else
#define InterlockedOr _InterlockedOr
#endif

VOID
USBPORT_DisarmHcForWake(
    PDEVICE_OBJECT FdoDeviceObject
    )

/*++

Routine Description:

    DisarmForWake

    cancels and frees the Pending wake irp for  the host controller

Arguments:


Return Value:

    none.

--*/
{
    PIRP irp;
    KIRQL irql;
    PDEVICE_EXTENSION devExt;
    USBHC_WAKE_STATE oldWakeState;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // no longer enabled for wake
    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_WAKE_ENABLED);

    // Go from HCWAKESTATE_WAITING to HCWAKESTATE_WAITING_CANCELLED, or
    //         HCWAKESTATE_ARMED to HCWAKESTATE_ARMING_CANCELLED, or
    // stay in HCWAKESTATE_DISARMED or HCWAKESTATE_COMPLETING
    oldWakeState = InterlockedOr( (PULONG)&devExt->Fdo.HcWakeState, 1 );
    //oldWakeState = RtlInterlockedSetBits((PULONG)&devExt->Fdo.HcWakeState, 1 );

    if (oldWakeState == HCWAKESTATE_ARMED) {

        IoCancelIrp(devExt->Fdo.HcPendingWakeIrp);

        //
        // Now that weve cancelled the IRP, try to give back ownership
        // to the completion routine by restoring the HCWAKESTATE_ARMED state
        //
        oldWakeState = InterlockedCompareExchange( (PULONG) &devExt->Fdo.HcWakeState,
                                                   HCWAKESTATE_ARMED,
                                                   HCWAKESTATE_ARMING_CANCELLED );

        if (oldWakeState == HCWAKESTATE_COMPLETING) {
            //
            // We didnt give back control of IRP in time, so we own it now.
            //
            // this will cause tp PoCompletion routine to run
            IoCompleteRequest( devExt->Fdo.HcPendingWakeIrp, IO_NO_INCREMENT);
        }
    }
}

#if 0
VOID
USBPORT_SubmitHcWakeIrp(
    PDEVICE_OBJECT FdoDeviceObject
    )

/*++

Routine Description:

    Allocate and submit a 'WaitWake' Irp to the host controllers PDO
    (usually owned by PCI).  This will enable the PME event needed to
    wake the system.

    Note: We only post the wake irp if the root hub PDO is 'enabled'
    for wakeup AND the host controller supports it.

Arguments:


Return Value:

    none.

--*/

{
    PIRP irp;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    BOOLEAN post = FALSE;
    POWER_STATE powerState;
    NTSTATUS ntStatus;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_WAKE_ENABLED));

    // this check just prevents us from posting a wake irp when we
    // already have one pending, although I'm not sure how we might
    // get into this situation.
    LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWW>',
        0, 0, 0);


    // if USBPORT_FDOFLAG_PENDING_WAKE_IRP is set then we have an irp
    // pending, or are about to have one otherwise we set the field and
    // post an irp

    KeAcquireSpinLock(&devExt->Fdo.HcPendingWakeIrpSpin.sl, &irql);
    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_HCPENDING_WAKE_IRP)) {

         LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWW0',
                0, 0, 0);
        // no wake irp pending, indicate that we
        // are about to post one

        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_HCPENDING_WAKE_IRP);
        USBPORT_ASSERT(devExt->Fdo.HcPendingWakeIrp == NULL);
        post = TRUE;

        // this event will be signalled when the irp completes
        KeInitializeEvent(&devExt->Fdo.HcPendingWakeIrpEvent,
            NotificationEvent, FALSE);
        KeInitializeEvent(&devExt->Fdo.HcPendingWakeIrpPostedEvent,
            NotificationEvent, FALSE);

    }

    KeReleaseSpinLock(&devExt->Fdo.HcPendingWakeIrpSpin.sl, irql);

    if (post) {
        // no wake irp, post one

        LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'hWWp',
                0, 0, 0);

        // According to the NTDDK this should be systemwake
        powerState.DeviceState = devExt->DeviceCapabilities.SystemWake;

        // send the wake irp to our PDO, since it is not our
        // responsibility to free the irp we don't keep track
        // of it
        ntStatus = PoRequestPowerIrp(devExt->Fdo.PhysicalDeviceObject,
                                     IRP_MN_WAIT_WAKE,
                                     powerState,
                                     USBPORT_HcWakeIrpCompletion,
                                     devExt,
                                     &irp);

        // serialize the cancel code so that we don't free
        // the irp until we know the address

        // track the pending request since we have the completion
        // routine hooked
        INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);

        if (ntStatus == STATUS_PENDING) {
            devExt->Fdo.HcPendingWakeIrp = irp;
            LOGENTRY(NULL, FdoDeviceObject, LOG_POWER, 'WAKp',
                FdoDeviceObject, irp, ntStatus);

            KeSetEvent(&devExt->Fdo.HcPendingWakeIrpPostedEvent,
                       1,
                       FALSE);
        } else {
            TEST_TRAP();
        }

        USBPORT_KdPrint((1, ">HC enabled for wakeup (%x) (irp = %x)\n",
            ntStatus, irp));
        DEBUG_BREAK();
    }

}
#endif


VOID
USBPORT_HcQueueWakeDpc(
    PDEVICE_OBJECT FdoDeviceObject
    )
{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (KeInsertQueueDpc(&devExt->Fdo.HcWakeDpc, 0, 0)) {
        INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
    }

}


VOID
USBPORT_HcWakeDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_CompletePdoWaitWake(fdoDeviceObject);

    DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\pnp.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    Port driver for USB host controllers

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_CreateDeviceObject)
#pragma alloc_text(PAGE, USBPORT_DeferredStartDevice)
#pragma alloc_text(PAGE, USBPORT_SymbolicLink)
#pragma alloc_text(PAGE, USBPORT_GetRegistryKeyValueForPdo)
#pragma alloc_text(PAGE, USBPORT_SetRegistryKeyValueForPdo)
#pragma alloc_text(PAGE, USBPORT_MakeRootHubPdoName)
#pragma alloc_text(PAGE, USBPORT_MakeHcdDeviceName)
#pragma alloc_text(PAGE, USBPORT_CreateRootHubPdo)
#pragma alloc_text(PAGE, USBPORT_GetIdString)
#pragma alloc_text(PAGE, USBPORTSVC_GetMiniportRegistryKeyValue)
#pragma alloc_text(PAGE, USBPORT_CreatePortFdoSymbolicLink)
#endif

// non paged functions
//USBPORT_FindMiniport
//USBPORT_Unload
//USBPORT_PnPAddDevice
//USBPORT_GetResources
//USBPORT_FdoStart_Complete
//USBPORT_FdoPnPIrp
//USBPORT_PdoPnPIrp

// globals

LIST_ENTRY USBPORT_MiniportDriverList;
USBPORT_SPIN_LOCK USBPORT_GlobalsSpinLock;
BOOLEAN USBPORT_GlobalInitialized = FALSE;
LIST_ENTRY USBPORT_USB2fdoList;
LIST_ENTRY USBPORT_USB1fdoList;

ULONG USB2LIB_HcContextSize;
ULONG USB2LIB_EndpointContextSize;
ULONG USB2LIB_TtContextSize;

/*
*/
#define USBPORT_DUMMY_USBD_EXT_SIZE 512
PUCHAR USBPORT_DummyUsbdExtension = NULL;

#if DBG
ULONG USBPORT_GlobalAllocedPagedPool;
ULONG USBPORT_GlobalAllocedNonPagedPool;
#endif


USB_MINIPORT_STATUS
USBPORTSVC_GetMiniportRegistryKeyValue(
    PDEVICE_DATA DeviceData,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
/*++

Routine Description:

    Get a registry parameter from either the hardware
    or software branch of the registry given the PDO

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);


    ntStatus = USBPORT_GetCachedRegistryKeyValueForPdo(
                                          devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          SoftwareBranch,
                                          KeyNameString,
                                          KeyNameStringLength,
                                          Data,
                                          DataLength);

    return USBPORT_NtStatus_TO_MiniportStatus(ntStatus);
}


NTSTATUS
USBPORT_GetRegistryKeyValueForPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
/*++

Routine Description:

    Get a registry parameter from either the hardware
    or software branch of the registry given the PDO

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;
    HANDLE handle;

    PAGED_CODE();

    if (SoftwareBranch) {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);
    } else {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    }

    if (NT_SUCCESS(ntStatus)) {

        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);

        length = sizeof(KEY_VALUE_FULL_INFORMATION) +
                KeyNameStringLength + DataLength;

        ALLOC_POOL_Z(fullInfo, PagedPool, length);

        USBPORT_KdPrint((2,"' GetRegistryKeyValueForPdo buffer = 0x%x\n", fullInfo));

        if (fullInfo) {
            ntStatus = ZwQueryValueKey(handle,
                            &keyNameUnicodeString,
                            KeyValueFullInformation,
                            fullInfo,
                            length,
                            &length);

            if (NT_SUCCESS(ntStatus)){
                USBPORT_ASSERT(DataLength == fullInfo->DataLength);
                RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
            }

            FREE_POOL(FdoDeviceObject, fullInfo);
        }
    }

    return ntStatus;
}


NTSTATUS
USBPORT_SetRegistryKeyValueForPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    ULONG Type,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyNameUnicodeString;
    HANDLE handle;

    PAGED_CODE();

    if (SoftwareBranch) {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    } else {
        ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_ALL,
                                         &handle);
    }

    if (NT_SUCCESS(ntStatus)) {

        RtlInitUnicodeString(&keyNameUnicodeString, KeyNameString);

        ntStatus = ZwSetValueKey(handle,
                        &keyNameUnicodeString,
                        0,
                        Type,
                        Data,
                        DataLength);

    }

    return ntStatus;
}


NTSTATUS
USBPORT_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION DevExt,
    PDEVICE_OBJECT PhysicalDeviceObject,
    LPGUID Guid
    )
/*++

Routine Description:

    create a symbolic link for a given GUID class and
    PhysicalDeviceObject

    We also write the name to the hw branch of the registry
    to make it easy to find for a particular instance
    of controller.

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    NTSTATUS ntStatus;

    PAGED_CODE();

    if (CreateFlag) {

        /*
         *  Create the symbolic link
         */

        USBPORT_ASSERT(!TEST_FLAG(DevExt->Flags, USBPORT_FLAG_SYM_LINK));

        ntStatus = IoRegisterDeviceInterface(
                        PhysicalDeviceObject,
                        Guid,
                        NULL,
                        &DevExt->SymbolicLinkName);

        if (NT_SUCCESS(ntStatus)) {

            /*
             *  Now set the symbolic link for the association and
             * store it..
             */

            // successfully alloced a link
            // set the flag so we will free it
            SET_FLAG(DevExt->Flags, USBPORT_FLAG_SYM_LINK);

            // write it to the registry -- this is for comaptibilty
            // with older OS versions

            ntStatus = USBPORT_SetRegistryKeyValueForPdo(
                            PhysicalDeviceObject,
                            USBPORT_HW_BRANCH,
                            REG_SZ,
                            SYM_LINK_KEY,
                            sizeof(SYM_LINK_KEY),
                            &DevExt->SymbolicLinkName.Buffer[0],
                            DevExt->SymbolicLinkName.Length);

            if (NT_SUCCESS(ntStatus)) {
                ntStatus =
                    IoSetDeviceInterfaceState(&DevExt->SymbolicLinkName,
                                              TRUE);
            }
        }

    } else {

        USBPORT_ASSERT(TEST_FLAG(DevExt->Flags, USBPORT_FLAG_SYM_LINK));

        /*
         *  Disable the symbolic link
         */
        ntStatus = IoSetDeviceInterfaceState(
                     &DevExt->SymbolicLinkName, FALSE);
        if (NT_SUCCESS(ntStatus)) {
            RtlFreeUnicodeString(&DevExt->SymbolicLinkName);
            CLEAR_FLAG(DevExt->Flags, USBPORT_FLAG_SYM_LINK);
        } else {
            DEBUG_BREAK();
        }

    }

    return ntStatus;
}


PUSBPORT_MINIPORT_DRIVER
USBPORT_FindMiniport(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Find a miniport given a DriverObject

Arguments:

    DriverObject - pointer to a driver object

Return Value:

    pointer to miniport or NULL

--*/
{
    KIRQL irql;
    PUSBPORT_MINIPORT_DRIVER found = NULL;
    PUSBPORT_MINIPORT_DRIVER miniportDriver;
    PLIST_ENTRY listEntry;

    KeAcquireSpinLock(&USBPORT_GlobalsSpinLock.sl, &irql);

    listEntry = &USBPORT_MiniportDriverList;
    if (!IsListEmpty(listEntry)) {
        listEntry = USBPORT_MiniportDriverList.Flink;
    }
//    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'FIl+', listEntry,
//            &USBPORT_MiniportDriverList, 0);

    while (listEntry != &USBPORT_MiniportDriverList) {

        miniportDriver = (PUSBPORT_MINIPORT_DRIVER)
            CONTAINING_RECORD(listEntry,
                              struct _USBPORT_MINIPORT_DRIVER,
                              ListEntry);

        if (miniportDriver->DriverObject == DriverObject) {
            found = miniportDriver;
            break;
        }

        // next entry
        listEntry = miniportDriver->ListEntry.Flink;
    }

    KeReleaseSpinLock(&USBPORT_GlobalsSpinLock.sl, irql);

//    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Fmpd', found, 0, 0);

    return found;
}


VOID
USBPORT_Unload(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free globally allocated miniport structure used to
    track this particular miniport driver.

    note: OS won't unload unless this is the last instance
    of the miniport

Arguments:

    DriverObject - pointer to a driver object

Return Value:

    None

--*/
{
    KIRQL irql;
    PUSBPORT_MINIPORT_DRIVER miniportDriver;

    // find the miniport driver data

    miniportDriver = USBPORT_FindMiniport(DriverObject);

    // we had better find it! If we don't we screwed up
    // the system will crash
    USBPORT_ASSERT(miniportDriver != NULL);
    if (miniportDriver == NULL) {
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0);
        // prefix happy
        return;
    }

    // the miniport should not need to do anything.
    // But just in case/ we will call them if they
    // indicated an unload routine in the DriverObject.

    USBPORT_KdPrint((1, "'unloading USB miniport\n"));

    if (miniportDriver->MiniportUnload != NULL) {
        miniportDriver->MiniportUnload(DriverObject);
    }

    USBPORT_InterlockedRemoveEntryList(&miniportDriver->ListEntry,
                                       &USBPORT_GlobalsSpinLock.sl);

    FREE_POOL(NULL, miniportDriver);

}


NTSTATUS
USBPORT_MakeHcdDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString,
    ULONG Idx
    )
/*++

Routine Description:

    This function generates the name used for the FDO.  The
    name format is USBFDO-n where nnn is 0 - 65535.


Arguments:

Return Value:

    None

--*/
{
    ULONG bit, i;
    PWCHAR deviceNameBuffer;
    WCHAR nameBuffer[]  = L"\\Device\\USBFDO-";
    NTSTATUS ntStatus;
    UNICODE_STRING tmpUnicodeString;
    WCHAR tmpBuffer[16];

    PAGED_CODE();

    // enough for 3 digits and NULL
    tmpUnicodeString.Buffer = tmpBuffer;
    tmpUnicodeString.MaximumLength = sizeof(tmpBuffer);
    tmpUnicodeString.Length = 0;

    ntStatus = RtlIntegerToUnicodeString(Idx,
                                         10,
                                         &tmpUnicodeString);

    if (NT_SUCCESS(ntStatus)) {

        USHORT siz;

        siz = sizeof(nameBuffer)+tmpUnicodeString.Length;

        // we can't log this alloc because the device object
        // has not been created yet
        ALLOC_POOL_Z(deviceNameBuffer, PagedPool, siz);

        if (deviceNameBuffer != NULL) {

            RtlCopyMemory(deviceNameBuffer, nameBuffer, sizeof(nameBuffer));
            RtlInitUnicodeString(DeviceNameUnicodeString,
                                 deviceNameBuffer);
            DeviceNameUnicodeString->MaximumLength = siz;

            ntStatus = RtlAppendUnicodeStringToString(
                            DeviceNameUnicodeString,
                            &tmpUnicodeString);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}


NTSTATUS
USBPORT_MakeRootHubPdoName(
    PDEVICE_OBJECT FdoDeviceObject,
    PUNICODE_STRING PdoNameUnicodeString,
    ULONG Index
    )
/*++

Routine Description:

    This service Creates a name for a PDO created by the HUB

Arguments:

Return Value:


--*/
{
    PWCHAR nameBuffer = NULL;
    WCHAR rootName[] = L"\\Device\\USBPDO-";
    UNICODE_STRING idUnicodeString;
    WCHAR buffer[32];
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT length;
    BOOLEAN haveString = FALSE;

    PAGED_CODE();

    length = sizeof(buffer)+sizeof(rootName);

    // os frees this when the unicode string is 'freed'
    ALLOC_POOL_OSOWNED(nameBuffer, PagedPool, length);

    if (nameBuffer) {
        RtlCopyMemory(nameBuffer, rootName, sizeof(rootName));

        RtlInitUnicodeString(PdoNameUnicodeString,
                             nameBuffer);
        PdoNameUnicodeString->MaximumLength =
            length;
        haveString = TRUE; // we have a string now

        RtlInitUnicodeString(&idUnicodeString,
                             &buffer[0]);
        idUnicodeString.MaximumLength =
            sizeof(buffer);

        ntStatus = RtlIntegerToUnicodeString(
                  Index,
                  10,
                  &idUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
             ntStatus = RtlAppendUnicodeStringToString(PdoNameUnicodeString,
                                                       &idUnicodeString);
        }

        USBPORT_KdPrint((3, "'USBPORT_MakeNodeName string = %x\n",
            PdoNameUnicodeString));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus) && haveString) {
        RtlFreeUnicodeString(PdoNameUnicodeString);
    }

    return ntStatus;
}


NTSTATUS
USBPORT_PnPAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of a USB host
    controller.  This is where we create our deviceObject.

Arguments:

    DriverObject - pointer to the driver object for this instance of HCD

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    NT STATUS CODE

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_EXTENSION devExt;
    UNICODE_STRING deviceNameUnicodeString;
    ULONG deviceNameIdx;
    PUSBPORT_MINIPORT_DRIVER miniportDriver;

    // since we raise IRQL in this function it cannot be pagable

    // find the driver
    miniportDriver = USBPORT_FindMiniport(DriverObject);

    USBPORT_ASSERT(miniportDriver != NULL);

    //
    // generate a device name
    //

    deviceNameIdx = 0;

    do {

        ntStatus = USBPORT_MakeHcdDeviceName(&deviceNameUnicodeString,
                                             deviceNameIdx);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBPORT_CreateDeviceObject(DriverObject,
                                                  miniportDriver,
                                                  &deviceObject,
                                                  &deviceNameUnicodeString);

            RtlFreeUnicodeString(&deviceNameUnicodeString);
            if (NT_SUCCESS(ntStatus)) {
                //preserve idx
                break;
            }
        }

        deviceNameIdx++;

    } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);

    if (NT_SUCCESS(ntStatus)) {

        GET_DEVICE_EXT(devExt, deviceObject);

        // BUGBUG OS should zero this
        RtlZeroMemory(devExt, sizeof(DEVICE_EXTENSION));

        devExt->DummyUsbdExtension = USBPORT_DummyUsbdExtension;
        devExt->Sig = USBPORT_DEVICE_EXT_SIG;
        devExt->HcFdoDeviceObject = deviceObject;
        devExt->Fdo.PhysicalDeviceObject = PhysicalDeviceObject;
        devExt->Fdo.DeviceNameIdx = deviceNameIdx;
        devExt->Fdo.MiniportDriver = miniportDriver;
        devExt->Fdo.MiniportDeviceData = &devExt->Fdo.MiniportExtension[0];

        if (USBPORT_IS_USB20(devExt)) {
            PUCHAR pch;

            pch = (PUCHAR) &devExt->Fdo.MiniportExtension[0];
            devExt->Fdo.Usb2LibHcContext = (PVOID) (pch +
                devExt->Fdo.MiniportDriver->RegistrationPacket.DeviceDataSize);

            USB2LIB_InitController(devExt->Fdo.Usb2LibHcContext);
        } else {
            devExt->Fdo.Usb2LibHcContext = USB_BAD_PTR;
        }

        INITIALIZE_PENDING_REQUEST_COUNTER(devExt);

        // inc once for the add
        // transition to -1 means we have no pending requests
        INCREMENT_PENDING_REQUEST_COUNT(deviceObject, NULL);
#if DBG
        USBPORT_LogAlloc(&devExt->Log, 16);
#else
        USBPORT_LogAlloc(&devExt->Log, 8);
#endif
        // init the log spinlock here
        KeInitializeSpinLock(&devExt->Fdo.LogSpinLock.sl);

//#if DBG
//        USBPORT_LogAlloc(&devExt->TransferLog, 4);
//        USBPORT_LogAlloc(&devExt->EnumLog, 4);
//#endif
        USBPORT_KdPrint((1, "'**USBPORT DEVICE OBJECT** (fdo) = %x, ext = %x\n",
            deviceObject, devExt));


        KeInitializeSemaphore(&devExt->Fdo.DeviceLock, 1, 1);
        KeInitializeSemaphore(&devExt->Fdo.CcLock, 1, 1);
        InitializeListHead(&devExt->Fdo.DeviceHandleList);
        InitializeListHead(&devExt->Fdo.MapTransferList);
        InitializeListHead(&devExt->Fdo.DoneTransferList);
        InitializeListHead(&devExt->Fdo.GlobalEndpointList);
        InitializeListHead(&devExt->Fdo.AttendEndpointList);
        InitializeListHead(&devExt->Fdo.EpStateChangeList);
        InitializeListHead(&devExt->Fdo.EpClosedList);
        InitializeListHead(&devExt->Fdo.BadRequestList);
        InitializeListHead(&devExt->Fdo.RegistryCache);
         devExt->Fdo.BadRequestFlush = 0;

        //
        // we need to handle a seemingly random set of requests
        // to start/stop/remove power up, down etc in order to
        // handle this we keep a set of PNP state flags

        // not removed, not started, not stopped
        devExt->PnpStateFlags = 0;
        // until we get a start we will consider ourselves OFF
        devExt->CurrentDevicePowerState = PowerDeviceD3;

        devExt->Fdo.MpStateFlags = 0;

        // attach to top of PnP stack
        devExt->Fdo.TopOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        devExt->Fdo.PendingRhCallback = 1;
        //
        // Indicate that the device object is ready for requests.
        //

        if (!USBPORT_IS_USB20(devExt)) {
            deviceObject->Flags |= DO_POWER_PAGABLE;
        }
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    USBPORT_KdPrint((2, "'exit USBPORT_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPORT_CreateDeviceObject(
    PDRIVER_OBJECT DriverObject,
    PUSBPORT_MINIPORT_DRIVER MiniportDriver,
    PDEVICE_OBJECT *DeviceObject,
    PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

    This routine is called to create a new instance of a USB host
    controller.

Arguments:

    DriverObject - pointer to the driver object for USBD.

    *DeviceObject - ptr to DeviceObject ptr to be filled
                    in with the device object we create.

    DeviceNameUnicodeString - optional pointer to a device
                    name for this FDO, can be NULL

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    ULONG extensionSize;

    PAGED_CODE();

    USBPORT_KdPrint((2, "'enter USBPORT_CreateDeviceObject\n"));

    extensionSize = sizeof(DEVICE_EXTENSION)+
                    MiniportDriver->RegistrationPacket.DeviceDataSize +
                    USB2LIB_HcContextSize;

    ntStatus = IoCreateDevice(DriverObject,
                              extensionSize,
                              DeviceNameUnicodeString, // Name
                              FILE_DEVICE_CONTROLLER,
                              0,
                              FALSE, //NOT Exclusive
                              DeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        devExt = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

        USBPORT_KdPrint((2, "'USBPORT_CreateDeviceObject: device object %x device extension = %x\n",
                 *DeviceObject, devExt));

    } else if (*DeviceObject) {
        IoDeleteDevice(*DeviceObject);
    }

    USBPORT_KdPrint((2, "'exit USBPORT_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPORT_GetResources(
    PDEVICE_OBJECT FdoDeviceObject,
    PCM_RESOURCE_LIST ResourceList,
    PHC_RESOURCES HcResources
    )

/*++

Routine Description:

Arguments:

    DeviceObject        - DeviceObject for this USB controller.

    ResourceList        - Resources for this controller.

Return Value:

    NT status code.

--*/

{
    ULONG i;
    NTSTATUS ntStatus;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR interrupt;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR memory;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ioport;
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace;
    PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDescriptor;
    ULONG mpOptionFlags;
    PDEVICE_EXTENSION devExt;

    USBPORT_KdPrint((2, "'enter USBPORT_GetResources\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    mpOptionFlags = REGISTRATION_PACKET(devExt).OptionFlags;

    // assume success
    ntStatus = STATUS_SUCCESS;

    // init the resource list
    RtlZeroMemory(HcResources, sizeof(*HcResources));

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'GRES', 0, 0, ResourceList);

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
        TEST_TRAP();
        // no resources, bail with success
        return ntStatus;
    }

    if (ResourceList == NULL) {
        USBPORT_KdPrint((1, "'no resources, failing start.\n"));
        ntStatus = STATUS_NONE_MAPPED;
        goto USBPORT_GetResources_Done;
    }

    fullResourceDescriptor = &ResourceList->List[0];
    PartialResourceList = &fullResourceDescriptor->PartialResourceList;

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'gres',
        PartialResourceList->Count,
        0,
        PartialResourceList);

    interrupt = NULL;
    memory    = NULL;
    ioport      = NULL;

    for (i = 0; i < PartialResourceList->Count; i++) {

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'resT', i,
            PartialResourceList->PartialDescriptors[i].Type, 0);

        switch (PartialResourceList->PartialDescriptors[i].Type) {
        case CmResourceTypeInterrupt:
            if (interrupt == NULL) {
                interrupt = &PartialResourceList->PartialDescriptors[i];
            }
            break;

        case CmResourceTypeMemory:
            if (memory == NULL) {
                memory = &PartialResourceList->PartialDescriptors[i];
            }
            break;

        case CmResourceTypePort:
            if (ioport == NULL) {
                ioport = &PartialResourceList->PartialDescriptors[i];
            }
            break;
        }
    }


    // only map resources this miniport actually needs

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NEED_IOPORT) &&
        ioport != NULL &&
        NT_SUCCESS(ntStatus)) {
        //
        // Set up AddressSpace to be of type Port I/O
        //

        USBPORT_KdPrint((1, "'Port Resources Found @ %x'%x, %d Ports Available \n",
            ioport->u.Port.Start.HighPart,
            ioport->u.Port.Start.LowPart,
            ioport->u.Port.Length));

        addressSpace =
            (ioport->Flags & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_IO? 1:0;

        cardAddress=ioport->u.Port.Start;

        if (!addressSpace) {
//                HcResources->Flags |= MAP_REGISTERS;
            HcResources->DeviceRegisters =
                MmMapIoSpace(
                cardAddress,
                ioport->u.Port.Length,
                FALSE);

            HcResources->DeviceRegistersLength =
                ioport->u.Port.Length;
        } else {
//                HcResources->Flags &= MAP_REGISTERS;
            HcResources->DeviceRegisters =
                (PVOID)(ULONG_PTR)cardAddress.QuadPart;
            HcResources->DeviceRegistersLength =
                ioport->u.Port.Length;
        }

        //
        // see if we successfully mapped the IO regs
        //

        if (HcResources->DeviceRegisters == NULL) {
            USBPORT_KdPrint((1, "'Couldn't map the device(port) registers. \n"));
            ntStatus = STATUS_NONE_MAPPED;
            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Fmio', 0, 0, ntStatus);

        } else {
            USBPORT_KdPrint((2, "'Mapped device(port) registers to 0x%x.\n",
                HcResources->DeviceRegisters));
            HcResources->Flags |= HCR_IO_REGS;
        }
    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NEED_MEMORY) &&
        memory != NULL &&
        NT_SUCCESS(ntStatus)) {
        //
        // Set up AddressSpace to be of type Memory mapped I/O
        //

        USBPORT_KdPrint((1,
            "'Memory Resources Found @ %x'%x, Length = %x\n",
            memory->u.Memory.Start.HighPart,
            memory->u.Memory.Start.LowPart,
            memory->u.Memory.Length));

        addressSpace = 0;
        HcResources->DeviceRegistersLength =
            memory->u.Memory.Length;

        cardAddress = memory->u.Memory.Start;

        HcResources->DeviceRegisters =
            MmMapIoSpace(cardAddress,
                         HcResources->DeviceRegistersLength,
                         FALSE);

        if (HcResources->DeviceRegisters == NULL) {
            USBPORT_KdPrint((1, "'Couldn't map the device(memory) registers. \n"));
            ntStatus = STATUS_NONE_MAPPED;
            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Fmmr', 0, 0, ntStatus);

        } else {
            USBPORT_KdPrint((2, "'Mapped device(memory) registers to 0x%x.\n",
                HcResources->DeviceRegisters));
            HcResources->Flags |= HCR_MEM_REGS;
        }
    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NEED_IRQ) &&
        interrupt != NULL &&
        NT_SUCCESS(ntStatus)) {
        //
        // Get Vector, level, and affinity information for this interrupt.
        //

        USBPORT_KdPrint((1, "'Interrupt Resources Found!  Level = %x Vector = %x\n",
            interrupt->u.Interrupt.Level,
            interrupt->u.Interrupt.Vector
            ));

        HcResources->Flags |= HCR_IRQ;

        //
        // Set up our interrupt.
        //

        USBPORT_KdPrint((2, "'requesting interrupt vector %x level %x\n",
                                interrupt->u.Interrupt.Level,
                                interrupt->u.Interrupt.Vector));

        HcResources->InterruptLevel=(KIRQL)interrupt->u.Interrupt.Level;
        HcResources->InterruptVector=interrupt->u.Interrupt.Vector;
        HcResources->Affinity=interrupt->u.Interrupt.Affinity;

        //
        // Initialize the interrupt object for the controller.
        //

        HcResources->InterruptObject = NULL;
        HcResources->ShareIRQ =
            interrupt->ShareDisposition == CmResourceShareShared ? TRUE : FALSE;
        HcResources->InterruptMode =
            interrupt->Flags == CM_RESOURCE_INTERRUPT_LATCHED ?
                Latched :
                LevelSensitive;

#ifdef DEBUG
        USBPORT_KdPrint((2, "'interrupt->ShareDisposition %x\n", interrupt->ShareDisposition));
        if (!HcResources->ShareIRQ) {
            TEST_TRAP();
        }
#endif
    }

USBPORT_GetResources_Done:

    TEST_PATH(ntStatus, FAILED_GETRESOURCES);

    USBPORT_KdPrint((2, "'exit USBPORT_GetResources (%x)\n", ntStatus));
    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'GRSd', 0, 0, ntStatus);

    return ntStatus;
}


NTSTATUS
USBPORT_FdoStart_Complete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIO_STACK_LOCATION irpStack;
    PKEVENT event = Context;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBPORT_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    // signal the start device dispatch to finsh
    KeSetEvent(event,
               1,
               FALSE);

    // defer completion
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBPORT_FdoPnPIrp(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Process the PNP IRPs sent to the FDO for the host
    controller.

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;
    BOOLEAN hardwarePresent = TRUE;

    USBPORT_KdPrint((2, "'IRP_MJ_PNP %x\n", FdoDeviceObject));

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'fPnP', irpStack->MinorFunction, 0, 0);

    switch (irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
        {
        KEVENT pnpStartEvent;

        KeInitializeEvent(&pnpStartEvent,
                          NotificationEvent,
                          FALSE);

        // pass on to host controllers PDO
        ntStatus =
            USBPORT_PassIrp(FdoDeviceObject,
                            USBPORT_FdoStart_Complete,
                            &pnpStartEvent,
                            TRUE,
                            TRUE,
                            TRUE,
                            Irp);

        if (ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(
                       &pnpStartEvent,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        TEST_PATH(ntStatus, FAILED_LOWER_START);

        if (NT_SUCCESS(ntStatus)) {

            //
            // irp completed succesfully by lower
            // drivers, start usbport and miniport
            //

            ntStatus =
                USBPORT_DeferredStartDevice(
                    FdoDeviceObject,
                    Irp);

#if DBG
            if (!NT_SUCCESS(ntStatus)) {
                USBPORT_KdPrint((1, "'miniport failed start %x\n", ntStatus));
                DEBUG_BREAK();
            }
#endif
        }
#if DBG
          else {
            USBPORT_KdPrint((1, "'lower drivers failed start %x\n", ntStatus));
            DEBUG_BREAK();
        }
#endif

        //
        // we must complete this irp since we defrerred completion
        // with the completion routine.
        //

        USBPORT_CompleteIrp(FdoDeviceObject,
                            Irp,
                            ntStatus,
                            0);

        goto USBPORT_ProcessPnPIrp_Done;

        }
        break;

    //
    // STOP & REMOVE messages unload the driver
    // when we get a STOP message it is still possible
    // touch the hardware, when we get a REMOVE message
    // we have to assume that the hardware is gone.
    //

    case IRP_MN_STOP_DEVICE:

        // check our state and take appropriate action
        if (TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED)) {
            // device is started, stop it now
            ntStatus = USBPORT_StopDevice(FdoDeviceObject,
                                          hardwarePresent);

            // not started flag, note: not started is not the
            // same as stopped
            CLEAR_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED);
            SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STOPPED);
        }

        if (!NT_SUCCESS(ntStatus)) {
            // bugbug what is our state if stop fails?
            TEST_TRAP();
        }

        // PnP commandment: Thou shalt not fail stop.
        Irp->IoStatus.Status =
            ntStatus = STATUS_SUCCESS;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'STOP', 0,
            devExt->PnpStateFlags, ntStatus);
        // Pass on to PDO
        break;

     case IRP_MN_QUERY_DEVICE_RELATIONS:

        {

        PDEVICE_RELATIONS deviceRelations;

        USBPORT_KdPrint((1,
            "'IRP_MN_QUERY_DEVICE_RELATIONS %x %x\n",
            FdoDeviceObject,
            irpStack->Parameters.QueryDeviceRelations.Type));

        ntStatus = STATUS_SUCCESS;

        switch(irpStack->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:

            // query relations.
            // we report only one child, the root hub

            // assume success
            ntStatus = STATUS_SUCCESS;

            ALLOC_POOL_OSOWNED(deviceRelations,
                               PagedPool,
                               sizeof(*deviceRelations));

            if (!deviceRelations) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                // Complete the Irp now with failure, don't pass it down.
                //
                USBPORT_CompleteIrp(FdoDeviceObject,
                                    Irp,
                                    ntStatus,
                                    0);

                goto USBPORT_ProcessPnPIrp_Done;
            }

            if (devExt->Fdo.RootHubPdo == NULL) {
                // we either have not created it or the current one
                // has been removed by the OS.

                // create a new root hub
                ntStatus =
                    USBPORT_CreateRootHubPdo(FdoDeviceObject,
                                             &devExt->Fdo.RootHubPdo);

            }

            if (NT_SUCCESS(ntStatus)) {

                PDEVICE_EXTENSION rhDevExt;
                KIRQL irql;

                GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
                ASSERT_PDOEXT(rhDevExt);

                deviceRelations->Count=1;
                deviceRelations->Objects[0] =
                    devExt->Fdo.RootHubPdo;
                ObReferenceObject(devExt->Fdo.RootHubPdo);
                Irp->IoStatus.Information=(ULONG_PTR)deviceRelations;

                // report the same PDO every time ie the PDO is never
                // truely remove until the controller is removed

            } else {
                FREE_POOL(FdoDeviceObject, deviceRelations);
                deviceRelations = NULL;
                // free the device object if we
                // created one
                TEST_TRAP();
            }

            Irp->IoStatus.Status = ntStatus;

            USBPORT_KdPrint((1,
                "'IRP_MN_QUERY_DEVICE_RELATIONS %x BusRelations\n",
                FdoDeviceObject));

            break;

        case TargetDeviceRelation:

            //
            // this one gets passed on
            //

            USBPORT_KdPrint((1,
                " IRP_MN_QUERY_DEVICE_RELATIONS %x, TargetDeviceRelation\n",
                FdoDeviceObject));
            break;

        case RemovalRelations:

            // assume success
            ntStatus = STATUS_SUCCESS;
            deviceRelations = NULL;

            if (USBPORT_IS_USB20(devExt)) {

                deviceRelations =
                    USBPORT_FindCompanionControllers(FdoDeviceObject,
                                                     TRUE,
                                                     FALSE);

                if (!deviceRelations) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                    // Complete the Irp now with failure, don't pass it down.
                    //
                    USBPORT_CompleteIrp(FdoDeviceObject,
                                        Irp,
                                        ntStatus,
                                        0);

                    goto USBPORT_ProcessPnPIrp_Done;
                }
            }

            Irp->IoStatus.Information=(ULONG_PTR)deviceRelations;
            Irp->IoStatus.Status = ntStatus;

            USBPORT_KdPrint((1,
                "'IRP_MN_QUERY_DEVICE_RELATIONS %x RemovalRelations\n",
                FdoDeviceObject));
            break;

        default:
            //
            // some other kind of relations
            // pass this on
            //
            USBPORT_KdPrint((1,
                "'IRP_MN_QUERY_DEVICE_RELATIONS %x, other relations\n",
                FdoDeviceObject));


        } /* case irpStack->Parameters.QueryDeviceRelations.Type */

        }
        break; /* IRP_MN_QUERY_DEVICE_RELATIONS */

    case IRP_MN_SURPRISE_REMOVAL:

        // hardware is gone
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'hcSR', 0, ntStatus, 0);

        USBPORT_KdPrint((1, " HC FDO (%x) surprise removed\n",
                FdoDeviceObject));
        DEBUG_BREAK();

        if (TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_REMOVED)) {

            // it would be odd to get a surprise remove when
            // we are already removed but it would not 'surprise'
            // me if Win2k did this under some cirumstance
            TEST_TRAP();

            ntStatus =
                USBPORT_PassIrp(FdoDeviceObject,
                                NULL,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE,
                                Irp);

            goto USBPORT_ProcessPnPIrp_Done;

        }

        // see if we have an interrupt
        // if so disconnect it
        // **
        // DDK implies that that interrupt resources bust be
        // freed on surprise remove and the PCI driver depends
        // on this.
        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED)) {

            // fortunately this cannot fail
            IoDisconnectInterrupt(devExt->Fdo.InterruptObject);

            LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'IOCd', 0, 0, 0);
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED);
        }

        USBPORT_InvalidateController(FdoDeviceObject,
                                     UsbMpControllerRemoved);

        break;

    case IRP_MN_REMOVE_DEVICE:

        {
        PDEVICE_OBJECT rootHubPdo;
        KIRQL irql;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'hcRM', 0, ntStatus, 0);

        USBPORT_KdPrint((1, " HC FDO (%x) is being removed\n",
                FdoDeviceObject));

        // this device is now 'REMOVED'

        KeAcquireSpinLock(&devExt->PendingRequestSpin.sl, &irql);
        USBPORT_ASSERT(!TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_REMOVED));
        SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_REMOVED);
        KeReleaseSpinLock(&devExt->PendingRequestSpin.sl, irql);

        // if we are started AND
        // we haven't been stopped yet then stop now.
        if (TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED) &&
            !TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STOPPED)) {
            NTSTATUS status;

            status = USBPORT_StopDevice(FdoDeviceObject,
                                        hardwarePresent);

            SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STOPPED);
        }

        //
        // pass on to our PDO
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus =
            USBPORT_PassIrp(FdoDeviceObject,
                            NULL,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE,
                            Irp);

        // bugbug
        // Flush any requests that are still queued in our driver


        // This DEC matches the INC in our add device,
        // this is our last reference and this will cause the
        // transition 0 -> -1 when all irps pending complete
        //
        // after this wait we consider it safe to 'unload'
        DECREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'watP', 0, 0, FdoDeviceObject);
        KeWaitForSingleObject(&devExt->PendingRequestEvent,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'waPD', 0, 0, FdoDeviceObject);

        // last chance to debug with the log
        DEBUG_BREAK();
        USBPORT_LogFree(FdoDeviceObject, &devExt->Log);
        USBPORT_LogFree(FdoDeviceObject, &devExt->TransferLog);
        USBPORT_LogFree(FdoDeviceObject, &devExt->EnumLog);


        //
        // important to detach FDO from PDO after we pass the irp on
        //

        IoDetachDevice(devExt->Fdo.TopOfStackDeviceObject);

        //
        // Delete the device object we created for this controller
        //

        rootHubPdo = devExt->Fdo.RootHubPdo;
        SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_DELETED);
        USBPORT_KdPrint((1, "'Deleting HC FDO (%x) now.\n",
            FdoDeviceObject));
        IoDeleteDevice(FdoDeviceObject);

        // HC is FDO gone so root hub is gone.
        //
        // note: in some cases we may not have a root hub
        // PDO since we create it in response to a QBR.
        if (rootHubPdo != NULL) {
            PDEVICE_EXTENSION rhDevExt;

            GET_DEVICE_EXT(rhDevExt, rootHubPdo);
            ASSERT_PDOEXT(rhDevExt);

            SET_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_DELETED);
            USBPORT_KdPrint((1, "'Deleting root hub PDO (%x) now.\n",
                            rootHubPdo));
            IoDeleteDevice(rootHubPdo);
        }

        goto USBPORT_ProcessPnPIrp_Done;

        }
        break;

    // Quoting from the book of PNP
    //
    // 'The FDO must either fail the IRP or set the
    //  IRP's status if it is not going change the IRP's status
    //  using a completion routine.'

    case IRP_MN_CANCEL_STOP_DEVICE:
        Irp->IoStatus.Status =
            ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'cstp', 0,
            devExt->PnpStateFlags, ntStatus);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        Irp->IoStatus.Status =
            ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'qstp', 0,
            devExt->PnpStateFlags, ntStatus);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        Irp->IoStatus.Status =
            ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'crmv', 0,
            devExt->PnpStateFlags, ntStatus);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        // BUGBUG reverse this in cance query remove?
        if (USBPORT_IS_USB20(devExt)) {
            // make a note on the CCs for this USB 2
            // master controller
            USBPORT_WriteHaction(FdoDeviceObject,
                                 2);
        }

        Irp->IoStatus.Status =
            ntStatus = STATUS_SUCCESS;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'qrmv', 0,
            devExt->PnpStateFlags, ntStatus);
        break;

    //
    // All other PnP messages passed on to our PDO
    //

    default:
        USBPORT_ASSERT(devExt->Fdo.TopOfStackDeviceObject != NULL);
        USBPORT_KdPrint((2, "'UNKNOWN PNP MESSAGE (%x)\n", irpStack->MinorFunction));

        //
        // All unahndled PnP messages are passed on to the PDO
        //

    } /* case PNP minor function */

    //
    // pass on to our PDO
    //
    ntStatus =
            USBPORT_PassIrp(FdoDeviceObject,
                            NULL,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE,
                            Irp);

USBPORT_ProcessPnPIrp_Done:

    // DO NOT touch the Irp from this point on

    return ntStatus;
}


NTSTATUS
USBPORT_DeferredStartDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This function is called as a result of MN_START_DEVICE,
    it is called after successful completion of the START
    irp by the lower drivers.

Arguments:

    DeviceObject - DeviceObject for this USB controller.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ntStatus = USBPORT_GetResources(FdoDeviceObject,
                                    irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                    &devExt->Fdo.HcResources);

    if (NT_SUCCESS(ntStatus)) {

        // got resources, start the port driver,
        // connect the interrupt and start miniport.
        ntStatus = USBPORT_StartDevice(FdoDeviceObject,
                                       &devExt->Fdo.HcResources);
    }

    if (NT_SUCCESS(ntStatus)) {
        CLEAR_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STOPPED);
        SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED);
        // consider ourselves powered
        //
        // Are we powered if we fail start?
        // PnP sure thinks we are becuse the OS sends power
        // irps. Since we handle this bogus case (ie have hit it)
        // for the OS we just set ourselves to D0 here.

        devExt->CurrentDevicePowerState = PowerDeviceD0;

        if (USBPORT_IS_USB20(devExt)) {
            USBPORT_RegisterUSB2fdo(FdoDeviceObject);

// for some reason we only do this fot XPSP1
// this is really only for the WU install
//            if (USBPORT_IS_USB20(devExt)) {
//                // set the default haction to wait (1) on
//                // successful start
//                USBPORT_WriteHaction(FdoDeviceObject,
//                                     1);
//            }


        } else {
            USBPORT_RegisterUSB1fdo(FdoDeviceObject);
        }

    } else {
        SET_FLAG(devExt->PnpStateFlags, USBPORT_PNP_START_FAILED);
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'dfST', 0, 0, ntStatus);

    return ntStatus;
}


PWCHAR
USB_MakeId(
    PDEVICE_OBJECT FdoDeviceObject,
    PWCHAR IdString,
    PWCHAR Buffer,
    PULONG Length,
    USHORT NullCount,
    USHORT Digits,
    USHORT HexId
    )
/*
    given a wide Id string like "FOOnnnn\0"
    add the HexId value to nnnn as hex
    this string is appended to the buffer passed in

    eg
    in  : FOOnnnn\0 , 0x123A
    out : FOO123A\0
*/
{
#define NIBBLE_TO_HEX( byte ) ((WCHAR)Nibble[byte])
    CONST UCHAR Nibble[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
        'B', 'C', 'D', 'E', 'F'};

    PWCHAR tmp, id;
    PUCHAR p;
    SIZE_T siz, idLen;

    idLen = wcslen(IdString)*sizeof(WCHAR);
    siz = idLen+(USHORT)*Length+(NullCount*sizeof(WCHAR));

    ALLOC_POOL_OSOWNED(tmp, PagedPool, siz);

    if (tmp == NULL) {
        *Length = 0;
    } else {
        // this takes care of the nulls
        RtlCopyMemory(tmp, Buffer, *Length);
        p = (PUCHAR) tmp;
        p += *Length;
        RtlCopyMemory(p, IdString, idLen);
        id = (PWCHAR) p;
        *Length = siz;

        // now convert the vaules
        while (*id != (WCHAR)'n' && Digits) {
            id++;
        }

        switch(Digits) {
        case 2:
            *(id) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+1) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        case 4:
            *(id) = NIBBLE_TO_HEX(HexId >> 12);
            *(id+1) = NIBBLE_TO_HEX((HexId >> 8) & 0x000f);
            *(id+2) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+3) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        }
    }

    if (Buffer != NULL) {
        FREE_POOL(FdoDeviceObject, Buffer);
    }

    return tmp;
#undef NIBBLE_TO_HEX
}



PWCHAR
USBPORT_GetIdString(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Vid,
    USHORT Pid,
    USHORT Rev
    )
/*++

Routine Description:

    Make an id string for PnP

Arguments:

Return Value:

    NT Status code.

--*/

{
    PWCHAR id;
    ULONG length;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // we need to generate the following series of strings

    // USB\\ROOT_HUB&VIDnnnn&PIDnnnn&REVnnnn\0
    // USB\\ROOT_HUB&VIDnnnn&PIDnnnn\0
    // USB\\ROOT_HUB\0\0


    // allocate space for the three id plus a NULL
    id = NULL;
    length = 0;

    // USB\\ROOT_HUB&VIDnnnn&PIDnnnn&REVnnnn\0
    if (USBPORT_IS_USB20(devExt)) {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB20&VIDnnnn\0",
                       id,
                       &length,
                       0,
                       4,  // four digits
                       Vid);
    } else {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB&VIDnnnn\0",
                       id,
                       &length,
                       0,
                       4,  // four digits
                       Vid);
    }

    id = USB_MakeId(FdoDeviceObject,
                   L"&PIDnnnn\0",
                   id,
                   &length,
                   0,
                   4,   // four digits
                   Pid);

    id = USB_MakeId(FdoDeviceObject,
                   L"&REVnnnn\0",
                   id,
                   &length,
                   1,   // add a NULL
                   4,   // four digits
                   Rev);

    // USB\\ROOT_HUB&VIDnnnn&PIDnnnn\0
    if (USBPORT_IS_USB20(devExt)) {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB20&VIDnnnn\0",
                       id,
                       &length,
                       0,
                       4,  // four digits
                       Vid);
    } else {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB&VIDnnnn\0",
                       id,
                       &length,
                       0,
                       4,  // four digits
                       Vid);
    }

    id = USB_MakeId(FdoDeviceObject,
                   L"&PIDnnnn\0",
                   id,
                   &length,
                   1,
                   4,   // four digits
                   Pid);

    // USB\\ROOT_HUB\0\0
    if (USBPORT_IS_USB20(devExt)) {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB20\0",
                       id,
                       &length,
                       2,  // double null
                       0,  // no digits
                       0);
    } else {
        id = USB_MakeId(FdoDeviceObject,
                       L"USB\\ROOT_HUB\0",
                       id,
                       &length,
                       2,  // double null
                       0,  // no digits
                       0);
    }

    return(id);
}


NTSTATUS
USBPORT_PdoPnPIrp(
    PDEVICE_OBJECT PdoDeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Disptach routine for PnP Irps sent to the PDO for the root hub.

    NOTE:
        irps sent to the PDO are always completed by the bus driver

Arguments:

    DeviceObject - Pdo for the root hub

Return Value:

    NTSTATUS

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_CAPABILITIES DeviceCapabilities;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION rhDevExt;
    PDEVICE_OBJECT fdoDeviceObject;
    // return no infornation by default
    ULONG_PTR information;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    fdoDeviceObject = rhDevExt->HcFdoDeviceObject;
    //GET_DEVICE_EXT(devExt, fdoDeviceObject);
    //ASSERT_FDOEXT(devExt);

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // don't stomp the current value unless we
    // have to.
    information = Irp->IoStatus.Information;

    USBPORT_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    // PNP messages for the PDO created for the root hub

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        {
        KIRQL irql;

        USBPORT_KdPrint((1, " Starting Root hub PDO %x\n",
            PdoDeviceObject));
        DEBUG_BREAK();
        INCREMENT_PENDING_REQUEST_COUNT(PdoDeviceObject, NULL);

        // first create the 'Device'
        ntStatus = USBPORT_RootHub_CreateDevice(fdoDeviceObject,
                                                PdoDeviceObject);

        //
        // create a symbolic link for the root hub PDO
        // USBUI uses this link to talk to the hub
        //

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBPORT_SymbolicLink(TRUE,
                                            rhDevExt,
                                            PdoDeviceObject,
                                            (LPGUID)&GUID_CLASS_USBHUB);
        }

        if (NT_SUCCESS(ntStatus)) {
            // erases remove and stop flags
            rhDevExt->PnpStateFlags = USBPORT_PNP_STARTED;
            // consider ourselves powered when started
            rhDevExt->CurrentDevicePowerState = PowerDeviceD0;
        }
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        {
        PDEVICE_EXTENSION devExt;
        KIRQL irql;

        USBPORT_KdPrint((1, " Root Hub PDO (%x) is being removed\n",
                PdoDeviceObject));

        LOGENTRY(NULL, fdoDeviceObject, LOG_PNP, 'rhRM', 0, 0, 0);

        GET_DEVICE_EXT(devExt, rhDevExt->HcFdoDeviceObject);
        ASSERT_FDOEXT(devExt);

        // stop if necessary
        USBPORT_StopRootHubPdo(fdoDeviceObject,
                               PdoDeviceObject);


        // when is a remove not a remove?  when PnP sends it.
        // this flag will be reset when the root hub pdo is
        // started
        SET_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_REMOVED);


        // since the PnP convention is for the PDO to exist
        // as long as the physical device exists we do not
        // delete the root hub PDO until the controller is
        // removed.

        // we will call this off just to gixe us a defined state
        rhDevExt->CurrentDevicePowerState = PowerDeviceD3;

        ntStatus = STATUS_SUCCESS;
        }
        break;

    case IRP_MN_STOP_DEVICE:

        // note: since OS PnP will STOP things that are not STARTED
        // we maintain two separate flags for this.
        //
        // the state machine looks like this:
        //
        //
        //         /  Started    \
        //  stop  =               = stopped
        //         \ Not Started /


        USBPORT_KdPrint((1, " Root Hub PDO %x is being stopped\n",
                PdoDeviceObject));

        USBPORT_StopRootHubPdo(fdoDeviceObject,
                               PdoDeviceObject);

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        //
        // Handle query caps for the root hub PDO
        //

        USBPORT_KdPrint((1, "'IRP_MN_QUERY_CAPABILITIES (rh PDO)\n"));

        //
        // Get the packet.
        //
        DeviceCapabilities =
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // The power state capabilities for the root
        // hub are based on those of the host controller.
        //
        // We then modify them based on the power rules of
        // USB
        //

        RtlCopyMemory(DeviceCapabilities,
                      &rhDevExt->DeviceCapabilities,
                      sizeof(*DeviceCapabilities));

        ntStatus = STATUS_SUCCESS;

        break;

    case IRP_MN_QUERY_ID:

        USBPORT_KdPrint((3, "'IOCTL_BUS_QUERY_ID\n"));

        ntStatus = STATUS_SUCCESS;

        switch (irpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:

            // return the 'generic' root hub ID
            {
            PWCHAR deviceId;
            WCHAR rootHubDeviceId[] = L"USB\\ROOT_HUB\0";
            WCHAR rootHubDeviceId_20[] = L"USB\\ROOT_HUB20\0";
            PWCHAR id;
            ULONG siz;
            PDEVICE_EXTENSION devExt;

            GET_DEVICE_EXT(devExt, fdoDeviceObject);
            ASSERT_FDOEXT(devExt);

            id = &rootHubDeviceId[0];
            siz = sizeof(rootHubDeviceId);
            if (USBPORT_IS_USB20(devExt)) {
                id = &rootHubDeviceId_20[0];
                siz = sizeof(rootHubDeviceId_20);
            }

            ALLOC_POOL_OSOWNED(deviceId,
                               PagedPool,
                               siz);

            if (deviceId) {
                RtlCopyMemory(deviceId,
                              id,
                              siz);
            }
            // device id for root hub is USB\ROOT_HUB
            information = (ULONG_PTR) deviceId;
            }
            LOGENTRY(NULL, fdoDeviceObject, LOG_PNP, 'DVid', information, 0, 0);

            break;

        case BusQueryHardwareIDs:

            {
            PDEVICE_EXTENSION devExt;

            //
            // generate hardware id for root hub
            //
            // A host controllers root hub VID,PID,REV is derived
            // from the controllers PCI VID,DEV,REV  that is:
            // root hub VID = hc VID (vendor id)
            // root hub PID = hc DEV (device id)
            // root hub REV = hc REV (revision id)
            //
            // this allows filter drivers to be loaded on
            // specific root hub instances.

            // for HW IDs we generate:
            // USB\PORT_ROOT_HUB&VIDnnnn&PIDnnnn&REVnnnn
            // USB\PORT_ROOT_HUB&VIDnnnn&PIDnnnn
            // USB\PORT_ROOT_HUB
            //
            GET_DEVICE_EXT(devExt, fdoDeviceObject);
            ASSERT_FDOEXT(devExt);

            information =
                (ULONG_PTR) USBPORT_GetIdString(
                    fdoDeviceObject,
                    devExt->Fdo.PciVendorId,
                    devExt->Fdo.PciDeviceId,
                    (USHORT) devExt->Fdo.PciRevisionId);

            LOGENTRY(NULL, fdoDeviceObject, LOG_PNP, 'HWid', information, 0, 0);

            }

            break;

         case BusQueryCompatibleIDs:
            information = 0;
            break;

        case BusQueryInstanceID:
            //
            // The root HUB is instanced solely by the controller's id.
            // Hence the UniqueDeviceId above.
            //
            information = 0;
            break;

        default:
            ntStatus = Irp->IoStatus.Status;
            break;
        }

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
        {
        // return the standard USB GUID
        PPNP_BUS_INFORMATION busInfo;

        ALLOC_POOL_OSOWNED(busInfo, PagedPool,
                           sizeof(PNP_BUS_INFORMATION));

        if (busInfo == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = 0;

            ntStatus = STATUS_SUCCESS;
            information = (ULONG_PTR) busInfo;
        }
        }
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        USBPORT_KdPrint((1," IRP_MN_QUERY_DEVICE_RELATIONS (PDO) %x %x\n",
                PdoDeviceObject,
                irpStack->Parameters.QueryDeviceRelations.Type));

        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;

            ALLOC_POOL_OSOWNED(deviceRelations, PagedPool, sizeof(*deviceRelations));

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                // return a reference to ourselves
                deviceRelations->Count = 1;
                ObReferenceObject(PdoDeviceObject);
                deviceRelations->Objects[0] =
                    PdoDeviceObject;
                ntStatus = STATUS_SUCCESS;
            }

            USBPORT_KdPrint((1, " TargetDeviceRelation to Root Hub PDO - complt\n"));

            information = (ULONG_PTR) deviceRelations;

        } else {
            ntStatus = Irp->IoStatus.Status;
            information = Irp->IoStatus.Information;
        }
        break;

    case IRP_MN_QUERY_INTERFACE:

        USBPORT_KdPrint((1," IRP_MN_QUERY_INTERFACE (PDO) %x\n",
                PdoDeviceObject));

        ntStatus =
            USBPORT_GetBusInterface(fdoDeviceObject,
                                    PdoDeviceObject,
                                    Irp);

        break;

   case IRP_MN_SURPRISE_REMOVAL:

        USBPORT_KdPrint((1," IRP_MN_SURPRISE_REMOVAL (PDO) %x\n",
                PdoDeviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    default:
        //
        // default behavior for an unhandled PnP irp is to return the
        // status currently in the irp

        USBPORT_KdPrint((1, " PnP IOCTL(%d) to root hub PDO not handled\n",
            irpStack->MinorFunction));

        ntStatus = Irp->IoStatus.Status;

    } /* switch, PNP minor function */

    USBPORT_CompleteIrp(PdoDeviceObject,
                        Irp,
                        ntStatus,
                        information);

    return ntStatus;
}


NTSTATUS
USBPORT_CreateRootHubPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT *RootHubPdo
    )
/*++

Routine Description:

    Attempt to create the root hub

Arguments:

    *RootHubPdo set to NULL if unsuccessful

Return Value:

    NTSTATUS

--*/
{
    ULONG index = 0;
    UNICODE_STRING rootHubPdoUnicodeString;
    PDEVICE_EXTENSION rhDevExt, devExt;
    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // those who wear priestly robes say we must do this

    do {
        ntStatus =
            USBPORT_MakeRootHubPdoName(FdoDeviceObject,
                                       &rootHubPdoUnicodeString,
                                       index);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus =
                IoCreateDevice(devExt->Fdo.MiniportDriver->DriverObject,
                               sizeof(DEVICE_EXTENSION),
                               &rootHubPdoUnicodeString,
                               FILE_DEVICE_BUS_EXTENDER,
                               0,
                               FALSE,
                               &deviceObject);

            index++;

            // delete the usbicode string we used for the
            // device name -- we don't need it anymore
            RtlFreeUnicodeString(&rootHubPdoUnicodeString);
        }

    } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);


    if (NT_SUCCESS(ntStatus)) {
        if (deviceObject != NULL) {

            rhDevExt = deviceObject->DeviceExtension;
            LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'rPDO', deviceObject, rhDevExt, 0);

            rhDevExt->DummyUsbdExtension = USBPORT_DummyUsbdExtension;
            rhDevExt->Sig = ROOTHUB_DEVICE_EXT_SIG;

            INITIALIZE_PENDING_REQUEST_COUNTER(rhDevExt);

            // transition to -1 means we have no pending requests
            INCREMENT_PENDING_REQUEST_COUNT(deviceObject, NULL);

            // point to our creator
            rhDevExt->HcFdoDeviceObject = FdoDeviceObject;

            // initialize root hub extension
            USBPORT_ComputeRootHubDeviceCaps(FdoDeviceObject,
                                             deviceObject);

            // initialize object
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            deviceObject->Flags |= DO_POWER_PAGABLE;
            deviceObject->StackSize = FdoDeviceObject->StackSize;

        } else {
            TEST_TRAP();
            // sucess but no devobj?
            // we will return an error
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(ntStatus)) {
        *RootHubPdo = deviceObject;
    } else {
        *RootHubPdo = NULL;
    }

    return ntStatus;
}


NTSTATUS
USBPORT_CreatePortFdoSymbolicLink(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Attempt to create a symbolic link for the HC. We use the
    PnP APIs to generate a name based on the USBPORT Host
    Controller Class GUID defined in USB.H

Arguments:

    *RootHubPdo set to NULL if unsuccessful

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);

    ntStatus = USBPORT_SymbolicLink(TRUE,
                                    devExt,
                                    devExt->Fdo.PhysicalDeviceObject,
                                    (LPGUID)&GUID_CLASS_USB_HOST_CONTROLLER);

    return ntStatus;
}


VOID
USBPORT_StopRootHubPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    Attempt to STOP the root hub

Arguments:



Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION rhDevExt, devExt;

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // disable the root hub notification interrupt
    // we won't need it while we are stopped
    MPRH_DisableIrq(devExt);

    // at this point no new notifications can come in for
    // the root hub

    // remove any start callback notifications
    rhDevExt->Pdo.HubInitCallback = NULL;
    rhDevExt->Pdo.HubInitContext = NULL;

    // remove the root hub 'device' the root hub PDO
    // will remain

    if (TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_STARTED)) {
        USBPORT_RootHub_RemoveDevice(FdoDeviceObject,
                                     PdoDeviceObject);

        // stopped = NOT started
        CLEAR_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_STARTED);
    }

    if (TEST_FLAG(rhDevExt->Flags, USBPORT_FLAG_SYM_LINK)) {
        USBPORT_SymbolicLink(FALSE,
                             rhDevExt,
                             PdoDeviceObject,
                             (LPGUID)&GUID_CLASS_USBHUB);
    }

    SET_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_STOPPED);

    // resume the controller if it is 'suspended'
    USBPORT_ResumeController(FdoDeviceObject);

}

/*
    Registry Key cache for miniports. Since the miniports cannot read
    the registry from the another thread other than the PNP thread we cache
    the reg values read from PNP start.

    Miniports re-read the registry on a re-start.

*/

PUSBPORT_REG_CACHE_ENTRY
USBPORT_GetCahceEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength
    )
/*++

Routine Description:

    Fetches a registry key value from the cache if there

Arguments:

Return Value:

    returns cached entry or NULL if not found

--*/
{
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION devExt;
    PUSBPORT_REG_CACHE_ENTRY regEntry;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // walk the list
    GET_HEAD_LIST(devExt->Fdo.RegistryCache, listEntry);

    while (listEntry &&
           listEntry != &devExt->Fdo.RegistryCache) {

        regEntry = (PUSBPORT_REG_CACHE_ENTRY) CONTAINING_RECORD(
                    listEntry,
                    struct _USBPORT_REG_CACHE_ENTRY,
                    RegLink);

        ASSERT_REG_CACHE(regEntry);

        if (KeyNameStringLength == regEntry->KeyNameStringLength &&
            SoftwareBranch == regEntry->SoftwareBranch &&
            RtlCompareMemory(regEntry->KeyNameString,
                             KeyNameString,
                             KeyNameStringLength)) {
            USBPORT_KdPrint((1, " reg entry found in cache\n"));
            return  regEntry;
        }

        listEntry = regEntry->RegLink.Flink;
    }

    USBPORT_KdPrint((1, " reg entry not in cache\n"));
    return NULL;
}


NTSTATUS
USBPORT_AddCahcedRegistryKey(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
/*++

Routine Description:

    Adds a reg key value to the cache

Arguments:

Return Value:

    returns STATUS_SUCCESS if the value was added to our cache


--*/
{
    PDEVICE_EXTENSION devExt;
    PUSBPORT_REG_CACHE_ENTRY regEntry;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);


    ALLOC_POOL_Z(regEntry, PagedPool,
                 sizeof(*regEntry)+KeyNameStringLength);

    if (regEntry != NULL) {
        ALLOC_POOL_Z(regEntry->Data, PagedPool, DataLength);
        if (regEntry->Data != NULL) {
            regEntry->Sig = SIG_REG_CACHE;
            regEntry->SoftwareBranch = SoftwareBranch;
            regEntry->KeyNameStringLength;
            regEntry->DataLength = DataLength;
            RtlCopyMemory(regEntry->Data, (PUCHAR)Data, DataLength);
            RtlCopyMemory(&regEntry->KeyNameString[0], KeyNameString,
                    KeyNameStringLength);
            InsertTailList(&devExt->Fdo.RegistryCache, &regEntry->RegLink);

            USBPORT_KdPrint((1, " adding cache reg entry %x\n", regEntry));

            return STATUS_SUCCESS;
        } else {
            FREE_POOL(FdoDeviceObject, regEntry);
        }
    }

    return STATUS_INSUFFICIENT_RESOURCES;

}


NTSTATUS
USBPORT_GetCachedRegistryKeyValueForPdo(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN SoftwareBranch,
    PWCHAR KeyNameString,
    ULONG KeyNameStringLength,
    PVOID Data,
    ULONG DataLength
    )
/*++

Routine Description:

    Fetches a registry key value from the cache since we cannot read
    the registry on a thread other than the PNP,POWER thread

    We cache entries between PNP start and STOP
Arguments:

Return Value:

    returns STATUS_SUCCESS if the value is found in the cache



--*/
{
    PDEVICE_EXTENSION devExt;
    PUSBPORT_REG_CACHE_ENTRY regEntry;
    NTSTATUS ntStatus;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_KdPrint((1, " USBPORT_GetCahcedRegistryKeyValueForPDO\n"));

    // read from the registry if we can
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_ON_PNP_THREAD)) {

        ntStatus = USBPORT_GetRegistryKeyValueForPdo(FdoDeviceObject,
                                                PhysicalDeviceObject,
                                                SoftwareBranch,
                                                KeyNameString,
                                                KeyNameStringLength,
                                                Data,
                                                DataLength);

        if (NT_SUCCESS(ntStatus)) {
            // cache it, if this fails we just return the result
            // of the read
            USBPORT_AddCahcedRegistryKey(
                    FdoDeviceObject,
                    SoftwareBranch,
                    KeyNameString,
                    KeyNameStringLength,
                    Data,
                    DataLength);
        }

        return ntStatus;

    }

    // just read from the cache

    regEntry = USBPORT_GetCahceEntry(FdoDeviceObject,
                                     SoftwareBranch,
                                     KeyNameString,
                                     KeyNameStringLength);
    if (regEntry != NULL) {
        if (regEntry->DataLength <= DataLength) {
            RtlCopyMemory(Data, regEntry->Data, regEntry->DataLength);
            ntStatus = STATUS_SUCCESS;
            TEST_TRAP();
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
    } else {
        ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return ntStatus;

}



VOID
USBPORT_FlushCahcedRegistryKeys(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Flushes cache. Removes all cached registry keys.

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    PUSBPORT_REG_CACHE_ENTRY regEntry;
    PLIST_ENTRY listEntry;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    while (!IsListEmpty(&devExt->Fdo.RegistryCache)) {
        listEntry = RemoveHeadList(&devExt->Fdo.RegistryCache);

        regEntry = (PUSBPORT_REG_CACHE_ENTRY) CONTAINING_RECORD(
                    listEntry,
                    struct _USBPORT_REG_CACHE_ENTRY,
                    RegLink);

        ASSERT_REG_CACHE(regEntry);

        FREE_POOL(FdoDeviceObject, regEntry->Data);
        FREE_POOL(FdoDeviceObject, regEntry);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\roothub.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    roothub.c

Abstract:

    root hub emultation code for usbport driver

Environment:

    kernel mode only

Notes:

Revision History:

   6-21-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_RootHub_CreateDevice)
#pragma alloc_text(PAGE, USBPORT_RootHub_RemoveDevice)
#endif

// non paged functions
// USBPORT_RootHub_StandardCommand
// USBPORT_RootHub_ClassCommand
// USBPORT_RootHub_Endpoint0
// USBPORT_RootHub_Endpoint1
// USBPORT_RootHub_EndpointWorker
// USBPORT_SetBit
// USBPORTSVC_InvalidateRootHub
// USBPORT_RootHub_PortRequest

#define RH_STANDARD_REQ    0
#define RH_CLASS_REQ       1

#define MIN(x, y)  (((x)<(y)) ? (x) : (y))

//
// HUB feature selectors
//
#define C_HUB_LOCAL_POWER           0
#define C_HUB_OVER_CURRENT          1
#define PORT_CONNECTION             0
#define PORT_ENABLE                 1
#define PORT_SUSPEND                2
#define PORT_OVER_CURRENT           3
#define PORT_RESET                  4
#define PORT_POWER                  8
#define PORT_LOW_SPEED              9
#define C_PORT_CONNECTION           16
#define C_PORT_ENABLE               17
#define C_PORT_SUSPEND              18
#define C_PORT_OVER_CURRENT         19
#define C_PORT_RESET                20


#define HUB_REQUEST_GET_STATUS      0
#define HUB_REQUEST_CLEAR_FEATURE   1
#define HUB_REQUEST_GET_STATE       2
#define HUB_REQUEST_SET_FEATURE     3
#define HUB_REQUEST_GET_DESCRIPTOR  6
#define HUB_REQUEST_SET_DESCRIPTOR  7

// recipient codes in the bRequestType field
#define RECIPIENT_DEVICE      0
#define RECIPIENT_INTRFACE    1
#define RECIPIENT_ENDPOINT    2
#define RECIPIENT_PORT        3

// Descriptor Templates

// the following structures are emulated the same
// way for all port drivers

UCHAR RH_DeviceDescriptor[] = {0x12, //bLength
                               0x01, //bDescrpitorType
                               0x00, 0x01, //bcdUSB
                               0x09, //bDeviceClass
                               0x01, //bDeviceSubClass
                               0x00, //bDeviceProtocol
                               0x08, //bMaxPacketSize0
                               0x00, 0x00, //idVendor
                               0x00, 0x00, //idProduct
                               0x00, 0x00, //bcdDevice
                               0x00, //iManufacturer
                               0x00, //iProduct
                               0x00, //iSerialNumber
                               0x01};//bNumConfigurations

UCHAR RH_ConfigurationDescriptor[] =
                         /* Config Descriptor   */
                        {0x09, //bLength
                         0x02, //bDescriptorType
                         0x19, 0x00, //wTotalLength
                         0x01, //bNumInterfaces
                         0x23, //iConfigurationValue
                         0x00, //iConfiguration
                         0x40, //bmAttributes
                         0x00, //MaxPower

                         /* Interface Descriptor */
                         0x09, //bLength
                         0x04, //bDescriptorType
                         0x00, //bInterfaceNumber
                         0x00, //bAlternateSetting
                         0x01, //bNumEndpoints
                         0x09, //bInterfaceClass
                         0x01, //bInterfaceSubClass
                         0x00, //bInterfaceProtocol
                         0x00, //iInterface

                         /* Endpoint Descriptor  */
                         0x07, //bLength
                         0x05, //bDescriptorType
                         0x81, //bEndpointAddress
                         0x03, //bmAttributes
                         0x08, 0x00, //wMaxPacketSize
                         0x0a};//bInterval

UCHAR RH_HubDescriptor[] =
                      {0x09,  //bLength
                       0x29,  //bDescriptorType
                       0x00,  //bNbrPorts
                       0x00, 0x00, //wHubCharacteristics
                       0x00,  // bPwrOn2PwrGood
                       0x00};  // bHubContrCurrent



#define RH_DEV_TO_HOST      1
#define RH_HOST_TO_DEV      0


RHSTATUS
USBPORT_RootHub_PortRequest(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PORT_OPERATION PortOperation
    )
/*++

Routine Description:

    Process a standard command sent on the control endpoint
    of the root hub.

Arguments:

    SetupPacket - pointer to a SetupPacket packet

Return Value:

    Root Hub status code.

--*/
{
    PVOID descriptor = NULL;
    ULONG length;
    RHSTATUS rhStatus = RH_STALL;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rSCM', SetupPacket, 0, 0);

    if (SetupPacket->wIndex.W > 0 &&
        SetupPacket->wIndex.W <= NUMBER_OF_PORTS(rhDevExt)) {

        USB_MINIPORT_STATUS mpStatus;

        switch(PortOperation) {
        case SetFeaturePortReset:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortReset(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case SetFeaturePortPower:
            if (USBPORT_IS_USB20(devExt)) {
                mpStatus = USBPORT_RootHub_PowerUsb2Port(FdoDeviceObject,
                                                         SetupPacket->wIndex.W);
            } else if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC)) {
                mpStatus = USBPORT_RootHub_PowerUsbCcPort(FdoDeviceObject,
                                                          SetupPacket->wIndex.W);
            } else {
                mpStatus =
                    devExt->Fdo.MiniportDriver->
                        RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                    devExt->Fdo.MiniportDeviceData,
                                                    SetupPacket->wIndex.W);
            }
            break;
        case SetFeaturePortEnable:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case SetFeaturePortSuspend:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortEnable:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortPower:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortConnectChange:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortResetChange:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortEnableChange:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortSuspend:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortSuspendChange:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        case ClearFeaturePortOvercurrentChange:
            mpStatus =
                devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                SetupPacket->wIndex.W);
            break;
        default:
            mpStatus = USBMP_STATUS_FAILURE;
            DEBUG_BREAK();
        }

        rhStatus = MPSTATUS_TO_RHSTATUS(mpStatus);

    } else {
        rhStatus = RH_STALL;
        DEBUG_BREAK();
    }

    return rhStatus;
}


RHSTATUS
USBPORT_RootHub_HubRequest(
    PDEVICE_OBJECT FdoDeviceObject,
    PORT_OPERATION PortOperation
    )
/*++

Routine Description:

    Process a standard command sent on the control endpoint
    of the root hub.

Arguments:

    SetupPacket - pointer to a SetupPacket packet

Return Value:

    Root Hub status code.

--*/
{
    RHSTATUS rhStatus = RH_STALL;
    PDEVICE_EXTENSION devExt, rhDevExt;
    USB_MINIPORT_STATUS mpStatus;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'hSCM', 0, 0, 0);

    switch(PortOperation) {
    case ClearFeaturePortOvercurrentChange:
        mpStatus =
            devExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange(
                                            devExt->Fdo.MiniportDeviceData,
                                            0);
        rhStatus = MPSTATUS_TO_RHSTATUS(mpStatus);
        break;
    }

    return rhStatus;

}


RHSTATUS
USBPORT_RootHub_StandardCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PUCHAR Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    Process a standard command sent on the control endpoint
    of the root hub.

Arguments:

    SetupPacket - pointer to a SetupPacket packet

Return Value:

    Root Hub status code.

--*/
{
    PVOID descriptor = NULL;
    ULONG length;
    RHSTATUS rhStatus = RH_STALL;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rSCM', SetupPacket, 0, 0);

    //
    // switch on the command
    //
    switch (SetupPacket->bRequest) {
    case USB_REQUEST_SET_ADDRESS:
        //
        //
        //
        if (SetupPacket->wIndex.W == 0 &&
            SetupPacket->wLength == 0 &&
            SetupPacket->bmRequestType.Dir == RH_HOST_TO_DEV) {
            rhDevExt->Pdo.RootHubDeviceHandle.DeviceAddress =
                    (UCHAR)SetupPacket->wValue.W;

            rhStatus = RH_SUCCESS;
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rSAD', 0, 0, 0);
        }
        break;

    case USB_REQUEST_GET_DESCRIPTOR:
        {
            ULONG siz;
            UCHAR descriptorIndex, descriptorType;

            descriptorType = (UCHAR) SetupPacket->wValue.HiByte;
            descriptorIndex = (UCHAR) SetupPacket->wValue.LowByte;

            switch (descriptorType) {

            case USB_DEVICE_DESCRIPTOR_TYPE:
                if (descriptorIndex == 0 &&
                    SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

                    siz = sizeof(RH_DeviceDescriptor);
                    // use PDO specific copy
                    descriptor = rhDevExt->Pdo.DeviceDescriptor;
                    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rGDS', descriptor, siz, 0);
                }
                break;

            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (descriptorIndex == 0 &&
                    SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {
                    siz = sizeof(RH_ConfigurationDescriptor);
                    // use pdo specific copy
                    descriptor = rhDevExt->Pdo.ConfigurationDescriptor;
                    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rGCS', descriptor, siz, 0);
                }
                break;

            //
            // BUGBUG these descriptor types not handled
            //
            case USB_STRING_DESCRIPTOR_TYPE:
                // we will stall
                TEST_TRAP();
            default:
                // we will stall
                DEBUG_BREAK();
            } /* descriptorType */

            if (descriptor) {

                length = MIN(*BufferLength, siz);

                RtlCopyMemory(Buffer, descriptor, length);
                *BufferLength = length;
                rhStatus = RH_SUCCESS;
            }
        }
        break;

    case USB_REQUEST_GET_STATUS:
        //
        // get_device_status
        //
        // report that we are self powered
        //
        // BUGBUG
        // are we self powered?
        // are we a remote wakeup source?
        //
        // see section 9.4.5 USB 1.0 spec
        //
        {
        PUSHORT status = (PUSHORT) Buffer;

        if (SetupPacket->wValue.W == 0 &&   //mbz
            SetupPacket->wLength == 2 &&
            SetupPacket->wIndex.W == 0 &&   //device
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

            USB_MINIPORT_STATUS mpStatus;

            MPRH_GetStatus(devExt, status, mpStatus);

            *BufferLength = sizeof(*status);

            rhStatus = MPSTATUS_TO_RHSTATUS(mpStatus);
        }
        }
        break;

    case USB_REQUEST_GET_CONFIGURATION:
        //
        // get_device_configuration
        //
        if (SetupPacket->wValue.W == 0 &&   //mbz
            SetupPacket->wIndex.W == 0 &&   //mbz
            SetupPacket->wLength == 1 &&
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {

            length = MIN(*BufferLength, sizeof(rhDevExt->Pdo.ConfigurationValue));
            RtlCopyMemory(Buffer, &rhDevExt->Pdo.ConfigurationValue, length);
            *BufferLength = length;
            rhStatus = RH_SUCCESS;
        }
        break;

    case USB_REQUEST_CLEAR_FEATURE:
        // bugbug, required
        TEST_TRAP();
        break;

    case USB_REQUEST_SET_CONFIGURATION:
        {
        PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor =
            (PUSB_CONFIGURATION_DESCRIPTOR) RH_ConfigurationDescriptor;

        if (SetupPacket->wIndex.W == 0 &&   // mbz
            SetupPacket->wLength == 0 &&  // mbz
            SetupPacket->bmRequestType.Dir == RH_HOST_TO_DEV &&
            (SetupPacket->wValue.W ==
                configurationDescriptor->bConfigurationValue ||
             SetupPacket->wValue.W == 0)) {

            rhDevExt->Pdo.ConfigurationValue =
                (UCHAR) SetupPacket->wValue.W;
            rhStatus = RH_SUCCESS;
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rSEC',
                rhDevExt->Pdo.ConfigurationValue, 0, 0);
        }
        }
        break;
    case USB_REQUEST_SET_FEATURE:
        // bugbug, required
        TEST_TRAP();
        break;
    //
    // these commands are optional for the hub
    //
    case USB_REQUEST_SET_DESCRIPTOR:
    case USB_REQUEST_SET_INTERFACE:
    case USB_REQUEST_GET_INTERFACE:
    case USB_REQUEST_SYNC_FRAME:
    default:
        // bad command, probably a bug in the
        // hub driver
        DEBUG_BREAK();
        break;
    }

    return rhStatus;
}


RHSTATUS
USBPORT_RootHub_ClassCommand(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSB_DEFAULT_PIPE_SETUP_PACKET SetupPacket,
    PUCHAR Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    Process a hub class command to the root hub control endpoint.

Arguments:

Return Value:

    Root Hub status code.

--*/
{
    PVOID descriptor = NULL;
    ULONG length;
    RHSTATUS rhStatus = RH_STALL;
    PDEVICE_EXTENSION devExt, rhDevExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rCCM', SetupPacket, 0, 0);

    //
    // switch on the command
    //

    switch (SetupPacket->bRequest) {
    case HUB_REQUEST_GET_STATUS:
        //
        //
        //
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // get port status
            //
            PRH_PORT_STATUS portStatus;
            //
            // see if we have a valid request
            //

            if (Buffer != NULL &&
                SetupPacket->wIndex.W > 0 &&
                SetupPacket->wIndex.W <= NUMBER_OF_PORTS(rhDevExt) &&
                SetupPacket->wLength >= sizeof(*portStatus)) {

                USB_MINIPORT_STATUS mpStatus;

                USBPORT_ASSERT(sizeof(*portStatus) == 4);
                USBPORT_ASSERT(*BufferLength >= sizeof(*portStatus));
                portStatus = (PRH_PORT_STATUS) Buffer;
                RtlZeroMemory(Buffer, sizeof(*portStatus));

                MPRH_GetPortStatus(devExt,
                                   SetupPacket->wIndex.W,
                                   portStatus,
                                   mpStatus);

                rhStatus = MPSTATUS_TO_RHSTATUS(mpStatus);
            }
        } else {

            //
            // get hub status
            //
            USB_MINIPORT_STATUS mpStatus;
            PRH_HUB_STATUS hubStatus;

            if (Buffer != NULL) {
                USBPORT_ASSERT(sizeof(*hubStatus) == 4);
                USBPORT_ASSERT(*BufferLength >= sizeof(*hubStatus));
                hubStatus = (PRH_HUB_STATUS) Buffer;
                    RtlZeroMemory(Buffer, sizeof(*hubStatus));

                MPRH_GetHubStatus(devExt, hubStatus, mpStatus);

                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rGHS',
                    *((PULONG) hubStatus), 0, 0);

                rhStatus = MPSTATUS_TO_RHSTATUS(mpStatus);
            }

        }
        break;

    case HUB_REQUEST_CLEAR_FEATURE:
        //
        // Hub/Port Clear Feature
        //
        LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rCFR',
            SetupPacket->bmRequestType.Recipient, 0, 0);
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // clear port feature
            //
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rCPR',
                SetupPacket->wValue.W, 0, 0);
            switch(SetupPacket->wValue.W) {
                //
                //
                //
            case PORT_ENABLE:

                // disable the port
                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortEnable);

                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rDsP',
                    SetupPacket->wIndex.W, 0, rhStatus);
                break;

            case PORT_POWER:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortPower);

                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rDpP',
                    SetupPacket->wIndex.W, 0, rhStatus);
                break;
            //
            // the following are not valid commands,
            // return a stall since that is most likely
            // what a real hub would do
            //
            case PORT_CONNECTION:
            case PORT_OVER_CURRENT:
            case PORT_LOW_SPEED:
            case PORT_RESET:
                DEBUG_BREAK();
                break;

            case C_PORT_CONNECTION:

                 rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortConnectChange);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfCC',
                        SetupPacket->wIndex.W, 0, rhStatus);
                break;

            case C_PORT_ENABLE:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortEnableChange);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfEC',
                        SetupPacket->wIndex.W, 0, rhStatus);

                break;

            case C_PORT_RESET:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortResetChange);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfRC',
                        SetupPacket->wIndex.W, 0, rhStatus);

                break;

            case PORT_SUSPEND:

                // clearing port suspend generates resume signalling
                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortSuspend);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfPS',
                        SetupPacket->wIndex.W, 0, rhStatus);

                break;

            case C_PORT_SUSPEND:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortSuspendChange);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfPS',
                        SetupPacket->wIndex.W, 0, rhStatus);

                break;

            case C_PORT_OVER_CURRENT:

                // overcuurent generated on NEC machines for ports with
                // no device attached.  We want to find out:
                // 1. Does the port still function - Yes
                // 2. Does the UI popup No
                // the overcurrent occurs on the port with no device connected
                // and the system in question has only one USB port.

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                ClearFeaturePortOvercurrentChange);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'cfOC',
                        SetupPacket->wIndex.W, 0, rhStatus);

                break;
            default:
                DEBUG_BREAK();
            }
        } else {
            //
            // clear hub feature
            //
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rCHR', SetupPacket->wValue.W, 0, 0);
            switch(SetupPacket->wValue.W) {
            case C_HUB_LOCAL_POWER:
                rhStatus = RH_SUCCESS;
                break;
            case C_HUB_OVER_CURRENT:
                rhStatus =
                    USBPORT_RootHub_HubRequest(FdoDeviceObject,
                                                ClearFeaturePortOvercurrentChange);
                break;
            default:
                DEBUG_BREAK();
            }
        }
        break;

    case HUB_REQUEST_GET_STATE:
        //
        //
        //
        DEBUG_BREAK();
        break;

    case HUB_REQUEST_SET_FEATURE:
        //
        //  Hub/Port feature request
        //
        if (SetupPacket->bmRequestType.Recipient == RECIPIENT_PORT) {
            //
            // set port feature
            //
            switch(SetupPacket->wValue.W) {
            case PORT_RESET:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                SetFeaturePortReset);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'sfPR',
                        SetupPacket->wIndex.W, 0, rhStatus);
                break;

            case PORT_SUSPEND:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                SetFeaturePortSuspend);
                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'sfPS',
                        SetupPacket->wIndex.W, 0, rhStatus);
                break;

            case PORT_ENABLE:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                SetFeaturePortEnable);

                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'sfPE',
                        SetupPacket->wIndex.W, 0, rhStatus);
                break;

            case PORT_POWER:

                rhStatus =
                    USBPORT_RootHub_PortRequest(FdoDeviceObject,
                                                SetupPacket,
                                                SetFeaturePortPower);

                LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'sfPP',
                        SetupPacket->wIndex.W, 0, rhStatus);
                break;
            case PORT_CONNECTION:
            case PORT_OVER_CURRENT:
            case PORT_LOW_SPEED:

            case C_PORT_CONNECTION:
            case C_PORT_ENABLE:
            case C_PORT_SUSPEND:
            case C_PORT_OVER_CURRENT:
            case C_PORT_RESET:
            default:
                DEBUG_BREAK();
            }
        } else {
            //
            // set hub feature
            //
            switch(SetupPacket->wValue.W) {
            case C_HUB_LOCAL_POWER:
            case C_HUB_OVER_CURRENT:
            default:
                DEBUG_BREAK();
            }

        }
        break;

    case HUB_REQUEST_GET_DESCRIPTOR:
        //
        // return the hub descriptor
        //
        if (Buffer != NULL &&
            SetupPacket->wValue.W == 0 &&
            // we already know it is a class command
            SetupPacket->bmRequestType.Dir == RH_DEV_TO_HOST) {
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rGHD', SetupPacket, SetupPacket->wLength, 0);

            length = MIN(*BufferLength, HUB_DESRIPTOR_LENGTH(rhDevExt));

            RtlCopyMemory(Buffer, rhDevExt->Pdo.HubDescriptor, length);
            *BufferLength = length;
            rhStatus = RH_SUCCESS;
        }
        break;

    case HUB_REQUEST_SET_DESCRIPTOR:
        //
        //
        //
        TEST_TRAP();
        break;

    default:
        // bad command
        DEBUG_BREAK();
        break;
    }

    return rhStatus;
}


VOID
USBPORT_SetBit(
    PVOID Bitmap,
    ULONG BitNumber
    )
/* ++

   Description:

   Set a bit in a given a string of bytes.

   Arguments:

   Return:

-- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PULONG l = (PULONG) Bitmap;


    dwordOffset = BitNumber / 32;
    bitOffset = BitNumber % 32;

    l[dwordOffset] |= (1 << bitOffset);
}


RHSTATUS
USBPORT_RootHub_Endpoint1(
    PHCD_TRANSFER_CONTEXT Transfer
    )
/*++

Routine Description:

    simulates an interrupt transfer

Arguments:

Return Value:

    root hub transfer status code

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION rhDevExt, devExt;
    RHSTATUS rhStatus;
    ULONG need;
    RH_HUB_STATUS hubStatus;
    PHCD_ENDPOINT endpoint;
    PTRANSFER_URB urb;
    PVOID buffer;
    USB_MINIPORT_STATUS mpStatus;
    ULONG i;

    ASSERT_TRANSFER(Transfer);

    // assume no change
    rhStatus = RH_NAK;

    endpoint = Transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    fdoDeviceObject = endpoint->FdoDeviceObject;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CONTROLLER_GONE)) {
        return rhStatus;
    }

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(rhDevExt->Pdo.HubInitCallback == NULL);

    // validate the buffer length
    urb = Transfer->Urb;
    buffer = Transfer->Tp.TransferBufferLength ?
                urb->TransferBufferMDL->MappedSystemVa :
                NULL;

    // compute how many bytes do we need to report a status
    // change for any port
    // 0,1-7  = 1
    // 8-15 = 2

    need = (NUMBER_OF_PORTS(rhDevExt)/8)+1;

    if (buffer == NULL ||
        Transfer->Tp.TransferBufferLength < need) {

        DEBUG_BREAK();
        rhStatus = RH_STALL;
        goto USBPORT_RootHub_Endpoint1_Done;
    }

    // zero buffer in case hub driver did not
    RtlZeroMemory(buffer, Transfer->Tp.TransferBufferLength);

    // get the current port status and
    // construct a bitmask of changed ports

    for (i=0; i< NUMBER_OF_PORTS(rhDevExt); i++) {

        RH_PORT_STATUS portStatus;

        // usb spec does not allow more than 255 ports
        USBPORT_ASSERT(i<256);
        MPRH_GetPortStatus(devExt, (USHORT)(i+1), &portStatus, mpStatus);

        LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'gPS+', portStatus.ul,
            mpStatus, i+1);

        if (mpStatus != USBMP_STATUS_SUCCESS ) {
            DEBUG_BREAK();
            rhStatus = RH_STALL;
            goto USBPORT_RootHub_Endpoint1_Done;
        }

        if (portStatus.ConnectChange ||
            portStatus.EnableChange ||
            portStatus.SuspendChange ||
            portStatus.OverCurrentChange ||
            portStatus.ResetChange) {

            USBPORT_SetBit(buffer,
                           i+1);
            rhStatus = RH_SUCCESS;
        }
    }

    //
    // We created a bit map (base of 1 not 0) listing whether or not
    // change has occurred on any of the down stream ports of the
    // root hub.

    // Bit 0 is reserved for the status change of the hub itself.
    //

    MPRH_GetHubStatus(devExt, &hubStatus, mpStatus);

    if (mpStatus != USBMP_STATUS_SUCCESS ) {
        DEBUG_BREAK();
        rhStatus = RH_STALL;
        goto USBPORT_RootHub_Endpoint1_Done;
    }

    if (hubStatus.LocalPowerChange ||
        hubStatus.OverCurrentChange) {

        USBPORT_SetBit(buffer,
                       0);
        rhStatus = RH_SUCCESS;
    }

    switch (rhStatus) {
    case RH_NAK:
        // we have a transfer pending but no changes yet
        // enable the controller to generate an interrupt
        // if a root hub change occurs
        MPRH_EnableIrq(devExt);
        break;

    case RH_SUCCESS:

        // set bytes transferred for this interrupt
        // endpoint
        urb->TransferBufferLength =
            Transfer->Tp.TransferBufferLength;
        break;

    case RH_STALL:
        DEBUG_BREAK();
        break;
    }

USBPORT_RootHub_Endpoint1_Done:

    return rhStatus;
}


RHSTATUS
USBPORT_RootHub_Endpoint0(
    PHCD_TRANSFER_CONTEXT Transfer
    )
/*++

Routine Description:

Arguments:

Return Value:

    root hub transfer status code

--*/
{
    RHSTATUS rhStatus;
    PTRANSFER_URB urb;
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    PUCHAR buffer;
    ULONG bufferLength;
    PHCD_ENDPOINT endpoint;
    PDEVICE_OBJECT fdoDeviceObject;

    ASSERT_TRANSFER(Transfer);
    urb = Transfer->Urb;

    endpoint = Transfer->Endpoint;
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    //
    // convert transfer buffer from MDL
    //
    buffer =
        Transfer->Tp.TransferBufferLength ?
            urb->TransferBufferMDL->MappedSystemVa :
            NULL;
    bufferLength = Transfer->Tp.TransferBufferLength;

    setupPacket = (PUSB_DEFAULT_PIPE_SETUP_PACKET)
        &urb->u.SetupPacket[0];

    if (setupPacket->bmRequestType.Type == RH_STANDARD_REQ) {
        rhStatus =
            USBPORT_RootHub_StandardCommand(fdoDeviceObject,
                                            setupPacket,
                                            buffer,
                                            &bufferLength);
        if (rhStatus == RH_SUCCESS) {
            // set the return length
            Transfer->MiniportBytesTransferred = bufferLength;
        }

    } else if (setupPacket->bmRequestType.Type == RH_CLASS_REQ) {
        rhStatus =
            USBPORT_RootHub_ClassCommand(fdoDeviceObject,
                                         setupPacket,
                                         buffer,
                                         &bufferLength);
        if (rhStatus == RH_SUCCESS) {
            // set the return length
            Transfer->MiniportBytesTransferred = bufferLength;
        }

    } else {
        rhStatus = RH_STALL;
        // probably a bug in the hub driver
        DEBUG_BREAK();
    }

    return rhStatus;
}


NTSTATUS
USBPORT_RootHub_CreateDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    Create the 'ROOT HUB' USB Device

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION rhDevExt, devExt;
    NTSTATUS ntStatus;
    PUCHAR descriptors;
    ROOTHUB_DATA hubData;
    ULONG hubDescriptorLength, length;
    ULONG i, portbytes;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    USBPORT_ASSERT(devExt->Fdo.RootHubPdo == PdoDeviceObject);

    // init the device handle
    rhDevExt->Pdo.RootHubDeviceHandle.Sig = SIG_DEVICE_HANDLE;
    rhDevExt->Pdo.RootHubDeviceHandle.DeviceAddress = 0;
    rhDevExt->Pdo.RootHubDeviceHandle.ConfigurationHandle = NULL;
    rhDevExt->Pdo.RootHubDeviceHandle.DeviceFlags =
        USBPORT_DEVICEFLAG_ROOTHUB;

    // define root hub speed based on the type of conroller
    if (USBPORT_IS_USB20(devExt)) {
        rhDevExt->Pdo.RootHubDeviceHandle.DeviceSpeed = UsbHighSpeed;
    } else {
        rhDevExt->Pdo.RootHubDeviceHandle.DeviceSpeed = UsbFullSpeed;
    }

    InitializeListHead(&rhDevExt->Pdo.RootHubDeviceHandle.PipeHandleList);
    InitializeListHead(&rhDevExt->Pdo.RootHubDeviceHandle.TtList);

    USBPORT_AddDeviceHandle(FdoDeviceObject,
                            &rhDevExt->Pdo.RootHubDeviceHandle);

    // assume success
    ntStatus = STATUS_SUCCESS;

    // root hub device is not configured yet
    rhDevExt->Pdo.ConfigurationValue = 0;

    // get root hub information from the miniport
    MPRH_GetRootHubData(devExt, &hubData);

    // use hub data to fabricate a hub descriptor
    // figure out how many bytes the variable part
    // it will be based on the nuber of ports
    // ie how many bytes does it take to represent
    // n ports
    // 1-8 ports  = 1 bytes
    // 9-16 ports = 2 bytes
    // 17-24 ports = 3 bytes
    // 25-36 ports = 4 bytes
    //...

    USBPORT_ASSERT(hubData.NumberOfPorts != 0);

    // number of bytes we need to represnt the ports
    portbytes = ((((hubData.NumberOfPorts-1)/8)+1));

    hubDescriptorLength = 7+(portbytes*2);

    length =
        sizeof(RH_ConfigurationDescriptor) +
        sizeof(RH_DeviceDescriptor) +
        hubDescriptorLength;

    // allocate space for our descriports
    ALLOC_POOL_Z(descriptors, NonPagedPool,
                 length);

    if (descriptors) {

        LOGENTRY(NULL, FdoDeviceObject,
            LOG_RH, 'rhDS', descriptors, length, portbytes);

        rhDevExt->Pdo.Descriptors = descriptors;

        // set up device descriptor
        rhDevExt->Pdo.DeviceDescriptor =
            (PUSB_DEVICE_DESCRIPTOR) descriptors;
        descriptors += sizeof(RH_DeviceDescriptor);
        RtlCopyMemory(rhDevExt->Pdo.DeviceDescriptor,
                      &RH_DeviceDescriptor[0],
                      sizeof(RH_DeviceDescriptor));


        // hack it up for USB2
        if (USBPORT_IS_USB20(devExt)) {
            rhDevExt->Pdo.DeviceDescriptor->bcdUSB  = 0x0200;
        }

        // use HC vendor and device for root hub
        rhDevExt->Pdo.DeviceDescriptor->idVendor =
            devExt->Fdo.PciVendorId;
        rhDevExt->Pdo.DeviceDescriptor->idProduct =
            devExt->Fdo.PciDeviceId;

        rhDevExt->Pdo.DeviceDescriptor->bcdDevice =
            devExt->Fdo.PciRevisionId;

        // set up config descriptor
        rhDevExt->Pdo.ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)
            descriptors;
        LOGENTRY(NULL, FdoDeviceObject,
            LOG_RH, 'rhCS', descriptors,0, 0);

        descriptors += sizeof(RH_ConfigurationDescriptor);
        RtlCopyMemory(rhDevExt->Pdo.ConfigurationDescriptor,
                      &RH_ConfigurationDescriptor[0],
                      sizeof(RH_ConfigurationDescriptor));

        // set up the hub descriptor
        rhDevExt->Pdo.HubDescriptor =
            (PUSB_HUB_DESCRIPTOR) descriptors;
        LOGENTRY(NULL, FdoDeviceObject,
            LOG_RH, 'rhHS', descriptors,0, 0);

        RtlCopyMemory(rhDevExt->Pdo.HubDescriptor,
                      &RH_HubDescriptor[0],
                      sizeof(RH_HubDescriptor));

        rhDevExt->Pdo.HubDescriptor->bDescriptorLength =
            hubDescriptorLength;

        rhDevExt->Pdo.HubDescriptor->bNumberOfPorts =
            (UCHAR) hubData.NumberOfPorts;
        rhDevExt->Pdo.HubDescriptor->wHubCharacteristics =
            hubData.HubCharacteristics.us;
        rhDevExt->Pdo.HubDescriptor->bPowerOnToPowerGood =
            hubData.PowerOnToPowerGood;
        rhDevExt->Pdo.HubDescriptor->bHubControlCurrent =
            hubData.HubControlCurrent;

        // fill in the var part
        for (i=0; i<portbytes; i++) {
            rhDevExt->Pdo.HubDescriptor->bRemoveAndPowerMask[i] =
                0;
            rhDevExt->Pdo.HubDescriptor->bRemoveAndPowerMask[i+portbytes] =
                0xff;
        }

        INITIALIZE_DEFAULT_PIPE(rhDevExt->Pdo.RootHubDeviceHandle.DefaultPipe,
                                USB_DEFAULT_MAX_PACKET);

        // init the default pipe
        ntStatus = USBPORT_OpenEndpoint(
                        &rhDevExt->Pdo.RootHubDeviceHandle,
                        FdoDeviceObject,
                        &rhDevExt->Pdo.RootHubDeviceHandle.DefaultPipe,
                        NULL,
                        TRUE);


    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


VOID
USBPORT_RootHub_RemoveDevice(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_OBJECT PdoDeviceObject
    )
/*++

Routine Description:

    Remove the 'ROOT HUB' USB Device

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION rhDevExt;

    LOGENTRY(NULL, FdoDeviceObject,
            LOG_RH, 'rhrm', 0, 0, 0);
    ASSERT_PASSIVE();

    GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
    ASSERT_PDOEXT(rhDevExt);

    // close the current config
    USBPORT_InternalCloseConfiguration(
        &rhDevExt->Pdo.RootHubDeviceHandle,
        FdoDeviceObject,
        0);

    // close the default pipe
    USBPORT_ClosePipe(
                    &rhDevExt->Pdo.RootHubDeviceHandle,
                    FdoDeviceObject,
                    &rhDevExt->Pdo.RootHubDeviceHandle.DefaultPipe);

    USBPORT_RemoveDeviceHandle(FdoDeviceObject,
                               &rhDevExt->Pdo.RootHubDeviceHandle);

    FREE_POOL(FdoDeviceObject, rhDevExt->Pdo.Descriptors);
    rhDevExt->Pdo.Descriptors = USBPORT_BAD_POINTER;
}


VOID
USBPORT_RootHub_EndpointWorker(
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    process transfers for the root hub

Arguments:

Return Value:

    None.

--*/
{
    PIRP irp;
    PLIST_ENTRY listEntry;
    PTRANSFER_URB urb;
    PHCD_TRANSFER_CONTEXT transfer = NULL;
    USBD_STATUS usbdStatus;
    RHSTATUS rhStatus;
    PDEVICE_OBJECT fdoDeviceObject;
    PDEVICE_EXTENSION devExt;

    ASSERT_ENDPOINT(Endpoint);
    fdoDeviceObject = Endpoint->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MP_CheckController(devExt);

    ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'LeA0');

    // Now check the active list, and process
    // the transfers on it
    GET_HEAD_LIST(Endpoint->ActiveList, listEntry);

    if (listEntry) {
        // ACTIVE(r)->
        // extract the urb that is currently on the active
        // list, there should only be one
        transfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_TRANSFER_CONTEXT,
                    TransferLink);
        LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'rACT', transfer, 0, 0);
        ASSERT_TRANSFER(transfer);
    }

    if (transfer) {

        ASSERT_TRANSFER(transfer);

        // is this transfer canceled?
        if ((transfer->Flags & USBPORT_TXFLAG_CANCELED) ||
            (transfer->Flags & USBPORT_TXFLAG_ABORTED)) {
            // yes,
            // just put it on the cancel list
            // since this routine is NOT renetrant
            // it will not be completed

            // remove from active
            RemoveEntryList(&transfer->TransferLink);
            // insert on cancel
            InsertTailList(&Endpoint->CancelList, &transfer->TransferLink);

            // removed from active list
            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeA0');

        } else {

            // transfer is not canceled, process it
            // NOTE: if the transfer is canceled at
            // this point it is only marked since it
            // is on the active list

            RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeA1');
            // relaese the lock no so that the miniport may freely
            // call InvalidateRootHub. Root hub functions so not take
            // the core spinlock

            // call root hub code
            if (Endpoint->Parameters.TransferType == Control) {
                rhStatus = USBPORT_RootHub_Endpoint0(transfer);
            } else {
                rhStatus = USBPORT_RootHub_Endpoint1(transfer);
                // if the interrupt ep nak'ed enable interrupt
                // changes
            }
            LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'ACT+', transfer, rhStatus, 0);

            if (rhStatus != RH_NAK) {

                // transfer is done.
                // NOTE: that donetransfer can only be called from this
                // routine and that this routine is NOT reentrant.
                // Hence, we don't need to worry about race conditions
                // caused by multiple calls to DoneTransfer
                usbdStatus = RHSTATUS_TO_USBDSTATUS(rhStatus);

                // This function expects the endpoint lock to be held
                // although it is not necessary in the case of the root
                // hub
                ACQUIRE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'LeX0');

                USBPORT_QueueDoneTransfer(transfer,
                                          usbdStatus);

                RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeX0');

            }

        }
    } else {
        // transfer queues empty

        if (Endpoint->CurrentState == ENDPOINT_REMOVE) {
             // put the endpoint on the closed list

             LOGENTRY(NULL, fdoDeviceObject, LOG_PNP, 'rmRE', 0, Endpoint, 0);

             ExInterlockedInsertTailList(&devExt->Fdo.EpClosedList,
                                         &Endpoint->ClosedLink,
                                         &devExt->Fdo.EpClosedListSpin.sl);
        }
        RELEASE_ENDPOINT_LOCK(Endpoint, fdoDeviceObject, 'UeA2');
    }

    // flush out canceled requests
    USBPORT_FlushCancelList(Endpoint);

}


VOID
USBPORT_InvalidateRootHub(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Invalidates the state of the root hub, this will
    trigger USBPORT to poll the root hub for any
    changes.

Arguments:

Return Value:

    None.

--*/
{
    PHCD_ENDPOINT endpoint = NULL;
    PDEVICE_EXTENSION devExt, rhDevExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'rhIV', 0, 0, 0);

    // disable the root hub notification interrupt
    MPRH_DisableIrq(devExt);

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SUSPENDED)) {
        USBPORT_HcQueueWakeDpc(FdoDeviceObject);
        return;
    }

    // make sure we have an endpoint
    ACQUIRE_ROOTHUB_LOCK(FdoDeviceObject, irql);
    if (devExt->Fdo.RootHubPdo) {

        GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);

        endpoint = rhDevExt->Pdo.RootHubInterruptEndpoint;

    }
    RELEASE_ROOTHUB_LOCK(FdoDeviceObject, irql);

    // if we have an endpoint, hence, a root hub then
    // process requests
    if (endpoint) {

        USBPORT_InvalidateEndpoint(FdoDeviceObject,
                                   rhDevExt->Pdo.RootHubInterruptEndpoint,
                                   IEP_SIGNAL_WORKER);
    }
}


VOID
USBPORTSVC_InvalidateRootHub(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Service exported to miniports.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'rhNO', 0, 0, 0);

    USBPORT_InvalidateRootHub(fdoDeviceObject);

}


VOID
USBPORT_UserSetRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    ULONG currentFrame, nextFrame;
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    RH_PORT_STATUS portStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserSetRootPortFeature\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'SRpF', 0, Parameters->PortNumber, Parameters->PortFeature);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode =
            usbUserStatus = UsbUserInvalidParameter;
        return;
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    switch(Parameters->PortFeature) {

    case PORT_RESET:
    {
        ULONG loopCount = 0;

        // attempt a reset
        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_SetFeaturePortReset(
                                        devExt->Fdo.MiniportDeviceData,
                                        Parameters->PortNumber);
        // wait for reset change, this process is drive byn the
        // HC root hub hardware or miniport

        do {
/*
            USBPORT_Wait(FdoDeviceObject, 1);
*/
            MP_Get32BitFrameNumber(devExt, currentFrame);
            do {
                MP_Get32BitFrameNumber(devExt, nextFrame);
                if(nextFrame < currentFrame) {
                    // roll-over
                    //
                    currentFrame = nextFrame;
                    MP_Get32BitFrameNumber(devExt, nextFrame);
                }
            } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

            MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);

            loopCount++;

        } while ((portStatus.ResetChange == 0) &&
                 (loopCount < 5));

        // clear the change bit
        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange(
                                        devExt->Fdo.MiniportDeviceData,
                                        Parameters->PortNumber);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;
    }

    case PORT_POWER:

        // power the port
        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);
        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case PORT_ENABLE:

        // enable the port
        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_SetFeaturePortEnable(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);
        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case PORT_SUSPEND:

        // suspend the port
        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_SetFeaturePortSuspend(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);
        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    default:

        usbUserStatus = UsbUserNotSupported;
        break;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'SRp>', 0, 0, usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}

VOID
USBPORT_UserClearRootPortFeature(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBUSER_REQUEST_HEADER Header,
    PRAW_ROOTPORT_FEATURE Parameters
    )
/*++

Routine Description:

    Cycle a specific Root Port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    none.

--*/
{
    ULONG currentFrame, nextFrame;
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USB_USER_ERROR_CODE usbUserStatus;
    RH_PORT_STATUS portStatus;

    USBPORT_KdPrint((2, "'USBPORT_UserRawResetPort\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    usbUserStatus = UsbUserSuccess;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'CFRp', 0, Parameters->PortNumber, Parameters->PortFeature);

    if (!USBPORT_ValidateRootPortApi(FdoDeviceObject, Parameters->PortNumber)) {
        Header->UsbUserStatusCode =
            usbUserStatus = UsbUserInvalidParameter;
        return;
    }

    if (!USBPORT_DCA_Enabled(FdoDeviceObject)) {
        Header->UsbUserStatusCode = UsbUserFeatureDisabled;
        return;
    }

    switch(Parameters->PortFeature) {

    case PORT_ENABLE:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnable(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case PORT_POWER:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case PORT_SUSPEND:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspend(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case C_PORT_ENABLE:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortEnableChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case C_PORT_CONNECTION:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortConnectChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);


        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case C_PORT_RESET:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortResetChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);


        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case C_PORT_SUSPEND:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortSuspendChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/

        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);


        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    case C_PORT_OVER_CURRENT:

        devExt->Fdo.MiniportDriver->
            RegistrationPacket.MINIPORT_RH_ClearFeaturePortOvercurrentChange(
                                                devExt->Fdo.MiniportDeviceData,
                                                Parameters->PortNumber);
/*
        USBPORT_Wait(FdoDeviceObject, 1);
*/
        MP_Get32BitFrameNumber(devExt, currentFrame);

        do {
            MP_Get32BitFrameNumber(devExt, nextFrame);
            if(nextFrame < currentFrame) {
                // roll-over
                //
                currentFrame = nextFrame;
                MP_Get32BitFrameNumber(devExt, nextFrame);
            }
        } while ((nextFrame - currentFrame) < FRAME_COUNT_WAIT);

        MPRH_GetPortStatus(devExt, (USHORT)(Parameters->PortNumber),
                &portStatus, mpStatus);
        // status is low 16 bits
        Parameters->PortStatus = (USHORT) portStatus.ul;
        break;

    default:

        usbUserStatus = UsbUserNotSupported;
        break;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'CFR>', 0, 0, usbUserStatus);

    Header->UsbUserStatusCode = usbUserStatus;
}


USB_MINIPORT_STATUS
USBPORT_RootHub_PowerUsb2Port(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Port
    )
/*++

Routine Description:

    Power up the USB 2 port and the assocaited CC port

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    miniport status

--*/

{
    PDEVICE_EXTENSION devExt, rhDevExt;
    USB_MINIPORT_STATUS mpStatus;
    PDEVICE_RELATIONS devRelations;
    USHORT p;
    ULONG i;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, '20pw', 0, 0, 0);

    // power the associated CC controllers ports
    // for now power all ports for any CC

    devRelations =
        USBPORT_FindCompanionControllers(FdoDeviceObject,
                                         FALSE,
                                         TRUE);

    // may get NULL here if no CCs found or are registered

    for (i=0; devRelations && i< devRelations->Count; i++) {
        PDEVICE_OBJECT fdo = devRelations->Objects[i];
        PDEVICE_EXTENSION ccDevExt, ccRhDevExt;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'pwCC', fdo,
            0, 0);

        GET_DEVICE_EXT(ccDevExt, fdo);
        ASSERT_FDOEXT(ccDevExt);

        GET_DEVICE_EXT(ccRhDevExt, ccDevExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(ccRhDevExt);

        // power the port
        for (p=0;
             (ccRhDevExt->PnpStateFlags & USBPORT_PNP_STARTED) &&
                p< NUMBER_OF_PORTS(ccRhDevExt);
             p++) {
            ccDevExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                    ccDevExt->Fdo.MiniportDeviceData,
                                                    p+1);
        }

    }

    devExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                    devExt->Fdo.MiniportDeviceData,
                                                    Port);

    // jd xxx
    // chirp it
    //devExt->Fdo.MiniportDriver->
    //            RegistrationPacket.MINIPORT_Chirp_RH_Port(
    //                                                devExt->Fdo.MiniportDeviceData,
    //                                                Port);


    // thou shall not leak memory
    if (devRelations != NULL) {
        FREE_POOL(FdoDeviceObject, devRelations);
    }

    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBPORT_RootHub_PowerUsbCcPort(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT Port
    )
/*++

Routine Description:

    Power up the USB  port on a CC

Arguments:

    DeviceObject - Fdo for USB HC

Return Value:

    miniport status

--*/

{
    PDEVICE_EXTENSION devExt, rhDevExt;
//    PDEVICE_OBJECT usb2Fdo;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_EXT(rhDevExt, devExt->Fdo.RootHubPdo);
    ASSERT_PDOEXT(rhDevExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'CCpw', 0, 0, Port);

    // if there is a 2.0 controller then
    // this a noop, port should already be powered

    //usb2Fdo =  USBPORT_FindUSB2Controller(FdoDeviceObject);

    // no 2.0 controller power this port
    devExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                devExt->Fdo.MiniportDeviceData,
                                                Port);
    return USBMP_STATUS_SUCCESS;
}


USB_MINIPORT_STATUS
USBPORT_RootHub_PowerAndChirpAllCcPorts(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Power up all the USB ports on a CC

Arguments:

    DeviceObject - Fdo for USB Companion

Return Value:

    miniport status

--*/

{
    PDEVICE_EXTENSION devExt;
    USB_MINIPORT_STATUS mpStatus;
    USHORT p;
    ULONG i;
    PDEVICE_OBJECT usb2Fdo;
    ROOTHUB_DATA hubData;
    ULONG nPorts;

    ASSERT_PASSIVE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MPRH_GetRootHubData(devExt, &hubData);
    nPorts = hubData.NumberOfPorts;

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'CCpw', 0, 0, 0);

    usb2Fdo =  USBPORT_FindUSB2Controller(FdoDeviceObject);
    // may get NULL if no 2.0 controller registered

    if (usb2Fdo) {
        PDEVICE_EXTENSION usb2DevExt;
        ULONG usb2Nports;

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'p120', usb2Fdo,
            0, 0);

        GET_DEVICE_EXT(usb2DevExt, usb2Fdo);
        ASSERT_FDOEXT(usb2DevExt);

        MPRH_GetRootHubData(usb2DevExt, &hubData);
        usb2Nports = hubData.NumberOfPorts;

        KeWaitForSingleObject(&usb2DevExt->Fdo.CcLock,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK);
        USBPORT_KdPrint((1, "'**> powering/chirping CC ports\n"));

        for (p=0;
             p< nPorts;
             p++) {

             devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                   devExt->Fdo.MiniportDeviceData,
                                                   p+1);
        }

        // some ammount of time must elapse between powering the CC port and
        // attempting to chirp.
        USBPORT_Wait(FdoDeviceObject, 10);

        // chirp all the ports on the USB 2 parent
        for (p=0;
             (usb2DevExt->Fdo.MiniportDriver->HciVersion >= USB_MINIPORT_HCI_VERSION_2)
                &&
              p < usb2Nports;
                p++) {
            usb2DevExt->Fdo.MiniportDriver->
                RegistrationPacket.MINIPORT_Chirp_RH_Port(
                                                    usb2DevExt->Fdo.MiniportDeviceData,
                                                    p+1);
        }

        USBPORT_KdPrint((1, "'**< powering/chirping CC ports\n"));
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_LOCK);
        KeReleaseSemaphore(&usb2DevExt->Fdo.CcLock,
                               LOW_REALTIME_PRIORITY,
                               1,
                               FALSE);


    } else {
        USBPORT_KdPrint((1, "'** powering CC ports\n"));

        // no CC, just power them
        for (p=0;
             p< nPorts;
             p++) {

             devExt->Fdo.MiniportDriver->
                    RegistrationPacket.MINIPORT_RH_SetFeaturePortPower(
                                                   devExt->Fdo.MiniportDeviceData,
                                                   p+1);
        }
    }

    return USBMP_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\status.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    status.c

Abstract:

    Status Code mapping functions

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_SetUSBDError
// USBPORT_MiniportStatus_TO_USBDStatus
// USBPORT_MiniportStatus_TO_NtStatus


NTSTATUS
USBPORT_SetUSBDError(
    PURB Urb,
    USBD_STATUS UsbdStatus
    )
/*++

Routine Description:

    Set the USBD error code in the urb and return an NTSTATUS 
    equivalent

Arguments:

    URB urb to set error in (optional)

Return Value:


--*/
{
    if (Urb) {
        Urb->UrbHeader.Status = UsbdStatus;
    }        

    switch (UsbdStatus) {
    case USBD_STATUS_SUCCESS:
        return STATUS_SUCCESS;
        
    case USBD_STATUS_INSUFFICIENT_RESOURCES:
        return STATUS_INSUFFICIENT_RESOURCES;
        
    case USBD_STATUS_INVALID_URB_FUNCTION:    
    case USBD_STATUS_INVALID_PARAMETER:
    case USBD_STATUS_INVALID_PIPE_HANDLE:
    case USBD_STATUS_BAD_START_FRAME:
        return STATUS_INVALID_PARAMETER;
        
    case USBD_STATUS_NOT_SUPPORTED:
        return STATUS_NOT_SUPPORTED;
    case USBD_STATUS_DEVICE_GONE:        
        return STATUS_DEVICE_NOT_CONNECTED;
    case USBD_STATUS_CANCELED:
        return STATUS_CANCELLED;
    }

    return STATUS_UNSUCCESSFUL;
}


USBD_STATUS
USBPORT_MiniportStatus_TO_USBDStatus(
    USB_MINIPORT_STATUS mpStatus
    )
/*++

Routine Description:

    return the USBD status code equivalent for a 
    miniport status code

Arguments:

Return Value:


--*/
{
    USBD_STATUS usbdStatus = USBD_STATUS_STATUS_NOT_MAPPED;

    switch (mpStatus) {
    case USBMP_STATUS_SUCCESS:
        usbdStatus = USBD_STATUS_SUCCESS;
        break;
    case USBMP_STATUS_BUSY:
        //usbdStatus = 
        //should not be mapping this one
        USBPORT_ASSERT(FALSE);
        break;
    case USBMP_STATUS_NO_RESOURCES:
        usbdStatus = USBD_STATUS_INSUFFICIENT_RESOURCES;
        break;
    case USBMP_STATUS_NO_BANDWIDTH:
        usbdStatus = USBD_STATUS_NO_BANDWIDTH;
        break;
    case USBMP_STATUS_NOT_SUPPORTED:
        usbdStatus = USBD_STATUS_NOT_SUPPORTED;
        break;
    default:
        usbdStatus = USBD_STATUS_INTERNAL_HC_ERROR;
        DEBUG_BREAK();
        break;
    }

    return usbdStatus;
}


NTSTATUS
USBPORT_MiniportStatus_TO_NtStatus(
    USB_MINIPORT_STATUS mpStatus
    )
/*++

Routine Description:

    return the NT status code equivalent for a 
    miniport status code

Arguments:

Return Value:


--*/
{
    USBD_STATUS usbdStatus;
    NTSTATUS ntStatus;
    
    usbdStatus = 
        USBPORT_MiniportStatus_TO_USBDStatus(mpStatus);

    ntStatus = USBPORT_SetUSBDError(NULL, usbdStatus);

    return ntStatus;
}    


USB_MINIPORT_STATUS
USBPORT_NtStatus_TO_MiniportStatus(
    NTSTATUS NtStatus
    )
/*++

Routine Description:

    return the miniport status code equivalent for a 
    NTSTATUS status code

Arguments:

Return Value:


--*/
{
    USB_MINIPORT_STATUS mpStatus;
    
    switch (NtStatus) {
    case STATUS_SUCCESS:
        mpStatus = USBMP_STATUS_SUCCESS;
        break;
        
    default:        
        mpStatus = USBMP_STATUS_NTERRCODE_NOT_MAPPFED;
    }

    return mpStatus;
}    


RHSTATUS
USBPORT_MiniportStatus_TO_RHStatus(
    USB_MINIPORT_STATUS mpStatus
    )
/*++

Routine Description:

    return the RH status code equivalent for a 
    miniport status code

Arguments:

Return Value:


--*/
{
    RHSTATUS rhStatus;

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        rhStatus = RH_SUCCESS;
    } else if (mpStatus == USBMP_STATUS_BUSY) {
        rhStatus = RH_NAK;
    } else {
        rhStatus = RH_STALL;
    }

    return rhStatus;
}    


USBD_STATUS
USBPORT_RHStatus_TO_USBDStatus(
    USB_MINIPORT_STATUS rhStatus
    )
/*++

Routine Description:

    return the RH status code equivalent for a 
    miniport status code

Arguments:

Return Value:


--*/
{
    USBD_STATUS usbdStatus;

    switch (rhStatus) {
    case RH_STALL:
        usbdStatus = USBD_STATUS_STALL_PID;
        break;
    case RH_SUCCESS:
        usbdStatus = USBD_STATUS_SUCCESS;
        break;
    case RH_NAK:
    default:
        // why are we mapping a NAK -- this is a bug.
        usbdStatus = USBD_STATUS_STALL_PID;
        DEBUG_BREAK();
    }

    return usbdStatus;
}        


USB_USER_ERROR_CODE
USBPORT_NtStatus_TO_UsbUserStatus(
    NTSTATUS NtStatus
    )
/*++

Routine Description:

    map NT status codes to our UI error codes

Arguments:

Return Value:


--*/
{
    USB_USER_ERROR_CODE usbUserStatus;

    switch (NtStatus) {
    case STATUS_SUCCESS:
        usbUserStatus = UsbUserSuccess;
        break;
        
    case STATUS_INVALID_PARAMETER:
        usbUserStatus = UsbUserInvalidParameter;
        break;
        
    default:        
        usbUserStatus = UsbUserErrorNotMapped;
    }

    return usbUserStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\thread.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    thread.c

Abstract:


Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// non paged functions
// USBPORT_CreateWorkerThread
// USBPORT_WorkerThreadStart
// USBPORT_SignalWorker


//NOTE perhaps one thread for all drivers will be enough
// we need to research this


// BUGBUG
// not a WDM function, see if we can do a runtime detect

/*
NTKERNELAPI
LONG
KeSetBasePriorityThread (
    IN PKTHREAD Thread,
    IN LONG Increment
    );

VOID
USBPORT_SetBasePriorityThread(
    PKTHREAD Thread,
    LONG Increment
    )
{
    //KeSetBasePriorityThread(Thread, Increment);
}
*/

VOID
USBPORT_WorkerThread(
    PVOID StartContext
    )
/*++

Routine Description:

    start the worker thread

Arguments:

Return Value:

    none

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;

    fdoDeviceObject = StartContext;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    devExt->Fdo.WorkerPkThread = KeGetCurrentThread();
    // priority setting optimal for suspend/resume

    // increment by 7, value suggested by perf team
    //USBPORT_SetBasePriorityThread(devExt->Fdo.WorkerPkThread, 7);

    // hurry up and wait
    do {

        LARGE_INTEGER t1, t2;

        KeQuerySystemTime(&t1);

        KeWaitForSingleObject(
                    &devExt->Fdo.WorkerThreadEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);

        KeQuerySystemTime(&t2);
        // deltaT in 100ns units 10 of these per ms
        // div by 10000 to get ms

        // compute how long we were idle
        devExt->Fdo.StatWorkIdleTime =
            (ULONG) ((t2.QuadPart - t1.QuadPart) / 10000);

        // see if we have work to do
        LOGENTRY(NULL, fdoDeviceObject, LOG_NOISY, 'wakW', 0, 0,
            devExt->Fdo.StatWorkIdleTime);

        // if someone is setting the event we stall here, the event will
        // be signalled and we will reset it.  This is OK because we
        // have not done any work yet
        KeAcquireSpinLock(&devExt->Fdo.WorkerThreadSpin.sl, &irql);
        // if someone sets the event they will stall here, until we reset
        // the event -- it will cause us to loop around again but that is
        // no big deal.
        KeResetEvent(&devExt->Fdo.WorkerThreadEvent);
        KeReleaseSpinLock(&devExt->Fdo.WorkerThreadSpin.sl, irql);
        // now doing work
        // at this point once work is complete we will wait until someone
        // else signals

        // don't do work unless we are started
        if (TEST_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED)) {
            USBPORT_DoSetPowerD0(fdoDeviceObject);

            // BUGBUG HP ia64 fix
            if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_SIGNAL_RH)) {
                PDEVICE_OBJECT usb2Fdo;
                PDEVICE_EXTENSION usb2DevExt;

                usb2Fdo = USBPORT_FindUSB2Controller(fdoDeviceObject);

                GET_DEVICE_EXT(usb2DevExt, usb2Fdo);
                ASSERT_FDOEXT(usb2DevExt);

                USBPORT_DoRootHubCallback(fdoDeviceObject, usb2Fdo);
                CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_SIGNAL_RH);

                // allow 2.0 controller to suspend
                InterlockedDecrement(&usb2DevExt->Fdo.PendingRhCallback);
                LOGENTRY(NULL, fdoDeviceObject, LOG_PNP, 'prh-', 0, 0,
                    usb2DevExt->Fdo.PendingRhCallback);
            }

            if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_CATC_TRAP)) {
                USBPORT_EndTransmitTriggerPacket(fdoDeviceObject);
            }

            USBPORT_Worker(fdoDeviceObject);
        }

    } while (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_KILL_THREAD));

    // cancel any wake irp we may have pending
    USBPORT_DisarmHcForWake(fdoDeviceObject);

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'Ttrm', 0, 0, 0);

    // kill ourselves
    PsTerminateSystemThread(STATUS_SUCCESS);

}


VOID
USBPORT_TerminateWorkerThread(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Terminate the USBPORT Worker thread synchronously

Arguments:

Return Value:

    none

--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS status;
    PVOID threadObject;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_THREAD_INIT)) {
        return;
    }

    // signal our thread to terminate

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Tthr', 0, 0, 0);
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_KILL_THREAD);

    // reference it so it won't go away before
    // we wait for it to finish

    status = ObReferenceObjectByHandle(devExt->Fdo.WorkerThreadHandle,
                                       SYNCHRONIZE,
                                       NULL,
                                       KernelMode,
                                       &threadObject,
                                       NULL);

    USBPORT_ASSERT(NT_SUCCESS(status))

    // signal worker takes the spinlock so on the off chance that
    // there is work being done this will stall
    USBPORT_SignalWorker(FdoDeviceObject);

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'ThWt', 0, 0, status);
    // wait for thread to finish
    KeWaitForSingleObject(
                    threadObject,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

    ObDereferenceObject(threadObject);
    ZwClose(devExt->Fdo.WorkerThreadHandle);
    devExt->Fdo.WorkerThreadHandle = NULL;

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'TthD', 0, 0, 0);

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_THREAD_INIT);

}


NTSTATUS
USBPORT_CreateWorkerThread(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Create the USBPORT Worker thread

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_KILL_THREAD);

    // initialize to NOT signaled
    // we initialize here because the we may signal
    // the event before the thread starts if we get
    // an interrupt.

    KeInitializeEvent(&devExt->Fdo.WorkerThreadEvent,
                      NotificationEvent,
                      FALSE);

    ntStatus =
        PsCreateSystemThread(&devExt->Fdo.WorkerThreadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        (HANDLE)0L,
        NULL,
        USBPORT_WorkerThread,
        FdoDeviceObject);

    if (NT_SUCCESS(ntStatus)) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_THREAD_INIT);
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'crTH', 0, 0, ntStatus);

    return ntStatus;
}


VOID
USBPORT_SignalWorker(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Signal that there is work to do.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    devExt->Fdo.StatWorkSignalCount++;

    KeAcquireSpinLock(&devExt->Fdo.WorkerThreadSpin.sl, &irql);
    LOGENTRY(NULL, FdoDeviceObject, LOG_NOISY, 'sigW', FdoDeviceObject, 0, 0);
    KeSetEvent(&devExt->Fdo.WorkerThreadEvent,
               1,
               FALSE);
    KeReleaseSpinLock(&devExt->Fdo.WorkerThreadSpin.sl, irql);
}


VOID
USBPORT_PowerWork(
    PVOID Context
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PUSB_POWER_WORK powerWork = Context;

    USBPORT_DoSetPowerD0(powerWork->FdoDeviceObject);

    DECREMENT_PENDING_REQUEST_COUNT(powerWork->FdoDeviceObject, NULL);

    FREE_POOL(powerWork->FdoDeviceObject, powerWork);
}


VOID
USBPORT_QueuePowerWorkItem(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PUSB_POWER_WORK powerWork;

    ALLOC_POOL_Z(powerWork, NonPagedPool, sizeof(*powerWork));

    // if the allocation fails the power work will be
    // deferred to our worker thread, this workitem is
    // just an  optimization

    if (powerWork != NULL) {
        ExInitializeWorkItem(&powerWork->QueueItem,
                             USBPORT_PowerWork,
                             powerWork);
        powerWork->FdoDeviceObject = FdoDeviceObject;

        INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
        ExQueueWorkItem(&powerWork->QueueItem,
                        CriticalWorkQueue);

    }
}


VOID
USBPORT_DoSetPowerD0(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;
    PDEVICE_EXTENSION devExt;
    ULONG controllerDisarmTime;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&devExt->Fdo.PowerSpin.sl, &irql);
    // see if we need to power on
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_NEED_SET_POWER_D0)) {

#ifdef XPSE
        LARGE_INTEGER dt, t1, t2;
#endif

        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_NEED_SET_POWER_D0);
        KeReleaseSpinLock(&devExt->Fdo.PowerSpin.sl, irql);

#ifdef XPSE
        // compute time to thread signal and wake
        KeQuerySystemTime(&t1);
        dt.QuadPart = t1.QuadPart - devExt->Fdo.ThreadResumeTimeStart.QuadPart;

        devExt->Fdo.ThreadResumeTime = (ULONG) (dt.QuadPart/10000);

        USBPORT_KdPrint((1, "(%x)  ThreadResumeTime %d ms \n",
            devExt, devExt->Fdo.ThreadResumeTime));
#endif

        // synchronously cancel the wake irp we have
        // in PCI so we don't get a completeion while
        // we power up.
        KeQuerySystemTime(&t1);
        USBPORT_DisarmHcForWake(FdoDeviceObject);
        KeQuerySystemTime(&t2);
        dt.QuadPart = t2.QuadPart - t1.QuadPart;

        controllerDisarmTime = (ULONG) (dt.QuadPart/10000);
        USBPORT_KdPrint((1, "(%x)  ControllerDisarmTime %d ms \n",
            devExt, controllerDisarmTime));

#ifdef XPSE
        // time the hw resume/start
        KeQuerySystemTime(&t1);
#endif

        // The goal here is to wait for the USB2 and its CCs to start
        // then make sure that the 20 controller holds the shared port
        // semaphore

        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_OFF)) {
            USBPORT_TurnControllerOn(FdoDeviceObject);
            USBPORT_SynchronizeControllersResume(FdoDeviceObject);

            if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC)) {
                // if this is a CC then power the ports here
                // the USB 2 controller holds the semaphore on
                // return from USBPORT_SynchronizeControllersResume
                USBPORT_KdPrint((1, " >power-chirp CC ports (on)\n"));
                USBPORT_RootHub_PowerAndChirpAllCcPorts(FdoDeviceObject);
            }
        } else {
            // complete the power irp, the controller is on
            // but is still 'suspended'
            USBPORT_RestoreController(FdoDeviceObject);
            USBPORT_SynchronizeControllersResume(FdoDeviceObject);
        }



#ifdef XPSE
        // compute time to start controller
        KeQuerySystemTime(&t2);
        dt.QuadPart = t2.QuadPart - t1.QuadPart;

        devExt->Fdo.ControllerResumeTime = (ULONG) (dt.QuadPart/10000);

        USBPORT_KdPrint((1, "(%x)  ControllerResumeTime %d ms \n",
            devExt, devExt->Fdo.ControllerResumeTime));

        // compute time to S0;
        KeQuerySystemTime(&t2);
        dt.QuadPart = t2.QuadPart - devExt->Fdo.S0ResumeTimeStart.QuadPart;

        devExt->Fdo.S0ResumeTime = (ULONG) (dt.QuadPart/10000);

        USBPORT_KdPrint((1, "(%x)  D0ResumeTime %d ms \n", devExt,
            devExt->Fdo.D0ResumeTime));
        USBPORT_KdPrint((1, "(%x)  S0ResumeTime %d ms \n", devExt,
            devExt->Fdo.S0ResumeTime));
#endif

        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_RESUME_SIGNALLING)) {
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RESUME_SIGNALLING);
            USBPORT_HcQueueWakeDpc(FdoDeviceObject);
        }
    } else {
        KeReleaseSpinLock(&devExt->Fdo.PowerSpin.sl, irql);
    }

}


VOID
USBPORT_SynchronizeControllersResume(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Synchronize the USB 2 controllers with companions.

    This routines blocks all dependent controllers unt their
    hardware is restored.  At that point it takes the CC lock
    for the USB 2 controller and allows all the controllers to
    resume.

    The CC lock protects the shared port registers from simultaneous
    access.

Arguments:

Return Value:

    None.

    The USB 2 controller holds the CC lock on return from this function

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT usb2Fdo;

    ASSERT_PASSIVE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'SYN2', FdoDeviceObject, 0, 0);

    if (USBPORT_IS_USB20(devExt)) {
        usb2Fdo =  FdoDeviceObject;
    } else {
        usb2Fdo =  USBPORT_FindUSB2Controller(FdoDeviceObject);
    }

    // may get NULL if no 2.0 controller registered
    // don't wait if not CCs or other controllers

    if (usb2Fdo) {
        PDEVICE_EXTENSION usb2DevExt, rhDevExt;

        LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'u2cc', FdoDeviceObject,
            usb2Fdo, 0);

        GET_DEVICE_EXT(usb2DevExt, usb2Fdo);
        ASSERT_FDOEXT(usb2DevExt);

        GET_DEVICE_EXT(rhDevExt, usb2DevExt->Fdo.RootHubPdo);
        ASSERT_PDOEXT(rhDevExt);


        // sync with the CC if this is a USB 2 controller
        // note that we only grab the CC lock if the root
        // hub PDO is enabled since it is released only
        // when the root hub is set to D0 -- this will never
        // happen if the rh is disabled

        if (USBPORT_IS_USB20(devExt) &&
            !TEST_FLAG(rhDevExt->PnpStateFlags, USBPORT_PNP_REMOVED)) {

            KeWaitForSingleObject(&usb2DevExt->Fdo.CcLock,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            USBPORT_ASSERT(!TEST_FDO_FLAG(usb2DevExt,
                    USBPORT_FDOFLAG_CC_LOCK));
            SET_FDO_FLAG(usb2DevExt, USBPORT_FDOFLAG_CC_LOCK);
            LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'grcc', FdoDeviceObject,
                usb2Fdo, 0);

            USBPORT_KdPrint((1, " >power 20 (on) %x\n",
                    FdoDeviceObject));
        }

        InterlockedDecrement(&usb2DevExt->Fdo.DependentControllers);

        // at this point any of the dependent controllers can continue

        do {
            USBPORT_Wait(FdoDeviceObject, 10);

            // sync with the CC if this is a USB 2 controller
            // note that we only grab the CC lock if the root
            // hub PDO is enabled since it is released only
            // when the root hub is set to D0 -- this will never
            // happen if the rh is disabled

        } while (usb2DevExt->Fdo.DependentControllers);

        LOGENTRY(NULL, FdoDeviceObject, LOG_RH, 'u2GO', FdoDeviceObject,
            usb2Fdo, 0);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\service.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    service.c

Abstract:

    DLL Services provided by usbport.sys

    This module conatins the load and initialization code 
    used by the port driver to link up with the miniport.

Environment:

    kernel mode only

Notes:


Revision History:

    6-20-99 : created

--*/

#define USBPORT

#include "common.h"

extern USBPORT_SPIN_LOCK USBPORT_GlobalsSpinLock;
extern LIST_ENTRY USBPORT_USB2fdoList;
extern LIST_ENTRY USBPORT_USB1fdoList;

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, USBD_InternalGetInterfaceLength)
#endif

NTSTATUS
DllUnload(
    VOID
    )
{
    extern BOOLEAN USBPORT_GlobalInitialized;
    
    USBPORT_KdPrint((1, "'unloading USBPORT\n"));

    // this will cause us to re-init even if our 
    // image is not unloaded or the data segment 
    // is not re-initialized (this happens on win9x)

    if (USBPORT_GlobalInitialized && USBPORT_DummyUsbdExtension) {
        FREE_POOL(NULL, USBPORT_DummyUsbdExtension);
    }

    USBPORT_GlobalInitialized = FALSE;
    USBPORT_DummyUsbdExtension = NULL;

    return STATUS_SUCCESS;
}


ULONG 
USBPORT_GetHciMn(
    )
{
    return USB_HCI_MN;
}


PDEVICE_OBJECT
USBPORT_FindUSB2Controller(
    PDEVICE_OBJECT CcFdoDeviceObject
    )
/*++

Routine Description:

    Given a companion controller find the FDO for the parent

Arguments:

Return Value:

--*/
{
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_EXTENSION devExt;
    KIRQL irql;
    PLIST_ENTRY listEntry;
    PDEVICE_EXTENSION ccExt;


    GET_DEVICE_EXT(ccExt, CcFdoDeviceObject);
    ASSERT_FDOEXT(ccExt);

    KeAcquireSpinLock(&USBPORT_GlobalsSpinLock.sl, &irql);

    GET_HEAD_LIST(USBPORT_USB2fdoList, listEntry);

    while (listEntry && 
           listEntry != &USBPORT_USB2fdoList) {
                    
        devExt = (PDEVICE_EXTENSION) CONTAINING_RECORD(
                    listEntry,
                    struct _DEVICE_EXTENSION, 
                    Fdo.ControllerLink);

        // find the USB 2 controller assocaited with this CC 
        
        if (devExt->Fdo.BusNumber == ccExt->Fdo.BusNumber &&
            devExt->Fdo.BusDevice == ccExt->Fdo.BusDevice) {
            deviceObject = devExt->HcFdoDeviceObject;                   
            break;
        }  

        listEntry = devExt->Fdo.ControllerLink.Flink; 
    }
    
    KeReleaseSpinLock(&USBPORT_GlobalsSpinLock.sl, irql);
    
    return deviceObject;
}


BOOLEAN
USBPORT_IsCCForFdo(
    PDEVICE_OBJECT Usb2FdoDeviceObject,
    PDEVICE_EXTENSION CcExt
    )
/*++

--*/
{
    PDEVICE_EXTENSION usb2Ext;

    GET_DEVICE_EXT(usb2Ext, Usb2FdoDeviceObject);
    ASSERT_FDOEXT(usb2Ext);

    ASSERT_FDOEXT(CcExt);

    if (usb2Ext->Fdo.BusNumber == CcExt->Fdo.BusNumber &&
        usb2Ext->Fdo.BusDevice == CcExt->Fdo.BusDevice) {
        return TRUE;
    }    

    return FALSE;        
}


PDEVICE_RELATIONS
USBPORT_FindCompanionControllers(
    PDEVICE_OBJECT Usb2FdoDeviceObject,
    BOOLEAN ReferenceObjects,
    BOOLEAN ReturnFdo
    )
/*++

Routine Description:

    Given a companion controller find the FDO for the parent

Arguments:

Return Value:

--*/
{
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_EXTENSION devExt;
    PLIST_ENTRY listEntry;
    KIRQL irql;
    PDEVICE_RELATIONS deviceRelations = NULL;
    ULONG count = 0;

    KeAcquireSpinLock(&USBPORT_GlobalsSpinLock.sl, &irql);

    GET_HEAD_LIST(USBPORT_USB1fdoList, listEntry);

    while (listEntry && 
           listEntry != &USBPORT_USB1fdoList) {

        devExt = (PDEVICE_EXTENSION) CONTAINING_RECORD(
                    listEntry,
                    struct _DEVICE_EXTENSION, 
                    Fdo.ControllerLink);

        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC) && 
            USBPORT_IsCCForFdo(Usb2FdoDeviceObject, devExt)) {
            count++;
        }
        
        listEntry = devExt->Fdo.ControllerLink.Flink; 
        
    } /* while */

    LOGENTRY(NULL, Usb2FdoDeviceObject, LOG_MISC, 'fccR', count, 0,
        Usb2FdoDeviceObject);

    if (count) {
        ALLOC_POOL_OSOWNED(deviceRelations, 
                           NonPagedPool,
                           sizeof(*deviceRelations)*count);
    }
    
    if (deviceRelations != NULL) {
        deviceRelations->Count = count;
        count = 0;
        
        GET_HEAD_LIST(USBPORT_USB1fdoList, listEntry);

        while (listEntry && 
               listEntry != &USBPORT_USB1fdoList) {

            devExt = (PDEVICE_EXTENSION) CONTAINING_RECORD(
                        listEntry,
                        struct _DEVICE_EXTENSION, 
                        Fdo.ControllerLink);

            if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC) &&
                USBPORT_IsCCForFdo(Usb2FdoDeviceObject, devExt)) {
                
                USBPORT_ASSERT(count < deviceRelations->Count);
                deviceRelations->Objects[count] = devExt->Fdo.PhysicalDeviceObject;
                if (ReferenceObjects) {
                    ObReferenceObject(deviceRelations->Objects[count]);
                }    

                if (ReturnFdo) {
                    deviceRelations->Objects[count] = 
                            devExt->HcFdoDeviceObject;
                }

                USBPORT_KdPrint((1, "'Found CC %x\n", deviceRelations->Objects[count]));

                count++;
            }
            
            listEntry = devExt->Fdo.ControllerLink.Flink; 
            
        } /* while */
    }    
    KeReleaseSpinLock(&USBPORT_GlobalsSpinLock.sl, irql);

    return deviceRelations;
}


VOID
USBPORT_RegisterUSB2fdo(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    tracks an instance of a USB 2 device

Arguments:

Return Value:

--*/    
{    
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_FDO_REGISTERED); 
    
    ExInterlockedInsertTailList(&USBPORT_USB2fdoList, 
                                &devExt->Fdo.ControllerLink,
                                &USBPORT_GlobalsSpinLock.sl);
}


VOID
USBPORT_RegisterUSB1fdo(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    tracks an instance of a USB 2 device

Arguments:

Return Value:

--*/    
{    
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_FDO_REGISTERED); 
    
    ExInterlockedInsertTailList(&USBPORT_USB1fdoList, 
                                &devExt->Fdo.ControllerLink,
                                &USBPORT_GlobalsSpinLock.sl);
}


VOID
USBPORT_DeregisterUSB2fdo(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    tracks an instance of a USB 2 device

Arguments:

Return Value:

--*/    
{    
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(devExt->Fdo.ControllerLink.Flink != NULL);
    USBPORT_ASSERT(devExt->Fdo.ControllerLink.Blink != NULL);
    
    USBPORT_InterlockedRemoveEntryList(&devExt->Fdo.ControllerLink,
                                       &USBPORT_GlobalsSpinLock.sl);

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_FDO_REGISTERED); 
    
    devExt->Fdo.ControllerLink.Blink = NULL;
    devExt->Fdo.ControllerLink.Flink = NULL;
    
}


VOID
USBPORT_DeregisterUSB1fdo(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    tracks an instance of a USB 2 device

Arguments:

Return Value:

--*/    
{    
    PDEVICE_EXTENSION devExt;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(devExt->Fdo.ControllerLink.Flink != NULL);
    USBPORT_ASSERT(devExt->Fdo.ControllerLink.Blink != NULL);
    
    USBPORT_InterlockedRemoveEntryList(&devExt->Fdo.ControllerLink,
                                       &USBPORT_GlobalsSpinLock.sl);

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_FDO_REGISTERED);
    
    devExt->Fdo.ControllerLink.Blink = NULL;
    devExt->Fdo.ControllerLink.Flink = NULL;
    
}


NTSTATUS
USBPORT_RegisterUSBPortDriver(
    PDRIVER_OBJECT DriverObject,
    ULONG MiniportHciVersion,
    PUSBPORT_REGISTRATION_PACKET RegistrationPacket
    )
/*++

Routine Description:

    Called from DriverEntry by miniport. 

    The opposite of this function is the DriverObject->Unload 
    routine which we hook.

Arguments:

Return Value:

--*/    
{

    PUSBPORT_MINIPORT_DRIVER miniportDriver;
    extern LIST_ENTRY USBPORT_MiniportDriverList;
    extern USBPORT_SPIN_LOCK USBPORT_GlobalsSpinLock;
    extern BOOLEAN USBPORT_GlobalInitialized;
    NTSTATUS ntStatus;
    extern ULONG USB2LIB_HcContextSize;
    extern ULONG USB2LIB_EndpointContextSize;
    extern ULONG USB2LIB_TtContextSize;
    ULONG regPacketLength = 0;

    // get global registry parameters, check on every 
    // miniport load 
    GET_GLOBAL_DEBUG_PARAMETERS();
    
    USBPORT_KdPrint((1, "'USBPORT Universal Serial Bus Host Controller Port Driver.\n"));
    USBPORT_KdPrint((1, "'Using USBDI version %x\n", USBDI_VERSION));
    USBPORT_KdPrint((2, "'Registration Packet %x\n", RegistrationPacket));
    DEBUG_BREAK();

    if (USBPORT_GlobalInitialized == FALSE) {
        // do some first time loaded stuff
        USBPORT_GlobalInitialized = TRUE;
        InitializeListHead(&USBPORT_MiniportDriverList);
        InitializeListHead(&USBPORT_USB2fdoList);
        InitializeListHead(&USBPORT_USB1fdoList);
        KeInitializeSpinLock(&USBPORT_GlobalsSpinLock.sl);

        ALLOC_POOL_Z(USBPORT_DummyUsbdExtension, 
                     NonPagedPool, 
                     USBPORT_DUMMY_USBD_EXT_SIZE);

        if (USBPORT_DummyUsbdExtension == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        USB2LIB_InitializeLib(
            &USB2LIB_HcContextSize,
            &USB2LIB_EndpointContextSize,
            &USB2LIB_TtContextSize,
            USB2LIB_DbgPrint,
            USB2LIB_DbgBreak);                                      
            
    }

    // non paged because we will call the function pointers
    // thru this structure
    ALLOC_POOL_Z(miniportDriver, 
                 NonPagedPool, 
                 sizeof(*miniportDriver));

    if (miniportDriver == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    USBPORT_KdPrint((1, "'miniport driver: %x\n", miniportDriver));
    
    miniportDriver->DriverObject = DriverObject;
    
    //
    // Create dispatch points for appropriate irps
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]=
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
    DriverObject->MajorFunction[IRP_MJ_PNP] = 
    DriverObject->MajorFunction[IRP_MJ_POWER] = USBPORT_Dispatch;

    DriverObject->DriverExtension->AddDevice = USBPORT_PnPAddDevice;

    miniportDriver->MiniportUnload = DriverObject->DriverUnload;
    DriverObject->DriverUnload = USBPORT_Unload;

    // set up the registration packet and return our function pointers 
    // miniport.

// bump this for pre-release versions of the stack to prevent 
// compatibilty problms with pre-release miniports
#define USBHDCDI_MIN_REV_SUPPORTED      100

    // remeber the registered version
    miniportDriver->HciVersion = MiniportHciVersion;
     
    if (MiniportHciVersion < USBHDCDI_MIN_REV_SUPPORTED) {
        return STATUS_UNSUCCESSFUL;
    }

    // do our version (1) stuff
    if (MiniportHciVersion >= 100) {
    
        // validate the registrtion packet
//        if (RegistrationPacket-> 
//            USBPORT_KdPrint((0, "'Miniport Registrtaion Packet is invalid!\n"));        
//            DEBUG_BREAK();
//            ntStatus = STATUS_UNSUCCESSFUL;
//            goto USBPORT_RegisterUSBPortDriver_Done;
//        }
        
        // do our version (1) stuff
        RegistrationPacket->USBPORTSVC_DbgPrint = 
            USBPORTSVC_DbgPrint;
        RegistrationPacket->USBPORTSVC_TestDebugBreak = 
            USBPORTSVC_TestDebugBreak;
        RegistrationPacket->USBPORTSVC_AssertFailure = 
            USBPORTSVC_AssertFailure;            
        RegistrationPacket->USBPORTSVC_GetMiniportRegistryKeyValue = 
            USBPORTSVC_GetMiniportRegistryKeyValue;
        RegistrationPacket->USBPORTSVC_InvalidateRootHub = 
            USBPORTSVC_InvalidateRootHub;            
        RegistrationPacket->USBPORTSVC_InvalidateEndpoint = 
            USBPORTSVC_InvalidateEndpoint; 
        RegistrationPacket->USBPORTSVC_CompleteTransfer = 
            USBPORTSVC_CompleteTransfer;       
        RegistrationPacket->USBPORTSVC_CompleteIsoTransfer = 
            USBPORTSVC_CompleteIsoTransfer;            
        RegistrationPacket->USBPORTSVC_LogEntry = 
            USBPORTSVC_LogEntry;
        RegistrationPacket->USBPORTSVC_MapHwPhysicalToVirtual =
            USBPORTSVC_MapHwPhysicalToVirtual;
        RegistrationPacket->USBPORTSVC_RequestAsyncCallback = 
            USBPORTSVC_RequestAsyncCallback;
        RegistrationPacket->USBPORTSVC_ReadWriteConfigSpace = 
            USBPORTSVC_ReadWriteConfigSpace;
        RegistrationPacket->USBPORTSVC_Wait = 
            USBPORTSVC_Wait;            
        RegistrationPacket->USBPORTSVC_InvalidateController = 
            USBPORTSVC_InvalidateController;             
        RegistrationPacket->USBPORTSVC_BugCheck = 
            USBPORTSVC_BugCheck;                     
        RegistrationPacket->USBPORTSVC_NotifyDoubleBuffer = 
            USBPORTSVC_NotifyDoubleBuffer;

        regPacketLength = sizeof(USBPORT_REGISTRATION_PACKET_V1);            

        USBPORT_KdPrint((1, "'Miniport Version 1 support\n"));
    }

    // do our version (2) stuff, this is a superset of version 1
    if (MiniportHciVersion >= 200) {
        USBPORT_KdPrint((1, "'Miniport Version 2 support\n"));
        
        regPacketLength = sizeof(USBPORT_REGISTRATION_PACKET);
    }
    
    // save a copy of the packet  
    RtlCopyMemory(&miniportDriver->RegistrationPacket,
                  RegistrationPacket,
                  regPacketLength);
                  

    // put this driver on our list
    ExInterlockedInsertTailList(&USBPORT_MiniportDriverList, 
                                &miniportDriver->ListEntry,
                                &USBPORT_GlobalsSpinLock.sl);

    ntStatus = STATUS_SUCCESS;
    TEST_PATH(ntStatus, FAILED_REGISTERUSBPORT);
    
USBPORT_RegisterUSBPortDriver_Done:

    return ntStatus;
}


/*
    Misc Miniport callable services
*/
#if 0
BOOLEAN
USBPORTSVC_SyncWait(
    PDEVICE_DATA DeviceData,
    xxx WaitCompletePollFunction,
    ULONG MaxMillisecondsToWait
    )
/*++

Routine Description:

    Service exported to miniports to wait on the HW

Arguments:

Return Value:

    Returns true if the time expired before the WaitCompletePoll
    function returns true
    

--*/
{   
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    LARGE_INTEGER finishTime, currentTime;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'synW', 0, 0, 0);

    KeQuerySystemTime(&finishTime);
    
    // convert millisecs to nanosecs (10 ^-3 -> 10^-9)           
    nonosecs.QuadPart = MaxMillisecondsToWait * 1000000

    // figure when we quit 
    finishTime.QuadPart += nonosecs.QuadPart

    while (!MP_WaitPollFunction(xxx)) {
                   
        KeQuerySystemTime(&currentTime);
        
        if (currentTime.QuadPart >= finishTime.QuadPart) {
            LOGENTRY(NULL, fdoDeviceObject, LOG_MISC, 'syTO', 0, 0, 0);
            return TRUE;
        }            
    }

    return FALSE;
}    
#endif


typedef struct _USBPORT_ASYNC_TIMER {

    ULONG Sig;
    PDEVICE_OBJECT FdoDeviceObject;
    KTIMER Timer;
    KDPC Dpc;
    PMINIPORT_CALLBACK MpCallbackFunction;
    UCHAR MiniportContext[0];
    
} USBPORT_ASYNC_TIMER, *PUSBPORT_ASYNC_TIMER;


VOID
USBPORT_AsyncTimerDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL irql;
    PUSBPORT_ASYNC_TIMER asyncTimer  = DeferredContext;
    PDEVICE_EXTENSION devExt;

    
    fdoDeviceObject = asyncTimer->FdoDeviceObject;
    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'ayTM', fdoDeviceObject, asyncTimer, 0);

    // call the miniport
    asyncTimer->Sig = SIG_MP_TIMR;
    asyncTimer->MpCallbackFunction(devExt->Fdo.MiniportDeviceData,
                                   &asyncTimer->MiniportContext[0]);        

    DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
    FREE_POOL(fdoDeviceObject, asyncTimer);
}


VOID
USBPORTSVC_RequestAsyncCallback(
    PDEVICE_DATA DeviceData,
    ULONG MilliSeconds,    
    PVOID Context,
    ULONG ContextLength,
    PMINIPORT_CALLBACK CallbackFunction
    )
/*++

Routine Description:

    Service exported to miniports to wait on the HW
    and to time asynchronous events

Arguments:

Return Value:

    None.

--*/
{   
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    LONG dueTime;
    ULONG timerIncerent;
    PUSBPORT_ASYNC_TIMER asyncTimer;
    SIZE_T siz;
    
    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    // allocate a timer 
    siz = sizeof(USBPORT_ASYNC_TIMER) + ContextLength;

    ALLOC_POOL_Z(asyncTimer, NonPagedPool, siz);

    LOGENTRY(NULL, fdoDeviceObject, LOG_RH, 'asyT', 0, siz, asyncTimer);

    // if this fails the miniport will be waiting a very long
    // time.
    
    if (asyncTimer != NULL) {
        if (ContextLength) {
            RtlCopyMemory(&asyncTimer->MiniportContext[0],
                          Context,
                          ContextLength);
        }            

        asyncTimer->MpCallbackFunction = CallbackFunction;
        asyncTimer->FdoDeviceObject = fdoDeviceObject;
        
        KeInitializeTimer(&asyncTimer->Timer);
        KeInitializeDpc(&asyncTimer->Dpc,
                        USBPORT_AsyncTimerDpc,
                        asyncTimer);

        timerIncerent = KeQueryTimeIncrement() - 1;

        dueTime = 
            -1 * (timerIncerent + MILLISECONDS_TO_100_NS_UNITS(MilliSeconds));
        
        KeSetTimer(&asyncTimer->Timer,
                   RtlConvertLongToLargeInteger(dueTime),
                   &asyncTimer->Dpc);

        INCREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\usb2.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    usb2.c

Abstract:

    functions for processing usb 2.0 specific requests

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

// taken from budgeter code

#define LARGEXACT (579)
#define USBPORT_MAX_REBALANCE 30


VOID
USBPORT_Rebalance(
    PDEVICE_OBJECT FdoDeviceObject,
    PLIST_ENTRY ReblanceListHead
    )
/*++

Routine Description:

    The rebalnce list contains all the endpoints that were effected
    by budgeting this new USB2 endpoint.  We must re-schedule each of
    them.

    This process occurs during configuration of the device which is 
    serialized so we don't need to protect the list.

--*/
{
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    LONG startHframe;
    ULONG scheduleOffset;
    UCHAR sMask, cMask, period;
    ULONG bandwidth;
    PDEVICE_EXTENSION devExt;
    LIST_ENTRY interruptChangeList;
    LIST_ENTRY periodPromotionList;
    LIST_ENTRY isoChangeList;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    InitializeListHead(&interruptChangeList);
    InitializeListHead(&periodPromotionList);
    InitializeListHead(&isoChangeList);
    
    // bugbug 
    // can the insertion of the new endpiont occurr after the modification
    // of the rebalnced endpoints?
    

    // bugbug, this list must be sorted such that the changes occurr
    // in the proper sequnence.

    // ???
    //    <------chnages must travel this direction
    // iso--interrupt

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 
        '2RB>', 0, 0, 0);
            

    while (!IsListEmpty(ReblanceListHead)) {

        listEntry = RemoveHeadList(ReblanceListHead);

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    RebalanceLink);
                    
        ASSERT_ENDPOINT(endpoint);
        endpoint->RebalanceLink.Flink = NULL;
        endpoint->RebalanceLink.Blink = NULL;

        sMask = USB2LIB_GetSMASK(endpoint->Usb2LibEpContext);
        cMask = USB2LIB_GetCMASK(endpoint->Usb2LibEpContext);
        bandwidth = USB2LIB_GetAllocedBusTime(endpoint->Usb2LibEpContext) * 8;

        scheduleOffset = USB2LIB_GetScheduleOffset(endpoint->Usb2LibEpContext);

        period = USB2LIB_GetNewPeriod(endpoint->Usb2LibEpContext);

        USBPORT_KdPrint((1,"'[RB-old] %x sMask = x%x cMask = x%x\n", endpoint,
                        endpoint->Parameters.InterruptScheduleMask,
                        endpoint->Parameters.SplitCompletionMask));
        USBPORT_KdPrint((1,"'[RB-old] Period x%x Offset x%x\n",  
                endpoint->Parameters.Period,
                endpoint->Parameters.ScheduleOffset));                        

        USBPORT_KdPrint((1,"'[RB-new] %x sMask = x%x cMask = x%x\n", 
                endpoint, sMask, cMask));
        USBPORT_KdPrint((1,"'[RB-new] Period x%x Offset x%x\n",  
                period, scheduleOffset));

  
        switch (endpoint->Parameters.TransferType) {
        case Interrupt:
            if (sMask == endpoint->Parameters.InterruptScheduleMask && 
                cMask == endpoint->Parameters.SplitCompletionMask && 
                scheduleOffset == endpoint->Parameters.ScheduleOffset && 
                period == endpoint->Parameters.Period) {

                USBPORT_KdPrint((1,"'[RB] no changes\n"));
                USBPORT_ASSERT(bandwidth == endpoint->Parameters.Bandwidth);
                
            } else if (period != endpoint->Parameters.Period ||
                       scheduleOffset != endpoint->Parameters.ScheduleOffset) {
                 
                USBPORT_KdPrint((1,"'[RB] period changes\n"));
                InsertTailList(&periodPromotionList, 
                               &endpoint->RebalanceLink);
            } else {
                USBPORT_KdPrint((1,"'[RB] interrupt changes\n"));
               
                InsertTailList(&interruptChangeList, 
                               &endpoint->RebalanceLink);
            }
            break;
            
        case Isochronous:
           
            if (sMask == endpoint->Parameters.InterruptScheduleMask && 
                cMask == endpoint->Parameters.SplitCompletionMask && 
                scheduleOffset == endpoint->Parameters.ScheduleOffset && 
                period == endpoint->Parameters.Period) {

                USBPORT_KdPrint((1,"'[RB] iso no changes\n"));
                USBPORT_ASSERT(bandwidth == endpoint->Parameters.Bandwidth);
                
            } else if (period != endpoint->Parameters.Period ||
                       scheduleOffset != endpoint->Parameters.ScheduleOffset) {
                 // currently not handled
                USBPORT_KdPrint((1,"'[RB] iso period changes\n"));
                TEST_TRAP(); 
            } else {
                USBPORT_KdPrint((1,"'[RB] iso changes\n"));
               
                InsertTailList(&isoChangeList, 
                               &endpoint->RebalanceLink);
            }
            break;
        }            

    }
    
    // now do the period promotions
    // BUGBUG lump period and interrupt together
    USBPORT_KdPrint((1,"'[RB] period\n"));
    USBPORT_RebalanceEndpoint(FdoDeviceObject,
                              &periodPromotionList);                                 

    USBPORT_KdPrint((1,"'[RB] interrupt\n"));
    USBPORT_RebalanceEndpoint(FdoDeviceObject,
                              &interruptChangeList);

    // now rebalance the iso endpoints
    USBPORT_KdPrint((1,"'[RB] iso\n"));
    USBPORT_RebalanceEndpoint(FdoDeviceObject,
                              &isoChangeList);                              

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 
        '2RB<', 0, 0, 0);
}


VOID
USBPORT_RebalanceEndpoint(
    PDEVICE_OBJECT FdoDeviceObject,
    PLIST_ENTRY EndpointList
    )
/*++

Routine Description:

    Computes the best schedule parameters for a USB2 endpoint.

--*/
{
    PLIST_ENTRY listEntry;
    PHCD_ENDPOINT endpoint;
    ULONG scheduleOffset;
    UCHAR sMask, cMask, period;
    ULONG bandwidth, n, i, bt;
    PDEVICE_EXTENSION devExt;
    PHCD_ENDPOINT nextEndpoint;
 
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    
    while (!IsListEmpty(EndpointList)) {

        listEntry = RemoveHeadList(EndpointList);

        endpoint = (PHCD_ENDPOINT) CONTAINING_RECORD(
                    listEntry,
                    struct _HCD_ENDPOINT, 
                    RebalanceLink);

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 
                'rbe+', endpoint, 0, 0);   
                
        ASSERT_ENDPOINT(endpoint);
        endpoint->RebalanceLink.Flink = NULL;
        endpoint->RebalanceLink.Blink = NULL;

        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Lex+');

        // notify the miniport of the changed parameters

        sMask = USB2LIB_GetSMASK(endpoint->Usb2LibEpContext);
        cMask = USB2LIB_GetCMASK(endpoint->Usb2LibEpContext);
         
        scheduleOffset = USB2LIB_GetScheduleOffset(endpoint->Usb2LibEpContext);
        period = USB2LIB_GetNewPeriod(endpoint->Usb2LibEpContext);
        bt = USB2LIB_GetAllocedBusTime(endpoint->Usb2LibEpContext);
        bandwidth = bt * 8;
        nextEndpoint = USB2LIB_GetNextEndpoint(endpoint->Usb2LibEpContext);
#if DBG            
        if (nextEndpoint) {
            ASSERT_ENDPOINT(nextEndpoint);
        }
#endif                
        USBPORT_KdPrint((1,"'[RB - %x] \n", endpoint)); 

        USBPORT_ASSERT(bandwidth == endpoint->Parameters.Bandwidth);
               
        endpoint->Parameters.InterruptScheduleMask = sMask;
        endpoint->Parameters.SplitCompletionMask = cMask;

        if (endpoint->Parameters.Period != period) {
            // adjust bandwidth tracked for this endpoint

            n = USBPORT_MAX_INTEP_POLLING_INTERVAL/endpoint->Parameters.Period;

            for (i=0; i<n; i++) {
                USBPORT_ASSERT(n*endpoint->Parameters.ScheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
                endpoint->Tt->BandwidthTable[n*endpoint->Parameters.ScheduleOffset+i] += 
                    endpoint->Parameters.Bandwidth;
            }

            if (bt >= LARGEXACT) {
                SET_FLAG(endpoint->Flags, EPFLAG_FATISO);
            } else {
                CLEAR_FLAG(endpoint->Flags, EPFLAG_FATISO);
            }
           
            // track new parameters resulting from period change                
            endpoint->Parameters.Period = period;
            endpoint->Parameters.ScheduleOffset = scheduleOffset;
            endpoint->Parameters.Bandwidth = bandwidth;
            endpoint->Parameters.Ordinal = 
                USBPORT_SelectOrdinal(FdoDeviceObject, endpoint);
           
            // new allocation
            n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

            for (i=0; i<n; i++) {
    
                USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
                endpoint->Tt->BandwidthTable[n*scheduleOffset+i] += 
                    bandwidth;
    
            }
        }

        MP_RebalanceEndpoint(devExt, endpoint);
        
        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'Lex-'); 
         
    }
}


BOOLEAN
USBPORT_AllocateBandwidthUSB20(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Computes the best schedule parameters for a USB2 endpoint.

--*/
{
    PDEVICE_EXTENSION devExt;
    USB2LIB_BUDGET_PARAMETERS budget;
    BOOLEAN alloced;
    LONG startHframe;
    ULONG scheduleOffset, bt;
    UCHAR sMask, cMask, period;
    PREBALANCE_LIST rebalanceList;
    ULONG rebalanceListEntries;
    ULONG bytes;
    LIST_ENTRY endpointList;
    PVOID ttContext;
    PTRANSACTION_TRANSLATOR translator = NULL;
    PHCD_ENDPOINT nextEndpoint;
    
    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);    

    InitializeListHead(&endpointList);
    
    Endpoint->Parameters.ScheduleOffset = 0;
    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 
        'a2BW', Endpoint, 0, 0);
    
    // bulk and control are not tracked
    if (Endpoint->Parameters.TransferType == Bulk ||
        Endpoint->Parameters.TransferType == Control ||
        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
         
        Endpoint->Parameters.ScheduleOffset = 0;
        return TRUE;
    }     

    if (Endpoint->Parameters.TransferType == Interrupt || 
        Endpoint->Parameters.TransferType == Isochronous) {

        USBPORT_KdPrint((1,"'ALLOCBW (EP) %x  >>>>>>>>>>>>\n", Endpoint)); 
        // period has been normalized to a value <= 
        // USBPORT_MAX_INTEP_POLLING_INTERVAL in either mf of frames

        // call the engine to compute appropriate split masks
        // for this interrupt endpoint

        //
        USBPORT_KdPrint((1,"'(alloc) ep = %x\n", Endpoint));
        
        // set budget input parameters
        if (Endpoint->Parameters.TransferType == Interrupt) {
            budget.TransferType = Budget_Interrupt;
            budget.Period = Endpoint->Parameters.Period;                
        } else {
            budget.TransferType = Budget_Iso;
            budget.Period = 1;                
        }
        budget.MaxPacket = Endpoint->Parameters.MaxPacketSize;
        if (Endpoint->Parameters.TransferDirection == In) {
            budget.Direction = Budget_In; 
        } else {
            budget.Direction = Budget_Out;
        }
        switch (Endpoint->Parameters.DeviceSpeed) {
        case HighSpeed:            
            budget.Speed = Budget_HighSpeed;
            break;
        case LowSpeed:
            budget.Speed = Budget_LowSpeed;
            break;
        case FullSpeed:
            budget.Speed = Budget_FullSpeed;
            break;
        }

        bytes = sizeof(PVOID) * USBPORT_MAX_REBALANCE;

        ALLOC_POOL_Z(rebalanceList, 
                     NonPagedPool,
                     bytes);

        // high speed endpoints will have no Tt context
        ttContext = NULL;
        if (Endpoint->Tt != NULL) {
            ASSERT_TT(Endpoint->Tt);
            translator = Endpoint->Tt;
            ttContext = &Endpoint->Tt->Usb2LibTtContext[0];
        }            
        
        if (rebalanceList != NULL) {
            rebalanceListEntries = USBPORT_MAX_REBALANCE;
            alloced = USB2LIB_AllocUsb2BusTime(
                devExt->Fdo.Usb2LibHcContext,
                ttContext, 
                Endpoint->Usb2LibEpContext,
                &budget,
                Endpoint, // context
                rebalanceList,
                &rebalanceListEntries);
        } else {
            alloced = FALSE;
            rebalanceListEntries = 0;
        }

        USBPORT_KdPrint((1,"'(alloc %d) rebalance count = %d\n",
            alloced, rebalanceListEntries));

        if (rebalanceListEntries > 0) {
            PHCD_ENDPOINT rebalanceEndpoint;
            ULONG i;

            // convert the rebalance entries to endpoints
            for (i=0; i< rebalanceListEntries; i++) {
                
                rebalanceEndpoint = rebalanceList->RebalanceContext[i];
                USBPORT_KdPrint((1,"'(alloc) rebalance Endpoint = %x \n", 
                    rebalanceList->RebalanceContext[i]));

                USBPORT_ASSERT(rebalanceEndpoint->RebalanceLink.Flink == NULL);
                USBPORT_ASSERT(rebalanceEndpoint->RebalanceLink.Blink == NULL);
                InsertTailList(&endpointList, 
                               &rebalanceEndpoint->RebalanceLink);

            }
        }
        
        if (rebalanceList != NULL) {
            FREE_POOL(FdoDeviceObject, rebalanceList);      
        }

        if (alloced == TRUE) {
            ULONG n, bandwidth;
            ULONG i;
            
            // compute parameters for the miniport
            startHframe = USB2LIB_GetStartMicroFrame(Endpoint->Usb2LibEpContext);
            scheduleOffset = USB2LIB_GetScheduleOffset(Endpoint->Usb2LibEpContext);
            period = USB2LIB_GetNewPeriod(Endpoint->Usb2LibEpContext);
            sMask = USB2LIB_GetSMASK(Endpoint->Usb2LibEpContext);
            cMask = USB2LIB_GetCMASK(Endpoint->Usb2LibEpContext);
            // bw in bit times
            bt = USB2LIB_GetAllocedBusTime(Endpoint->Usb2LibEpContext);
            bandwidth = bt*8;
            nextEndpoint = USB2LIB_GetNextEndpoint(Endpoint->Usb2LibEpContext);

#if DBG            
            if (nextEndpoint) {
                ASSERT_ENDPOINT(nextEndpoint);
            }
#endif            
            // update the bw table in the TT
            if (translator == NULL) {
                n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;
        
                for (i=0; i<n; i++) {

                    USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
                    USBPORT_ASSERT(devExt->Fdo.BandwidthTable[n*scheduleOffset+i] >= bandwidth);
                    devExt->Fdo.BandwidthTable[n*scheduleOffset+i] -= bandwidth;
            
                }
            } else {
                // tt  allocation, track the bw
                
                n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;
        
                for (i=0; i<n; i++) {

                    USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
                    USBPORT_ASSERT(translator->BandwidthTable[n*scheduleOffset+i] >= bandwidth);
                    translator->BandwidthTable[n*scheduleOffset+i] -= bandwidth;
                }
            }                

            Endpoint->Parameters.Period = period;
            Endpoint->Parameters.ScheduleOffset = scheduleOffset;
            Endpoint->Parameters.InterruptScheduleMask = sMask;
            Endpoint->Parameters.SplitCompletionMask = cMask;
            Endpoint->Parameters.Bandwidth = bandwidth;
            if (bt >= LARGEXACT) {
                SET_FLAG(Endpoint->Flags, EPFLAG_FATISO);
            }
            
            USBPORT_KdPrint((1,"'[NEW] %x sMask = x%x cMask = x%x hFrame x%x\n", 
                Endpoint, sMask, cMask, startHframe));
            USBPORT_KdPrint((1,"'[NEW] Period x%x Offset x%x bw = %d\n",  
                period, scheduleOffset, bandwidth));                        
            USBPORT_KdPrint((1,"'[NEW] BudgetNextEp x%x \n", nextEndpoint));              
        } else {    
            USBPORT_KdPrint((1,"'[NEW] alloc failed\n")); 
        }
        USBPORT_KdPrint((1,"'ALLOCBW (EP) <<<<<<<<<<<<<<<<<\n")); 
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 
        'a2RB', 0, 0, alloced);

    USBPORT_KdPrint((1,"'REBLANCE (EP) >>>>>>>>>>>>>>>>>>>>\n")); 
    // process the rebalanced endpoints
    USBPORT_Rebalance(FdoDeviceObject,
                      &endpointList);
    USBPORT_KdPrint((1,"'REBLANCE (EP) <<<<<<<<<<<<<<<<<<<<<\n")); 
    
    if (translator != NULL) {
        // adjust the global bandwidth tracked for this tt
        ULONG bandwidth, i;
        
        // release old bandwidth
        bandwidth = translator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] += bandwidth;
        }

        USBPORT_UpdateAllocatedBwTt(translator);
        // alloc new            
        bandwidth = translator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] -= bandwidth;
        }
    }
    
    return alloced;
}


VOID
USBPORT_FreeBandwidthUSB20(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Frees the bw reserved for a give endpoint

Arguments:

Return Value:

    FALSE if no bandwidth availble

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG period, bandwidth, sheduleOffset, i, n;
    PREBALANCE_LIST rebalanceList;
    ULONG rebalanceListEntries;
    ULONG bytes;
    LIST_ENTRY endpointList;
    PVOID ttContext;
    PTRANSACTION_TRANSLATOR translator = NULL;
    ULONG scheduleOffset;
        
    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);    
    period = Endpoint->Parameters.Period;
    scheduleOffset = Endpoint->Parameters.ScheduleOffset;
    bandwidth = Endpoint->Parameters.Bandwidth;
 
    InitializeListHead(&endpointList);

    if (Endpoint->Parameters.TransferType == Bulk ||
        Endpoint->Parameters.TransferType == Control ||
        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        // these come out of our standard 10%
        return;
    }      
    
    USBPORT_KdPrint((1,"'(free) Endpoint = %x\n", Endpoint));
    bytes = sizeof(PVOID) * USBPORT_MAX_REBALANCE;

    // This must succeed, if we can't get memory for the 
    // rebalance list we cannot reorganize the schedule 
    // as a result of the device leaving. This means the 
    // whole schedule is busted and the bus will not function 
    // at all after this occurs.
    //
    
    ALLOC_POOL_Z(rebalanceList, 
                 NonPagedPool,
                 bytes);


    if (rebalanceList == NULL) {
        // if this fails we have no choice but to leave 
        // the schedule hoplessly you-know-what'ed up.
        return;
    }
    
    rebalanceListEntries = USBPORT_MAX_REBALANCE;

    // high speed endpoints will have no Tt context

    ttContext = NULL;
    if (Endpoint->Tt != NULL) {
        ASSERT_TT(Endpoint->Tt);
        translator = Endpoint->Tt;
        ttContext = &Endpoint->Tt->Usb2LibTtContext[0];
    }     

    if (translator == NULL) {
        
        // allocate 2.0 bus time
        n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

        for (i=0; i<n; i++) {

            USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
            devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;
    
        } 
        
    } else {
        // tt  allocation, track the bw on the tt
        
        n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

        for (i=0; i<n; i++) {

            USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
            translator->BandwidthTable[n*scheduleOffset+i] += bandwidth;
    
        }

    }      
    
    USB2LIB_FreeUsb2BusTime(
            devExt->Fdo.Usb2LibHcContext,
            ttContext, 
            Endpoint->Usb2LibEpContext,
            rebalanceList,
            &rebalanceListEntries);

    USBPORT_KdPrint((1,"'[FREE] %x sMask = x%x cMask = x%x\n", 
            Endpoint,
            Endpoint->Parameters.InterruptScheduleMask,
            Endpoint->Parameters.SplitCompletionMask));
    USBPORT_KdPrint((1,"'[FREE] Period x%x Offset x%x bw %d\n",  
            Endpoint->Parameters.Period,
            Endpoint->Parameters.ScheduleOffset,
            Endpoint->Parameters.Bandwidth));                        

    USBPORT_KdPrint((1,"'rebalance count = %d\n",
        rebalanceListEntries));
        
    if (rebalanceListEntries > 0) {
        PHCD_ENDPOINT rebalanceEndpoint;
        ULONG rbIdx;

        // convert the rebalance entries to endpoints
        for (rbIdx=0; rbIdx< rebalanceListEntries; rbIdx++) {
            rebalanceEndpoint = rebalanceList->RebalanceContext[rbIdx];
            USBPORT_KdPrint((1,"'(free) rebalance Endpoint = %x\n", 
                rebalanceList->RebalanceContext[rbIdx]));
            
            if (rebalanceEndpoint != Endpoint) {
                USBPORT_ASSERT(rebalanceEndpoint->RebalanceLink.Flink == NULL);
                USBPORT_ASSERT(rebalanceEndpoint->RebalanceLink.Blink == NULL);
                InsertTailList(&endpointList, 
                               &rebalanceEndpoint->RebalanceLink);
            }                               
        }
    }
    
    if (rebalanceList != NULL) {
        FREE_POOL(FdoDeviceObject, rebalanceList);      
    }

    // process the rebalanced endpoints
    USBPORT_Rebalance(FdoDeviceObject,
                      &endpointList);

    if (translator != NULL) {
        // adjust the global bandwidth tracked for this tt
        
        // release old bandwidth
        bandwidth = translator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] += bandwidth;
        }

        USBPORT_UpdateAllocatedBwTt(translator);
        // alloc new            
        bandwidth = translator->MaxAllocedBw;
        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            devExt->Fdo.BandwidthTable[i] -= bandwidth;
        }
    }
    
    return;
}


/*
    Endpoint Ordinal 

    An endpoint ordinal is a schedule attribute of the endpoint.  
    The ordinal set is unique for each endpoint type,period,offset,speed 
    combination.  The ordinal is used to indicate the relative 
    order the endpoints should be visited by the host controller 
    hardware.

    Interrupt Ordinals

    These are unique to each node in the interrupt schedule, we maintain
    a table similar to the miniport interrupt tree:


    // the array looks like this, values indicate period:
    //  1, 2, 2, 4, 4, 4, 4, 8,
    //  8, 8, 8, 8, 8, 8, 8,16,
    // 16,16,16,16,16,16,16,16,
    // 16,16,16,16,16,16,16,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,32,
    // 32,32,32,32,32,32,32,
    
*/

ULONG
USBPORT_SelectOrdinal(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Frees the bw reserved for a give endpoint

Arguments:

Return Value:

    FALSE if no bandwidth availble

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG ordinal;
    static o = 0;
    
    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (!USBPORT_IS_USB20(devExt)) {
        return 0;
    }

    switch (Endpoint->Parameters.TransferType) {
    case Bulk:
    case Control:
        ordinal = 0;
        break;
    case Interrupt:
        // BUGBUG
        ordinal = o++;
        break;  
    case Isochronous:
        if (TEST_FLAG(Endpoint->Flags, EPFLAG_FATISO)) {
            ordinal = 0;
        } else {
            ordinal = 1;
        }
        break;
    }                    
    
    return ordinal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\xsplit.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    xsplit.c

Abstract:

    splits a DMA transfer into multiple smallest transfers
    that the miniport can handle.

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#endif

ULONG
USBPORT_MakeSplitTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PTRANSFER_SG_LIST SgList,
    PHCD_TRANSFER_CONTEXT SplitTransfer,
    ULONG MaxTransferLength,
    ULONG MaxPacketLength,
    PULONG Idx,
    PULONG Offset,
    ULONG BytesToMap,
    ULONG LengthMapped
    )    
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    PTRANSFER_SG_ENTRY32 sgEntry;
    PTRANSFER_SG_LIST splitSgList;
    ULONG length;

    sgEntry = &SgList->SgEntry[*Idx];

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'splt', 
             SplitTransfer, 
             *Idx, 
             *Offset);

    USBPORT_ASSERT(MaxTransferLength % MaxPacketLength == 0)
    
    if ((sgEntry->Length - *Offset) > MaxTransferLength) {

        // case 2, this transfer falls entirely within 
        // this sg entry
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'spt1', 
             MaxTransferLength, 
             *Offset, 
             sgEntry);

        // make one transfer from sg[Idx]
        // inc offset

        length = MaxTransferLength;
        
        splitSgList = &SplitTransfer->SgList;
        splitSgList->SgCount = 1;
        splitSgList->SgEntry[0].LogicalAddress.Hw32 = 
            sgEntry->LogicalAddress.Hw32 + *Offset;
        splitSgList->SgEntry[0].SystemAddress = 
            sgEntry->SystemAddress + *Offset;
        splitSgList->SgEntry[0].Length = length;
        // start offset is always 0 for the first element
        splitSgList->SgEntry[0].StartOffset = 0;

        SplitTransfer->Tp.TransferBufferLength = 
            length;
            
        SplitTransfer->Tp.MiniportFlags = MPTX_SPLIT_TRANSFER;
            
        splitSgList->MdlVirtualAddress = 
            SgList->MdlVirtualAddress + LengthMapped;
            
        splitSgList->MdlSystemAddress = 
            SgList->MdlSystemAddress + LengthMapped;

        // indicate that this is a split child
        SET_FLAG(SplitTransfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD);
        
        *Offset += length;
        BytesToMap -= length;
        
    } else {
    
        // make transfer from last part of sg[Idx] 
        // and first part of sg[Idx+1] if necessary, 
        // inc Idx
        // reset offset

        // case 2
        length = sgEntry->Length - *Offset;
        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'spt2', 
             MaxTransferLength, 
             *Offset, 
             length);
             
        USBPORT_ASSERT(length <= MaxTransferLength);

        // last part of sg1;
        splitSgList = &SplitTransfer->SgList;

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'sgE1', 
                    splitSgList,
                    sgEntry,
                    0);
                    
        splitSgList->SgCount = 1;
        splitSgList->SgEntry[0].LogicalAddress.Hw32 = 
            sgEntry->LogicalAddress.Hw32 + *Offset;
        splitSgList->SgEntry[0].SystemAddress = 
            sgEntry->SystemAddress + *Offset;
        splitSgList->SgEntry[0].Length = length;
        // start offset is always 0 for the first element
        splitSgList->SgEntry[0].StartOffset = 0;

        SplitTransfer->Tp.TransferBufferLength = 
            length; 

        SplitTransfer->Tp.MiniportFlags = MPTX_SPLIT_TRANSFER;

        splitSgList->MdlVirtualAddress = 
            SgList->MdlVirtualAddress + LengthMapped;
            
        splitSgList->MdlSystemAddress = 
            SgList->MdlSystemAddress + LengthMapped;
            
        // indicate that this is a split child
        SET_FLAG(SplitTransfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD);

        *Offset += length;             
        BytesToMap -= length;

        // calculate max size of second part
        length = MaxTransferLength - length;
        
        if (length > BytesToMap) {
            length = BytesToMap;
        }

        if (length == 0) {
        
            (*Idx)++;
            *Offset = 0;
            
        } else {

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'spt3', 
                     MaxTransferLength, 
                     *Offset, 
                     length);
                     
            (*Idx)++;
            *Offset = 0;

            sgEntry = &SgList->SgEntry[*Idx];

            LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'sgE2', 
                    splitSgList,
                    sgEntry,
                    *Idx);
                    
            splitSgList->SgCount++;
            splitSgList->SgEntry[1].LogicalAddress.Hw32 = 
                sgEntry->LogicalAddress.Hw32 + *Offset;
            splitSgList->SgEntry[1].SystemAddress = 
                sgEntry->SystemAddress + *Offset;
            splitSgList->SgEntry[1].Length = length;
            splitSgList->SgEntry[1].StartOffset =
                splitSgList->SgEntry[0].Length;

            SplitTransfer->Tp.TransferBufferLength += length; 

            *Offset += length;             
            BytesToMap -= length;
                
        } 
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'spt>', 
                     BytesToMap, 
                     0, 
                     0);

    return BytesToMap;
}        


NTSTATUS
USBPORT_SplitBulkInterruptTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PLIST_ENTRY TransferList
    )    
/*++

Routine Description:

    Split a bulk or interrupt transfer

Arguments:

Return Value:

    nt status code

--*/
{
    ULONG maxTransferLength, maxPacketLength;
    PHCD_TRANSFER_CONTEXT splitTransfer;
    PTRANSFER_SG_LIST sgList;
    LIST_ENTRY tmpList;
    ULONG idx, i, offset, bytesToMap, lengthMapped;
    ULONG numberOfSplits;
    PLIST_ENTRY listEntry;

    sgList = &Transfer->SgList;
    maxPacketLength = EP_MAX_PACKET(Endpoint);
    USBPORT_ASSERT(EP_MAX_TRANSFER(Endpoint) >= maxPacketLength);
    // round to the smallest multiple of max packet size
    maxTransferLength = 
        (EP_MAX_TRANSFER(Endpoint)/maxPacketLength) * maxPacketLength;
    
    // some notes:

    // 
    //
    // The MAXTRANSFER is equal to USB_PAGE_SIZE (4k) and
    // the transfer sg list is broken into usb pages.  In this 
    // case we construct a transfer structure for each pair of
    // sg entries we round the length of the first sg entry down
    // to the highest multiple of MAXPACKET so we get a split 
    // pattern like this:
    // 
    //          {Sg1}{.Sg2.}{.Sg3.}{.Sg4.}     sg entries
    //       |------|------|------|------|     page breaks
    //          |----------------------|       original transfer
    //          <...><>                           
    //                 <...><>                         
    //                        <...><><.>               
    //          {1    }{2    }{3    }{4}       splits
    //             

    // The MAXTRANSFER is less than USB_PAGE_SIZE (4k) and the 
    // transfer sg list is broken into usb pages.
    //
    // the pattern will look like this:
    //
    //        {...Sg1......}{......Sg2......}{......Sg3......}
    //    |----------------|----------------|----------------|
    //        |-----------------------------------|
    //        <..>
    //            <..>
    //                <..>
    //                    <><>
    //                        <..>
    //                            <..>
    //                                <..>
    //                                    <><>
    //                                        <..>
    //        {1 }{2 }{3 }{4 }{5 }{6 }{7 }{8 }{9 }

    // cases:
    // case 1 - transfer lies within the sg entry
    // case 2 - transfer overlaps the sg entry


    // 
    // The MAXTRANSFER is greater than USB_PAGE_SIZE (4k)
    // ie etc, we currently don't handle this case
    //
    // Note: since the buffer is currently completely mapped 
    // and locked it is better to tune the mniport to take the 
    // larger transfers if possible
    
    if (EP_MAX_TRANSFER(Endpoint) > USB_PAGE_SIZE) {
        
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0);
    }
    
    
    // allocate the split elements

    // mark the parent transfer as a split
    SET_FLAG(Transfer->Flags, USBPORT_TXFLAG_SPLIT);

    numberOfSplits = 
        Transfer->Tp.TransferBufferLength / maxTransferLength + 1;

    LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'sptC', 
                     numberOfSplits, 
                     0, 
                     0);        
    
    InitializeListHead(&tmpList);
    
    for (i=0; i<numberOfSplits; i++) {
    
        ALLOC_POOL_Z(splitTransfer, 
                     NonPagedPool,
                     Transfer->TotalLength);

        if (splitTransfer == NULL) {
            goto SplitBulkInterruptTransfer_Fail;
        }            
        
        RtlCopyMemory(splitTransfer,
                      Transfer,
                      Transfer->TotalLength);

        splitTransfer->MiniportContext = (PUCHAR) splitTransfer;
        splitTransfer->MiniportContext += splitTransfer->PrivateLength;                      
        InitializeListHead(&splitTransfer->DoubleBufferList);
        
        InsertTailList(&tmpList, 
                       &splitTransfer->TransferLink);
         
    }

    idx = 0;
    offset = 0;
    bytesToMap = Transfer->Tp.TransferBufferLength;
    lengthMapped = 0;
    
    while (bytesToMap) {

        LOGENTRY(NULL, FdoDeviceObject, LOG_XFERS, 'sptM', 
                     bytesToMap, 
                     offset, 
                     idx);
    
        listEntry = RemoveHeadList(&tmpList);
        
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);

        ASSERT_TRANSFER(splitTransfer);
 
        bytesToMap = USBPORT_MakeSplitTransfer(FdoDeviceObject,
                                               sgList, 
                                               splitTransfer,
                                               maxTransferLength,
                                               maxPacketLength,
                                               &idx,
                                               &offset,
                                               bytesToMap,
                                               lengthMapped);

        lengthMapped += splitTransfer->Tp.TransferBufferLength;                                               

        InsertTailList(TransferList, 
                       &splitTransfer->TransferLink);
                       
        InsertTailList(&Transfer->SplitTransferList, 
                       &splitTransfer->SplitLink);   
                       
    }

    // free extra splits we did not use
    while (!IsListEmpty(&tmpList)) {

        listEntry = RemoveHeadList(&tmpList);
        
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);

        ASSERT_TRANSFER(splitTransfer);

        UNSIG(splitTransfer);
        FREE_POOL(FdoDeviceObject, splitTransfer);   
    }

    return STATUS_SUCCESS;

SplitBulkInterruptTransfer_Fail:

    TEST_TRAP();
    // free the tmp list
    while (!IsListEmpty(&tmpList)) {
       
        listEntry = RemoveHeadList(&tmpList);
        
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);

        ASSERT_TRANSFER(splitTransfer);

        UNSIG(splitTransfer);
        FREE_POOL(FdoDeviceObject, splitTransfer);                        
    }

    return STATUS_INSUFFICIENT_RESOURCES;
    
}


#if 0
NTSTATUS
USBPORT_SplitIsochronousTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PLIST_ENTRY TransferList
    )    
/*++

Routine Description:

    Split an iso transfer

Arguments:

Return Value:

    none

--*/
{
    PMINIPORT_ISO_TRANSFER isoTransfer, splitIsoTransfer;
    PHCD_TRANSFER_CONTEXT splitTransfer;
    LIST_ENTRY tmpList;
    
    // first figure out how many child transfer structures
    // we will need and allocate them, we do this based on 
    // the most packets we can fit in to a request

    // we do not fixup the SG table for the child transfers 
    // since this information is not passed to the miniport

    isoTransfer = Transfer->IsoTransfer;

    transferCount = 0;
    length = 0;
    maxSplitLength = EP_MAX_TRANSFER(Endpoint);
    
    for (i=0; i<isoTransfer->PacketCount; i++) {
        if (length + isoTransfer->Packets[i].Length > maxSplitLength) {    
            length = 0;
            transferCount++;
        } else {
            length += isoTransfer->Packets[i].Length
        }
    }

    // transferCount is the number of child transfers,
    // allocate them the now and clone the parent 
    InitializeListHead(tmpList);
    for (i=0; i<transferCount; i++) {
        TRANSFER_SG_LIST sgList;
        
        splitTransfer = ALLOC()
        if (splitTransfer == NULL) {
            // release resources and return an error
            TEST_TRAP();
            xxx;
            break;
        }            
        RtlCopyMemory(splitTransfer,
                      Transfer,
                      Transfer->TotalLength);

        sgList = &splitTransfer->SgList;
        // zap the sg table since we don't use it for children
        for (j=0; j<sgList->SgCount; j++) {
            sgList->SgEntry[j].LogicalAddress = 0xffffffff;
            sgList->SgEntry[j].SystemAddress = USB_BAD_PTR;
            sgList->SgEntry[j].Length = 0xffffffff;
            sgList->SgEntry[j].StartOffset = 0xffffffff;
        }            
        sgList->Flags = 0xFFFFFFFF;
        sgList->MdlVirtualAddress = USB_BAD_PTR;
        sgList->MdlSystemAddress = USB_BAD_PTR;
        sgList->SgCount = 0xFFFFFFFF;
        
        InsertTailList(&tmpList, 
                       &splitTransfer->TransferLink);                      
    }

    // we now have a list of child transfer structures.
    
    // intialize them
    pkt = 0;
    systemAddress = isoTransfer->SystemAddress;
    InitializeListHead(&Transfer->SplitTransferList);
    do {
    
        listEntry = RemoveHeadList(&tmpList);
        
        splitTransfer = (PHCD_TRANSFER_CONTEXT) CONTAINING_RECORD(
                        listEntry,
                        struct _HCD_TRANSFER_CONTEXT, 
                        TransferLink);
                    
        ASSERT_TRANSFER(splitTransfer);
        SET_FLAG(transfer->Flags, USBPORT_TXFLAG_SPLIT_CHILD);
        splitIsoTransfer = splitTransfer->IsoTransfer; 
        splitIsoTransfer->PacketCount = 0;
        splitIsoTransfer->SystemAdderess = systemAddress;
        splitLength = 0;
        i = 0;
        InsertTailList(TransferList, 
                       &splitTransfer->TransferLink); 
        InsertTailList(Transfer->SplitTransferList, 
                       &splitTransfer->SplitLink);   

        while (1) {
            if (splitLength + isoTransfer->Packets[pkt].Length > maxSplitLength) {    
                // this transfer is filled, move to the next one
                systemAddress += splitLength;
                break;
            } else {
                splitIsoTransfer->Packets[i] = isoTransfer->Packets[pkt];   
                splitLength += splitIsoTransfer->Packets[i].Length;
                splitIsoTransfer->PacketCount++;    
                pkt++;
                i++;
            }
        }
    } while (pkt < isoTransfer->PacketCount); 

}
#endif

VOID
USBPORT_SplitTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint,
    PHCD_TRANSFER_CONTEXT Transfer,
    PLIST_ENTRY TransferList
    )    
/*++

Routine Description:

    Splits a transfer into multiple transfers of the proper size 
    for the miniport.

    Returns a list of transfer structures that need to be added to
    the active list.  If the transfer does not need to be split the
    list will contain only the original transfer.

Arguments:

Return Value:

    none

--*/
{

    InitializeListHead(TransferList);
    InitializeListHead(&Transfer->SplitTransferList);
    Transfer->UsbdStatus = USBD_STATUS_SUCCESS;

    if (Transfer->Tp.TransferBufferLength <= EP_MAX_TRANSFER(Endpoint)) {
        // no split needed
        InsertTailList(TransferList, 
                       &Transfer->TransferLink);
        return;                       
    }

    switch(Endpoint->Parameters.TransferType) {
    case Interrupt:
    case Bulk:
        USBPORT_SplitBulkInterruptTransfer(FdoDeviceObject,
                                           Endpoint,
                                           Transfer,
                                           TransferList);        
        break;
    case Control:
        // not supported yet
        // although currently not supported the USBD stack never 
        // correctly implemented transfers > 4k so we fudge it here
        // 
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0);
        break;
    case Isochronous:
        BUGCHECK(USBBUGCODE_INTERNAL_ERROR, 0, 0, 0);
        break;
    }
}    


VOID
USBPORT_DoneSplitTransfer(
    PHCD_TRANSFER_CONTEXT SplitTransfer
    )    
/*++

Routine Description:

    Called when a split transfer is completed by hardware
    this function only completes active transfers

Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL tIrql;
                   
    endpoint = SplitTransfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'dnSP',
        SplitTransfer, 0, 0);
     
    // get the parent
    transfer = SplitTransfer->Transfer;
    ASSERT_TRANSFER(transfer);
    
    //
    // copy the child data to the parent transfer
    // 
    transfer->MiniportBytesTransferred += 
        SplitTransfer->MiniportBytesTransferred;

    // error ?
    //
    if (SplitTransfer->UsbdStatus != USBD_STATUS_SUCCESS && 
        !TEST_FLAG(SplitTransfer->Flags, USBPORT_TXFLAG_KILL_SPLIT)) {
        transfer->UsbdStatus = SplitTransfer->UsbdStatus;
    }

    ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);
    // remove this transfer from the list
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'rmSP',
            transfer, 0, SplitTransfer);
    RemoveEntryList(&SplitTransfer->SplitLink);

    // flush any triple buffers
    USBPORT_FlushAdapterDBs(fdoDeviceObject,
                            SplitTransfer);

    // free this child
    UNSIG(SplitTransfer);
    FREE_POOL(fdoDeviceObject, SplitTransfer);
    
    // is the transfer complete?
    if (IsListEmpty(&transfer->SplitTransferList)) {
        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cpSP',
            transfer, 0, 0);
        RELEASE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);
            
        USBPORT_DoneTransfer(transfer);
    } else {
        RELEASE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);
    }
}


VOID
USBPORT_CancelSplitTransfer(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_TRANSFER_CONTEXT SplitTransfer
    )    
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    PHCD_TRANSFER_CONTEXT transfer;
    PHCD_ENDPOINT endpoint;
    PDEVICE_OBJECT fdoDeviceObject;
    KIRQL tIrql;
                   
    endpoint = SplitTransfer->Endpoint;    
    ASSERT_ENDPOINT(endpoint);
    fdoDeviceObject = endpoint->FdoDeviceObject;

    // remove the child, when all children are gone put the 
    // parent on the cancel list
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'caSP',
        SplitTransfer, 0, 0);
     
    // get the parent
    transfer = SplitTransfer->Transfer;
    ASSERT_TRANSFER(transfer);
    
    //
    // copy the child data to the parent transfer
    // 
    transfer->MiniportBytesTransferred += 
        SplitTransfer->MiniportBytesTransferred;

    ACQUIRE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);
    // remove this transfer from the list
    LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'rmSP',
            transfer, 0, SplitTransfer);
    RemoveEntryList(&SplitTransfer->SplitLink);
    RELEASE_TRANSFER_LOCK(fdoDeviceObject, transfer, tIrql);

    // free this child
    UNSIG(SplitTransfer);
    FREE_POOL(fdoDeviceObject, SplitT