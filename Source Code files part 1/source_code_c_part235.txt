ICorDebugStepperEnum_Next(This,celt,steppers,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,steppers,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepperEnum_Next_Proxy( 
    ICorDebugStepperEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugStepperEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepperEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcessEnum_INTERFACE_DEFINED__
#define __ICorDebugProcessEnum_INTERFACE_DEFINED__

/* interface ICorDebugProcessEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcessEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB05-8A68-11d2-983C-0000F808342D")
    ICorDebugProcessEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcessEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcessEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugProcessEnumVtbl;

    interface ICorDebugProcessEnum
    {
        CONST_VTBL struct ICorDebugProcessEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcessEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcessEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcessEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcessEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugProcessEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugProcessEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugProcessEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugProcessEnum_Next(This,celt,processes,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,processes,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcessEnum_Next_Proxy( 
    ICorDebugProcessEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugProcessEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcessEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThreadEnum_INTERFACE_DEFINED__
#define __ICorDebugThreadEnum_INTERFACE_DEFINED__

/* interface ICorDebugThreadEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugThreadEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB06-8A68-11d2-983C-0000F808342D")
    ICorDebugThreadEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThreadEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThreadEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugThreadEnumVtbl;

    interface ICorDebugThreadEnum
    {
        CONST_VTBL struct ICorDebugThreadEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThreadEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThreadEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThreadEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThreadEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugThreadEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugThreadEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugThreadEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugThreadEnum_Next(This,celt,threads,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,threads,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThreadEnum_Next_Proxy( 
    ICorDebugThreadEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugThreadEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThreadEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrameEnum_INTERFACE_DEFINED__
#define __ICorDebugFrameEnum_INTERFACE_DEFINED__

/* interface ICorDebugFrameEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrameEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB07-8A68-11d2-983C-0000F808342D")
    ICorDebugFrameEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrameEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrameEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugFrameEnumVtbl;

    interface ICorDebugFrameEnum
    {
        CONST_VTBL struct ICorDebugFrameEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrameEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrameEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrameEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrameEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugFrameEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugFrameEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugFrameEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugFrameEnum_Next(This,celt,frames,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,frames,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrameEnum_Next_Proxy( 
    ICorDebugFrameEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugFrameEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrameEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChainEnum_INTERFACE_DEFINED__
#define __ICorDebugChainEnum_INTERFACE_DEFINED__

/* interface ICorDebugChainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugChainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB08-8A68-11d2-983C-0000F808342D")
    ICorDebugChainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugChainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugChainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugChainEnumVtbl;

    interface ICorDebugChainEnum
    {
        CONST_VTBL struct ICorDebugChainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugChainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugChainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugChainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugChainEnum_Next(This,celt,chains,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,chains,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChainEnum_Next_Proxy( 
    ICorDebugChainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugChainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleEnum_INTERFACE_DEFINED__
#define __ICorDebugModuleEnum_INTERFACE_DEFINED__

/* interface ICorDebugModuleEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB09-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugModuleEnumVtbl;

    interface ICorDebugModuleEnum
    {
        CONST_VTBL struct ICorDebugModuleEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugModuleEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugModuleEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugModuleEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugModuleEnum_Next(This,celt,modules,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,modules,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleEnum_Next_Proxy( 
    ICorDebugModuleEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugModuleEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueEnum_INTERFACE_DEFINED__
#define __ICorDebugValueEnum_INTERFACE_DEFINED__

/* interface ICorDebugValueEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0A-8A68-11d2-983C-0000F808342D")
    ICorDebugValueEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugValueEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugValueEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugValueEnumVtbl;

    interface ICorDebugValueEnum
    {
        CONST_VTBL struct ICorDebugValueEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugValueEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugValueEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugValueEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugValueEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueEnum_Next_Proxy( 
    ICorDebugValueEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugValueEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__
#define __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__

/* interface ICorDebugErrorInfoEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugErrorInfoEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0E18809-72B5-11d2-976F-00A0C9B4D50C")
    ICorDebugErrorInfoEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugErrorInfoEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugErrorInfoEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugErrorInfoEnumVtbl;

    interface ICorDebugErrorInfoEnum
    {
        CONST_VTBL struct ICorDebugErrorInfoEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugErrorInfoEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugErrorInfoEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugErrorInfoEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugErrorInfoEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugErrorInfoEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugErrorInfoEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugErrorInfoEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugErrorInfoEnum_Next(This,celt,errors,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,errors,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugErrorInfoEnum_Next_Proxy( 
    ICorDebugErrorInfoEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugErrorInfoEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_INTERFACE_DEFINED__
#define __ICorDebugAppDomainEnum_INTERFACE_DEFINED__

/* interface ICorDebugAppDomainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63ca1b24-4359-4883-bd57-13f815f58744")
    ICorDebugAppDomainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAppDomainEnumVtbl;

    interface ICorDebugAppDomainEnum
    {
        CONST_VTBL struct ICorDebugAppDomainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAppDomainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAppDomainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAppDomainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAppDomainEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomainEnum_Next_Proxy( 
    ICorDebugAppDomainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAppDomainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_INTERFACE_DEFINED__
#define __ICorDebugAssemblyEnum_INTERFACE_DEFINED__

/* interface ICorDebugAssemblyEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a2a1ec9-85ec-4bfb-9f15-a89fdfe0fe83")
    ICorDebugAssemblyEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAssemblyEnumVtbl;

    interface ICorDebugAssemblyEnum
    {
        CONST_VTBL struct ICorDebugAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssemblyEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAssemblyEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAssemblyEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssemblyEnum_Next_Proxy( 
    ICorDebugAssemblyEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAssemblyEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueErrorInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D600D41-F4F6-4cb3-B7EC-7BD164944036")
    ICorDebugEditAndContinueErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCode( 
            /* [out] */ HRESULT *pHr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCode )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ HRESULT *pHr);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugEditAndContinueErrorInfoVtbl;

    interface ICorDebugEditAndContinueErrorInfo
    {
        CONST_VTBL struct ICorDebugEditAndContinueErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueErrorInfo_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugEditAndContinueErrorInfo_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugEditAndContinueErrorInfo_GetErrorCode(This,pHr)	\
    (This)->lpVtbl -> GetErrorCode(This,pHr)

#define ICorDebugEditAndContinueErrorInfo_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetModule_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetToken_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetErrorCode_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ HRESULT *pHr);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetString_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueSnapshot */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DC3FA01-D7CB-11d2-8A95-0080C792E5D8")
    ICorDebugEditAndContinueSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CopyMetaData( 
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMvid( 
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoDataRVA( 
            /* [out] */ ULONG32 *pRoDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRwDataRVA( 
            /* [out] */ ULONG32 *pRwDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPEBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILMap( 
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPESymbolBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        HRESULT ( STDMETHODCALLTYPE *CopyMetaData )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMvid )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRoDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *GetRwDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRwDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *SetPEBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetILMap )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetPESymbolBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        END_INTERFACE
    } ICorDebugEditAndContinueSnapshotVtbl;

    interface ICorDebugEditAndContinueSnapshot
    {
        CONST_VTBL struct ICorDebugEditAndContinueSnapshotVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueSnapshot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueSnapshot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueSnapshot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueSnapshot_CopyMetaData(This,pIStream,pMvid)	\
    (This)->lpVtbl -> CopyMetaData(This,pIStream,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetMvid(This,pMvid)	\
    (This)->lpVtbl -> GetMvid(This,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetRoDataRVA(This,pRoDataRVA)	\
    (This)->lpVtbl -> GetRoDataRVA(This,pRoDataRVA)

#define ICorDebugEditAndContinueSnapshot_GetRwDataRVA(This,pRwDataRVA)	\
    (This)->lpVtbl -> GetRwDataRVA(This,pRwDataRVA)

#define ICorDebugEditAndContinueSnapshot_SetPEBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPEBytes(This,pIStream)

#define ICorDebugEditAndContinueSnapshot_SetILMap(This,mdFunction,cMapSize,map)	\
    (This)->lpVtbl -> SetILMap(This,mdFunction,cMapSize,map)

#define ICorDebugEditAndContinueSnapshot_SetPESymbolBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPESymbolBytes(This,pIStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_CopyMetaData_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_CopyMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetMvid_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetMvid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRoDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRwDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPEBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPEBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetILMap_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ mdToken mdFunction,
    /* [in] */ ULONG cMapSize,
    /* [size_is][in] */ COR_IL_MAP map[  ]);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetILMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HPROCESS_UserSize(     unsigned long *, unsigned long            , HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserMarshal(  unsigned long *, unsigned char *, HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserUnmarshal(unsigned long *, unsigned char *, HPROCESS * ); 
void                      __RPC_USER  HPROCESS_UserFree(     unsigned long *, HPROCESS * ); 

unsigned long             __RPC_USER  HTHREAD_UserSize(     unsigned long *, unsigned long            , HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserMarshal(  unsigned long *, unsigned char *, HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserUnmarshal(unsigned long *, unsigned char *, HTHREAD * ); 
void                      __RPC_USER  HTHREAD_UserFree(     unsigned long *, HTHREAD * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cordbpriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * cordbpriv.h -- header file for private Debugger data shared by various
 *                Runtime components.
 * ------------------------------------------------------------------------- */

#ifndef _cordbpriv_h_
#define _cordbpriv_h_

#include "corhdr.h"

//
// Environment variable used to control the Runtime's debugging modes.
// This is PURELY FOR INTERNAL, NONSHIPPING USAGE!! (ie, for the test team)
//
#define CorDB_CONTROL_ENV_VAR_NAME      "Cor_Debugging_Control_424242"
#define CorDB_CONTROL_ENV_VAR_NAMEL    L"Cor_Debugging_Control_424242"

//
// Environment variable used to controll the Runtime's debugging modes.
//
#define CorDB_REG_KEY                 FRAMEWORK_REGISTRY_KEY_W L"\\"
#define CorDB_REG_DEBUGGER_KEY       L"DbgManagedDebugger"
#define CorDB_REG_QUESTION_KEY       L"DbgJITDebugLaunchSetting"
#define CorDB_ENV_DEBUGGER_KEY       L"COMPLUS_DbgManagedDebugger"

//
// We split the value of DbgJITDebugLaunchSetting between the value for whether or not to ask the user and between a
// mask of places to ask. The places to ask are specified in the UnhandledExceptionLocation enum in excep.h.
//
enum DebuggerLaunchSetting
{
    DLS_ASK_USER          = 0x00000000,
    DLS_TERMINATE_APP     = 0x00000001,
    DLS_ATTACH_DEBUGGER   = 0x00000002,
    DLS_QUESTION_MASK     = 0x0000000F,
    DLS_ASK_WHEN_SERVICE  = 0x00000010,
    DLS_MODIFIER_MASK     = 0x000000F0,
    DLS_LOCATION_MASK     = 0xFFFFFF00,
    DLS_LOCATION_SHIFT    = 8 // Shift right 8 bits to get a UnhandledExceptionLocation value from the location part.
};


//
// Flags used to control the Runtime's debugging modes. These indicate to
// the Runtime that it needs to load the Runtime Controller, track data
// during JIT's, etc.
//
enum DebuggerControlFlag
{
    DBCF_NORMAL_OPERATION			= 0x0000,

    DBCF_USER_MASK					= 0x00FF,
    DBCF_GENERATE_DEBUG_CODE		= 0x0001,
    DBCF_ALLOW_JIT_OPT				= 0x0008,
    DBCF_PROFILER_ENABLED			= 0x0020,
	DBCF_ACTIVATE_REMOTE_DEBUGGING	= 0x0040,

    DBCF_INTERNAL_MASK				= 0xFF00,
    DBCF_ATTACHED					= 0x0200
};

//
// Flags used to control the debuggable state of modules and
// assemblies.
//
enum DebuggerAssemblyControlFlags
{
    DACF_NONE                       = 0x00,
    DACF_USER_OVERRIDE              = 0x01,
    DACF_ALLOW_JIT_OPTS             = 0x02,
    DACF_TRACK_JIT_INFO             = 0x04,
    DACF_ENC_ENABLED                = 0x08,
    DACF_CONTROL_FLAGS_MASK         = 0x0F,

    DACF_PDBS_COPIED                = 0x10,
    DACF_MISC_FLAGS_MASK            = 0x10,
};


// {74860182-3295-4954-8BD5-40B5C9E7C4EA}
extern const GUID __declspec(selectany) IID_ICorDBPrivHelper =
    {0x74860182,0x3295,0x4954,{0x8b,0xd5,0x40,0xb5,0xc9,0xe7,0xc4,0xea}};

/*
 * This class is used to help the debugger get a COM interface pointer to
 * a newly created managed object.
 */
class ICorDBPrivHelper : public IUnknown
{
public:
    ///////////////////////////////////////////////////////////////////////////
    // ICorDBPrivHelper methods

    // This is the main method of this interface.  This assumes that
    // the runtime has been started, and it will load the assembly
    // specified, load the class specified, run the cctor, create an
    // instance of the class and return an IUnknown wrapper to that
    // object.
    virtual HRESULT STDMETHODCALLTYPE CreateManagedObject(
        /*in*/  WCHAR *wszAssemblyName,
        /*in*/  WCHAR *wszModuleName,
        /*in*/  mdTypeDef classToken,
        /*in*/  void *rawData,
        /*out*/ IUnknown **ppUnk) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetManagedObjectContents(
        /* in */ IUnknown *pObject,
        /* in */ void *rawData,
        /* in */ ULONG32 dataSize) = 0;
};

#endif /* _cordbpriv_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cordebug_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:08 2003
 */
/* Compiler settings for cordebug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_CORDBLib,0x53D13620,0xF417,0x11d1,0x97,0x62,0xA6,0x38,0x26,0xA4,0xF2,0x55);


MIDL_DEFINE_GUID(CLSID, CLSID_CorDebug,0x6fef44d0,0x39e7,0x4c77,0xbe,0x8e,0xc9,0xf8,0xcf,0x98,0x86,0x30);


MIDL_DEFINE_GUID(CLSID, CLSID_EmbeddedCLRCorDebug,0x211f1254,0xbc7e,0x4af5,0xb9,0xaa,0x06,0x73,0x08,0xd8,0x3d,0xd1);


MIDL_DEFINE_GUID(IID, IID_ICorDebugManagedCallback,0x3d6f5f60,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorDebugUnmanagedCallback,0x5263E909,0x8CB5,0x11d3,0xBD,0x2F,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(IID, IID_ICorDebug,0x3d6f5f61,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorDebugController,0x3d6f5f62,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorDebugAppDomain,0x3d6f5f63,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorDebugAssembly,0xdf59507c,0xd47a,0x459e,0xbc,0xe2,0x64,0x27,0xea,0xc8,0xfd,0x06);


MIDL_DEFINE_GUID(IID, IID_ICorDebugProcess,0x3d6f5f64,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorDebugBreakpoint,0xCC7BCAE8,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugFunctionBreakpoint,0xCC7BCAE9,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugModuleBreakpoint,0xCC7BCAEA,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugValueBreakpoint,0xCC7BCAEB,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugStepper,0xCC7BCAEC,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugRegisterSet,0xCC7BCB0B,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugThread,0x938c6d66,0x7fb6,0x4f69,0xb3,0x89,0x42,0x5b,0x89,0x87,0x32,0x9b);


MIDL_DEFINE_GUID(IID, IID_ICorDebugChain,0xCC7BCAEE,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugFrame,0xCC7BCAEF,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugILFrame,0x03E26311,0x4F76,0x11d3,0x88,0xC6,0x00,0x60,0x97,0x94,0x54,0x18);


MIDL_DEFINE_GUID(IID, IID_ICorDebugNativeFrame,0x03E26314,0x4F76,0x11d3,0x88,0xC6,0x00,0x60,0x97,0x94,0x54,0x18);


MIDL_DEFINE_GUID(IID, IID_ICorDebugModule,0xdba2d8c1,0xe5c5,0x4069,0x8c,0x13,0x10,0xa7,0xc6,0xab,0xf4,0x3d);


MIDL_DEFINE_GUID(IID, IID_ICorDebugFunction,0xCC7BCAF3,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugCode,0xCC7BCAF4,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugClass,0xCC7BCAF5,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugEval,0xCC7BCAF6,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugValue,0xCC7BCAF7,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugGenericValue,0xCC7BCAF8,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugReferenceValue,0xCC7BCAF9,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugHeapValue,0xCC7BCAFA,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugObjectValue,0x18AD3D6E,0xB7D2,0x11d2,0xBD,0x04,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(IID, IID_ICorDebugBoxValue,0xCC7BCAFC,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugStringValue,0xCC7BCAFD,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugArrayValue,0x0405B0DF,0xA660,0x11d2,0xBD,0x02,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(IID, IID_ICorDebugContext,0xCC7BCB00,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugEnum,0xCC7BCB01,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugObjectEnum,0xCC7BCB02,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugBreakpointEnum,0xCC7BCB03,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugStepperEnum,0xCC7BCB04,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugProcessEnum,0xCC7BCB05,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugThreadEnum,0xCC7BCB06,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugFrameEnum,0xCC7BCB07,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugChainEnum,0xCC7BCB08,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugModuleEnum,0xCC7BCB09,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugValueEnum,0xCC7BCB0A,0x8A68,0x11d2,0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D);


MIDL_DEFINE_GUID(IID, IID_ICorDebugErrorInfoEnum,0xF0E18809,0x72B5,0x11d2,0x97,0x6F,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorDebugAppDomainEnum,0x63ca1b24,0x4359,0x4883,0xbd,0x57,0x13,0xf8,0x15,0xf5,0x87,0x44);


MIDL_DEFINE_GUID(IID, IID_ICorDebugAssemblyEnum,0x4a2a1ec9,0x85ec,0x4bfb,0x9f,0x15,0xa8,0x9f,0xdf,0xe0,0xfe,0x83);


MIDL_DEFINE_GUID(IID, IID_ICorDebugEditAndContinueErrorInfo,0x8D600D41,0xF4F6,0x4cb3,0xB7,0xEC,0x7B,0xD1,0x64,0x94,0x40,0x36);


MIDL_DEFINE_GUID(IID, IID_ICorDebugEditAndContinueSnapshot,0x6DC3FA01,0xD7CB,0x11d2,0x8A,0x95,0x00,0x80,0xC7,0x92,0xE5,0xD8);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corhdr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__

#define FRAMEWORK_REGISTRY_KEY          "Software\\Microsoft\\.NETFramework"
#define FRAMEWORK_REGISTRY_KEY_W        L"Software\\Microsoft\\.NETFramework"

#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
typedef LPVOID  mdScope;                // Why is this still needed?
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope  
typedef mdToken mdMethodDef;            // Method in this scope 
typedef mdToken mdParamDef;             // param token  
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)  
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdToken mdPermission;           // DeclSecurity 

typedef mdToken mdSignature;            // Signature object 
typedef mdToken mdEvent;                // event token  
typedef mdToken mdProperty;             // property token   

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)  

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdExportedType;         // ExportedType token.
typedef mdToken mdManifestResource;     // ManifestResource token.

typedef mdToken mdTypeSpec;             // TypeSpec object 

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token   

#ifndef MACROS_NOT_SUPPORTED
typedef unsigned long RID;      
#else
typedef unsigned RID;      
#endif // MACROS_NOT_SUPPORTED

typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for CLR data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


// @TODO: This hack is required because we pull in the COM+ 2.0 PE header
// definition from winnt.h, and the flag below hasn't propogated yet.
#define   COMIMAGE_FLAGS_STRONGNAMESIGNED     0x00000008

#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// CLR Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =0,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,   
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,    
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.   
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.   
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
	COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,   // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths    
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    ULONG                   cb;              
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;
    
    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;        
    ULONG                   Flags;           
    ULONG                   EntryPointToken;
    
    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
    
} IMAGE_COR20_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

#define COR_ENUM_FIELD_NAME			"value__"
#define COR_ENUM_FIELD_NAME_W		L"value__"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix 
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ExportedType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdSequentialLayout      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000020,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,     
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    // end string format mask

    tdBeforeFieldInit       =   0x00100000,     // Initialize the class any time before first static field access.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdSequentialLayout(x)             (((x) & tdLayoutMask) == tdSequentialLayout)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)

#define IsTdBeforeFieldInit(x)              ((x) & tdBeforeFieldInit)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdCheckAccessOnOverride     =   0x0200,     // Overridability is the same as the visibility.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.
    
    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdCheckAccessOnOverride(x)        ((x) & mdCheckAccessOnOverride)
#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.
    
    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0x9500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

// Param attr bits, used by DefineParam. 
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]    
    pdOut                       =   0x0002,     // Param is [out]   
    pdOptional                  =   0x0010,     // Param is optional    

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.
    
    pdUnused                    =   0xcfe0,
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default 
    
    prUnused                =   0xe9ff,
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property  
    msGetter    =   0x0002,     // Getter for property  
    msOther     =   0x0004,     // other method for property or event   
    msAddOn     =   0x0008,     // AddOn method for event   
    msRemoveOn  =   0x0010,     // RemoveOn method for event    
    msFire      =   0x0020,     // Fire method for event    
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask       =   0x000f,     // Mask allows growth of enum.
    dclActionNil        =   0x0000, 
    dclRequest          =   0x0001,     //  
    dclDemand           =   0x0002,     //  
    dclAssert           =   0x0003,     //  
    dclDeny             =   0x0004,     //  
    dclPermitOnly       =   0x0005,     //  
    dclLinktimeCheck    =   0x0006,     //  
    dclInheritanceCheck =   0x0007,     //  
    dclRequestMinimum   =   0x0008,     //
    dclRequestOptional  =   0x0009,     //
    dclRequestRefuse    =   0x000a,     //
    dclPrejitGrant      =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied     =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand     =   0x000d,     //
    dclNonCasLinkDemand =   0x000e,
    dclNonCasInheritance=   0x000f,
    dclMaximumValue     =   0x000f,     // Maximum legal value  
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
#define IsDclRequest(x)                     (((x) & dclActionMask) == dclRequest)
#define IsDclDemand(x)                      (((x) & dclActionMask) == dclDemand)
#define IsDclAssert(x)                      (((x) & dclActionMask) == dclAssert)
#define IsDclDeny(x)                        (((x) & dclActionMask) == dclDeny)
#define IsDclPermitOnly(x)                  (((x) & dclActionMask) == dclPermitOnly)
#define IsDclLinktimeCheck(x)               (((x) & dclActionMask) == dclLinktimeCheck)
#define IsDclInheritanceCheck(x)            (((x) & dclActionMask) == dclInheritanceCheck)
#define IsDclMaximumValue(x)                (((x) & dclActionMask) == dclMaximumValue)


// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.   
    miIL                =   0x0000,   // Method impl is IL.   
    miNative            =   0x0001,   // Method impl is native.     
    miOPTIL             =   0x0002,   // Method impl is OPTIL 
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miPreserveSig       =   0x0080,   // Indicates method sig is not to be mangled to do HRESULT conversion.

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.                                      
    miMaxMethodImplVal  =   0xffff,   // Range check value    
} CorMethodImpl; 

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiPreserveSig(x)                  ((x) & miPreserveSig)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{ 
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002, 
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,
    

    pmBestFitUseAssem   = 0x0000,
    pmBestFitEnabled    = 0x0010,
    pmBestFitDisabled   = 0x0020,
    pmBestFitMask       = 0x0030,
    
    pmThrowOnUnmappableCharUseAssem   = 0x0000,
    pmThrowOnUnmappableCharEnabled    = 0x1000,
    pmThrowOnUnmappableCharDisabled   = 0x2000,
    pmThrowOnUnmappableCharMask       = 0x3000,
    
    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)

#define IsPmBestFitEnabled(x)                 (((x) & pmBestFitMask) == pmBestFitEnabled)
#define IsPmBestFitDisabled(x)                (((x) & pmBestFitMask) == pmBestFitDisabled)
#define IsPmBestFitUseAssem(x)                (((x) & pmBestFitMask) == pmBestFitUseAssem)

#define IsPmThrowOnUnmappableCharEnabled(x)   (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharEnabled)
#define IsPmThrowOnUnmappableCharDisabled(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharDisabled)
#define IsPmThrowOnUnmappableCharUseAssem(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharUseAssem)

// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afPublicKey             =   0x0001,     // The assembly ref holds the full (unhashed) public key.
    
    afCompatibilityMask     =   0x0070,
    afSideBySideCompatible  =   0x0000,     // The assembly is side by side compatible.
    afNonSideBySideAppDomain=   0x0010,     // The assembly cannot execute with other versions if
                                            // they are executing in the same application domain.
    afNonSideBySideProcess  =   0x0020,     // The assembly cannot execute with other versions if
                                            // they are executing in the same process.
    afNonSideBySideMachine  =   0x0030,     // The assembly cannot execute with other versions if
                                            // they are executing on the same machine.
    
    afRetargetable          =   0x0100,     // The assembly can be retargeted (at runtime) to an
                                            //  assembly from a different publisher.

	afEnableJITcompileTracking  =   0x8000, // From "DebuggableAttribute".
	afDisableJITcompileOptimizer=   0x4000, // From "DebuggableAttribute".
    
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfSideBySideCompatible(x)         (((x) & afCompatibilityMask) == afSideBySideCompatible)
#define IsAfNonSideBySideAppDomain(x)       (((x) & afCompatibilityMask) == afNonSideBySideAppDomain)
#define IsAfNonSideBySideProcess(x)         (((x) & afCompatibilityMask) == afNonSideBySideProcess)
#define IsAfNonSideBySideMachine(x)         (((x) & afCompatibilityMask) == afNonSideBySideMachine)

#define IsAfRetargetable(x)                 ((x) & afRetargetable)

#define IsAfEnableJITcompileTracking(x)     ((x) & afEnableJITcompileTracking)
#define IsAfDisableJITcompileOptimizer(x)   ((x) & afDisableJITcompileOptimizer)

// Macros for accessing the MemberRef members of CorAssemblyFlags.
#define IsAfPublicKey(x)                    ((x) & afPublicKey)
#define IsAfPublicKeyToken(x)               (((x) & afPublicKey) == 0)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)


// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that 
                                            // the bytes can be incremented easily  
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,  
    ELEMENT_TYPE_VOID           = 0x1,  
    ELEMENT_TYPE_BOOLEAN        = 0x2,  
    ELEMENT_TYPE_CHAR           = 0x3,  
    ELEMENT_TYPE_I1             = 0x4,  
    ELEMENT_TYPE_U1             = 0x5, 
    ELEMENT_TYPE_I2             = 0x6,  
    ELEMENT_TYPE_U2             = 0x7,  
    ELEMENT_TYPE_I4             = 0x8,  
    ELEMENT_TYPE_U4             = 0x9,  
    ELEMENT_TYPE_I8             = 0xa,  
    ELEMENT_TYPE_U8             = 0xb,  
    ELEMENT_TYPE_R4             = 0xc,  
    ELEMENT_TYPE_R8             = 0xd,  
    ELEMENT_TYPE_STRING         = 0xe,  

    // every type above PTR will be simple type 
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>   
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type> 

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token> 
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>  

    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // This is a simple type.   

    ELEMENT_TYPE_I              = 0x18,     // native integer size  
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size 
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // This is for signatures generated internally (which will not be persisted in any way).
    ELEMENT_TYPE_INTERNAL       = 0x21,     // INTERNAL <typehandle>

    // Note that this is the max of base type excluding modifiers   
    ELEMENT_TYPE_MAX            = 0x22,     // first invalid element type   


    ELEMENT_TYPE_MODIFIER       = 0x40, 
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1, 
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1, 
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,  
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,  
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,  
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,  
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8, 
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,  
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,  
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,  
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING, 
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array 
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_TAGGED_OBJECT= 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55    
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  

    IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9,
    IMAGE_CEE_CS_CALLCONV_MAX       = 0x10,  // first invalid calling convention    


        // The high bits of the calling convention convey additional info   
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits 
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter    
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
} CorCallingConvention;


typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,  
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,  
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,  
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,  

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,  
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,  
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,  
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,  

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,  
    NATIVE_TYPE_U1          = 0x4,  
    NATIVE_TYPE_I2          = 0x5,  
    NATIVE_TYPE_U2          = 0x6,  
    NATIVE_TYPE_I4          = 0x7,  
    NATIVE_TYPE_U4          = 0x8,  
    NATIVE_TYPE_I8          = 0x9,  
    NATIVE_TYPE_U8          = 0xa,  
    NATIVE_TYPE_R4          = 0xb,  
    NATIVE_TYPE_R8          = 0xc,  
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED 
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED  

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13, 
    NATIVE_TYPE_LPSTR       = 0x14, 
    NATIVE_TYPE_LPWSTR      = 0x15, 
    NATIVE_TYPE_LPTSTR      = 0x16, 
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17, 
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,
    NATIVE_TYPE_IDISPATCH   = 0x1a,
    NATIVE_TYPE_STRUCT      = 0x1b, 
    NATIVE_TYPE_INTF        = 0x1c, 
    NATIVE_TYPE_SAFEARRAY   = 0x1d, 
    NATIVE_TYPE_FIXEDARRAY  = 0x1e, 
    NATIVE_TYPE_INT         = 0x1f, 
    NATIVE_TYPE_UINT        = 0x20, 

    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)   

    NATIVE_TYPE_BYVALSTR    = 0x22,
                              
    NATIVE_TYPE_ANSIBSTR    = 0x23,

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform


    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    NATIVE_TYPE_FUNC        = 0x26,

    NATIVE_TYPE_ASANY       = 0x28,

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed 
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type   
} CorNativeType;


enum 
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs   
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls  
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.  

typedef enum CorILMethodSect                             // codes that identify attributes   
{
    CorILMethod_Sect_Reserved    = 0,   
    CorILMethod_Sect_EHTable     = 1,   
    CorILMethod_Sect_OptILTable  = 2,   

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code  
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format   
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one    
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL 
{
    BYTE Kind;  
    BYTE DataSize;  
} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT 
{
    unsigned Kind : 8;  
    unsigned DataSize : 24; 
} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)  
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter    
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause  
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE 
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree 
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;  
    DWORD               TryOffset;    
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers    
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16; 
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset; 
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;   
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;   
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{ 
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars   
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one    

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis  

        // Indicates the format for the COR_ILMETHOD header 
    CorILMethod_FormatShift     = 3,    
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1), 
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even 
    CorILMethod_SmallFormat     = 0x0000,           
    CorILMethod_FatFormat       = 0x0003,   
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;    
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags    
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack   
    DWORD   CodeSize;           // size of the code 
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  
} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;   
    IMAGE_COR_ILMETHOD_FAT        Fat;    
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo; 
    DWORD       EHInfo; 
} IMAGE_COR_NATIVE_DESCRIPTOR;


typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY 
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;  
    ULONG   MethodRVA;  
    mdToken Token;  
    BYTE    Flags;  
    BYTE    CodeManager;    
    BYTE    MIHData[0]; 
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by 
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the CLR Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.    
    USHORT      Count;                  // How many entries at location.    
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.  
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S 
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                = 0xffffffff,
    MDDupENC                = MDDupAll,
    MDNoDupChecks           = 0x00000000,
    MDDupTypeDef            = 0x00000001,
    MDDupInterfaceImpl      = 0x00000002,
    MDDupMethodDef          = 0x00000004,
    MDDupTypeRef            = 0x00000008,
    MDDupMemberRef          = 0x00000010,
    MDDupCustomAttribute    = 0x00000020,   
    MDDupParamDef           = 0x00000040,
    MDDupPermission         = 0x00000080,
    MDDupProperty           = 0x00000100,
    MDDupEvent              = 0x00000200,
    MDDupFieldDef           = 0x00000400,
    MDDupSignature          = 0x00000800,
    MDDupModuleRef          = 0x00001000,
    MDDupTypeSpec           = 0x00002000,
    MDDupImplMap            = 0x00004000,
    MDDupAssemblyRef        = 0x00008000,
    MDDupFile               = 0x00010000,
    MDDupExportedType       = 0x00020000,
    MDDupManifestResource   = 0x00040000,
    // gap for debug junk
    MDDupAssembly           = 0x10000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, and TypeSpec
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault       = 0x00000003,
    MDRefToDefAll           = 0xffffffff,
    MDRefToDefNone          = 0x00000000,
    MDTypeRefToDef          = 0x00000001,
    MDMemberRefToDef        = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault         = 0x0000000f,
    MDNotifyAll             = 0xffffffff,
    MDNotifyNone            = 0x00000000,
    MDNotifyMethodDef       = 0x00000001,
    MDNotifyMemberRef       = 0x00000002,
    MDNotifyFieldDef        = 0x00000004,
    MDNotifyTypeRef         = 0x00000008,

    MDNotifyTypeDef         = 0x00000010,
    MDNotifyParamDef        = 0x00000020,
    MDNotifyInterfaceImpl   = 0x00000040,
    MDNotifyProperty        = 0x00000080,
    MDNotifyEvent           = 0x00000100,
    MDNotifySignature       = 0x00000200,
    MDNotifyTypeSpec        = 0x00000400,
    MDNotifyCustomAttribute = 0x00000800,  
    MDNotifySecurityValue   = 0x00001000,
    MDNotifyPermission      = 0x00002000,
    MDNotifyModuleRef       = 0x00004000,
    
    MDNotifyNameSpace       = 0x00008000,

    MDNotifyAssemblyRef     = 0x01000000,
    MDNotifyFile            = 0x02000000,
    MDNotifyExportedType    = 0x04000000,
    MDNotifyResource        = 0x08000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn              = 0x00000001,   // Deprecated name.
    MDSetENCOff             = 0x00000002,   // Deprecated name.

    MDUpdateENC             = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull            = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension       = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental     = 0x00000004,   // Incremental compilation
    MDUpdateMask            = 0x00000007,

    MDUpdateDelta           = 0x00000008,   // If ENC on, save only deltas.

} CorSetENC;


// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault = 0x00000000,  // default not to generate any error
    MDErrorOutOfOrderNone   = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll    = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder      = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder       = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder       = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder    = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder       = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the custom attributes including the deleted ones
    MDImportOptionAllExportedTypes  = 0x00000040,   // all of the ExportedTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault   = 0x00000000,
    MDThreadSafetyOff       = 0x00000000,
    MDThreadSafetyOn        = 0x00000001,
} CorThreadSafetyOptions;


// flags for MetaDataLinkerOptions
typedef enum CorLinkerOptions
{
    // default behavior is not to keep private types
    MDAssembly          = 0x00000000,
    MDNetModule         = 0x00000001,
} CorLinkerOptions;


// 
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//
typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField; 
    ULONG       ulOffset;   
} COR_FIELD_OFFSET;

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;    
    ULONG Count;    
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //          
    mdtTypeRef              = 0x01000000,       //          
    mdtTypeDef              = 0x02000000,       //          
    mdtFieldDef             = 0x04000000,       //           
    mdtMethodDef            = 0x06000000,       //       
    mdtParamDef             = 0x08000000,       //           
    mdtInterfaceImpl        = 0x09000000,       //  
    mdtMemberRef            = 0x0a000000,       //       
    mdtCustomAttribute      = 0x0c000000,       //      
    mdtPermission           = 0x0e000000,       //       
    mdtSignature            = 0x11000000,       //       
    mdtEvent                = 0x14000000,       //           
    mdtProperty             = 0x17000000,       //           
    mdtModuleRef            = 0x1a000000,       //       
    mdtTypeSpec             = 0x1b000000,       //           
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtExportedType         = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //

    mdtString               = 0x70000000,       //          
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)               
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)             
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)             
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)           
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)         
#define mdParamDefNil               ((mdParamDef)mdtParamDef)           
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)     
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)         
#define mdCustomAttributeNil        ((mdCustomAttribute)mdtCustomAttribute)         
#define mdPermissionNil             ((mdPermission)mdtPermission)           
#define mdSignatureNil              ((mdSignature)mdtSignature)         
#define mdEventNil                  ((mdEvent)mdtEvent)             
#define mdPropertyNil               ((mdProperty)mdtProperty)           
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)         
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)           
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdExportedTypeNil           ((mdExportedType)mdtExportedType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)

#define mdStringNil                 ((mdString)mdtString)               

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead      =   0x00000000,     // Open scope for read
    ofWrite     =   0x00000001,     // Open scope for write.
    ofCopyMemory =  0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.
    ofCacheImage =  0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib =   0x00000080,     // Don't OpenScope on a typelib.
} CorOpenFlags;


typedef enum CorBaseType    // TokenFromRid(X,Y) replaced with (X | Y)
{
    mdtBaseType_BOOLEAN        = ( ELEMENT_TYPE_BOOLEAN | mdtBaseType ),  
    mdtBaseType_CHAR           = ( ELEMENT_TYPE_CHAR    | mdtBaseType ),
    mdtBaseType_I1             = ( ELEMENT_TYPE_I1      | mdtBaseType ), 
    mdtBaseType_U1             = ( ELEMENT_TYPE_U1      | mdtBaseType ),
    mdtBaseType_I2             = ( ELEMENT_TYPE_I2      | mdtBaseType ),  
    mdtBaseType_U2             = ( ELEMENT_TYPE_U2      | mdtBaseType ),  
    mdtBaseType_I4             = ( ELEMENT_TYPE_I4      | mdtBaseType ),  
    mdtBaseType_U4             = ( ELEMENT_TYPE_U4      | mdtBaseType ),  
    mdtBaseType_I8             = ( ELEMENT_TYPE_I8      | mdtBaseType ),  
    mdtBaseType_U8             = ( ELEMENT_TYPE_U8      | mdtBaseType ),  
    mdtBaseType_R4             = ( ELEMENT_TYPE_R4      | mdtBaseType ),  
    mdtBaseType_R8             = ( ELEMENT_TYPE_R8      | mdtBaseType ),  
    mdtBaseType_STRING         = ( ELEMENT_TYPE_STRING  | mdtBaseType ),
    mdtBaseType_I              = ( ELEMENT_TYPE_I       | mdtBaseType ),    
    mdtBaseType_U              = ( ELEMENT_TYPE_U       | mdtBaseType ),    
} CorBaseType;


typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor | 
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,
    
} CorAttributeTargets;

#ifndef MACROS_NOT_SUPPORTED
//
// Some well-known custom attributes 
//
#ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
#endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_CLASSINTERFACE_TYPE_W           L"System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_TYPE             "System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_BESTFITMAPPING_TYPE_W           L"System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_TYPE             "System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_LCIDCONVERSION_TYPE_W           L"System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_TYPE             "System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE_W    L"System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE      "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_DECIMALVALUE_TYPE_W    			L"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_TYPE      			"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_SIG       			{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 5, ELEMENT_TYPE_VOID, ELEMENT_TYPE_U1, ELEMENT_TYPE_U1, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4}

#define INTEROP_DATETIMEVALUE_TYPE_W    		L"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_TYPE      		"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I8}

#define INTEROP_IUNKNOWNVALUE_TYPE_W    		L"System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_TYPE      		 "System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHVALUE_TYPE_W    		L"System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_TYPE      		 "System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_AUTOPROXY_TYPE_W                L"System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_TYPE                  "System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_TYPELIBVERSION_TYPE_W           L"System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_TYPE             "System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMCOMPATIBLEVERSION_TYPE_W     L"System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_TYPE       "System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_SIG        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 4, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMEVENTINTERFACE_TYPE_W        L"System.Runtime.InteropServices.ComEventInterfaceAttribute"
#define INTEROP_COMEVENTINTERFACE_TYPE          "System.Runtime.InteropServices.ComEventInterfaceAttribute"

#define INTEROP_COCLASS_TYPE_W                  L"System.Runtime.InteropServices.CoClassAttribute"
#define INTEROP_COCLASS_TYPE                    "System.Runtime.InteropServices.CoClassAttribute"

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"                                
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"                                 
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"                                
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"                                 
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}

#define CMOD_CALLCONV_NAMESPACE_OLD             "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.CompilerServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))   
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))    
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))   
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged)) 
#define COR_IS_METHOD_IAT(flags)                (flags & miIAT) 


//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomAttribute;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomAttribute;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corerror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*********************************************************************
 **                                                                 **
 ** CorError.h - lists the HResults used by the .NET Framework's    **
 **              Common Language Runtime.                           **
 ** Created: September 3, 1999.                                     **
 **                                                                 **
 *********************************************************************/


#ifndef __COMMON_LANGUAGE_RUNTIME_HRESULTS__
#define __COMMON_LANGUAGE_RUNTIME_HRESULTS__

/*********************************************************************

These HRESULTs are used for mapping managed exceptions to COM error codes
and vice versa through COM Interop.  For background on COM error codes see 
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/error_9td2.asp.
 
FACILITY_URT is defined as 0x13 (0x8013xxxx). The facility range is reserved 
for the .NET Framework SDK teams.
 
Within that range, the following subranges have been allocated for different 
feature areas:
 
0x10yy for Execution Engine
0x11yy for Metadata, TypeLib Export, and CLDB
0x12yy for MetaData Validator
0x13yy for Debugger and Profiler errors
0x14yy for Security 
0x15yy for BCL
0x1600 - 0x161F for Reflection
0x1620 - 0x163F for System.IO
0x1640 - 0x165F for Security
0x1660 - 0x16FF for BCL
0x17yy for shim 
0x18yy for IL Verifier
0x19yy for .NET Framework
0x1Ayy for .NET Framework
0x1Byy for MetaData Validator
0x30yy for VSA errors

Base class library HRESULTs are copied from this file into many different 
files named __HResults.cs under the BCL directory.  Frameworks HRESULTs are 
defined in src/main/HResults.cs. If you make any modifications to 
the range allocations described above, please make sure the corerror.h file 
gets updated.

*********************************************************************/

#include <winerror.h>

#ifndef FACILITY_URT
#define FACILITY_URT            0x13
#endif

#ifndef EMAKEHR
#define SMAKEHR(val)            MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_URT, val)
#define EMAKEHR(val)            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_URT, val)
#endif


// ******************
// FACILITY_UTF
// ******************


// ******************
// Metadata errors
// ******************

//**** ICeeFileGen errors.
#define CEE_E_ENTRYPOINT                EMAKEHR(0x1000)     // The entry point info is invalid.
#define CEE_E_CVTRES_NOT_FOUND          EMAKEHR(0x1001)     // cannot find cvtres.exe

//**** EE errors
#define MSEE_E_LOADLIBFAILED            EMAKEHR(0x1010)     // Failed to delay load library %s (Win32 error: %d).
#define MSEE_E_GETPROCFAILED            EMAKEHR(0x1011)     // Failed to get entry point %s (Win32 error: %d).
#define MSEE_E_MULTCOPIESLOADED         EMAKEHR(0x1012)     // Multiple copies of MSCOREE.dll have been loaded by the same process.
// the following two are COR to match the name used in the library
#define COR_E_APPDOMAINUNLOADED         EMAKEHR(0x1014)     // access unloaded appdomain
#define COR_E_CANNOTUNLOADAPPDOMAIN     EMAKEHR(0x1015)     // Error while unloading an appdomain
#define MSEE_E_ASSEMBLYLOADINPROGRESS   EMAKEHR(0x1016)     // Assembly is being currently being loaded
#define MSEE_E_CANNOTCREATEAPPDOMAIN    EMAKEHR(0x1017)     // Attempt to create appdomain failed
#define COR_E_FIXUPSINEXE                                       EMAKEHR(0x1019)         // Attempt to load an unverifiable exe with fixups (IAT with more than 2 sections or a TLS section)

//**** Assembly Cache errors
#define COR_E_MODULE_HASH_CHECK_FAILED EMAKEHR(0x1039)      // The check of the module's hash failed.
#define FUSION_E_REF_DEF_MISMATCH       EMAKEHR(0x1040)     // The located assembly's manifest definition does not match the assembly reference.
#define FUSION_E_INVALID_PRIVATE_ASM_LOCATION EMAKEHR(0x1041) // The private assembly was located outside the appbase directory.
#define FUSION_E_ASM_MODULE_MISSING     EMAKEHR(0x1042)     // A module specified in the manifest was not found.
#define FUSION_E_UNEXPECTED_MODULE_FOUND EMAKEHR(0x1043)    // Modules which are not in the manifest were streamed in.
#define FUSION_E_PRIVATE_ASM_DISALLOWED EMAKEHR(0x1044)     // A strongly-named assembly is required.
#define FUSION_E_SIGNATURE_CHECK_FAILED EMAKEHR(0x1045)     // The check of the signature failed.
#define FUSION_E_DATABASE_ERROR         EMAKEHR(0x1046)     // An unexpected error was encountered in the Assembly Cache database.
#define FUSION_E_INVALID_NAME           EMAKEHR(0x1047)     // The given assembly name or codebase was invalid.
#define FUSION_E_CODE_DOWNLOAD_DISABLED EMAKEHR(0x1048)     // HTTP download of assemblies has been disabled for this appdomain.
#define FUSION_E_UNINSTALL_DISALLOWED   EMAKEHR(0x1049)     // Uninstall of given assembly is not allowed



//=============================================================================
// THE VALIDATOR IS CURRENTLY USING ERROR CODES STARTING WITH 0x1050 ONWARDS.
// LOOK AT ERROR CODES STARTING FROM VLDTR_E_AS_NAMENULL.  JUST A NOTE IN CASE
// THE EE EVER COMES TO THE POINT OF NEEDING THOSE!!!
//=============================================================================

//**** Generic errors.
#define CLDB_E_FILE_BADREAD             EMAKEHR(0x1100)     // Error occured during a read.
#define CLDB_E_FILE_BADWRITE            EMAKEHR(0x1101)     // Error occured during a write.
#define CLDB_E_FILE_READONLY            EMAKEHR(0x1103)     // File is read only.
#define CLDB_E_NAME_ERROR               EMAKEHR(0x1105)     // An ill-formed name was given.
#define CLDB_S_TRUNCATION               SMAKEHR(0x1106)     // STATUS: Data value was truncated.
#define CLDB_E_TRUNCATION               EMAKEHR(0x1106)     // ERROR:  Data value was truncated.
#define CLDB_E_FILE_OLDVER              EMAKEHR(0x1107)     // Old version error.
#define CLDB_E_RELOCATED                EMAKEHR(0x1108)     // A shared mem open failed to open at the originally
                                                    //  assigned memory address.
#define CLDB_S_NULL                     SMAKEHR(0x1109)     // NULL data value.
#define CLDB_E_SMDUPLICATE              EMAKEHR(0x110A)     // Create of shared memory failed.  A memory mapping of the same name already exists.
#define CLDB_E_NO_DATA                  EMAKEHR(0x110B)     // There isn't .CLB data in the memory or stream.
#define CLDB_E_READONLY                 EMAKEHR(0x110C)     // Database is read only.
#define CLDB_E_INCOMPATIBLE             EMAKEHR(0x110D)     // The importing scope is not comptabile with the emitting scope

//**** Schema errors.
#define CLDB_E_FILE_CORRUPT             EMAKEHR(0x110E)     // File is corrupt.
#define CLDB_E_SCHEMA_VERNOTFOUND       EMAKEHR(0x110F)   // Version %d of schema '%s' not found.
#define CLDB_E_BADUPDATEMODE            EMAKEHR(0x1110)     // cannot open a incrementally build scope for full update

//**** Index errors.
#define CLDB_E_INDEX_NONULLKEYS         EMAKEHR(0x1121)     // Null value not allowed in unique index or primary key.
#define CLDB_E_INDEX_DUPLICATE          EMAKEHR(0x1122)     // Unique index %s has been violated.
#define CLDB_E_INDEX_BADTYPE            EMAKEHR(0x1123)     // The columns data type is not allowed in an index.
#define CLDB_E_INDEX_NOTFOUND           EMAKEHR(0x1124)     // Index %s not found.
#define CLDB_S_INDEX_TABLESCANREQUIRED  SMAKEHR(0x1125) // Table scan required to run query.

//**** Record errors.
#define CLDB_E_RECORD_NOTFOUND          EMAKEHR(0x1130)     // Record wasn't found on lookup.
#define CLDB_E_RECORD_OVERFLOW          EMAKEHR(0x1131)     // Too many records were returned for criteria.
#define CLDB_E_RECORD_DUPLICATE         EMAKEHR(0x1132)     // Record is a duplicate.
#define CLDB_E_RECORD_PKREQUIRED        EMAKEHR(0x1133)    // Primary key value is required.
#define CLDB_E_RECORD_DELETED           EMAKEHR(0x1134)     // Record is valid but deleted.
#define CLDB_E_RECORD_OUTOFORDER        EMAKEHR(0x1135)    // Record is emitted out of order.

//**** Column errors.
#define CLDB_E_COLUMN_OVERFLOW          EMAKEHR(0x1140)     // Data too large.
#define CLDB_E_COLUMN_READONLY          EMAKEHR(0x1141)     // Column cannot be changed.
#define CLDB_E_COLUMN_SPECIALCOL        EMAKEHR(0x1142)    // Too many RID or primary key columns, 1 is max.
#define CLDB_E_COLUMN_PKNONULLS         EMAKEHR(0x1143)     // Primary key column %s may not allow the null value.

//**** Table errors.
#define CLDB_E_TABLE_CANTDROP           EMAKEHR(0x1150)     // Can't auto-drop table while open.

//**** Object errors.
#define CLDB_E_OBJECT_NOTFOUND          EMAKEHR(0x1151)     // Object was not found in the database.
#define CLDB_E_OBJECT_COLNOTFOUND       EMAKEHR(0x1152)   // The column was not found.

//**** Vector errors.
#define CLDB_E_VECTOR_BADINDEX          EMAKEHR(0x1153)     // The index given was invalid.

//**** Heap errors;
#define CLDB_E_TOO_BIG                  EMAKEHR(0x1154)     // A blob or string was too big.

//**** IMeta* errors.

#define META_E_DUPLICATE                EMAKEHR(0x1180)     // Attempt to define an object that already exists.
#define META_E_GUID_REQUIRED            EMAKEHR(0x1181)     // A guid was not provided where one was required.
#define META_E_TYPEDEF_MISMATCH         EMAKEHR(0x1182)     // Merge: an import typedef matched ns.name, but not version and guid.
#define META_E_MERGE_COLLISION          EMAKEHR(0x1183)     // Merge: conflict between import and emit

#define META_E_METHD_NOT_FOUND          EMAKEHR(0x1187) // Merge: Class already in emit scope, but member not found
#define META_E_FIELD_NOT_FOUND          EMAKEHR(0x1188) // Merge: Class already in emit scope, but member not found
#define META_S_PARAM_MISMATCH           SMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_PARAM_MISMATCH           EMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_BADMETADATA              EMAKEHR(0x118A) // Merge: Inconsistency in meta data import scope
#define META_E_INTFCEIMPL_NOT_FOUND     EMAKEHR(0x118B) // Merge: Class already in emit scope, but interfaceimpl not found
#define META_E_CLASS_LAYOUT_INCONSISTENT EMAKEHR(0x118D) // Merge: Class is duplicated but class layout information is not consistent
#define META_E_FIELD_MARSHAL_NOT_FOUND  EMAKEHR(0x118E) // Merge: Field is duplicated but we cannot find the matching FieldMarshal information
#define META_E_METHODSEM_NOT_FOUND      EMAKEHR(0x118F) // Merge: 
#define META_E_EVENT_NOT_FOUND          EMAKEHR(0x1190) // Merge: Method is duplicated but we cannot find the matching event info.
#define META_E_PROP_NOT_FOUND           EMAKEHR(0x1191) // Merge: Method is duplicated but we cannot find the maching property info.
#define META_E_BAD_SIGNATURE            EMAKEHR(0x1192) // Bad binary signature
#define META_E_BAD_INPUT_PARAMETER      EMAKEHR(0x1193) // Bad input parameters
#define META_E_METHDIMPL_INCONSISTENT   EMAKEHR(0x1194) // Merge: duplicated methods have inconsistent ImplFlags
#define META_E_MD_INCONSISTENCY         EMAKEHR(0x1195) // Merge: Inconsistency in meta data

#define META_E_CANNOTRESOLVETYPEREF     EMAKEHR(0x1196) // Cannot resolve typeref
#define META_S_DUPLICATE                SMAKEHR(0x1197) // Attempt to define an object that already exists in valid scenerios.
#define META_E_STRINGSPACE_FULL         EMAKEHR(0x1198) // No logical space left to create more user strings.

#define META_E_UNEXPECTED_REMAP         EMAKEHR(0x1199) // A TokenRemap occurred which we weren't prepared to handle.

#define META_E_HAS_UNMARKALL            EMAKEHR(0x119A) // Unmark all has been called already
#define META_E_MUST_CALL_UNMARKALL      EMAKEHR(0x119B) // Must call UnmarkAll first before marking.

#define TLBX_E_CANT_LOAD_MODULE         EMAKEHR(0x11A0) // TypeLib export: can't open the module to export.
#define TLBX_E_CANT_LOAD_CLASS          EMAKEHR(0x11A1) // TypeLib export: can't load a class.  
#define TLBX_E_NULL_MODULE              EMAKEHR(0x11A2) // TypeLib export: the hMod of a loaded class is 0; can't export it.
#define TLBX_E_NO_CLSID_KEY             EMAKEHR(0x11A3) // TypeLib export: no CLSID or Interface subkey to HKCR.
#define TLBX_E_CIRCULAR_EXPORT          EMAKEHR(0x11A4) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_IMPORT          EMAKEHR(0x11A5) // TypeLib import: attempt to import a TLB exported from a CLB.
#define TLBX_E_BAD_NATIVETYPE           EMAKEHR(0x11A6) // TypeLib export: bad Native type in method signature.
#define TLBX_E_BAD_VTABLE               EMAKEHR(0x11A7) // TypeLib import: non-increasing vtable (duplicate slots).
#define TLBX_E_CRM_NON_STATIC           EMAKEHR(0x11A8) // TypeLib export: the COM register method is non static.
#define TLBX_E_CRM_INVALID_SIG          EMAKEHR(0x11A9) // TypeLib export: the specified COM register method does not have the correct signature.
#define TLBX_E_CLASS_LOAD_EXCEPTION     EMAKEHR(0x11AA) // TypeLib export: can't load, have the class load exception.
#define TLBX_E_UNKNOWN_SIGNATURE        EMAKEHR(0x11AB) // TypeLib export: unknown element in signature.
#define TLBX_E_REFERENCED_TYPELIB       EMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_S_REFERENCED_TYPELIB       SMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_E_INVALID_NAMESPACE        EMAKEHR(0x11AD) // TypeLib import: an imported typelib has an invalid namespace name.
#define TLBX_E_LAYOUT_ERROR             EMAKEHR(0x11AE) // Typelib export: an error on Layout()
#define TLBX_E_NOTIUNKNOWN              EMAKEHR(0x11AF) // Typelib import: Interface not derived from IUnknown.
#define TLBX_E_NONVISIBLEVALUECLASS     EMAKEHR(0x11B0) // Typelib export: Non COM visible value type in method signature.
#define TLBX_E_LPTSTR_NOT_ALLOWED       EMAKEHR(0x11B1) // Typelib export: Types which contain the native type NATIVE_TYPE_LPTSTR are not allowed to be exported to COM.
#define TLBX_E_AUTO_CS_NOT_ALLOWED      EMAKEHR(0x11B2) // Typelib export: Types with a char set of auto are not allowed to be exported to COM.
#define TLBX_S_NOSTDINTERFACE           SMAKEHR(0x11B3) // Typelib export: Found an interface marked as IID_IDispatch or IID_IUnknown.
#define TLBX_S_DUPLICATE_DISPID         SMAKEHR(0x11B4) // Typelib export: duplicate dispid found; ignored.
#define TLBX_E_ENUM_VALUE_INVALID       EMAKEHR(0x11B5) // Typelib export: The enum value is not legal for a typelib.
#define TLBX_E_DUPLICATE_IID            EMAKEHR(0x11B6) // Typelib export: Duplicate IID
#define TLBX_E_NO_NESTED_ARRAYS         EMAKEHR(0x11B7) // Tyeplib export: detected nested arrays.
#define TLBX_E_PARAM_ERROR_NAMED        EMAKEHR(0x11B8) // Typelib import: param type couldn't be converted.
#define TLBX_E_PARAM_ERROR_UNNAMED      EMAKEHR(0x11B9) // Typelib import: param type couldn't be converted -- param name unknown.
#define TLBX_E_AGNOST_SIGNATURE         EMAKEHR(0x11BA) // TypeLib export: size agnostic element in signature.
#define TLBX_E_CONVERT_FAIL             EMAKEHR(0x11BB) // TypeLib export: exporter failed.
#define TLBX_W_DUAL_NOT_DISPATCH        EMAKEHR(0x11BC) // Typelib import: [dual] interface not derived from IDispatch.
#define TLBX_E_BAD_SIGNATURE            EMAKEHR(0x11BD) // Typelib export: unconvertable signature (use specific error for reporting!)
#define TLBX_E_ARRAY_NEEDS_NT_FIXED     EMAKEHR(0x11BE) // Typelib export: non-fixed/non-safearray array in struct
#define TLBX_E_CLASS_NEEDS_NT_INTF      EMAKEHR(0x11BF) // Typelib export: non-interface class in struct

#define TLBX_E_INVALID_TYPEINFO         EMAKEHR(0x1160) // Typelib import: invalid type, not converted.
#define TLBX_E_INVALID_TYPEINFO_UNNAMED EMAKEHR(0x1161) // Typelib import: invalid type, not converted -- name unknown.
#define TLBX_E_CTX_NESTED               EMAKEHR(0x1162) // Typelib export: Format string for nested contexts.
#define TLBX_E_ERROR_MESSAGE            EMAKEHR(0x1163) // Typelib export: Error message wrapper.
#define TLBX_E_CANT_SAVE                EMAKEHR(0x1164) // Typelib export: cant "SaveAllChanges()"
#define TLBX_W_LIBNOTREGISTERED         EMAKEHR(0x1165) // Typelib export: type library is not registered.
#define TLBX_E_CANTLOADLIBRARY          EMAKEHR(0x1166) // Typelib export: type library cannot be loaded.
#define TLBX_E_BAD_VT_TYPE              EMAKEHR(0x1167) // Typelib import: invalid VT_*, not converted.
#define TLBX_E_NO_MSCOREE_TLB           EMAKEHR(0x1168) // Typelib export: can't load mscoree.tlb
#define TLBX_E_BAD_MSCOREE_TLB          EMAKEHR(0x1169) // Typelib export: can't get a required typeinfo from mscoree.tlb.
#define TLBX_E_TLB_EXCEPTION            EMAKEHR(0x116a) // Typelib import: fault reading a typelib.
#define TLBX_E_MULTIPLE_LCIDS           EMAKEHR(0x116b) // Typelib import: Multiple LCID's parameters on a method.
#define TLBX_I_TYPEINFO_IMPORTED        SMAKEHR(0x116c) // Typelib import: progress report.
#define TLBX_E_AMBIGUOUS_RETURN         EMAKEHR(0x116d) // Typelib import: duplicate or ambiguous return types.
#define TLBX_E_DUPLICATE_TYPE_NAME      EMAKEHR(0x116e) // Typelib import: duplicate name (due to user-defined name).
#define TLBX_I_USEIUNKNOWN              SMAKEHR(0x116f) // Typelib export: substituted IUnknown for type.
#define TLBX_I_UNCONVERTABLE_ARGS       SMAKEHR(0x1170) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_UNCONVERTABLE_FIELD      SMAKEHR(0x1171) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_NONSEQUENTIALSTRUCT      EMAKEHR(0x1172) // Typelib export: Can't convert non-sequential structs.
#define TLBX_W_WARNING_MESSAGE          SMAKEHR(0x1173) // Typelib export: Warning message wrapper. 
#define TLBX_I_RESOLVEREFFAILED         EMAKEHR(0x1174) // Typelib import: The resolve ref call failed.
#define TLBX_E_ASANY                    EMAKEHR(0x1175) // Typelib export: Encounterd "AsAny" -- ignored.
#define TLBX_E_INVALIDLCIDPARAM         EMAKEHR(0x1176) // Typelib export: Encounterd an LCID attribute set to an invalid param.
#define TLBX_E_LCIDONDISPONLYITF        EMAKEHR(0x1177) // Typelib export: Encounterd an LCID attribute on a disp only interface.
#define TLBX_E_NONPUBLIC_FIELD          EMAKEHR(0x1178) // Typelib export: Non-public field in public struct.
#define TLBX_I_TYPE_EXPORTED            SMAKEHR(0x1179) // Typelib export: type exported
#define TLBX_I_DUPLICATE_DISPID         SMAKEHR(0x117A) // Typelib export: duplicate dispid -- auto corrected.
#define TLBX_E_BAD_NAMES                EMAKEHR(0x117B) // Typelib export: bad names list.
#define TLBX_I_REF_TYPE_AS_STRUCT       SMAKEHR(0x117C) // Typelib export: referenct tyep had layout, exported as struct.
#define TLBX_W_NON_INTEGRAL_CA_TYPE     SMAKEHR(0x1184) // TypeLib import: Ignoring IDL custom attribute -- does not have an integral value.
#define TLBX_W_IENUM_CA_ON_IUNK         SMAKEHR(0x1185) // TypeLib import: Ignoring IDL custom attribute -- using IEnum CA on an IUnknown derived interface.
                    
                    
#define META_E_CA_INVALID_TARGET        EMAKEHR(0x11C0) // Known custom attribute on invalid target.
#define META_E_CA_INVALID_VALUE         EMAKEHR(0x11C1) // Known custom attribute had invalid value.
#define META_E_CA_INVALID_BLOB          EMAKEHR(0x11C2) // Known custom attribute blob is bad format.
#define META_E_CA_REPEATED_ARG          EMAKEHR(0x11C3) // Known custom attribute blob has repeated named argument.
#define META_E_CA_UNKNOWN_ARGUMENT      EMAKEHR(0x11C4) // Known custom attrubte named arg not recognized.
#define META_E_CA_VARIANT_NYI           EMAKEHR(0x11C5) // Known attribute named argument doesn't support variant.
#define META_E_CA_ARRAY_NYI             EMAKEHR(0x11C6) // Known attribute named argument doesn't support array.
#define META_E_CA_UNEXPECTED_TYPE       EMAKEHR(0x11C7) // Known attribute parser found unexpected type.
#define META_E_CA_INVALID_ARGTYPE       EMAKEHR(0x11C8) // Known attribute parser only handles fields -- no properties.
#define META_E_CA_INVALID_ARG_FOR_TYPE  EMAKEHR(0x11C9) // Known attribute parser found an argument that is invalid for the object it is applied to.
#define META_E_CA_INVALID_UUID          EMAKEHR(0x11CA) // The format of the UUID was invalid.
#define META_E_CA_INVALID_MARSHALAS_FIELDS EMAKEHR(0x11CB) // The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.
#define META_E_CA_NT_FIELDONLY          EMAKEHR(0x11CC) // The specified unmanaged type is only valid on fields.
#define META_E_CA_NEGATIVE_PARAMINDEX   EMAKEHR(0x11CD) // The parameter index cannot be negative.
#define META_E_CA_NEGATIVE_MULTIPLIER   EMAKEHR(0x11CE) // The multiplier cannot be negative.
#define META_E_CA_NEGATIVE_CONSTSIZE    EMAKEHR(0x11CF) // The constant size cannot be negative.
#define META_E_CA_FIXEDSTR_SIZE_REQUIRED EMAKEHR(0x11D0) // A fixed string requires a size.
#define META_E_CA_CUSTMARSH_TYPE_REQUIRED EMAKEHR(0x11D1) // A custom marshaler requires the custom marshaler type.
#define META_E_CA_FILENAME_REQUIRED     EMAKEHR(0x11d2) // A DllImport attribute requires a filename.

// Return values from validator functions.
#define VLDTR_S_WRN                     SMAKEHR(0x1200) // Warnings found in the validator.
#define VLDTR_S_ERR                     SMAKEHR(0x1201) // Errors found in the validator.
#define VLDTR_S_WRNERR                  SMAKEHR(0x1202) // Warnings and errors found in the validator.

// Validator structural errors.                 
#define VLDTR_E_RID_OUTOFRANGE          EMAKEHR(0x1203) // Rid is out of range.
#define VLDTR_E_CDTKN_OUTOFRANGE        EMAKEHR(0x1204) // Coded token type is out of range.
#define VLDTR_E_CDRID_OUTOFRANGE        EMAKEHR(0x1205) // Coded rid is out of range.
#define VLDTR_E_STRING_INVALID          EMAKEHR(0x1206) // String offset is invalid.
#define VLDTR_E_GUID_INVALID            EMAKEHR(0x1207) // GUID offset is invalid.
#define VLDTR_E_BLOB_INVALID            EMAKEHR(0x1208) // Blob offset if invalid.

// Validator semantic errors.                   
#define VLDTR_E_MOD_MULTI               EMAKEHR(0x1209) // Multiple module records found.
#define VLDTR_E_MOD_NULLMVID            EMAKEHR(0x120A) // Module has null MVID.
#define VLDTR_E_TR_NAMENULL             EMAKEHR(0x120B) // TypeRef name is NULL.
#define VLDTR_E_TR_DUP                  EMAKEHR(0x120C) // TypeRef has a dup.
#define VLDTR_E_TD_NAMENULL             EMAKEHR(0x120D) // TypeDef name is NULL.
#define VLDTR_E_TD_DUPNAME              EMAKEHR(0x120E) // TypeDef has a dup based on name+namespace.
#define VLDTR_E_TD_DUPGUID              EMAKEHR(0x120F) // TypeDef has a dup based on GUID.
#define VLDTR_E_TD_NOTIFACEOBJEXTNULL   EMAKEHR(0x1210) // TypeDef that's not an Interface and not System.Object extends nil parent.
#define VLDTR_E_TD_OBJEXTENDSNONNULL    EMAKEHR(0x1211) // System.Object extends a non-nil parent.
#define VLDTR_E_TD_EXTENDSSEALED        EMAKEHR(0x1212) // TypeDef extends sealed class.
#define VLDTR_E_TD_DLTNORTSPCL          EMAKEHR(0x1213) // TypeDef is Deleted but not marked with RTSpecialName.
#define VLDTR_E_TD_RTSPCLNOTDLT         EMAKEHR(0x1214) // TypeDef is marked RTSpecialName, but is not a Deleted record.
#define VLDTR_E_MI_DECLPRIV             EMAKEHR(0x1215) // MethodImpl's Decl is private
#define VLDTR_E_AS_BADNAME              EMAKEHR(0x1216) // Assembly [Ref] name has path and/or extension.
#define VLDTR_E_FILE_SYSNAME            EMAKEHR(0x1217) // File has a system name (con, com, aux, etc.).
#define VLDTR_E_MI_BODYSTATIC           EMAKEHR(0x1218) // MethodImpl's body is static.
#define VLDTR_E_TD_IFACENOTABS          EMAKEHR(0x1219) // TypeDef is marked Interface but not Abstract.
#define VLDTR_E_TD_IFACEPARNOTNIL       EMAKEHR(0x121A) // TypeDef is marked Interface but parent is not Nil.
#define VLDTR_E_TD_IFACEGUIDNULL        EMAKEHR(0x121B) // TypeDef is marked Interface but GUID is NULL.
#define VLDTR_E_MI_DECLFINAL            EMAKEHR(0x121C) // TMethodImpl's Decl is final.
#define VLDTR_E_TD_VTNOTSEAL            EMAKEHR(0x121D) // TypeDef is marked ValueType but not marked Sealed.
#define VLDTR_E_PD_BADFLAGS             EMAKEHR(0x121E) // Param has extra bits in flags.
#define VLDTR_E_IFACE_DUP               EMAKEHR(0x121F) // InterfaceImpl has a dup.
#define VLDTR_E_MR_NAMENULL             EMAKEHR(0x1220) // MemberRef name is NULL.
#define VLDTR_E_MR_VTBLNAME             EMAKEHR(0x1221) // MemberRef has an invalid name, _VtblGap*.
#define VLDTR_E_MR_DELNAME              EMAKEHR(0x1222) // MemberRef has an invalid name, _Deleted*.
#define VLDTR_E_MR_PARNIL               EMAKEHR(0x1223) // MemberRef parent Nil in a PE file.
#define VLDTR_E_MR_BADCALLINGCONV       EMAKEHR(0x1224) // MemberRef has invalid calling convention.
#define VLDTR_E_MR_NOTVARARG            EMAKEHR(0x1225) // MemberRef has Method parent but calling convention is not VARARG.
#define VLDTR_E_MR_NAMEDIFF             EMAKEHR(0x1226) // MemberRef name different from parent MethodDef.
#define VLDTR_E_MR_SIGDIFF              EMAKEHR(0x1227) // MemberRef signature different from parent MethodDef.
#define VLDTR_E_MR_DUP                  EMAKEHR(0x1228) // MemberRef has a dup.
#define VLDTR_E_CL_TDAUTO               EMAKEHR(0x1229) // ClassLayout parent TypeDef is marked AutoLayout.
#define VLDTR_E_CL_BADPCKSZ             EMAKEHR(0x122A) // ClassLayout has bad PackingSize.
#define VLDTR_E_CL_DUP                  EMAKEHR(0x122B) // ClassLayout has dup.
#define VLDTR_E_FL_BADOFFSET            EMAKEHR(0x122C) // FieldLayout2 has bad offset.
#define VLDTR_E_FL_TDNIL                EMAKEHR(0x122D) // FieldLayout2 has field with nil parent.
#define VLDTR_E_FL_NOCL                 EMAKEHR(0x122E) // FieldLayout2 has no ClassLayout record.
#define VLDTR_E_FL_TDNOTEXPLCT          EMAKEHR(0x122F) // FieldLayout2 parent TypeDef is not marked with ExplicitLayout.
#define VLDTR_E_FL_FLDSTATIC            EMAKEHR(0x1230) // FieldLayout2 has field marked Static.
#define VLDTR_E_FL_DUP                  EMAKEHR(0x1231) // FieldLayout2 has a dup.
#define VLDTR_E_MODREF_NAMENULL         EMAKEHR(0x1232) // ModuleRef name is NULL.
#define VLDTR_E_MODREF_DUP              EMAKEHR(0x1233) // ModuleRef has a dup.
#define VLDTR_E_TR_BADSCOPE             EMAKEHR(0x1234) // TypeRef has a bad resolution scope.
#define VLDTR_E_TD_NESTEDNOENCL         EMAKEHR(0x1235) // TypeDef marked nested has no encloser.
#define VLDTR_E_TD_EXTTRRES             EMAKEHR(0x1236) // TypeDef extends a TypeRef which resolves to a TypeDef in the same module.
#define VLDTR_E_SIGNULL                 EMAKEHR(0x1237) // Signature specified is zero-sized.
#define VLDTR_E_SIGNODATA               EMAKEHR(0x1238) // Signature does not have enough data at specified byte.
#define VLDTR_E_MD_BADCALLINGCONV       EMAKEHR(0x1239) // Method signature has invalid calling convention.
#define VLDTR_E_MD_THISSTATIC           EMAKEHR(0x123A) // Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.
#define VLDTR_E_MD_NOTTHISNOTSTATIC     EMAKEHR(0x123B) // Method is not marked static but is not HASTHIS/EXPLICITTHIS.
#define VLDTR_E_MD_NOARGCNT             EMAKEHR(0x123C) // Method signature is missing the argument count.
#define VLDTR_E_SIG_MISSELTYPE          EMAKEHR(0x123D) // Signature missing element type.
#define VLDTR_E_SIG_MISSTKN             EMAKEHR(0x123E) // Signature missing token.
#define VLDTR_E_SIG_TKNBAD              EMAKEHR(0x123F) // Signature has bad token.
#define VLDTR_E_SIG_MISSFPTR            EMAKEHR(0x1240) // Signature is missing function pointer.
#define VLDTR_E_SIG_MISSFPTRARGCNT      EMAKEHR(0x1241) // Signature has function pointer missing argument count.
#define VLDTR_E_SIG_MISSRANK            EMAKEHR(0x1242) // Signature is missing rank specification.
#define VLDTR_E_SIG_MISSNSIZE           EMAKEHR(0x1243) // Signature is missing count of sized dimensions.
#define VLDTR_E_SIG_MISSSIZE            EMAKEHR(0x1244) // Signature is missing size of dimension.
#define VLDTR_E_SIG_MISSNLBND           EMAKEHR(0x1245) // Signature is missing count of lower bounds.
#define VLDTR_E_SIG_MISSLBND            EMAKEHR(0x1246) // Signature is missing a lower bound.
#define VLDTR_E_SIG_BADELTYPE           EMAKEHR(0x1247) // Signature has bad element type.
#define VLDTR_E_SIG_MISSVASIZE          EMAKEHR(0x1248) // Signature has value array missing size.
#define VLDTR_E_FD_BADCALLINGCONV       EMAKEHR(0x1249) // Field signature has invalid calling convention.
#define VLDTR_E_MD_NAMENULL             EMAKEHR(0x124A) // Method name is NULL.
#define VLDTR_E_MD_PARNIL               EMAKEHR(0x124B) // Method has parent NIL.
#define VLDTR_E_MD_DUP                  EMAKEHR(0x124C) // Method has dup.
#define VLDTR_E_FD_NAMENULL             EMAKEHR(0x124D) // Field name is NULL.
#define VLDTR_E_FD_PARNIL               EMAKEHR(0x124E) // Field parent is Nil.
#define VLDTR_E_FD_DUP                  EMAKEHR(0x124F) // Field has dup.
#define VLDTR_E_AS_MULTI                EMAKEHR(0x1250) // Multiple Assembly records found.
#define VLDTR_E_AS_NAMENULL             EMAKEHR(0x1251) // Assembly name is NULL.
#define VLDTR_E_SIG_TOKTYPEMISMATCH     EMAKEHR(0x1252) // E_T_VALUETYPE<class token> or E_T_CLASS<vtype token>.
#define VLDTR_E_CL_TDINTF               EMAKEHR(0x1253) // Class layout on an Interface.
#define VLDTR_E_ASOS_OSPLTFRMIDINVAL    EMAKEHR(0x1254) // AssemblyOS platform ID invalid.
#define VLDTR_E_AR_NAMENULL             EMAKEHR(0x1255) // AssemblyRef name is NULL.
#define VLDTR_E_TD_ENCLNOTNESTED        EMAKEHR(0x1256) // TypeDef not nested has encloser.
#define VLDTR_E_AROS_OSPLTFRMIDINVAL    EMAKEHR(0x1257) // AssemblyRefOS has invalid platform ID.
#define VLDTR_E_FILE_NAMENULL           EMAKEHR(0x1258) // File name is NULL.
#define VLDTR_E_CT_NAMENULL             EMAKEHR(0x1259) // ComType name is NULL.
#define VLDTR_E_TD_EXTENDSCHILD         EMAKEHR(0x125A) // TypeDef extends its own child.
#define VLDTR_E_MAR_NAMENULL            EMAKEHR(0x125B) // ManifestResource name is NULL.
#define VLDTR_E_FILE_DUP                EMAKEHR(0x125C) // File has dup.
#define VLDTR_E_FILE_NAMEFULLQLFD       EMAKEHR(0x125D) // File name is fully qualified.
#define VLDTR_E_CT_DUP                  EMAKEHR(0x125E) // ComType has dup.
#define VLDTR_E_MAR_DUP                 EMAKEHR(0x125F) // ManifestResource has dup.
#define VLDTR_E_MAR_NOTPUBPRIV          EMAKEHR(0x1260) // ManifestResource is neither Public not Private.
#define VLDTR_E_TD_ENUMNOVALUE          EMAKEHR(0x1261) // Enum has no "value__" field.
#define VLDTR_E_TD_ENUMVALSTATIC        EMAKEHR(0x1262) // Enum's "value__" field is static.
#define VLDTR_E_TD_ENUMVALNOTSN         EMAKEHR(0x1263) // Enum's "value__" field is not SpecialName.
#define VLDTR_E_TD_ENUMFLDNOTST         EMAKEHR(0x1264) // Enum's field is not static.
#define VLDTR_E_TD_ENUMFLDNOTLIT        EMAKEHR(0x1265) // Enum's field is not literal.
#define VLDTR_E_TD_ENUMNOLITFLDS        EMAKEHR(0x1266) // Enum has no literal fields.
#define VLDTR_E_TD_ENUMFLDSIGMISMATCH   EMAKEHR(0x1267) // Enum's field sig does not match value__ sig.
#define VLDTR_E_TD_ENUMVALNOT1ST        EMAKEHR(0x1268) // Enum's "value__" field is not first.
#define VLDTR_E_FD_NOTVALUERTSN         EMAKEHR(0x1269) // Field is RTSpecialName but name is not "value__".
#define VLDTR_E_FD_VALUEPARNOTENUM      EMAKEHR(0x126A) // Field "value__" in not Enum class.
#define VLDTR_E_FD_INSTINIFACE          EMAKEHR(0x126B) // Instance field in interface.
#define VLDTR_E_FD_NOTPUBINIFACE        EMAKEHR(0x126C) // Non-public field in interface.
#define VLDTR_E_FMD_GLOBALNOTPUBPRIVSC  EMAKEHR(0x126D) // Global field/method neither Public nor PrivateScope.
#define VLDTR_E_FMD_GLOBALNOTSTATIC     EMAKEHR(0x126E) // Global field/method not static.
#define VLDTR_E_FD_GLOBALNORVA          EMAKEHR(0x126F) // Global field has no RVA.
#define VLDTR_E_MD_CTORZERORVA          EMAKEHR(0x1270) // .ctor,.cctor has zero RVA.
#define VLDTR_E_FD_MARKEDNOMARSHAL      EMAKEHR(0x1271) // Field is marked marshaled but has no marshaling rec.
#define VLDTR_E_FD_MARSHALNOTMARKED     EMAKEHR(0x1272) // Field has marshaling rec but is not marked marshaled.
#define VLDTR_E_FD_MARKEDNODEFLT        EMAKEHR(0x1273) // Field is marked HasDefault but has no const value.
#define VLDTR_E_FD_DEFLTNOTMARKED       EMAKEHR(0x1274) // Field has const value rec but is not marked HasDefault.
#define VLDTR_E_FMD_MARKEDNOSECUR       EMAKEHR(0x1275) // Field/method is marked HasSecurity but has no security rec.
#define VLDTR_E_FMD_SECURNOTMARKED      EMAKEHR(0x1276) // Field/method has security rec but is not marked HasSecurity.
#define VLDTR_E_FMD_PINVOKENOTSTATIC    EMAKEHR(0x1277) // Field/method is PInvoke but is not marked Static.
#define VLDTR_E_FMD_MARKEDNOPINVOKE     EMAKEHR(0x1278) // Field/method is marked PInvoke but has no ImplMap.
#define VLDTR_E_FMD_PINVOKENOTMARKED    EMAKEHR(0x1279) // Field/method has ImplMap but is not marked PInvoke.
#define VLDTR_E_FMD_BADIMPLMAP          EMAKEHR(0x127A) // Field/method has invalid ImplMap
#define VLDTR_E_IMAP_BADMODREF          EMAKEHR(0x127B) // ImplMap has invalid ModuleRef
#define VLDTR_E_IMAP_BADMEMBER          EMAKEHR(0x127C) // ImplMap has invalid MemberForwarded
#define VLDTR_E_IMAP_BADIMPORTNAME      EMAKEHR(0x127D) // ImplMap has invalid ImportName
#define VLDTR_E_IMAP_BADCALLCONV        EMAKEHR(0x127E) // ImplMap has invalid call conv
#define VLDTR_E_FMD_BADACCESSFLAG       EMAKEHR(0x127F) // Field/method has invalid access flag
#define VLDTR_E_FD_INITONLYANDLITERAL   EMAKEHR(0x1280) // Field is InitOnly and Literal
#define VLDTR_E_FD_LITERALNOTSTATIC     EMAKEHR(0x1281) // Field is Literal but not Static
#define VLDTR_E_FMD_RTSNNOTSN           EMAKEHR(0x1282) // Field/method is RTSpec.Name but not Spec.Name
#define VLDTR_E_MD_ABSTPARNOTABST       EMAKEHR(0x1283) // Method is abstract, parent is not
#define VLDTR_E_MD_NOTSTATABSTININTF    EMAKEHR(0x1284) // Method not static or abstract in interface
#define VLDTR_E_MD_NOTPUBININTF         EMAKEHR(0x1285) // Method not public in interface
#define VLDTR_E_MD_CTORININTF           EMAKEHR(0x1286) // ctor in interface
#define VLDTR_E_MD_GLOBALCTORCCTOR      EMAKEHR(0x1287) // global ctor or cctor
#define VLDTR_E_MD_CTORSTATIC           EMAKEHR(0x1288) // static ctor
#define VLDTR_E_MD_CTORNOTSNRTSN        EMAKEHR(0x1289) // ctor,cctor not marked SpecialName,RTSpecialName
#define VLDTR_E_MD_CTORVIRT             EMAKEHR(0x128A) // virtual ctor,cctor
#define VLDTR_E_MD_CTORABST             EMAKEHR(0x128B) // abstract ctor,cctor
#define VLDTR_E_MD_CCTORNOTSTATIC       EMAKEHR(0x128C) // instance cctor
#define VLDTR_E_MD_ZERORVA              EMAKEHR(0x128D) // RVA=0, method not abstract or pinvoke or runtime, or reverse
#define VLDTR_E_MD_FINNOTVIRT           EMAKEHR(0x128E) // Method is final and not virtual
#define VLDTR_E_MD_STATANDFINORVIRT     EMAKEHR(0x128F) // Method is static and final or virtual
#define VLDTR_E_MD_ABSTANDFINAL         EMAKEHR(0x1290) // Method is abstract and final
#define VLDTR_E_MD_ABSTANDIMPL          EMAKEHR(0x1291) // Method is abstract and implemented
#define VLDTR_E_MD_ABSTANDPINVOKE       EMAKEHR(0x1292) // Method is abstract and pinvoke
#define VLDTR_E_MD_ABSTNOTVIRT          EMAKEHR(0x1293) // Method is abstract and not virtual
#define VLDTR_E_MD_NOTABSTNOTIMPL       EMAKEHR(0x1294) // Method is not abstract and not implemented
#define VLDTR_E_MD_NOTABSTBADFLAGSRVA   EMAKEHR(0x1295) // Method is not abstract and not (RVA!=0 or pinvoke or runtime)
#define VLDTR_E_MD_PRIVSCOPENORVA       EMAKEHR(0x1296) // Method is PrivateScope and has RVA==0
#define VLDTR_E_MD_GLOBALABSTORVIRT     EMAKEHR(0x1297) // Global method is abstract or virtual
#define VLDTR_E_SIG_LONGFORM            EMAKEHR(0x1298) // Signature uses long form
#define VLDTR_E_MD_MULTIPLESEMANTICS    EMAKEHR(0x1299) // Method has multiple semantics (warning)
#define VLDTR_E_MD_INVALIDSEMANTICS     EMAKEHR(0x129A) // Method has invalid semantics (not event or prop)
#define VLDTR_E_MD_SEMANTICSNOTEXIST    EMAKEHR(0x129B) // Method has semantics assoc that does not exist
#define VLDTR_E_MI_DECLNOTVIRT          EMAKEHR(0x129C) // MethodImpl's Decl is not virtual
#define VLDTR_E_FMD_GLOBALITEM          EMAKEHR(0x129D) // Global field/method (warning,CLS)
#define VLDTR_E_MD_MULTSEMANTICFLAGS    EMAKEHR(0x129E) // Method has multiple semantic flags set
#define VLDTR_E_MD_NOSEMANTICFLAGS      EMAKEHR(0x129F) // Method has no semantic flags set
#define VLDTR_E_FD_FLDINIFACE           EMAKEHR(0x12A0) // Field in Interface (warning, CLS)
#define VLDTR_E_AS_HASHALGID            EMAKEHR(0x12A1) // Unrecognized Hash Alg ID (warning)
#define VLDTR_E_AS_PROCID               EMAKEHR(0x12A2) // Unrecognized Processor ID in Assembly(warning)
#define VLDTR_E_AR_PROCID               EMAKEHR(0x12A3) // Unrecognized Processor ID in AssemblyRef(warning)
#define VLDTR_E_CN_PARENTRANGE          EMAKEHR(0x12A4) // Constant: parent token out of range
#define VLDTR_E_AS_BADFLAGS             EMAKEHR(0x12A5) // Invalid flags in Assembly
#define VLDTR_E_TR_HASTYPEDEF           EMAKEHR(0x12A6) // There is TypeDef with same name as TypeRef (warning)
#define VLDTR_E_IFACE_BADIMPL           EMAKEHR(0x12A7) // In InterfaceImpl, the implementing token is not TypeDef
#define VLDTR_E_IFACE_BADIFACE          EMAKEHR(0x12A8) // In InterfaceImpl, the implemented token is not TypeDef or TypeRef
#define VLDTR_E_TD_SECURNOTMARKED       EMAKEHR(0x12A9) // TypeDef has security rec but not marked HasSecurity
#define VLDTR_E_TD_MARKEDNOSECUR        EMAKEHR(0x12AA) // TypeDef marked HasSecurity but has no security rec
#define VLDTR_E_MD_CCTORHASARGS         EMAKEHR(0x12AB) // .cctor has arguments
#define VLDTR_E_CT_BADIMPL              EMAKEHR(0x12AC) // COMType has invalid Implementation
#define VLDTR_E_MI_ALIENBODY            EMAKEHR(0x12AD) // MethodImpl has body from other class
#define VLDTR_E_MD_CCTORCALLCONV        EMAKEHR(0x12AE) // .cctor has invalid calling convention
#define VLDTR_E_MI_BADCLASS             EMAKEHR(0x12AF) // MethodImpl has invalid Class token
#define VLDTR_E_MI_CLASSISINTF          EMAKEHR(0x12B0) // MethodImpl declared in Interface
#define VLDTR_E_MI_BADDECL              EMAKEHR(0x12B1) // MethodImpl has invalid MethodDeclaration token
#define VLDTR_E_MI_BADBODY              EMAKEHR(0x12B2) // MethodImpl has invalid MethodBody token
#define VLDTR_E_MI_DUP                  EMAKEHR(0x12B3) // MethodImpl has duplicate
#define VLDTR_E_FD_BADPARENT            EMAKEHR(0x12B4) // Bad field parent
#define VLDTR_E_MD_PARAMOUTOFSEQ        EMAKEHR(0x12B5) // Param out of sequence (warning)
#define VLDTR_E_MD_PARASEQTOOBIG        EMAKEHR(0x12B6) // Param's sequence num exceeds num of args
#define VLDTR_E_MD_PARMMARKEDNOMARSHAL  EMAKEHR(0x12B7) // Param marked HasMarshal, has no marshaling info
#define VLDTR_E_MD_PARMMARSHALNOTMARKED EMAKEHR(0x12B8) // Param has marshaling info, not marked HasMarshal
#define VLDTR_E_MD_PARMMARKEDNODEFLT    EMAKEHR(0x12BA) // Param marked HasDefault, has no const value
#define VLDTR_E_MD_PARMDEFLTNOTMARKED   EMAKEHR(0x12BB) // Param has const value, not marked HasDefault
#define VLDTR_E_PR_BADSCOPE             EMAKEHR(0x12BC) // Prop has invalid scope
#define VLDTR_E_PR_NONAME               EMAKEHR(0x12BD) // Prop has no name
#define VLDTR_E_PR_NOSIG                EMAKEHR(0x12BE) // Prop has no signature
#define VLDTR_E_PR_DUP                  EMAKEHR(0x12BF) // Prop has a duplicate
#define VLDTR_E_PR_BADCALLINGCONV       EMAKEHR(0x12C0) // Prop has bad calling convention
#define VLDTR_E_PR_MARKEDNODEFLT        EMAKEHR(0x12C1) // Prop marked HasDefault, has no const value
#define VLDTR_E_PR_DEFLTNOTMARKED       EMAKEHR(0x12C2) // Prop has const value, not marked HasDefault
#define VLDTR_E_PR_BADSEMANTICS         EMAKEHR(0x12C3) // Prop has method not (Setter,Getter, or Other)
#define VLDTR_E_PR_BADMETHOD            EMAKEHR(0x12C4) // Prop has method with invalid token
#define VLDTR_E_PR_ALIENMETHOD          EMAKEHR(0x12C5) // Prop has method from another class
#define VLDTR_E_CN_BLOBNOTNULL          EMAKEHR(0x12C6) // Const has non-null blob when it should not
#define VLDTR_E_CN_BLOBNULL             EMAKEHR(0x12C7) // Const has null value blob
#define VLDTR_E_EV_BADSCOPE             EMAKEHR(0x12C8) // Event has invalid scope
#define VLDTR_E_EV_NONAME               EMAKEHR(0x12CA) // Event has no name
#define VLDTR_E_EV_DUP                  EMAKEHR(0x12CB) // Event has a duplicate
#define VLDTR_E_EV_BADEVTYPE            EMAKEHR(0x12CC) // Event has invalid EventType
#define VLDTR_E_EV_EVTYPENOTCLASS       EMAKEHR(0x12CD) // Event's EventType is not a class
#define VLDTR_E_EV_BADSEMANTICS         EMAKEHR(0x12CE) // Event has method not (AddOn,RemoveOn,Fire,Other)
#define VLDTR_E_EV_BADMETHOD            EMAKEHR(0x12CF) // Event has method with invalid token
#define VLDTR_E_EV_ALIENMETHOD          EMAKEHR(0x12D0) // Event has method from another class
#define VLDTR_E_EV_NOADDON              EMAKEHR(0x12D1) // Event has no AddOn method
#define VLDTR_E_EV_NOREMOVEON           EMAKEHR(0x12D2) // Event has no RemoveOn method
#define VLDTR_E_CT_DUPTDNAME            EMAKEHR(0x12D3) // ExportedType has same name as TypeDef
#define VLDTR_E_MAR_BADOFFSET           EMAKEHR(0x12D4) // MRes refers to non-PE file with offset !=0
#define VLDTR_E_DS_BADOWNER             EMAKEHR(0x12D5) // Decl.security has invalid owner token
#define VLDTR_E_DS_BADFLAGS             EMAKEHR(0x12D6) // Decl.security has invalid action flags
#define VLDTR_E_DS_NOBLOB               EMAKEHR(0x12D7) // Decl.security has no permission blob
#define VLDTR_E_MAR_BADIMPL             EMAKEHR(0x12D8) // Manifest resource has invalid Implementation
#define VLDTR_E_MR_VARARGCALLINGCONV    EMAKEHR(0x12DA) // MemberRef has VARARG calling conv. (CLS warning)
#define VLDTR_E_MD_CTORNOTVOID          EMAKEHR(0x12DB) // .ctor,.cctor returning not void
#define VLDTR_E_EV_FIRENOTVOID          EMAKEHR(0x12DC) // Fire method returning not void
#define VLDTR_E_AS_BADLOCALE            EMAKEHR(0x12DD) // Invalid locale
#define VLDTR_E_CN_PARENTTYPE           EMAKEHR(0x12DE) // Constant has parent of invalid type
#define VLDTR_E_SIG_SENTINMETHODDEF     EMAKEHR(0x12DF) // E_T_SENTINEL in MethodDef signature
#define VLDTR_E_SIG_SENTMUSTVARARG      EMAKEHR(0x12E0) // E_T_SENTINEL <=> VARARG
#define VLDTR_E_SIG_MULTSENTINELS       EMAKEHR(0x12E1) // Multiple E_T_SENTINELs
#define VLDTR_E_SIG_LASTSENTINEL        EMAKEHR(0x12E2) // E_T_SENTINEL not followed by type
#define VLDTR_E_SIG_MISSARG             EMAKEHR(0x12E3) // Signature missing argument
#define VLDTR_E_SIG_BYREFINFIELD        EMAKEHR(0x12E4) // Field of ByRef type
#define VLDTR_E_MD_SYNCMETHODINVTYPE    EMAKEHR(0x12E5) // Synchronized method in value class
#define VLDTR_E_TD_NAMETOOLONG          EMAKEHR(0x12E6) // TypeDef name too long
#define VLDTR_E_AS_PROCDUP              EMAKEHR(0x12E7) // Duplicate Assembly Processor
#define VLDTR_E_ASOS_DUP                EMAKEHR(0x12E8) // Duplicate Assembly OS (ID+ver.major+ver.minor)
#define VLDTR_E_MAR_BADFLAGS            EMAKEHR(0x12E9) // Manifest Resource has bad flags
#define VLDTR_E_CT_NOTYPEDEFID          EMAKEHR(0x12EA) // COMType has nil TypeDefId
#define VLDTR_E_FILE_BADFLAGS           EMAKEHR(0x12EB) // File has bad flags
#define VLDTR_E_FILE_NULLHASH           EMAKEHR(0x12EC) // File has no hash blob
#define VLDTR_E_MOD_NONAME              EMAKEHR(0x12ED) // Module has no name
#define VLDTR_E_MOD_NAMEFULLQLFD        EMAKEHR(0x12EE) // Module has fully-qualified name
#define VLDTR_E_TD_RTSPCLNOTSPCL        EMAKEHR(0x12EF) // TypeDef is tdRTSpecialName but not tdSpecialName
#define VLDTR_E_TD_EXTENDSIFACE         EMAKEHR(0x12F0) // TypeDef extends interface
#define VLDTR_E_MD_CTORPINVOKE          EMAKEHR(0x12F1) // .ctor,.cctor is PInvokeImpl
#define VLDTR_E_TD_SYSENUMNOTCLASS      EMAKEHR(0x12F2) // System.Enum is not a class
#define VLDTR_E_TD_SYSENUMNOTEXTVTYPE   EMAKEHR(0x12F3) // System.Enum extends not System.ValueType
#define VLDTR_E_MI_SIGMISMATCH          EMAKEHR(0x12F4) // MethodImpl's Decl and Body signatures mismatch
#define VLDTR_E_TD_ENUMHASMETHODS       EMAKEHR(0x12F5) // TypeDef extends System.Enum but has methods
#define VLDTR_E_TD_ENUMIMPLIFACE        EMAKEHR(0x12F6) // TypeDef extends System.Enum but impls interface(s)
#define VLDTR_E_TD_ENUMHASPROP          EMAKEHR(0x12F7) // TypeDef extends System.Enum but has prop(s)
#define VLDTR_E_TD_ENUMHASEVENT         EMAKEHR(0x12F8) // TypeDef extends System.Enum but has event(s)
#define VLDTR_E_TD_BADMETHODLST         EMAKEHR(0x12F9) // TypeDef has MethodList > Nmethods+1
#define VLDTR_E_TD_BADFIELDLST          EMAKEHR(0x12FA) // TypeDef has FieldList > Nfields+1
#define VLDTR_E_CN_BADTYPE              EMAKEHR(0x12FB) // Constant has wrong type
#define VLDTR_E_TD_ENUMNOINSTFLD        EMAKEHR(0x12FC) // Enum has no instance fields
#define VLDTR_E_TD_ENUMMULINSTFLD       EMAKEHR(0x12FD) // Enum has multiple instance fields
             
                                  
#define VLDTR_E_INTERRUPTED             EMAKEHR(0x12FE) // Validator has been interrupted by the VEHandler.
#define VLDTR_E_NOTINIT                 EMAKEHR(0x12FF) // Validator failed to initialize correctly.

#define VLDTR_E_IFACE_NOTIFACE          EMAKEHR(0x1B00) // Interface in InterfaceImpl is not marked tdInterface
#define VLDTR_E_FD_RVAHASNORVA          EMAKEHR(0x1B01) // Field marked fdHasFieldRVA but has no RVA rec
#define VLDTR_E_FD_RVAHASZERORVA        EMAKEHR(0x1B02) // Field marked fdHasFieldRVA has RVA =0
#define VLDTR_E_MD_RVAANDIMPLMAP        EMAKEHR(0x1B03) // Method has both RVA !=0 and ImplMap
#define VLDTR_E_TD_EXTRAFLAGS           EMAKEHR(0x1B04) // TypeDef has extraneous bits in flags
#define VLDTR_E_TD_EXTENDSITSELF        EMAKEHR(0x1B05) // TypeDef extends itself
#define VLDTR_E_TD_SYSVTNOTEXTOBJ       EMAKEHR(0x1B06) // System.ValueType does not extend System.Object
#define VLDTR_E_TD_EXTTYPESPEC          EMAKEHR(0x1B07) // Class extends TypeSpec (warning)
#define VLDTR_E_TD_VTNOSIZE             EMAKEHR(0x1B09) // Value Class has zero size
#define VLDTR_E_TD_IFACESEALED          EMAKEHR(0x1B0A) // Interface is sealed
#define VLDTR_E_NC_BADNESTED            EMAKEHR(0x1B0B) // Bad "nested" token in NestedClass
#define VLDTR_E_NC_BADENCLOSER          EMAKEHR(0x1B0C) // Bad "enclosing" token in NestedClass
#define VLDTR_E_NC_DUP                  EMAKEHR(0x1B0D) // Duplicate NestedClass record
#define VLDTR_E_NC_DUPENCLOSER          EMAKEHR(0x1B0E) // Duplicate NestedClass with different encloser
#define VLDTR_E_FRVA_ZERORVA            EMAKEHR(0x1B0F) // RVA=0 in FieldRVA record
#define VLDTR_E_FRVA_BADFIELD           EMAKEHR(0x1B10) // Invalid field token in FieldRVA record
#define VLDTR_E_FRVA_DUPRVA             EMAKEHR(0x1B11) // Duplicate RVA in FieldRVA record
#define VLDTR_E_FRVA_DUPFIELD           EMAKEHR(0x1B12) // Duplicate field in FieldRVA record
#define VLDTR_E_EP_BADTOKEN             EMAKEHR(0x1B13) // Bad token as entry point in CLR header
#define VLDTR_E_EP_INSTANCE             EMAKEHR(0x1B14) // Entry point in CLR header is a token of instance method
#define VLDTR_E_TD_ENUMFLDBADTYPE       EMAKEHR(0x1B15) // Enum has non-integral underlying type
#define VLDTR_E_MD_BADRVA               EMAKEHR(0x1B16) // Method has bogus RVA
#define VLDTR_E_FD_LITERALNODEFAULT     EMAKEHR(0x1B17) // Literal field has no const value
#define VLDTR_E_IFACE_METHNOTIMPL       EMAKEHR(0x1B18) // Class implementing an interface doesn't impl.one of methods
#define VLDTR_E_CA_BADPARENT            EMAKEHR(0x1B19) // CA has invalid owner
#define VLDTR_E_CA_BADTYPE              EMAKEHR(0x1B1A) // CA has invalid type
#define VLDTR_E_CA_NOTCTOR              EMAKEHR(0x1B1B) // CA type is not .ctor
#define VLDTR_E_CA_BADSIG               EMAKEHR(0x1B1C) // CA type has bad signature
#define VLDTR_E_CA_NOSIG                EMAKEHR(0x1B1D) // CA type has no signature
#define VLDTR_E_CA_BADPROLOG            EMAKEHR(0x1B1E) // CA blob has bad prolog (not 0x01 0x00)
#define VLDTR_E_MD_BADLOCALSIGTOK       EMAKEHR(0x1B1F) // Method has invalid LocalSig token
#define VLDTR_E_MD_BADHEADER            EMAKEHR(0x1B20) // Method has invalid header
#define VLDTR_E_EP_TOOMANYARGS          EMAKEHR(0x1B21) // Entry point has more than one arg
#define VLDTR_E_EP_BADRET               EMAKEHR(0x1B22) // Entry point has bad return type
#define VLDTR_E_EP_BADARG               EMAKEHR(0x1B23) // Entry point has bad argument
#define VLDTR_E_SIG_BADVOID             EMAKEHR(0x1B24) // Illegal "void" in signature


//**** Common Language Runtime Debugging Services errors
#define CORDBG_E_UNRECOVERABLE_ERROR                    EMAKEHR(0x1300) // Unrecoverable API error.
#define CORDBG_E_PROCESS_TERMINATED                     EMAKEHR(0x1301) // Process was terminated.
#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED               EMAKEHR(0x1302) // Process not synchronized.
#define CORDBG_E_CLASS_NOT_LOADED                       EMAKEHR(0x1303) // A class is not loaded.
#define CORDBG_E_IL_VAR_NOT_AVAILABLE                   EMAKEHR(0x1304) // An IL variable is not available at the
                                                                        // current native IP.
#define CORDBG_E_BAD_REFERENCE_VALUE                    EMAKEHR(0x1305) // A reference value was found to be bad
                                                                        // during dereferencing.
#define CORDBG_E_FIELD_NOT_AVAILABLE                    EMAKEHR(0x1306) // A field in a class is not available,
                                                                        // because the runtime optimized it away.
#define CORDBG_E_NON_NATIVE_FRAME                       EMAKEHR(0x1307) // "Native frame only" operation on
                                                                        // non-native frame
#define CORDBG_E_NONCONTINUABLE_EXCEPTION               EMAKEHR(0x1308) // Continue on non-continuable exception
#define CORDBG_E_CODE_NOT_AVAILABLE                     EMAKEHR(0x1309) // The code is currently unavailable
#define CORDBG_E_FUNCTION_NOT_IL                        EMAKEHR(0x130A) // Attempt to get a ICorDebugFunction for
                                                                        // a function that is not IL.
#define CORDBG_S_BAD_START_SEQUENCE_POINT               SMAKEHR(0x130B) // Attempt to SetIP not at a sequence point
#define CORDBG_S_BAD_END_SEQUENCE_POINT                 SMAKEHR(0x130C) // Attempt to SetIP when not going to a
                                                                        // sequence point.  If both this and
                                                                        // CORDBG_E_BAD_START_SEQUENCE_POINT are
                                                                        // true, only CORDBG_E_BAD_START_SEQUENCE_POINT
                                                                        // will be reported.
#define CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP           SMAKEHR(0x130D) // SetIP is possible, but the debugger doesn't
                                                                        // have enough info to fix variable locations,
                                                                        // GC refs, or anything else. Use at your own
                                                                        // risk.
#define CORDBG_E_CANT_SET_IP_INTO_FINALLY               EMAKEHR(0x130E) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling finally clause to a point inside
                                                                        // of one.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY             EMAKEHR(0x130F) // SetIP isnt possible because it would move 
                                                                        // EIP from within an exception handling finally 
                                                                        // clause to a point outside of one.
#define CORDBG_E_CANT_SET_IP_INTO_CATCH                 EMAKEHR(0x1310) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling catch clause to a point inside of
                                                                        // one.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME    EMAKEHR(0x1311) // Setip cannot be done on any frame except
                                                                        // the leaf frame.
#define CORDBG_E_SET_IP_IMPOSSIBLE                      EMAKEHR(0x1312) // SetIP isn't allowed. For example, there is
                                                                        // insufficient memory to perform SetIP.
#define CORDBG_E_FUNC_EVAL_BAD_START_POINT              EMAKEHR(0x1313) // Func eval can't work if we're, for example,
                                                                        // not stopped at a GC safe point.
#define CORDBG_E_INVALID_OBJECT                         EMAKEHR(0x1314) // This object value is no longer valid.  
#define CORDBG_E_FUNC_EVAL_NOT_COMPLETE                 EMAKEHR(0x1315) // If you call CordbEval::GetResult before the
                                                                        // func eval has finished, you'll get this
                                                                        // result.
#define CORDBG_S_FUNC_EVAL_HAS_NO_RESULT                SMAKEHR(0x1316) // Some Func evals will lack a return value,
                                                                        // such as those whose return type is void.
#define CORDBG_S_VALUE_POINTS_TO_VOID                   SMAKEHR(0x1317) // The Debugging API doesn't support
                                                                        // dereferencing pointers of type void.
#define CORDBG_E_INPROC_NOT_IMPL                        EMAKEHR(0x1318) // The inproc version of the debugging API
                                                                        // doesn't implement this function,
#define CORDBG_S_FUNC_EVAL_ABORTED                      SMAKEHR(0x1319) // The func eval completed, but was aborted.
#define CORDBG_E_STATIC_VAR_NOT_AVAILABLE               EMAKEHR(0x131A) // A static variable isn't available because
                                                                        // it hasn't been initialized yet.
#define CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS     EMAKEHR(0x131B) // Can't copy a VC with object refs in it.
#define CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER       EMAKEHR(0x131C) // SetIP can't leave or enter a filter
#define CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE EMAKEHR(0x131D) // You can't change JIT settings for ZAP
                                                                        // modules.

#define CORDBG_E_REMOTE_CONNECTION_CONN_RESET           EMAKEHR(0x1320) // The remote device closed the connection.
#define CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE           EMAKEHR(0x1321) // The connection was closed due to akeep alive failure.
#define CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR          EMAKEHR(0x1322) // Generic error that the device connection has been broken with no chance for recovery.

#define CORDBG_E_BAD_THREAD_STATE                       EMAKEHR(0x132d) // The state of the thread is invalid.
#define CORDBG_E_DEBUGGER_ALREADY_ATTACHED              EMAKEHR(0x132e) // This process has already been attached to
#define CORDBG_E_SUPERFLOUS_CONTINUE                    EMAKEHR(0x132f) // Returned from a call to Continue that was
                                                                        // Not matched with a stopping event.
#define CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1330) // Can't perfrom SetValue on non-leaf frames.
#define CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE EMAKEHR(0x1331) // When doing EnC, some JITters don't let you
                                                                        // increase the maximum level to which
                                                                        // exception handling can be nested.
#define CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED             EMAKEHR(0x1332) // Tried to do EnC on a module that wasn't
                                                                        // started in EnC mode.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION        EMAKEHR(0x1333) // Setip cannot be done on any exception
#define CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL           EMAKEHR(0x1334) // The 'variable' doesn't exist because it is a
                                                                        // literal optimized away by the compiler - ask
                                                                        // Metadata for it's default value, instead.
#define CORDBG_E_PROCESS_DETACHED                       EMAKEHR(0x1335) // Process has been detached from
#define CORDBG_E_ENC_METHOD_SIG_CHANGED                 EMAKEHR(0x1336) // Not allowed to change the signature of an
                                                                        // existing method - compiler should make new method
                                                                        // instead.
#define CORDBG_E_ENC_METHOD_NO_LOCAL_SIG                EMAKEHR(0x1337) // Can't get the local signature for the method
                                                                        // we're trying to EnC.
#define CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUECLASS       EMAKEHR(0x1338) // Adding a field to a value class is prohibitted,
                                                                        // since we can't guarantee the new field is contiguous to
                                                                        // VC's on the stack, embedded in other objects, etc.
#define CORDBG_E_ENC_CANT_CHANGE_FIELD                  EMAKEHR(0x1339) // Once you've got a field, you're not allowed to change
                                                                        // it, since that would change the size of the type it belongs to.
#define CORDBG_E_ENC_RE_ADD_CLASS                       EMAKEHR(0x133A) // AddAvailableClassHaveLock will return this if we're trying to
                                                                        // to add a class that's been previously added.  If we've got a
                                                                        // "delta-PE" that includes everything from the original PE, then
                                                                        // we can ignore this return value. It's the same as S_OK in that case.
#define CORDBG_E_FIELD_NOT_STATIC                       EMAKEHR(0x133B) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-static field
#define CORDBG_E_FIELD_NOT_INSTANCE                     EMAKEHR(0x133C) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-instance field
#define CORDBG_E_ENC_ZAPPED_WITHOUT_ENC                 EMAKEHR(0x133D) // If a zap file was created without the EnC flag set, then
                                                                        // we can't do EnC on it, no matter what.
#define CORDBG_E_ENC_BAD_METHOD_INFO                    EMAKEHR(0x133E) // Lacking information about method.
#define CORDBG_E_ENC_JIT_CANT_UPDATE                    EMAKEHR(0x133F) // The JIT is unable to update the method.
#define CORDBG_E_ENC_MISSING_CLASS                      EMAKEHR(0x1340) // An internal structure about the class is missing
#define CORDBG_E_ENC_INTERNAL_ERROR                     EMAKEHR(0x1341) // Generic message for "Something user doesn't control went wrong" message.
#define CORDBG_E_ENC_HANGING_FIELD                      EMAKEHR(0x1342) // The field was added via enc after the class was loaded, and so instead of
                                                                        // the field being contiguous with the other fields, it's 'hanging' off the 
                                                                        // instance, so the right side will have to go & get (instance-specific 
                                                                        // info based on the particular object. 
#define CORDBG_E_MODULE_NOT_LOADED                      EMAKEHR(0x1343) // If the module isn't loaded, including if it's been unloaded.

#define CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS             EMAKEHR(0x1344) // Not allowed to change which class something inherits from
#define CORDBG_E_UNABLE_TO_SET_BREAKPOINT               EMAKEHR(0x1345) // Can't set a breakpoint here.
#define CORDBG_E_DEBUGGING_NOT_POSSIBLE                 EMAKEHR(0x1346) // Debugging isn't possible due to an incompatability within the CLR implementation.
#define CORDBG_E_KERNEL_DEBUGGER_ENABLED                EMAKEHR(0x1347) // Debugging isn't possible because a kernel debugger is enabled on the system.
#define CORDBG_E_KERNEL_DEBUGGER_PRESENT                EMAKEHR(0x1348) // Debugging isn't possible because a kernel debugger is present on the system.
#define CORDBG_E_HELPER_THREAD_DEAD                     EMAKEHR(0x1349) // The debugger's internal helper thread is dead.
#define CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE      EMAKEHR(0x134A) // Not allowed to change interface inheritance.
#define CORDBG_E_INCOMPATIBLE_PROTOCOL                  EMAKEHR(0x134B) // The debugger's protocol is incompatible with the debuggee.
#define CORDBG_E_TOO_MANY_PROCESSES                     EMAKEHR(0x134C) // The debugger can only handle a finite number of debuggees.
#define CORDBG_E_INTEROP_NOT_SUPPORTED                  EMAKEHR(0x134D) // Interop is not allowed on a win9x platform

//**** Common Language Runtime Profiling Services errors
#define CORPROF_E_FUNCTION_NOT_COMPILED EMAKEHR(0x1350)     // Function not yet compiled.
#define CORPROF_E_DATAINCOMPLETE        EMAKEHR(0x1351)     // The ID is not fully loaded/defined yet.
#define CORPROF_E_NOT_REJITABLE_METHODS EMAKEHR(0x1352)     // The Module is not configured for updateable methods.
#define CORPROF_E_CANNOT_UPDATE_METHOD  EMAKEHR(0x1353)     // The Method could not be updated for re-jit.
#define CORPROF_E_FUNCTION_NOT_IL       EMAKEHR(0x1354)     // The Method has no associated IL
#define CORPROF_E_NOT_MANAGED_THREAD    EMAKEHR(0x1355)     // The thread has never run managed code before
#define CORPROF_E_CALL_ONLY_FROM_INIT   EMAKEHR(0x1356)     // The function may only be called during profiler init
#define CORPROF_E_INPROC_NOT_ENABLED    EMAKEHR(0x1357)     // Inprocess debugging must be enabled during init
                                                            // Also returned when BeginInprocDebugging not called
                                                            // before using the inprocess debugging services
#define CORPROF_E_JITMAPS_NOT_ENABLED   EMAKEHR(0x1358)     // Can't get a JIT map becuase they are not enabled
#define CORPROF_E_INPROC_ALREADY_BEGUN  EMAKEHR(0x1359)     // If a profiler tries to call BeginInprocDebugging more than
                                                            // once, it will get this error.
#define CORPROF_E_INPROC_NOT_AVAILABLE  EMAKEHR(0x135A)     // States that inprocess debugging not allowed at this point
                                                            // (for example during GC callbacks or RuntimeSuspention callbacks
#define CORPROF_E_NOT_YET_AVAILABLE     EMAKEHR(0x135B)     // This is a general error used to indicated that the information
                                                            // requested is not yet available
//**** Security errors
#define SECURITY_E_XML_TO_ASN_ENCODING  EMAKEHR(0x1400)     // Failed to convert XML to ASN 
#define SECURITY_E_INCOMPATIBLE_SHARE   EMAKEHR(0x1401)     // Loading this assembly would produce a different grant set from other instances
#define SECURITY_E_UNVERIFIABLE         EMAKEHR(0x1402)     // Unverifable code failed policy check
#define SECURITY_E_INCOMPATIBLE_EVIDENCE EMAKEHR(0x1403)     // Assembly already loaded without additional security evidence.

//**** Reserved.
#define CLDB_E_INTERNALERROR            EMAKEHR(0x1fff)

// ******************
// Debugger & Profiler errors
// ******************


// ******************
// Security errors
// ******************

#define CORSEC_E_DECODE_SET             EMAKEHR(0x1410)         // Failure decoding permission set
#define CORSEC_E_ENCODE_SET             EMAKEHR(0x1411)         // Failure encoding permission set
#define CORSEC_E_UNSUPPORTED_FORMAT     EMAKEHR(0x1412)         // Unrecognized encoding format
#define SN_CRYPTOAPI_CALL_FAILED        EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define CORSEC_E_CRYPTOAPI_CALL_FAILED  EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define SN_NO_SUITABLE_CSP              EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_NO_SUITABLE_CSP        EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_INVALID_ATTR           EMAKEHR(0x1415)         // Invalid security custom attribute
#define CORSEC_E_POLICY_EXCEPTION       EMAKEHR(0x1416)         // PolicyException thrown
#define CORSEC_E_MIN_GRANT_FAIL         EMAKEHR(0x1417)         // Failed to grant minimum permission requests
#define CORSEC_E_NO_EXEC_PERM           EMAKEHR(0x1418)         // Failed to grant permission to execute
#define CORSEC_E_XMLSYNTAX              EMAKEHR(0x1419)         // XML Syntax error
#define CORSEC_E_INVALID_STRONGNAME     EMAKEHR(0x141a)         // Strong name validation failed
#define CORSEC_E_MISSING_STRONGNAME     EMAKEHR(0x141b)         // Assembly is not strong named
#define CORSEC_E_CONTAINER_NOT_FOUND    EMAKEHR(0x141c)         // Strong name key container not found
#define CORSEC_E_INVALID_IMAGE_FORMAT   EMAKEHR(0x141d)         // Invalid assembly file format

//**** crypto errors 1430 -- 143f

#define CORSEC_E_CRYPTO                 EMAKEHR(0x1430)         // generic CryptographicException
#define CORSEC_E_CRYPTO_UNEX_OPER       EMAKEHR(0x1431)         // generic CryptographicUnexpectedOperationException

//**** security custom attribute errors 143d -- 144f

#define CORSECATTR_E_BAD_ACTION_ASM             EMAKEHR(0x143d) // SecurityAction type invalid on assembly
#define CORSECATTR_E_BAD_ACTION_OTHER           EMAKEHR(0x143e) // SecurityAction type invalid on types and methods
#define CORSECATTR_E_BAD_PARENT                 EMAKEHR(0x143f) // Security custom attribute attached to invalid parent
#define CORSECATTR_E_TRUNCATED                  EMAKEHR(0x1440) // Bad custom attribute serialized blob
#define CORSECATTR_E_BAD_VERSION                EMAKEHR(0x1441) // Bad custom attribute serialized blob version
#define CORSECATTR_E_BAD_ACTION                 EMAKEHR(0x1442) // Invalid security action code
#define CORSECATTR_E_NO_SELF_REF                EMAKEHR(0x1443) // CA ref to CA def'd in same assembly
#define CORSECATTR_E_BAD_NONCAS                 EMAKEHR(0x1444) // Use of non-CAS perm with invalid action
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED       EMAKEHR(0x1445) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX    EMAKEHR(0x1446) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED           EMAKEHR(0x1447) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED_EX        EMAKEHR(0x1448) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_ABSTRACT                   EMAKEHR(0x1449) // CA type is abstract
#define CORSECATTR_E_UNSUPPORTED_TYPE           EMAKEHR(0x144a) // Unsupported type for field/property setter
#define CORSECATTR_E_UNSUPPORTED_ENUM_TYPE      EMAKEHR(0x144b) // Unsupported base type for enum field/property
#define CORSECATTR_E_NO_FIELD                   EMAKEHR(0x144c) // Couldn't find a CA field
#define CORSECATTR_E_NO_PROPERTY                EMAKEHR(0x144d) // Couldn't find a CA property
#define CORSECATTR_E_EXCEPTION                  EMAKEHR(0x144e) // Unexpected exception
#define CORSECATTR_E_EXCEPTION_HR               EMAKEHR(0x144f) // Unexpected exception


//**** Isolated Storage Errors 1450 - 14FF
#define ISS_E_ISOSTORE                   EMAKEHR(0x1450L)

#define ISS_E_OPEN_STORE_FILE            EMAKEHR(0x1460L)
#define ISS_E_OPEN_FILE_MAPPING          EMAKEHR(0x1461L)
#define ISS_E_MAP_VIEW_OF_FILE           EMAKEHR(0x1462L)
#define ISS_E_GET_FILE_SIZE              EMAKEHR(0x1463L)
#define ISS_E_CREATE_MUTEX               EMAKEHR(0x1464L)
#define ISS_E_LOCK_FAILED                EMAKEHR(0x1465L)
#define ISS_E_FILE_WRITE                 EMAKEHR(0x1466L)
#define ISS_E_SET_FILE_POINTER           EMAKEHR(0x1467L)
#define ISS_E_CREATE_DIR                 EMAKEHR(0x1468L)
#define ISS_E_STORE_NOT_OPEN             EMAKEHR(0x1469L)

#define ISS_E_CORRUPTED_STORE_FILE       EMAKEHR(0x1480L)
#define ISS_E_STORE_VERSION              EMAKEHR(0x1481L)
#define ISS_E_FILE_NOT_MAPPED            EMAKEHR(0x1482L)
#define ISS_E_BLOCK_SIZE_TOO_SMALL       EMAKEHR(0x1483L)
#define ISS_E_ALLOC_TOO_LARGE            EMAKEHR(0x1484L)
#define ISS_E_USAGE_WILL_EXCEED_QUOTA    EMAKEHR(0x1485L)
#define ISS_E_TABLE_ROW_NOT_FOUND        EMAKEHR(0x1486L)

#define ISS_E_DEPRECATE                  EMAKEHR(0x14A0L)
#define ISS_E_CALLER                     EMAKEHR(0x14A1L)
#define ISS_E_PATH_LENGTH                EMAKEHR(0x14A2L)
#define ISS_E_MACHINE                    EMAKEHR(0x14A3L)


#define ISS_E_ISOSTORE_START             EMAKEHR(0x1450L)
#define ISS_E_ISOSTORE_END               EMAKEHR(0x14FFL)

// ******************
// Classlib errors
// ******************


//
// MessageId: COR_E_APPLICATION
//
// MessageText: 
//
// The base class for all "less serious" exceptions.
//
#define COR_E_APPLICATION  EMAKEHR(0x1600L) 
 

//
// MessageId: COR_E_ARGUMENT
//
// MessageText: 
//
// An argument does not meet the contract of the method.
//
#define COR_E_ARGUMENT  E_INVALIDARG        // 0x80070057
 

//
// MessageId: COR_E_ARGUMENTOUTOFRANGE
//
// MessageText: 
//
// An argument was out of its legal range.
//
#define COR_E_ARGUMENTOUTOFRANGE  EMAKEHR(0x1502L) 


//
// MessageId: COR_E_ARITHMETIC
//
// MessageText: 
//
// Overflow or underflow in mathematical operations.
//
#define COR_E_ARITHMETIC  HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)     // 0x80070216
 

//
// MessageId: COR_E_ARRAYTYPEMISMATCH
//
// MessageText: 
//
// Attempted to store an object of the wrong type in an array
//
#define COR_E_ARRAYTYPEMISMATCH  EMAKEHR(0x1503L) 


//
// MessageId: COR_E_CONTEXTMARSHAL
//
// MessageText: 
//
// 
//
#define COR_E_CONTEXTMARSHAL  EMAKEHR(0x1504L) 

//
// MessageId: COR_E_DEVICESNOTSUPPORTED
//
// MessageText: 
//
// 
//
#define COR_E_DEVICESNOTSUPPORTED  EMAKEHR(0x1540L) 

 
//
// MessageId: COR_E_DIVIDEBYZERO
//
// MessageText: 
//
// Attempted to divide a number by zero.
//
#define COR_E_DIVIDEBYZERO  DISP_E_DIVBYZERO
 

//
// MessageId: COR_E_EXCEPTION
//
// MessageText: 
//
// Base class for all exceptions in the runtime
//
#define COR_E_EXCEPTION  EMAKEHR(0x1500L) 
 

//
// MessageId: COR_E_EXECUTIONENGINE
//
// MessageText: 
//
// An internal error happened in the Common Language Runtime's Execution Engine
//
#define COR_E_EXECUTIONENGINE  EMAKEHR(0x1506L) 
 

//
// MessageId: COR_E_FIELDACCESS
//
// MessageText: 
//
// Access to this field is denied.
//
#define COR_E_FIELDACCESS  EMAKEHR(0x1507L) 
 

//
// MessageId: COR_E_FORMAT
//
// MessageText: 
//
// The format of one arguments does not meet the contract of the method.
//
#define COR_E_FORMAT  EMAKEHR(0x1537L)
 

//
// MessageId: COR_E_BADIMAGEFORMAT
//
// MessageText: 
//
// The format of DLL or executable being loaded is invalid.
//
#define COR_E_BADIMAGEFORMAT  _HRESULT_TYPEDEF_(0x8007000BL) 
 
 
//
// MessageId: COR_E_ASSEMBLYEXPECTED
//
// MessageText: 
//
// The module was expected to contain an assembly manifest.
//
#define COR_E_ASSEMBLYEXPECTED  EMAKEHR(0x1018L)

//
// MessageId: COR_E_TYPEUNLOADED
//
// MessageText: 
//
// The type had been unloaded.
//
#define COR_E_TYPEUNLOADED   EMAKEHR(0x1013L)

//
// MessageId: COR_E_INDEXOUTOFRANGE
//
// MessageText: 
//
// Attempted to access an element within an array by using an index that is 
// not within the bound of that array.
//
#define COR_E_INDEXOUTOFRANGE  EMAKEHR(0x1508L) 
 

//
// MessageId: COR_E_INVALIDCAST
//
// MessageText: 
//
// Indicates a bad cast condition
//
#define COR_E_INVALIDCAST  E_NOINTERFACE        // 0x80004002
 

//
// MessageId: COR_E_INVALIDOPERATION
//
// MessageText: 
//
// An operation is not legal in the current state.
//
#define COR_E_INVALIDOPERATION  EMAKEHR(0x1509L) 
 

//
// MessageId: COR_E_INVALIDPROGRAM
//
// MessageText: 
//
// A program contained invalid IL or bad metadata.  Usually this is a compiler bug.
//
#define COR_E_INVALIDPROGRAM  EMAKEHR(0x153AL) 


//
// MessageId: COR_E_MEMBERACCESS
//
// MessageText: 
//
// Access to this member is denied.
//
#define COR_E_MEMBERACCESS  EMAKEHR(0x151AL)


//
// MessageId: COR_E_METHODACCESS
//
// MessageText: 
//
// Access to this method is denied.
//
#define COR_E_METHODACCESS  EMAKEHR(0x1510L) 
 

//
// MessageId: COR_E_MISSINGFIELD
//
// MessageText: 
//
// An attempt was made to dynamically access a field that does not exist.
//
#define COR_E_MISSINGFIELD  EMAKEHR(0x1511L) 
 

//
// MessageId: COR_E_MISSINGMANIFESTRESOURCE
//
// MessageText: 
//
// An expected resource in the assembly manifest was missing.
//
#define COR_E_MISSINGMANIFESTRESOURCE  EMAKEHR(0x1532L) 


//
// MessageId: COR_E_MISSINGMEMBER
//
// MessageText: 
//
// An attempt was made to dynamically invoke or access a field or method
// that does not exist.
//
#define COR_E_MISSINGMEMBER  EMAKEHR(0x1512L) 


//
// MessageId: COR_E_MISSINGMETHOD
//
// MessageText: 
//
// An attempt was made to dynamically invoke a method that does not exist
//
#define COR_E_MISSINGMETHOD  EMAKEHR(0x1513L) 
 

//
// MessageId: COR_E_MULTICASTNOTSUPPORTED
//
// MessageText: 
//
// Attempted to combine delegates that are not multicast
//
#define COR_E_MULTICASTNOTSUPPORTED  EMAKEHR(0x1514L) 
 

//
// MessageId: COR_E_NOTFINITENUMBER
//
// MessageText: 
//
//  Thrown if value (a floating point number) is either the not a number value (NaN) or +- infinity value
//  VB needs this stuff 
#define COR_E_NOTFINITENUMBER     EMAKEHR(0x1528L)


//
// MessageId: COR_E_DUPLICATEWAITOBJECT
//
// MessageText: 
//
// An object appears more than once in the wait objects array.
//
#define COR_E_DUPLICATEWAITOBJECT   EMAKEHR(0x1529L)


//
// MessageId: COR_E_PLATFORMNOTSUPPORTED
//
// MessageText: 
//
// The method is not supported on this platform
//
#define COR_E_PLATFORMNOTSUPPORTED  EMAKEHR(0x1539L) 

//
// MessageId: COR_E_NOTSUPPORTED
//
// MessageText: 
//
// The method is not supported
//
#define COR_E_NOTSUPPORTED  EMAKEHR(0x1515L) 
 
//
// MessageId: COR_E_NULLREFERENCE
//
// MessageText: 
//
// Dereferencing a null reference. In general class libraries should not throw this
//
#define COR_E_NULLREFERENCE  E_POINTER      // 0x80004003
 

//
// MessageId: COR_E_OUTOFMEMORY
//
// MessageText: 
//
// The EE thows this exception when no more memory is avaible to continue execution
//
#define COR_E_OUTOFMEMORY  E_OUTOFMEMORY        // 0x8007000E
 

//
// MessageId: COR_E_OVERFLOW
//
// MessageText: 
//
// An arithmetic, casting, or conversion operation overflowed or underflowed.
//
#define COR_E_OVERFLOW  EMAKEHR(0x1516L) 
 

//
// MessageId: COR_E_RANK
//
// MessageText: 
//
// An array has the wrong number of dimensions for a particular operation.
//
#define COR_E_RANK  EMAKEHR(0x1517L) 
 

//
// MessageId: COR_E_REMOTING
//
// MessageText: 
//
// An error relating to remoting occurred.
//
#define COR_E_REMOTING  EMAKEHR(0x150BL)
#define COR_E_SERVER  EMAKEHR(0x150EL) 

//
// MessageId: COR_E_SERVICEDCOMPONENT
//
// MessageText: 
//
// An error relating to ServicedComponent occurred.
//
#define COR_E_SERVICEDCOMPONENT  EMAKEHR(0x150FL)

             
//
// MessageId: COR_E_SECURITY
//
// MessageText: 
//
// An error relating to security occured.
//
#define COR_E_SECURITY  EMAKEHR(0x150AL) 
 

//
// MessageID: COR_E_SERIALIZATION
//
// MessageText:
//
// An error relating to serialization has occurred.
//
#define COR_E_SERIALIZATION EMAKEHR(0x150CL)


//
// MessageId: COR_E_STACKOVERFLOW
//
// MessageText: 
//
// Is raised by the EE when the execution stack overflows as it is attempting to ex
//
#define COR_E_STACKOVERFLOW  HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW)       // 0x800703E9


//
// MessageId: COR_E_SYNCHRONIZATIONLOCK
//
// MessageText: 
//
// Wait(), Notify() or NotifyAll() was called from an unsynchronized ** block of c
//
#define COR_E_SYNCHRONIZATIONLOCK  EMAKEHR(0x1518L) 


//
// MessageId: COR_E_SYSTEM
//
// MessageText: 
//
// The base class for the runtime's "less serious" exceptions
//
#define COR_E_SYSTEM  EMAKEHR(0x1501L) 


//
// MessageId: COR_E_THREADABORTED
//
// MessageText: 
//
// Thrown into a thread to cause it to abort. Not catchable. 
//
#define COR_E_THREADABORTED  EMAKEHR(0x1530L) 

 
//
// MessageId: COR_E_THREADINTERRUPTED
//
// MessageText: 
//
// Indicates that the thread was interrupted from a waiting state
//
#define COR_E_THREADINTERRUPTED  EMAKEHR(0x1519L) 


//
// MessageId: COR_E_THREADSTATE
//
// MessageText: 
//
// Indicate that the Thread class is in an invalid state for the method call
//
#define COR_E_THREADSTATE  EMAKEHR(0x1520L) 
 

//
// MessageId: COR_E_THREADSTOP
//
// MessageText: 
//
// Thrown into a thread to cause it to stop. This exception is typically not caught
//
#define COR_E_THREADSTOP  EMAKEHR(0x1521L) 
 

//
// MessageId: COR_E_TYPEINITIALIZATION
//
// MessageText: 
//
// An exception was thrown by a type's initializer (.cctor).
//
#define COR_E_TYPEINITIALIZATION  EMAKEHR(0x1534L) 


//
// MessageId: COR_E_TYPELOAD
//
// MessageText: 
//
// Could not find or load a specific type (class, enum, etc).
//
#define COR_E_TYPELOAD  EMAKEHR(0x1522L) 


//
// MessageId: COR_E_ENTRYPOINTNOTFOUND
//
// MessageText: 
//
// Could not find the specified DllImport entry point
//
#define COR_E_ENTRYPOINTNOTFOUND  EMAKEHR(0x1523L) 


//
// MessageId: COR_E_DLLNOTFOUND
//
// MessageText: 
//
// Could not find the specified DllImport DLL.
//
#define COR_E_DLLNOTFOUND  EMAKEHR(0x1524L) 


//
// MessageId: COR_E_UNAUTHORIZEDACCESS
//
// MessageText: 
//
// Access is denied.
//
#define COR_E_UNAUTHORIZEDACCESS  E_ACCESSDENIED    // 0x80070005


//
// MessageId: COR_E_VERIFICATION
//
// MessageText: 
//
// A verification failure occurred
//
#define COR_E_VERIFICATION  EMAKEHR(0x150DL) 


//
// MessageId: COR_E_INVALIDCOMOBJECT
//
// MessageText: 
//
// An invalid __ComObject has been used.
//
#define COR_E_INVALIDCOMOBJECT     EMAKEHR(0x1527L)


//
// MessageId: COR_E_MARSHALDIRECTIVE
//
// MessageText: 
//
// The marshaling directives are invalid.
//
#define COR_E_MARSHALDIRECTIVE     EMAKEHR(0x1535L)


//
// MessageId: COR_E_INVALIDOLEVARIANTTYPE
//
// MessageText: 
//
// The type of an OLE variant that was passed into the runtime is invalid.
//
#define COR_E_INVALIDOLEVARIANTTYPE    EMAKEHR(0x1531L)


//
// MessageId: COR_E_SAFEARRAYTYPEMISMATCH
//
// MessageText: 
//
// A mismatch has occured between the runtime type of the array and the 
// sub type recorded in the metadata.
//
#define COR_E_SAFEARRAYTYPEMISMATCH    EMAKEHR(0x1533L)


//
// MessageId: COR_E_SAFEARRAYRANKMISMATCH
//
// MessageText: 
//
// A mismatch has occured between the runtime rank of the array and the 
// rank recorded in the metadata.
//
#define COR_E_SAFEARRAYRANKMISMATCH    EMAKEHR(0x1538L)


//
// MessageId: COR_E_TARGETPARAMCOUNT
//
// MessageText: 
//
// There was a mismatch between number of arguments provided and the number expected
//
#define COR_E_TARGETPARAMCOUNT     DISP_E_BADPARAMCOUNT
 

//
// MessageId: COR_E_AMBIGUOUSMATCH
//
// MessageText: 
//
// While late binding to a method via reflection, could not resolve between 
// multiple overloads of a method.
//
#define COR_E_AMBIGUOUSMATCH  _HRESULT_TYPEDEF_(0x8000211DL) 
 

//
// MessageId: COR_E_INVALIDFILTERCRITERIA
//
// MessageText: 
//
// The given filter criteria does not match the filter contract.
//
#define COR_E_INVALIDFILTERCRITERIA  EMAKEHR(0x1601L) 
 

//
// MessageId: COR_E_REFLECTIONTYPELOAD
//
// MessageText: 
//
// Could not find or load a specific class that was requested through Reflection
//
#define COR_E_REFLECTIONTYPELOAD  EMAKEHR(0x1602L) 


//
// MessageId: COR_E_TARGET
//
// MessageText: 
//
// - If you attempt to invoke a non-static method with a null Object - If you atte
//
#define COR_E_TARGET  EMAKEHR(0x1603L) 
 

//
// MessageId: COR_E_TARGETINVOCATION
//
// MessageText: 
//
// If the method called throws an exception
//
#define COR_E_TARGETINVOCATION  EMAKEHR(0x1604L)


//
// MessageId: COR_E_CUSTOMATTRIBUTEFORMAT
//
// MessageText: 
//
// If the binary format of a custom attribute is invalid.
//
#define COR_E_CUSTOMATTRIBUTEFORMAT  EMAKEHR(0x1605L)


//
// MessageId: COR_E_ENDOFSTREAM
//
// MessageText: 
//
// Thrown when the End of file is reached
//
#define COR_E_ENDOFSTREAM  HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) 
 

//
// MessageId: COR_E_FILELOAD
//
// MessageText: 
//
// 
//
#define COR_E_FILELOAD  EMAKEHR(0x1621L)


//
// MessageId: COR_E_FILENOTFOUND
//
// MessageText: 
//
// 
//
#define COR_E_FILENOTFOUND  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

//
// MessageId: COR_E_IO
//
// MessageText: 
//
// Some sort of I/O error.
//
#define COR_E_IO  EMAKEHR(0x1620L) 
 

//
// MessageId: COR_E_DIRECTORYNOTFOUND
//
// MessageText: 
//
// The specified path couldn't be found.
//
#define COR_E_DIRECTORYNOTFOUND  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)


//
// MessageId: COR_E_PATHTOOLONG
//
// MessageText: 
//
// The specified path was too long.
// 
#define COR_E_PATHTOOLONG  HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE)



//**** Shim errors 1700 - 1750
// 
#define CLR_E_SHIM_RUNTIMELOAD            EMAKEHR(0x1700)     // Failed to load the runtime
#define CLR_E_SHIM_RUNTIMEEXPORT          EMAKEHR(0x1701)     // Failed to find a required export in the runtime
#define CLR_E_SHIM_INSTALLROOT            EMAKEHR(0x1702)     // Install root is not defined
#define CLR_E_SHIM_INSTALLCOMP            EMAKEHR(0x1703)     // Expected component of the runtime is not available

//**** Verifier Errors 1800 - 18FF
// See src/dlls/mscorrc/mscorrc.rc for a description of each error

#define VER_E_HRESULT           EMAKEHR(0x1801)
#define VER_E_OFFSET            EMAKEHR(0x1802)
#define VER_E_OPCODE            EMAKEHR(0x1803)
#define VER_E_OPERAND           EMAKEHR(0x1804)
#define VER_E_TOKEN             EMAKEHR(0x1805)
#define VER_E_EXCEPT            EMAKEHR(0x1806)
#define VER_E_STACK_SLOT        EMAKEHR(0x1807)
#define VER_E_LOC               EMAKEHR(0x1808)
#define VER_E_ARG               EMAKEHR(0x1809)
#define VER_E_FOUND             EMAKEHR(0x180A)
#define VER_E_EXPECTED          EMAKEHR(0x180B)

#define VER_E_UNKNOWN_OPCODE    EMAKEHR(0x1810)
#define VER_E_SIG_CALLCONV      EMAKEHR(0x1811)
#define VER_E_SIG_ELEMTYPE      EMAKEHR(0x1812)

#define VER_E_RET_SIG           EMAKEHR(0x1814)
#define VER_E_FIELD_SIG         EMAKEHR(0x1815)

#define VER_E_INTERNAL          EMAKEHR(0x1818)
#define VER_E_STACK_TOO_LARGE   EMAKEHR(0x1819)
#define VER_E_ARRAY_NAME_LONG   EMAKEHR(0x181A)

#define VER_E_FALLTHRU          EMAKEHR(0x1820)
#define VER_E_TRY_GTEQ_END      EMAKEHR(0x1821)
#define VER_E_TRYEND_GT_CS      EMAKEHR(0x1822)
#define VER_E_HND_GTEQ_END      EMAKEHR(0x1823)
#define VER_E_HNDEND_GT_CS      EMAKEHR(0x1824)
#define VER_E_FLT_GTEQ_CS       EMAKEHR(0x1825)
#define VER_E_TRY_START         EMAKEHR(0x1826)
#define VER_E_HND_START         EMAKEHR(0x1827)
#define VER_E_FLT_START         EMAKEHR(0x1828)
#define VER_E_TRY_OVERLAP       EMAKEHR(0x1829)
#define VER_E_TRY_EQ_HND_FIL    EMAKEHR(0x182A)
#define VER_E_TRY_SHARE_FIN_FAL EMAKEHR(0x182B)
#define VER_E_HND_OVERLAP       EMAKEHR(0x182C)
#define VER_E_HND_EQ            EMAKEHR(0x182D)
#define VER_E_FIL_OVERLAP       EMAKEHR(0x182E)
#define VER_E_FIL_EQ            EMAKEHR(0x182F)
#define VER_E_FIL_CONT_TRY      EMAKEHR(0x1830)
#define VER_E_FIL_CONT_HND      EMAKEHR(0x1831)
#define VER_E_FIL_CONT_FIL      EMAKEHR(0x1832)
#define VER_E_FIL_GTEQ_CS       EMAKEHR(0x1833)
#define VER_E_FIL_START         EMAKEHR(0x1834)
#define VER_E_FALLTHRU_EXCEP    EMAKEHR(0x1835)
#define VER_E_FALLTHRU_INTO_HND EMAKEHR(0x1836)
#define VER_E_FALLTHRU_INTO_FIL EMAKEHR(0x1837)
#define VER_E_LEAVE             EMAKEHR(0x1838)
#define VER_E_RETHROW           EMAKEHR(0x1839)
#define VER_E_ENDFINALLY        EMAKEHR(0x183A)
#define VER_E_ENDFILTER         EMAKEHR(0x183B)
#define VER_E_ENDFILTER_MISSING EMAKEHR(0x183C)
#define VER_E_BR_INTO_TRY       EMAKEHR(0x183D)
#define VER_E_BR_INTO_HND       EMAKEHR(0x183E)
#define VER_E_BR_INTO_FIL       EMAKEHR(0x183F)
#define VER_E_BR_OUTOF_TRY      EMAKEHR(0x1840)
#define VER_E_BR_OUTOF_HND      EMAKEHR(0x1841)
#define VER_E_BR_OUTOF_FIL      EMAKEHR(0x1842)
#define VER_E_BR_OUTOF_FIN      EMAKEHR(0x1843)
#define VER_E_RET_FROM_TRY      EMAKEHR(0x1844)
#define VER_E_RET_FROM_HND      EMAKEHR(0x1845)
#define VER_E_RET_FROM_FIL      EMAKEHR(0x1846)
#define VER_E_BAD_JMP_TARGET    EMAKEHR(0x1847)
#define VER_E_PATH_LOC          EMAKEHR(0x1848)
#define VER_E_PATH_THIS         EMAKEHR(0x1849)
#define VER_E_PATH_STACK        EMAKEHR(0x184A)
#define VER_E_PATH_STACK_DEPTH  EMAKEHR(0x184B)
#define VER_E_THIS              EMAKEHR(0x184C)
#define VER_E_THIS_UNINIT_EXCEP EMAKEHR(0x184D)
#define VER_E_THIS_UNINIT_STORE EMAKEHR(0x184E)
#define VER_E_THIS_UNINIT_RET   EMAKEHR(0x184F)
#define VER_E_THIS_UNINIT_V_RET EMAKEHR(0x1850)
#define VER_E_THIS_UNINIT_BR    EMAKEHR(0x1851)
#define VER_E_LDFTN_CTOR        EMAKEHR(0x1852)
#define VER_E_STACK_NOT_EQ      EMAKEHR(0x1853)
#define VER_E_STACK_UNEXPECTED  EMAKEHR(0x1854)
#define VER_E_STACK_EXCEPTION   EMAKEHR(0x1855)
#define VER_E_STACK_OVERFLOW    EMAKEHR(0x1856)
#define VER_E_STACK_UNDERFLOW   EMAKEHR(0x1857)
#define VER_E_STACK_EMPTY       EMAKEHR(0x1858)
#define VER_E_STACK_UNINIT      EMAKEHR(0x1859)
#define VER_E_STACK_I_I4_I8     EMAKEHR(0x185A)
#define VER_E_STACK_R_R4_R8     EMAKEHR(0x185B)
#define VER_E_STACK_NO_R_I8     EMAKEHR(0x185C)
#define VER_E_STACK_NUMERIC     EMAKEHR(0x185D)
#define VER_E_STACK_OBJREF      EMAKEHR(0x185E)
#define VER_E_STACK_P_OBJREF    EMAKEHR(0x185F)
#define VER_E_STACK_BYREF       EMAKEHR(0x1860)
#define VER_E_STACK_METHOD      EMAKEHR(0x1861)
#define VER_E_STACK_ARRAY_SD    EMAKEHR(0x1862)
#define VER_E_STACK_VALCLASS    EMAKEHR(0x1863)
#define VER_E_STACK_P_VALCLASS  EMAKEHR(0x1864)
#define VER_E_STACK_NO_VALCLASS EMAKEHR(0x1865)
#define VER_E_LOC_DEAD          EMAKEHR(0x1866)
#define VER_E_LOC_NUM           EMAKEHR(0x1867)
#define VER_E_ARG_NUM           EMAKEHR(0x1868)
#define VER_E_TOKEN_RESOLVE     EMAKEHR(0x1869)
#define VER_E_TOKEN_TYPE        EMAKEHR(0x186A)
#define VER_E_TOKEN_TYPE_MEMBER EMAKEHR(0x186B)
#define VER_E_TOKEN_TYPE_FIELD  EMAKEHR(0x186C)
#define VER_E_TOKEN_TYPE_SIG    EMAKEHR(0x186D)
#define VER_E_UNVERIFIABLE      EMAKEHR(0x186E)
#define VER_E_LDSTR_OPERAND     EMAKEHR(0x186F)
#define VER_E_RET_PTR_TO_STACK  EMAKEHR(0x1870)
#define VER_E_RET_VOID          EMAKEHR(0x1871)
#define VER_E_RET_MISSING       EMAKEHR(0x1872)
#define VER_E_RET_EMPTY         EMAKEHR(0x1873)
#define VER_E_RET_UNINIT        EMAKEHR(0x1874)
#define VER_E_ARRAY_ACCESS      EMAKEHR(0x1875)
#define VER_E_ARRAY_V_STORE     EMAKEHR(0x1876)
#define VER_E_ARRAY_SD          EMAKEHR(0x1877)
#define VER_E_ARRAY_SD_PTR      EMAKEHR(0x1878)
#define VER_E_ARRAY_FIELD       EMAKEHR(0x1879)
#define VER_E_ARGLIST           EMAKEHR(0x187A)
#define VER_E_VALCLASS          EMAKEHR(0x187B)
#define VER_E_METHOD_ACCESS     EMAKEHR(0x187C)
#define VER_E_FIELD_ACCESS      EMAKEHR(0x187D)
#define VER_E_DEAD              EMAKEHR(0x187E)
#define VER_E_FIELD_STATIC      EMAKEHR(0x187F)
#define VER_E_FIELD_NO_STATIC   EMAKEHR(0x1880)
#define VER_E_ADDR              EMAKEHR(0x1881)
#define VER_E_ADDR_BYREF        EMAKEHR(0x1882)
#define VER_E_ADDR_LITERAL      EMAKEHR(0x1883)
#define VER_E_INITONLY          EMAKEHR(0x1884)
#define VER_E_THROW             EMAKEHR(0x1885)
#define VER_E_CALLVIRT_VALCLASS EMAKEHR(0x1886)
#define VER_E_CALL_SIG          EMAKEHR(0x1887)
#define VER_E_CALL_STATIC       EMAKEHR(0x1888)
#define VER_E_CTOR              EMAKEHR(0x1889)
#define VER_E_CTOR_VIRT         EMAKEHR(0x188A)
#define VER_E_CTOR_OR_SUPER     EMAKEHR(0x188B)
#define VER_E_CTOR_MUL_INIT     EMAKEHR(0x188C)
#define VER_E_SIG               EMAKEHR(0x188D)
#define VER_E_SIG_ARRAY         EMAKEHR(0x188E)
#define VER_E_SIG_ARRAY_PTR     EMAKEHR(0x188F)
#define VER_E_SIG_ARRAY_BYREF   EMAKEHR(0x1890)
#define VER_E_SIG_ELEM_PTR      EMAKEHR(0x1891)
#define VER_E_SIG_VARARG        EMAKEHR(0x1892)
#define VER_E_SIG_VOID          EMAKEHR(0x1893)
#define VER_E_SIG_BYREF_BYREF   EMAKEHR(0x1894)
#define VER_E_CODE_SIZE_ZERO    EMAKEHR(0x1896)
#define VER_E_BAD_VARARG        EMAKEHR(0x1897)
#define VER_E_TAIL_CALL         EMAKEHR(0x1898)
#define VER_E_TAIL_BYREF        EMAKEHR(0x1899)
#define VER_E_TAIL_RET          EMAKEHR(0x189A)
#define VER_E_TAIL_RET_VOID     EMAKEHR(0x189B)
#define VER_E_TAIL_RET_TYPE     EMAKEHR(0x189C)
#define VER_E_TAIL_STACK_EMPTY  EMAKEHR(0x189D)
#define VER_E_METHOD_END        EMAKEHR(0x189E)
#define VER_E_BAD_BRANCH        EMAKEHR(0x189F)
#define VER_E_FIN_OVERLAP       EMAKEHR(0x18A0)
#define VER_E_LEXICAL_NESTING   EMAKEHR(0x18A1)
#define VER_E_VOLATILE          EMAKEHR(0x18A2)
#define VER_E_UNALIGNED         EMAKEHR(0x18A3)
#define VER_E_INNERMOST_FIRST   EMAKEHR(0x18A4)
#define VER_E_CALLI_VIRTUAL     EMAKEHR(0x18A5)
#define VER_E_CALL_ABSTRACT     EMAKEHR(0x18A6)
#define VER_E_STACK_UNEXP_ARRAY EMAKEHR(0x18A7)
#define VER_E_NOT_IN_GC_HEAP    EMAKEHR(0x18A8)
#define VER_E_TRY_N_EMPTY_STACK EMAKEHR(0x18A9)
#define VER_E_DLGT_CTOR         EMAKEHR(0x18AA)
#define VER_E_DLGT_BB           EMAKEHR(0x18AB)
#define VER_E_DLGT_PATTERN      EMAKEHR(0x18AC)
#define VER_E_DLGT_LDFTN        EMAKEHR(0x18AD)
#define VER_E_FTN_ABSTRACT      EMAKEHR(0x18AE)
#define VER_E_SIG_C_VC          EMAKEHR(0x18AF)
#define VER_E_SIG_VC_C          EMAKEHR(0x18B0)
#define VER_E_BOX_PTR_TO_STACK  EMAKEHR(0x18B1)
#define VER_E_SIG_BYREF_TB_AH   EMAKEHR(0x18B2)
#define VER_E_SIG_ARRAY_TB_AH   EMAKEHR(0x18B3)
#define VER_E_ENDFILTER_STACK   EMAKEHR(0x18B4)
#define VER_E_DLGT_SIG_I        EMAKEHR(0x18B5)
#define VER_E_DLGT_SIG_O        EMAKEHR(0x18B6)
#define VER_E_RA_PTR_TO_STACK   EMAKEHR(0x18B7)
#define VER_E_CATCH_VALUE_TYPE  EMAKEHR(0x18B8)
#define VER_E_FIL_PRECEED_HND   EMAKEHR(0x18B9)
#define VER_E_LDVIRTFTN_STATIC  EMAKEHR(0x18BA)
#define VER_E_CALLVIRT_STATIC   EMAKEHR(0x18BB)
#define VER_E_INITLOCALS        EMAKEHR(0x18BC)
#define VER_E_BR_TO_EXCEPTION   EMAKEHR(0x18BD)
#define VER_E_CALL_CTOR         EMAKEHR(0x18BE)

#define VER_E_BAD_PE            EMAKEHR(0x18F0)
#define VER_E_BAD_MD            EMAKEHR(0x18F1)
#define VER_E_BAD_APPDOMAIN     EMAKEHR(0x18F2)
#define VER_E_TYPELOAD          EMAKEHR(0x18F3)
#define VER_E_PE_LOAD           EMAKEHR(0x18F4)
#define VER_E_WRITE_RVA_STATIC  EMAKEHR(0x18F5)


//
// ATTENTION: Range 0x1900 - 0x1AFF is reserved for Framework errors
//            Range 0x1B00 - 0x1BFF is reserved for MD Validator errors (see above VLDTR_E_...)
//
#endif // __COMMON_LANGUAGE_RUNTIME_HRESULTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corhlpr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
 **                                                                        **
 ** Corhlpr.h - signature helpers.                                         **
 **                                                                        **
 ****************************************************************************/

#include "corhlpr.h"
#include <stdlib.h>

/*************************************************************************************
*
* get number of bytes consumed by one argument/return type
*
*************************************************************************************/

HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig, 
    ULONG       *pcbTotal)
{
    ULONG       cb;
    ULONG       cbTotal;
    CorElementType ulElementType;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iData;
    mdToken     tk;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    HRESULT     hr = NOERROR;

    _ASSERTE(pcbTotal);

    cbTotal = CorSigUncompressElementType(pbSig, &ulElementType);
    while (CorIsModifierElementType((CorElementType) ulElementType))
    {
        cbTotal += CorSigUncompressElementType(&pbSig[cbTotal], &ulElementType);
    }
    switch (ulElementType)
    {
        case ELEMENT_TYPE_SZARRAY:
		case 0x1e /* obsolete */:
            // skip over base type
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;
            break;

        case ELEMENT_TYPE_FNPTR:
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &callingconv);

            // remember number of bytes to represent the arg counts
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &cArg);

            // how many bytes to represent the return type
            IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
            cbTotal += cb;
    
            // loop through argument
            for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
            {
                IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }

            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // skip over base type
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;

            // Parse for the rank
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            // if rank == 0, we are done
            if (ulData == 0)
                break;

            // any size of dimension specified?
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);
            while (ulData--)
            {
                cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulTemp);
            }

            // any lower bound specified?
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            while (ulData--)
            {
                cbTotal += CorSigUncompressSignedInt(&pbSig[cbTotal], &iData);
            }

            break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
		case ELEMENT_TYPE_CMOD_REQD:
		case ELEMENT_TYPE_CMOD_OPT:
            // count the bytes for the token compression
            cbTotal += CorSigUncompressToken(&pbSig[cbTotal], &tk);
            if ( ulElementType == ELEMENT_TYPE_CMOD_REQD ||
		         ulElementType == ELEMENT_TYPE_CMOD_OPT)
            {
                // skip over base type
                IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }
            break;
        default:
            break;
    }

    *pcbTotal = cbTotal;
ErrExit:
    return hr;
}


//*****************************************************************************
// copy fixed part of VarArg signature to a buffer
//*****************************************************************************
HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of COM+ method signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob)                // [OUT] number of bytes written to the above output buffer
{
    HRESULT     hr = NOERROR;
    ULONG       cbCalling;
    ULONG       cbArgsNumber;           // number of bytes to store the original arg count
    ULONG       cbArgsNumberTemp;       // number of bytes to store the fixed arg count
    ULONG       cbTotal = 0;            // total of number bytes for return type + all fixed arguments
    ULONG       cbCur = 0;              // index through the pvSigBlob
    ULONG       cb;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    CorElementType ulElementType;
    BYTE        *pbSig;

    _ASSERTE (pvSigBlob && pcbSigBlob);

    // remember the number of bytes to represent the calling convention
    cbCalling = CorSigUncompressData (pvSigBlob, &callingconv);
    _ASSERTE (isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_VARARG));
    cbCur += cbCalling;

    // remember number of bytes to represent the arg counts
    cbArgsNumber= CorSigUncompressData (&pvSigBlob[cbCur], &cArg);
    cbCur += cbArgsNumber;

    // how many bytes to represent the return type
    IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
    cbCur += cb;
    cbTotal += cb;
    
    // loop through argument until we found ELEMENT_TYPE_SENTINEL or run
    // out of arguments
    for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
    {
        _ASSERTE(cbCur < cbSigBlob);

        // peak the outter most ELEMENT_TYPE_*
        CorSigUncompressElementType (&pvSigBlob[cbCur], &ulElementType);
        if (ulElementType == ELEMENT_TYPE_SENTINEL)
            break;
        IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
        cbTotal += cb;
        cbCur += cb;
    }

    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &cArg);

    // now cbCalling : the number of bytes needed to store the calling convention
    // cbArgNumberTemp : number of bytes to store the fixed arg count
    // cbTotal : the number of bytes to store the ret and fixed arguments

    *pcbSigBlob = cbCalling + cbArgsNumberTemp + cbTotal;

    // resize the buffer
    IfFailGo( pqbSig->ReSize(*pcbSigBlob) );
    pbSig = (BYTE *)pqbSig->Ptr();

    // copy over the calling convention
    cb = CorSigCompressData(callingconv, pbSig);

    // copy over the fixed arg count
    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &pbSig[cb]);

    // copy over the fixed args + ret type
    memcpy(&pbSig[cb + cbArgsNumberTemp], &pvSigBlob[cbCalling + cbArgsNumber], cbTotal);

ErrExit:
    return hr;
}





//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************

extern "C" {

/***************************************************************************/
/* Note that this construtor does not set the LocalSig, but has the
   advantage that it does not have any dependancy on EE structures.
   inside the EE use the FunctionDesc constructor */

void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header) 
{
    memset(pThis, 0, sizeof(COR_ILMETHOD_DECODER));
    if (header->Tiny.IsTiny()) {
        ((COR_ILMETHOD_DECODER*)pThis)->MaxStack = header->Tiny.GetMaxStack();
        ((COR_ILMETHOD_DECODER*)pThis)->Code = header->Tiny.GetCode();
        ((COR_ILMETHOD_DECODER*)pThis)->CodeSize = header->Tiny.GetCodeSize();
        ((COR_ILMETHOD_DECODER*)pThis)->Flags |= CorILMethod_TinyFormat;
        return;
    }
    if (header->Fat.IsFat()) {
        _ASSERTE((((size_t) header) & 3) == 0);        // header is aligned
        *((COR_ILMETHOD_FAT*) pThis) = header->Fat;
        ((COR_ILMETHOD_DECODER*)pThis)->Code = header->Fat.GetCode();
        _ASSERTE(header->Fat.Size >= 3);        // Size if valid
        ((COR_ILMETHOD_DECODER*)pThis)->Sect = header->Fat.GetSect();
        if (((COR_ILMETHOD_DECODER*)pThis)->Sect != 0 && ((COR_ILMETHOD_DECODER*)pThis)->Sect->Kind() == CorILMethod_Sect_EHTable) {
            ((COR_ILMETHOD_DECODER*)pThis)->EH = (COR_ILMETHOD_SECT_EH*) ((COR_ILMETHOD_DECODER*)pThis)->Sect;
            ((COR_ILMETHOD_DECODER*)pThis)->Sect = ((COR_ILMETHOD_DECODER*)pThis)->Sect->Next();
        }
        return;
    }
    // so we don't asert on trash  _ASSERTE(!"Unknown format");
}

// Calculate the total method size. First get address of end of code. If there are no sections, then
// the end of code addr marks end of COR_ILMETHOD. Otherwise find addr of end of last section and use it
// to mark end of COR_ILMETHD. Assumes that the code is directly followed
// by each section in the on-disk format
int __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header)
{
    BYTE *lastAddr = (BYTE*)((COR_ILMETHOD_DECODER*)pThis)->Code + ((COR_ILMETHOD_DECODER*)pThis)->CodeSize;    // addr of end of code
    const COR_ILMETHOD_SECT *sect = ((COR_ILMETHOD_DECODER*)pThis)->EH;
	if (sect != 0 && sect->Next() == 0)
		lastAddr = (BYTE *)(&sect->Data()[sect->DataSize()]);
	else
	{
		const COR_ILMETHOD_SECT *nextSect;
		for (sect = ((COR_ILMETHOD_DECODER*)pThis)->Sect; 
			 sect; sect = nextSect) {
			nextSect = sect->Next();
			if (nextSect == 0) {
				// sect points to the last section, so set lastAddr
				lastAddr = (BYTE *)(&sect->Data()[sect->DataSize()]);
				break;
			}
		}
    }
    return (int)(lastAddr - (BYTE*)header);
}

/*********************************************************************/
/* APIs for emitting sections etc */

unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL moreSections)
{
    if (header->MaxStack <= 8 && (header->Flags & ~CorILMethod_FormatMask) == 0
        && header->LocalVarSigTok == 0 && header->CodeSize < 64 && !moreSections)
        return(sizeof(COR_ILMETHOD_TINY));

    return(sizeof(COR_ILMETHOD_FAT));
}

/*********************************************************************/
        // emit the header (bestFormat) return amount emitted   
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header, 
                  BOOL moreSections, BYTE* outBuff)
{
    BYTE* origBuff = outBuff;
    if (size == 1) {
            // Tiny format
        *outBuff++ = (BYTE) (CorILMethod_TinyFormat | (header->CodeSize << 2));
    }
    else {
            // Fat format
        _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
        COR_ILMETHOD_FAT* fatHeader = (COR_ILMETHOD_FAT*) outBuff;
        outBuff += sizeof(COR_ILMETHOD_FAT);
        *fatHeader = *header;
        fatHeader->Flags |= CorILMethod_FatFormat;
        _ASSERTE((fatHeader->Flags & CorILMethod_FormatMask) == CorILMethod_FatFormat);
        if (moreSections)
            fatHeader->Flags |= CorILMethod_MoreSects;
        fatHeader->Size = sizeof(COR_ILMETHOD_FAT) / 4;
    }
    _ASSERTE(&origBuff[size] == outBuff);
    return(size);
}

/*********************************************************************/
/* static */
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff)
{    
    if (((COR_ILMETHOD_SECT_EH *)pSectEH)->IsFat()) 
        return(&(((COR_ILMETHOD_SECT_EH *)pSectEH)->Fat.Clauses[idx])); 

    // mask to remove sign extension - cast just wouldn't work 
    buff->Flags         = (CorExceptionFlag)((((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].Flags)&0x0000ffff); 
    buff->ClassToken    = ((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].ClassToken;    
    buff->TryOffset     = ((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].TryOffset;   
    buff->TryLength     = ((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].TryLength; 
    buff->HandlerLength = ((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].HandlerLength;
    buff->HandlerOffset = ((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx].HandlerOffset; 
    return(buff);   
}   
/*********************************************************************/
        // compute the size of the section (best format)    
        // codeSize is the size of the method   
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize)
{
    return((ehCount)? SectEH_SizeWorst(ehCount) : 0);
}

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount)
{
    return((ehCount)? (COR_ILMETHOD_SECT_EH_FAT::Size(ehCount)) : 0);
}

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
{
    if (ehCount == 0)
        return(0);

    unsigned smallSize = COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount);
    if (smallSize > COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE)
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
    for (unsigned i = 0; i < ehCount; i++) {
        if (clauses[i].TryOffset > 0xFFFF ||
                clauses[i].TryLength > 0xFF ||
                clauses[i].HandlerOffset > 0xFFFF ||
                clauses[i].HandlerLength > 0xFF) {
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
        }
    }
    return smallSize;
}

/*********************************************************************/

        // emit the section (best format);  
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,   
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,   
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets)
{
    if (size == 0)
       return(0);

    _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
    BYTE* origBuff = outBuff;
    if (ehCount <= 0)
        return 0;

    // Initialize the ehTypeOffsets array.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++)
            ehTypeOffsets[i] = -1;
    }

    if (COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount) < COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE) {
        COR_ILMETHOD_SECT_EH_SMALL* EHSect = (COR_ILMETHOD_SECT_EH_SMALL*) outBuff;
        for (unsigned i = 0; i < ehCount; i++) {
            if (clauses[i].TryOffset > 0xFFFF ||
                    clauses[i].TryLength > 0xFF ||
                    clauses[i].HandlerOffset > 0xFFFF ||
                    clauses[i].HandlerLength > 0xFF) {
                break;  // fall through and generate as FAT
            }
            _ASSERTE((clauses[i].Flags & ~0xFFFF) == 0);
            _ASSERTE((clauses[i].TryOffset & ~0xFFFF) == 0);
            _ASSERTE((clauses[i].TryLength & ~0xFF) == 0);
            _ASSERTE((clauses[i].HandlerOffset & ~0xFFFF) == 0);
            _ASSERTE((clauses[i].HandlerLength & ~0xFF) == 0);
            EHSect->Clauses[i].Flags         = (CorExceptionFlag) clauses[i].Flags;
            EHSect->Clauses[i].TryOffset     = (WORD) clauses[i].TryOffset;
            EHSect->Clauses[i].TryLength     = (WORD) clauses[i].TryLength;
            EHSect->Clauses[i].HandlerOffset = (WORD) clauses[i].HandlerOffset;
            EHSect->Clauses[i].HandlerLength = (WORD) clauses[i].HandlerLength;
            EHSect->Clauses[i].ClassToken    = clauses[i].ClassToken;
        }
        if (i >= ehCount) {
            // if actually got through all the clauses and they are small enough
            EHSect->Kind = CorILMethod_Sect_EHTable;
            EHSect->Reserved = 0;
            if (moreSections)
                EHSect->Kind |= CorILMethod_Sect_MoreSects;
            EHSect->DataSize = EHSect->Size(ehCount);
            _ASSERTE(EHSect->DataSize == EHSect->Size(ehCount)); // make sure didn't overflow
            outBuff = (BYTE*) &EHSect->Clauses[ehCount];
            // Set the offsets for the exception type tokens.
            if (ehTypeOffsets)
            {
                for (unsigned int i = 0; i < ehCount; i++) {
                    if (EHSect->Clauses[i].Flags == COR_ILEXCEPTION_CLAUSE_NONE)
                    {
                        _ASSERTE(! IsNilToken(EHSect->Clauses[i].ClassToken));
                        ehTypeOffsets[i] = (ULONG)((BYTE *)&EHSect->Clauses[i].ClassToken - origBuff);
                    }
                }
            }
            return(size);
        }
    }
    // either total size too big or one of constituent elements too big (eg. offset or length)
    COR_ILMETHOD_SECT_EH_FAT* EHSect = (COR_ILMETHOD_SECT_EH_FAT*) outBuff;
    EHSect->Kind = CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat;
    if (moreSections)
        EHSect->Kind |= CorILMethod_Sect_MoreSects;
    EHSect->DataSize = EHSect->Size(ehCount);
    memcpy(EHSect->Clauses, clauses, ehCount * sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    outBuff = (BYTE*) &EHSect->Clauses[ehCount];
    _ASSERTE(&origBuff[size] == outBuff);
    // Set the offsets for the exception type tokens.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++) {
            if (EHSect->Clauses[i].Flags == COR_ILEXCEPTION_CLAUSE_NONE)
            {
                _ASSERTE(! IsNilToken(EHSect->Clauses[i].ClassToken));
                ehTypeOffsets[i] = (ULONG)((BYTE *)&EHSect->Clauses[i].ClassToken - origBuff);
            }
        }
    }
    return(size);
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cordebug_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:08 2003
 */
/* Compiler settings for cordebug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "cordebug.h"

#define TYPE_FORMAT_STRING_SIZE   4555                              
#define PROC_FORMAT_STRING_SIZE   7845                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugManagedCallback_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugManagedCallback_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugUnmanagedCallback_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugUnmanagedCallback_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugController_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugController_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugAppDomain_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugAppDomain_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugAssembly_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugAssembly_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugProcess_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugProcess_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugBreakpoint_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugBreakpoint_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugFunctionBreakpoint_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugFunctionBreakpoint_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugModuleBreakpoint_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugModuleBreakpoint_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugValueBreakpoint_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugValueBreakpoint_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugStepper_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugStepper_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugRegisterSet_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugRegisterSet_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugThread_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugThread_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugChain_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugChain_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugFrame_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugFrame_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugILFrame_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugILFrame_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugNativeFrame_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugNativeFrame_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugModule_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugModule_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugFunction_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugFunction_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugCode_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugCode_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugClass_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugClass_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugEval_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugEval_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugReferenceValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugReferenceValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugHeapValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugHeapValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugObjectValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugObjectValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugBoxValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugBoxValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugStringValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugStringValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugArrayValue_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugArrayValue_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugContext_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugContext_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugObjectEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugObjectEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugBreakpointEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugBreakpointEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugStepperEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugStepperEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugProcessEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugProcessEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugThreadEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugThreadEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugFrameEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugFrameEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugChainEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugChainEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugModuleEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugModuleEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugValueEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugValueEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugErrorInfoEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugErrorInfoEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugAppDomainEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugAppDomainEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugAssemblyEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugAssemblyEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugEditAndContinueErrorInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugEditAndContinueErrorInfo_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorDebugEditAndContinueSnapshot_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorDebugEditAndContinueSnapshot_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Breakpoint */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAppDomain */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter pThread */

/* 22 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pBreakpoint */

/* 28 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure StepComplete */

/* 40 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 50 */	NdrFcShort( 0x6 ),	/* 6 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pAppDomain */

/* 56 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 58 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 60 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pThread */

/* 62 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 64 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 66 */	NdrFcShort( 0x4a ),	/* Type Offset=74 */

	/* Parameter pStepper */

/* 68 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 70 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 72 */	NdrFcShort( 0x5c ),	/* Type Offset=92 */

	/* Parameter reason */

/* 74 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 76 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 78 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 80 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 82 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 84 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Break */

/* 86 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 88 */	NdrFcLong( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x5 ),	/* 5 */
/* 94 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x8 ),	/* 8 */
/* 100 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 102 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 106 */	NdrFcShort( 0x6e ),	/* Type Offset=110 */

	/* Parameter thread */

/* 108 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 112 */	NdrFcShort( 0x80 ),	/* Type Offset=128 */

	/* Return value */

/* 114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Exception */

/* 120 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 122 */	NdrFcLong( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x6 ),	/* 6 */
/* 128 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	NdrFcShort( 0x8 ),	/* 8 */
/* 134 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAppDomain */

/* 136 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 140 */	NdrFcShort( 0x92 ),	/* Type Offset=146 */

	/* Parameter pThread */

/* 142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 146 */	NdrFcShort( 0xa4 ),	/* Type Offset=164 */

	/* Parameter unhandled */

/* 148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EvalComplete */

/* 160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x7 ),	/* 7 */
/* 168 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 174 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAppDomain */

/* 176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 180 */	NdrFcShort( 0xb6 ),	/* Type Offset=182 */

	/* Parameter pThread */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 186 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */

	/* Parameter pEval */

/* 188 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 190 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 192 */	NdrFcShort( 0xda ),	/* Type Offset=218 */

	/* Return value */

/* 194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 196 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EvalException */

/* 200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 214 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAppDomain */

/* 216 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 220 */	NdrFcShort( 0xec ),	/* Type Offset=236 */

	/* Parameter pThread */

/* 222 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 224 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 226 */	NdrFcShort( 0xfe ),	/* Type Offset=254 */

	/* Parameter pEval */

/* 228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 230 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 232 */	NdrFcShort( 0x110 ),	/* Type Offset=272 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateProcess */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0x9 ),	/* 9 */
/* 248 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 256 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 258 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 260 */	NdrFcShort( 0x122 ),	/* Type Offset=290 */

	/* Return value */

/* 262 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 264 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExitProcess */

/* 268 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0xa ),	/* 10 */
/* 276 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 282 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 284 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 286 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 288 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Return value */

/* 290 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 292 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 294 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateThread */

/* 296 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 298 */	NdrFcLong( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0xb ),	/* 11 */
/* 304 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 310 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 312 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 314 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 316 */	NdrFcShort( 0x146 ),	/* Type Offset=326 */

	/* Parameter thread */

/* 318 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 320 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 322 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Return value */

/* 324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 326 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExitThread */

/* 330 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0xc ),	/* 12 */
/* 338 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 346 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 350 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter thread */

/* 352 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 356 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Return value */

/* 358 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 360 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadModule */

/* 364 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 366 */	NdrFcLong( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0xd ),	/* 13 */
/* 372 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 380 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 384 */	NdrFcShort( 0x18e ),	/* Type Offset=398 */

	/* Parameter pModule */

/* 386 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 388 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 390 */	NdrFcShort( 0x1a0 ),	/* Type Offset=416 */

	/* Return value */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnloadModule */

/* 398 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0xe ),	/* 14 */
/* 406 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x8 ),	/* 8 */
/* 412 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 414 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 416 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 418 */	NdrFcShort( 0x1b2 ),	/* Type Offset=434 */

	/* Parameter pModule */

/* 420 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 422 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 424 */	NdrFcShort( 0x1c4 ),	/* Type Offset=452 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadClass */

/* 432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0xf ),	/* 15 */
/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 448 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 450 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 452 */	NdrFcShort( 0x1d6 ),	/* Type Offset=470 */

	/* Parameter c */

/* 454 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 456 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 458 */	NdrFcShort( 0x1e8 ),	/* Type Offset=488 */

	/* Return value */

/* 460 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 462 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnloadClass */

/* 466 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 468 */	NdrFcLong( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x10 ),	/* 16 */
/* 474 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x8 ),	/* 8 */
/* 480 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 482 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 484 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 486 */	NdrFcShort( 0x1fa ),	/* Type Offset=506 */

	/* Parameter c */

/* 488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 490 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 492 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Return value */

/* 494 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 496 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DebuggerError */

/* 500 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 502 */	NdrFcLong( 0x0 ),	/* 0 */
/* 506 */	NdrFcShort( 0x11 ),	/* 17 */
/* 508 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 512 */	NdrFcShort( 0x8 ),	/* 8 */
/* 514 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pProcess */

/* 516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 520 */	NdrFcShort( 0x21e ),	/* Type Offset=542 */

	/* Parameter errorHR */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 524 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter errorCode */

/* 528 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 530 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LogMessage */

/* 540 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x12 ),	/* 18 */
/* 548 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 550 */	NdrFcShort( 0x3c ),	/* 60 */
/* 552 */	NdrFcShort( 0x8 ),	/* 8 */
/* 554 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pAppDomain */

/* 556 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 558 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 560 */	NdrFcShort( 0x230 ),	/* Type Offset=560 */

	/* Parameter pThread */

/* 562 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 564 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 566 */	NdrFcShort( 0x242 ),	/* Type Offset=578 */

	/* Parameter lLevel */

/* 568 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 572 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pLogSwitchName */

/* 574 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 576 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 578 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pMessage */

/* 580 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 582 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 584 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Return value */

/* 586 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 588 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LogSwitch */

/* 592 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 594 */	NdrFcLong( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x13 ),	/* 19 */
/* 600 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 602 */	NdrFcShort( 0x44 ),	/* 68 */
/* 604 */	NdrFcShort( 0x8 ),	/* 8 */
/* 606 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter pAppDomain */

/* 608 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 610 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 612 */	NdrFcShort( 0x25c ),	/* Type Offset=604 */

	/* Parameter pThread */

/* 614 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 616 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 618 */	NdrFcShort( 0x26e ),	/* Type Offset=622 */

	/* Parameter lLevel */

/* 620 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 622 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulReason */

/* 626 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 630 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pLogSwitchName */

/* 632 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 634 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 636 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pParentName */

/* 638 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 640 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 642 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Return value */

/* 644 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 646 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 648 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateAppDomain */

/* 650 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 652 */	NdrFcLong( 0x0 ),	/* 0 */
/* 656 */	NdrFcShort( 0x14 ),	/* 20 */
/* 658 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x8 ),	/* 8 */
/* 664 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pProcess */

/* 666 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 668 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 670 */	NdrFcShort( 0x288 ),	/* Type Offset=648 */

	/* Parameter pAppDomain */

/* 672 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 674 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 676 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 678 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 680 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExitAppDomain */

/* 684 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 686 */	NdrFcLong( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x15 ),	/* 21 */
/* 692 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x8 ),	/* 8 */
/* 698 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pProcess */

/* 700 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 702 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 704 */	NdrFcShort( 0x2ac ),	/* Type Offset=684 */

	/* Parameter pAppDomain */

/* 706 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 708 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 710 */	NdrFcShort( 0x2be ),	/* Type Offset=702 */

	/* Return value */

/* 712 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 714 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadAssembly */

/* 718 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 720 */	NdrFcLong( 0x0 ),	/* 0 */
/* 724 */	NdrFcShort( 0x16 ),	/* 22 */
/* 726 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 732 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 734 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 736 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 738 */	NdrFcShort( 0x2d0 ),	/* Type Offset=720 */

	/* Parameter pAssembly */

/* 740 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 742 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 744 */	NdrFcShort( 0x2e2 ),	/* Type Offset=738 */

	/* Return value */

/* 746 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 748 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 750 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnloadAssembly */

/* 752 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 754 */	NdrFcLong( 0x0 ),	/* 0 */
/* 758 */	NdrFcShort( 0x17 ),	/* 23 */
/* 760 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0x8 ),	/* 8 */
/* 766 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 768 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 770 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 772 */	NdrFcShort( 0x2f4 ),	/* Type Offset=756 */

	/* Parameter pAssembly */

/* 774 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 776 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 778 */	NdrFcShort( 0x306 ),	/* Type Offset=774 */

	/* Return value */

/* 780 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 782 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ControlCTrap */

/* 786 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 788 */	NdrFcLong( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0x18 ),	/* 24 */
/* 794 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 802 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 804 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 806 */	NdrFcShort( 0x318 ),	/* Type Offset=792 */

	/* Return value */

/* 808 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 810 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 812 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NameChange */

/* 814 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 816 */	NdrFcLong( 0x0 ),	/* 0 */
/* 820 */	NdrFcShort( 0x19 ),	/* 25 */
/* 822 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAppDomain */

/* 830 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 832 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 834 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Parameter pThread */

/* 836 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 838 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 840 */	NdrFcShort( 0x33c ),	/* Type Offset=828 */

	/* Return value */

/* 842 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 844 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 846 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateModuleSymbols */

/* 848 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 850 */	NdrFcLong( 0x0 ),	/* 0 */
/* 854 */	NdrFcShort( 0x1a ),	/* 26 */
/* 856 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x8 ),	/* 8 */
/* 862 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAppDomain */

/* 864 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 866 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 868 */	NdrFcShort( 0x34e ),	/* Type Offset=846 */

	/* Parameter pModule */

/* 870 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 872 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 874 */	NdrFcShort( 0x360 ),	/* Type Offset=864 */

	/* Parameter pSymbolStream */

/* 876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 878 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 880 */	NdrFcShort( 0x372 ),	/* Type Offset=882 */

	/* Return value */

/* 882 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 884 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EditAndContinueRemap */

/* 888 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0x1b ),	/* 27 */
/* 896 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 902 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pAppDomain */

/* 904 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 906 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 908 */	NdrFcShort( 0x384 ),	/* Type Offset=900 */

	/* Parameter pThread */

/* 910 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 912 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 914 */	NdrFcShort( 0x396 ),	/* Type Offset=918 */

	/* Parameter pFunction */

/* 916 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 918 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 920 */	NdrFcShort( 0x3a8 ),	/* Type Offset=936 */

	/* Parameter fAccurate */

/* 922 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 924 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 928 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 930 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 932 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BreakpointSetError */

/* 934 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 936 */	NdrFcLong( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x1c ),	/* 28 */
/* 942 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 944 */	NdrFcShort( 0x8 ),	/* 8 */
/* 946 */	NdrFcShort( 0x8 ),	/* 8 */
/* 948 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pAppDomain */

/* 950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 952 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 954 */	NdrFcShort( 0x3ba ),	/* Type Offset=954 */

	/* Parameter pThread */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 960 */	NdrFcShort( 0x3cc ),	/* Type Offset=972 */

	/* Parameter pBreakpoint */

/* 962 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 964 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 966 */	NdrFcShort( 0x3de ),	/* Type Offset=990 */

	/* Parameter dwError */

/* 968 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 970 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 972 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 976 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DebugEvent */

/* 980 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x3 ),	/* 3 */
/* 988 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 990 */	NdrFcShort( 0x10 ),	/* 16 */
/* 992 */	NdrFcShort( 0x8 ),	/* 8 */
/* 994 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pDebugEvent */

/* 996 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 998 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1000 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fOutOfBand */

/* 1002 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1004 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1008 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1010 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1012 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stop */

/* 1014 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1016 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1020 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1022 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1024 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1026 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1028 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter dwTimeout */

/* 1030 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1032 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1036 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1038 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1040 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Continue */

/* 1042 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1044 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1050 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1052 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1056 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter fIsOutOfBand */

/* 1058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1064 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsRunning */

/* 1070 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1072 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1076 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1078 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1082 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1084 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbRunning */

/* 1086 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1088 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1092 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1094 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure HasQueuedCallbacks */

/* 1098 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1100 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1106 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1112 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pThread */

/* 1114 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1116 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1118 */	NdrFcShort( 0x3f4 ),	/* Type Offset=1012 */

	/* Parameter pbQueued */

/* 1120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1122 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1128 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateThreads */

/* 1132 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1138 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1140 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1146 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppThreads */

/* 1148 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1150 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1152 */	NdrFcShort( 0x40a ),	/* Type Offset=1034 */

	/* Return value */

/* 1154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1156 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetAllThreadsDebugState */

/* 1160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1168 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1170 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1174 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter state */

/* 1176 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1180 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter pExceptThisThread */

/* 1182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1186 */	NdrFcShort( 0x420 ),	/* Type Offset=1056 */

	/* Return value */

/* 1188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1190 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Detach */

/* 1194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1200 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1202 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1208 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 1210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1212 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Terminate */

/* 1216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1222 */	NdrFcShort( 0xa ),	/* 10 */
/* 1224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1230 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter exitCode */

/* 1232 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1236 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanCommitChanges */

/* 1244 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1246 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0xb ),	/* 11 */
/* 1252 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1258 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter cSnapshots */

/* 1260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pSnapshots */

/* 1266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1270 */	NdrFcShort( 0x444 ),	/* Type Offset=1092 */

	/* Parameter pError */

/* 1272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1276 */	NdrFcShort( 0x456 ),	/* Type Offset=1110 */

	/* Return value */

/* 1278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CommitChanges */

/* 1284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1290 */	NdrFcShort( 0xc ),	/* 12 */
/* 1292 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1296 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1298 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter cSnapshots */

/* 1300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pSnapshots */

/* 1306 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1310 */	NdrFcShort( 0x47e ),	/* Type Offset=1150 */

	/* Parameter pError */

/* 1312 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1316 */	NdrFcShort( 0x490 ),	/* Type Offset=1168 */

	/* Return value */

/* 1318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1320 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 1324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1330 */	NdrFcShort( 0xd ),	/* 13 */
/* 1332 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1338 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProcess */

/* 1340 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1342 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1344 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 1346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1348 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateAssemblies */

/* 1352 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0xe ),	/* 14 */
/* 1360 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1364 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1366 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAssemblies */

/* 1368 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1372 */	NdrFcShort( 0x4bc ),	/* Type Offset=1212 */

	/* Return value */

/* 1374 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModuleFromMetaDataInterface */

/* 1380 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1382 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1386 */	NdrFcShort( 0xf ),	/* 15 */
/* 1388 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1394 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pIMetaData */

/* 1396 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1398 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1400 */	NdrFcShort( 0x4d2 ),	/* Type Offset=1234 */

	/* Parameter ppModule */

/* 1402 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1404 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1406 */	NdrFcShort( 0x4e4 ),	/* Type Offset=1252 */

	/* Return value */

/* 1408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1410 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateBreakpoints */

/* 1414 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1426 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1428 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBreakpoints */

/* 1430 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1432 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1434 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Return value */

/* 1436 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1438 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateSteppers */

/* 1442 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1448 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1450 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1454 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1456 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppSteppers */

/* 1458 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1460 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1462 */	NdrFcShort( 0x510 ),	/* Type Offset=1296 */

	/* Return value */

/* 1464 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1466 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsAttached */

/* 1470 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1472 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1476 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1478 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1484 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbAttached */

/* 1486 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1488 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1492 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1494 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1496 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 1498 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1500 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1506 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1510 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1512 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 1514 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1516 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 1520 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1522 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 1526 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1528 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1530 */	NdrFcShort( 0x52e ),	/* Type Offset=1326 */

	/* Return value */

/* 1532 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1534 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetObject */

/* 1538 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1540 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1544 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1546 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1548 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1550 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1552 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObject */

/* 1554 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1556 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1558 */	NdrFcShort( 0x53c ),	/* Type Offset=1340 */

	/* Return value */

/* 1560 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1562 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1564 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Attach */

/* 1566 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1568 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1572 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1574 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1578 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1580 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 1582 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1584 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1586 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetID */

/* 1588 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1590 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1596 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1600 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1602 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pId */

/* 1604 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1606 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1610 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1612 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1614 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 1616 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1618 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1624 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1626 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1628 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1630 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProcess */

/* 1632 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1634 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1636 */	NdrFcShort( 0x556 ),	/* Type Offset=1366 */

	/* Return value */

/* 1638 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1640 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAppDomain */

/* 1644 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1646 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1650 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1652 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1656 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1658 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAppDomain */

/* 1660 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1664 */	NdrFcShort( 0x56c ),	/* Type Offset=1388 */

	/* Return value */

/* 1666 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1670 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateModules */

/* 1672 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1674 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1678 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1680 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1682 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1684 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1686 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppModules */

/* 1688 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1690 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1692 */	NdrFcShort( 0x582 ),	/* Type Offset=1410 */

	/* Return value */

/* 1694 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1696 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCodeBase */

/* 1700 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1702 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1706 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1708 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1710 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1712 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1714 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 1716 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1718 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 1722 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1724 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 1728 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1730 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1732 */	NdrFcShort( 0x59c ),	/* Type Offset=1436 */

	/* Return value */

/* 1734 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1736 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 1740 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1742 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1746 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1748 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1752 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1754 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 1756 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1758 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1760 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 1762 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1764 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1766 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 1768 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1770 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1772 */	NdrFcShort( 0x5ae ),	/* Type Offset=1454 */

	/* Return value */

/* 1774 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1776 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetID */

/* 1780 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1782 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1786 */	NdrFcShort( 0xd ),	/* 13 */
/* 1788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1792 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1794 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwProcessId */

/* 1796 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1798 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1800 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1802 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1804 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1806 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHandle */

/* 1808 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1810 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1814 */	NdrFcShort( 0xe ),	/* 14 */
/* 1816 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1820 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1822 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter phProcessHandle */

/* 1824 */	NdrFcShort( 0x2112 ),	/* Flags:  must free, out, simple ref, srv alloc size=8 */
/* 1826 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1828 */	NdrFcShort( 0x5c6 ),	/* Type Offset=1478 */

	/* Return value */

/* 1830 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1832 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThread */

/* 1836 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1838 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0xf ),	/* 15 */
/* 1844 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1846 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1848 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1850 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwThreadId */

/* 1852 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1856 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppThread */

/* 1858 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1862 */	NdrFcShort( 0x5d0 ),	/* Type Offset=1488 */

	/* Return value */

/* 1864 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1866 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateObjects */

/* 1870 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1872 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1876 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1878 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1882 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1884 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObjects */

/* 1886 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1888 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1890 */	NdrFcShort( 0x5e6 ),	/* Type Offset=1510 */

	/* Return value */

/* 1892 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1894 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1896 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsTransitionStub */

/* 1898 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1900 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1906 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1908 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1910 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1912 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter address */

/* 1914 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1916 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1918 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pbTransitionStub */

/* 1920 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1922 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1924 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1926 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1928 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1930 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsOSSuspended */

/* 1932 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1934 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1938 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1940 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1944 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1946 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter threadID */

/* 1948 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1950 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbSuspended */

/* 1954 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1956 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1962 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThreadContext */

/* 1966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1972 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1974 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1976 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1978 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1980 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter threadID */

/* 1982 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1984 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1986 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter contextSize */

/* 1988 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1990 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1992 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter context */

/* 1994 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1996 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1998 */	NdrFcShort( 0x604 ),	/* Type Offset=1540 */

	/* Return value */

/* 2000 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2002 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2004 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetThreadContext */

/* 2006 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2008 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x14 ),	/* 20 */
/* 2014 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2016 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2020 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter threadID */

/* 2022 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2024 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter contextSize */

/* 2028 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2030 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2032 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter context */

/* 2034 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2036 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2038 */	NdrFcShort( 0x612 ),	/* Type Offset=1554 */

	/* Return value */

/* 2040 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2042 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2044 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadMemory */

/* 2046 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2048 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2052 */	NdrFcShort( 0x15 ),	/* 21 */
/* 2054 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2056 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2058 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2060 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter address */

/* 2062 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2064 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2066 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter size */

/* 2068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2070 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter buffer */

/* 2074 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2076 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2078 */	NdrFcShort( 0x620 ),	/* Type Offset=1568 */

	/* Parameter read */

/* 2080 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2082 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteMemory */

/* 2092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x16 ),	/* 22 */
/* 2100 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2102 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2104 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2106 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter address */

/* 2108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2112 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter size */

/* 2114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter buffer */

/* 2120 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2122 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2124 */	NdrFcShort( 0x632 ),	/* Type Offset=1586 */

	/* Parameter written */

/* 2126 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2128 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2134 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearCurrentException */

/* 2138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2144 */	NdrFcShort( 0x17 ),	/* 23 */
/* 2146 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2152 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter threadID */

/* 2154 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2156 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2160 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2162 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnableLogMessages */

/* 2166 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2168 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2172 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2174 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2176 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter fOnOff */

/* 2182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ModifyLogSwitch */

/* 2194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x19 ),	/* 25 */
/* 2202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2204 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2208 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pLogSwitchName */

/* 2210 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2212 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2214 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter lLevel */

/* 2216 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2218 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateAppDomains */

/* 2228 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2230 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x1a ),	/* 26 */
/* 2236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2242 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAppDomains */

/* 2244 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2248 */	NdrFcShort( 0x644 ),	/* Type Offset=1604 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetObject */

/* 2256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x1b ),	/* 27 */
/* 2264 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2268 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2270 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObject */

/* 2272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2276 */	NdrFcShort( 0x65a ),	/* Type Offset=1626 */

	/* Return value */

/* 2278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ThreadForFiberCookie */

/* 2284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2292 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2296 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2298 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter fiberCookie */

/* 2300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppThread */

/* 2306 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2310 */	NdrFcShort( 0x670 ),	/* Type Offset=1648 */

	/* Return value */

/* 2312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHelperThreadID */

/* 2318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2324 */	NdrFcShort( 0x1d ),	/* 29 */
/* 2326 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2330 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2332 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pThreadID */

/* 2334 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2336 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2342 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Activate */

/* 2346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2352 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2354 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2358 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2360 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bActive */

/* 2362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2364 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2368 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsActive */

/* 2374 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2380 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2386 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2388 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbActive */

/* 2390 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunction */

/* 2402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2410 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2416 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFunction */

/* 2418 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2420 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2422 */	NdrFcShort( 0x68e ),	/* Type Offset=1678 */

	/* Return value */

/* 2424 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2426 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOffset */

/* 2430 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2436 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2438 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2442 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2444 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnOffset */

/* 2446 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2448 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2454 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModule */

/* 2458 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2464 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2466 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2472 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppModule */

/* 2474 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2478 */	NdrFcShort( 0x6a8 ),	/* Type Offset=1704 */

	/* Return value */

/* 2480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetValue */

/* 2486 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2492 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2494 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2496 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2498 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2500 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppValue */

/* 2502 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2504 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2506 */	NdrFcShort( 0x6be ),	/* Type Offset=1726 */

	/* Return value */

/* 2508 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2510 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2512 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsActive */

/* 2514 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2516 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2520 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2522 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2526 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2528 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbActive */

/* 2530 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2532 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2534 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2536 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2538 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Deactivate */

/* 2542 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2544 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2548 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2550 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2554 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2556 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2560 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetInterceptMask */

/* 2564 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2570 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2574 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2578 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter mask */

/* 2580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2582 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2584 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 2586 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2588 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetUnmappedStopMask */

/* 2592 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2594 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2598 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2600 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2602 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2604 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2606 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter mask */

/* 2608 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2610 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2612 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 2614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2616 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Step */

/* 2620 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2626 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2628 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2634 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bStepIn */

/* 2636 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2638 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2644 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure StepRange */

/* 2648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2656 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2658 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2662 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter bStepIn */

/* 2664 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2666 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ranges */

/* 2670 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2672 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2674 */	NdrFcShort( 0x6e0 ),	/* Type Offset=1760 */

	/* Parameter cRangeCount */

/* 2676 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2678 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2680 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2682 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2684 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2686 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure StepOut */

/* 2688 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2690 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2694 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2696 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2700 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2702 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2704 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2706 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRangeIL */

/* 2710 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2716 */	NdrFcShort( 0xa ),	/* 10 */
/* 2718 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2720 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2722 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2724 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bIL */

/* 2726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2732 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRegistersAvailable */

/* 2738 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2740 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2744 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2750 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2752 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pAvailable */

/* 2754 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2756 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2758 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 2760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2762 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRegisters */

/* 2766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2772 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2774 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2776 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2780 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter mask */

/* 2782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2784 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2786 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter regCount */

/* 2788 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2790 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter regBuffer */

/* 2794 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2796 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2798 */	NdrFcShort( 0x6f2 ),	/* Type Offset=1778 */

	/* Return value */

/* 2800 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2802 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRegisters */

/* 2806 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2808 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2812 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2814 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2816 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2818 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2820 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter mask */

/* 2822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2824 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2826 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter regCount */

/* 2828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter regBuffer */

/* 2834 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2838 */	NdrFcShort( 0x700 ),	/* Type Offset=1792 */

	/* Return value */

/* 2840 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2842 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThreadContext */

/* 2846 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2848 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2852 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2854 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2858 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2860 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter contextSize */

/* 2862 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2864 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter context */

/* 2868 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2870 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2872 */	NdrFcShort( 0x70a ),	/* Type Offset=1802 */

	/* Return value */

/* 2874 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2876 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2878 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetThreadContext */

/* 2880 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2882 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2886 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2888 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2894 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter contextSize */

/* 2896 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2898 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter context */

/* 2902 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2904 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2906 */	NdrFcShort( 0x718 ),	/* Type Offset=1816 */

	/* Return value */

/* 2908 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2910 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 2914 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2916 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2920 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2922 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2928 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProcess */

/* 2930 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2934 */	NdrFcShort( 0x726 ),	/* Type Offset=1830 */

	/* Return value */

/* 2936 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetID */

/* 2942 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2944 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2948 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2950 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2954 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2956 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwThreadId */

/* 2958 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2960 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2964 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2966 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHandle */

/* 2970 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2976 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2978 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2982 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2984 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter phThreadHandle */

/* 2986 */	NdrFcShort( 0x2112 ),	/* Flags:  must free, out, simple ref, srv alloc size=8 */
/* 2988 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2990 */	NdrFcShort( 0x746 ),	/* Type Offset=1862 */

	/* Return value */

/* 2992 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2994 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAppDomain */

/* 2998 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3000 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3004 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3006 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3010 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3012 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAppDomain */

/* 3014 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3016 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3018 */	NdrFcShort( 0x750 ),	/* Type Offset=1872 */

	/* Return value */

/* 3020 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3022 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3024 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDebugState */

/* 3026 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3028 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3032 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3034 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3036 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3038 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3040 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter state */

/* 3042 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3044 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3046 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 3048 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3050 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3052 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugState */

/* 3054 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3056 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3060 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3062 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3066 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3068 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pState */

/* 3070 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 3072 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3074 */	NdrFcShort( 0x766 ),	/* Type Offset=1894 */

	/* Return value */

/* 3076 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3078 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3080 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetUserState */

/* 3082 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3084 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3088 */	NdrFcShort( 0x9 ),	/* 9 */
/* 3090 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3092 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3094 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3096 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pState */

/* 3098 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 3100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3102 */	NdrFcShort( 0x76a ),	/* Type Offset=1898 */

	/* Return value */

/* 3104 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3106 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCurrentException */

/* 3110 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3112 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3116 */	NdrFcShort( 0xa ),	/* 10 */
/* 3118 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3122 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3124 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppExceptionObject */

/* 3126 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3128 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3130 */	NdrFcShort( 0x76e ),	/* Type Offset=1902 */

	/* Return value */

/* 3132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3134 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearCurrentException */

/* 3138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3144 */	NdrFcShort( 0xb ),	/* 11 */
/* 3146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3152 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 3154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3156 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateStepper */

/* 3160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3166 */	NdrFcShort( 0xc ),	/* 12 */
/* 3168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3174 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppStepper */

/* 3176 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3180 */	NdrFcShort( 0x784 ),	/* Type Offset=1924 */

	/* Return value */

/* 3182 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateChains */

/* 3188 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3194 */	NdrFcShort( 0xd ),	/* 13 */
/* 3196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3202 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChains */

/* 3204 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3208 */	NdrFcShort( 0x79a ),	/* Type Offset=1946 */

	/* Return value */

/* 3210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetActiveChain */

/* 3216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3222 */	NdrFcShort( 0xe ),	/* 14 */
/* 3224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3230 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3232 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3236 */	NdrFcShort( 0x7b0 ),	/* Type Offset=1968 */

	/* Return value */

/* 3238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetActiveFrame */

/* 3244 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3246 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3250 */	NdrFcShort( 0xf ),	/* 15 */
/* 3252 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3254 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3258 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFrame */

/* 3260 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3264 */	NdrFcShort( 0x7c6 ),	/* Type Offset=1990 */

	/* Return value */

/* 3266 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRegisterSet */

/* 3272 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3274 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3278 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3280 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3286 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppRegisters */

/* 3288 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3292 */	NdrFcShort( 0x7dc ),	/* Type Offset=2012 */

	/* Return value */

/* 3294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateEval */

/* 3300 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3306 */	NdrFcShort( 0x11 ),	/* 17 */
/* 3308 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3312 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3314 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEval */

/* 3316 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3318 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3320 */	NdrFcShort( 0x7f2 ),	/* Type Offset=2034 */

	/* Return value */

/* 3322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3324 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetObject */

/* 3328 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3334 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3336 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3342 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObject */

/* 3344 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3348 */	NdrFcShort( 0x808 ),	/* Type Offset=2056 */

	/* Return value */

/* 3350 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3352 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThread */

/* 3356 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3358 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3362 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3364 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3370 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppThread */

/* 3372 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3376 */	NdrFcShort( 0x81e ),	/* Type Offset=2078 */

	/* Return value */

/* 3378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3380 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStackRange */

/* 3384 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3390 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3392 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3396 */	NdrFcShort( 0x50 ),	/* 80 */
/* 3398 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pStart */

/* 3400 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3402 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3404 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pEnd */

/* 3406 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3408 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3410 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 3412 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3414 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetContext */

/* 3418 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3420 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3424 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3426 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3432 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppContext */

/* 3434 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3436 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3438 */	NdrFcShort( 0x83c ),	/* Type Offset=2108 */

	/* Return value */

/* 3440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3442 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCaller */

/* 3446 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3452 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3458 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3460 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3462 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3464 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3466 */	NdrFcShort( 0x852 ),	/* Type Offset=2130 */

	/* Return value */

/* 3468 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3470 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCallee */

/* 3474 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3476 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3480 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3486 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3488 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3490 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3492 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3494 */	NdrFcShort( 0x868 ),	/* Type Offset=2152 */

	/* Return value */

/* 3496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3498 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPrevious */

/* 3502 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3510 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3514 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3516 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3518 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3520 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3522 */	NdrFcShort( 0x87e ),	/* Type Offset=2174 */

	/* Return value */

/* 3524 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3526 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNext */

/* 3530 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3532 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3536 */	NdrFcShort( 0x9 ),	/* 9 */
/* 3538 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3544 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3546 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3548 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3550 */	NdrFcShort( 0x894 ),	/* Type Offset=2196 */

	/* Return value */

/* 3552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3554 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsManaged */

/* 3558 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3564 */	NdrFcShort( 0xa ),	/* 10 */
/* 3566 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3568 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3570 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3572 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pManaged */

/* 3574 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3576 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3578 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3580 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3582 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateFrames */

/* 3586 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3588 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3592 */	NdrFcShort( 0xb ),	/* 11 */
/* 3594 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3598 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3600 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFrames */

/* 3602 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3604 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3606 */	NdrFcShort( 0x8ae ),	/* Type Offset=2222 */

	/* Return value */

/* 3608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3610 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetActiveFrame */

/* 3614 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3620 */	NdrFcShort( 0xc ),	/* 12 */
/* 3622 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3626 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3628 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFrame */

/* 3630 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3634 */	NdrFcShort( 0x8c4 ),	/* Type Offset=2244 */

	/* Return value */

/* 3636 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRegisterSet */

/* 3642 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3644 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3648 */	NdrFcShort( 0xd ),	/* 13 */
/* 3650 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3656 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppRegisters */

/* 3658 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3660 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3662 */	NdrFcShort( 0x8da ),	/* Type Offset=2266 */

	/* Return value */

/* 3664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3666 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReason */

/* 3670 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3676 */	NdrFcShort( 0xe ),	/* 14 */
/* 3678 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3682 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3684 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pReason */

/* 3686 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 3688 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3690 */	NdrFcShort( 0x8f0 ),	/* Type Offset=2288 */

	/* Return value */

/* 3692 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3694 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3696 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetChain */

/* 3698 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3700 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3704 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3710 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3712 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppChain */

/* 3714 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3716 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3718 */	NdrFcShort( 0x8f4 ),	/* Type Offset=2292 */

	/* Return value */

/* 3720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3722 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCode */

/* 3726 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3728 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3732 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3734 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3736 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3740 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCode */

/* 3742 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3744 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3746 */	NdrFcShort( 0x90a ),	/* Type Offset=2314 */

	/* Return value */

/* 3748 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3750 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunction */

/* 3754 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3760 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3762 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3766 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3768 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFunction */

/* 3770 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3772 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3774 */	NdrFcShort( 0x920 ),	/* Type Offset=2336 */

	/* Return value */

/* 3776 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3778 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunctionToken */

/* 3782 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3788 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3790 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3794 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3796 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pToken */

/* 3798 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3800 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3804 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3806 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStackRange */

/* 3810 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3812 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3816 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3818 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3820 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3822 */	NdrFcShort( 0x50 ),	/* 80 */
/* 3824 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pStart */

/* 3826 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3828 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3830 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pEnd */

/* 3832 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3834 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3836 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 3838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3840 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCaller */

/* 3844 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3850 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3852 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3858 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFrame */

/* 3860 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3862 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3864 */	NdrFcShort( 0x942 ),	/* Type Offset=2370 */

	/* Return value */

/* 3866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3868 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCallee */

/* 3872 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3878 */	NdrFcShort( 0x9 ),	/* 9 */
/* 3880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3884 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3886 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFrame */

/* 3888 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3890 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3892 */	NdrFcShort( 0x958 ),	/* Type Offset=2392 */

	/* Return value */

/* 3894 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3896 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateStepper */

/* 3900 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3902 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3906 */	NdrFcShort( 0xa ),	/* 10 */
/* 3908 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3910 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3914 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppStepper */

/* 3916 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3918 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3920 */	NdrFcShort( 0x96e ),	/* Type Offset=2414 */

	/* Return value */

/* 3922 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3924 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetIP */

/* 3928 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3930 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3934 */	NdrFcShort( 0xb ),	/* 11 */
/* 3936 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3940 */	NdrFcShort( 0x3e ),	/* 62 */
/* 3942 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pnOffset */

/* 3944 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3946 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pMappingResult */

/* 3950 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 3952 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3954 */	NdrFcShort( 0x988 ),	/* Type Offset=2440 */

	/* Return value */

/* 3956 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3958 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3960 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetIP */

/* 3962 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3964 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3968 */	NdrFcShort( 0xc ),	/* 12 */
/* 3970 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3972 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3974 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3976 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter nOffset */

/* 3978 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3980 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3986 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateLocalVariables */

/* 3990 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3996 */	NdrFcShort( 0xd ),	/* 13 */
/* 3998 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4000 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4004 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppValueEnum */

/* 4006 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4008 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4010 */	NdrFcShort( 0x98c ),	/* Type Offset=2444 */

	/* Return value */

/* 4012 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4014 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4016 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalVariable */

/* 4018 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4020 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4024 */	NdrFcShort( 0xe ),	/* 14 */
/* 4026 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4030 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4032 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwIndex */

/* 4034 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4036 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4038 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4040 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4042 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4044 */	NdrFcShort( 0x9a2 ),	/* Type Offset=2466 */

	/* Return value */

/* 4046 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4048 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4050 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumerateArguments */

/* 4052 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4054 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4058 */	NdrFcShort( 0xf ),	/* 15 */
/* 4060 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4064 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4066 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppValueEnum */

/* 4068 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4070 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4072 */	NdrFcShort( 0x9b8 ),	/* Type Offset=2488 */

	/* Return value */

/* 4074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4076 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetArgument */

/* 4080 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4086 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4088 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4090 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4092 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4094 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwIndex */

/* 4096 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4098 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4102 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4106 */	NdrFcShort( 0x9ce ),	/* Type Offset=2510 */

	/* Return value */

/* 4108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStackDepth */

/* 4114 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4116 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4120 */	NdrFcShort( 0x11 ),	/* 17 */
/* 4122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4126 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4128 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pDepth */

/* 4130 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4132 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4136 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4138 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStackValue */

/* 4142 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4144 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4148 */	NdrFcShort( 0x12 ),	/* 18 */
/* 4150 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4156 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwIndex */

/* 4158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4160 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4164 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4166 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4168 */	NdrFcShort( 0x9e8 ),	/* Type Offset=2536 */

	/* Return value */

/* 4170 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4172 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4174 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanSetIP */

/* 4176 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4178 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4182 */	NdrFcShort( 0x13 ),	/* 19 */
/* 4184 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4188 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4190 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter nOffset */

/* 4192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4194 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4198 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4200 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetIP */

/* 4204 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4206 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4210 */	NdrFcShort( 0xb ),	/* 11 */
/* 4212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4216 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4218 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnOffset */

/* 4220 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4222 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4226 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4228 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetIP */

/* 4232 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4234 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4238 */	NdrFcShort( 0xc ),	/* 12 */
/* 4240 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4244 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4246 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter nOffset */

/* 4248 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4250 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4256 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRegisterSet */

/* 4260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4266 */	NdrFcShort( 0xd ),	/* 13 */
/* 4268 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4274 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppRegisters */

/* 4276 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4280 */	NdrFcShort( 0xa02 ),	/* Type Offset=2562 */

	/* Return value */

/* 4282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalRegisterValue */

/* 4288 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4294 */	NdrFcShort( 0xe ),	/* 14 */
/* 4296 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4298 */	NdrFcShort( 0x16 ),	/* 22 */
/* 4300 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4302 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter reg */

/* 4304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4306 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4308 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter cbSigBlob */

/* 4310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4312 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 4316 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4322 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4324 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4326 */	NdrFcShort( 0xa18 ),	/* Type Offset=2584 */

	/* Return value */

/* 4328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4330 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalDoubleRegisterValue */

/* 4334 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4340 */	NdrFcShort( 0xf ),	/* 15 */
/* 4342 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4344 */	NdrFcShort( 0x1c ),	/* 28 */
/* 4346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4348 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter highWordReg */

/* 4350 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4352 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4354 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter lowWordReg */

/* 4356 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4358 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4360 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter cbSigBlob */

/* 4362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4364 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 4368 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4370 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4374 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4376 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4378 */	NdrFcShort( 0xa2e ),	/* Type Offset=2606 */

	/* Return value */

/* 4380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4382 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalMemoryValue */

/* 4386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4392 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4394 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4396 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4400 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter address */

/* 4402 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4406 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter cbSigBlob */

/* 4408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4410 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 4414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4416 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4420 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4422 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4424 */	NdrFcShort( 0xa44 ),	/* Type Offset=2628 */

	/* Return value */

/* 4426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4428 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalRegisterMemoryValue */

/* 4432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4438 */	NdrFcShort( 0x11 ),	/* 17 */
/* 4440 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 4442 */	NdrFcShort( 0x26 ),	/* 38 */
/* 4444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4446 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter highWordReg */

/* 4448 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4450 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4452 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter lowWordAddress */

/* 4454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4456 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4458 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter cbSigBlob */

/* 4460 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4462 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 4466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4468 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4472 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4474 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4476 */	NdrFcShort( 0xa5a ),	/* Type Offset=2650 */

	/* Return value */

/* 4478 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4480 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalMemoryRegisterValue */

/* 4484 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4490 */	NdrFcShort( 0x12 ),	/* 18 */
/* 4492 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 4494 */	NdrFcShort( 0x26 ),	/* 38 */
/* 4496 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4498 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter highWordAddress */

/* 4500 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4502 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4504 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter lowWordRegister */

/* 4506 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4510 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter cbSigBlob */

/* 4512 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4514 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 4518 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4520 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 4524 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4526 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4528 */	NdrFcShort( 0xa70 ),	/* Type Offset=2672 */

	/* Return value */

/* 4530 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4532 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4534 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanSetIP */

/* 4536 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4538 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4542 */	NdrFcShort( 0x13 ),	/* 19 */
/* 4544 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4546 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4548 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4550 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter nOffset */

/* 4552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4554 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4560 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 4564 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4570 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4578 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProcess */

/* 4580 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4582 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4584 */	NdrFcShort( 0xa86 ),	/* Type Offset=2694 */

	/* Return value */

/* 4586 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4588 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBaseAddress */

/* 4592 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4594 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4598 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4600 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4604 */	NdrFcShort( 0x2c ),	/* 44 */
/* 4606 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 4608 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4610 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4612 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 4614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4616 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAssembly */

/* 4620 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4626 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4628 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4634 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAssembly */

/* 4636 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4638 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4640 */	NdrFcShort( 0xaa0 ),	/* Type Offset=2720 */

	/* Return value */

/* 4642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4644 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 4648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4654 */	NdrFcShort( 0x6 ),	/* 6 */
/* 4656 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4658 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4660 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4662 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 4664 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4666 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 4670 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4672 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 4676 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4678 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4680 */	NdrFcShort( 0xaba ),	/* Type Offset=2746 */

	/* Return value */

/* 4682 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4684 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4686 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnableJITDebugging */

/* 4688 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4690 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4694 */	NdrFcShort( 0x7 ),	/* 7 */
/* 4696 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4698 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4700 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4702 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter bTrackJITInfo */

/* 4704 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4706 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bAllowJitOpts */

/* 4710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4712 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4718 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnableClassLoadCallbacks */

/* 4722 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4730 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4736 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bClassLoadCallbacks */

/* 4738 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4740 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4746 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunctionFromToken */

/* 4750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4756 */	NdrFcShort( 0x9 ),	/* 9 */
/* 4758 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4764 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter methodDef */

/* 4766 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4768 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppFunction */

/* 4772 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4774 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4776 */	NdrFcShort( 0xac8 ),	/* Type Offset=2760 */

	/* Return value */

/* 4778 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4780 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunctionFromRVA */

/* 4784 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4786 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4790 */	NdrFcShort( 0xa ),	/* 10 */
/* 4792 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4794 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4796 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4798 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter rva */

/* 4800 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4804 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppFunction */

/* 4806 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4808 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4810 */	NdrFcShort( 0xade ),	/* Type Offset=2782 */

	/* Return value */

/* 4812 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4814 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4816 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetClassFromToken */

/* 4818 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4820 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4824 */	NdrFcShort( 0xb ),	/* 11 */
/* 4826 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4832 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter typeDef */

/* 4834 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4836 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppClass */

/* 4840 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4842 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4844 */	NdrFcShort( 0xaf4 ),	/* Type Offset=2804 */

	/* Return value */

/* 4846 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4848 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4850 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateBreakpoint */

/* 4852 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4854 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4858 */	NdrFcShort( 0xc ),	/* 12 */
/* 4860 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4866 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBreakpoint */

/* 4868 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4870 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4872 */	NdrFcShort( 0xb0a ),	/* Type Offset=2826 */

	/* Return value */

/* 4874 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4876 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4878 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEditAndContinueSnapshot */

/* 4880 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4882 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4886 */	NdrFcShort( 0xd ),	/* 13 */
/* 4888 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4894 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEditAndContinueSnapshot */

/* 4896 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4898 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4900 */	NdrFcShort( 0xb20 ),	/* Type Offset=2848 */

	/* Return value */

/* 4902 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4904 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4906 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMetaDataInterface */

/* 4908 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4910 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4914 */	NdrFcShort( 0xe ),	/* 14 */
/* 4916 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4918 */	NdrFcShort( 0x44 ),	/* 68 */
/* 4920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4922 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter riid */

/* 4924 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4926 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4928 */	NdrFcShort( 0xb40 ),	/* Type Offset=2880 */

	/* Parameter ppObj */

/* 4930 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4932 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4934 */	NdrFcShort( 0xb4c ),	/* Type Offset=2892 */

	/* Return value */

/* 4936 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4938 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetToken */

/* 4942 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4944 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4948 */	NdrFcShort( 0xf ),	/* 15 */
/* 4950 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4954 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4956 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pToken */

/* 4958 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4960 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4964 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4966 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsDynamic */

/* 4970 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4976 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4978 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4982 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4984 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pDynamic */

/* 4986 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4988 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4992 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4994 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetGlobalVariableValue */

/* 4998 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5000 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5004 */	NdrFcShort( 0x11 ),	/* 17 */
/* 5006 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5008 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5010 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5012 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter fieldDef */

/* 5014 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5016 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5018 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 5020 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5022 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5024 */	NdrFcShort( 0xb6a ),	/* Type Offset=2922 */

	/* Return value */

/* 5026 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5028 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5030 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 5032 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5034 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5038 */	NdrFcShort( 0x12 ),	/* 18 */
/* 5040 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5044 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5046 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcBytes */

/* 5048 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5050 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5052 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5054 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5056 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5058 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsInMemory */

/* 5060 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5062 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5066 */	NdrFcShort( 0x13 ),	/* 19 */
/* 5068 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5072 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5074 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pInMemory */

/* 5076 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5078 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5080 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5082 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5084 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModule */

/* 5088 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5090 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5094 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5096 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5100 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5102 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppModule */

/* 5104 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5106 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5108 */	NdrFcShort( 0xb88 ),	/* Type Offset=2952 */

	/* Return value */

/* 5110 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5112 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5114 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetClass */

/* 5116 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5118 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5124 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5130 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppClass */

/* 5132 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5136 */	NdrFcShort( 0xb9e ),	/* Type Offset=2974 */

	/* Return value */

/* 5138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetToken */

/* 5144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5150 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5156 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5158 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pMethodDef */

/* 5160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5162 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5168 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetILCode */

/* 5172 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5178 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5180 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5186 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCode */

/* 5188 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5190 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5192 */	NdrFcShort( 0xbb8 ),	/* Type Offset=3000 */

	/* Return value */

/* 5194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5196 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNativeCode */

/* 5200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5206 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5208 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5214 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCode */

/* 5216 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5220 */	NdrFcShort( 0xbce ),	/* Type Offset=3022 */

	/* Return value */

/* 5222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5224 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateBreakpoint */

/* 5228 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5230 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5240 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5242 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBreakpoint */

/* 5244 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5248 */	NdrFcShort( 0xbe4 ),	/* Type Offset=3044 */

	/* Return value */

/* 5250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalVarSigToken */

/* 5256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5262 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5264 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5268 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5270 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pmdSig */

/* 5272 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5276 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCurrentVersionNumber */

/* 5284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5290 */	NdrFcShort( 0xa ),	/* 10 */
/* 5292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5296 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5298 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnCurrentVersion */

/* 5300 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsIL */

/* 5312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5318 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5324 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5326 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbIL */

/* 5328 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5336 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunction */

/* 5340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5346 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5348 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5354 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFunction */

/* 5356 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5358 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5360 */	NdrFcShort( 0xc06 ),	/* Type Offset=3078 */

	/* Return value */

/* 5362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5364 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddress */

/* 5368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5374 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5380 */	NdrFcShort( 0x2c ),	/* 44 */
/* 5382 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pStart */

/* 5384 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5388 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 5390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 5396 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5402 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5408 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5410 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcBytes */

/* 5412 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5414 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5418 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5420 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateBreakpoint */

/* 5424 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5426 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5430 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5432 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5434 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5438 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter offset */

/* 5440 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppBreakpoint */

/* 5446 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5450 */	NdrFcShort( 0xc24 ),	/* Type Offset=3108 */

	/* Return value */

/* 5452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCode */

/* 5458 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5466 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5468 */	NdrFcShort( 0x18 ),	/* 24 */
/* 5470 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5472 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter startOffset */

/* 5474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endOffset */

/* 5480 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cBufferAlloc */

/* 5486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter buffer */

/* 5492 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5496 */	NdrFcShort( 0xc3a ),	/* Type Offset=3130 */

	/* Parameter pcBufferSize */

/* 5498 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5500 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5502 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5504 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5506 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5508 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVersionNumber */

/* 5510 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5512 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5516 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5518 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5522 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5524 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter nVersion */

/* 5526 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5528 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5530 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5532 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5534 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetILToNativeMapping */

/* 5538 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5540 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5544 */	NdrFcShort( 0xa ),	/* 10 */
/* 5546 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5548 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5550 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5552 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cMap */

/* 5554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5556 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcMap */

/* 5560 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5562 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5564 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter map */

/* 5566 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5568 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5570 */	NdrFcShort( 0xc5c ),	/* Type Offset=3164 */

	/* Return value */

/* 5572 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5574 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5576 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEnCRemapSequencePoints */

/* 5578 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5580 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5584 */	NdrFcShort( 0xb ),	/* 11 */
/* 5586 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5590 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5592 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cMap */

/* 5594 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5596 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcMap */

/* 5600 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5602 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter offsets */

/* 5606 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5608 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5610 */	NdrFcShort( 0xc72 ),	/* Type Offset=3186 */

	/* Return value */

/* 5612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5614 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModule */

/* 5618 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5620 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5624 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5626 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5632 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pModule */

/* 5634 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5636 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5638 */	NdrFcShort( 0xc80 ),	/* Type Offset=3200 */

	/* Return value */

/* 5640 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5642 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5644 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetToken */

/* 5646 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5648 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5652 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5654 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5658 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5660 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pTypeDef */

/* 5662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5664 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5670 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStaticFieldValue */

/* 5674 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5680 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5682 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5684 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5688 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter fieldDef */

/* 5690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5692 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pFrame */

/* 5696 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5698 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5700 */	NdrFcShort( 0xc9a ),	/* Type Offset=3226 */

	/* Parameter ppValue */

/* 5702 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5704 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5706 */	NdrFcShort( 0xcac ),	/* Type Offset=3244 */

	/* Return value */

/* 5708 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5710 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CallFunction */

/* 5714 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5716 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5720 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5722 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5726 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5728 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pFunction */

/* 5730 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5732 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5734 */	NdrFcShort( 0xcc2 ),	/* Type Offset=3266 */

	/* Parameter nArgs */

/* 5736 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5738 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppArgs */

/* 5742 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5744 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5746 */	NdrFcShort( 0xce6 ),	/* Type Offset=3302 */

	/* Return value */

/* 5748 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5750 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NewObject */

/* 5754 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5760 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5762 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5764 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5766 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5768 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pConstructor */

/* 5770 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5772 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5774 */	NdrFcShort( 0xcf8 ),	/* Type Offset=3320 */

	/* Parameter nArgs */

/* 5776 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5778 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppArgs */

/* 5782 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5784 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5786 */	NdrFcShort( 0xd1c ),	/* Type Offset=3356 */

	/* Return value */

/* 5788 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5790 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NewObjectNoConstructor */

/* 5794 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5796 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5800 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5802 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5806 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5808 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pClass */

/* 5810 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5812 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5814 */	NdrFcShort( 0xd2e ),	/* Type Offset=3374 */

	/* Return value */

/* 5816 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5818 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5820 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NewString */

/* 5822 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5824 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5828 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5836 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter string */

/* 5838 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5840 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5842 */	NdrFcShort( 0xd42 ),	/* Type Offset=3394 */

	/* Return value */

/* 5844 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5846 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NewArray */

/* 5850 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5852 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5856 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5858 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5860 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5862 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5864 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter elementType */

/* 5866 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5868 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pElementClass */

/* 5872 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5874 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5876 */	NdrFcShort( 0xd44 ),	/* Type Offset=3396 */

	/* Parameter rank */

/* 5878 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5882 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dims */

/* 5884 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5886 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5888 */	NdrFcShort( 0xd56 ),	/* Type Offset=3414 */

	/* Parameter lowBounds */

/* 5890 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5892 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5894 */	NdrFcShort( 0xd60 ),	/* Type Offset=3424 */

	/* Return value */

/* 5896 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5898 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsActive */

/* 5902 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5904 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5908 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5910 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5914 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5916 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbActive */

/* 5918 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5920 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5924 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5926 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5928 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Abort */

/* 5930 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5932 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5936 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5944 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 5946 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5948 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5950 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResult */

/* 5952 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5954 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5958 */	NdrFcShort( 0xa ),	/* 10 */
/* 5960 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5964 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5966 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppResult */

/* 5968 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5970 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5972 */	NdrFcShort( 0xd6e ),	/* Type Offset=3438 */

	/* Return value */

/* 5974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5976 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThread */

/* 5980 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5986 */	NdrFcShort( 0xb ),	/* 11 */
/* 5988 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5990 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5992 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5994 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppThread */

/* 5996 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5998 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6000 */	NdrFcShort( 0xd84 ),	/* Type Offset=3460 */

	/* Return value */

/* 6002 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6004 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateValue */

/* 6008 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6010 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6014 */	NdrFcShort( 0xc ),	/* 12 */
/* 6016 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6020 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6022 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter elementType */

/* 6024 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6026 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pElementClass */

/* 6030 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6032 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6034 */	NdrFcShort( 0xd9a ),	/* Type Offset=3482 */

	/* Parameter ppValue */

/* 6036 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6038 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6040 */	NdrFcShort( 0xdac ),	/* Type Offset=3500 */

	/* Return value */

/* 6042 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6044 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6046 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetType */

/* 6048 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6050 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6054 */	NdrFcShort( 0x3 ),	/* 3 */
/* 6056 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6060 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6062 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pType */

/* 6064 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6066 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6070 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6072 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 6076 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6078 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6082 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6084 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6086 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6088 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6090 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pSize */

/* 6092 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6098 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddress */

/* 6104 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6106 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6110 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6116 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6118 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 6120 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6124 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateBreakpoint */

/* 6132 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6138 */	NdrFcShort( 0x6 ),	/* 6 */
/* 6140 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6146 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBreakpoint */

/* 6148 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6150 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6152 */	NdrFcShort( 0xdce ),	/* Type Offset=3534 */

	/* Return value */

/* 6154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6156 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsNull */

/* 6160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6166 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6172 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6174 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbNull */

/* 6176 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6182 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetValue */

/* 6188 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6194 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6200 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6202 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pValue */

/* 6204 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6208 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetValue */

/* 6216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6222 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6224 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6226 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6230 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter value */

/* 6232 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6236 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6240 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Dereference */

/* 6244 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6246 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6250 */	NdrFcShort( 0xa ),	/* 10 */
/* 6252 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6254 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6258 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppValue */

/* 6260 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6264 */	NdrFcShort( 0xdec ),	/* Type Offset=3564 */

	/* Return value */

/* 6266 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DereferenceStrong */

/* 6272 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6274 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6278 */	NdrFcShort( 0xb ),	/* 11 */
/* 6280 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6286 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppValue */

/* 6288 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6292 */	NdrFcShort( 0xe02 ),	/* Type Offset=3586 */

	/* Return value */

/* 6294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsValid */

/* 6300 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6306 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6308 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6312 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6314 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbValid */

/* 6316 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6318 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6324 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateRelocBreakpoint */

/* 6328 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6336 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6342 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBreakpoint */

/* 6344 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6348 */	NdrFcShort( 0xe1c ),	/* Type Offset=3612 */

	/* Return value */

/* 6350 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6352 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetClass */

/* 6356 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6358 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6362 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6364 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6368 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6370 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppClass */

/* 6372 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6376 */	NdrFcShort( 0xe32 ),	/* Type Offset=3634 */

	/* Return value */

/* 6378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6380 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFieldValue */

/* 6384 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6392 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6394 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6398 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pClass */

/* 6400 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6402 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6404 */	NdrFcShort( 0xe48 ),	/* Type Offset=3656 */

	/* Parameter fieldDef */

/* 6406 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6408 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 6412 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6414 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6416 */	NdrFcShort( 0xe5a ),	/* Type Offset=3674 */

	/* Return value */

/* 6418 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6420 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVirtualMethod */

/* 6424 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6426 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6430 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6432 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6434 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6438 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter memberRef */

/* 6440 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppFunction */

/* 6446 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6450 */	NdrFcShort( 0xe70 ),	/* Type Offset=3696 */

	/* Return value */

/* 6452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetContext */

/* 6458 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6464 */	NdrFcShort( 0xa ),	/* 10 */
/* 6466 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6472 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppContext */

/* 6474 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6478 */	NdrFcShort( 0xe86 ),	/* Type Offset=3718 */

	/* Return value */

/* 6480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsValueClass */

/* 6486 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6492 */	NdrFcShort( 0xb ),	/* 11 */
/* 6494 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6496 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6498 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6500 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbIsValueClass */

/* 6502 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6504 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6508 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6510 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6512 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetManagedCopy */

/* 6514 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6516 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6520 */	NdrFcShort( 0xc ),	/* 12 */
/* 6522 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6528 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObject */

/* 6530 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6532 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6534 */	NdrFcShort( 0xea0 ),	/* Type Offset=3744 */

	/* Return value */

/* 6536 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6538 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetFromManagedCopy */

/* 6542 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6544 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6548 */	NdrFcShort( 0xd ),	/* 13 */
/* 6550 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6554 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6556 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pObject */

/* 6558 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6560 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6562 */	NdrFcShort( 0xeb6 ),	/* Type Offset=3766 */

	/* Return value */

/* 6564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6566 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetObject */

/* 6570 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6572 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6576 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6578 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6584 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppObject */

/* 6586 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6588 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6590 */	NdrFcShort( 0xec8 ),	/* Type Offset=3784 */

	/* Return value */

/* 6592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6594 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLength */

/* 6598 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6604 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6606 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6610 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6612 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcchString */

/* 6614 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6616 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6620 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6622 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 6626 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6632 */	NdrFcShort( 0xa ),	/* 10 */
/* 6634 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6636 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6638 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6640 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchString */

/* 6642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6644 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchString */

/* 6648 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6650 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szString */

/* 6654 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6658 */	NdrFcShort( 0xee6 ),	/* Type Offset=3814 */

	/* Return value */

/* 6660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6662 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetElementType */

/* 6666 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6672 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6678 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6680 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pType */

/* 6682 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6684 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6686 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6688 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6690 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6692 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRank */

/* 6694 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6696 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6700 */	NdrFcShort( 0xa ),	/* 10 */
/* 6702 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6706 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6708 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnRank */

/* 6710 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6718 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */

/* 6722 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6728 */	NdrFcShort( 0xb ),	/* 11 */
/* 6730 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6734 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6736 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnCount */

/* 6738 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6740 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6746 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDimensions */

/* 6750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6756 */	NdrFcShort( 0xc ),	/* 12 */
/* 6758 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6764 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter cdim */

/* 6766 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6768 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dims */

/* 6772 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6774 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6776 */	NdrFcShort( 0xf00 ),	/* Type Offset=3840 */

	/* Return value */

/* 6778 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6780 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure HasBaseIndicies */

/* 6784 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6786 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6790 */	NdrFcShort( 0xd ),	/* 13 */
/* 6792 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6796 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6798 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbHasBaseIndicies */

/* 6800 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6808 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBaseIndicies */

/* 6812 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6818 */	NdrFcShort( 0xe ),	/* 14 */
/* 6820 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6822 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6826 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter cdim */

/* 6828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6830 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter indicies */

/* 6834 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6836 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6838 */	NdrFcShort( 0xf12 ),	/* Type Offset=3858 */

	/* Return value */

/* 6840 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6842 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetElement */

/* 6846 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6848 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6852 */	NdrFcShort( 0xf ),	/* 15 */
/* 6854 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6858 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6860 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter cdim */

/* 6862 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6864 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter indices */

/* 6868 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6870 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6872 */	NdrFcShort( 0xf20 ),	/* Type Offset=3872 */

	/* Parameter ppValue */

/* 6874 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6876 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6878 */	NdrFcShort( 0xf2e ),	/* Type Offset=3886 */

	/* Return value */

/* 6880 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6882 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6884 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetElementAtPosition */

/* 6886 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6888 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6892 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6894 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6896 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6900 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter nPosition */

/* 6902 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6904 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6906 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppValue */

/* 6908 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6910 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6912 */	NdrFcShort( 0xf44 ),	/* Type Offset=3908 */

	/* Return value */

/* 6914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6916 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */

/* 6920 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6926 */	NdrFcShort( 0x3 ),	/* 3 */
/* 6928 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6930 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6932 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6934 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter celt */

/* 6936 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6938 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6944 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 6948 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6954 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6956 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6960 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6962 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 6964 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6966 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 6970 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6976 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6978 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6984 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 6986 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6988 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6990 */	NdrFcShort( 0xf5a ),	/* Type Offset=3930 */

	/* Return value */

/* 6992 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6994 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */

/* 6998 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7000 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7004 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7006 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7010 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7012 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcelt */

/* 7014 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7016 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7018 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7020 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7022 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7024 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7026 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7028 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7032 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7034 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7038 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7040 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7042 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7044 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7046 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter objects */

/* 7048 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7050 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7052 */	NdrFcShort( 0xf74 ),	/* Type Offset=3956 */

	/* Parameter pceltFetched */

/* 7054 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7056 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7058 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7062 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7072 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7074 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7076 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7078 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7080 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7082 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7084 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter breakpoints */

/* 7088 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7090 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7092 */	NdrFcShort( 0xf98 ),	/* Type Offset=3992 */

	/* Parameter pceltFetched */

/* 7094 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7096 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7102 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7112 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7114 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7118 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7120 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7122 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7124 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter steppers */

/* 7128 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7130 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7132 */	NdrFcShort( 0xfc0 ),	/* Type Offset=4032 */

	/* Parameter pceltFetched */

/* 7134 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7138 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7142 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7146 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7152 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7154 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7158 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7160 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7164 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter processes */

/* 7168 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7170 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7172 */	NdrFcShort( 0xfe8 ),	/* Type Offset=4072 */

	/* Parameter pceltFetched */

/* 7174 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7176 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7182 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7186 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7192 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7194 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7198 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7200 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7204 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter threads */

/* 7208 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7210 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7212 */	NdrFcShort( 0x1010 ),	/* Type Offset=4112 */

	/* Parameter pceltFetched */

/* 7214 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7222 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7232 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7234 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7238 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7240 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7242 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter frames */

/* 7248 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7252 */	NdrFcShort( 0x1038 ),	/* Type Offset=4152 */

	/* Parameter pceltFetched */

/* 7254 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7262 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7266 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7272 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7274 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7276 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7278 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7280 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7284 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter chains */

/* 7288 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7290 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7292 */	NdrFcShort( 0x1060 ),	/* Type Offset=4192 */

	/* Parameter pceltFetched */

/* 7294 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7296 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7300 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7302 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7306 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7308 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7312 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7314 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7318 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7320 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7322 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7324 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter modules */

/* 7328 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7330 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7332 */	NdrFcShort( 0x1088 ),	/* Type Offset=4232 */

	/* Parameter pceltFetched */

/* 7334 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7336 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7342 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7352 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7354 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7358 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7360 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7364 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter values */

/* 7368 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7372 */	NdrFcShort( 0x10b0 ),	/* Type Offset=4272 */

	/* Parameter pceltFetched */

/* 7374 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7382 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7392 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7398 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7400 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7402 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter errors */

/* 7408 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7412 */	NdrFcShort( 0x10d8 ),	/* Type Offset=4312 */

	/* Parameter pceltFetched */

/* 7414 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7426 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7428 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7432 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7434 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7438 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7440 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7442 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7446 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter values */

/* 7448 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7450 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7452 */	NdrFcShort( 0x1100 ),	/* Type Offset=4352 */

	/* Parameter pceltFetched */

/* 7454 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7456 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7458 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7460 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7462 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 7466 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7468 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7472 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7478 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7480 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 7482 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7484 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7486 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter values */

/* 7488 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7490 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7492 */	NdrFcShort( 0x1128 ),	/* Type Offset=4392 */

	/* Parameter pceltFetched */

/* 7494 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7496 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7500 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7502 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7504 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModule */

/* 7506 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7508 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7512 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7514 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7516 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7520 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppModule */

/* 7522 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7526 */	NdrFcShort( 0x113e ),	/* Type Offset=4414 */

	/* Return value */

/* 7528 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetToken */

/* 7534 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7536 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7540 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7542 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7546 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7548 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pToken */

/* 7550 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7552 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7558 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetErrorCode */

/* 7562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7568 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7574 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7576 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pHr */

/* 7578 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7580 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7584 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7586 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 7590 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7592 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7596 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7598 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7602 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7604 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchString */

/* 7606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchString */

/* 7612 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szString */

/* 7618 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7622 */	NdrFcShort( 0x1160 ),	/* Type Offset=4448 */

	/* Return value */

/* 7624 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CopyMetaData */

/* 7630 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7632 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7636 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7638 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7642 */	NdrFcShort( 0x4c ),	/* 76 */
/* 7644 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pIStream */

/* 7646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7648 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7650 */	NdrFcShort( 0x116e ),	/* Type Offset=4462 */

	/* Parameter pMvid */

/* 7652 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 7654 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7656 */	NdrFcShort( 0xb40 ),	/* Type Offset=2880 */

	/* Return value */

/* 7658 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7660 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMvid */

/* 7664 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7666 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7670 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7672 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7676 */	NdrFcShort( 0x4c ),	/* 76 */
/* 7678 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pMvid */

/* 7680 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 7682 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7684 */	NdrFcShort( 0xb40 ),	/* Type Offset=2880 */

	/* Return value */

/* 7686 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7688 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRoDataRVA */

/* 7692 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7694 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7698 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7700 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7706 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRoDataRVA */

/* 7708 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7710 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7716 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRwDataRVA */

/* 7720 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7726 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7728 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7732 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7734 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRwDataRVA */

/* 7736 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7738 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7742 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7744 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7746 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPEBytes */

/* 7748 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7750 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7754 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7756 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7762 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pIStream */

/* 7764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7766 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7768 */	NdrFcShort( 0x1190 ),	/* Type Offset=4496 */

	/* Return value */

/* 7770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7772 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetILMap */

/* 7776 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7778 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7782 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7784 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7786 */	NdrFcShort( 0x10 ),	/* 16 */
/* 7788 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7790 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter mdFunction */

/* 7792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cMapSize */

/* 7798 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter map */

/* 7804 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7808 */	NdrFcShort( 0x11aa ),	/* Type Offset=4522 */

	/* Return value */

/* 7810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPESymbolBytes */

/* 7816 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7822 */	NdrFcShort( 0x9 ),	/* 9 */
/* 7824 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7830 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pIStream */

/* 7832 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7834 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7836 */	NdrFcShort( 0x11b8 ),	/* Type Offset=4536 */

	/* Return value */

/* 7838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7840 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/*  8 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 10 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 12 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 14 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 16 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 18 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 20 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 22 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 26 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 28 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 30 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 32 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 34 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 36 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 38 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 40 */	NdrFcLong( 0xcc7bcae8 ),	/* -864302360 */
/* 44 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 46 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 48 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 50 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 52 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 54 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 56 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 58 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 62 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 64 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 66 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 68 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 70 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 72 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 74 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 76 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 80 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 82 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 84 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 86 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 88 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 90 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 92 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 94 */	NdrFcLong( 0xcc7bcaec ),	/* -864302356 */
/* 98 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 100 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 102 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 104 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 106 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 108 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 110 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 112 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 116 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 118 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 120 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 122 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 124 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 126 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 128 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 130 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 134 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 136 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 138 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 140 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 142 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 144 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 146 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 148 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 152 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 154 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 156 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 158 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 160 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 162 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 164 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 166 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 170 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 172 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 174 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 176 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 178 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 180 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 182 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 184 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 188 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 190 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 192 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 194 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 196 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 198 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 200 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 202 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 206 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 208 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 210 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 212 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 214 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 216 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 218 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 220 */	NdrFcLong( 0xcc7bcaf6 ),	/* -864302346 */
/* 224 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 226 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 228 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 230 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 232 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 234 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 236 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 238 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 242 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 244 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 246 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 248 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 250 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 252 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 254 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 256 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 260 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 262 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 264 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 266 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 268 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 270 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 272 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 274 */	NdrFcLong( 0xcc7bcaf6 ),	/* -864302346 */
/* 278 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 280 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 282 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 284 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 286 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 288 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 290 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 292 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 296 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 298 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 300 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 302 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 304 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 306 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 308 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 310 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 314 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 316 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 318 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 320 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 322 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 324 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 332 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 334 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 336 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 338 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 340 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 342 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 350 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 352 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 354 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 356 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 358 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 360 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 362 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 364 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 368 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 370 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 372 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 374 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 376 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 378 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 380 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 382 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 386 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 388 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 390 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 392 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 394 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 396 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 398 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 400 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 404 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 406 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 408 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 410 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 412 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 414 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 416 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 418 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 422 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 424 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 426 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 428 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 430 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 432 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 434 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 436 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 440 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 442 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 444 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 446 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 448 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 450 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 452 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 454 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 458 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 460 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 462 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 464 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 466 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 468 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 470 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 472 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 476 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 478 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 480 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 482 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 484 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 486 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 488 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 490 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 494 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 496 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 498 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 500 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 502 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 504 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 506 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 508 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 512 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 514 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 516 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 518 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 520 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 522 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 524 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 526 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 530 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 532 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 534 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 536 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 538 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 540 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 542 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 544 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 548 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 550 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 552 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 554 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 556 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 558 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 560 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 562 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 566 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 568 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 570 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 572 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 574 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 576 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 578 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 580 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 584 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 586 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 588 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 590 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 592 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 594 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 596 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 598 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 600 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 602 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 604 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 606 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 610 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 612 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 614 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 616 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 618 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 620 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 622 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 624 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 628 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 630 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 632 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 634 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 636 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 638 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 640 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 642 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 644 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 646 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 648 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 650 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 654 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 656 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 658 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 660 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 662 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 664 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 666 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 668 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 672 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 674 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 676 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 678 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 680 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 682 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 684 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 686 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 690 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 692 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 694 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 696 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 698 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 700 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 702 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 704 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 708 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 710 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 712 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 714 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 716 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 718 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 720 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 722 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 726 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 728 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 730 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 732 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 734 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 736 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 738 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 740 */	NdrFcLong( 0xdf59507c ),	/* -547794820 */
/* 744 */	NdrFcShort( 0xd47a ),	/* -11142 */
/* 746 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 748 */	0xbc,		/* 188 */
			0xe2,		/* 226 */
/* 750 */	0x64,		/* 100 */
			0x27,		/* 39 */
/* 752 */	0xea,		/* 234 */
			0xc8,		/* 200 */
/* 754 */	0xfd,		/* 253 */
			0x6,		/* 6 */
/* 756 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 758 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 762 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 764 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 766 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 768 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 770 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 772 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 774 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 776 */	NdrFcLong( 0xdf59507c ),	/* -547794820 */
/* 780 */	NdrFcShort( 0xd47a ),	/* -11142 */
/* 782 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 784 */	0xbc,		/* 188 */
			0xe2,		/* 226 */
/* 786 */	0x64,		/* 100 */
			0x27,		/* 39 */
/* 788 */	0xea,		/* 234 */
			0xc8,		/* 200 */
/* 790 */	0xfd,		/* 253 */
			0x6,		/* 6 */
/* 792 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 794 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 798 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 800 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 802 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 804 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 806 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 808 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 810 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 812 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 816 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 818 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 820 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 822 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 824 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 826 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 828 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 830 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 834 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 836 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 838 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 840 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 842 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 844 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 846 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 848 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 852 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 854 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 856 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 858 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 860 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 862 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 864 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 866 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 870 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 872 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 874 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 876 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 878 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 880 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 882 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 884 */	NdrFcLong( 0xc ),	/* 12 */
/* 888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 894 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 896 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 898 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 900 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 902 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 906 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 908 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 910 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 912 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 914 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 916 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 918 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 920 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 924 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 926 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 928 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 930 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 932 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 934 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 936 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 938 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 942 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 944 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 946 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 948 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 950 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 952 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 954 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 956 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 960 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 962 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 964 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 966 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 968 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 970 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 972 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 974 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 978 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 980 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 982 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 984 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 986 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 988 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 990 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 992 */	NdrFcLong( 0xcc7bcae8 ),	/* -864302360 */
/* 996 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 998 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1000 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1002 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1004 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1006 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1008 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1010 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1012 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1014 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 1018 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 1020 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 1022 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 1024 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 1026 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 1028 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 1030 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1032 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1034 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1036 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1038) */
/* 1038 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1040 */	NdrFcLong( 0xcc7bcb06 ),	/* -864302330 */
/* 1044 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1046 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1048 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1050 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1052 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1054 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1056 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1058 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 1062 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 1064 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 1066 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 1068 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 1070 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 1072 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 1074 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1076 */	NdrFcLong( 0x6dc3fa01 ),	/* 1841560065 */
/* 1080 */	NdrFcShort( 0xd7cb ),	/* -10293 */
/* 1082 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1084 */	0x8a,		/* 138 */
			0x95,		/* 149 */
/* 1086 */	0x0,		/* 0 */
			0x80,		/* 128 */
/* 1088 */	0xc7,		/* 199 */
			0x92,		/* 146 */
/* 1090 */	0xe5,		/* 229 */
			0xd8,		/* 216 */
/* 1092 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1094 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1096 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1098 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1100 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1104 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1106 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1074) */
/* 1108 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1110 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1112 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1114) */
/* 1114 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1116 */	NdrFcLong( 0xf0e18809 ),	/* -253655031 */
/* 1120 */	NdrFcShort( 0x72b5 ),	/* 29365 */
/* 1122 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1124 */	0x97,		/* 151 */
			0x6f,		/* 111 */
/* 1126 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 1128 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 1130 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 1132 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1134 */	NdrFcLong( 0x6dc3fa01 ),	/* 1841560065 */
/* 1138 */	NdrFcShort( 0xd7cb ),	/* -10293 */
/* 1140 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1142 */	0x8a,		/* 138 */
			0x95,		/* 149 */
/* 1144 */	0x0,		/* 0 */
			0x80,		/* 128 */
/* 1146 */	0xc7,		/* 199 */
			0x92,		/* 146 */
/* 1148 */	0xe5,		/* 229 */
			0xd8,		/* 216 */
/* 1150 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1156 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1158 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1162 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1164 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1132) */
/* 1166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1168 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1170 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1172) */
/* 1172 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1174 */	NdrFcLong( 0xf0e18809 ),	/* -253655031 */
/* 1178 */	NdrFcShort( 0x72b5 ),	/* 29365 */
/* 1180 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1182 */	0x97,		/* 151 */
			0x6f,		/* 111 */
/* 1184 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 1186 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 1188 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 1190 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1192 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1194) */
/* 1194 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1196 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 1200 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 1202 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1204 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 1206 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 1208 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 1210 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 1212 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1214 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1216) */
/* 1216 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1218 */	NdrFcLong( 0x4a2a1ec9 ),	/* 1244274377 */
/* 1222 */	NdrFcShort( 0x85ec ),	/* -31252 */
/* 1224 */	NdrFcShort( 0x4bfb ),	/* 19451 */
/* 1226 */	0x9f,		/* 159 */
			0x15,		/* 21 */
/* 1228 */	0xa8,		/* 168 */
			0x9f,		/* 159 */
/* 1230 */	0xdf,		/* 223 */
			0xe0,		/* 224 */
/* 1232 */	0xfe,		/* 254 */
			0x83,		/* 131 */
/* 1234 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1244 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1246 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1248 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1250 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1252 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1254 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1256) */
/* 1256 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1258 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 1262 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 1264 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 1266 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 1268 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 1270 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 1272 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 1274 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1276 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1278) */
/* 1278 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1280 */	NdrFcLong( 0xcc7bcb03 ),	/* -864302333 */
/* 1284 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1286 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1288 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1290 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1292 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1294 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1296 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1298 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1300) */
/* 1300 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1302 */	NdrFcLong( 0xcc7bcb04 ),	/* -864302332 */
/* 1306 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1308 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1310 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1312 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1314 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1316 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1318 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1320 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1322 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1324 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1326 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 1328 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1330 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1332 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1334 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1336 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1338 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1340 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1342 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1344) */
/* 1344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1346 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 1350 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1352 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1354 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1356 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1358 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1360 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1362 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1364 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1366 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1370) */
/* 1370 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1372 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 1376 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 1378 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1380 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 1382 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 1384 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 1386 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 1388 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1390 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1392) */
/* 1392 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1394 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 1398 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 1400 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1402 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 1404 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 1406 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 1408 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 1410 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1412 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1414) */
/* 1414 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1416 */	NdrFcLong( 0xcc7bcb09 ),	/* -864302327 */
/* 1420 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1422 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1424 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1426 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1428 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1430 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1432 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1434 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1436 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 1438 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1440 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1444 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1446 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1448 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1450 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1452 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1454 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 1456 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1458 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1460 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1462 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1464 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1466 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1468 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1470 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1472 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1474 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1478) */
/* 1476 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1478 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1484 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1486 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1476) */
/* 1488 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1490 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1492) */
/* 1492 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1494 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 1498 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 1500 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 1502 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 1504 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 1506 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 1508 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 1510 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1514) */
/* 1514 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1516 */	NdrFcLong( 0xcc7bcb02 ),	/* -864302334 */
/* 1520 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1522 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1524 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1526 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1528 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1530 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1532 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1534 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1536 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1538 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1540 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1542 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1544 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1546 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1548 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1550 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1552 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1554 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1556 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1558 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1560 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1562 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1564 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1566 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1568 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1570 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1572 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1574 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1576 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1578 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1580 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1582 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1584 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1586 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1588 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1590 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1594 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1596 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1598 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1600 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1602 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1604 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1606 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1608) */
/* 1608 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1610 */	NdrFcLong( 0x63ca1b24 ),	/* 1674189604 */
/* 1614 */	NdrFcShort( 0x4359 ),	/* 17241 */
/* 1616 */	NdrFcShort( 0x4883 ),	/* 18563 */
/* 1618 */	0xbd,		/* 189 */
			0x57,		/* 87 */
/* 1620 */	0x13,		/* 19 */
			0xf8,		/* 248 */
/* 1622 */	0x15,		/* 21 */
			0xf5,		/* 245 */
/* 1624 */	0x87,		/* 135 */
			0x44,		/* 68 */
/* 1626 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1628 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1630) */
/* 1630 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1632 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 1636 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1638 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1640 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1642 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1644 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1646 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1648 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1650 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1652) */
/* 1652 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1654 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 1658 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 1660 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 1662 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 1664 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 1666 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 1668 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 1670 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1672 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1674 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1676 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1678 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1680 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1682) */
/* 1682 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1684 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 1688 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1690 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1692 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1694 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1696 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1698 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1700 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1702 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1704 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1706 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1708) */
/* 1708 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1710 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 1714 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 1716 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 1718 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 1720 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 1722 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 1724 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 1726 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1728 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1730) */
/* 1730 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1732 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 1736 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1738 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1740 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1742 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1744 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1746 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1748 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1750 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1752 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1754 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1756 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1758 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1760 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1764 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1766 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1768 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1770 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1752) */
/* 1772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1774 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1776 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 1778 */	
			0x1c,		/* FC_CVARRAY */
			0x7,		/* 7 */
/* 1780 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1782 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1784 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1786 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1790 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1792 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1794 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1796 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1798 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1800 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1802 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1804 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1806 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1808 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1810 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1812 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1814 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1816 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1818 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1820 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1822 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1824 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1826 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1828 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1830 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1832 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1834) */
/* 1834 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1836 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 1840 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 1842 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1844 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 1846 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 1848 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 1850 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 1852 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1854 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1856 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1858 */	NdrFcShort( 0x4 ),	/* Offset= 4 (1862) */
/* 1860 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1862 */	0xb4,		/* FC_USER_MARSHAL */
			0x3,		/* 3 */
/* 1864 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1866 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1868 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1870 */	NdrFcShort( 0xfffffff6 ),	/* Offset= -10 (1860) */
/* 1872 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1874 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1876) */
/* 1876 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1878 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 1882 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 1884 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1886 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 1888 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 1890 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 1892 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 1894 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1896 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 1898 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1900 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 1902 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1904 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1906) */
/* 1906 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1908 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 1912 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1914 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1916 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1918 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1920 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1922 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1924 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1926 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1928) */
/* 1928 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1930 */	NdrFcLong( 0xcc7bcaec ),	/* -864302356 */
/* 1934 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1936 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1938 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1940 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1942 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1944 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1946 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1948 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1950) */
/* 1950 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1952 */	NdrFcLong( 0xcc7bcb08 ),	/* -864302328 */
/* 1956 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1958 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1960 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1962 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1964 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1966 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1968 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1970 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1972) */
/* 1972 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1974 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 1978 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 1980 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 1982 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 1984 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1986 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1988 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 1990 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1992 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1994) */
/* 1994 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1996 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 2000 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2002 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2004 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2006 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2008 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2010 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2012 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2014 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2016) */
/* 2016 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2018 */	NdrFcLong( 0xcc7bcb0b ),	/* -864302325 */
/* 2022 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2024 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2026 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2028 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2030 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2032 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2034 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2036 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2038) */
/* 2038 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2040 */	NdrFcLong( 0xcc7bcaf6 ),	/* -864302346 */
/* 2044 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2046 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2048 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2050 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2052 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2054 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2056 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2060) */
/* 2060 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2062 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2066 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2068 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2070 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2072 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2074 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2076 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2078 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2080 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2082) */
/* 2082 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2084 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 2088 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 2090 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 2092 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 2094 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 2096 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 2098 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 2100 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2102 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2104 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2106 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2108 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2110 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2112) */
/* 2112 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2114 */	NdrFcLong( 0xcc7bcb00 ),	/* -864302336 */
/* 2118 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2120 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2122 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2124 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2126 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2128 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2130 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2132 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2134) */
/* 2134 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2136 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 2140 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2142 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2144 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2146 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2148 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2150 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2152 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2154 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2156) */
/* 2156 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2158 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 2162 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2164 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2166 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2168 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2170 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2172 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2174 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2178) */
/* 2178 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2180 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 2184 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2186 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2188 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2190 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2192 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2194 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2196 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2200) */
/* 2200 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2202 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 2206 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2208 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2210 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2212 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2214 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2216 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2218 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2220 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2222 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2224 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2226) */
/* 2226 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2228 */	NdrFcLong( 0xcc7bcb07 ),	/* -864302329 */
/* 2232 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2234 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2236 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2238 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2240 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2242 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2244 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2246 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2248) */
/* 2248 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2250 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 2254 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2256 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2258 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2260 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2262 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2264 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2266 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2268 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2270) */
/* 2270 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2272 */	NdrFcLong( 0xcc7bcb0b ),	/* -864302325 */
/* 2276 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2278 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2280 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2282 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2284 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2286 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2288 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2290 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 2292 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2296) */
/* 2296 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2298 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 2302 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2304 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2306 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2308 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2310 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2312 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2314 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2316 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2318) */
/* 2318 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2320 */	NdrFcLong( 0xcc7bcaf4 ),	/* -864302348 */
/* 2324 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2326 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2328 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2330 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2332 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2334 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2336 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2338 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2340) */
/* 2340 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2342 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 2346 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2348 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2350 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2352 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2354 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2356 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2358 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2360 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2362 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2364 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2366 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2368 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2370 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2372 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2374) */
/* 2374 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2376 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 2380 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2382 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2384 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2386 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2388 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2390 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2392 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2394 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2396) */
/* 2396 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2398 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 2402 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2404 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2406 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2408 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2410 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2412 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2414 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2416 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2418) */
/* 2418 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2420 */	NdrFcLong( 0xcc7bcaec ),	/* -864302356 */
/* 2424 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2426 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2428 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2430 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2432 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2434 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2436 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2438 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2440 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2442 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 2444 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2446 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2448) */
/* 2448 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2450 */	NdrFcLong( 0xcc7bcb0a ),	/* -864302326 */
/* 2454 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2456 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2458 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2460 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2462 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2464 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2466 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2468 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2470) */
/* 2470 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2472 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2476 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2478 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2480 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2482 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2484 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2486 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2488 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2490 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2492) */
/* 2492 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2494 */	NdrFcLong( 0xcc7bcb0a ),	/* -864302326 */
/* 2498 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2500 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2502 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2504 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2506 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2508 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2510 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2514) */
/* 2514 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2516 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2520 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2522 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2524 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2526 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2528 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2530 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2532 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2534 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2536 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2538 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2540) */
/* 2540 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2542 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2546 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2548 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2550 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2552 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2554 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2556 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2558 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2560 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2562 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2564 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2566) */
/* 2566 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2568 */	NdrFcLong( 0xcc7bcb0b ),	/* -864302325 */
/* 2572 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2574 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2576 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2578 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2580 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2582 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2584 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2586 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2588) */
/* 2588 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2590 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2594 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2596 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2598 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2600 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2602 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2604 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2606 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2608 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2610) */
/* 2610 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2612 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2616 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2618 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2620 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2622 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2624 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2626 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2628 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2630 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2632) */
/* 2632 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2634 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2638 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2640 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2642 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2644 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2646 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2648 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2650 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2652 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2654) */
/* 2654 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2656 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2660 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2662 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2664 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2666 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2668 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2670 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2672 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2674 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2676) */
/* 2676 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2678 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2682 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2684 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2686 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2688 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2690 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2692 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2694 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2696 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2698) */
/* 2698 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2700 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 2704 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 2706 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 2708 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 2710 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 2712 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 2714 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 2716 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2718 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2720 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2722 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2724) */
/* 2724 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2726 */	NdrFcLong( 0xdf59507c ),	/* -547794820 */
/* 2730 */	NdrFcShort( 0xd47a ),	/* -11142 */
/* 2732 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 2734 */	0xbc,		/* 188 */
			0xe2,		/* 226 */
/* 2736 */	0x64,		/* 100 */
			0x27,		/* 39 */
/* 2738 */	0xea,		/* 234 */
			0xc8,		/* 200 */
/* 2740 */	0xfd,		/* 253 */
			0x6,		/* 6 */
/* 2742 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2744 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2746 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 2748 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2750 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2752 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2754 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2758 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 2760 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2762 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2764) */
/* 2764 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2766 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 2770 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2772 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2774 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2776 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2778 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2780 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2782 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2784 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2786) */
/* 2786 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2788 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 2792 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2794 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2796 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2798 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2800 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2802 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2804 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2806 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2808) */
/* 2808 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2810 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 2814 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2816 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2818 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2820 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2822 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2824 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2826 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2828 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2830) */
/* 2830 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2832 */	NdrFcLong( 0xcc7bcaea ),	/* -864302358 */
/* 2836 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2838 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2840 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2842 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2844 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2846 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2848 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2850 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2852) */
/* 2852 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2854 */	NdrFcLong( 0x6dc3fa01 ),	/* 1841560065 */
/* 2858 */	NdrFcShort( 0xd7cb ),	/* -10293 */
/* 2860 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2862 */	0x8a,		/* 138 */
			0x95,		/* 149 */
/* 2864 */	0x0,		/* 0 */
			0x80,		/* 128 */
/* 2866 */	0xc7,		/* 199 */
			0x92,		/* 146 */
/* 2868 */	0xe5,		/* 229 */
			0xd8,		/* 216 */
/* 2870 */	
			0x11, 0x0,	/* FC_RP */
/* 2872 */	NdrFcShort( 0x8 ),	/* Offset= 8 (2880) */
/* 2874 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 2876 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2878 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 2880 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 2882 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2884 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 2886 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2888 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (2874) */
			0x5b,		/* FC_END */
/* 2892 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2894 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2896) */
/* 2896 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2898 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2906 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2908 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2910 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2912 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2914 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2916 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2918 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2920 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2922 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2924 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2926) */
/* 2926 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2928 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 2932 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2934 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2936 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2938 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2940 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2942 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2944 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2946 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2948 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2950 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2952 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2954 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2956) */
/* 2956 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2958 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 2962 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 2964 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 2966 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 2968 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 2970 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 2972 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 2974 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2976 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2978) */
/* 2978 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2980 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 2984 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 2986 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2988 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 2990 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2992 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 2994 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 2996 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 2998 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3000 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3002 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3004) */
/* 3004 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3006 */	NdrFcLong( 0xcc7bcaf4 ),	/* -864302348 */
/* 3010 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3012 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3014 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3016 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3018 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3020 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3022 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3024 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3026) */
/* 3026 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3028 */	NdrFcLong( 0xcc7bcaf4 ),	/* -864302348 */
/* 3032 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3034 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3036 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3038 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3040 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3042 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3044 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3046 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3048) */
/* 3048 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3050 */	NdrFcLong( 0xcc7bcae9 ),	/* -864302359 */
/* 3054 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3056 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3058 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3060 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3062 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3064 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3066 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3068 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3070 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3072 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3074 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3076 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3078 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3080 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3082) */
/* 3082 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3084 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 3088 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3090 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3092 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3094 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3096 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3098 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3100 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3102 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 3104 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3106 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3108 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3110 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3112) */
/* 3112 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3114 */	NdrFcLong( 0xcc7bcae9 ),	/* -864302359 */
/* 3118 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3120 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3122 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3124 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3126 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3128 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3130 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 3132 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3134 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3138 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3140 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3142 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 3144 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3146 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3148 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3150 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3152 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3154 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3156 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 3158 */	NdrFcShort( 0xc ),	/* 12 */
/* 3160 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 3162 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3164 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 3166 */	NdrFcShort( 0xc ),	/* 12 */
/* 3168 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3172 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3174 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3176 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3178 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (3156) */
/* 3180 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3182 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3184 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3186 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 3188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3190 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3192 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3194 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3196 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3198 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3200 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3202 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3204) */
/* 3204 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3206 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 3210 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 3212 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 3214 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 3216 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 3218 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 3220 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 3222 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3224 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3226 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3228 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 3232 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3234 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3236 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3238 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3240 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3242 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3244 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3246 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3248) */
/* 3248 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3250 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3254 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3256 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3258 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3260 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3262 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3264 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3266 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3268 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 3272 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3274 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3276 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3278 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3280 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3282 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3284 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3286 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3290 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3292 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3294 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3296 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3298 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3300 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3302 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3304 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3306 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3310 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3314 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3316 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3284) */
/* 3318 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3320 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3322 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 3326 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3328 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3330 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3332 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3334 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3336 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3338 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3340 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3344 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3346 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3348 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3350 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3352 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3354 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3356 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3360 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3362 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3364 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3368 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3370 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3338) */
/* 3372 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3374 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3376 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 3380 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3382 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3384 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3386 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3388 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3390 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3392 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 3394 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3396 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3398 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 3402 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3404 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3406 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3408 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3410 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3412 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3414 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 3416 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3418 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3420 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3422 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3424 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 3426 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3428 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3430 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3432 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3434 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3436 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3438 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3442) */
/* 3442 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3444 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3448 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3450 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3452 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3454 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3456 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3458 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3460 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3462 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3464) */
/* 3464 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3466 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 3470 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 3472 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 3474 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 3476 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 3478 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 3480 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 3482 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3484 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 3488 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3490 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3492 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3494 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3496 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3498 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3500 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3502 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3504) */
/* 3504 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3506 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3510 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3512 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3514 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3516 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3518 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3520 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3522 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3524 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3526 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3528 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3530 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3532 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 3534 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3536 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3538) */
/* 3538 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3540 */	NdrFcLong( 0xcc7bcaeb ),	/* -864302357 */
/* 3544 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3546 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3548 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3550 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3552 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3554 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3556 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3558 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3560 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3562 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 3564 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3566 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3568) */
/* 3568 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3570 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3574 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3576 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3578 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3580 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3582 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3584 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3586 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3590) */
/* 3590 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3592 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3596 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3598 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3600 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3602 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3604 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3606 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3608 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3610 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3612 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3614 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3616) */
/* 3616 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3618 */	NdrFcLong( 0xcc7bcaeb ),	/* -864302357 */
/* 3622 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3624 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3626 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3628 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3630 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3632 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3634 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3638) */
/* 3638 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3640 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 3644 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3646 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3648 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3650 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3652 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3654 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3656 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3658 */	NdrFcLong( 0xcc7bcaf5 ),	/* -864302347 */
/* 3662 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3664 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3666 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3668 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3670 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3672 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3674 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3676 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3678) */
/* 3678 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3680 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3684 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3686 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3688 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3690 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3692 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3694 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3696 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3698 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3700) */
/* 3700 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3702 */	NdrFcLong( 0xcc7bcaf3 ),	/* -864302349 */
/* 3706 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3708 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3710 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3712 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3714 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3716 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3718 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3720 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3722) */
/* 3722 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3724 */	NdrFcLong( 0xcc7bcb00 ),	/* -864302336 */
/* 3728 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3730 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3732 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3734 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3736 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3738 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3740 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3742 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3744 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3746 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3748) */
/* 3748 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3750 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3758 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 3760 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3762 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3764 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 3766 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3776 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 3778 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3780 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3782 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 3784 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3786 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3788) */
/* 3788 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3790 */	NdrFcLong( 0x18ad3d6e ),	/* 414006638 */
/* 3794 */	NdrFcShort( 0xb7d2 ),	/* -18478 */
/* 3796 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3798 */	0xbd,		/* 189 */
			0x4,		/* 4 */
/* 3800 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3802 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3804 */	0x49,		/* 73 */
			0xbd,		/* 189 */
/* 3806 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3808 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3810 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3812 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3814 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 3816 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3818 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3820 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3822 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3826 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 3828 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3830 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3832 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3834 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3836 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3838 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3840 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 3842 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3844 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3846 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3848 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3852 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3854 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3856 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3858 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 3860 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3862 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3864 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3866 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3868 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3870 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3872 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 3874 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3876 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3878 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3880 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3882 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3884 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3886 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3888 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3890) */
/* 3890 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3892 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3896 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3898 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3900 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3902 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3904 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3906 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3908 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3910 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3912) */
/* 3912 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3914 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 3918 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3920 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3922 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3924 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3926 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3928 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3930 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3932 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3934) */
/* 3934 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3936 */	NdrFcLong( 0xcc7bcb01 ),	/* -864302335 */
/* 3940 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3942 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3944 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3946 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3948 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3950 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3952 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3954 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3956 */	
			0x1c,		/* FC_CVARRAY */
			0x7,		/* 7 */
/* 3958 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3960 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3962 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3964 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3966 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3968 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3970 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3972 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3974 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3976 */	NdrFcLong( 0xcc7bcae8 ),	/* -864302360 */
/* 3980 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 3982 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 3984 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 3986 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 3988 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 3990 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 3992 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3996 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3998 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4000 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4002 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4004 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4006 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3974) */
/* 4008 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4010 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4012 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4014 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4016 */	NdrFcLong( 0xcc7bcaec ),	/* -864302356 */
/* 4020 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 4022 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 4024 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 4026 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4028 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 4030 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 4032 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4036 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4038 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4040 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4042 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4044 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4046 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4014) */
/* 4048 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4050 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4052 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4054 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4056 */	NdrFcLong( 0x3d6f5f64 ),	/* 1030709092 */
/* 4060 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 4062 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 4064 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 4066 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 4068 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 4070 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 4072 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4076 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4078 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4080 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4082 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4084 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4086 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4054) */
/* 4088 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4090 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4092 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4094 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4096 */	NdrFcLong( 0x938c6d66 ),	/* -1819513498 */
/* 4100 */	NdrFcShort( 0x7fb6 ),	/* 32694 */
/* 4102 */	NdrFcShort( 0x4f69 ),	/* 20329 */
/* 4104 */	0xb3,		/* 179 */
			0x89,		/* 137 */
/* 4106 */	0x42,		/* 66 */
			0x5b,		/* 91 */
/* 4108 */	0x89,		/* 137 */
			0x87,		/* 135 */
/* 4110 */	0x32,		/* 50 */
			0x9b,		/* 155 */
/* 4112 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4116 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4118 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4120 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4124 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4126 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4094) */
/* 4128 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4130 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4132 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4134 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4136 */	NdrFcLong( 0xcc7bcaef ),	/* -864302353 */
/* 4140 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 4142 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 4144 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 4146 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4148 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 4150 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 4152 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4156 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4160 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4162 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4164 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4166 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4134) */
/* 4168 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4170 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4172 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4174 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4176 */	NdrFcLong( 0xcc7bcaee ),	/* -864302354 */
/* 4180 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 4182 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 4184 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 4186 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4188 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 4190 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 4192 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4196 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4200 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4202 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4206 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4174) */
/* 4208 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4210 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4212 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4214 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4216 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 4220 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 4222 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 4224 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 4226 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 4228 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 4230 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 4232 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4236 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4238 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4240 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4244 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4246 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4214) */
/* 4248 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4250 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4252 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4254 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4256 */	NdrFcLong( 0xcc7bcaf7 ),	/* -864302345 */
/* 4260 */	NdrFcShort( 0x8a68 ),	/* -30104 */
/* 4262 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 4264 */	0x98,		/* 152 */
			0x3c,		/* 60 */
/* 4266 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4268 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 4270 */	0x34,		/* 52 */
			0x2d,		/* 45 */
/* 4272 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4276 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4280 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4282 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4286 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4254) */
/* 4288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4290 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4292 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4294 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4296 */	NdrFcLong( 0x8d600d41 ),	/* -1923084991 */
/* 4300 */	NdrFcShort( 0xf4f6 ),	/* -2826 */
/* 4302 */	NdrFcShort( 0x4cb3 ),	/* 19635 */
/* 4304 */	0xb7,		/* 183 */
			0xec,		/* 236 */
/* 4306 */	0x7b,		/* 123 */
			0xd1,		/* 209 */
/* 4308 */	0x64,		/* 100 */
			0x94,		/* 148 */
/* 4310 */	0x40,		/* 64 */
			0x36,		/* 54 */
/* 4312 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4316 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4318 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4320 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4322 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4324 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4326 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4294) */
/* 4328 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4330 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4332 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4334 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4336 */	NdrFcLong( 0x3d6f5f63 ),	/* 1030709091 */
/* 4340 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 4342 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 4344 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 4346 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 4348 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 4350 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 4352 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4356 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4358 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4360 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4364 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4366 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4334) */
/* 4368 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4370 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4372 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4374 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4376 */	NdrFcLong( 0xdf59507c ),	/* -547794820 */
/* 4380 */	NdrFcShort( 0xd47a ),	/* -11142 */
/* 4382 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 4384 */	0xbc,		/* 188 */
			0xe2,		/* 226 */
/* 4386 */	0x64,		/* 100 */
			0x27,		/* 39 */
/* 4388 */	0xea,		/* 234 */
			0xc8,		/* 200 */
/* 4390 */	0xfd,		/* 253 */
			0x6,		/* 6 */
/* 4392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4396 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4398 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4400 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4402 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4404 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4406 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4374) */
/* 4408 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4410 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4412 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4414 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4416 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4418) */
/* 4418 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4420 */	NdrFcLong( 0xdba2d8c1 ),	/* -610084671 */
/* 4424 */	NdrFcShort( 0xe5c5 ),	/* -6715 */
/* 4426 */	NdrFcShort( 0x4069 ),	/* 16489 */
/* 4428 */	0x8c,		/* 140 */
			0x13,		/* 19 */
/* 4430 */	0x10,		/* 16 */
			0xa7,		/* 167 */
/* 4432 */	0xc6,		/* 198 */
			0xab,		/* 171 */
/* 4434 */	0xf4,		/* 244 */
			0x3d,		/* 61 */
/* 4436 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4438 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4440 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4442 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4444 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4446 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4448 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 4450 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4452 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4454 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4456 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4458 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4460 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 4462 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4464 */	NdrFcLong( 0xc ),	/* 12 */
/* 4468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4472 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 4474 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4476 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4478 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 4480 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4482 */	NdrFcShort( 0xfffff9be ),	/* Offset= -1602 (2880) */
/* 4484 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4486 */	NdrFcShort( 0xfffff9ba ),	/* Offset= -1606 (2880) */
/* 4488 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4490 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4492 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 4494 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 4496 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4498 */	NdrFcLong( 0xc ),	/* 12 */
/* 4502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4506 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 4508 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4510 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4512 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 4514 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 4516 */	NdrFcShort( 0xc ),	/* 12 */
/* 4518 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 4520 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4522 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4524 */	NdrFcShort( 0xc ),	/* 12 */
/* 4526 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4528 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4532 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (4514) */
/* 4534 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4536 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4538 */	NdrFcLong( 0xc ),	/* 12 */
/* 4542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4546 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 4548 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4550 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4552 */	0x0,		/* 0 */
			0x46,		/* 70 */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HPROCESS_UserSize
            ,HPROCESS_UserMarshal
            ,HPROCESS_UserUnmarshal
            ,HPROCESS_UserFree
            },
            {
            HTHREAD_UserSize
            ,HTHREAD_UserMarshal
            ,HTHREAD_UserUnmarshal
            ,HTHREAD_UserFree
            }

        };



/* Standard interface: __MIDL_itf_cordebug_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICorDebugManagedCallback, ver. 0.0,
   GUID={0x3d6f5f60,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugManagedCallback_FormatStringOffsetTable[] =
    {
    0,
    40,
    86,
    120,
    160,
    200,
    240,
    268,
    296,
    330,
    364,
    398,
    432,
    466,
    500,
    540,
    592,
    650,
    684,
    718,
    752,
    786,
    814,
    848,
    888,
    934
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugManagedCallback_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugManagedCallback_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugManagedCallback_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugManagedCallback_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(29) _ICorDebugManagedCallbackProxyVtbl = 
{
    &ICorDebugManagedCallback_ProxyInfo,
    &IID_ICorDebugManagedCallback,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::Breakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::StepComplete */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::Break */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::Exception */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::EvalComplete */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::EvalException */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::CreateProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::ExitProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::CreateThread */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::ExitThread */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::LoadModule */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::UnloadModule */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::LoadClass */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::UnloadClass */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::DebuggerError */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::LogMessage */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::LogSwitch */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::CreateAppDomain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::ExitAppDomain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::LoadAssembly */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::UnloadAssembly */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::ControlCTrap */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::NameChange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::UpdateModuleSymbols */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::EditAndContinueRemap */ ,
    (void *) (INT_PTR) -1 /* ICorDebugManagedCallback::BreakpointSetError */
};

const CInterfaceStubVtbl _ICorDebugManagedCallbackStubVtbl =
{
    &IID_ICorDebugManagedCallback,
    &ICorDebugManagedCallback_ServerInfo,
    29,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugUnmanagedCallback, ver. 0.0,
   GUID={0x5263E909,0x8CB5,0x11d3,{0xBD,0x2F,0x00,0x00,0xF8,0x08,0x49,0xBD}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugUnmanagedCallback_FormatStringOffsetTable[] =
    {
    980
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugUnmanagedCallback_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugUnmanagedCallback_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugUnmanagedCallback_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugUnmanagedCallback_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ICorDebugUnmanagedCallbackProxyVtbl = 
{
    &ICorDebugUnmanagedCallback_ProxyInfo,
    &IID_ICorDebugUnmanagedCallback,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugUnmanagedCallback::DebugEvent */
};

const CInterfaceStubVtbl _ICorDebugUnmanagedCallbackStubVtbl =
{
    &IID_ICorDebugUnmanagedCallback,
    &ICorDebugUnmanagedCallback_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_cordebug_0112, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorDebug, ver. 0.0,
   GUID={0x3d6f5f61,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */


/* Standard interface: __MIDL_itf_cordebug_0113, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorDebugController, ver. 0.0,
   GUID={0x3d6f5f62,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugController_FormatStringOffsetTable[] =
    {
    1014,
    1042,
    1070,
    1098,
    1132,
    1160,
    1194,
    1216,
    1244,
    1284
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugController_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugController_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugController_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugController_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _ICorDebugControllerProxyVtbl = 
{
    &ICorDebugController_ProxyInfo,
    &IID_ICorDebugController,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Stop */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Continue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::IsRunning */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::HasQueuedCallbacks */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::EnumerateThreads */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::SetAllThreadsDebugState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Detach */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Terminate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CanCommitChanges */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CommitChanges */
};

const CInterfaceStubVtbl _ICorDebugControllerStubVtbl =
{
    &IID_ICorDebugController,
    &ICorDebugController_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugAppDomain, ver. 0.0,
   GUID={0x3d6f5f63,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugAppDomain_FormatStringOffsetTable[] =
    {
    1014,
    1042,
    1070,
    1098,
    1132,
    1160,
    1194,
    1216,
    1244,
    1284,
    1324,
    1352,
    1380,
    1414,
    1442,
    1470,
    1498,
    1538,
    1566,
    1588
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugAppDomain_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAppDomain_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugAppDomain_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAppDomain_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(23) _ICorDebugAppDomainProxyVtbl = 
{
    &ICorDebugAppDomain_ProxyInfo,
    &IID_ICorDebugAppDomain,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Stop */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Continue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::IsRunning */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::HasQueuedCallbacks */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::EnumerateThreads */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::SetAllThreadsDebugState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Detach */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Terminate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CanCommitChanges */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CommitChanges */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::GetProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::EnumerateAssemblies */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::GetModuleFromMetaDataInterface */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::EnumerateBreakpoints */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::EnumerateSteppers */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::IsAttached */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::GetName */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::GetObject */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::Attach */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomain::GetID */
};

const CInterfaceStubVtbl _ICorDebugAppDomainStubVtbl =
{
    &IID_ICorDebugAppDomain,
    &ICorDebugAppDomain_ServerInfo,
    23,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugAssembly, ver. 0.0,
   GUID={0xdf59507c,0xd47a,0x459e,{0xbc,0xe2,0x64,0x27,0xea,0xc8,0xfd,0x06}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugAssembly_FormatStringOffsetTable[] =
    {
    1616,
    1644,
    1672,
    1700,
    1740
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugAssembly_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAssembly_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugAssembly_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAssembly_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugAssemblyProxyVtbl = 
{
    &ICorDebugAssembly_ProxyInfo,
    &IID_ICorDebugAssembly,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugAssembly::GetProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAssembly::GetAppDomain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAssembly::EnumerateModules */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAssembly::GetCodeBase */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAssembly::GetName */
};

const CInterfaceStubVtbl _ICorDebugAssemblyStubVtbl =
{
    &IID_ICorDebugAssembly,
    &ICorDebugAssembly_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugProcess, ver. 0.0,
   GUID={0x3d6f5f64,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugProcess_FormatStringOffsetTable[] =
    {
    1014,
    1042,
    1070,
    1098,
    1132,
    1160,
    1194,
    1216,
    1244,
    1284,
    1780,
    1808,
    1836,
    1870,
    1898,
    1932,
    1966,
    2006,
    2046,
    2092,
    2138,
    2166,
    2194,
    2228,
    2256,
    2284,
    2318
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugProcess_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugProcess_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(30) _ICorDebugProcessProxyVtbl = 
{
    &ICorDebugProcess_ProxyInfo,
    &IID_ICorDebugProcess,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Stop */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Continue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::IsRunning */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::HasQueuedCallbacks */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::EnumerateThreads */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::SetAllThreadsDebugState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Detach */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::Terminate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CanCommitChanges */ ,
    (void *) (INT_PTR) -1 /* ICorDebugController::CommitChanges */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetID */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetHandle */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetThread */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::EnumerateObjects */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::IsTransitionStub */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::IsOSSuspended */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetThreadContext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::SetThreadContext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::ReadMemory */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::WriteMemory */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::ClearCurrentException */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::EnableLogMessages */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::ModifyLogSwitch */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::EnumerateAppDomains */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetObject */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::ThreadForFiberCookie */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcess::GetHelperThreadID */
};

const CInterfaceStubVtbl _ICorDebugProcessStubVtbl =
{
    &IID_ICorDebugProcess,
    &ICorDebugProcess_ServerInfo,
    30,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugBreakpoint, ver. 0.0,
   GUID={0xCC7BCAE8,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugBreakpoint_FormatStringOffsetTable[] =
    {
    2346,
    2374
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugBreakpoint_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugBreakpoint_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorDebugBreakpointProxyVtbl = 
{
    &ICorDebugBreakpoint_ProxyInfo,
    &IID_ICorDebugBreakpoint,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::Activate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::IsActive */
};

const CInterfaceStubVtbl _ICorDebugBreakpointStubVtbl =
{
    &IID_ICorDebugBreakpoint,
    &ICorDebugBreakpoint_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugFunctionBreakpoint, ver. 0.0,
   GUID={0xCC7BCAE9,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugFunctionBreakpoint_FormatStringOffsetTable[] =
    {
    2346,
    2374,
    2402,
    2430
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugFunctionBreakpoint_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFunctionBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugFunctionBreakpoint_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFunctionBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorDebugFunctionBreakpointProxyVtbl = 
{
    &ICorDebugFunctionBreakpoint_ProxyInfo,
    &IID_ICorDebugFunctionBreakpoint,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::Activate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::IsActive */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunctionBreakpoint::GetFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunctionBreakpoint::GetOffset */
};

const CInterfaceStubVtbl _ICorDebugFunctionBreakpointStubVtbl =
{
    &IID_ICorDebugFunctionBreakpoint,
    &ICorDebugFunctionBreakpoint_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugModuleBreakpoint, ver. 0.0,
   GUID={0xCC7BCAEA,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugModuleBreakpoint_FormatStringOffsetTable[] =
    {
    2346,
    2374,
    2458
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugModuleBreakpoint_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModuleBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugModuleBreakpoint_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModuleBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICorDebugModuleBreakpointProxyVtbl = 
{
    &ICorDebugModuleBreakpoint_ProxyInfo,
    &IID_ICorDebugModuleBreakpoint,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::Activate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::IsActive */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModuleBreakpoint::GetModule */
};

const CInterfaceStubVtbl _ICorDebugModuleBreakpointStubVtbl =
{
    &IID_ICorDebugModuleBreakpoint,
    &ICorDebugModuleBreakpoint_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugValueBreakpoint, ver. 0.0,
   GUID={0xCC7BCAEB,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugValueBreakpoint_FormatStringOffsetTable[] =
    {
    2346,
    2374,
    2486
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugValueBreakpoint_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValueBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugValueBreakpoint_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValueBreakpoint_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICorDebugValueBreakpointProxyVtbl = 
{
    &ICorDebugValueBreakpoint_ProxyInfo,
    &IID_ICorDebugValueBreakpoint,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::Activate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpoint::IsActive */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValueBreakpoint::GetValue */
};

const CInterfaceStubVtbl _ICorDebugValueBreakpointStubVtbl =
{
    &IID_ICorDebugValueBreakpoint,
    &ICorDebugValueBreakpoint_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugStepper, ver. 0.0,
   GUID={0xCC7BCAEC,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugStepper_FormatStringOffsetTable[] =
    {
    2514,
    2542,
    2564,
    2592,
    2620,
    2648,
    2688,
    2710
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugStepper_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStepper_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugStepper_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStepper_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _ICorDebugStepperProxyVtbl = 
{
    &ICorDebugStepper_ProxyInfo,
    &IID_ICorDebugStepper,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::IsActive */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::Deactivate */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::SetInterceptMask */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::SetUnmappedStopMask */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::Step */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::StepRange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::StepOut */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepper::SetRangeIL */
};

const CInterfaceStubVtbl _ICorDebugStepperStubVtbl =
{
    &IID_ICorDebugStepper,
    &ICorDebugStepper_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugRegisterSet, ver. 0.0,
   GUID={0xCC7BCB0B,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugRegisterSet_FormatStringOffsetTable[] =
    {
    2738,
    2766,
    2806,
    2846,
    2880
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugRegisterSet_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugRegisterSet_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugRegisterSet_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugRegisterSet_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugRegisterSetProxyVtbl = 
{
    &ICorDebugRegisterSet_ProxyInfo,
    &IID_ICorDebugRegisterSet,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugRegisterSet::GetRegistersAvailable */ ,
    (void *) (INT_PTR) -1 /* ICorDebugRegisterSet::GetRegisters */ ,
    (void *) (INT_PTR) -1 /* ICorDebugRegisterSet::SetRegisters */ ,
    (void *) (INT_PTR) -1 /* ICorDebugRegisterSet::GetThreadContext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugRegisterSet::SetThreadContext */
};

const CInterfaceStubVtbl _ICorDebugRegisterSetStubVtbl =
{
    &IID_ICorDebugRegisterSet,
    &ICorDebugRegisterSet_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugThread, ver. 0.0,
   GUID={0x938c6d66,0x7fb6,0x4f69,{0xb3,0x89,0x42,0x5b,0x89,0x87,0x32,0x9b}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugThread_FormatStringOffsetTable[] =
    {
    2914,
    2942,
    2970,
    2998,
    3026,
    3054,
    3082,
    3110,
    3138,
    3160,
    3188,
    3216,
    3244,
    3272,
    3300,
    3328
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugThread_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugThread_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugThread_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugThread_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(19) _ICorDebugThreadProxyVtbl = 
{
    &ICorDebugThread_ProxyInfo,
    &IID_ICorDebugThread,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetID */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetHandle */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetAppDomain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::SetDebugState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetDebugState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetUserState */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetCurrentException */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::ClearCurrentException */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::CreateStepper */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::EnumerateChains */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetActiveChain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetActiveFrame */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetRegisterSet */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::CreateEval */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThread::GetObject */
};

const CInterfaceStubVtbl _ICorDebugThreadStubVtbl =
{
    &IID_ICorDebugThread,
    &ICorDebugThread_ServerInfo,
    19,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugChain, ver. 0.0,
   GUID={0xCC7BCAEE,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugChain_FormatStringOffsetTable[] =
    {
    3356,
    3384,
    3418,
    3446,
    3474,
    3502,
    3530,
    3558,
    3586,
    3614,
    3642,
    3670
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugChain_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugChain_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugChain_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugChain_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(15) _ICorDebugChainProxyVtbl = 
{
    &ICorDebugChain_ProxyInfo,
    &IID_ICorDebugChain,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetThread */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetStackRange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetContext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetCaller */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetCallee */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetPrevious */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetNext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::IsManaged */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::EnumerateFrames */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetActiveFrame */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetRegisterSet */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChain::GetReason */
};

const CInterfaceStubVtbl _ICorDebugChainStubVtbl =
{
    &IID_ICorDebugChain,
    &ICorDebugChain_ServerInfo,
    15,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugFrame, ver. 0.0,
   GUID={0xCC7BCAEF,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugFrame_FormatStringOffsetTable[] =
    {
    3698,
    3726,
    3754,
    3782,
    3810,
    3844,
    3872,
    3900
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugFrame_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugFrame_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _ICorDebugFrameProxyVtbl = 
{
    &ICorDebugFrame_ProxyInfo,
    &IID_ICorDebugFrame,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetChain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunctionToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetStackRange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCaller */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCallee */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::CreateStepper */
};

const CInterfaceStubVtbl _ICorDebugFrameStubVtbl =
{
    &IID_ICorDebugFrame,
    &ICorDebugFrame_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugILFrame, ver. 0.0,
   GUID={0x03E26311,0x4F76,0x11d3,{0x88,0xC6,0x00,0x60,0x97,0x94,0x54,0x18}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugILFrame_FormatStringOffsetTable[] =
    {
    3698,
    3726,
    3754,
    3782,
    3810,
    3844,
    3872,
    3900,
    3928,
    3962,
    3990,
    4018,
    4052,
    4080,
    4114,
    4142,
    4176
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugILFrame_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugILFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugILFrame_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugILFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(20) _ICorDebugILFrameProxyVtbl = 
{
    &ICorDebugILFrame_ProxyInfo,
    &IID_ICorDebugILFrame,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetChain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunctionToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetStackRange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCaller */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCallee */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::CreateStepper */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::GetIP */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::SetIP */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::EnumerateLocalVariables */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::GetLocalVariable */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::EnumerateArguments */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::GetArgument */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::GetStackDepth */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::GetStackValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugILFrame::CanSetIP */
};

const CInterfaceStubVtbl _ICorDebugILFrameStubVtbl =
{
    &IID_ICorDebugILFrame,
    &ICorDebugILFrame_ServerInfo,
    20,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugNativeFrame, ver. 0.0,
   GUID={0x03E26314,0x4F76,0x11d3,{0x88,0xC6,0x00,0x60,0x97,0x94,0x54,0x18}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugNativeFrame_FormatStringOffsetTable[] =
    {
    3698,
    3726,
    3754,
    3782,
    3810,
    3844,
    3872,
    3900,
    4204,
    4232,
    4260,
    4288,
    4334,
    4386,
    4432,
    4484,
    4536
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugNativeFrame_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugNativeFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugNativeFrame_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugNativeFrame_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(20) _ICorDebugNativeFrameProxyVtbl = 
{
    &ICorDebugNativeFrame_ProxyInfo,
    &IID_ICorDebugNativeFrame,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetChain */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetFunctionToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetStackRange */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCaller */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::GetCallee */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrame::CreateStepper */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetIP */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::SetIP */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetRegisterSet */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetLocalRegisterValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetLocalDoubleRegisterValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetLocalMemoryValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetLocalRegisterMemoryValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::GetLocalMemoryRegisterValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugNativeFrame::CanSetIP */
};

const CInterfaceStubVtbl _ICorDebugNativeFrameStubVtbl =
{
    &IID_ICorDebugNativeFrame,
    &ICorDebugNativeFrame_ServerInfo,
    20,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugModule, ver. 0.0,
   GUID={0xdba2d8c1,0xe5c5,0x4069,{0x8c,0x13,0x10,0xa7,0xc6,0xab,0xf4,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugModule_FormatStringOffsetTable[] =
    {
    4564,
    4592,
    4620,
    4648,
    4688,
    4722,
    4750,
    4784,
    4818,
    4852,
    4880,
    4908,
    4942,
    4970,
    4998,
    5032,
    5060
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugModule_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModule_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugModule_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModule_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(20) _ICorDebugModuleProxyVtbl = 
{
    &ICorDebugModule_ProxyInfo,
    &IID_ICorDebugModule,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetProcess */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetBaseAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetAssembly */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetName */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::EnableJITDebugging */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::EnableClassLoadCallbacks */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetFunctionFromToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetFunctionFromRVA */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetClassFromToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetEditAndContinueSnapshot */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetMetaDataInterface */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::IsDynamic */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetGlobalVariableValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModule::IsInMemory */
};

const CInterfaceStubVtbl _ICorDebugModuleStubVtbl =
{
    &IID_ICorDebugModule,
    &ICorDebugModule_ServerInfo,
    20,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugFunction, ver. 0.0,
   GUID={0xCC7BCAF3,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugFunction_FormatStringOffsetTable[] =
    {
    5088,
    5116,
    5144,
    5172,
    5200,
    5228,
    5256,
    5284
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugFunction_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFunction_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugFunction_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFunction_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _ICorDebugFunctionProxyVtbl = 
{
    &ICorDebugFunction_ProxyInfo,
    &IID_ICorDebugFunction,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetModule */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetClass */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetILCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetNativeCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetLocalVarSigToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFunction::GetCurrentVersionNumber */
};

const CInterfaceStubVtbl _ICorDebugFunctionStubVtbl =
{
    &IID_ICorDebugFunction,
    &ICorDebugFunction_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugCode, ver. 0.0,
   GUID={0xCC7BCAF4,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugCode_FormatStringOffsetTable[] =
    {
    5312,
    5340,
    5368,
    5396,
    5424,
    5458,
    5510,
    5538,
    5578
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugCode_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugCode_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugCode_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugCode_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _ICorDebugCodeProxyVtbl = 
{
    &ICorDebugCode_ProxyInfo,
    &IID_ICorDebugCode,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::IsIL */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetVersionNumber */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetILToNativeMapping */ ,
    (void *) (INT_PTR) -1 /* ICorDebugCode::GetEnCRemapSequencePoints */
};

const CInterfaceStubVtbl _ICorDebugCodeStubVtbl =
{
    &IID_ICorDebugCode,
    &ICorDebugCode_ServerInfo,
    12,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugClass, ver. 0.0,
   GUID={0xCC7BCAF5,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugClass_FormatStringOffsetTable[] =
    {
    5618,
    5646,
    5674
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugClass_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugClass_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugClass_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugClass_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICorDebugClassProxyVtbl = 
{
    &ICorDebugClass_ProxyInfo,
    &IID_ICorDebugClass,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugClass::GetModule */ ,
    (void *) (INT_PTR) -1 /* ICorDebugClass::GetToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugClass::GetStaticFieldValue */
};

const CInterfaceStubVtbl _ICorDebugClassStubVtbl =
{
    &IID_ICorDebugClass,
    &ICorDebugClass_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugEval, ver. 0.0,
   GUID={0xCC7BCAF6,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugEval_FormatStringOffsetTable[] =
    {
    5714,
    5754,
    5794,
    5822,
    5850,
    5902,
    5930,
    5952,
    5980,
    6008
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugEval_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEval_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugEval_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEval_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _ICorDebugEvalProxyVtbl = 
{
    &ICorDebugEval_ProxyInfo,
    &IID_ICorDebugEval,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::CallFunction */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::NewObject */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::NewObjectNoConstructor */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::NewString */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::NewArray */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::IsActive */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::Abort */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::GetResult */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::GetThread */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEval::CreateValue */
};

const CInterfaceStubVtbl _ICorDebugEvalStubVtbl =
{
    &IID_ICorDebugEval,
    &ICorDebugEval_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugValue, ver. 0.0,
   GUID={0xCC7BCAF7,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorDebugValueProxyVtbl = 
{
    &ICorDebugValue_ProxyInfo,
    &IID_ICorDebugValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */
};

const CInterfaceStubVtbl _ICorDebugValueStubVtbl =
{
    &IID_ICorDebugValue,
    &ICorDebugValue_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugGenericValue, ver. 0.0,
   GUID={0xCC7BCAF8,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */


/* Object interface: ICorDebugReferenceValue, ver. 0.0,
   GUID={0xCC7BCAF9,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugReferenceValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6160,
    6188,
    6216,
    6244,
    6272
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugReferenceValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugReferenceValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugReferenceValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugReferenceValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _ICorDebugReferenceValueProxyVtbl = 
{
    &ICorDebugReferenceValue_ProxyInfo,
    &IID_ICorDebugReferenceValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugReferenceValue::IsNull */ ,
    (void *) (INT_PTR) -1 /* ICorDebugReferenceValue::GetValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugReferenceValue::SetValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugReferenceValue::Dereference */ ,
    (void *) (INT_PTR) -1 /* ICorDebugReferenceValue::DereferenceStrong */
};

const CInterfaceStubVtbl _ICorDebugReferenceValueStubVtbl =
{
    &IID_ICorDebugReferenceValue,
    &ICorDebugReferenceValue_ServerInfo,
    12,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugHeapValue, ver. 0.0,
   GUID={0xCC7BCAFA,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugHeapValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6300,
    6328
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugHeapValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugHeapValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugHeapValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugHeapValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _ICorDebugHeapValueProxyVtbl = 
{
    &ICorDebugHeapValue_ProxyInfo,
    &IID_ICorDebugHeapValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::IsValid */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::CreateRelocBreakpoint */
};

const CInterfaceStubVtbl _ICorDebugHeapValueStubVtbl =
{
    &IID_ICorDebugHeapValue,
    &ICorDebugHeapValue_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugObjectValue, ver. 0.0,
   GUID={0x18AD3D6E,0xB7D2,0x11d2,{0xBD,0x04,0x00,0x00,0xF8,0x08,0x49,0xBD}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugObjectValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6356,
    6384,
    6424,
    6458,
    6486,
    6514,
    6542
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugObjectValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugObjectValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugObjectValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugObjectValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _ICorDebugObjectValueProxyVtbl = 
{
    &ICorDebugObjectValue_ProxyInfo,
    &IID_ICorDebugObjectValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::GetClass */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::GetFieldValue */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::GetVirtualMethod */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::GetContext */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::IsValueClass */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::GetManagedCopy */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectValue::SetFromManagedCopy */
};

const CInterfaceStubVtbl _ICorDebugObjectValueStubVtbl =
{
    &IID_ICorDebugObjectValue,
    &ICorDebugObjectValue_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugBoxValue, ver. 0.0,
   GUID={0xCC7BCAFC,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugBoxValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6300,
    6328,
    6570
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugBoxValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBoxValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugBoxValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBoxValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _ICorDebugBoxValueProxyVtbl = 
{
    &ICorDebugBoxValue_ProxyInfo,
    &IID_ICorDebugBoxValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::IsValid */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::CreateRelocBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBoxValue::GetObject */
};

const CInterfaceStubVtbl _ICorDebugBoxValueStubVtbl =
{
    &IID_ICorDebugBoxValue,
    &ICorDebugBoxValue_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugStringValue, ver. 0.0,
   GUID={0xCC7BCAFD,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugStringValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6300,
    6328,
    6598,
    6626
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugStringValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStringValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugStringValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStringValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _ICorDebugStringValueProxyVtbl = 
{
    &ICorDebugStringValue_ProxyInfo,
    &IID_ICorDebugStringValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::IsValid */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::CreateRelocBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStringValue::GetLength */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStringValue::GetString */
};

const CInterfaceStubVtbl _ICorDebugStringValueStubVtbl =
{
    &IID_ICorDebugStringValue,
    &ICorDebugStringValue_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugArrayValue, ver. 0.0,
   GUID={0x0405B0DF,0xA660,0x11d2,{0xBD,0x02,0x00,0x00,0xF8,0x08,0x49,0xBD}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugArrayValue_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6300,
    6328,
    6666,
    6694,
    6722,
    6750,
    6784,
    6812,
    6846,
    6886
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugArrayValue_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugArrayValue_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugArrayValue_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugArrayValue_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _ICorDebugArrayValueProxyVtbl = 
{
    &ICorDebugArrayValue_ProxyInfo,
    &IID_ICorDebugArrayValue,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetSize */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::GetAddress */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValue::CreateBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::IsValid */ ,
    (void *) (INT_PTR) -1 /* ICorDebugHeapValue::CreateRelocBreakpoint */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetElementType */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetRank */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetDimensions */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::HasBaseIndicies */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetBaseIndicies */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetElement */ ,
    (void *) (INT_PTR) -1 /* ICorDebugArrayValue::GetElementAtPosition */
};

const CInterfaceStubVtbl _ICorDebugArrayValueStubVtbl =
{
    &IID_ICorDebugArrayValue,
    &ICorDebugArrayValue_ServerInfo,
    17,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugContext, ver. 0.0,
   GUID={0xCC7BCB00,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugContext_FormatStringOffsetTable[] =
    {
    6048,
    6076,
    6104,
    6132,
    6356,
    6384,
    6424,
    6458,
    6486,
    6514,
    6542,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugContext_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugContext_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugContext_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugContext_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _ICorDebugContextProxyVtbl = 
{
    0,
    &IID_ICorDebugContext,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* forced delegation ICorDebugValue::GetType */ ,
    0 /* forced delegation ICorDebugValue::GetSize */ ,
    0 /* forced delegation ICorDebugValue::GetAddress */ ,
    0 /* forced delegation ICorDebugValue::CreateBreakpoint */ ,
    0 /* forced delegation ICorDebugObjectValue::GetClass */ ,
    0 /* forced delegation ICorDebugObjectValue::GetFieldValue */ ,
    0 /* forced delegation ICorDebugObjectValue::GetVirtualMethod */ ,
    0 /* forced delegation ICorDebugObjectValue::GetContext */ ,
    0 /* forced delegation ICorDebugObjectValue::IsValueClass */ ,
    0 /* forced delegation ICorDebugObjectValue::GetManagedCopy */ ,
    0 /* forced delegation ICorDebugObjectValue::SetFromManagedCopy */
};


static const PRPC_STUB_FUNCTION ICorDebugContext_table[] =
{
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ICorDebugContextStubVtbl =
{
    &IID_ICorDebugContext,
    &ICorDebugContext_ServerInfo,
    14,
    &ICorDebugContext_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: ICorDebugEnum, ver. 0.0,
   GUID={0xCC7BCB01,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorDebugEnumProxyVtbl = 
{
    &ICorDebugEnum_ProxyInfo,
    &IID_ICorDebugEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */
};

const CInterfaceStubVtbl _ICorDebugEnumStubVtbl =
{
    &IID_ICorDebugEnum,
    &ICorDebugEnum_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugObjectEnum, ver. 0.0,
   GUID={0xCC7BCB02,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugObjectEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7026
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugObjectEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugObjectEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugObjectEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugObjectEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugObjectEnumProxyVtbl = 
{
    &ICorDebugObjectEnum_ProxyInfo,
    &IID_ICorDebugObjectEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugObjectEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugObjectEnumStubVtbl =
{
    &IID_ICorDebugObjectEnum,
    &ICorDebugObjectEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugBreakpointEnum, ver. 0.0,
   GUID={0xCC7BCB03,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugBreakpointEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7066
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugBreakpointEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBreakpointEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugBreakpointEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugBreakpointEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugBreakpointEnumProxyVtbl = 
{
    &ICorDebugBreakpointEnum_ProxyInfo,
    &IID_ICorDebugBreakpointEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugBreakpointEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugBreakpointEnumStubVtbl =
{
    &IID_ICorDebugBreakpointEnum,
    &ICorDebugBreakpointEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugStepperEnum, ver. 0.0,
   GUID={0xCC7BCB04,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugStepperEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7106
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugStepperEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStepperEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugStepperEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugStepperEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugStepperEnumProxyVtbl = 
{
    &ICorDebugStepperEnum_ProxyInfo,
    &IID_ICorDebugStepperEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugStepperEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugStepperEnumStubVtbl =
{
    &IID_ICorDebugStepperEnum,
    &ICorDebugStepperEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugProcessEnum, ver. 0.0,
   GUID={0xCC7BCB05,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugProcessEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7146
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugProcessEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugProcessEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugProcessEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugProcessEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugProcessEnumProxyVtbl = 
{
    &ICorDebugProcessEnum_ProxyInfo,
    &IID_ICorDebugProcessEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugProcessEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugProcessEnumStubVtbl =
{
    &IID_ICorDebugProcessEnum,
    &ICorDebugProcessEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugThreadEnum, ver. 0.0,
   GUID={0xCC7BCB06,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugThreadEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7186
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugThreadEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugThreadEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugThreadEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugThreadEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugThreadEnumProxyVtbl = 
{
    &ICorDebugThreadEnum_ProxyInfo,
    &IID_ICorDebugThreadEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugThreadEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugThreadEnumStubVtbl =
{
    &IID_ICorDebugThreadEnum,
    &ICorDebugThreadEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugFrameEnum, ver. 0.0,
   GUID={0xCC7BCB07,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugFrameEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7226
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugFrameEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFrameEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugFrameEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugFrameEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugFrameEnumProxyVtbl = 
{
    &ICorDebugFrameEnum_ProxyInfo,
    &IID_ICorDebugFrameEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugFrameEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugFrameEnumStubVtbl =
{
    &IID_ICorDebugFrameEnum,
    &ICorDebugFrameEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugChainEnum, ver. 0.0,
   GUID={0xCC7BCB08,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugChainEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7266
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugChainEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugChainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugChainEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugChainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugChainEnumProxyVtbl = 
{
    &ICorDebugChainEnum_ProxyInfo,
    &IID_ICorDebugChainEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugChainEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugChainEnumStubVtbl =
{
    &IID_ICorDebugChainEnum,
    &ICorDebugChainEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugModuleEnum, ver. 0.0,
   GUID={0xCC7BCB09,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugModuleEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7306
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugModuleEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModuleEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugModuleEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugModuleEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugModuleEnumProxyVtbl = 
{
    &ICorDebugModuleEnum_ProxyInfo,
    &IID_ICorDebugModuleEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugModuleEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugModuleEnumStubVtbl =
{
    &IID_ICorDebugModuleEnum,
    &ICorDebugModuleEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugValueEnum, ver. 0.0,
   GUID={0xCC7BCB0A,0x8A68,0x11d2,{0x98,0x3C,0x00,0x00,0xF8,0x08,0x34,0x2D}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugValueEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7346
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugValueEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValueEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugValueEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugValueEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugValueEnumProxyVtbl = 
{
    &ICorDebugValueEnum_ProxyInfo,
    &IID_ICorDebugValueEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugValueEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugValueEnumStubVtbl =
{
    &IID_ICorDebugValueEnum,
    &ICorDebugValueEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugErrorInfoEnum, ver. 0.0,
   GUID={0xF0E18809,0x72B5,0x11d2,{0x97,0x6F,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugErrorInfoEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7386
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugErrorInfoEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugErrorInfoEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugErrorInfoEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugErrorInfoEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugErrorInfoEnumProxyVtbl = 
{
    &ICorDebugErrorInfoEnum_ProxyInfo,
    &IID_ICorDebugErrorInfoEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugErrorInfoEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugErrorInfoEnumStubVtbl =
{
    &IID_ICorDebugErrorInfoEnum,
    &ICorDebugErrorInfoEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugAppDomainEnum, ver. 0.0,
   GUID={0x63ca1b24,0x4359,0x4883,{0xbd,0x57,0x13,0xf8,0x15,0xf5,0x87,0x44}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugAppDomainEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7426
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugAppDomainEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAppDomainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugAppDomainEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAppDomainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugAppDomainEnumProxyVtbl = 
{
    &ICorDebugAppDomainEnum_ProxyInfo,
    &IID_ICorDebugAppDomainEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAppDomainEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugAppDomainEnumStubVtbl =
{
    &IID_ICorDebugAppDomainEnum,
    &ICorDebugAppDomainEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugAssemblyEnum, ver. 0.0,
   GUID={0x4a2a1ec9,0x85ec,0x4bfb,{0x9f,0x15,0xa8,0x9f,0xdf,0xe0,0xfe,0x83}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugAssemblyEnum_FormatStringOffsetTable[] =
    {
    6920,
    6948,
    6970,
    6998,
    7466
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugAssemblyEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAssemblyEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugAssemblyEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugAssemblyEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorDebugAssemblyEnumProxyVtbl = 
{
    &ICorDebugAssemblyEnum_ProxyInfo,
    &IID_ICorDebugAssemblyEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorDebugAssemblyEnum::Next */
};

const CInterfaceStubVtbl _ICorDebugAssemblyEnumStubVtbl =
{
    &IID_ICorDebugAssemblyEnum,
    &ICorDebugAssemblyEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugEditAndContinueErrorInfo, ver. 0.0,
   GUID={0x8D600D41,0xF4F6,0x4cb3,{0xB7,0xEC,0x7B,0xD1,0x64,0x94,0x40,0x36}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugEditAndContinueErrorInfo_FormatStringOffsetTable[] =
    {
    7506,
    7534,
    7562,
    7590
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugEditAndContinueErrorInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEditAndContinueErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugEditAndContinueErrorInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEditAndContinueErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorDebugEditAndContinueErrorInfoProxyVtbl = 
{
    &ICorDebugEditAndContinueErrorInfo_ProxyInfo,
    &IID_ICorDebugEditAndContinueErrorInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueErrorInfo::GetModule */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueErrorInfo::GetToken */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueErrorInfo::GetErrorCode */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueErrorInfo::GetString */
};

const CInterfaceStubVtbl _ICorDebugEditAndContinueErrorInfoStubVtbl =
{
    &IID_ICorDebugEditAndContinueErrorInfo,
    &ICorDebugEditAndContinueErrorInfo_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorDebugEditAndContinueSnapshot, ver. 0.0,
   GUID={0x6DC3FA01,0xD7CB,0x11d2,{0x8A,0x95,0x00,0x80,0xC7,0x92,0xE5,0xD8}} */

#pragma code_seg(".orpc")
static const unsigned short ICorDebugEditAndContinueSnapshot_FormatStringOffsetTable[] =
    {
    7630,
    7664,
    7692,
    7720,
    7748,
    7776,
    7816
    };

static const MIDL_STUBLESS_PROXY_INFO ICorDebugEditAndContinueSnapshot_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEditAndContinueSnapshot_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorDebugEditAndContinueSnapshot_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorDebugEditAndContinueSnapshot_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _ICorDebugEditAndContinueSnapshotProxyVtbl = 
{
    &ICorDebugEditAndContinueSnapshot_ProxyInfo,
    &IID_ICorDebugEditAndContinueSnapshot,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::CopyMetaData */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::GetMvid */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::GetRoDataRVA */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::GetRwDataRVA */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::SetPEBytes */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::SetILMap */ ,
    (void *) (INT_PTR) -1 /* ICorDebugEditAndContinueSnapshot::SetPESymbolBytes */
};

const CInterfaceStubVtbl _ICorDebugEditAndContinueSnapshotStubVtbl =
{
    &IID_ICorDebugEditAndContinueSnapshot,
    &ICorDebugEditAndContinueSnapshot_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _cordebug_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICorDebugContextProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugEditAndContinueSnapshotProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugObjectEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugBreakpointEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugStepperEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugProcessEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugThreadEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugFrameEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugChainEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugErrorInfoEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugModuleEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugUnmanagedCallbackProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugValueEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugRegisterSetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugILFrameProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugNativeFrameProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugAppDomainEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugEditAndContinueErrorInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugManagedCallbackProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugControllerProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugAppDomainProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugProcessProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugThreadProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugObjectValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugAssemblyProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugModuleProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugAssemblyEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugArrayValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugBreakpointProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugFunctionBreakpointProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugModuleBreakpointProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugValueBreakpointProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugStepperProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugChainProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugFrameProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugFunctionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugCodeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugClassProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugEvalProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugReferenceValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugHeapValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugBoxValueProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorDebugStringValueProxyVtbl,
    0
};

const CInterfaceStubVtbl * _cordebug_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICorDebugContextStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugEditAndContinueSnapshotStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugObjectEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugBreakpointEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugStepperEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugProcessEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugThreadEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugFrameEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugChainEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugErrorInfoEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugModuleEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugUnmanagedCallbackStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugValueEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugRegisterSetStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugILFrameStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugNativeFrameStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugAppDomainEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugEditAndContinueErrorInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugManagedCallbackStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugControllerStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugAppDomainStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugProcessStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugThreadStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugObjectValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugAssemblyStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugModuleStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugAssemblyEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugArrayValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugBreakpointStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugFunctionBreakpointStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugModuleBreakpointStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugValueBreakpointStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugStepperStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugChainStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugFrameStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugFunctionStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugCodeStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugClassStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugEvalStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugReferenceValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugHeapValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugBoxValueStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorDebugStringValueStubVtbl,
    0
};

PCInterfaceName const _cordebug_InterfaceNamesList[] = 
{
    "ICorDebugContext",
    "ICorDebugEnum",
    "ICorDebugEditAndContinueSnapshot",
    "ICorDebugObjectEnum",
    "ICorDebugBreakpointEnum",
    "ICorDebugStepperEnum",
    "ICorDebugProcessEnum",
    "ICorDebugThreadEnum",
    "ICorDebugFrameEnum",
    "ICorDebugChainEnum",
    "ICorDebugErrorInfoEnum",
    "ICorDebugModuleEnum",
    "ICorDebugUnmanagedCallback",
    "ICorDebugValueEnum",
    "ICorDebugRegisterSet",
    "ICorDebugILFrame",
    "ICorDebugNativeFrame",
    "ICorDebugAppDomainEnum",
    "ICorDebugEditAndContinueErrorInfo",
    "ICorDebugManagedCallback",
    "ICorDebugController",
    "ICorDebugAppDomain",
    "ICorDebugProcess",
    "ICorDebugThread",
    "ICorDebugObjectValue",
    "ICorDebugAssembly",
    "ICorDebugModule",
    "ICorDebugAssemblyEnum",
    "ICorDebugArrayValue",
    "ICorDebugBreakpoint",
    "ICorDebugFunctionBreakpoint",
    "ICorDebugModuleBreakpoint",
    "ICorDebugValueBreakpoint",
    "ICorDebugStepper",
    "ICorDebugChain",
    "ICorDebugFrame",
    "ICorDebugFunction",
    "ICorDebugCode",
    "ICorDebugClass",
    "ICorDebugEval",
    "ICorDebugValue",
    "ICorDebugReferenceValue",
    "ICorDebugHeapValue",
    "ICorDebugBoxValue",
    "ICorDebugStringValue",
    0
};

const IID *  _cordebug_BaseIIDList[] = 
{
    &IID_ICorDebugObjectValue,   /* forced */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


#define _cordebug_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _cordebug, pIID, n)

int __stdcall _cordebug_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _cordebug, 45, 32 )
    IID_BS_LOOKUP_NEXT_TEST( _cordebug, 16 )
    IID_BS_LOOKUP_NEXT_TEST( _cordebug, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _cordebug, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _cordebug, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _cordebug, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _cordebug, 45, *pIndex )
    
}

const ExtendedProxyFileInfo cordebug_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _cordebug_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _cordebug_StubVtblList,
    (const PCInterfaceName * ) & _cordebug_InterfaceNamesList,
    (const IID ** ) & _cordebug_BaseIIDList,
    & _cordebug_IID_Lookup, 
    45,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corhlpr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Corhlpr.h - this file contains a set of "as is" code that may be        **
 **             used by developers writing compilers and tools against      **
 **             the Common Language Runtime. The code is not officially     **
 **             supported, but is code being used by the Runtime itself.    **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHLPR_H__
#define __CORHLPR_H__

#include "cor.h"
#include "corhdr.h"
#include "corerror.h"



//*****************************************************************************
// There are a set of macros commonly used in the helpers which you will want
// to override to get richer behavior.  The following defines what is needed
// if you chose not to do the extra work.
//*****************************************************************************
#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)
#endif

#ifndef _ASSERTE
#define _ASSERTE(expr)
#endif





//*****************************************************************************
//
//***** Utility helpers
//
//*****************************************************************************


#define MAX_CLASSNAME_LENGTH 1024

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
template <DWORD SIZE, DWORD INCREMENT> 
class CQuickBytesBase
{
public:
    CQuickBytesBase() :
        pbBuff(0),
        iSize(0),
        cbTotal(SIZE)
    { }

    void Destroy()
    {
        if (pbBuff)
        {
            free(pbBuff);
            pbBuff = 0;
        }
    }

    void *Alloc(SIZE_T iItems)
    {
        iSize = iItems;
        if (iItems <= SIZE)
        {
            cbTotal = SIZE;
            return (&rgData[0]);
        }
        else
        {
            if (pbBuff) free(pbBuff);
            pbBuff = malloc(iItems);
            cbTotal = pbBuff ? iItems : 0;
            return (pbBuff);
        }
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        void *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return NOERROR;
        }

        pbBuffNew = malloc(iItems + INCREMENT);
        if (!pbBuffNew)
            ExitProcess(E_OUTOFMEMORY);
        if (pbBuff) 
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            free(pbBuff);
        }
        else
        {
            _ASSERTE(cbTotal == SIZE);
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + INCREMENT;
        iSize = iItems;
        pbBuff = pbBuffNew;
        return NOERROR;
        
    }

    operator PVOID()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    void *Ptr()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    SIZE_T Size()
    { return (iSize); }

    SIZE_T MaxSize()
    { return (cbTotal); }

    void Maximize()
    { 
        HRESULT hr = ReSize(MaxSize());
        _ASSERTE(hr == NOERROR);
    }

    void        *pbBuff;
    SIZE_T      iSize;              // number of bytes used
    SIZE_T      cbTotal;            // total bytes allocated in the buffer
    BYTE        rgData[SIZE];
};

#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

class CQuickBytesNoDtor : public CQuickBytesBase<CQUICKBYTES_BASE_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

class CQuickBytes : public CQuickBytesNoDtor
{
public:
    CQuickBytes() { }

    ~CQuickBytes()
    {
        Destroy();
    }
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesNoDtorSpecifySize : public CQuickBytesBase<CQUICKBYTES_BASE_SPECIFY_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE> 
class CQuickBytesSpecifySize : public CQuickBytesNoDtorSpecifySize<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
public:
    CQuickBytesSpecifySize() { }

    ~CQuickBytesSpecifySize()
    {
        Destroy();
    }
};


#define STRING_SIZE 10
class CQuickString : public CQuickBytesBase<STRING_SIZE, STRING_SIZE> 
{
public:
    CQuickString() { }

    ~CQuickString()
    {
        Destroy();
    }
    
    void *Alloc(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Alloc(iItems*sizeof(WCHAR));
    }

    HRESULT ReSize(SIZE_T iItems)
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::ReSize(iItems * sizeof(WCHAR));
    }

    SIZE_T Size()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::Size() / sizeof(WCHAR);
    }

    SIZE_T MaxSize()
    {
        return CQuickBytesBase<STRING_SIZE, STRING_SIZE>::MaxSize() / sizeof(WCHAR);
    }

    WCHAR* String()
    {
        return (WCHAR*) Ptr();
    }

};

//*****************************************************************************
//
//***** Signature helpers
//
//*****************************************************************************

inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv); 
}

HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig, 
    ULONG       *pcbTotal);

HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of CLR signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob);               // [OUT] number of bytes written to the above output buffer




//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************



//*****************************************************************************
typedef struct tagCOR_ILMETHOD_SECT_SMALL : IMAGE_COR_ILMETHOD_SECT_SMALL {
        //Data follows  
    const BYTE* Data() const { return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_SMALL)); }    
} COR_ILMETHOD_SECT_SMALL;


/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct tagCOR_ILMETHOD_SECT_FAT : IMAGE_COR_ILMETHOD_SECT_FAT {
        //Data follows  
    const BYTE* Data() const { return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_FAT)); }  
} COR_ILMETHOD_SECT_FAT;


/************************************/
/* NOTE this structure must be DWORD aligned!! */
struct COR_ILMETHOD_SECT 
{
    bool More() const           { return((AsSmall()->Kind & CorILMethod_Sect_MoreSects) != 0); }    
    CorILMethodSect Kind() const{ return((CorILMethodSect) (AsSmall()->Kind & CorILMethod_Sect_KindMask)); }    
    const COR_ILMETHOD_SECT* Next() const   {   
        if (!More()) return(0); 
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->DataSize])->Align());    
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align()); 
        }   
    const COR_ILMETHOD_SECT* NextLoc() const   {   
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->DataSize])->Align());    
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align()); 
        }   
    const BYTE* Data() const {  
        if (IsFat()) return(AsFat()->Data());   
        return(AsSmall()->Data());  
        }   
    unsigned DataSize() const { 
        if (IsFat()) return(AsFat()->DataSize); 
        return(AsSmall()->DataSize);    
        }   

    friend struct COR_ILMETHOD; 
    friend struct tagCOR_ILMETHOD_FAT; 
    friend struct tagCOR_ILMETHOD_TINY;    
    bool IsFat() const                            { return((AsSmall()->Kind & CorILMethod_Sect_FatFormat) != 0); }  
    const COR_ILMETHOD_SECT* Align() const        { return((COR_ILMETHOD_SECT*) ((((UINT_PTR) this) + 3) & ~3));  } 
protected:
    const COR_ILMETHOD_SECT_FAT*   AsFat() const  { return((COR_ILMETHOD_SECT_FAT*) this); }    
    const COR_ILMETHOD_SECT_SMALL* AsSmall() const{ return((COR_ILMETHOD_SECT_SMALL*) this); }  

    // The body is either a COR_ILMETHOD_SECT_SMALL or COR_ILMETHOD_SECT_FAT    
    // (as indicated by the CorILMethod_Sect_FatFormat bit  
};

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_FAT : public COR_ILMETHOD_SECT_FAT {
    static unsigned Size(unsigned ehCount) {    
        return (sizeof(COR_ILMETHOD_SECT_EH_FAT) +  
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT) * (ehCount-1)); 
        }   
                    
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
};

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_SMALL : public COR_ILMETHOD_SECT_SMALL {
    static unsigned Size(unsigned ehCount) {    
        return (sizeof(COR_ILMETHOD_SECT_EH_SMALL) +    
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL) * (ehCount-1));   
        }   
    WORD Reserved;                                  // alignment padding    
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
};


/***********************************/
// exported functions (implementation in Format\Format.cpp:
extern "C" {
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff);
        // compute the size of the section (best format)    
        // codeSize is the size of the method   
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize);  

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount);  

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses);  

        // emit the section (best format);  
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,   
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0);
} // extern "C"


struct COR_ILMETHOD_SECT_EH : public COR_ILMETHOD_SECT
{
    unsigned EHCount() const {  
        return (unsigned)(IsFat() ? (Fat.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) : 
                        (Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL))); 
    }   

        // return one clause in its fat form.  Use 'buff' if needed 
    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* EHClause(unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff) const
    { return SectEH_EHClause((void *)this, idx, buff); };
        // compute the size of the section (best format)    
        // codeSize is the size of the method   
    // deprecated
    unsigned static Size(unsigned ehCount, unsigned codeSize)
    { return SectEH_SizeWithCode(ehCount, codeSize); };

    // will return worse-case size and then Emit will return actual size
    unsigned static Size(unsigned ehCount)
    { return SectEH_SizeWorst(ehCount); };

    // will return exact size which will match the size returned by Emit
    unsigned static Size(unsigned ehCount, const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
    { return SectEH_SizeExact(ehCount, (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses);  };

        // emit the section (best format);  
    unsigned static Emit(unsigned size, unsigned ehCount,   
                  const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,   
                  bool moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0)
    { return SectEH_Emit(size, ehCount,
                         (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses,
                         moreSections, outBuff, ehTypeOffsets); };

//private:

    union { 
        COR_ILMETHOD_SECT_EH_SMALL Small;   
        COR_ILMETHOD_SECT_EH_FAT Fat;   
        };  
};


/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct tagCOR_ILMETHOD_TINY : IMAGE_COR_ILMETHOD_TINY
{
    bool     IsTiny() const         { return((Flags_CodeSize & (CorILMethod_FormatMask >> 1)) == CorILMethod_TinyFormat); } 
    unsigned GetCodeSize() const    { return(((unsigned) Flags_CodeSize) >> (CorILMethod_FormatShift-1)); } 
    unsigned GetMaxStack() const    { return(8); }  
    BYTE*    GetCode() const        { return(((BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_TINY)); } 
    DWORD    GetLocalVarSigTok() const  { return(0); }  
    COR_ILMETHOD_SECT* GetSect() const { return(0); }   
} COR_ILMETHOD_TINY;


/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct tagCOR_ILMETHOD_FAT : IMAGE_COR_ILMETHOD_FAT
{
    bool     IsFat() const              { return((Flags & CorILMethod_FormatMask) == CorILMethod_FatFormat); }  
    unsigned GetMaxStack() const        { return(MaxStack); }   
    unsigned GetCodeSize() const        { return(CodeSize); }   
    mdToken  GetLocalVarSigTok() const      { return(LocalVarSigTok); } 
    BYTE*    GetCode() const            { return(((BYTE*) this) + 4*Size); }    
    const COR_ILMETHOD_SECT* GetSect() const {  
        if (!(Flags & CorILMethod_MoreSects)) return(0);    
        return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());    
        }   
} COR_ILMETHOD_FAT;


extern "C" {
/************************************/
// exported functions (impl. Format\Format.cpp)
unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL MoreSections);    
        // emit the header (bestFormat) return amount emitted   
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header, 
                  BOOL moreSections, BYTE* outBuff);    
}

struct COR_ILMETHOD
{
        // a COR_ILMETHOD header should not be decoded by hand.  Instead us 
        // COR_ILMETHOD_DECODER to decode it.   
    friend class COR_ILMETHOD_DECODER;  

        // compute the size of the header (best format) 
    unsigned static Size(const COR_ILMETHOD_FAT* header, bool MoreSections)
    { return IlmethodSize((COR_ILMETHOD_FAT*)header,MoreSections); };
        // emit the header (bestFormat) return amount emitted   
    unsigned static Emit(unsigned size, const COR_ILMETHOD_FAT* header, 
                  bool moreSections, BYTE* outBuff)
    { return IlmethodEmit(size, (COR_ILMETHOD_FAT*)header, moreSections, outBuff); };

//private:
    union   
    {   
        COR_ILMETHOD_TINY       Tiny;   
        COR_ILMETHOD_FAT        Fat;    
    };  
        // Code follows the Header, then immedately after the code comes    
        // any sections (COR_ILMETHOD_SECT).    
};

extern "C" {
/***************************************************************************/
/* COR_ILMETHOD_DECODER is the only way functions internal to the EE should
   fetch data from a COR_ILMETHOD.  This way any dependancy on the file format
   (and the multiple ways of encoding the header) is centralized to the 
   COR_ILMETHOD_DECODER constructor) */
    void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header);
    int  __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header);
} // extern "C"

class COR_ILMETHOD_DECODER : public COR_ILMETHOD_FAT  
{
public:
        // Decode the COR header into a more convinient internal form   
        // This is the ONLY way you should access COR_ILMETHOD so format changes are easier 
    COR_ILMETHOD_DECODER(const COR_ILMETHOD* header) { DecoderInit(this,(COR_ILMETHOD*)header); };   

        // The constructor above can not do a 'complete' job, because it    
        // can not look up the local variable signature meta-data token.    
        // This method should be used when you have access to the Meta data API
        // If the consturction fails, the 'Code' field is set to 
    COR_ILMETHOD_DECODER(COR_ILMETHOD* header, void *pInternalImport, bool verify=false);  

    unsigned EHCount() const {  
        if (EH == 0) return(0); 
        else return(EH->EHCount()); 
        }   

    // returns total size of method for use in copying
    int GetOnDiskSize(const COR_ILMETHOD* header) { return DecoderGetOnDiskSize(this,(COR_ILMETHOD*)header); };

    // Flags        these are available because we inherit COR_ILMETHOD_FAT 
    // MaxStack 
    // CodeSize 
    const BYTE* Code;   
    PCCOR_SIGNATURE LocalVarSig;        // pointer to signature blob, or 0 if none  
    const COR_ILMETHOD_SECT_EH* EH;     // eh table if any  0 if none   
    const COR_ILMETHOD_SECT* Sect;      // additional sections  0 if none   
};

STDAPI_(void)   ReleaseFusionInterfaces();
BOOL STDMETHODCALLTYPE   BeforeFusionShutdown();

STDAPI_(void)   DontReleaseFusionInterfaces();
void STDMETHODCALLTYPE   DontReleaseFusionInterfaces();

#endif // __CORHLPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corhost.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorHost.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __CorHost__h__
#define __CorHost__h__

#include "mscoree.h"
#include "ivehandler.h"
#include "ivalidator.h"
#include "threadpool.h"


#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType COM##FnName FnParamList; 

typedef VOID (__stdcall *WAITORTIMERCALLBACK)(PVOID, BOOL); 
                     
#include "tpoolfnsp.h"

#undef STRUCT_ENTRY

class AppDomain;

class CorHost :
    public ICorRuntimeHost, public ICorThreadpool
    , public IGCHost, public ICorConfiguration
    , public IValidator, public IDebuggerInfo
{
public:
    CorHost();

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);


    // *** ICorRuntimeHost methods ***
    // Returns an object for configuring the runtime prior to 
    // it starting. If the runtime has been initialized this
    // routine returns an error. See ICorConfiguration.
    STDMETHODIMP GetConfiguration(ICorConfiguration** pConfiguration);

    // Starts the runtime. This is equivalent to CoInitializeCor();
    STDMETHODIMP Start();
    
    // Terminates the runtime, This is equivalent CoUninitializeCor();
    STDMETHODIMP Stop();
    
    // Creates a domain in the runtime. The identity array is 
    // a pointer to an array TYPE containing IIdentity objects defining
    // the security identity.
    STDMETHODIMP CreateDomain(LPCWSTR pwzFriendlyName,   // Optional
                              IUnknown* pIdentityArray, // Optional
                              IUnknown ** pAppDomain);
    
    // Returns the default domain.
    STDMETHODIMP GetDefaultDomain(IUnknown ** pAppDomain);
    
    
    // Enumerate currently existing domains. 
    STDMETHODIMP EnumDomains(HDOMAINENUM *hEnum);
    
    // Returns S_FALSE when there are no more domains. A domain
    // is passed out only when S_OK is returned.
    STDMETHODIMP NextDomain(HDOMAINENUM hEnum,
                            IUnknown** pAppDomain);
    
    // Close the enumeration releasing resources
    STDMETHODIMP CloseEnum(HDOMAINENUM hEnum);

    STDMETHODIMP CreateDomainEx(LPCWSTR pwzFriendlyName,
                                IUnknown* pSetup, // Optional
                                IUnknown* pEvidence, // Optional
                                IUnknown ** pAppDomain);

    // Create appdomain setup object that can be passed into CreateDomainEx
    STDMETHODIMP CreateDomainSetup(IUnknown** pAppDomainSetup);

    // Create Evidence object that can be passed into CreateDomainEx
    STDMETHODIMP CreateEvidence(IUnknown** pEvidence);

    // Unload a domain, releasing the reference will only release the 
    // the wrapper to the domain not unload the domain. 
    STDMETHODIMP UnloadDomain(IUnknown* pAppDomain);

    // Returns the threads domain if there is one.
    STDMETHODIMP CurrentDomain(IUnknown ** pAppDomain);

    STDMETHODIMP CreateLogicalThreadState();    // Return code.
    STDMETHODIMP DeleteLogicalThreadState();    // Return code.
    STDMETHODIMP SwitchInLogicalThreadState(    // Return code.
        DWORD *pFiberCookie                     // [in] Cookie that indicates the fiber to use.
        );

    STDMETHODIMP SwitchOutLogicalThreadState(   // Return code.
        DWORD **pFiberCookie                    // [out] Cookie that indicates the fiber being switched out.
        );

    STDMETHODIMP LocksHeldByLogicalThread(      // Return code.
        DWORD *pCount                           // [out] Number of locks that the current thread holds.
        );

    virtual HRESULT STDMETHODCALLTYPE SetGCThreadControl( 
        /* [in] */ IGCThreadControl __RPC_FAR *pGCThreadControl);

    virtual HRESULT STDMETHODCALLTYPE SetGCHostControl( 
        /* [in] */ IGCHostControl __RPC_FAR *pGCHostControl);

    virtual HRESULT STDMETHODCALLTYPE SetDebuggerThreadControl( 
        /* [in] */ IDebuggerThreadControl __RPC_FAR *pDebuggerThreadControl);

    virtual HRESULT STDMETHODCALLTYPE AddDebuggerSpecialThread( 
        /* [in] */ DWORD dwSpecialThreadId);

    // Helper function to update the thread list in the debugger control block
    static HRESULT RefreshDebuggerSpecialThreadList();

    // Clean up debugger special thread list, called at shutdown
#ifdef SHOULD_WE_CLEANUP
    static void CleanupDebuggerSpecialThreadList();
#endif /* SHOULD_WE_CLEANUP */

    // Clean up debugger thread control object, called at shutdown
    static void CleanupDebuggerThreadControl();

    // Helper function that returns true if the thread is in the debugger special thread list
    static BOOL IsDebuggerSpecialThread(DWORD dwThreadId);

    // Class factory hook-up.
    static HRESULT CreateObject(REFIID riid, void **ppUnk);

    STDMETHODIMP MapFile(                       // Return code.
        HANDLE     hFile,                       // [in]  Handle for file
        HMODULE   *hMapAddress                  // [out] HINSTANCE for mapped file
        );


    // IGCHost
    STDMETHODIMP STDMETHODCALLTYPE SetGCStartupLimits( 
        DWORD SegmentSize,
        DWORD MaxGen0Size);

    STDMETHODIMP STDMETHODCALLTYPE Collect( 
        long Generation);

    STDMETHODIMP STDMETHODCALLTYPE GetStats( 
        COR_GC_STATS *pStats);

    STDMETHODIMP STDMETHODCALLTYPE GetThreadStats( 
        DWORD *pFiberCookie,
        COR_GC_THREAD_STATS *pStats);

    STDMETHODIMP STDMETHODCALLTYPE SetVirtualMemLimit(
        SIZE_T sztMaxVirtualMemMB);
    
    // IValidate
    STDMETHODIMP STDMETHODCALLTYPE Validate(
            IVEHandler        *veh,
            IUnknown          *pAppDomain,
            unsigned long      ulFlags,
            unsigned long      ulMaxError,
            unsigned long      token,
            LPWSTR             fileName,
            byte               *pe,
            unsigned long      ulSize);

    STDMETHODIMP STDMETHODCALLTYPE FormatEventInfo(
            HRESULT            hVECode,
            VEContext          Context,
            LPWSTR             msg,
            unsigned long      ulMaxLength,
            SAFEARRAY         *psa);

    // This mechanism isn't thread-safe with respect to reference counting, because
    // the runtime will use the cached pointer without adding extra refcounts to protect
    // itself.  So if one thread calls GetGCThreadControl & another thread calls
    // ICorHost::SetGCThreadControl, we have a race.
    static IGCThreadControl *GetGCThreadControl()
    {
        return m_CachedGCThreadControl;
    }

    static IGCHostControl *GetGCHostControl()
    {
        return m_CachedGCHostControl;
    }
    /**************************************************************************************/
    //ICorThreadpool methods
    
    HRESULT STDMETHODCALLTYPE  CorRegisterWaitForSingleObject(PHANDLE phNewWaitObject,
                                                              HANDLE hWaitObject,
                                                              WAITORTIMERCALLBACK Callback,
                                                              PVOID Context,
                                                              ULONG timeout,
                                                              BOOL  executeOnlyOnce,
                                                              BOOL* pResult)
    {
        
        ULONG flag = executeOnlyOnce ? (WAIT_SINGLE_EXECUTION |  WT_EXECUTEDEFAULT) : WT_EXECUTEDEFAULT;
        
        *pResult = COMRegisterWaitForSingleObject(phNewWaitObject,
                                                  hWaitObject,
                                                  Callback,
                                                  Context,
                                                  timeout,
                                                  flag);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }
    
    
    HRESULT STDMETHODCALLTYPE  CorUnregisterWait(HANDLE hWaitObject,HANDLE CompletionEvent, BOOL* pResult)
    {
        
        *pResult = COMUnregisterWaitEx(hWaitObject,CompletionEvent);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
        
    }
    
    
    HRESULT STDMETHODCALLTYPE  CorQueueUserWorkItem(LPTHREAD_START_ROUTINE Function,PVOID Context,BOOL executeOnlyOnce, BOOL* pResult )
    {
        
        *pResult = COMQueueUserWorkItem(Function,Context,QUEUE_ONLY);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }
    
    
    HRESULT STDMETHODCALLTYPE  CorCreateTimer(PHANDLE phNewTimer,
                                              WAITORTIMERCALLBACK Callback,
                                              PVOID Parameter,
                                              DWORD DueTime,
                                              DWORD Period, 
                                              BOOL* pResult)
    {
        
        *pResult = COMCreateTimerQueueTimer(phNewTimer,Callback,Parameter,DueTime,Period,WT_EXECUTEDEFAULT);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }
    

    HRESULT STDMETHODCALLTYPE  CorChangeTimer(HANDLE Timer,ULONG DueTime,ULONG Period, BOOL* pResult)
    {

        *pResult = COMChangeTimerQueueTimer(Timer,DueTime,Period);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }


    HRESULT STDMETHODCALLTYPE  CorDeleteTimer(HANDLE Timer, HANDLE CompletionEvent, BOOL* pResult)
    {

        *pResult = COMDeleteTimerQueueTimer(Timer,CompletionEvent);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }

    HRESULT STDMETHODCALLTYPE  CorBindIoCompletionCallback(HANDLE fileHandle, LPOVERLAPPED_COMPLETION_ROUTINE callback)
    {

        COMBindIoCompletionCallback(fileHandle,callback,0);
        return S_OK;
    }



    HRESULT STDMETHODCALLTYPE  CorCallOrQueueUserWorkItem(LPTHREAD_START_ROUTINE Function,PVOID Context,BOOL* pResult )
    {
        *pResult = COMQueueUserWorkItem(Function,Context,CALL_OR_QUEUE);
        return (*pResult ? S_OK : HRESULT_FROM_WIN32(GetLastError()));
    }


	HRESULT STDMETHODCALLTYPE CorSetMaxThreads(DWORD MaxWorkerThreads,
	                                           DWORD MaxIOCompletionThreads)
    {
        BOOL result = COMSetMaxThreads(MaxWorkerThreads, MaxIOCompletionThreads);
        return (result ? S_OK : E_FAIL);
    }

	HRESULT STDMETHODCALLTYPE CorGetMaxThreads(DWORD *MaxWorkerThreads,
	                                           DWORD *MaxIOCompletionThreads)
    {
        BOOL result = COMGetMaxThreads(MaxWorkerThreads, MaxIOCompletionThreads);
        return (result ? S_OK : E_FAIL);
    }

	HRESULT STDMETHODCALLTYPE CorGetAvailableThreads(DWORD *AvailableWorkerThreads,
	                                              DWORD *AvailableIOCompletionThreads)
    {
        BOOL result = COMGetAvailableThreads(AvailableWorkerThreads, AvailableIOCompletionThreads);
        return (result ? S_OK : E_FAIL);
    }


    static IDebuggerThreadControl *GetDebuggerThreadControl()
    {
        return m_CachedDebuggerThreadControl;
    }

    static DWORD GetDebuggerSpecialThreadCount()
    {
        return m_DSTCount;
    }

    static DWORD *GetDebuggerSpecialThreadArray()
    {
        return m_DSTArray;
    }

    STDMETHODIMP IsDebuggerAttached(BOOL *pbAttached);
    
private:

    HRESULT GetDomainsExposedObject(AppDomain* pDomain, IUnknown** ppObject);

    ULONG       m_cRef;                 // Ref count.
    PVOID       m_pMDConverter;         // MetaDataConverter
    BOOL        m_Started;              // Has START been called?

    PVOID       m_pValidatorMethodDesc; // The method we are validating
    // Cache the IGCThreadControl interface until the EE is started, at which point
    // we pass it through.
    static IGCThreadControl *m_CachedGCThreadControl;
    static IGCHostControl *m_CachedGCHostControl;
    static IDebuggerThreadControl *m_CachedDebuggerThreadControl;

    // Array of ID's of threads that should be considered "special" to
    // the debugging services.
    static DWORD *m_DSTArray;
    static DWORD  m_DSTArraySize;
    static DWORD  m_DSTCount;
};

#include "cordbpriv.h"

class ICorDBPrivHelperImpl : public ICorDBPrivHelper
{
private:
    // For ref counting
    ULONG m_refCount;
    static ICorDBPrivHelperImpl *m_pDBHelper;

public:
    ///////////////////////////////////////////////////////////////////////////
    // ctor/dtor

    ICorDBPrivHelperImpl();

    ///////////////////////////////////////////////////////////////////////////
    // IUnknown methods

    HRESULT STDMETHODCALLTYPE QueryInterface(
        REFIID id,
        void **pInterface);

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    ///////////////////////////////////////////////////////////////////////////
    // ICorDBPrivHelper methods

    // This is the main method of this interface.  This assumes that the runtime
    // has been started, and it will load the assembly specified, load the class
    // specified, run the cctor, create an instance of the class and return
    // an IUnknown wrapper to that object.
    virtual HRESULT STDMETHODCALLTYPE CreateManagedObject(
        /*in*/  WCHAR *wszAssemblyName,
        /*in*/  WCHAR *wszModuleName,
        /*in*/  mdTypeDef classToken,
        /*in*/  void *rawData,
        /*out*/ IUnknown **ppUnk);
    
    virtual HRESULT STDMETHODCALLTYPE GetManagedObjectContents(
        /* in */ IUnknown *pObject,
        /* in */ void *rawData,
        /* in */ ULONG32 dataSize);

    ///////////////////////////////////////////////////////////////////////////
    // Helper methods

    // GetDBHelper will new the helper class if necessary, and return
    // the pointer.  It will return null if it runs out of memory.
    static ICorDBPrivHelperImpl *GetDBHelper();

};

#endif // __CorHost__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
*                                                                             *
* CorInfo.h -    EE / Code generator interface                                *
*                                                                             *
*               Version 1.0                                                   *
*******************************************************************************
*                                                                             *
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY      *
*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE        *
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR      *
*  PURPOSE.                                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef _COR_INFO_H_
#define _COR_INFO_H_

#include <CorHdr.h>

// CorInfoHelpFunc defines the set of helpers (accessed via the getHelperFtn())
// The signatures of the helpers are below (see RuntimeHelperArgumentCheck)

enum CorInfoHelpFunc
{
    CORINFO_HELP_UNDEF,

    /* Arithmetic helpers */

    CORINFO_HELP_LLSH,
    CORINFO_HELP_LRSH,
    CORINFO_HELP_LRSZ,
    CORINFO_HELP_LMUL,
    CORINFO_HELP_LMUL_OVF,
    CORINFO_HELP_ULMUL_OVF,
    CORINFO_HELP_LDIV,
    CORINFO_HELP_LMOD,
    CORINFO_HELP_ULDIV,
    CORINFO_HELP_ULMOD,
    CORINFO_HELP_ULNG2DBL,              // Convert a unsigned in to a double
    CORINFO_HELP_DBL2INT,
    CORINFO_HELP_DBL2INT_OVF,
    CORINFO_HELP_DBL2LNG,
    CORINFO_HELP_DBL2LNG_OVF,
    CORINFO_HELP_DBL2UINT,
    CORINFO_HELP_DBL2UINT_OVF,
    CORINFO_HELP_DBL2ULNG,
    CORINFO_HELP_DBL2ULNG_OVF,
    CORINFO_HELP_FLTREM,
    CORINFO_HELP_DBLREM,

    /* Allocating a new object */

    CORINFO_HELP_NEW_DIRECT,        // new object
    CORINFO_HELP_NEW_CROSSCONTEXT,  // cross context new object
    CORINFO_HELP_NEWFAST,
    CORINFO_HELP_NEWSFAST,          // allocator for small, non-finalizer, non-array object
    CORINFO_HELP_NEWSFAST_ALIGN8,   // allocator for small, non-finalizer, non-array object, 8 byte aligned
    CORINFO_HELP_NEW_SPECIALDIRECT, // direct but only if no context needed
    CORINFO_HELP_NEWOBJ,            // helper that works just like instruction (calls constructor)
    CORINFO_HELP_NEWARR_1_DIRECT,   // helper for any one dimensional array creation
    CORINFO_HELP_NEWARR_1_OBJ,      // optimized 1-D object arrays
    CORINFO_HELP_NEWARR_1_VC,       // optimized 1-D value class arrays
    CORINFO_HELP_NEWARR_1_ALIGN8,   // like VC, but aligns the array start
    CORINFO_HELP_STRCNS,            // create a new string literal

    /* Object model */

    CORINFO_HELP_INITCLASS,         // Initialize class if not already initialized

    CORINFO_HELP_ISINSTANCEOF,
    CORINFO_HELP_ISINSTANCEOFCLASS, // Optimized helper for classes (vs arrays & interfaces)
    CORINFO_HELP_CHKCAST,
    CORINFO_HELP_CHKCASTCLASS,

    CORINFO_HELP_BOX,
    CORINFO_HELP_UNBOX,
    CORINFO_HELP_GETREFANY,         // Extract the byref checking it is the expected type

    CORINFO_HELP_EnC_RESOLVEVIRTUAL,// Get addr of virtual method introduced via EnC
                                    // (it wont exist in the original vtable)

    CORINFO_HELP_ARRADDR_ST,        // assign to element of object array with type-checking
    CORINFO_HELP_LDELEMA_REF,       // does a precise type comparision and returns address

    /* Exceptions */

    CORINFO_HELP_THROW,             // Throw an exception object
    CORINFO_HELP_RETHROW,           // Rethrow the currently active exception
    CORINFO_HELP_USER_BREAKPOINT,   // For a user program to break to the debugger
    CORINFO_HELP_RNGCHKFAIL,        // array bounds check failed
    CORINFO_HELP_OVERFLOW,          // throw an overflow exception

    CORINFO_HELP_INTERNALTHROW,     // Support for really fast jit
    CORINFO_HELP_INTERNALTHROWSTACK,
    CORINFO_HELP_VERIFICATION,

    CORINFO_HELP_ENDCATCH,          // call back into the EE at the end of a catch block

    /* Synchronization */

    CORINFO_HELP_MON_ENTER,
    CORINFO_HELP_MON_EXIT,
    CORINFO_HELP_MON_ENTER_STATIC,
    CORINFO_HELP_MON_EXIT_STATIC,

    /* GC support */

    CORINFO_HELP_STOP_FOR_GC,       // Call GC (force a GC)
    CORINFO_HELP_POLL_GC,           // Ask GC if it wants to collect

    CORINFO_HELP_STRESS_GC,         // Force a GC, but then update the JITTED code to be a noop call
    CORINFO_HELP_CHECK_OBJ,         // confirm that ECX is a valid object pointer (debugging only)

    /* GC Write barrier support */

    CORINFO_HELP_ASSIGN_REF_EAX,    // EAX hold GC ptr, want do a 'mov [EDX], EAX' and inform GC
    CORINFO_HELP_ASSIGN_REF_EBX,    // EBX hold GC ptr, want do a 'mov [EDX], EBX' and inform GC
    CORINFO_HELP_ASSIGN_REF_ECX,    // ECX hold GC ptr, want do a 'mov [EDX], ECX' and inform GC
    CORINFO_HELP_ASSIGN_REF_ESI,    // ESI hold GC ptr, want do a 'mov [EDX], ESI' and inform GC
    CORINFO_HELP_ASSIGN_REF_EDI,    // EDI hold GC ptr, want do a 'mov [EDX], EDI' and inform GC
    CORINFO_HELP_ASSIGN_REF_EBP,    // EBP hold GC ptr, want do a 'mov [EDX], EBP' and inform GC

    CORINFO_HELP_CHECKED_ASSIGN_REF_EAX,  // These are the same as ASSIGN_REF above ...
    CORINFO_HELP_CHECKED_ASSIGN_REF_EBX,  // ... but checks if EDX points to heap.
    CORINFO_HELP_CHECKED_ASSIGN_REF_ECX,
    CORINFO_HELP_CHECKED_ASSIGN_REF_ESI,
    CORINFO_HELP_CHECKED_ASSIGN_REF_EDI,
    CORINFO_HELP_CHECKED_ASSIGN_REF_EBP,

    CORINFO_HELP_ASSIGN_BYREF,      // EDI is byref, will do a MOVSD, incl. inc of ESI and EDI
                                    // will trash ECX

    /* Accessing fields */

    // For COM object support (using COM get/set routines to update object)
    // and EnC and cross-context support
    CORINFO_HELP_GETFIELD32,
    CORINFO_HELP_SETFIELD32,
    CORINFO_HELP_GETFIELD64,
    CORINFO_HELP_SETFIELD64,
    CORINFO_HELP_GETFIELD32OBJ,
    CORINFO_HELP_SETFIELD32OBJ,
    CORINFO_HELP_GETFIELDSTRUCT,
    CORINFO_HELP_SETFIELDSTRUCT,
    CORINFO_HELP_GETFIELDADDR,

    CORINFO_HELP_GETSTATICFIELDADDR,

    CORINFO_HELP_GETSHAREDSTATICBASE,

    /* Profiling enter/leave probe addresses */
    CORINFO_HELP_PROF_FCN_CALL,         // record a call to a method (callee)
    CORINFO_HELP_PROF_FCN_RET,          // record a return from called method (callee)
    CORINFO_HELP_PROF_FCN_ENTER,        // record the entry to a method (caller)
    CORINFO_HELP_PROF_FCN_LEAVE,        // record the completion of current method (caller)
    CORINFO_HELP_PROF_FCN_TAILCALL,     // record the completionof current method through tailcall (caller)

    /* Miscellaneous */

    CORINFO_HELP_PINVOKE_CALLI,         // Indirect pinvoke call
    CORINFO_HELP_TAILCALL,              // Perform a tail call

    CORINFO_HELP_GET_THREAD_FIELD_ADDR_PRIMITIVE,
    CORINFO_HELP_GET_THREAD_FIELD_ADDR_OBJREF,

    CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_PRIMITIVE,
    CORINFO_HELP_GET_CONTEXT_FIELD_ADDR_OBJREF,


    CORINFO_HELP_NOTANUMBER,           // throw an overflow exception
    CORINFO_HELP_SEC_UNMGDCODE_EXCPT,  // throw a security unmanaged code exception

    CORINFO_HELP_GET_THREAD,

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
     *
     * Start of Machine-specific helpers. All new common JIT helpers
     * should be added before here
     *
     *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

#ifdef  USE_HELPERS_FOR_INT_DIV
    //
    // Some architectures use helpers for Integer Divide and Rem
    //
    // Keep these at the end of the enum
    //
    CORINFO_HELP_I4_DIV,
    CORINFO_HELP_I4_MOD,
    CORINFO_HELP_U4_DIV,
    CORINFO_HELP_U4_MOD,
#endif

#if    !CPU_HAS_FP_SUPPORT
    //
    // Some architectures need helpers for FP support
    //
    // Keep these at the end of the enum
    //

    CORINFO_HELP_R4_NEG,
    CORINFO_HELP_R8_NEG,

    CORINFO_HELP_R4_ADD,
    CORINFO_HELP_R8_ADD,
    CORINFO_HELP_R4_SUB,
    CORINFO_HELP_R8_SUB,
    CORINFO_HELP_R4_MUL,
    CORINFO_HELP_R8_MUL,
    CORINFO_HELP_R4_DIV,
    CORINFO_HELP_R8_DIV,

    CORINFO_HELP_R4_EQ,
    CORINFO_HELP_R8_EQ,
    CORINFO_HELP_R4_NE,
    CORINFO_HELP_R8_NE,
    CORINFO_HELP_R4_LT,
    CORINFO_HELP_R8_LT,
    CORINFO_HELP_R4_LE,
    CORINFO_HELP_R8_LE,
    CORINFO_HELP_R4_GE,
    CORINFO_HELP_R8_GE,
    CORINFO_HELP_R4_GT,
    CORINFO_HELP_R8_GT,

    CORINFO_HELP_R8_TO_I4,
    CORINFO_HELP_R8_TO_I8,
    CORINFO_HELP_R8_TO_R4,

    CORINFO_HELP_R4_TO_I4,
    CORINFO_HELP_R4_TO_I8,
    CORINFO_HELP_R4_TO_R8,

    CORINFO_HELP_I4_TO_R4,
    CORINFO_HELP_I4_TO_R8,
    CORINFO_HELP_I8_TO_R4,
    CORINFO_HELP_I8_TO_R8,
    CORINFO_HELP_U4_TO_R4,
    CORINFO_HELP_U4_TO_R8,
    CORINFO_HELP_U8_TO_R4,
    CORINFO_HELP_U8_TO_R8,
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
     *
     * Don't add new JIT helpers here! Add them before the machine-specific
     * helpers.
     *
     *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

    CORINFO_HELP_COUNT
};

// The enumeration is returned in 'getSig','getType', getArgType methods
enum CorInfoType
{
    CORINFO_TYPE_UNDEF           = 0x0,
    CORINFO_TYPE_VOID            = 0x1,
    CORINFO_TYPE_BOOL            = 0x2,
    CORINFO_TYPE_CHAR            = 0x3,
    CORINFO_TYPE_BYTE            = 0x4,
    CORINFO_TYPE_UBYTE           = 0x5,
    CORINFO_TYPE_SHORT           = 0x6,
    CORINFO_TYPE_USHORT          = 0x7,
    CORINFO_TYPE_INT             = 0x8,
    CORINFO_TYPE_UINT            = 0x9,
    CORINFO_TYPE_LONG            = 0xa,
    CORINFO_TYPE_ULONG           = 0xb,
    CORINFO_TYPE_FLOAT           = 0xc,
    CORINFO_TYPE_DOUBLE          = 0xd,
    CORINFO_TYPE_STRING          = 0xe,         // Not used, should remove
    CORINFO_TYPE_PTR             = 0xf,
    CORINFO_TYPE_BYREF           = 0x10,
    CORINFO_TYPE_VALUECLASS      = 0x11,
    CORINFO_TYPE_CLASS           = 0x12,
    CORINFO_TYPE_REFANY          = 0x13,
    CORINFO_TYPE_COUNT,                         // number of jit types
};

enum CorInfoTypeWithMod
{
    CORINFO_TYPE_MASK            = 0x3F,        // lower 6 bits are type mask
    CORINFO_TYPE_MOD_PINNED      = 0x40,        // can be applied to CLASS, or BYREF to indiate pinned
};

inline CorInfoType strip(CorInfoTypeWithMod val) {
	return CorInfoType(val & CORINFO_TYPE_MASK);
}

// The enumeration is returned in 'getSig'
enum CorInfoCallConv
{
    CORINFO_CALLCONV_DEFAULT    = 0x0,
    CORINFO_CALLCONV_C          = 0x1,
    CORINFO_CALLCONV_STDCALL    = 0x2,
    CORINFO_CALLCONV_THISCALL   = 0x3,
    CORINFO_CALLCONV_FASTCALL   = 0x4,
    CORINFO_CALLCONV_VARARG     = 0x5,
    CORINFO_CALLCONV_FIELD      = 0x6,
    CORINFO_CALLCONV_LOCAL_SIG  = 0x7,
    CORINFO_CALLCONV_PROPERTY   = 0x8,

    CORINFO_CALLCONV_MASK       = 0x0f,         // Calling convention is bottom 4 bits
    CORINFO_CALLCONV_HASTHIS    = 0x20,
    CORINFO_CALLCONV_EXPLICITTHIS=0x40,
    CORINFO_CALLCONV_PARAMTYPE  = 0x80,         // Needs a special type parameter arg (past last)
};

enum CorInfoUnmanagedCallConv
{
    CORINFO_UNMANAGED_CALLCONV_UNKNOWN,
    CORINFO_UNMANAGED_CALLCONV_STDCALL,
    CORINFO_UNMANAGED_CALLCONV_C
};

// These are returned from getMethodOptions
enum CorInfoOptions
{
    CORINFO_OPT_INIT_LOCALS         = 0x00000010,  // zero initialize all variables
};

// These are potential return values for ICorFieldInfo::getFieldCategory
// If the JIT receives a category that it doesn't know about or doesn't
// care to optimize specially for, it should treat it as CORINFO_FIELDCATEGORY_UNKNOWN.
enum CorInfoFieldCategory
{
    CORINFO_FIELDCATEGORY_NORMAL,   // normal GC object
    CORINFO_FIELDCATEGORY_UNKNOWN,  // always call field get/set helpers
    CORINFO_FIELDCATEGORY_I1_I1,    // indirect access: fetch 1 byte
    CORINFO_FIELDCATEGORY_I2_I2,    // indirect access: fetch 2 bytes
    CORINFO_FIELDCATEGORY_I4_I4,    // indirect access: fetch 4 bytes
    CORINFO_FIELDCATEGORY_I8_I8,    // indirect access: fetch 8 bytes
    CORINFO_FIELDCATEGORY_BOOLEAN_BOOL, // boolean to 4-byte BOOL
    CORINFO_FIELDCATEGORY_CHAR_CHAR,// (Unicode) "char" to (ansi) CHAR
    CORINFO_FIELDCATEGORY_UI1_UI1,  // indirect access: fetch 1 byte
    CORINFO_FIELDCATEGORY_UI2_UI2,  // indirect access: fetch 2 bytes
    CORINFO_FIELDCATEGORY_UI4_UI4,  // indirect access: fetch 4 bytes
    CORINFO_FIELDCATEGORY_UI8_UI8,  // indirect access: fetch 8 bytes
};

// these are the attribute flags for fields and methods (getMethodAttribs)
enum CorInfoFlag
{
    // These values are an identical mapping from the resp.
    // access_flag bits
    CORINFO_FLG_PUBLIC                = 0x00000001,
    CORINFO_FLG_PRIVATE               = 0x00000002,
    CORINFO_FLG_PROTECTED             = 0x00000004,
    CORINFO_FLG_STATIC                = 0x00000008,
    CORINFO_FLG_FINAL                 = 0x00000010,
    CORINFO_FLG_SYNCH                 = 0x00000020,
    CORINFO_FLG_VIRTUAL               = 0x00000040,
//  CORINFO_FLG_AGILE                 = 0x00000080,
    CORINFO_FLG_NATIVE                = 0x00000100,
    CORINFO_FLG_NOTREMOTABLE          = 0x00000200,
    CORINFO_FLG_ABSTRACT              = 0x00000400,

    CORINFO_FLG_EnC                   = 0x00000800, // member was added by Edit'n'Continue

    // These are internal flags that can only be on methods
    CORINFO_FLG_IMPORT                = 0x00020000, // method is an imported symbol
    CORINFO_FLG_DELEGATE_INVOKE       = 0x00040000, // "Delegate
    CORINFO_FLG_UNCHECKEDPINVOKE      = 0x00080000, // Is a P/Invoke call that requires no security checks
    CORINFO_FLG_SECURITYCHECK         = 0x00100000,
    CORINFO_FLG_NOGCCHECK             = 0x00200000, // This method is FCALL that has no GC check.  Don't put alone in loops
    CORINFO_FLG_INTRINSIC             = 0x00400000, // This method MAY have an intrinsic ID
    CORINFO_FLG_CONSTRUCTOR           = 0x00800000, // method is an instance or type initializer
    CORINFO_FLG_RUN_CCTOR             = 0x01000000, // this method must run the class cctor

    // These are the valid bits that a jitcompiler can pass to setJitterMethodFlags for
    // non-native methods only; a jitcompiler can access these flags using getMethodFlags.
    CORINFO_FLG_JITTERFLAGSMASK       = 0xF0000000,

    CORINFO_FLG_DONT_INLINE           = 0x10000000,
    CORINFO_FLG_INLINED               = 0x20000000,
    CORINFO_FLG_NOSIDEEFFECTS         = 0x40000000,

    // These are internal flags that can only be on Fields
    CORINFO_FLG_HELPER                = 0x00010000, // field accessed via ordinary helper calls
    CORINFO_FLG_TLS                   = 0x00020000, // This variable accesses thread local store.
    CORINFO_FLG_SHARED_HELPER         = 0x00040000, // field is access via optimized shared helper
    CORINFO_FLG_STATIC_IN_HEAP        = 0x00080000, // This field (must be static) is in the GC heap as a boxed object
    CORINFO_FLG_UNMANAGED             = 0x00200000, // is this an unmanaged value class?

    // These are internal flags that can only be on Modules
    CORINFO_FLG_TRUSTED               = 0x00010000,

    // These are internal flags that can only be on Classes
    CORINFO_FLG_VALUECLASS            = 0x00010000, // is the class a value class
    CORINFO_FLG_INITIALIZED           = 0x00020000, // The class has been cctor'ed
    CORINFO_FLG_VAROBJSIZE            = 0x00040000, // the object size varies depending of constructor args
    CORINFO_FLG_ARRAY                 = 0x00080000, // class is an array class (initialized differently)
    CORINFO_FLG_INTERFACE             = 0x00100000, // it is an interface
    CORINFO_FLG_CONTEXTFUL            = 0x00400000, // is this a contextful class?
    // unused                           0x00200000, 
    CORINFO_FLG_OBJECT                = 0x00800000, // is this the object class?
    CORINFO_FLG_CONTAINS_GC_PTR       = 0x01000000, // does the class contain a gc ptr ?
    CORINFO_FLG_DELEGATE              = 0x02000000, // is this a subclass of delegate or multicast delegate ?
    CORINFO_FLG_MARSHAL_BYREF         = 0x04000000, // is this a subclass of MarshalByRef ?
    CORINFO_FLG_CONTAINS_STACK_PTR    = 0x08000000, // This class has a stack pointer inside it
    CORINFO_FLG_NEEDS_INIT            = 0x10000000, // This class needs JIT hooks for cctor
};

enum CORINFO_ACCESS_FLAGS
{
    CORINFO_ACCESS_ANY        = 0x0000, // Normal access
    CORINFO_ACCESS_THIS       = 0x0001, // Accessed via the this reference
    CORINFO_ACCESS_UNWRAP     = 0x0002, // Accessed via an unwrap reference
};

// These are the flags set on an CORINFO_EH_CLAUSE
enum CORINFO_EH_CLAUSE_FLAGS
{
    CORINFO_EH_CLAUSE_NONE    = 0,
    CORINFO_EH_CLAUSE_FILTER  = 0x0001, // If this bit is on, then this EH entry is for a filter
    CORINFO_EH_CLAUSE_FINALLY = 0x0002, // This clause is a finally clause
    CORINFO_EH_CLAUSE_FAULT   = 0x0004, // This clause is a fault   clause
};

// This enumeration is passed to InternalThrow
enum CorInfoException
{
    CORINFO_NullReferenceException,
    CORINFO_DivideByZeroException,
    CORINFO_InvalidCastException,
    CORINFO_IndexOutOfRangeException,
    CORINFO_OverflowException,
    CORINFO_SynchronizationLockException,
    CORINFO_ArrayTypeMismatchException,
    CORINFO_RankException,
    CORINFO_ArgumentNullException,
    CORINFO_ArgumentException,
    CORINFO_Exception_Count,
};


// This enumeration is returned by getIntrinsicID. Methods corresponding to 
// these values will have "well-known" specified behavior. Calls to these
// methods could be replaced with inlined code corresponding to the
// specified behavior (without having to examine the IL beforehand).

enum CorInfoIntrinsics
{
    CORINFO_INTRINSIC_Sin,
    CORINFO_INTRINSIC_Cos,
    CORINFO_INTRINSIC_Sqrt,
    CORINFO_INTRINSIC_Abs,
    CORINFO_INTRINSIC_Round,
    CORINFO_INTRINSIC_GetChar,              // fetch character out of string
    CORINFO_INTRINSIC_Array_GetDimLength,   // Get number of elements in a given dimension of an array
    CORINFO_INTRINSIC_Array_GetLengthTotal, // Get total number of elements in an array
    CORINFO_INTRINSIC_Array_Get,            // Get the value of an element in an array
    CORINFO_INTRINSIC_Array_Set,            // Set the value of an element in an array
    CORINFO_INTRINSIC_StringGetChar,  // fetch character out of string
    CORINFO_INTRINSIC_StringLength,   // get the length

    CORINFO_INTRINSIC_Count,
    CORINFO_INTRINSIC_Illegal = 0x7FFFFFFF,     // Not a true intrinsic,
};

// This enumeration is passed to
enum CorInfoCallCategory
{
    CORINFO_CallCategoryVTableOffset = 0,   // Use the getMethodVTableOffset
    CORINFO_CallCategoryPointer      = 1,   // Use the getMethodPointer() helper
    CORINFO_CallCatgeoryEntryPoint   = 2,   // Use the getMethodEntryPoint() helper
};

// Can a value be accessed directly from JITed code.
enum InfoAccessType
{
    IAT_VALUE,      // The info value is directly available
    IAT_PVALUE,     // The value needs to be accessed via an       indirection
    IAT_PPVALUE     // The value needs to be accessed via a double indirection
};

enum CorInfoGCType
{
    TYPE_GC_NONE,   // no embedded objectrefs   
    TYPE_GC_REF,    // Is an object ref 
    TYPE_GC_BYREF,  // Is an interior pointer - promote it but don't scan it    
    TYPE_GC_OTHER   // requires type-specific treatment 
};  

enum CorInfoClassId
{
    CLASSID_SYSTEM_OBJECT,
    CLASSID_TYPED_BYREF,
    CLASSID_TYPE_HANDLE,
    CLASSID_FIELD_HANDLE,
    CLASSID_METHOD_HANDLE,
    CLASSID_STRING,
    CLASSID_ARGUMENT_HANDLE,
};

enum CorInfoFieldAccess
{
    CORINFO_GET,
    CORINFO_SET,
    CORINFO_ADDRESS,
};

enum CorInfoInline
{
    INLINE_PASS = 0,                    // Inlining OK
    INLINE_RESPECT_BOUNDARY = 1,        // You can inline if there are no calls from the method being inlined

        // failures are negative
    INLINE_FAIL = -1,                   // Inlining not OK for this case only
    INLINE_NEVER = -2,                  // This method should never be inlined, regardless of context
};

inline bool dontInline(CorInfoInline val) {
    return(val < 0);
}

enum
{
        CORINFO_EXCEPTION_COMPLUS = ('COM' | 0xE0000000)
};

// Cookie types consumed by the code generator (these are opaque values
// not inspected by the code generator):

typedef struct CORINFO_ASSEMBLY_STRUCT_*    CORINFO_ASSEMBLY_HANDLE;
typedef struct CORINFO_MODULE_STRUCT_*      CORINFO_MODULE_HANDLE;
typedef struct CORINFO_CLASS_STRUCT_*       CORINFO_CLASS_HANDLE;
typedef struct CORINFO_METHOD_STRUCT_*      CORINFO_METHOD_HANDLE;
typedef struct CORINFO_FIELD_STRUCT_*       CORINFO_FIELD_HANDLE;
typedef struct CORINFO_ARG_LIST_STRUCT_*    CORINFO_ARG_LIST_HANDLE;    // represents a list of argument types
typedef struct CORINFO_SIG_STRUCT_*         CORINFO_SIG_HANDLE;         // represents the whole list
typedef struct CORINFO_GENERIC_STRUCT_*     CORINFO_GENERIC_HANDLE;     // a generic handle (could be any of the above)
typedef struct CORINFO_PROFILING_STRUCT_*   CORINFO_PROFILING_HANDLE;   // a handle guaranteed to be unique per process

// what is actually passed on the varargs call
typedef struct CORINFO_VarArgInfo *         CORINFO_VARARGS_HANDLE;

struct CORINFO_SIG_INFO
{
    CorInfoCallConv         callConv;
    CORINFO_CLASS_HANDLE    retTypeClass;   	// if the return type is a value class, this is its handle (enums are normalized)
	CORINFO_CLASS_HANDLE	retTypeSigClass;	// returns the value class as it is in the sig (enums are not converted to primitives)
    CorInfoType             retType : 8;
    unsigned                flags   : 8;    	// unused at present
    unsigned                numArgs : 16;
    CORINFO_ARG_LIST_HANDLE args;
    CORINFO_SIG_HANDLE      sig;
    CORINFO_MODULE_HANDLE   scope;          // passed to getArgClass
    mdToken                 token;

    bool                hasRetBuffArg()     { return retType == CORINFO_TYPE_VALUECLASS || retType == CORINFO_TYPE_REFANY; }
    CorInfoCallConv     getCallConv()       { return CorInfoCallConv((callConv & CORINFO_CALLCONV_MASK)); }
    bool                hasThis()           { return ((callConv & CORINFO_CALLCONV_HASTHIS) != 0); }
    unsigned            totalILArgs()       { return (numArgs + hasThis()); }
    unsigned            totalNativeArgs()   { return (totalILArgs() + hasRetBuffArg()); }
    bool                isVarArg()          { return (getCallConv() == CORINFO_CALLCONV_VARARG); }
    bool                hasTypeArg()        { return ((callConv & CORINFO_CALLCONV_PARAMTYPE) != 0); }
};

struct CORINFO_METHOD_INFO
{
    CORINFO_METHOD_HANDLE       ftn;
    CORINFO_MODULE_HANDLE       scope;
    BYTE *                      ILCode;
    unsigned                    ILCodeSize;
    unsigned short              maxStack;
    unsigned short              EHcount;
    CorInfoOptions              options;
    CORINFO_SIG_INFO            args;
    CORINFO_SIG_INFO            locals;
};

struct CORINFO_EH_CLAUSE
{
    CORINFO_EH_CLAUSE_FLAGS     Flags;
    DWORD                       TryOffset;
    DWORD                       TryLength;
    DWORD                       HandlerOffset;
    DWORD                       HandlerLength;
    union
    {
        DWORD                   ClassToken;       // use for type-based exception handlers
        DWORD                   FilterOffset;     // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)
    };
};

enum CORINFO_OS
{
    CORINFO_WIN9x,
    CORINFO_WINNT,
    CORINFO_WINCE
};


// For some highly optimized paths, the JIT must generate code that directly
// manipulates internal EE data structures. The getEEInfo() helper returns
// this structure containing the needed offsets and values.
struct CORINFO_EE_INFO
{
    // Size of the Frame structure
    unsigned    sizeOfFrame;

    // Offsets into the Frame structure
    unsigned    offsetOfFrameVptr;
    unsigned    offsetOfFrameLink;

    // Details about the InlinedCallFrame
    unsigned    offsetOfInlinedCallFrameCallSiteTracker;
    unsigned    offsetOfInlinedCallFrameCalleeSavedRegisters;
    unsigned    offsetOfInlinedCallFrameCallTarget;
    unsigned    offsetOfInlinedCallFrameReturnAddress;

    // Offsets into the Thread structure
    unsigned    offsetOfThreadFrame;
    unsigned    offsetOfGCState;

    // Offsets into the methodtable
    unsigned    offsetOfInterfaceTable;

    // Delegate offsets
    unsigned    offsetOfDelegateInstance;
    unsigned    offsetOfDelegateFirstTarget;

    // Remoting offsets
    unsigned    offsetOfTransparentProxyRP;
    unsigned    offsetOfRealProxyServer;

    CORINFO_OS  osType;
    unsigned    osMajor;
    unsigned    osMinor;
    unsigned    osBuild;

    bool        noDirectTLS : 1;     // If true, jit can't line TLS fetches.
};

/**********************************************************************************
 * The following is the internal structure of an object that the compiler knows about
 * when it generates code
 **********************************************************************************/
#pragma pack(push, 4)

#define CORINFO_PAGE_SIZE   0x1000                           // the page size on the machine

    // TODO: put this in the CORINFO_EE_INFO data structure
#define MAX_UNCHECKED_OFFSET_FOR_NULL_OBJECT ((32*1024)-1)   // when generating JIT code 

typedef void* CORINFO_MethodPtr;            // a generic method pointer

struct CORINFO_Object
{
    CORINFO_MethodPtr      *methTable;      // the vtable for the object
};

struct CORINFO_String : public CORINFO_Object
{
    unsigned                buffLen;
    unsigned                stringLen;
    const wchar_t           chars[1];       // actually of variable size
};

struct CORINFO_Array : public CORINFO_Object
{
    unsigned                length;

#if 0
    /* Multi-dimensional arrays have the lengths and bounds here */
    unsigned                dimLength[length];
    unsigned                dimBound[length];
#endif

    union
    {
        __int8              i1Elems[1];    // actually of variable size
        unsigned __int8     u1Elems[1];
        __int16             i2Elems[1];
        unsigned __int16    u2Elems[1];
        __int32             i4Elems[1];
        unsigned __int32    u4Elems[1];
        float               r4Elems[1];
        double              r8Elems[1];
        __int64             i8Elems[1];
        unsigned __int64    u8Elems[1];
    };
};

struct CORINFO_RefArray : public CORINFO_Object
{
    unsigned                length;
    CORINFO_CLASS_HANDLE    cls;

#if 0
    /* Multi-dimensional arrays have the lengths and bounds here */
    unsigned                dimLength[length];
    unsigned                dimBound[length];
#endif

    CORINFO_Object*         refElems[1];    // actually of variable size;
};

struct CORINFO_RefAny
{
    void                        *dataPtr;
    CORINFO_CLASS_HANDLE        type;
};

// The jit assumes the CORINFO_VARARGS_HANDLE is a pointer to a subclass of this
struct CORINFO_VarArgInfo
{
    unsigned                argBytes;       // number of bytes the arguments take up.
                                            // (The CORINFO_VARARGS_HANDLE counts as an arg)
};

#pragma pack(pop)

// use offsetof to get the offset of the fields above
#include <stddef.h> // offsetof
#ifndef offsetof
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif

/**********************************************************************************/

/************************************************************************
 * CORINFO_METHOD_HANDLE can actually refer to either a Function or a method, the
 * following callbacks are legal for either functions are methods
 ************************************************************************/

class ICorMethodInfo
{
public:
    // this function is for debugging only.  It returns the method name
    // and if 'moduleName' is non-null, it sets it to something that will
    // says which method (a class name, or a module name)
    virtual const char* __stdcall getMethodName (
            CORINFO_METHOD_HANDLE       ftn,        /* IN */
            const char                **moduleName  /* OUT */
            ) = 0;

    // this function is for debugging only.  It returns a value that
    // is will always be the same for a given method.  It is used
    // to implement the 'jitRange' functionality
    virtual unsigned __stdcall getMethodHash (
            CORINFO_METHOD_HANDLE       ftn         /* IN */
            ) = 0;

    // return flags (defined above, CORINFO_FLG_PUBLIC ...)
    virtual DWORD __stdcall getMethodAttribs (
            CORINFO_METHOD_HANDLE       ftn,        /* IN */
            CORINFO_METHOD_HANDLE       context     /* IN */
            ) = 0;

    // return method invocation category. Use this rather than
    // getMethodAttribs to determine form of call.
    virtual CorInfoCallCategory __stdcall getMethodCallCategory(
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // sets private JIT flags, which can be, retrieved using getAttrib.
    virtual void __stdcall setMethodAttribs (
            CORINFO_METHOD_HANDLE       ftn,        /* IN */
            DWORD                       attribs     /* IN */
            ) = 0;

    virtual void __stdcall getMethodSig (
             CORINFO_METHOD_HANDLE      ftn,        /* IN  */
             CORINFO_SIG_INFO          *sig         /* OUT */
             ) = 0;

        /*********************************************************************
         * Note the following methods can only be used on functions known
         * to be IL.  This includes the method being compiled and any method
         * that 'getMethodInfo' returns true for
         *********************************************************************/

        // return information about a method private to the implementation
        //      returns false if method is not IL, or is otherwise unavailable.
        //      This method is used to fetch data needed to inline functions
    virtual bool __stdcall getMethodInfo (
            CORINFO_METHOD_HANDLE   ftn,            /* IN  */
            CORINFO_METHOD_INFO*    info            /* OUT */
            ) = 0;

    //  Returns false if the call is across assemblies thus we cannot inline

    virtual CorInfoInline __stdcall canInline (
            CORINFO_METHOD_HANDLE   callerHnd,      /* IN  */
            CORINFO_METHOD_HANDLE   calleeHnd,      /* IN  */
            CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY           /* IN  */
            ) = 0;

    //  Returns false if the call is across assemblies thus we cannot tailcall

    virtual bool __stdcall canTailCall (
            CORINFO_METHOD_HANDLE   callerHnd,      /* IN  */
            CORINFO_METHOD_HANDLE   calleeHnd,      /* IN  */
            CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY           /* IN  */
            ) = 0;

    // get individual exception handler
    virtual void __stdcall getEHinfo(
            CORINFO_METHOD_HANDLE ftn,              /* IN  */
            unsigned          EHnumber,             /* IN */
            CORINFO_EH_CLAUSE* clause               /* OUT */
            ) = 0;

    // return class it belongs to
    virtual CORINFO_CLASS_HANDLE __stdcall getMethodClass (
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // return module it belongs to
    virtual CORINFO_MODULE_HANDLE __stdcall getMethodModule (
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // This function returns the offset of the specified method in the
    // vtable of it's owning class or interface.
    virtual unsigned __stdcall getMethodVTableOffset (
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // If a method's attributes have (getMethodAttribs) CORINFO_FLG_INTRINSIC set,
    // getIntrinsicID() returns the intrinsic ID.
    virtual CorInfoIntrinsics __stdcall getIntrinsicID(
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // returns TRUE if 'field' can be modified in method
    // (should return FALSE if the field is final, and we are not in a class initializer)
    virtual BOOL __stdcall canPutField(
            CORINFO_METHOD_HANDLE       method,
            CORINFO_FIELD_HANDLE        field
            ) = 0;

    // return the unmanaged calling convention for a PInvoke
    virtual CorInfoUnmanagedCallConv __stdcall getUnmanagedCallConv(
            CORINFO_METHOD_HANDLE       method
            ) = 0;

    // return if any marshaling is required for PInvoke methods.  Note that
    // method == 0 => calli.  The call site sig is only needed for the varargs or calli case
    virtual BOOL __stdcall pInvokeMarshalingRequired(
            CORINFO_METHOD_HANDLE       method, 
            CORINFO_SIG_INFO*           callSiteSig
            ) = 0;

    // TRUE if the methods are compatible
    virtual BOOL __stdcall compatibleMethodSig(
            CORINFO_METHOD_HANDLE        child, 
            CORINFO_METHOD_HANDLE        parent
            ) = 0;

    // Check Visibility rules.
    // For Protected (family access) members, type of the instance is also
    // considered when checking visibility rules.
    virtual BOOL __stdcall canAccessMethod(
            CORINFO_METHOD_HANDLE       context,
            CORINFO_METHOD_HANDLE       target,
            CORINFO_CLASS_HANDLE        instance
            ) = 0;

    // Given a Delegate type and a method, check if the method signature
    // is Compatible with the Invoke method of the delegate.
    virtual BOOL __stdcall isCompatibleDelegate(
            CORINFO_CLASS_HANDLE        objCls,
            CORINFO_METHOD_HANDLE       method,
            CORINFO_METHOD_HANDLE       delegateCtor
            ) = 0;
};

/**********************************************************************************/

class ICorModuleInfo
{
public:
    // return flags (for things like CORINFO_FLG_TRUSTED)
    virtual DWORD __stdcall getModuleAttribs (
            CORINFO_MODULE_HANDLE   module          /* IN  */
            ) = 0;

    // the context parameter is used to do access checks.  If 0, no access checks are done
    virtual CORINFO_CLASS_HANDLE __stdcall findClass (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK,    /* IN  */
            CORINFO_METHOD_HANDLE       context     /* IN  */
            ) = 0;

    // the context parameter is used to do access checks.  If 0, no access checks are done
    virtual CORINFO_FIELD_HANDLE __stdcall findField (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK,    /* IN  */
            CORINFO_METHOD_HANDLE       context     /* IN  */
            ) = 0;

    // This looks up a function by token (what the IL CALLVIRT, CALLSTATIC instructions use)
    // the context parameter is used to do access checks.  If 0, no access checks are done
    virtual CORINFO_METHOD_HANDLE __stdcall findMethod (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK,    /* IN */
            CORINFO_METHOD_HANDLE       context     /* IN  */
            ) = 0;

    // Signature information about the call sig
    virtual void __stdcall findSig (
            CORINFO_MODULE_HANDLE       module,     /* IN */
            unsigned                    sigTOK,     /* IN */
            CORINFO_SIG_INFO           *sig         /* OUT */
            ) = 0;

    // for Varargs, the signature at the call site may differ from
    // the signature at the definition.  Thus we need a way of
    // fetching the call site information
    virtual void __stdcall findCallSiteSig (
            CORINFO_MODULE_HANDLE       module,     /* IN */
            unsigned                    methTOK,    /* IN */
            CORINFO_SIG_INFO           *sig         /* OUT */
            ) = 0;

    //@DEPRECATED: Use embedGenericToken() instead
    // Finds an EE token handle (could be a CORINFO_CLASS_HANDLE, or a
    // CORINFO_METHOD_HANDLE ...) in a generic way
    // the context parameter is used to do access checks.  If 0, no access checks are done
    virtual CORINFO_GENERIC_HANDLE __stdcall findToken (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK,    /* IN  */
            CORINFO_METHOD_HANDLE       context,     /* IN  */
            CORINFO_CLASS_HANDLE&       tokenType   /* OUT */
            ) = 0;

    virtual const char * __stdcall findNameOfToken (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            mdToken                     metaTOK     /* IN  */
            ) = 0;

    // Returns true if the module does not require verification
    virtual BOOL __stdcall canSkipVerification (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            BOOL                        fQuickCheckOnly
            ) = 0;

    // Checks if the given metadata token is valid
    virtual BOOL __stdcall isValidToken (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK     /* IN  */
            ) = 0;

    // Checks if the given metadata token is valid StringRef
    virtual BOOL __stdcall isValidStringRef (
            CORINFO_MODULE_HANDLE       module,     /* IN  */
            unsigned                    metaTOK     /* IN  */
            ) = 0;

};

/**********************************************************************************/

class ICorClassInfo
{
public:
    // If the value class 'cls' is isomorphic to a primitive type it will
    // return that type, otherwise it will return CORINFO_TYPE_VALUECLASS
    virtual CorInfoType __stdcall asCorInfoType (
            CORINFO_CLASS_HANDLE    cls
            ) = 0;

    // for completeness
    virtual const char* __stdcall getClassName (
            CORINFO_CLASS_HANDLE    cls
            ) = 0;

    // return flags (defined above, CORINFO_FLG_PUBLIC ...)
    virtual DWORD __stdcall getClassAttribs (
            CORINFO_CLASS_HANDLE    cls,
            CORINFO_METHOD_HANDLE   context
            ) = 0;

    virtual CORINFO_MODULE_HANDLE __stdcall getClassModule (
            CORINFO_CLASS_HANDLE    cls
            ) = 0;

    // get the class representing the single dimentional array for the
    // element type represented by clsHnd
    virtual CORINFO_CLASS_HANDLE __stdcall getSDArrayForClass (
            CORINFO_CLASS_HANDLE    clsHnd
            ) = 0 ;

    // return the number of bytes needed by an instance of the class
    virtual unsigned __stdcall getClassSize (
            CORINFO_CLASS_HANDLE        cls
            ) = 0;

    // This is only called for Value classes.  It returns a boolean array
    // in representing of 'cls' from a GC perspective.  The class is
    // assumed to be an array of machine words
    // (of length // getClassSize(cls) / sizeof(void*)),
    // 'gcPtrs' is a poitner to an array of BYTEs of this length.
    // getClassGClayout fills in this array so that gcPtrs[i] is set 
    // to one of the CorInfoGCType values which is the GC type of
    // the i-th machine word of an object of type 'cls'
    // returns the number of GC pointers in the array
    virtual unsigned __stdcall getClassGClayout (
            CORINFO_CLASS_HANDLE        cls,        /* IN */
            BYTE                       *gcPtrs      /* OUT */
            ) = 0;

    // returns the number of instance fields in a class
    virtual const unsigned __stdcall getClassNumInstanceFields (
            CORINFO_CLASS_HANDLE        cls        /* IN */
            ) = 0;

    // returns the "NEW" helper optimized for "newCls."
    virtual CorInfoHelpFunc __stdcall getNewHelper(
            CORINFO_CLASS_HANDLE        newCls,
            CORINFO_METHOD_HANDLE       context
            ) = 0;

    // returns the newArr (1-Dim array) helper optimized for "arrayCls."
    virtual CorInfoHelpFunc __stdcall getNewArrHelper(
            CORINFO_CLASS_HANDLE        arrayCls,
            CORINFO_METHOD_HANDLE       context
            ) = 0;

    // returns the "IsInstanceOf" helper optimized for "IsInstCls."
    virtual CorInfoHelpFunc __stdcall getIsInstanceOfHelper(
            CORINFO_CLASS_HANDLE        IsInstCls
            ) = 0;

    // returns the "ChkCast" helper optimized for "IsInstCls."
    virtual CorInfoHelpFunc __stdcall getChkCastHelper(
            CORINFO_CLASS_HANDLE        IsInstCls
            ) = 0;

    // tries to initialize the class (run the class constructor).
    // this function can return false, which means that the JIT must
    // insert helper calls before accessing class members.
    virtual BOOL __stdcall initClass(
            CORINFO_CLASS_HANDLE        cls,
            CORINFO_METHOD_HANDLE       context,
            BOOL                        speculative = FALSE     // TRUE means don't actually run it
            ) = 0;

    // tries to load the class
    // this function can return false, which means that the JIT must
    // insert helper calls before accessing class members.
    virtual BOOL __stdcall loadClass(
            CORINFO_CLASS_HANDLE        cls,
            CORINFO_METHOD_HANDLE       context,
            BOOL                        speculative = FALSE     // TRUE means don't actually run it
            ) = 0;

    // returns the class handle for the special builtin classes
    virtual CORINFO_CLASS_HANDLE __stdcall getBuiltinClass (
            CorInfoClassId              classId
            ) = 0;

    // "System.Int32" ==> CORINFO_TYPE_INT..
    virtual CorInfoType __stdcall getTypeForPrimitiveValueClass(
            CORINFO_CLASS_HANDLE        cls
            ) = 0;

    // TRUE if child is a subtype of parent
    // if parent is an interface, then does child implement / extend parent
    virtual BOOL __stdcall canCast(
            CORINFO_CLASS_HANDLE        child,  // subtype (extends parent)
            CORINFO_CLASS_HANDLE        parent  // base type
            ) = 0;

    // returns is the intersection of cls1 and cls2.
    virtual CORINFO_CLASS_HANDLE __stdcall mergeClasses(
            CORINFO_CLASS_HANDLE        cls1, 
            CORINFO_CLASS_HANDLE        cls2
            ) = 0;

    // Given a class handle, returns the Parent type.
    // For COMObjectType, it returns Class Handle of System.Object.
    // Returns 0 if System.Object is passed in.
    virtual CORINFO_CLASS_HANDLE __stdcall getParentType (
            CORINFO_CLASS_HANDLE        cls
            ) = 0;

    // Returns the CorInfoType of the "child type". If the child type is
    // not a primitive type, *clsRet will be set.
    // Given an Array of Type Foo, returns Foo.
    // Given BYREF Foo, returns Foo
    virtual CorInfoType __stdcall getChildType (
            CORINFO_CLASS_HANDLE       clsHnd,
            CORINFO_CLASS_HANDLE       *clsRet
            ) = 0;

    // Check Visibility rules.
    virtual BOOL __stdcall canAccessType(
            CORINFO_METHOD_HANDLE       context,
            CORINFO_CLASS_HANDLE        target
            ) = 0;

    // Check if this is a Single Dimentional Array
    virtual BOOL __stdcall isSDArray(
            CORINFO_CLASS_HANDLE        cls
            ) = 0;
};


/**********************************************************************************/

class ICorFieldInfo
{
public:
    // this function is for debugging only.  It returns the field name
    // and if 'moduleName' is non-null, it sets it to something that will
    // says which method (a class name, or a module name)
    virtual const char* __stdcall getFieldName (
                        CORINFO_FIELD_HANDLE        ftn,        /* IN */
                        const char                **moduleName  /* OUT */
                        ) = 0;

    // return flags (defined above, CORINFO_FLG_PUBLIC ...)
    virtual DWORD __stdcall getFieldAttribs (
                        CORINFO_FIELD_HANDLE    field,
                        CORINFO_METHOD_HANDLE   context,
                        CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY
                        ) = 0;

    // return class it belongs to
    virtual CORINFO_CLASS_HANDLE __stdcall getFieldClass (
                        CORINFO_FIELD_HANDLE    field
                        ) = 0;

    // return the field's type, if it is CORINFO_TYPE_VALUECLASS 'structType' is set
    // the field's value class (if 'structType' == 0, then don't bother
    // the structure info).
    virtual CorInfoType __stdcall getFieldType(
                        CORINFO_FIELD_HANDLE    field,
                        CORINFO_CLASS_HANDLE   *structType
                        ) = 0;

    // returns the field's compilation category
    virtual CorInfoFieldCategory __stdcall getFieldCategory (
                        CORINFO_FIELD_HANDLE    field
                        ) = 0;

    // returns the field's compilation category
    virtual CorInfoHelpFunc __stdcall getFieldHelper(
                        CORINFO_FIELD_HANDLE    field,
                        enum CorInfoFieldAccess kind    // Get, Set, Address
                        ) = 0;


    // return the offset of the indirection pointer for indirect fields
    virtual unsigned __stdcall getIndirectionOffset (
                        ) = 0;

    // return the data member's instance offset
    virtual unsigned __stdcall getFieldOffset (
                        CORINFO_FIELD_HANDLE    field
                        ) = 0;

    // return the data member's number
    virtual const unsigned __stdcall getFieldNumber (
                        CORINFO_FIELD_HANDLE    field
                        ) = 0;

    // return the enclosing class of the field
    virtual CORINFO_CLASS_HANDLE __stdcall getEnclosingClass (
                        CORINFO_FIELD_HANDLE    field
                        ) = 0;

    // Check Visibility rules.
    // For Protected (family access) members, type of the instance is also
    // considered when checking visibility rules.
    virtual BOOL __stdcall canAccessField(
                        CORINFO_METHOD_HANDLE   context,
                        CORINFO_FIELD_HANDLE    target,
                        CORINFO_CLASS_HANDLE    instance
                        ) = 0;
};

/*********************************************************************************/

class ICorDebugInfo
{
public:

    /*----------------------------- Boundary-info ---------------------------*/

    enum MappingTypes
    {
        NO_MAPPING  = -1,
        PROLOG      = -2,
        EPILOG      = -3
    };

    enum BoundaryTypes
    {
        NO_BOUNDARIES           = 0x00,
        STACK_EMPTY_BOUNDARIES  = 0x01,
        CALL_SITE_BOUNDARIES    = 0x02,
        ALL_BOUNDARIES          = 0x04
    };

    // Note that SourceTypes can be or'd together - it's possible that
    // a sequence point will also be a stack_empty point, and/or a call site.
    // The debugger will check to see if a boundary offset's source field &
    // SEQUENCE_POINT is true to determine if the boundary is a sequence point.
    enum SourceTypes
    {
        SOURCE_TYPE_INVALID        = 0x00, // To indicate that nothing else applies
        SEQUENCE_POINT             = 0x01, // The debugger asked for it.
        STACK_EMPTY                = 0x02, // The stack is empty here
        CALL_SITE                  = 0x04, // This is a call site.
 		NATIVE_END_OFFSET_UNKNOWN  = 0x08 // Indicates a epilog endpoint
    };

    struct OffsetMapping
    {
        DWORD           nativeOffset;
        DWORD           ilOffset;
        SourceTypes     source; // The debugger needs this so that
                                // we don't put Edit and Continue breakpoints where
                                // the stack isn't empty.  We can put regular breakpoints
                                // there, though, so we need a way to discriminate
                                // between offsets.
    };

        // query the EE to find out where interesting break points
        // in the code are.  The JIT will insure that these places
        // have a corresponding break point in native code.
    virtual void __stdcall getBoundaries(
                CORINFO_METHOD_HANDLE   ftn,                // [IN] method of interest
                unsigned int           *cILOffsets,         // [OUT] size of pILOffsets
                DWORD                 **pILOffsets,         // [OUT] IL offsets of interest
                                                            //       jit MUST free with freeArray!
                BoundaryTypes          *implictBoundaries   // [OUT] tell jit, all boundries of this type
                ) = 0;

    // report back the mapping from IL to native code,
    // this map should include all boundaries that 'getBoundaries'
    // reported as interesting to the debugger.

    // Note that debugger (and profiler) is assuming that all of the
    // offsets form a contiguous block of memory, and that the
    // OffsetMapping is sorted in order of increasing native offset.
    virtual void __stdcall setBoundaries(
                CORINFO_METHOD_HANDLE   ftn,            // [IN] method of interest
                ULONG32                 cMap,           // [IN] size of pMap
                OffsetMapping          *pMap            // [IN] map including all points of interest.
                                                        //      jit allocated with allocateArray, EE frees
                ) = 0;

    /*------------------------------ Var-info -------------------------------*/

    enum RegNum
    {
#ifdef _X86_
        REGNUM_EAX,
        REGNUM_ECX,
        REGNUM_EDX,
        REGNUM_EBX,
        REGNUM_ESP,
        REGNUM_EBP,
        REGNUM_ESI,
        REGNUM_EDI,
#endif
        REGNUM_COUNT
    };

    // VarLoc describes the location of a native variable

    enum VarLocType
    {
        VLT_REG,        // variable is in a register
        VLT_STK,        // variable is on the stack (memory addressed relative to the frame-pointer)
        VLT_REG_REG,    // variable lives in two registers
        VLT_REG_STK,    // variable lives partly in a register and partly on the stack
        VLT_STK_REG,    // reverse of VLT_REG_STK
        VLT_STK2,       // variable lives in two slots on the stack
        VLT_FPSTK,      // variable lives on the floating-point stack
        VLT_FIXED_VA,   // variable is a fixed argument in a varargs function (relative to VARARGS_HANDLE)
        VLT_MEMORY,     // used for varargs' sigcookie. @TODO: Remove this once VLT_FIXED_VA works

        VLT_COUNT,
        VLT_INVALID
    };

    struct VarLoc
    {
        VarLocType      vlType;

        union
        {
            // VLT_REG -- Any 32 bit enregistered value (TYP_INT, TYP_REF, etc)
            // eg. EAX

            struct
            {
                RegNum      vlrReg;
            } vlReg;

            // VLT_STK -- Any 32 bit value which is on the stack
            // eg. [ESP+0x20], or [EBP-0x28]

            struct
            {
                RegNum      vlsBaseReg;
                signed      vlsOffset;
            } vlStk;

            // VLT_REG_REG -- TYP_LONG with both DWords enregistred
            // eg. RBM_EAXEDX

            struct
            {
                RegNum      vlrrReg1;
                RegNum      vlrrReg2;
            } vlRegReg;

            // VLT_REG_STK -- Partly enregistered TYP_LONG
            // eg { LowerDWord=EAX UpperDWord=[ESP+0x8] }

            struct
            {
                RegNum      vlrsReg;
                struct
                {
                    RegNum      vlrssBaseReg;
                    signed      vlrssOffset;
                }           vlrsStk;
            } vlRegStk;

            // VLT_STK_REG -- Partly enregistered TYP_LONG
            // eg { LowerDWord=[ESP+0x8] UpperDWord=EAX }

            struct
            {
                struct
                {
                    RegNum      vlsrsBaseReg;
                    signed      vlsrsOffset;
                }           vlsrStk;
                RegNum      vlsrReg;
            } vlStkReg;

            // VLT_STK2 -- Any 64 bit value which is on the stack,
            // in 2 successsive DWords.
            // eg 2 DWords at [ESP+0x10]

            struct
            {
                RegNum      vls2BaseReg;
                signed      vls2Offset;
            } vlStk2;

            // VLT_FPSTK -- enregisterd TYP_DOUBLE (on the FP stack)
            // eg. ST(3). Actually it is ST("FPstkHeigth - vpFpStk")

            struct
            {
                unsigned        vlfReg;
            } vlFPstk;

            // VLT_FIXED_VA -- fixed argument of a varargs function.
            // The argument location depends on the size of the variable
            // arguments (...). Inspecting the VARARGS_HANDLE indicates the
            // location of the first arg. This argument can then be accessed
            // relative to the position of the first arg

            struct
            {
                unsigned        vlfvOffset;
            } vlFixedVarArg;

            // VLT_MEMORY

            struct
            {
                void        *rpValue; // pointer to the in-process
                // location of the value.
            } vlMemory;
        };
    };

    enum { VARARGS_HANDLE = -1 }; // Value for the CORINFO_VARARGS_HANDLE varNumber

    struct ILVarInfo
    {
        DWORD           startOffset;
        DWORD           endOffset;
        DWORD           varNumber;
    };

    struct NativeVarInfo
    {
        DWORD           startOffset;
        DWORD           endOffset;
        DWORD           varNumber;
        VarLoc          loc;
    };

    // query the EE to find out the scope of local varables.
    // normally the JIT would trash variables after last use, but
    // under debugging, the JIT needs to keep them live over their
    // entire scope so that they can be inspected.
    virtual void __stdcall getVars(
            CORINFO_METHOD_HANDLE           ftn,            // [IN]  method of interest
            ULONG32                        *cVars,          // [OUT] size of 'vars'
            ILVarInfo                     **vars,           // [OUT] scopes of variables of interest
                                                            //       jit MUST free with freeArray!
            bool                           *extendOthers    // [OUT] it TRUE, then assume the scope
                                                            //       of unmentioned vars is entire method
            ) = 0;

    // report back to the EE the location of every variable.
    // note that the JIT might split lifetimes into different
    // locations etc.
    virtual void __stdcall setVars(
            CORINFO_METHOD_HANDLE           ftn,            // [IN] method of interest
            ULONG32                         cVars,          // [IN] size of 'vars'
            NativeVarInfo                  *vars            // [IN] map telling where local vars are stored at what points
                                                            //      jit allocated with allocateArray, EE frees
            ) = 0;

    /*-------------------------- Misc ---------------------------------------*/

    // used to pass back arrays that the EE will free
    virtual void * __stdcall allocateArray(
                        ULONG              cBytes
                        ) = 0;

    // JitCompiler will free arrays passed from the EE using this
    virtual void __stdcall freeArray(
            void               *array
            ) = 0;
};

/*****************************************************************************/

class ICorArgInfo
{
public:
    // advance the pointer to the argument list.
    // a ptr of 0, is special and always means the first argument
    virtual CORINFO_ARG_LIST_HANDLE __stdcall getArgNext (
            CORINFO_ARG_LIST_HANDLE     args            /* IN */
            ) = 0;

    // Get the type of a particular argument
    // CORINFO_TYPE_UNDEF is returned when there are no more arguments
    // If the type returned is a primitive type (or an enum) *vcTypeRet set to NULL
    // otherwise it is set to the TypeHandle associted with the type
    virtual CorInfoTypeWithMod __stdcall getArgType (
            CORINFO_SIG_INFO*           sig,            /* IN */
            CORINFO_ARG_LIST_HANDLE     args,           /* IN */
            CORINFO_CLASS_HANDLE       *vcTypeRet       /* OUT */
            ) = 0;

    // If the Arg is a CORINFO_TYPE_CLASS fetch the class handle associated with it
    virtual CORINFO_CLASS_HANDLE __stdcall getArgClass (
            CORINFO_SIG_INFO*           sig,            /* IN */
            CORINFO_ARG_LIST_HANDLE     args            /* IN */
            ) = 0;
};


//------------------------------------------------------------------------------
//      This opaque type is used to communicate about fixups

struct    IDeferredLocation
{
    /*  Call back to apply a location to a reference,
        when the target location is known.
     */
    virtual void    applyLocation () = 0;
};

class ICorLinkInfo
{
public:
    // Called when the jit is trying to embed a method address in the
    // code stream & it is not yet available (i.e. getMethodEntryPoint has
    // returned NULL).
    //
    // The EE is passed the location where the address is to be written
    // into the code stream, and whether it is a relative or absolute address.
    //
    // The EE should return true if it promises to fixup the address before
    // the code method can be executed.     This is generally only possible
    // in static (pre-jit time) compilation scenarios.

    virtual bool __stdcall deferLocation(
            CORINFO_METHOD_HANDLE           ftn,        /* IN  */
            IDeferredLocation              *pIDL        /* IN  */
            ) = 0;
    /*
       The given IDeferredLocation is to be associated with the
       as yet unlocated, or imported, target ftn.  When ftn becomes
       located a call is made to pIDL->applyLocation().
       After the applyLocation() call is made, the ICorMethodInfo
       is guaranteed to remove its reference to the deferred location
       object, and never to call it again, so the deferred location
       object may be destroyed or recycled.
    */

    // Called when an absolute or relative pointer is embedded in the code
    // stream. A relocation may be recorded if necessary.
    virtual void __stdcall recordRelocation(
            void                          **location,   /* IN  */
            WORD                            fRelocType  /* IN  */
            ) = 0;
};

/*****************************************************************************
 * ICorErrorInfo contains methods to deal with SEH exceptions being thrown
 * from the corinfo interface.  These methods may be called when an exception
 * with code EXCEPTION_COMPLUS is caught.
 *
 * @todo: This interface is really a temporary placeholder and probably will move
 *                elsewhere.
 *****************************************************************************/

class ICorErrorInfo
{
public:
    // Returns the HRESULT of the current exception
    virtual HRESULT __stdcall GetErrorHRESULT() = 0;

    // Returns the class of the current exception
    virtual CORINFO_CLASS_HANDLE __stdcall GetErrorClass() = 0;

        // Returns the message of the current exception
        virtual ULONG __stdcall GetErrorMessage(LPWSTR buffer, ULONG bufferLength) = 0;

    // returns EXCEPTION_EXECUTE_HANDLER if it is OK for the compile to handle the
    //                        exception, abort some work (like the inlining) and continue compilation
    // returns EXCEPTION_CONTINUE_SEARCH if exception must always be handled by the EE
    //                    things like ThreadStoppedException ...
    // returns EXCEPTION_CONTINUE_EXECUTION if exception is fixed up by the EE

    virtual int __stdcall FilterException(struct _EXCEPTION_POINTERS *pExceptionPointers) = 0;
};


/*****************************************************************************
 * ICorStaticInfo contains EE interface methods which return values that are
 * constant from invocation to invocation.  Thus they may be imbedded in
 * persisted information like statically generated code. (This is of course
 * assuming that all code versions are identical each time.)
 *****************************************************************************/

class ICorStaticInfo : public ICorMethodInfo, public ICorModuleInfo,
                                           public ICorClassInfo, public ICorFieldInfo,
                                           public ICorDebugInfo, public ICorArgInfo,
                                           public ICorLinkInfo, public ICorErrorInfo
{
public:
    // Return details about EE internal data structures
    virtual void __stdcall getEEInfo(
                CORINFO_EE_INFO            *pEEInfoOut
                ) = 0;

    // This looks up a pointer to static data
    // Note that it only works on the current module
    virtual void* __stdcall findPtr (
                CORINFO_MODULE_HANDLE       module,     /* IN  */
                unsigned                    ptrTOK      /* IN */
                ) = 0;
};

/*****************************************************************************
 * ICorDynamicInfo contains EE interface methods which return values that may
 * change from invocation to invocation.  They cannot be imbedded in persisted
 * data; they must be requeried each time the EE is run.
 *****************************************************************************/

class ICorDynamicInfo : public ICorStaticInfo
{
public:

    //
    // These methods return values to the JIT which are not constant
    // from session to session.
    //
    // These methods take an extra parameter : void **ppIndirection.
    // If a JIT supports generation of prejit code (install-o-jit), it
    // must pass a non-null value for this parameter, and check the
    // resulting value.  If *ppIndirection is NULL, code should be
    // generated normally.  If non-null, then the value of
    // *ppIndirection is an address in the cookie table, and the code
    // generator needs to generate an indirection through the table to
    // get the resulting value.  In this case, the return result of the
    // function must NOT be directly embedded in the generated code.
    //
    // Note that if a JIT does not support prejit code generation, it
    // may ignore the extra parameter & pass the default of NULL - the
    // prejit ICorDynamicInfo implementation will see this & generate
    // an error if the jitter is used in a prejit scenario.
    //

    // Return details about EE internal data structures

    virtual DWORD __stdcall getThreadTLSIndex(
                    void                  **ppIndirection = NULL
                    ) = 0;

    virtual const void * __stdcall getInlinedCallFrameVptr(
                    void                  **ppIndirection = NULL
                    ) = 0;

    virtual LONG * __stdcall getAddrOfCaptureThreadGlobal(
                    void                  **ppIndirection = NULL
                    ) = 0;

    // return the native entry point to an EE helper (see CorInfoHelpFunc)
    virtual void* __stdcall getHelperFtn (
                    CorInfoHelpFunc         ftnNum,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // return a callable address of the function (native code). This function
    // may return a different value (depending on whether the method has
    // been JITed or not.  pAccessType is an in-out parameter.  The JIT
    // specifies what level of indirection it desires, and the EE sets it
    // to what it can provide (which may not be the same).  Currently the
    virtual void* __stdcall getFunctionEntryPoint(
                    CORINFO_METHOD_HANDLE   ftn,            /* IN  */
                    InfoAccessType         *pAccessType,    /* INOUT */
                    CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY
                    ) = 0;

    // return a directly callable address. This can be used similarly to the
    // value returned by getFunctionEntryPoint() except that it is
    // guaranteed to be the same for a given function. 
    // pAccessType is an in-out parameter.  The JIT
    // specifies what level of indirection it desires, and the EE sets it
    // to what it can provide (which may not be the same).  Currently the
    virtual void* __stdcall getFunctionFixedEntryPoint(
                    CORINFO_METHOD_HANDLE   ftn,
                    InfoAccessType         *pAccessType,    /* INOUT */
                    CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY
                    ) = 0;

    // get the syncronization handle that is passed to monXstatic function
    virtual void* __stdcall getMethodSync(
                    CORINFO_METHOD_HANDLE               ftn,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // These entry points must be called if a handle is being embedded in
    // the code to be passed to a JIT helper function. (as opposed to just
    // being passed back into the ICorInfo interface.)

    virtual CORINFO_MODULE_HANDLE __stdcall embedModuleHandle(
                    CORINFO_MODULE_HANDLE   handle,
                    void                  **ppIndirection = NULL
                    ) = 0;

    virtual CORINFO_CLASS_HANDLE __stdcall embedClassHandle(
                    CORINFO_CLASS_HANDLE    handle,
                    void                  **ppIndirection = NULL
                    ) = 0;

    virtual CORINFO_METHOD_HANDLE __stdcall embedMethodHandle(
                    CORINFO_METHOD_HANDLE   handle,
                    void                  **ppIndirection = NULL
                    ) = 0;

    virtual CORINFO_FIELD_HANDLE __stdcall embedFieldHandle(
                    CORINFO_FIELD_HANDLE    handle,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // Finds an embeddable EE token handle (could be a CORINFO_CLASS_HANDLE, or a
    // CORINFO_METHOD_HANDLE ...) in a generic way
    // the context parameter is used to do access checks.  If 0, no access checks are done
    virtual CORINFO_GENERIC_HANDLE __stdcall embedGenericHandle(
                    CORINFO_MODULE_HANDLE   module,
                    unsigned                metaTOK,
                    CORINFO_METHOD_HANDLE   context,
                    void                  **ppIndirection,
                    CORINFO_CLASS_HANDLE& tokenType 
                    ) = 0;

    // allocate a call site hint
    virtual void** __stdcall AllocHintPointer(
                    CORINFO_METHOD_HANDLE   method,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // return the unmanaged target *if method has already been prelinked.*
    virtual void* __stdcall getPInvokeUnmanagedTarget(
                    CORINFO_METHOD_HANDLE   method,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // return address of fixup area for late-bound PInvoke calls.
    virtual void* __stdcall getAddressOfPInvokeFixup(
                    CORINFO_METHOD_HANDLE   method,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // Generate a cookie based on the signature that would needs to be passed
    // to CORINFO_HELP_PINVOKE_CALLI
    virtual LPVOID GetCookieForPInvokeCalliSig(
            CORINFO_SIG_INFO* szMetaSig,
            void           ** ppIndirection = NULL
            ) = 0;

    // Gets a method handle that can be used to correlate profiling data.
    // This is the IP of a native method, or the address of the descriptor struct
    // for IL.  Always guaranteed to be unique per process, and not to move. */
    virtual CORINFO_PROFILING_HANDLE __stdcall GetProfilingHandle(
                    CORINFO_METHOD_HANDLE   method,
                    BOOL                   *pbHookFunction,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // returns the unique ID associated with an inteface class
    virtual void* __stdcall getInterfaceID (
                    CORINFO_CLASS_HANDLE    cls,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // returns the offset into the interface table
    virtual unsigned __stdcall getInterfaceTableOffset (
                    CORINFO_CLASS_HANDLE    cls,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // returns the class's domain ID for accessing shared statics
    virtual unsigned __stdcall getClassDomainID (
                    CORINFO_CLASS_HANDLE    cls,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // return the data's address (for static fields only)
    virtual void* __stdcall getFieldAddress(
                    CORINFO_FIELD_HANDLE    field,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // registers a vararg sig & returns a VM cookie for it (which can contain other stuff)
    virtual CORINFO_VARARGS_HANDLE __stdcall getVarArgsHandle(
                    CORINFO_SIG_INFO       *pSig,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // Allocate a string literal on the heap and return a handle to it
    virtual LPVOID __stdcall constructStringLiteral(
                    CORINFO_MODULE_HANDLE   module,
                    mdToken                 metaTok,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // (static fields only) given that 'field' refers to thread local store,
    // return the ID (TLS index), which is used to find the begining of the
    // TLS data area for the particular DLL 'field' is associated with.
    virtual DWORD __stdcall getFieldThreadLocalStoreID (
                    CORINFO_FIELD_HANDLE    field,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // returns the class typedesc given a methodTok (needed for arrays since
    // they share a common method table, so we can't use getMethodClass)
    virtual CORINFO_CLASS_HANDLE __stdcall findMethodClass(
                    CORINFO_MODULE_HANDLE   module,
                    mdToken                 methodTok)
                    = 0;
    // returns the extra (type instantiation) parameter to be pushed as the last 
    // argument for static methods on parametersized types 
    // (needed when CORINFO_FLG_INSTPARAM is set)
    virtual LPVOID __stdcall getInstantiationParam(
                    CORINFO_MODULE_HANDLE   module,
                    mdToken                 methodTok,
                    void                  **ppIndirection = NULL
                    ) = 0;

    // Sets another object to intercept calls to "self"
    virtual void __stdcall setOverride(
                ICorDynamicInfo             *pOverride
                ) = 0;
};

/*****************************************************************************
 * These typedefs indication the calling conventions for the various helper
 * functions
 *****************************************************************************/

/*
 * Arithmetic helpers
 */

typedef __int64                 (__stdcall *pHlpLLsh) (void);     // val = EDX:EAX  count = ECX
typedef __int64                 (__stdcall *pHlpLRsh) (void);     // val = EDX:EAX  count = ECX
typedef __int64                 (__stdcall *pHlpLRsz) (void);     // val = EDX:EAX  count = ECX
typedef __int64                 (__stdcall *pHlpLMul) (__int64 val1, __int64 val2);
typedef unsigned __int64        (__stdcall *pHlpULMul) (unsigned __int64 val1, unsigned __int64 val2);
typedef __int64                 (__stdcall *pHlpLDiv) (__int64 divisor, __int64 dividend);
typedef unsigned __int64        (__stdcall *pHlpULDiv) (unsigned __int64 divisor, unsigned __int64 dividend);
typedef __int64                 (__stdcall *pHlpLMulOvf) (__int64 val2, __int64 val1);
typedef __int64                 (__stdcall *pHlpLMod) (__int64 divisor, __int64 dividend);
typedef unsigned __int64        (__stdcall *pHlpULMod) (unsigned __int64 divisor, unsigned __int64 dividend);

typedef int                     (__stdcall *pHlpFlt2Int) (float val);
typedef __int64                 (__stdcall *pHlpFlt2Lng) (float val);
typedef int                     (__stdcall *pHlpDbl2Int) (double val);
typedef __int64                 (__stdcall *pHlpDbl2Lng) (double val);
typedef double                  (__stdcall *pHlpDblRem) (double divisor, double dividend);
typedef float                   (__stdcall *pHlpFltRem) (float divisor, float dividend);

/*
 * Allocating a new object
 */
// FIX NOW.  Most of the args here have to be reversed!!!

typedef CORINFO_Object          (__fastcall *pHlpNew_Direct) (CORINFO_CLASS_HANDLE cls);
// create an array of primitive types 'type' of length cElem
typedef CORINFO_Object          (__fastcall *pHlpNewArr) (CorInfoType type, unsigned cElem);
// create the array 'arrayClass' of length cElem
typedef CORINFO_Object          (__fastcall *pHlpNewArr_1_Direct) (CORINFO_CLASS_HANDLE arrayClass, unsigned cElem);

// this helper acts just like the IL NEWOBJ instruction. It expects its
// arguments to the constructor, the 'constr' handle is passed instead of
// the 'this' pointer.
// typedef CORINFO_Object       (__fastcall *pHlpNewObj) (CORINFO_METHOD_HANDLE constr, ...);

// the above defintion is the one we would like, but because
// arrays share the same class structure (and hence method handles),
// we are using the following, less efficient form
typedef CORINFO_Object          (_cdecl *pHlpNewObj) (CORINFO_MODULE_HANDLE module, unsigned constrTok, ...);

// create new multidimensional array, needs the maximum length
// for every dimension. NOTE: This list starts with the size
// of the inner-most (right-most) dimension !
typedef CORINFO_Object          (_cdecl *pHlpNewArr_N) (CORINFO_MODULE_HANDLE module, unsigned MetaTok, unsigned numDim, ...);  // Dim1 Dim2...

// get constant string
typedef CORINFO_Object          (__fastcall *pHlpStrCns) (CORINFO_MODULE_HANDLE module, unsigned MetaTok);

/*
 * Object model
 */

// If the class initializer for 'cls' has not been run, run it.
typedef void                    (__fastcall *pHlpInitClass) (CORINFO_CLASS_HANDLE cls);
typedef BOOL                    (__fastcall *pHlpIsInstanceOf) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
typedef CORINFO_Object          (__fastcall *pHlpChkCast) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
typedef CORINFO_MethodPtr       (__fastcall *pHlpResolveInterface) (CORINFO_Object obj, void* IID, unsigned * guess);
typedef CORINFO_MethodPtr       (__fastcall*pHlpEnCResolveVirtual)(CORINFO_Object obj, CORINFO_METHOD_HANDLE method);

typedef CORINFO_Object          (__fastcall *pHlpGetRefAny) (void* refAnyPtr, CORINFO_CLASS_HANDLE clsHnd);
typedef CORINFO_Object          (__fastcall *pHlpTypeRefAny) (void* refAnyPtr);

// Assign 'elem' to 'idx' of the array 'arr'
typedef void                    (__fastcall *pHlpArrAddr_St) (CORINFO_Object array, int index, CORINFO_Object elem);

// returns address of type 'type' to elem 'idx' of the array 'arr' (return value really an interior pointer
typedef void*                   (__fastcall *pHlpLdelema_Ref) (CORINFO_Object array, int index, CORINFO_CLASS_HANDLE type);

/*
 * Exceptions
 */

typedef void                    (__fastcall *pHlpThrow) (CORINFO_Object obj);
typedef void                    (__fastcall *pHlpRethrow) ();
typedef void                    (__fastcall *pHlpUserBreakpoint) ();
// tryIndex = 0 -> no encompassing try-statement in current method
// tryIndex > 0 -> index of nearest encompassing try-block (1-based)
typedef void                    (__fastcall *pHlpRngChkFail) (unsigned tryIndex);
typedef void                    (__fastcall *pHlpOverFlow) (unsigned tryIndex);
typedef void                    (__fastcall *pHlpInternalThrow) (CorInfoException throwEnum);
typedef void                    (__fastcall *pHlpEndCatch) ();

/*
 * Synchronization
 */

typedef void                    (__fastcall *pHlpMonEnter) (CORINFO_Object obj);
typedef void                    (__fastcall *pHlpMonExit) (CORINFO_Object obj);
typedef void                    (__fastcall *pHlpMonEnterStatic) (CORINFO_METHOD_HANDLE method);
typedef void                    (__fastcall *pHlpMonExitStatic) (CORINFO_METHOD_HANDLE method);

/*
 * GC support
 */

typedef void                    (__fastcall *pHlpStop_For_GC) ();     // Force a GC
typedef void                    (__fastcall *pHlpPoll_GC) ();         // Allow a GC

/*
 * GC Write barrier support
 */

typedef void                    (__fastcall *pHlpAssign_Ref_EAX)(); // *EDX = EAX, inform GC
typedef void                    (__fastcall *pHlpAssign_Ref_EBX)(); // *EDX = EBX, inform GC
typedef void                    (__fastcall *pHlpAssign_Ref_ECX)(); // *EDX = ECX, inform GC
typedef void                    (__fastcall *pHlpAssign_Ref_ESI)(); // *EDX = ESI, inform GC
typedef void                    (__fastcall *pHlpAssign_Ref_EDI)(); // *EDX = EDI, inform GC
typedef void                    (__fastcall *pHlpAssign_Ref_EBP)(); // *EDX = EBP, inform GC

/*
 * Accessing fields
 */

// applicable for all non-static fields, main purpose to set/get fields
// in non cor-native objects (e.g. COM)
typedef int                     (__fastcall *pHlpGetField32)    (CORINFO_Object obj, CORINFO_FIELD_HANDLE field);
typedef __int64                 (__fastcall *pHlpGetField64)    (CORINFO_Object obj, CORINFO_FIELD_HANDLE field);
typedef void                    (__fastcall *pHlpSetField32)    (CORINFO_Object obj, CORINFO_FIELD_HANDLE field, int val);
typedef void                    (__fastcall *pHlpSetField64)    (CORINFO_Object obj, CORINFO_FIELD_HANDLE field, __int64 val);
typedef void*                   (__fastcall *pHlpGetField32Obj) (CORINFO_Object obj, CORINFO_FIELD_HANDLE field);
typedef void*                   (__fastcall *pHlpGetFieldAddr)  (void *         obj, CORINFO_FIELD_HANDLE field);

/*
 * Miscellaneous
 */

// Arguments set us as usual. Eax has target address. Calli cookie from
// GetCookieForPInvokeCalliSig() should be last pushed on the stack.
typedef void                    (__fastcall *pHlpPinvokeCalli)();

// All callee-saved registers have to be saved on the stack just below the stack arguments,
// Enregistered arguements are in correct registers, remaining args pushed on stack,
// followed by count of stack arguments, followed by the target address.
// Has to be EBP frame.
typedef void                    (__fastcall *pHlpTailCall)();

/**********************************************************************************/

#endif // _COR_INFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corperme.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CorPermE.H
//
// Defines the Memory and Error routines defined in the secuirty libraries. 
// These routines are mainly for the security dll and the runtime.
//
//*****************************************************************************
#ifndef _CORPERME_H_
#define _CORPERME_H_


//=============================================================================
// Valid entries for the security Flag are:
//    0x0001 Print Security Exceptions
//    0x0002 Print errors 
//    0x0004 Log to file (otherwise it is dumped to a debug window only)
//    0x0008 Log to stderr if no log file specified
//    0x0010 Log to stdout if no log file specfied
//    0x0020 Log to debugger console
//    0x0040 Append to the log file instead of overwriting
//    0x0080 Flush log
//    0x00000100 Trace critical information (highest)
//    0x00000200 Trace out Win32 errors
//    0x00000400 Trace out COM errors
//    0x00000800 Trace out ASN errors
//    0x00001000 Debug stackwalk
//    0x00002000 CAPI errors
//    0x00004000 EE errors
//    0x00008000 Security User Interface
//    0x20000000 Trace out Crypto API Errors
//    0x40000000 Trace out permission type
//    0x80000000 Trace the function names (lowest)
//    0xffffff00 Trace levels 
//
// Registry Keys are:
// HKLM\software\Microsoft\ComponentLibrary
//    SecurityFlag
//    SecurityLog
//=============================================================================
typedef enum {
    S_EXCEPTIONS =  0x0001,
    S_ERRORS     =  0x0002,
    S_LOG        =  0x0004,
    S_STDERR     =  0x0008,       // 
    S_STDOUT     =  0x0010,       // 
    S_CONSOLE    =  0x0020,       // 
    S_APPEND     =  0x0040,       // Append to the file if it exists
    S_FLUSH      =  0x0080,       // Flush the file after every write
    S_CRITICAL   =  0x0100,       // Trace critical information
    S_WINDOWS    =  0x0200,       // Window Errors
    S_COM        =  0x0400,       // COM Errors
    S_ASN        =  0x0800,       // ASN Errors
    S_STACKWALK  =  0x1000,       // Debug stackwalk
    S_CAPI       =  0x2000,       // CAPI errors
    S_ENGINE     =  0x4000,       // EE errors
    S_UI         =  0x8000,       // Security User Interface
    S_RESOLVEINFO = 0x020000,     // Resolution information 
    S_PERMISSIONS = 0x40000000,
    S_FUNCTIONS  =  0x80000000,   // Trace the function names 
    S_ALL        =  0xffffff00
} DEBUG_FLAGS;

//
// Returns the current logging level
//
long LogLevel();

//
// Converts the current Win32 error into an HRESULT
//
static HRESULT Win32Error()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    return hr;
}

//
// Prints to log and debug console. Should be off the form
// LogWin32Error(L"Routine_name", L"Error message", error_level);
// Returns:
//      HRESULT         HRESULT corresponding to the current win32 error;
//
HRESULT SLogWin32Error(LPCSTR pswRoutine, LPCSTR pswComment, long level);

//
// Prints the HRESULT to the log file and debug consle.
// Should be of the form 
// LogError(hr, "Routine_Name", "Error message");
// Returns:
//      HRESULT         Error code passed in.
//
HRESULT SLogError(HRESULT hr, LPCSTR psRoutine, LPCSTR psComment, long level);

//
// Logs information to the log file, stderr or stdout. In debug builds it
// will also print out to the console. 
//
// SPrintLogA - ASCII version
//
void SPrintLogA(LPCSTR format, ...);
void SPrintLogW(LPCWSTR format, ...);

//
// Logging and debug console macros 
//
#ifdef DBG

//
// Prints to log and debug console. Should be off the form
// LOGWIN32("Routine_name", "Error message", error_level);
// Returns an HRESULT corresponding to the error;
//
#define LOGWIN32(x, y, z) SLogWin32Error(x, y, z)

//
// Prints the HRESULT to the log file and debug consle.
// Should be of the form 
// LOGERROR(hr, "Routine_Name", "Error message", error_level);
// Returns:
//      HRESULT         Error code passed in.
//
#define LOGERROR(h, x, y, z) SLogError(h, x, y, z)
#define LOGCORERROR(x, y, z) SLogError(x.corError, y, x.corMsg, z)

//
// Outputs to the log if there is sufficent priviledge
//
#define SECLOG(x, z) if(LogLevel() & z) SPrintLogA x
#else  // DBG

// Non debug then just return the error codes
#define LOGWIN32(x, y, z)  Win32Error();
#define LOGERROR(h, x, y, z)  h
#define LOGCORERROR(x, y, z) x.corError
#define SECLOG(x, z)

#endif  // DBG


//=============================================================================
// Error macros so we do not have to see goto's in the code
// Adds structure to where error handling and clean up code goes. Be careful
// when rethrowing EE exceptions, the routine must be cleaned up first.
//=============================================================================
typedef struct _CorError {
    HRESULT corError;
    LPSTR   corMsg;
} CorError;

#define CORTRY       HRESULT _tcorError = 0; LPSTR _tcorMsg = NULL;
#define CORTHROW(x)  {_tcorError = x; goto CORERROR;} //
#define CORCATCH(x)  goto CORCONT; \
                     CORERROR: \
                     { CorError x; x.corError = _tcorError; x.corMsg = _tcorMsg;
#define COREND       } CORCONT: //                                        

#ifdef DBG
// Debug versions for having annotated errors. Strings are removed in 
// free builds to keep size down.
// @TODO: set up standard error messages as localizable strings
#define CORTHROWMSG(x, y)  {_tcorError = x; _tcorMsg = y; goto CORERROR;} //
#else  // DBG
#define CORTHROWMSG(x, y)  {_tcorError = x; goto CORERROR;} //
#endif


#ifdef __cplusplus
extern "C" {
#endif

__inline
LPVOID WINAPI 
MallocM(size_t size)
{
    return LocalAlloc(LMEM_FIXED, size);
}

__inline
void WINAPI
FreeM(LPVOID pData)
{
    LocalFree((HLOCAL) pData);
}
    
#define WIDEN_CP CP_UTF8

// Helper macros for security logging
#define WIDEN(psz, pwsz) \
    LPCSTR _##psz = (LPCSTR) psz; \
    int _cc##psz = _##psz ? strlen(_##psz) + 1 : 0; \
    LPWSTR pwsz = (LPWSTR) (_cc##psz ? _alloca((_cc##psz) * sizeof(WCHAR)) : NULL); \
    if(pwsz) WszMultiByteToWideChar(WIDEN_CP, 0, _##psz, _cc##psz, pwsz, _cc##psz);


#define NARROW(pwsz, psz) \
    LPCWSTR _##pwsz = (LPCWSTR) pwsz; \
    int _cc##psz =  _##pwsz ? WszWideCharToMultiByte(WIDEN_CP, 0, _##pwsz, -1, NULL, 0, NULL, NULL) : 0; \
    LPSTR psz = (LPSTR) (_cc##psz ? _alloca(_cc##psz) : NULL); \
    if(psz) WszWideCharToMultiByte(WIDEN_CP, 0, _##pwsz, -1, psz, _cc##psz, NULL, NULL);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corjit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
*                                                                             *
* CorJit.h -    EE / JIT interface                                            *
*                                                                             *
*               Version 1.0                                                   *
*******************************************************************************
*                                                                             *
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY      *
*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE        *
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR      *
*  PURPOSE.                                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef _COR_JIT_H_
#define _COR_JIT_H_

#include <corinfo.h>

/* The default max method size that the inliner considers for inlining */
#define DEFAULT_INLINE_SIZE             32

/*****************************************************************************/
    // These are error codes returned by CompileMethod
enum CorJitResult
{
    // Note that I dont use FACILITY_NULL for the facility number,
    // we may want to get a 'real' facility number
    CORJIT_OK            =     NO_ERROR,
    CORJIT_BADCODE       =     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL, 1),
    CORJIT_OUTOFMEM      =     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL, 2),
    CORJIT_INTERNALERROR =     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL, 3),
    CORJIT_SKIPPED       =     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL, 4),
};

/* values for flags in compileMethod */

enum CorJitFlag
{
    CORJIT_FLG_SPEED_OPT           = 0x00000001,
    CORJIT_FLG_SIZE_OPT            = 0x00000002,
    CORJIT_FLG_DEBUG_OPT           = 0x00000004, // generate "debuggable" code
    CORJIT_FLG_DEBUG_EnC           = 0x00000008, // We are in Edit-n-Continue mode
    CORJIT_FLG_DEBUG_INFO          = 0x00000010, // generate line and local-var info
    CORJIT_FLG_LOOSE_EXCEPT_ORDER  = 0x00000020, // loose exception order 

    CORJIT_FLG_TARGET_PENTIUM      = 0x00000100,
    CORJIT_FLG_TARGET_PPRO         = 0x00000200,
    CORJIT_FLG_TARGET_P4           = 0x00000400,

    CORJIT_FLG_USE_FCOMI           = 0x00001000, // Generated code may use fcomi(p) instruction
    CORJIT_FLG_USE_CMOV            = 0x00002000, // Generated code may use cmov instruction

    CORJIT_FLG_PROF_CALLRET        = 0x00010000, // Wrap method calls with probes
    CORJIT_FLG_PROF_ENTERLEAVE     = 0x00020000, // Instrument prologues/epilogues
    CORJIT_FLG_PROF_INPROC_ACTIVE  = 0x00040000, // Inprocess debugging active requires different instrumentation
 CORJIT_FLG_PROF_NO_PINVOKE_INLINE = 0x00080000, // Disables PInvoke inlining
    CORJIT_FLG_SKIP_VERIFICATION   = 0x00100000, // (lazy) skip verification - determined without doing a full resolve.
    CORJIT_FLG_PREJIT              = 0x00200000, // jit or prejit is the execution engine.
    CORJIT_FLG_RELOC               = 0x00400000, // Generate relocatable code
    CORJIT_FLG_IMPORT_ONLY         = 0x00800000, // Only import the function
};

class ICorJitCompiler;
class ICorJitInfo;

extern "C" ICorJitCompiler* __stdcall getJit();

/*******************************************************************************
 * ICorJitCompiler is the interface that the EE uses to get IL byteocode converted
 * to native code.  Note that to accomplish this the JIT has to call back to the
 * EE to get symbolic information.  The IJitInfo passed to the compileMethod
 * routine is the handle the JIT uses to call back to the EE
 *******************************************************************************/

class ICorJitCompiler
{
public:
    virtual CorJitResult __stdcall compileMethod (
            ICorJitInfo				   *comp,               /* IN */
            struct CORINFO_METHOD_INFO *info,               /* IN */
            unsigned					flags,              /* IN */
            BYTE					  **nativeEntry,        /* OUT */
            ULONG					   *nativeSizeOfCode    /* OUT */
            ) = 0;
};

/*********************************************************************************
 * a ICorJitInfo is the main interface that the JIT uses to call back to the EE and
 *   get information
 *********************************************************************************/

class ICorJitInfo : public virtual ICorDynamicInfo
{
public:
    virtual HRESULT __stdcall alloc (
            ULONG code_len, unsigned char** ppCode,
            ULONG EHinfo_len, unsigned char** ppEHinfo,
            ULONG GCinfo_len, unsigned char** ppGCinfo
            ) = 0;

	// REVIEW: does not allow bbt-like separation of often/rarely used code
	// get a block of memory for the code, readonly data, and read-write data
    virtual HRESULT __stdcall allocMem (
            ULONG               codeSize,       /* IN */
            ULONG               roDataSize,     /* IN */
            ULONG               rwDataSize,     /* IN */
            void **             codeBlock,      /* OUT */
            void **             roDataBlock,    /* OUT */
            void **             rwDataBlock     /* OUT */
            ) = 0;

	// get a block of memory needed for the code manager informantion
	// (info for crawling the stack frame. Note that allocMem must be
	// called before this method can be called
    virtual HRESULT __stdcall allocGCInfo (
            ULONG               size,           /* IN */
            void **             block           /* OUT */
            ) = 0;

	// indicate how many exception handlers blocks are to be returned
	// this is guarenteed to be called before any 'setEHinfo' call.
	// Note that allocMem must be called before this method can be called
    virtual HRESULT __stdcall setEHcount (
            unsigned			cEH				/* IN */
			) = 0;

	// set the values for one particular exception handler block
    virtual void __stdcall setEHinfo (
            unsigned				EHnumber,   /* IN  */
            const CORINFO_EH_CLAUSE *clause      /* IN */
            ) = 0;

	// Level -> fatalError, Level 2 -> Error, Level 3 -> Warning
	// Level 4 means happens 10 times in a run, level 5 means 100, level 6 means 1000 ...
	// returns non-zero if the logging succeeded 
	virtual BOOL __cdecl logMsg(unsigned level, const char* fmt, va_list args) = 0;

	// do an assert.  will return true if the code should retry (DebugBreak)
	// returns false, if the assert should be igored.
	virtual int doAssert(const char* szFile, int iLine, const char* szExpr) = 0;
};

/**********************************************************************************/
#endif // _COR_CORJIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpermp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CorPermP.H
//
// Defines the Private routines defined in the secuirty libraries. These routines
// are mainly for the security dll and the runtime.
//
//*****************************************************************************
#ifndef _CORPERMP_H_
#define _CORPERMP_H_

#include "utilcode.h"
#include "CorPermE.h"

#ifdef __cplusplus
extern "C" {
#endif

//==========================================================================
// Encoding and Decoding PermissionSets

//==========================================================================
// Initialization routines for registering installable OIDS for capi20
// Currently there is no C/C++ support for OID parsing. It is only supported
// by using the permission objects within the runtime
// 
// Parameter: 
//      dllName         The name of the module (eg. mscorsec.dll)
// Returns:
//      S_OK            This routines only returns S_OK currently
//==========================================================================
HRESULT WINAPI CorPermRegisterServer(LPCWSTR dllName);
HRESULT WINAPI CorPermUnregisterServer();

//==========================================================================
// Removes the capi entries for installable OID's. Is not currently supported
// so does nothing
//
// Returns:
//      S_OK            This routines only returns S_OK currently
//==========================================================================
HRESULT WINAPI CorFactoryRegister(HINSTANCE hInst);

HRESULT WINAPI CorFactoryUnregister();

HRESULT WINAPI CorFactoryCanUnloadNow();

#ifdef __cplusplus
}
#endif
    

#include "CorPerm.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corperm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CorPerm.H
//
// Defines the public routines defined in the security libraries. All these
// routines are defined within CorPerm.lib.
//
//*****************************************************************************
#ifndef _CORPERM_H_
#define _CORPERM_H_

#include <wincrypt.h>
#include <urlmon.h>
#include <wintrust.h>
#include "CorHdr.h"
#include "CorPolicy.h"

#ifdef __cplusplus
extern "C" {
#endif


//--------------------------------------------------------------------------
// Global security settings
// ------------------------
// 

// Needs to be in sync with URLZONE
typedef enum {
    LocalMachine = URLZONE_LOCAL_MACHINE,     // 0, My Computer
    Intranet     = URLZONE_INTRANET,          // 1, The Intranet
    Trusted      = URLZONE_TRUSTED,           // 2, Trusted Zone
    Internet     = URLZONE_INTERNET,          // 3, The Internet
    Untrusted    = URLZONE_UNTRUSTED,         // 4, Untrusted Zone
    NumZones     = 5,
    NoZone       = -1
} SecZone;

// Managed URL action flags (see urlmon.idl)
#define URLACTION_MANAGED_MIN                           0x00002000
#define URLACTION_MANAGED_SIGNED                        0x00002001
#define URLACTION_MANAGED_UNSIGNED                      0x00002004
#define URLACTION_MANAGED_MAX                           0x000020FF

// Global disable flags. These are set for every zone.
#define CORSETTING_SECURITY_OFF                         0x1F000000
#define CORSETTING_EXECUTION_PERMISSION_CHECK_DISABLED  0x00000100
// This next flag is used to toggle old-vs-new policy
// eventually this will be pulled
#define CORSETTING_USEPOLICYMANAGER             0x01000000

// Trust Levels 
#define URLPOLICY_COR_NOTHING                   0x00000000
#define URLPOLICY_COR_TIME                      0x00010000
#define URLPOLICY_COR_EQUIPMENT                 0x00020000
#define URLPOLICY_COR_EVERYTHING                0x00030000
#define URLPOLICY_COR_CUSTOM                    0x00800000


// Module Specific security settings
#define COR_MODULE_SECURITY_SKIP_VERIFY         0x00000001

#define KEY_COM_SECURITY_MODULE        FRAMEWORK_REGISTRY_KEY_W L"\\Security\\Policy\\ModuleAttribute"

#define KEY_COM_SECURITY_POLICY FRAMEWORK_REGISTRY_KEY_W L"\\Security\\Policy" 
#define HKEY_POLICY_ROOT        HKEY_LOCAL_MACHINE


//--------------------------------------------------------------------
// GetPublisher
// ------------
// Returns signature information (Encoded signature and permissions)
// NOTE: This does perform any policy checks on the certificates. All
// that can be determined is the File was signed and the bits are OK.
//
// Free information with CoTaskMemFree (just the pointer not the contents)
//

// For dwFlag values
#define COR_NOUI               0x01
#define COR_NOPOLICY           0x02
#define COR_DISPLAYGRANTED     0x04    // Intersect the requested permissions with the policy to 
                                       // to display the granted set


HRESULT STDMETHODCALLTYPE
GetPublisher(IN LPWSTR        pwsFileName,      // File name, this is required even with the handle
             IN HANDLE        hFile,            // Optional file name
             IN  DWORD        dwFlags,          // COR_NOUI or COR_NOPOLICY
             OUT PCOR_TRUST  *pInfo,            // Returns a PCOR_TRUST (Use CoTaskMemFree)
             OUT DWORD       *dwInfo);          // Size of pInfo.

HRESULT STDMETHODCALLTYPE
CheckManagedFileWithUser(IN LPWSTR pwsFileName,
                         IN LPWSTR pwsURL,
                         IN IInternetZoneManager*  pZoneManager,
                         IN LPCWSTR pZoneName,
                         IN DWORD  dwZoneIndex,
                         IN DWORD  dwSignedPolicy,
                         IN DWORD  dwUnsignedPolicy);


#define COR_UNSIGNED_NO  0x0
#define COR_UNSIGNED_YES 0x1
#define COR_UNSIGNED_ALWAYS 0x2

extern HRESULT DisplayUnsignedRequestDialog(HWND hParent,       // Parents hwnd
                                            PCRYPT_PROVIDER_DATA pData, 
                                            LPCWSTR pURL,       // Url associated with code
                                            LPCWSTR pZONE,      // Zone associated with code
                                            DWORD* pdwState);   // Return COR_UNSIGNED_YES or COR_UNSIGNED_NO
    
interface IMetaDataAssemblyImport;

// Structure used to describe an individual security permission.
typedef struct
{
    DWORD           dwIndex;                    // Unique permission index used for error tracking
    CHAR            szName[1024/*MAX_CLASSNAME_LENGTH*/+1];   // Fully qualified permission class name
    mdMemberRef     tkCtor;                     // Custom attribute constructor
    mdTypeRef       tkTypeRef;                  // Custom attribute class ref
    mdAssemblyRef   tkAssemblyRef;              // Custom attribute class assembly
    BYTE            *pbValues;                  // Serialized field/property initializers
    DWORD           cbValues;                   // Byte count for above
    WORD            wValues;                    // Count of values in above
} CORSEC_PERM;

// Context structure that tracks the creation of a security permission set from
// individual permission requests.
typedef struct
{
    mdToken         tkObj;                      // Parent object
    DWORD           dwAction;                   // Security action type (CorDeclSecurity)
    DWORD           dwPermissions;              // Number of permissions in set
    CORSEC_PERM     *pPermissions;              // Pointer to array of permissions
    DWORD           dwAllocated;                // Number of elements in above array
#ifdef __cplusplus
    IMetaDataAssemblyImport *pImport;           // Current meta data scope
    IUnknown        *pAppDomain;                // AppDomain in which managed security code will be run. 

#else
    void            *pImport;
    void            *pAppDomain;
#endif
} CORSEC_PSET;

// Reads permission requests (if any) from the manifest of an assembly.
HRESULT STDMETHODCALLTYPE
GetPermissionRequests(LPCWSTR   pwszFileName,
                      BYTE    **ppbMinimal,
                      DWORD    *pcbMinimal,
                      BYTE    **ppbOptional,
                      DWORD    *pcbOptional,
                      BYTE    **ppbRefused,
                      DWORD    *pcbRefused);

// Environment variable used to switch to translating security attributes via
// the bootstrap database (when building mscorlib itself). The value contains
// the directory the bootstrap database lives in.
#define SECURITY_BOOTSTRAP_DB L"__SECURITY_BOOTSTRAP_DB"

// Translate a set of security custom attributes into a serialized permission set blob.
HRESULT STDMETHODCALLTYPE
TranslateSecurityAttributes(CORSEC_PSET    *pPset,
                            BYTE          **ppbOutput,
                            DWORD          *pcbOutput,
                            BYTE          **ppbNonCasOutput,
                            DWORD          *pcbNonCasOutput,
                            DWORD          *pdwErrorIndex);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpolicy.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef _CORPOLICY_H
#define _CORPOLICY_H

#include "urlmon.h"

#ifdef __cplusplus
extern "C" {
#endif


// {D41E4F1D-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_PROVIDER_DOWNLOAD \
{ 0xd41e4f1d, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

// {D41E4F1E-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_PROVIDER_CHECK \
{ 0xd41e4f1e, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }


// {D41E4F1F-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_LOCKDOWN_CHECK \
{ 0xd41e4f1f, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

// {31D1ADC1-D329-11d1-8ED8-0080C76516C6}
#define COREE_POLICY_PROVIDER \
{ 0x31d1adc1, 0xd329, 0x11d1, {0x8e, 0xd8, 0x0, 0x80, 0xc7, 0x65, 0x16, 0xc6 } }

// This structure is returned from the winverify trust call, free up the structure
// using CoTaskMemAlloc except for COREE_POLICY_PROVIDER which uses LocalALLoc.

typedef struct _COR_TRUST {
    DWORD       cbSize;                   // Size of structure
    DWORD       flag;                     // Reserved
    BOOL        fAllActiveXPermissions;   // ActiveX explicitly asked for all (must have been signed)
    BOOL        fAllPermissions;          // Cor permissions, explicit ask for all
    DWORD       dwEncodingType;           // Encoding type
    PBYTE       pbCorPermissions;         // Encoded cor permission blob
    DWORD       cbCorPermissions;
    PBYTE       pbSigner;                 // Encoded signer.
    DWORD       cbSigner;
    LPCWSTR     pwszZone;                 // Zone index (copied from action data)
    GUID        guidZone;                 // Not used currently
    HRESULT     hVerify;                  // Authenticode policy return
} COR_TRUST, *PCOR_TRUST;

// Pass this structure into WinVerifyTrust (corpol trust provider). The result
// is returned in pbCorTrust.
typedef struct _COR_POLICY_PROVIDER {
    DWORD                 cbSize;                   // Size of policy provider
    LPVOID                pZoneManager;             // Zone interface manager
    LPCWSTR               pwszZone;                 // Zone index
    BOOL                  fNoBadUI;                 // Optional bad ui
    PCOR_TRUST            pbCorTrust;               // Returned cor information (CoTaskMemAlloc)
    DWORD                 cbCorTrust;               // Total allocated size of pCorTrust
    DWORD                 dwActionID;               // Optional ActionID ID
    DWORD                 dwUnsignedActionID;       // Optional ActionID ID
    BOOL                  VMBased;                  // Called from VM (FALSE by DEFAULT)
    DWORD                 dwZoneIndex;              // IE zone numbers
} COR_POLICY_PROVIDER, *PCOR_POLICY_PROVIDER;

//  Returned flags in COR_TRUST flag
#define COR_NOUI_DISPLAYED 0x1
#define COR_DELAYED_PERMISSIONS 0x02  // The subject was unsigned, returned
                                      // look up information in pbCorPermissions
                                      // to be passed into GetUnsignedPermissions().
                                      // If this flag is not set and pbCorPermissions
                                      // is not NULL then pbCorPermissions contains
                                      // encoded permissions


//--------------------------------------------------------------------
// For COR_POLICY_LOCKDOWN_CHECK:
// -----------------------------

// Structure to pass into WVT
typedef struct _COR_LOCKDOWN {
    DWORD                 cbSize;          // Size of policy provider
    DWORD                 flag;            // reserved
    BOOL                  fAllPublishers;  // Trust all publishers or just ones in the trusted data base
} COR_LOCKDOWN, *PCOR_LOCKDOWN;

#ifdef __cplusplus
}
#endif

#endif // _CORPOLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CORPRIV.H
// 
// ===========================================================================
#ifndef _CORPRIV_H_
#define _CORPRIV_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// %%Includes: ---------------------------------------------------------------
// avoid taking DLL import hit on intra-DLL calls
#define NODLLIMPORT
#include "Cor.h"
#include "MetaData.h"

class UTSemReadWrite;

// Helper function to get a pointer to the Dispenser interface.
STDAPI MetaDataGetDispenser(            // Return HRESULT
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv);                  // Return interface pointer here.


// Helper function to get an Internal interface with an in-memory metadata section
STDAPI  GetMetaDataInternalInterface(
    LPVOID      pData,                  // [IN] in memory metadata section
    ULONG       cbData,                 // [IN] size of the metadata section
    DWORD       flags,                  // [IN] CorOpenFlags
    REFIID      riid,                   // [IN] desired interface
    void        **ppv);                 // [OUT] returned interface

// Helper function to get an internal scopeless interface given a scope.
STDAPI  GetMetaDataInternalInterfaceFromPublic(
    void        *pv,                    // [IN] Given interface
    REFIID      riid,                   // [IN] desired interface
    void        **ppv);                 // [OUT] returned interface

// Helper function to get an internal scopeless interface given a scope.
STDAPI  GetMetaDataPublicInterfaceFromInternal(
    void        *pv,                    // [IN] Given interface
    REFIID      riid,                   // [IN] desired interface
    void        **ppv);                 // [OUT] returned interface

// Converts an internal MD import API into the read/write version of this API.
// This could support edit and continue, or modification of the metadata at
// runtime (say for profiling).
STDAPI ConvertMDInternalImport(         // S_OK or error.
    IMDInternalImport *pIMD,            // [IN] The metadata to be updated.
    IMDInternalImport **ppIMD);         // [OUT] Put RW interface here.

STDAPI GetAssemblyMDInternalImport(             // Return code.
    LPCWSTR     szFileName,             // [in] The scope to open.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk);              // [out] Return interface on success.

class CQuickBytes;


// predefined constant for parent token for global functions
#define     COR_GLOBAL_PARENT_TOKEN     TokenFromRid(1, mdtTypeDef)



//////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////

// %%Interfaces: -------------------------------------------------------------

// interface IMetaDataHelper

// {AD93D71D-E1F2-11d1-9409-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataHelper =
{ 0xad93d71d, 0xe1f2, 0x11d1, {0x94, 0x9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

// {AD93D71E-E1F2-11d1-9409-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataHelperOLD =
{ 0xad93d71e, 0xe1f2, 0x11d1, {0x94, 0x9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

#undef  INTERFACE
#define INTERFACE IMetaDataHelper
DECLARE_INTERFACE_(IMetaDataHelper, IUnknown)
{
    // helper functions 
    // This function is exposing the ability to translate signature from a given 
    // source scope to a given target scope.
    // This is not spec'ed. And may not be supported PostM3.
    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(ConvertTextSigToComSig)(      // Return hresult.
        IMetaDataEmit *emit,                // [IN] emit interface
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found
        LPCSTR      pSignature,             // [IN] class file format signature
        CQuickBytes *pqbNewSig,             // [OUT] place holder for CLR signature
        ULONG       *pcbCount) PURE;        // [OUT] the result size of signature

    STDMETHOD(ExportTypeLibFromModule)(     // Result.
        LPCWSTR     szModule,               // [IN] Module name.
        LPCWSTR     szTlb,                  // [IN] TypeLib name.
        BOOL        bRegister) PURE;        // [IN] Set to TRUE to have the typelib be registered.

    STDMETHOD(GetMetadata)(
        ULONG       ulSelect,               // [IN] Selector.
        void        **ppData) PURE;         // [OUT] Put pointer to data here.

    STDMETHOD_(IUnknown *, GetCachedInternalInterface)(BOOL fWithLock) PURE;    // S_OK or error
    STDMETHOD(SetCachedInternalInterface)(IUnknown * pUnk) PURE;    // S_OK or error
    STDMETHOD_(UTSemReadWrite*, GetReaderWriterLock)() PURE;   // return the reader writer lock
    STDMETHOD(SetReaderWriterLock)(UTSemReadWrite * pSem) PURE; 
};



// {5C240AE4-1E09-11d3-9424-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmitHelper =
{ 0x5c240ae4, 0x1e09, 0x11d3, {0x94, 0x24, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

#undef  INTERFACE
#define INTERFACE IMetaDataEmitHelper
DECLARE_INTERFACE_(IMetaDataEmitHelper, IUnknown)
{
    // emit helper functions 
    STDMETHOD(DefineMethodSemanticsHelper)(
        mdToken     tkAssociation,          // [IN] property or event token
        DWORD       dwFlags,                // [IN] semantics
        mdMethodDef md) PURE;               // [IN] method to associated with

    STDMETHOD(SetFieldLayoutHelper)(                // Return hresult.
        mdFieldDef  fd,                     // [IN] field to associate the layout info
        ULONG       ulOffset) PURE;         // [IN] the offset for the field

    STDMETHOD(DefineEventHelper) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(AddDeclarativeSecurityHelper) (
        mdToken     tk,                     // [IN] Parent token (typedef/methoddef)
        DWORD       dwAction,               // [IN] Security action (CorDeclSecurity)
        void const  *pValue,                // [IN] Permission set blob
        DWORD       cbValue,                // [IN] Byte count of permission set blob
        mdPermission*pmdPermission) PURE;   // [OUT] Output permission token

    STDMETHOD(SetResolutionScopeHelper)(    // Return hresult.
        mdTypeRef   tr,                     // [IN] TypeRef record to update
        mdToken     rs) PURE;               // [IN] new ResolutionScope 

    STDMETHOD(SetManifestResourceOffsetHelper)(  // Return hresult.
        mdManifestResource mr,              // [IN] The manifest token
        ULONG       ulOffset) PURE;         // [IN] new offset 

    STDMETHOD(SetTypeParent)(               // Return hresult.
        mdTypeDef   td,                     // [IN] Type definition
        mdToken     tkExtends) PURE;        // [IN] parent type

    STDMETHOD(AddInterfaceImpl)(            // Return hresult.
        mdTypeDef   td,                     // [IN] Type definition
        mdToken     tkInterface) PURE;      // [IN] interface type

};

//////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////
typedef enum CorElementTypeInternal
{
    ELEMENT_TYPE_VAR_INTERNAL            = 0x13,     // a type variable VAR <U1> 

    ELEMENT_TYPE_VALUEARRAY_INTERNAL     = 0x17,     // VALUEARRAY <type> <bound>    
    
    ELEMENT_TYPE_R_INTERNAL              = 0x1A,     // native real size 
    
} CorElementTypeInternal;

#define ELEMENT_TYPE_VAR           ((CorElementType) ELEMENT_TYPE_VAR_INTERNAL          )
#define ELEMENT_TYPE_VALUEARRAY    ((CorElementType) ELEMENT_TYPE_VALUEARRAY_INTERNAL   )
#define ELEMENT_TYPE_R             ((CorElementType) ELEMENT_TYPE_R_INTERNAL            )

typedef enum CorBaseTypeInternal    // TokenFromRid(X,Y) replaced with (X | Y)
{
    mdtBaseType_R              = ( ELEMENT_TYPE_R       | mdtBaseType ),    
} CorBaseTypeInternal;


// %%Classes: ----------------------------------------------------------------
#ifndef offsetof
#define offsetof(s,f)   ((ULONG)(&((s*)0)->f))
#endif
#ifndef lengthof
#define lengthof(rg)    (sizeof(rg)/sizeof(rg[0]))
#endif

#define COR_MODULE_CLASS    "<Module>"
#define COR_WMODULE_CLASS   L"<Module>"

// PE images loaded through the runtime. 
typedef struct _dummyCOR { BYTE b; } *HCORMODULE;

enum CorLoadFlags
{
    CorLoadMask = 0xf,
    CorLoadUndefinedMap = 0x0,
    CorLoadDataMap = 0x1,           // MapViewOfFile, copied into memory, RW access
    CorLoadImageMap = 0x2,          // The runtime has laid out the sections
    CorLoadOSMap = 0x3,             // MapViewOfFile, preferred base address, RO access
    CorLoadOSImage = 0x4,           // Normally loaded by the OS (LoadLibrary)
    CorReLoadOSMap = 0x5,           // Link of one handle to another. (Cast hOSHandle to CORHANDLE)
    CorReLocsApplied = 0x10,        // CorLoadImageMap + relocs guaranteed
    CorKeepInTable = 0x20
};

STDAPI RuntimeOpenImage(LPCWSTR pszFileName, HCORMODULE* hHandle);
STDAPI RuntimeOpenImageInternal(LPCWSTR pszFileName, HCORMODULE* hHandle, DWORD *pdwLength);
STDAPI RuntimeReleaseHandle(HCORMODULE hHandle);
CorLoadFlags STDMETHODCALLTYPE RuntimeImageType(HCORMODULE hHandle);
STDAPI RuntimeOSHandle(HCORMODULE hHandle, HMODULE* hModule);
STDAPI RuntimeReadHeaders(PBYTE hAddress, IMAGE_DOS_HEADER** ppDos,
                          IMAGE_NT_HEADERS** ppNT, IMAGE_COR20_HEADER** ppCor,
                          BOOL fDataMap, DWORD dwLength);
EXTERN_C PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(PIMAGE_NT_HEADERS NtHeaders,
                                                        ULONG Rva,
                                                        ULONG FileLength = 0);
EXTERN_C PIMAGE_SECTION_HEADER Cor_RtlImageRvaRangeToSection(PIMAGE_NT_HEADERS NtHeaders,
                                                             ULONG Rva, ULONG Range,
                                                             ULONG FileLength = 0);
EXTERN_C DWORD Cor_RtlImageRvaToOffset(PIMAGE_NT_HEADERS NtHeaders,
                                       ULONG Rva,
                                       ULONG FileLength = 0);
EXTERN_C PBYTE Cor_RtlImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders,
                                   PBYTE Base,
                                   ULONG Rva,
                                   ULONG FileLength);

STDAPI RuntimeGetAssemblyStrongNameHash(PBYTE pbBase,
                                        LPWSTR szwFileName,
                                        BOOL fFileMap,
                                        BYTE *pbHash,
                                        DWORD *pcbHash);

STDAPI RuntimeGetAssemblyStrongNameHashForModule(HCORMODULE   hModule,
                                                 BYTE        *pbSNHash,
                                                 DWORD       *pcbSNHash);

#endif  // _CORPRIV_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corprof.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:10 2003
 */
/* Compiler settings for corprof.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corprof_h__
#define __corprof_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorProfilerCallback_FWD_DEFINED__
#define __ICorProfilerCallback_FWD_DEFINED__
typedef interface ICorProfilerCallback ICorProfilerCallback;
#endif 	/* __ICorProfilerCallback_FWD_DEFINED__ */


#ifndef __ICorProfilerInfo_FWD_DEFINED__
#define __ICorProfilerInfo_FWD_DEFINED__
typedef interface ICorProfilerInfo ICorProfilerInfo;
#endif 	/* __ICorProfilerInfo_FWD_DEFINED__ */


#ifndef __IMethodMalloc_FWD_DEFINED__
#define __IMethodMalloc_FWD_DEFINED__
typedef interface IMethodMalloc IMethodMalloc;
#endif 	/* __IMethodMalloc_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corprof_0000 */
/* [local] */ 

#define PROFILER_REGKEY_ROOT            L"software\\microsoft\\.NETFramework\\Profilers"
#define PROFILER_REGVALUE_HELPSTRING    L"HelpString"
#define PROFILER_REGVALUE_PROFID        L"ProfilerID"
#define CorDB_CONTROL_Profiling         "Cor_Enable_Profiling"
#define CorDB_CONTROL_ProfilingL       L"Cor_Enable_Profiling"
#if 0
typedef LONG32 mdToken;

typedef mdToken mdModule;

typedef mdToken mdTypeDef;

typedef mdToken mdMethodDef;

typedef ULONG CorElementType;


#endif
#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef const BYTE *LPCBYTE;

typedef BYTE *LPBYTE;

typedef UINT_PTR ProcessID;

typedef UINT_PTR AssemblyID;

typedef UINT_PTR AppDomainID;

typedef UINT_PTR ModuleID;

typedef UINT_PTR ClassID;

typedef UINT_PTR ThreadID;

typedef UINT_PTR ContextID;

typedef UINT_PTR FunctionID;

typedef UINT_PTR ObjectID;

typedef UINT_PTR __stdcall __stdcall FunctionIDMapper( 
    FunctionID funcId,
    BOOL *pbHookFunction);

typedef void FunctionEnter( 
    FunctionID funcID);

typedef void FunctionLeave( 
    FunctionID funcID);

typedef void FunctionTailcall( 
    FunctionID funcID);

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0001
    {	COR_PRF_MONITOR_NONE	= 0,
	COR_PRF_MONITOR_FUNCTION_UNLOADS	= 0x1,
	COR_PRF_MONITOR_CLASS_LOADS	= 0x2,
	COR_PRF_MONITOR_MODULE_LOADS	= 0x4,
	COR_PRF_MONITOR_ASSEMBLY_LOADS	= 0x8,
	COR_PRF_MONITOR_APPDOMAIN_LOADS	= 0x10,
	COR_PRF_MONITOR_JIT_COMPILATION	= 0x20,
	COR_PRF_MONITOR_EXCEPTIONS	= 0x40,
	COR_PRF_MONITOR_GC	= 0x80,
	COR_PRF_MONITOR_OBJECT_ALLOCATED	= 0x100,
	COR_PRF_MONITOR_THREADS	= 0x200,
	COR_PRF_MONITOR_REMOTING	= 0x400,
	COR_PRF_MONITOR_CODE_TRANSITIONS	= 0x800,
	COR_PRF_MONITOR_ENTERLEAVE	= 0x1000,
	COR_PRF_MONITOR_CCW	= 0x2000,
	COR_PRF_MONITOR_REMOTING_COOKIE	= 0x4000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_REMOTING_ASYNC	= 0x8000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_SUSPENDS	= 0x10000,
	COR_PRF_MONITOR_CACHE_SEARCHES	= 0x20000,
	COR_PRF_MONITOR_CLR_EXCEPTIONS	= 0x1000000,
	COR_PRF_MONITOR_ALL	= 0x107ffff,
	COR_PRF_ENABLE_REJIT	= 0x40000,
	COR_PRF_ENABLE_INPROC_DEBUGGING	= 0x80000,
	COR_PRF_ENABLE_JIT_MAPS	= 0x100000,
	COR_PRF_DISABLE_INLINING	= 0x200000,
	COR_PRF_DISABLE_OPTIMIZATIONS	= 0x400000,
	COR_PRF_ENABLE_OBJECT_ALLOCATED	= 0x800000,
	COR_PRF_ALL	= 0x1ffffff,
	COR_PRF_MONITOR_IMMUTABLE	= COR_PRF_MONITOR_CODE_TRANSITIONS | COR_PRF_MONITOR_REMOTING | COR_PRF_MONITOR_REMOTING_COOKIE | COR_PRF_MONITOR_REMOTING_ASYNC | COR_PRF_MONITOR_GC | COR_PRF_ENABLE_REJIT | COR_PRF_ENABLE_INPROC_DEBUGGING | COR_PRF_ENABLE_JIT_MAPS | COR_PRF_DISABLE_OPTIMIZATIONS | COR_PRF_DISABLE_INLINING | COR_PRF_ENABLE_OBJECT_ALLOCATED
    } 	COR_PRF_MONITOR;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0002
    {	PROFILER_PARENT_UNKNOWN	= 0xfffffffd,
	PROFILER_GLOBAL_CLASS	= 0xfffffffe,
	PROFILER_GLOBAL_MODULE	= 0xffffffff
    } 	COR_PRF_MISC;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0003
    {	COR_PRF_CACHED_FUNCTION_FOUND	= 0,
	COR_PRF_CACHED_FUNCTION_NOT_FOUND	= COR_PRF_CACHED_FUNCTION_FOUND + 1
    } 	COR_PRF_JIT_CACHE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0004
    {	COR_PRF_TRANSITION_CALL	= 0,
	COR_PRF_TRANSITION_RETURN	= COR_PRF_TRANSITION_CALL + 1
    } 	COR_PRF_TRANSITION_REASON;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0005
    {	COR_PRF_SUSPEND_OTHER	= 0,
	COR_PRF_SUSPEND_FOR_GC	= 1,
	COR_PRF_SUSPEND_FOR_APPDOMAIN_SHUTDOWN	= 2,
	COR_PRF_SUSPEND_FOR_CODE_PITCHING	= 3,
	COR_PRF_SUSPEND_FOR_SHUTDOWN	= 4,
	COR_PRF_SUSPEND_FOR_INPROC_DEBUGGER	= 6,
	COR_PRF_SUSPEND_FOR_GC_PREP	= 7
    } 	COR_PRF_SUSPEND_REASON;






extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_s_ifspec;

#ifndef __ICorProfilerCallback_INTERFACE_DEFINED__
#define __ICorProfilerCallback_INTERFACE_DEFINED__

/* interface ICorProfilerCallback */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("176FBED1-A55C-4796-98CA-A9DA0EF883E7")
    ICorProfilerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pICorProfilerInfoUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleAttachedToAssembly( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FunctionUnloadStarted( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationStarted( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchStarted( 
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITFunctionPitched( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITInlining( 
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadCreated( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadDestroyed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadAssignedToOSThread( 
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientSendingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientReceivingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerReceivingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationReturned( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerSendingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmanagedToManagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ManagedToUnmanagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendStarted( 
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendAborted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadSuspended( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadResumed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MovedReferences( 
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectAllocated( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectsAllocatedByClass( 
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectReferences( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootReferences( 
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionThrown( 
            /* [in] */ ObjectID thrownObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchCatcherFound( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerEnter( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerLeave( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherEnter( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableCreated( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableDestroyed( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherFound( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherExecute( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorProfilerCallback * This,
            /* [in] */ IUnknown *pICorProfilerInfoUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleAttachedToAssembly )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result);
        
        HRESULT ( STDMETHODCALLTYPE *JITFunctionPitched )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITInlining )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadAssignedToOSThread )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientSendingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientReceivingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerReceivingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationReturned )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerSendingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *UnmanagedToManagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *ManagedToUnmanagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendAborted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadSuspended )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadResumed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *MovedReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectAllocated )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectsAllocatedByClass )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionThrown )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID thrownObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchCatcherFound )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerLeave )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherFound )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherExecute )( 
            ICorProfilerCallback * This);
        
        END_INTERFACE
    } ICorProfilerCallbackVtbl;

    interface ICorProfilerCallback
    {
        CONST_VTBL struct ICorProfilerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerCallback_Initialize(This,pICorProfilerInfoUnk)	\
    (This)->lpVtbl -> Initialize(This,pICorProfilerInfoUnk)

#define ICorProfilerCallback_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ICorProfilerCallback_AppDomainCreationStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainCreationStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainCreationFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainCreationFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AppDomainShutdownStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainShutdownStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainShutdownFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainShutdownFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AssemblyLoadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyLoadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyLoadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyLoadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_AssemblyUnloadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyUnloadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyUnloadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyUnloadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_ModuleLoadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleLoadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleLoadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleLoadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleUnloadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleUnloadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleUnloadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleUnloadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleAttachedToAssembly(This,moduleId,AssemblyId)	\
    (This)->lpVtbl -> ModuleAttachedToAssembly(This,moduleId,AssemblyId)

#define ICorProfilerCallback_ClassLoadStarted(This,classId)	\
    (This)->lpVtbl -> ClassLoadStarted(This,classId)

#define ICorProfilerCallback_ClassLoadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassLoadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_ClassUnloadStarted(This,classId)	\
    (This)->lpVtbl -> ClassUnloadStarted(This,classId)

#define ICorProfilerCallback_ClassUnloadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassUnloadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_FunctionUnloadStarted(This,functionId)	\
    (This)->lpVtbl -> FunctionUnloadStarted(This,functionId)

#define ICorProfilerCallback_JITCompilationStarted(This,functionId,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationStarted(This,functionId,fIsSafeToBlock)

#define ICorProfilerCallback_JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)

#define ICorProfilerCallback_JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)	\
    (This)->lpVtbl -> JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)

#define ICorProfilerCallback_JITCachedFunctionSearchFinished(This,functionId,result)	\
    (This)->lpVtbl -> JITCachedFunctionSearchFinished(This,functionId,result)

#define ICorProfilerCallback_JITFunctionPitched(This,functionId)	\
    (This)->lpVtbl -> JITFunctionPitched(This,functionId)

#define ICorProfilerCallback_JITInlining(This,callerId,calleeId,pfShouldInline)	\
    (This)->lpVtbl -> JITInlining(This,callerId,calleeId,pfShouldInline)

#define ICorProfilerCallback_ThreadCreated(This,threadId)	\
    (This)->lpVtbl -> ThreadCreated(This,threadId)

#define ICorProfilerCallback_ThreadDestroyed(This,threadId)	\
    (This)->lpVtbl -> ThreadDestroyed(This,threadId)

#define ICorProfilerCallback_ThreadAssignedToOSThread(This,managedThreadId,osThreadId)	\
    (This)->lpVtbl -> ThreadAssignedToOSThread(This,managedThreadId,osThreadId)

#define ICorProfilerCallback_RemotingClientInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingClientInvocationStarted(This)

#define ICorProfilerCallback_RemotingClientSendingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientSendingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientReceivingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientReceivingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientInvocationFinished(This)	\
    (This)->lpVtbl -> RemotingClientInvocationFinished(This)

#define ICorProfilerCallback_RemotingServerReceivingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerReceivingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingServerInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingServerInvocationStarted(This)

#define ICorProfilerCallback_RemotingServerInvocationReturned(This)	\
    (This)->lpVtbl -> RemotingServerInvocationReturned(This)

#define ICorProfilerCallback_RemotingServerSendingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerSendingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_UnmanagedToManagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> UnmanagedToManagedTransition(This,functionId,reason)

#define ICorProfilerCallback_ManagedToUnmanagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> ManagedToUnmanagedTransition(This,functionId,reason)

#define ICorProfilerCallback_RuntimeSuspendStarted(This,suspendReason)	\
    (This)->lpVtbl -> RuntimeSuspendStarted(This,suspendReason)

#define ICorProfilerCallback_RuntimeSuspendFinished(This)	\
    (This)->lpVtbl -> RuntimeSuspendFinished(This)

#define ICorProfilerCallback_RuntimeSuspendAborted(This)	\
    (This)->lpVtbl -> RuntimeSuspendAborted(This)

#define ICorProfilerCallback_RuntimeResumeStarted(This)	\
    (This)->lpVtbl -> RuntimeResumeStarted(This)

#define ICorProfilerCallback_RuntimeResumeFinished(This)	\
    (This)->lpVtbl -> RuntimeResumeFinished(This)

#define ICorProfilerCallback_RuntimeThreadSuspended(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadSuspended(This,threadId)

#define ICorProfilerCallback_RuntimeThreadResumed(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadResumed(This,threadId)

#define ICorProfilerCallback_MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback_ObjectAllocated(This,objectId,classId)	\
    (This)->lpVtbl -> ObjectAllocated(This,objectId,classId)

#define ICorProfilerCallback_ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)	\
    (This)->lpVtbl -> ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)

#define ICorProfilerCallback_ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)	\
    (This)->lpVtbl -> ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)

#define ICorProfilerCallback_RootReferences(This,cRootRefs,rootRefIds)	\
    (This)->lpVtbl -> RootReferences(This,cRootRefs,rootRefIds)

#define ICorProfilerCallback_ExceptionThrown(This,thrownObjectId)	\
    (This)->lpVtbl -> ExceptionThrown(This,thrownObjectId)

#define ICorProfilerCallback_ExceptionSearchFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFunctionLeave(This)

#define ICorProfilerCallback_ExceptionSearchFilterEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFilterEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFilterLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFilterLeave(This)

#define ICorProfilerCallback_ExceptionSearchCatcherFound(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchCatcherFound(This,functionId)

#define ICorProfilerCallback_ExceptionOSHandlerEnter(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerEnter(This,__unused)

#define ICorProfilerCallback_ExceptionOSHandlerLeave(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerLeave(This,__unused)

#define ICorProfilerCallback_ExceptionUnwindFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionLeave(This)

#define ICorProfilerCallback_ExceptionUnwindFinallyEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFinallyLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyLeave(This)

#define ICorProfilerCallback_ExceptionCatcherEnter(This,functionId,objectId)	\
    (This)->lpVtbl -> ExceptionCatcherEnter(This,functionId,objectId)

#define ICorProfilerCallback_ExceptionCatcherLeave(This)	\
    (This)->lpVtbl -> ExceptionCatcherLeave(This)

#define ICorProfilerCallback_COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)	\
    (This)->lpVtbl -> COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)

#define ICorProfilerCallback_COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)	\
    (This)->lpVtbl -> COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)

#define ICorProfilerCallback_ExceptionCLRCatcherFound(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherFound(This)

#define ICorProfilerCallback_ExceptionCLRCatcherExecute(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherExecute(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Initialize_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ IUnknown *pICorProfilerInfoUnk);


void __RPC_STUB ICorProfilerCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Shutdown_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleAttachedToAssembly_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ AssemblyID AssemblyId);


void __RPC_STUB ICorProfilerCallback_ModuleAttachedToAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_FunctionUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_FunctionUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ BOOL *pbUseCachedFunction);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_JIT_CACHE result);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITFunctionPitched_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_JITFunctionPitched_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITInlining_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID callerId,
    /* [in] */ FunctionID calleeId,
    /* [out] */ BOOL *pfShouldInline);


void __RPC_STUB ICorProfilerCallback_JITInlining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadAssignedToOSThread_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID managedThreadId,
    /* [in] */ DWORD osThreadId);


void __RPC_STUB ICorProfilerCallback_ThreadAssignedToOSThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientSendingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientSendingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientReceivingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientReceivingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerReceivingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerReceivingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationReturned_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationReturned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerSendingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerSendingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_UnmanagedToManagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_UnmanagedToManagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ManagedToUnmanagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_ManagedToUnmanagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendAborted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendAborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadSuspended_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadResumed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadResumed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_MovedReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cMovedObjectIDRanges,
    /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
    /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
    /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);


void __RPC_STUB ICorProfilerCallback_MovedReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectAllocated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ObjectAllocated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectsAllocatedByClass_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cClassCount,
    /* [size_is][in] */ ClassID classIds[  ],
    /* [size_is][in] */ ULONG cObjects[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectsAllocatedByClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId,
    /* [in] */ ULONG cObjectRefs,
    /* [size_is][in] */ ObjectID objectRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RootReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cRootRefs,
    /* [size_is][in] */ ObjectID rootRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_RootReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionThrown_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID thrownObjectId);


void __RPC_STUB ICorProfilerCallback_ExceptionThrown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchCatcherFound_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerLeave_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ObjectID objectId);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ULONG cSlots);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherFound_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherExecute_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerCallback_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerInfo_INTERFACE_DEFINED__
#define __ICorProfilerInfo_INTERFACE_DEFINED__

/* interface ICorProfilerInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28B5557D-3F3F-48b4-90B2-5F9EEA2F6C48")
    ICorProfilerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassFromObject( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventMask( 
            /* [out] */ DWORD *pdwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromIP( 
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandleFromThread( 
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsArrayClass( 
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadInfo( 
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ThreadID *pThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassIDInfo( 
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventMask( 
            /* [in] */ DWORD dwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnterLeaveFunctionHooks( 
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionIDMapper( 
            /* [in] */ FunctionIDMapper *pFunc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTokenAndMetaDataFromFunction( 
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleInfo( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleMetaData( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBodyAllocator( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainInfo( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyInfo( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionReJIT( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceGC( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILInstrumentedCodeMap( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionInterface( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionIThisThread( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginInprocDebugging( 
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndInprocDebugging( 
            /* [in] */ DWORD dwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromObject )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventMask )( 
            ICorProfilerInfo * This,
            /* [out] */ DWORD *pdwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromIP )( 
            ICorProfilerInfo * This,
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleFromThread )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsArrayClass )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICorProfilerInfo * This,
            /* [out] */ ThreadID *pThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassIDInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventMask )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnterLeaveFunctionHooks )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionIDMapper )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionIDMapper *pFunc);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenAndMetaDataFromFunction )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleMetaData )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBodyAllocator )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc);
        
        HRESULT ( STDMETHODCALLTYPE *SetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionReJIT )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ForceGC )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetILInstrumentedCodeMap )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionInterface )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionIThisThread )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *EndInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        END_INTERFACE
    } ICorProfilerInfoVtbl;

    interface ICorProfilerInfo
    {
        CONST_VTBL struct ICorProfilerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerInfo_GetClassFromObject(This,objectId,pClassId)	\
    (This)->lpVtbl -> GetClassFromObject(This,objectId,pClassId)

#define ICorProfilerInfo_GetClassFromToken(This,moduleId,typeDef,pClassId)	\
    (This)->lpVtbl -> GetClassFromToken(This,moduleId,typeDef,pClassId)

#define ICorProfilerInfo_GetCodeInfo(This,functionId,pStart,pcSize)	\
    (This)->lpVtbl -> GetCodeInfo(This,functionId,pStart,pcSize)

#define ICorProfilerInfo_GetEventMask(This,pdwEvents)	\
    (This)->lpVtbl -> GetEventMask(This,pdwEvents)

#define ICorProfilerInfo_GetFunctionFromIP(This,ip,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromIP(This,ip,pFunctionId)

#define ICorProfilerInfo_GetFunctionFromToken(This,moduleId,token,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,moduleId,token,pFunctionId)

#define ICorProfilerInfo_GetHandleFromThread(This,threadId,phThread)	\
    (This)->lpVtbl -> GetHandleFromThread(This,threadId,phThread)

#define ICorProfilerInfo_GetObjectSize(This,objectId,pcSize)	\
    (This)->lpVtbl -> GetObjectSize(This,objectId,pcSize)

#define ICorProfilerInfo_IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)	\
    (This)->lpVtbl -> IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)

#define ICorProfilerInfo_GetThreadInfo(This,threadId,pdwWin32ThreadId)	\
    (This)->lpVtbl -> GetThreadInfo(This,threadId,pdwWin32ThreadId)

#define ICorProfilerInfo_GetCurrentThreadID(This,pThreadId)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,pThreadId)

#define ICorProfilerInfo_GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)	\
    (This)->lpVtbl -> GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)

#define ICorProfilerInfo_GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)	\
    (This)->lpVtbl -> GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)

#define ICorProfilerInfo_SetEventMask(This,dwEvents)	\
    (This)->lpVtbl -> SetEventMask(This,dwEvents)

#define ICorProfilerInfo_SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)	\
    (This)->lpVtbl -> SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)

#define ICorProfilerInfo_SetFunctionIDMapper(This,pFunc)	\
    (This)->lpVtbl -> SetFunctionIDMapper(This,pFunc)

#define ICorProfilerInfo_GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)	\
    (This)->lpVtbl -> GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)

#define ICorProfilerInfo_GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)	\
    (This)->lpVtbl -> GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)

#define ICorProfilerInfo_GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)	\
    (This)->lpVtbl -> GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)

#define ICorProfilerInfo_GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)	\
    (This)->lpVtbl -> GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)

#define ICorProfilerInfo_GetILFunctionBodyAllocator(This,moduleId,ppMalloc)	\
    (This)->lpVtbl -> GetILFunctionBodyAllocator(This,moduleId,ppMalloc)

#define ICorProfilerInfo_SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)	\
    (This)->lpVtbl -> SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)

#define ICorProfilerInfo_GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)	\
    (This)->lpVtbl -> GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)

#define ICorProfilerInfo_GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)	\
    (This)->lpVtbl -> GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)

#define ICorProfilerInfo_SetFunctionReJIT(This,functionId)	\
    (This)->lpVtbl -> SetFunctionReJIT(This,functionId)

#define ICorProfilerInfo_ForceGC(This)	\
    (This)->lpVtbl -> ForceGC(This)

#define ICorProfilerInfo_SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)	\
    (This)->lpVtbl -> SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)

#define ICorProfilerInfo_GetInprocInspectionInterface(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionInterface(This,ppicd)

#define ICorProfilerInfo_GetInprocInspectionIThisThread(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionIThisThread(This,ppicd)

#define ICorProfilerInfo_GetThreadContext(This,threadId,pContextId)	\
    (This)->lpVtbl -> GetThreadContext(This,threadId,pContextId)

#define ICorProfilerInfo_BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)	\
    (This)->lpVtbl -> BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)

#define ICorProfilerInfo_EndInprocDebugging(This,dwProfilerContext)	\
    (This)->lpVtbl -> EndInprocDebugging(This,dwProfilerContext)

#define ICorProfilerInfo_GetILToNativeMapping(This,functionId,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,functionId,cMap,pcMap,map)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromObject_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCodeInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ LPCBYTE *pStart,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetCodeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ DWORD *pdwEvents);


void __RPC_STUB ICorProfilerInfo_GetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromIP_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ LPCBYTE ip,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdToken token,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetHandleFromThread_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ HANDLE *phThread);


void __RPC_STUB ICorProfilerInfo_GetHandleFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetObjectSize_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_IsArrayClass_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ CorElementType *pBaseElemType,
    /* [out] */ ClassID *pBaseClassId,
    /* [out] */ ULONG *pcRank);


void __RPC_STUB ICorProfilerInfo_IsArrayClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ DWORD *pdwWin32ThreadId);


void __RPC_STUB ICorProfilerInfo_GetThreadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCurrentThreadID_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ ThreadID *pThreadId);


void __RPC_STUB ICorProfilerInfo_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassIDInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdTypeDef *pTypeDefToken);


void __RPC_STUB ICorProfilerInfo_GetClassIDInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ ClassID *pClassId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetFunctionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwEvents);


void __RPC_STUB ICorProfilerInfo_SetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEnterLeaveFunctionHooks_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionEnter *pFuncEnter,
    /* [in] */ FunctionLeave *pFuncLeave,
    /* [in] */ FunctionTailcall *pFuncTailcall);


void __RPC_STUB ICorProfilerInfo_SetEnterLeaveFunctionHooks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionIDMapper_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionIDMapper *pFunc);


void __RPC_STUB ICorProfilerInfo_SetFunctionIDMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppImport,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ LPCBYTE *ppBaseLoadAddress,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AssemblyID *pAssemblyId);


void __RPC_STUB ICorProfilerInfo_GetModuleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleMetaData_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ DWORD dwOpenFlags,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppOut);


void __RPC_STUB ICorProfilerInfo_GetModuleMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodId,
    /* [out] */ LPCBYTE *ppMethodHeader,
    /* [out] */ ULONG *pcbMethodSize);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBodyAllocator_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ IMethodMalloc **ppMalloc);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBodyAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodid,
    /* [in] */ LPCBYTE pbNewILMethodHeader);


void __RPC_STUB ICorProfilerInfo_SetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAppDomainInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ ProcessID *pProcessId);


void __RPC_STUB ICorProfilerInfo_GetAppDomainInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAssemblyInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AppDomainID *pAppDomainId,
    /* [out] */ ModuleID *pModuleId);


void __RPC_STUB ICorProfilerInfo_GetAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionReJIT_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerInfo_SetFunctionReJIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_ForceGC_Proxy( 
    ICorProfilerInfo * This);


void __RPC_STUB ICorProfilerInfo_ForceGC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILInstrumentedCodeMap_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fStartJit,
    /* [in] */ ULONG cILMapEntries,
    /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);


void __RPC_STUB ICorProfilerInfo_SetILInstrumentedCodeMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionInterface_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionIThisThread_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionIThisThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadContext_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ ContextID *pContextId);


void __RPC_STUB ICorProfilerInfo_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_BeginInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ BOOL fThisThreadOnly,
    /* [out] */ DWORD *pdwProfilerContext);


void __RPC_STUB ICorProfilerInfo_BeginInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_EndInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwProfilerContext);


void __RPC_STUB ICorProfilerInfo_EndInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILToNativeMapping_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorProfilerInfo_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerInfo_INTERFACE_DEFINED__ */


#ifndef __IMethodMalloc_INTERFACE_DEFINED__
#define __IMethodMalloc_INTERFACE_DEFINED__

/* interface IMethodMalloc */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IMethodMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0EFB28B-6EE2-4d7b-B983-A75EF7BEEDB8")
    IMethodMalloc : public IUnknown
    {
    public:
        virtual void *STDMETHODCALLTYPE Alloc( 
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMethodMallocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMethodMalloc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMethodMalloc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMethodMalloc * This);
        
        void *( STDMETHODCALLTYPE *Alloc )( 
            IMethodMalloc * This,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IMethodMallocVtbl;

    interface IMethodMalloc
    {
        CONST_VTBL struct IMethodMallocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMethodMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMethodMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMethodMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMethodMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void *STDMETHODCALLTYPE IMethodMalloc_Alloc_Proxy( 
    IMethodMalloc * This,
    /* [in] */ ULONG cb);


void __RPC_STUB IMethodMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMethodMalloc_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpub_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_CorpubProcessLib,0xe97ca460,0x657d,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(CLSID, CLSID_CorpubPublish,0x047a9a40,0x657e,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);


MIDL_DEFINE_GUID(IID, IID_ICorPublish,0x9613A0E7,0x5A68,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorPublishEnum,0xC0B22967,0x5A69,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorPublishProcess,0x18D87AF1,0x5A6A,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorPublishAppDomain,0xD6315C8F,0x5A6A,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorPublishProcessEnum,0xA37FBD41,0x5A69,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);


MIDL_DEFINE_GUID(IID, IID_ICorPublishAppDomainEnum,0x9F0C98F5,0x5A6A,0x11d3,0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corprof_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:10 2003
 */
/* Compiler settings for corprof.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICorProfilerCallback,0x176FBED1,0xA55C,0x4796,0x98,0xCA,0xA9,0xDA,0x0E,0xF8,0x83,0xE7);


MIDL_DEFINE_GUID(IID, IID_ICorProfilerInfo,0x28B5557D,0x3F3F,0x48b4,0x90,0xB2,0x5F,0x9E,0xEA,0x2F,0x6C,0x48);


MIDL_DEFINE_GUID(IID, IID_IMethodMalloc,0xA0EFB28B,0x6EE2,0x4d7b,0xB9,0x83,0xA7,0x5E,0xF7,0xBE,0xED,0xB8);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\correg.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CorReg.H
//
// ===========================================================================
// This file is obsolete.
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma message("#include of obsolete file CorReg.h")
#error include of obsolete file CorReg.h

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpub_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "corpub.h"

#define TYPE_FORMAT_STRING_SIZE   195                               
#define PROC_FORMAT_STRING_SIZE   379                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorPublishEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorPublishEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorPublishProcess_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorPublishProcess_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorPublishAppDomain_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorPublishAppDomain_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorPublishProcessEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorPublishProcessEnum_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorPublishAppDomainEnum_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorPublishAppDomainEnum_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Skip */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter celt */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x5 ),	/* 5 */
/* 58 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 66 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 70 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 72 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */

/* 78 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 80 */	NdrFcLong( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x6 ),	/* 6 */
/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 88 */	NdrFcShort( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x24 ),	/* 36 */
/* 92 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcelt */

/* 94 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 96 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 102 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsManaged */

/* 106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x3 ),	/* 3 */
/* 114 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x24 ),	/* 36 */
/* 120 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pbManaged */

/* 122 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 124 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 130 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumAppDomains */

/* 134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x4 ),	/* 4 */
/* 142 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x8 ),	/* 8 */
/* 148 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 150 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 154 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcessID */

/* 162 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x5 ),	/* 5 */
/* 170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x24 ),	/* 36 */
/* 176 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pid */

/* 178 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 180 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 182 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 184 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 186 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 188 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDisplayName */

/* 190 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x6 ),	/* 6 */
/* 198 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 202 */	NdrFcShort( 0x24 ),	/* 36 */
/* 204 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 206 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 208 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 212 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 214 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 218 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 220 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 222 */	NdrFcShort( 0x42 ),	/* Type Offset=66 */

	/* Return value */

/* 224 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 226 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetID */

/* 230 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 232 */	NdrFcLong( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x3 ),	/* 3 */
/* 238 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 242 */	NdrFcShort( 0x24 ),	/* 36 */
/* 244 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter puId */

/* 246 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 248 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 258 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x4 ),	/* 4 */
/* 266 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 268 */	NdrFcShort( 0x8 ),	/* 8 */
/* 270 */	NdrFcShort( 0x24 ),	/* 36 */
/* 272 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 274 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 276 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 280 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 282 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 286 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 288 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 290 */	NdrFcShort( 0x5c ),	/* Type Offset=92 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 298 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x7 ),	/* 7 */
/* 306 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 310 */	NdrFcShort( 0x24 ),	/* 36 */
/* 312 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 314 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 316 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 318 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter objects */

/* 320 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 322 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 324 */	NdrFcShort( 0x80 ),	/* Type Offset=128 */

	/* Parameter pceltFetched */

/* 326 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 328 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 332 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 334 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 336 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 338 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 340 */	NdrFcLong( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x7 ),	/* 7 */
/* 346 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 348 */	NdrFcShort( 0x8 ),	/* 8 */
/* 350 */	NdrFcShort( 0x24 ),	/* 36 */
/* 352 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 356 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter objects */

/* 360 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 362 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 364 */	NdrFcShort( 0xac ),	/* Type Offset=172 */

	/* Parameter pceltFetched */

/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 374 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
/*  6 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  8 */	NdrFcLong( 0xc0b22967 ),	/* -1062065817 */
/* 12 */	NdrFcShort( 0x5a69 ),	/* 23145 */
/* 14 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 16 */	0x8f,		/* 143 */
			0x84,		/* 132 */
/* 18 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 20 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 22 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 24 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 26 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 30 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 34 */	NdrFcShort( 0x2 ),	/* Offset= 2 (36) */
/* 36 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 38 */	NdrFcLong( 0x9f0c98f5 ),	/* -1626564363 */
/* 42 */	NdrFcShort( 0x5a6a ),	/* 23146 */
/* 44 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 46 */	0x8f,		/* 143 */
			0x84,		/* 132 */
/* 48 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 50 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 52 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 54 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 56 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 58 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 60 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 62 */	
			0x11, 0x0,	/* FC_RP */
/* 64 */	NdrFcShort( 0x2 ),	/* Offset= 2 (66) */
/* 66 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 68 */	NdrFcShort( 0x2 ),	/* 2 */
/* 70 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 72 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 74 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 76 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 78 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 80 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 82 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 84 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 86 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 88 */	
			0x11, 0x0,	/* FC_RP */
/* 90 */	NdrFcShort( 0x2 ),	/* Offset= 2 (92) */
/* 92 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 94 */	NdrFcShort( 0x2 ),	/* 2 */
/* 96 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 102 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 104 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 106 */	
			0x11, 0x0,	/* FC_RP */
/* 108 */	NdrFcShort( 0x14 ),	/* Offset= 20 (128) */
/* 110 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 112 */	NdrFcLong( 0x18d87af1 ),	/* 416840433 */
/* 116 */	NdrFcShort( 0x5a6a ),	/* 23146 */
/* 118 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 120 */	0x8f,		/* 143 */
			0x84,		/* 132 */
/* 122 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 124 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 126 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 128 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */
/* 132 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 136 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 138 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 140 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 142 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (110) */
/* 144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 146 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 148 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 150 */	
			0x11, 0x0,	/* FC_RP */
/* 152 */	NdrFcShort( 0x14 ),	/* Offset= 20 (172) */
/* 154 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 156 */	NdrFcLong( 0xd6315c8f ),	/* -701408113 */
/* 160 */	NdrFcShort( 0x5a6a ),	/* 23146 */
/* 162 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 164 */	0x8f,		/* 143 */
			0x84,		/* 132 */
/* 166 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 168 */	0xc9,		/* 201 */
			0xb4,		/* 180 */
/* 170 */	0xd5,		/* 213 */
			0xc,		/* 12 */
/* 172 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 180 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 186 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (154) */
/* 188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 190 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 192 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_corpub_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICorPublish, ver. 0.0,
   GUID={0x9613A0E7,0x5A68,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */


/* Object interface: ICorPublishEnum, ver. 0.0,
   GUID={0xC0B22967,0x5A69,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorPublishEnum_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    78
    };

static const MIDL_STUBLESS_PROXY_INFO ICorPublishEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorPublishEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorPublishEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorPublishEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorPublishEnumProxyVtbl = 
{
    &ICorPublishEnum_ProxyInfo,
    &IID_ICorPublishEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::GetCount */
};

const CInterfaceStubVtbl _ICorPublishEnumStubVtbl =
{
    &IID_ICorPublishEnum,
    &ICorPublishEnum_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorPublishProcess, ver. 0.0,
   GUID={0x18D87AF1,0x5A6A,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorPublishProcess_FormatStringOffsetTable[] =
    {
    106,
    134,
    162,
    190
    };

static const MIDL_STUBLESS_PROXY_INFO ICorPublishProcess_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorPublishProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorPublishProcess_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorPublishProcess_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ICorPublishProcessProxyVtbl = 
{
    &ICorPublishProcess_ProxyInfo,
    &IID_ICorPublishProcess,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorPublishProcess::IsManaged */ ,
    (void *) (INT_PTR) -1 /* ICorPublishProcess::EnumAppDomains */ ,
    (void *) (INT_PTR) -1 /* ICorPublishProcess::GetProcessID */ ,
    (void *) (INT_PTR) -1 /* ICorPublishProcess::GetDisplayName */
};

const CInterfaceStubVtbl _ICorPublishProcessStubVtbl =
{
    &IID_ICorPublishProcess,
    &ICorPublishProcess_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorPublishAppDomain, ver. 0.0,
   GUID={0xD6315C8F,0x5A6A,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorPublishAppDomain_FormatStringOffsetTable[] =
    {
    230,
    258
    };

static const MIDL_STUBLESS_PROXY_INFO ICorPublishAppDomain_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorPublishAppDomain_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorPublishAppDomain_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorPublishAppDomain_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorPublishAppDomainProxyVtbl = 
{
    &ICorPublishAppDomain_ProxyInfo,
    &IID_ICorPublishAppDomain,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorPublishAppDomain::GetID */ ,
    (void *) (INT_PTR) -1 /* ICorPublishAppDomain::GetName */
};

const CInterfaceStubVtbl _ICorPublishAppDomainStubVtbl =
{
    &IID_ICorPublishAppDomain,
    &ICorPublishAppDomain_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorPublishProcessEnum, ver. 0.0,
   GUID={0xA37FBD41,0x5A69,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorPublishProcessEnum_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    78,
    298
    };

static const MIDL_STUBLESS_PROXY_INFO ICorPublishProcessEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorPublishProcessEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorPublishProcessEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorPublishProcessEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorPublishProcessEnumProxyVtbl = 
{
    &ICorPublishProcessEnum_ProxyInfo,
    &IID_ICorPublishProcessEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorPublishProcessEnum::Next */
};

const CInterfaceStubVtbl _ICorPublishProcessEnumStubVtbl =
{
    &IID_ICorPublishProcessEnum,
    &ICorPublishProcessEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorPublishAppDomainEnum, ver. 0.0,
   GUID={0x9F0C98F5,0x5A6A,0x11d3,{0x8F,0x84,0x00,0xA0,0xC9,0xB4,0xD5,0x0C}} */

#pragma code_seg(".orpc")
static const unsigned short ICorPublishAppDomainEnum_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    78,
    338
    };

static const MIDL_STUBLESS_PROXY_INFO ICorPublishAppDomainEnum_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorPublishAppDomainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorPublishAppDomainEnum_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorPublishAppDomainEnum_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICorPublishAppDomainEnumProxyVtbl = 
{
    &ICorPublishAppDomainEnum_ProxyInfo,
    &IID_ICorPublishAppDomainEnum,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Skip */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Reset */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::Clone */ ,
    (void *) (INT_PTR) -1 /* ICorPublishEnum::GetCount */ ,
    (void *) (INT_PTR) -1 /* ICorPublishAppDomainEnum::Next */
};

const CInterfaceStubVtbl _ICorPublishAppDomainEnumStubVtbl =
{
    &IID_ICorPublishAppDomainEnum,
    &ICorPublishAppDomainEnum_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _corpub_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICorPublishProcessEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorPublishEnumProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorPublishAppDomainProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorPublishProcessProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorPublishAppDomainEnumProxyVtbl,
    0
};

const CInterfaceStubVtbl * _corpub_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICorPublishProcessEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorPublishEnumStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorPublishAppDomainStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorPublishProcessStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorPublishAppDomainEnumStubVtbl,
    0
};

PCInterfaceName const _corpub_InterfaceNamesList[] = 
{
    "ICorPublishProcessEnum",
    "ICorPublishEnum",
    "ICorPublishAppDomain",
    "ICorPublishProcess",
    "ICorPublishAppDomainEnum",
    0
};


#define _corpub_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _corpub, pIID, n)

int __stdcall _corpub_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _corpub, 5, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _corpub, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _corpub, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _corpub, 5, *pIndex )
    
}

const ExtendedProxyFileInfo corpub_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _corpub_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _corpub_StubVtblList,
    (const PCInterfaceName * ) & _corpub_InterfaceNamesList,
    0, // no delegation
    & _corpub_IID_Lookup, 
    5,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corprof_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:10 2003
 */
/* Compiler settings for corprof.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "corprof.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_corprof_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICorProfilerCallback, ver. 0.0,
   GUID={0x176FBED1,0xA55C,0x4796,{0x98,0xCA,0xA9,0xDA,0x0E,0xF8,0x83,0xE7}} */


/* Object interface: ICorProfilerInfo, ver. 0.0,
   GUID={0x28B5557D,0x3F3F,0x48b4,{0x90,0xB2,0x5F,0x9E,0xEA,0x2F,0x6C,0x48}} */


/* Object interface: IMethodMalloc, ver. 0.0,
   GUID={0xA0EFB28B,0x6EE2,0x4d7b,{0xB9,0x83,0xA7,0x5E,0xF7,0xBE,0xED,0xB8}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _corprof_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _corprof_StubVtblList[] = 
{
    0
};

PCInterfaceName const _corprof_InterfaceNamesList[] = 
{
    0
};


#define _corprof_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _corprof, pIID, n)

int __stdcall _corprof_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo corprof_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _corprof_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _corprof_StubVtblList,
    (const PCInterfaceName * ) & _corprof_InterfaceNamesList,
    0, // no delegation
    & _corprof_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corpub.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corpub_h__
#define __corpub_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __CorpubPublish_FWD_DEFINED__
#define __CorpubPublish_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorpubPublish CorpubPublish;
#else
typedef struct CorpubPublish CorpubPublish;
#endif /* __cplusplus */

#endif 	/* __CorpubPublish_FWD_DEFINED__ */


#ifndef __ICorPublish_FWD_DEFINED__
#define __ICorPublish_FWD_DEFINED__
typedef interface ICorPublish ICorPublish;
#endif 	/* __ICorPublish_FWD_DEFINED__ */


#ifndef __ICorPublishEnum_FWD_DEFINED__
#define __ICorPublishEnum_FWD_DEFINED__
typedef interface ICorPublishEnum ICorPublishEnum;
#endif 	/* __ICorPublishEnum_FWD_DEFINED__ */


#ifndef __ICorPublishProcess_FWD_DEFINED__
#define __ICorPublishProcess_FWD_DEFINED__
typedef interface ICorPublishProcess ICorPublishProcess;
#endif 	/* __ICorPublishProcess_FWD_DEFINED__ */


#ifndef __ICorPublishAppDomain_FWD_DEFINED__
#define __ICorPublishAppDomain_FWD_DEFINED__
typedef interface ICorPublishAppDomain ICorPublishAppDomain;
#endif 	/* __ICorPublishAppDomain_FWD_DEFINED__ */


#ifndef __ICorPublishProcessEnum_FWD_DEFINED__
#define __ICorPublishProcessEnum_FWD_DEFINED__
typedef interface ICorPublishProcessEnum ICorPublishProcessEnum;
#endif 	/* __ICorPublishProcessEnum_FWD_DEFINED__ */


#ifndef __ICorPublishAppDomainEnum_FWD_DEFINED__
#define __ICorPublishAppDomainEnum_FWD_DEFINED__
typedef interface ICorPublishAppDomainEnum ICorPublishAppDomainEnum;
#endif 	/* __ICorPublishAppDomainEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corpub_0000 */
/* [local] */ 

#if 0
#endif
typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corpub_0000_0001
    {	COR_PUB_MANAGEDONLY	= 0x1
    } 	COR_PUB_ENUMPROCESS;








extern RPC_IF_HANDLE __MIDL_itf_corpub_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corpub_0000_v0_0_s_ifspec;


#ifndef __CorpubProcessLib_LIBRARY_DEFINED__
#define __CorpubProcessLib_LIBRARY_DEFINED__

/* library CorpubProcessLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CorpubProcessLib;

EXTERN_C const CLSID CLSID_CorpubPublish;

#ifdef __cplusplus

class DECLSPEC_UUID("047a9a40-657e-11d3-8d5b-00104b35e7ef")
CorpubPublish;
#endif
#endif /* __CorpubProcessLib_LIBRARY_DEFINED__ */

#ifndef __ICorPublish_INTERFACE_DEFINED__
#define __ICorPublish_INTERFACE_DEFINED__

/* interface ICorPublish */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublish;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9613A0E7-5A68-11d3-8F84-00A0C9B4D50C")
    ICorPublish : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumProcesses( 
            /* [in] */ COR_PUB_ENUMPROCESS Type,
            /* [out] */ ICorPublishProcessEnum **ppIEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ unsigned int pid,
            /* [out] */ ICorPublishProcess **ppProcess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublish * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublish * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublish * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProcesses )( 
            ICorPublish * This,
            /* [in] */ COR_PUB_ENUMPROCESS Type,
            /* [out] */ ICorPublishProcessEnum **ppIEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorPublish * This,
            /* [in] */ unsigned int pid,
            /* [out] */ ICorPublishProcess **ppProcess);
        
        END_INTERFACE
    } ICorPublishVtbl;

    interface ICorPublish
    {
        CONST_VTBL struct ICorPublishVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublish_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublish_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublish_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublish_EnumProcesses(This,Type,ppIEnum)	\
    (This)->lpVtbl -> EnumProcesses(This,Type,ppIEnum)

#define ICorPublish_GetProcess(This,pid,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,pid,ppProcess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublish_EnumProcesses_Proxy( 
    ICorPublish * This,
    /* [in] */ COR_PUB_ENUMPROCESS Type,
    /* [out] */ ICorPublishProcessEnum **ppIEnum);


void __RPC_STUB ICorPublish_EnumProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublish_GetProcess_Proxy( 
    ICorPublish * This,
    /* [in] */ unsigned int pid,
    /* [out] */ ICorPublishProcess **ppProcess);


void __RPC_STUB ICorPublish_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublish_INTERFACE_DEFINED__ */


#ifndef __ICorPublishEnum_INTERFACE_DEFINED__
#define __ICorPublishEnum_INTERFACE_DEFINED__

/* interface ICorPublishEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0B22967-5A69-11d3-8F84-00A0C9B4D50C")
    ICorPublishEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorPublishEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishEnum * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } ICorPublishEnumVtbl;

    interface ICorPublishEnum
    {
        CONST_VTBL struct ICorPublishEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishEnum_Skip_Proxy( 
    ICorPublishEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorPublishEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_Reset_Proxy( 
    ICorPublishEnum * This);


void __RPC_STUB ICorPublishEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_Clone_Proxy( 
    ICorPublishEnum * This,
    /* [out] */ ICorPublishEnum **ppEnum);


void __RPC_STUB ICorPublishEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_GetCount_Proxy( 
    ICorPublishEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorPublishEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishEnum_INTERFACE_DEFINED__ */


#ifndef __ICorPublishProcess_INTERFACE_DEFINED__
#define __ICorPublishProcess_INTERFACE_DEFINED__

/* interface ICorPublishProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18D87AF1-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsManaged( 
            /* [out] */ BOOL *pbManaged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppDomains( 
            /* [out] */ ICorPublishAppDomainEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessID( 
            /* [out] */ unsigned int *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsManaged )( 
            ICorPublishProcess * This,
            /* [out] */ BOOL *pbManaged);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppDomains )( 
            ICorPublishProcess * This,
            /* [out] */ ICorPublishAppDomainEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessID )( 
            ICorPublishProcess * This,
            /* [out] */ unsigned int *pid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ICorPublishProcess * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName);
        
        END_INTERFACE
    } ICorPublishProcessVtbl;

    interface ICorPublishProcess
    {
        CONST_VTBL struct ICorPublishProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishProcess_IsManaged(This,pbManaged)	\
    (This)->lpVtbl -> IsManaged(This,pbManaged)

#define ICorPublishProcess_EnumAppDomains(This,ppEnum)	\
    (This)->lpVtbl -> EnumAppDomains(This,ppEnum)

#define ICorPublishProcess_GetProcessID(This,pid)	\
    (This)->lpVtbl -> GetProcessID(This,pid)

#define ICorPublishProcess_GetDisplayName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetDisplayName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishProcess_IsManaged_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ BOOL *pbManaged);


void __RPC_STUB ICorPublishProcess_IsManaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_EnumAppDomains_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ ICorPublishAppDomainEnum **ppEnum);


void __RPC_STUB ICorPublishProcess_EnumAppDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_GetProcessID_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ unsigned int *pid);


void __RPC_STUB ICorPublishProcess_GetProcessID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_GetDisplayName_Proxy( 
    ICorPublishProcess * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR *szName);


void __RPC_STUB ICorPublishProcess_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishProcess_INTERFACE_DEFINED__ */


#ifndef __ICorPublishAppDomain_INTERFACE_DEFINED__
#define __ICorPublishAppDomain_INTERFACE_DEFINED__

/* interface ICorPublishAppDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishAppDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6315C8F-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishAppDomain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG32 *puId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishAppDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishAppDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishAppDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorPublishAppDomain * This,
            /* [out] */ ULONG32 *puId);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorPublishAppDomain * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName);
        
        END_INTERFACE
    } ICorPublishAppDomainVtbl;

    interface ICorPublishAppDomain
    {
        CONST_VTBL struct ICorPublishAppDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishAppDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishAppDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishAppDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishAppDomain_GetID(This,puId)	\
    (This)->lpVtbl -> GetID(This,puId)

#define ICorPublishAppDomain_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishAppDomain_GetID_Proxy( 
    ICorPublishAppDomain * This,
    /* [out] */ ULONG32 *puId);


void __RPC_STUB ICorPublishAppDomain_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishAppDomain_GetName_Proxy( 
    ICorPublishAppDomain * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR *szName);


void __RPC_STUB ICorPublishAppDomain_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishAppDomain_INTERFACE_DEFINED__ */


#ifndef __ICorPublishProcessEnum_INTERFACE_DEFINED__
#define __ICorPublishProcessEnum_INTERFACE_DEFINED__

/* interface ICorPublishProcessEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishProcessEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A37FBD41-5A69-11d3-8F84-00A0C9B4D50C")
    ICorPublishProcessEnum : public ICorPublishEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishProcess **objects,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishProcessEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishProcessEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishProcessEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishProcessEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishProcessEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishProcessEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorPublishProcessEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishProcess **objects,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorPublishProcessEnumVtbl;

    interface ICorPublishProcessEnum
    {
        CONST_VTBL struct ICorPublishProcessEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishProcessEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishProcessEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishProcessEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishProcessEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishProcessEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishProcessEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishProcessEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorPublishProcessEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishProcessEnum_Next_Proxy( 
    ICorPublishProcessEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorPublishProcess **objects,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorPublishProcessEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishProcessEnum_INTERFACE_DEFINED__ */


#ifndef __ICorPublishAppDomainEnum_INTERFACE_DEFINED__
#define __ICorPublishAppDomainEnum_INTERFACE_DEFINED__

/* interface ICorPublishAppDomainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishAppDomainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F0C98F5-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishAppDomainEnum : public ICorPublishEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishAppDomainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishAppDomainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishAppDomainEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishAppDomainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorPublishAppDomainEnumVtbl;

    interface ICorPublishAppDomainEnum
    {
        CONST_VTBL struct ICorPublishAppDomainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishAppDomainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishAppDomainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishAppDomainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishAppDomainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishAppDomainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishAppDomainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishAppDomainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorPublishAppDomainEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishAppDomainEnum_Next_Proxy( 
    ICorPublishAppDomainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorPublishAppDomainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishAppDomainEnum_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsvc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:11 2003
 */
/* Compiler settings for corsvc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICORSvcDbgInfo,0xB4BCA369,0x27F4,0x4f1b,0xA0,0x24,0xB0,0x26,0x41,0x17,0xFE,0x53);


MIDL_DEFINE_GUID(IID, IID_ICORSvcDbgNotify,0x34C71F55,0xF3D8,0x4ACF,0x84,0xF4,0x4E,0x86,0xBB,0xD5,0xAE,0xBC);


MIDL_DEFINE_GUID(IID, LIBID_CORSvcLib,0xBDAD03B5,0x018F,0x4c99,0x9D,0x0C,0x54,0x6B,0x38,0xE7,0xB3,0xB3);


MIDL_DEFINE_GUID(CLSID, CLSID_CORSvc,0x20BC1828,0x06F0,0x11d2,0x8C,0xF4,0x00,0xA0,0xC9,0xB0,0xA0,0x63);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsvcpriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

// Try to keep the shared memory to a page at most
#define MAX_EVENTS ((0x1000-sizeof(DWORD)-(sizeof(int)*2)-(sizeof(HANDLE)*2))/sizeof(ServiceEvent))

// The name of the service's shared memory block
#define SERVICE_MAPPED_MEMORY_NAME L"CORSvcEventQueue"

// Invalid event index for structure below
#define INVALID_EVENT_INDEX (-1)

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

// These are the types of events that can occur
enum ServiceEventType
{
    runtimeStarted,
    stopService
};

// This contains the data relevant to each type of event
struct ServiceEventData
{
    union
    {
        struct
        {
            // The procid for the process that is starting up the runtime
            DWORD dwProcId;

            // A handle valid in the process starting up the runtime that
            // should be duplicated by the service and signalled if the
            // process waiting on the notification chooses not to attach
            HANDLE hContEvt;
        } runtimeStartedData;

        struct
        {
        } stopServiceData;
    };
};

// This is a complete event
struct ServiceEvent
{
    ServiceEventType eventType;
    ServiceEventData eventData;
    int              iNext;
};


// This is the data contained in the shared memory block
struct ServiceEventBlock
{
    // This is the procid for the service process, and is used for duplication
    // of handles below
    DWORD  dwServiceProcId;

    // Index to the first free ServiceEvent element (can be -1 for none)
    int    iFreeListHeadIdx;

    // Index to the first queued event (can be -1 for none)
    int    iEventListHeadIdx;
    int    iEventListTailIdx;

    //
    // NOTE: handles are for service process, not runtime process
    //

    // The lock for accessing this data
    HANDLE hSvcLock;

    // This semaphore has a count equivalent to the number of free available
    // events, so if all the events are being taken, then a thread that wants
    // an event will wait till a free one is put on the queue
    HANDLE hFreeEventSem;

    // The event to set to tell the service that data is available
    // (set after adding event to event queue)
    HANDLE hDataAvailableEvt;

    // The array of events, elements of which are on either the free list
    // or event list
    ServiceEvent arrEvents[MAX_EVENTS];

    void InitQueues()
    {
        // Link all event elements for free list
        for (int i = 0; i < MAX_EVENTS; i++)
        {
            // Link this event to the next one
            arrEvents[i].iNext = i + 1;
        }

        // Invalidate the next pointer of the last element
        arrEvents[MAX_EVENTS - 1].iNext = INVALID_EVENT_INDEX;

        // Point the free list header to this new list
        iFreeListHeadIdx = 0;

        // Invalidate the event list pointer
        iEventListHeadIdx = INVALID_EVENT_INDEX;
        iEventListTailIdx = INVALID_EVENT_INDEX;

    }

    // Add the event to the end of the list
    void QueueEvent(ServiceEvent *pEvent)
    {
        int idx = pEvent - arrEvents;
        _ASSERTE(idx >= 0 && idx < MAX_EVENTS);

        arrEvents[idx].iNext = INVALID_EVENT_INDEX;

        if (iEventListHeadIdx == INVALID_EVENT_INDEX)
        {
            iEventListHeadIdx = idx;
            iEventListTailIdx = idx;
        }
        else
        {
            arrEvents[iEventListTailIdx].iNext = idx;
            iEventListTailIdx = idx;
        }
    }

    // Pull the event off the front of the list
    ServiceEvent *DequeueEvent()
    {
        int idx = iEventListHeadIdx;

        if (idx != INVALID_EVENT_INDEX)
        {
            iEventListHeadIdx = arrEvents[idx].iNext;
            return (&arrEvents[idx]);
        }

        return (NULL);
    }

    void FreeEvent(ServiceEvent *pEvent)
    {
        int idx = pEvent - arrEvents;
        _ASSERTE(idx >= 0 && idx < MAX_EVENTS);

        arrEvents[idx].iNext = iFreeListHeadIdx;
        iFreeListHeadIdx = idx;
    }

    ServiceEvent *GetFreeEvent()
    {
        int idx = iFreeListHeadIdx;

        if (idx != INVALID_EVENT_INDEX)
        {
            iFreeListHeadIdx = arrEvents[idx].iNext;
            return (&arrEvents[idx]);
        }

        return (NULL);
    }
};

// This structure is created in the IPC block of a managed app, and is used
// to notify the service that the runtime is starting up, as well as by the
// service to notify the runtime that it may continue.
struct ServiceIPCControlBlock
{
    // This says whether or not the runtime should notify the service that
    // it is starting up
	BOOL   bNotifyService;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsvc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:11 2003
 */
/* Compiler settings for corsvc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corsvc_h__
#define __corsvc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICORSvcDbgInfo_FWD_DEFINED__
#define __ICORSvcDbgInfo_FWD_DEFINED__
typedef interface ICORSvcDbgInfo ICORSvcDbgInfo;
#endif 	/* __ICORSvcDbgInfo_FWD_DEFINED__ */


#ifndef __ICORSvcDbgNotify_FWD_DEFINED__
#define __ICORSvcDbgNotify_FWD_DEFINED__
typedef interface ICORSvcDbgNotify ICORSvcDbgNotify;
#endif 	/* __ICORSvcDbgNotify_FWD_DEFINED__ */


#ifndef __CORSvc_FWD_DEFINED__
#define __CORSvc_FWD_DEFINED__

#ifdef __cplusplus
typedef class CORSvc CORSvc;
#else
typedef struct CORSvc CORSvc;
#endif /* __cplusplus */

#endif 	/* __CORSvc_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corsvc_0000 */
/* [local] */ 

#if 0
#endif




extern RPC_IF_HANDLE __MIDL_itf_corsvc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsvc_0000_v0_0_s_ifspec;

#ifndef __ICORSvcDbgInfo_INTERFACE_DEFINED__
#define __ICORSvcDbgInfo_INTERFACE_DEFINED__

/* interface ICORSvcDbgInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICORSvcDbgInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4BCA369-27F4-4f1b-A024-B0264117FE53")
    ICORSvcDbgInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestRuntimeStartupNotification( 
            /* [in] */ UINT_PTR procId,
            /* [in] */ ICORSvcDbgNotify *pINotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelRuntimeStartupNotification( 
            /* [in] */ UINT_PTR procId,
            /* [in] */ ICORSvcDbgNotify *pINotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICORSvcDbgInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICORSvcDbgInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICORSvcDbgInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICORSvcDbgInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestRuntimeStartupNotification )( 
            ICORSvcDbgInfo * This,
            /* [in] */ UINT_PTR procId,
            /* [in] */ ICORSvcDbgNotify *pINotify);
        
        HRESULT ( STDMETHODCALLTYPE *CancelRuntimeStartupNotification )( 
            ICORSvcDbgInfo * This,
            /* [in] */ UINT_PTR procId,
            /* [in] */ ICORSvcDbgNotify *pINotify);
        
        END_INTERFACE
    } ICORSvcDbgInfoVtbl;

    interface ICORSvcDbgInfo
    {
        CONST_VTBL struct ICORSvcDbgInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICORSvcDbgInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICORSvcDbgInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICORSvcDbgInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICORSvcDbgInfo_RequestRuntimeStartupNotification(This,procId,pINotify)	\
    (This)->lpVtbl -> RequestRuntimeStartupNotification(This,procId,pINotify)

#define ICORSvcDbgInfo_CancelRuntimeStartupNotification(This,procId,pINotify)	\
    (This)->lpVtbl -> CancelRuntimeStartupNotification(This,procId,pINotify)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICORSvcDbgInfo_RequestRuntimeStartupNotification_Proxy( 
    ICORSvcDbgInfo * This,
    /* [in] */ UINT_PTR procId,
    /* [in] */ ICORSvcDbgNotify *pINotify);


void __RPC_STUB ICORSvcDbgInfo_RequestRuntimeStartupNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICORSvcDbgInfo_CancelRuntimeStartupNotification_Proxy( 
    ICORSvcDbgInfo * This,
    /* [in] */ UINT_PTR procId,
    /* [in] */ ICORSvcDbgNotify *pINotify);


void __RPC_STUB ICORSvcDbgInfo_CancelRuntimeStartupNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICORSvcDbgInfo_INTERFACE_DEFINED__ */


#ifndef __ICORSvcDbgNotify_INTERFACE_DEFINED__
#define __ICORSvcDbgNotify_INTERFACE_DEFINED__

/* interface ICORSvcDbgNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICORSvcDbgNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34C71F55-F3D8-4ACF-84F4-4E86BBD5AEBC")
    ICORSvcDbgNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyRuntimeStartup( 
            /* [in] */ UINT_PTR procId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyServiceStopped( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICORSvcDbgNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICORSvcDbgNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICORSvcDbgNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICORSvcDbgNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRuntimeStartup )( 
            ICORSvcDbgNotify * This,
            /* [in] */ UINT_PTR procId);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyServiceStopped )( 
            ICORSvcDbgNotify * This);
        
        END_INTERFACE
    } ICORSvcDbgNotifyVtbl;

    interface ICORSvcDbgNotify
    {
        CONST_VTBL struct ICORSvcDbgNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICORSvcDbgNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICORSvcDbgNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICORSvcDbgNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICORSvcDbgNotify_NotifyRuntimeStartup(This,procId)	\
    (This)->lpVtbl -> NotifyRuntimeStartup(This,procId)

#define ICORSvcDbgNotify_NotifyServiceStopped(This)	\
    (This)->lpVtbl -> NotifyServiceStopped(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICORSvcDbgNotify_NotifyRuntimeStartup_Proxy( 
    ICORSvcDbgNotify * This,
    /* [in] */ UINT_PTR procId);


void __RPC_STUB ICORSvcDbgNotify_NotifyRuntimeStartup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICORSvcDbgNotify_NotifyServiceStopped_Proxy( 
    ICORSvcDbgNotify * This);


void __RPC_STUB ICORSvcDbgNotify_NotifyServiceStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICORSvcDbgNotify_INTERFACE_DEFINED__ */



#ifndef __CORSvcLib_LIBRARY_DEFINED__
#define __CORSvcLib_LIBRARY_DEFINED__

/* library CORSvcLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CORSvcLib;

EXTERN_C const CLSID CLSID_CORSvc;

#ifdef __cplusplus

class DECLSPEC_UUID("20BC1828-06F0-11d2-8CF4-00A0C9B0A063")
CORSvc;
#endif
#endif /* __CORSvcLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corregpriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CORREGPRIV.H
//
// ===========================================================================
// This file is obsolete.
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma message("#include of obsolete file corregpriv.h")

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsvc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:11 2003
 */
/* Compiler settings for corsvc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "corsvc.h"

#define TYPE_FORMAT_STRING_SIZE   39                                
#define PROC_FORMAT_STRING_SIZE   119                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICORSvcDbgInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICORSvcDbgInfo_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICORSvcDbgNotify_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICORSvcDbgNotify_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure RequestRuntimeStartupNotification */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter procId */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pINotify */

/* 22 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 28 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CancelRuntimeStartupNotification */

/* 34 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 36 */	NdrFcLong( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x4 ),	/* 4 */
/* 42 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
/* 48 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter procId */

/* 50 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 52 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pINotify */

/* 56 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 58 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 60 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 62 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 64 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NotifyRuntimeStartup */

/* 68 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 70 */	NdrFcLong( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x3 ),	/* 3 */
/* 76 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 78 */	NdrFcShort( 0x8 ),	/* 8 */
/* 80 */	NdrFcShort( 0x8 ),	/* 8 */
/* 82 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter procId */

/* 84 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 86 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 92 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NotifyServiceStopped */

/* 96 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x4 ),	/* 4 */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0x8 ),	/* 8 */
/* 110 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 112 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 114 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x34c71f55 ),	/* 885464917 */
/*  8 */	NdrFcShort( 0xf3d8 ),	/* -3112 */
/* 10 */	NdrFcShort( 0x4acf ),	/* 19151 */
/* 12 */	0x84,		/* 132 */
			0xf4,		/* 244 */
/* 14 */	0x4e,		/* 78 */
			0x86,		/* 134 */
/* 16 */	0xbb,		/* 187 */
			0xd5,		/* 213 */
/* 18 */	0xae,		/* 174 */
			0xbc,		/* 188 */
/* 20 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 22 */	NdrFcLong( 0x34c71f55 ),	/* 885464917 */
/* 26 */	NdrFcShort( 0xf3d8 ),	/* -3112 */
/* 28 */	NdrFcShort( 0x4acf ),	/* 19151 */
/* 30 */	0x84,		/* 132 */
			0xf4,		/* 244 */
/* 32 */	0x4e,		/* 78 */
			0x86,		/* 134 */
/* 34 */	0xbb,		/* 187 */
			0xd5,		/* 213 */
/* 36 */	0xae,		/* 174 */
			0xbc,		/* 188 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_corsvc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICORSvcDbgInfo, ver. 0.0,
   GUID={0xB4BCA369,0x27F4,0x4f1b,{0xA0,0x24,0xB0,0x26,0x41,0x17,0xFE,0x53}} */

#pragma code_seg(".orpc")
static const unsigned short ICORSvcDbgInfo_FormatStringOffsetTable[] =
    {
    0,
    34
    };

static const MIDL_STUBLESS_PROXY_INFO ICORSvcDbgInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICORSvcDbgInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICORSvcDbgInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICORSvcDbgInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICORSvcDbgInfoProxyVtbl = 
{
    &ICORSvcDbgInfo_ProxyInfo,
    &IID_ICORSvcDbgInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICORSvcDbgInfo::RequestRuntimeStartupNotification */ ,
    (void *) (INT_PTR) -1 /* ICORSvcDbgInfo::CancelRuntimeStartupNotification */
};

const CInterfaceStubVtbl _ICORSvcDbgInfoStubVtbl =
{
    &IID_ICORSvcDbgInfo,
    &ICORSvcDbgInfo_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICORSvcDbgNotify, ver. 0.0,
   GUID={0x34C71F55,0xF3D8,0x4ACF,{0x84,0xF4,0x4E,0x86,0xBB,0xD5,0xAE,0xBC}} */

#pragma code_seg(".orpc")
static const unsigned short ICORSvcDbgNotify_FormatStringOffsetTable[] =
    {
    68,
    96
    };

static const MIDL_STUBLESS_PROXY_INFO ICORSvcDbgNotify_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICORSvcDbgNotify_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICORSvcDbgNotify_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICORSvcDbgNotify_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICORSvcDbgNotifyProxyVtbl = 
{
    &ICORSvcDbgNotify_ProxyInfo,
    &IID_ICORSvcDbgNotify,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICORSvcDbgNotify::NotifyRuntimeStartup */ ,
    (void *) (INT_PTR) -1 /* ICORSvcDbgNotify::NotifyServiceStopped */
};

const CInterfaceStubVtbl _ICORSvcDbgNotifyStubVtbl =
{
    &IID_ICORSvcDbgNotify,
    &ICORSvcDbgNotify_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _corsvc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICORSvcDbgNotifyProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICORSvcDbgInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _corsvc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICORSvcDbgNotifyStubVtbl,
    ( CInterfaceStubVtbl *) &_ICORSvcDbgInfoStubVtbl,
    0
};

PCInterfaceName const _corsvc_InterfaceNamesList[] = 
{
    "ICORSvcDbgNotify",
    "ICORSvcDbgInfo",
    0
};


#define _corsvc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _corsvc, pIID, n)

int __stdcall _corsvc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _corsvc, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _corsvc, 2, *pIndex )
    
}

const ExtendedProxyFileInfo corsvc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _corsvc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _corsvc_StubVtblList,
    (const PCInterfaceName * ) & _corsvc_InterfaceNamesList,
    0, // no delegation
    & _corsvc_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsym.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:09 2003
 */
/* Compiler settings for corsym.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corsym_h__
#define __corsym_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __CorSymWriter_FWD_DEFINED__
#define __CorSymWriter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymWriter CorSymWriter;
#else
typedef struct CorSymWriter CorSymWriter;
#endif /* __cplusplus */

#endif 	/* __CorSymWriter_FWD_DEFINED__ */


#ifndef __CorSymReader_FWD_DEFINED__
#define __CorSymReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymReader CorSymReader;
#else
typedef struct CorSymReader CorSymReader;
#endif /* __cplusplus */

#endif 	/* __CorSymReader_FWD_DEFINED__ */


#ifndef __CorSymBinder_FWD_DEFINED__
#define __CorSymBinder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymBinder CorSymBinder;
#else
typedef struct CorSymBinder CorSymBinder;
#endif /* __cplusplus */

#endif 	/* __CorSymBinder_FWD_DEFINED__ */


#ifndef __CorSymWriter_SxS_FWD_DEFINED__
#define __CorSymWriter_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymWriter_SxS CorSymWriter_SxS;
#else
typedef struct CorSymWriter_SxS CorSymWriter_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymWriter_SxS_FWD_DEFINED__ */


#ifndef __CorSymReader_SxS_FWD_DEFINED__
#define __CorSymReader_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymReader_SxS CorSymReader_SxS;
#else
typedef struct CorSymReader_SxS CorSymReader_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymReader_SxS_FWD_DEFINED__ */


#ifndef __CorSymBinder_SxS_FWD_DEFINED__
#define __CorSymBinder_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymBinder_SxS CorSymBinder_SxS;
#else
typedef struct CorSymBinder_SxS CorSymBinder_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymBinder_SxS_FWD_DEFINED__ */


#ifndef __ISymUnmanagedBinder_FWD_DEFINED__
#define __ISymUnmanagedBinder_FWD_DEFINED__
typedef interface ISymUnmanagedBinder ISymUnmanagedBinder;
#endif 	/* __ISymUnmanagedBinder_FWD_DEFINED__ */


#ifndef __ISymUnmanagedBinder2_FWD_DEFINED__
#define __ISymUnmanagedBinder2_FWD_DEFINED__
typedef interface ISymUnmanagedBinder2 ISymUnmanagedBinder2;
#endif 	/* __ISymUnmanagedBinder2_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDispose_FWD_DEFINED__
#define __ISymUnmanagedDispose_FWD_DEFINED__
typedef interface ISymUnmanagedDispose ISymUnmanagedDispose;
#endif 	/* __ISymUnmanagedDispose_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDocument_FWD_DEFINED__
#define __ISymUnmanagedDocument_FWD_DEFINED__
typedef interface ISymUnmanagedDocument ISymUnmanagedDocument;
#endif 	/* __ISymUnmanagedDocument_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDocumentWriter_FWD_DEFINED__
#define __ISymUnmanagedDocumentWriter_FWD_DEFINED__
typedef interface ISymUnmanagedDocumentWriter ISymUnmanagedDocumentWriter;
#endif 	/* __ISymUnmanagedDocumentWriter_FWD_DEFINED__ */


#ifndef __ISymUnmanagedMethod_FWD_DEFINED__
#define __ISymUnmanagedMethod_FWD_DEFINED__
typedef interface ISymUnmanagedMethod ISymUnmanagedMethod;
#endif 	/* __ISymUnmanagedMethod_FWD_DEFINED__ */


#ifndef __ISymUnmanagedNamespace_FWD_DEFINED__
#define __ISymUnmanagedNamespace_FWD_DEFINED__
typedef interface ISymUnmanagedNamespace ISymUnmanagedNamespace;
#endif 	/* __ISymUnmanagedNamespace_FWD_DEFINED__ */


#ifndef __ISymUnmanagedReader_FWD_DEFINED__
#define __ISymUnmanagedReader_FWD_DEFINED__
typedef interface ISymUnmanagedReader ISymUnmanagedReader;
#endif 	/* __ISymUnmanagedReader_FWD_DEFINED__ */


#ifndef __ISymUnmanagedScope_FWD_DEFINED__
#define __ISymUnmanagedScope_FWD_DEFINED__
typedef interface ISymUnmanagedScope ISymUnmanagedScope;
#endif 	/* __ISymUnmanagedScope_FWD_DEFINED__ */


#ifndef __ISymUnmanagedVariable_FWD_DEFINED__
#define __ISymUnmanagedVariable_FWD_DEFINED__
typedef interface ISymUnmanagedVariable ISymUnmanagedVariable;
#endif 	/* __ISymUnmanagedVariable_FWD_DEFINED__ */


#ifndef __ISymUnmanagedWriter_FWD_DEFINED__
#define __ISymUnmanagedWriter_FWD_DEFINED__
typedef interface ISymUnmanagedWriter ISymUnmanagedWriter;
#endif 	/* __ISymUnmanagedWriter_FWD_DEFINED__ */


#ifndef __ISymUnmanagedWriter2_FWD_DEFINED__
#define __ISymUnmanagedWriter2_FWD_DEFINED__
typedef interface ISymUnmanagedWriter2 ISymUnmanagedWriter2;
#endif 	/* __ISymUnmanagedWriter2_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corsym_0000 */
/* [local] */ 

#if 0
typedef typedef unsigned int UINT32;
;

typedef mdToken mdTypeDef;

typedef mdToken mdMethodDef;

typedef typedef ULONG_PTR SIZE_T;
;

#endif
#ifndef __CORHDR_H__
typedef mdToken mdSignature;

#endif
extern GUID __declspec(selectany) CorSym_LanguageType_C = { 0x63a08714, 0xfc37, 0x11d2, { 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1 } };
extern GUID __declspec(selectany) CorSym_LanguageType_CPlusPlus = { 0x3a12d0b7, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
extern GUID __declspec(selectany) CorSym_LanguageType_CSharp = { 0x3f5162f8, 0x07c6, 0x11d3, { 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1 } };
extern GUID __declspec(selectany) CorSym_LanguageType_Basic = { 0x3a12d0b8, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
extern GUID __declspec(selectany) CorSym_LanguageType_Java = { 0x3a12d0b4, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
extern GUID __declspec(selectany) CorSym_LanguageType_Cobol = { 0xaf046cd1, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
extern GUID __declspec(selectany) CorSym_LanguageType_Pascal = { 0xaf046cd2, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
extern GUID __declspec(selectany) CorSym_LanguageType_ILAssembly = { 0xaf046cd3, 0xd0e1, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
extern GUID __declspec(selectany) CorSym_LanguageType_JScript = { 0x3a12d0b6, 0xc26c, 0x11d0, { 0xb4, 0x42, 0x00, 0xa0, 0x24, 0x4a, 0x1d, 0xd2 } };
extern GUID __declspec(selectany) CorSym_LanguageType_SMC = { 0xd9b9f7b, 0x6611, 0x11d3, { 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd } };
extern GUID __declspec(selectany) CorSym_LanguageType_MCPlusPlus = { 0x4b35fde8, 0x07c6, 0x11d3, { 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1 } };
extern GUID __declspec(selectany) CorSym_LanguageVendor_Microsoft = { 0x994b45c4, 0xe6e9, 0x11d2, { 0x90, 0x3f, 0x00, 0xc0, 0x4f, 0xa3, 0x02, 0xa1 } };
extern GUID __declspec(selectany) CorSym_DocumentType_Text = { 0x5a869d0b, 0x6611, 0x11d3, { 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd } };
extern GUID __declspec(selectany) CorSym_DocumentType_MC =   { 0xeb40cb65, 0x3c1f, 0x4352, { 0x9d, 0x7b, 0xba, 0xf, 0xc4, 0x7a, 0x9d, 0x77 } };










typedef 
enum CorSymAddrKind
    {	ADDR_IL_OFFSET	= 1,
	ADDR_NATIVE_RVA	= 2,
	ADDR_NATIVE_REGISTER	= 3,
	ADDR_NATIVE_REGREL	= 4,
	ADDR_NATIVE_OFFSET	= 5,
	ADDR_NATIVE_REGREG	= 6,
	ADDR_NATIVE_REGSTK	= 7,
	ADDR_NATIVE_STKREG	= 8,
	ADDR_BITFIELD	= 9
    } 	CorSymAddrKind;

typedef 
enum CorSymVarFlag
    {	VAR_IS_COMP_GEN	= 1
    } 	CorSymVarFlag;



extern RPC_IF_HANDLE __MIDL_itf_corsym_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0000_v0_0_s_ifspec;


#ifndef __CorSymLib_LIBRARY_DEFINED__
#define __CorSymLib_LIBRARY_DEFINED__

/* library CorSymLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CorSymLib;

EXTERN_C const CLSID CLSID_CorSymWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("108296C1-281E-11d3-BD22-0000F80849BD")
CorSymWriter;
#endif

EXTERN_C const CLSID CLSID_CorSymReader;

#ifdef __cplusplus

class DECLSPEC_UUID("108296C2-281E-11d3-BD22-0000F80849BD")
CorSymReader;
#endif

EXTERN_C const CLSID CLSID_CorSymBinder;

#ifdef __cplusplus

class DECLSPEC_UUID("AA544D41-28CB-11d3-BD22-0000F80849BD")
CorSymBinder;
#endif

EXTERN_C const CLSID CLSID_CorSymWriter_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0AE2DEB0-F901-478b-BB9F-881EE8066788")
CorSymWriter_SxS;
#endif

EXTERN_C const CLSID CLSID_CorSymReader_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0A3976C5-4529-4ef8-B0B0-42EED37082CD")
CorSymReader_SxS;
#endif

EXTERN_C const CLSID CLSID_CorSymBinder_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0A29FF9E-7F9C-4437-8B11-F424491E3931")
CorSymBinder_SxS;
#endif
#endif /* __CorSymLib_LIBRARY_DEFINED__ */

#ifndef __ISymUnmanagedBinder_INTERFACE_DEFINED__
#define __ISymUnmanagedBinder_INTERFACE_DEFINED__

/* interface ISymUnmanagedBinder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedBinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA544D42-28CB-11d3-BD22-0000F80849BD")
    ISymUnmanagedBinder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderForFile( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReaderFromStream( 
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedBinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedBinder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedBinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedBinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile )( 
            ISymUnmanagedBinder * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromStream )( 
            ISymUnmanagedBinder * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedBinderVtbl;

    interface ISymUnmanagedBinder
    {
        CONST_VTBL struct ISymUnmanagedBinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedBinder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedBinder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedBinder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedBinder_GetReaderForFile(This,importer,fileName,searchPath,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile(This,importer,fileName,searchPath,pRetVal)

#define ISymUnmanagedBinder_GetReaderFromStream(This,importer,pstream,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromStream(This,importer,pstream,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder_GetReaderForFile_Proxy( 
    ISymUnmanagedBinder * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *fileName,
    /* [in] */ const WCHAR *searchPath,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder_GetReaderForFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder_GetReaderFromStream_Proxy( 
    ISymUnmanagedBinder * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ IStream *pstream,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder_GetReaderFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedBinder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corsym_0110 */
/* [local] */ 

typedef 
enum CorSymSearchPolicyAttributes
    {	AllowRegistryAccess	= 0x1,
	AllowSymbolServerAccess	= 0x2,
	AllowOriginalPathAccess	= 0x4,
	AllowReferencePathAccess	= 0x8
    } 	CorSymSearchPolicyAttributes;



extern RPC_IF_HANDLE __MIDL_itf_corsym_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0110_v0_0_s_ifspec;

#ifndef __ISymUnmanagedBinder2_INTERFACE_DEFINED__
#define __ISymUnmanagedBinder2_INTERFACE_DEFINED__

/* interface ISymUnmanagedBinder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedBinder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ACCEE350-89AF-4ccb-8B40-1C2C4C6F9434")
    ISymUnmanagedBinder2 : public ISymUnmanagedBinder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderForFile2( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedBinder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedBinder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedBinder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromStream )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile2 )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedBinder2Vtbl;

    interface ISymUnmanagedBinder2
    {
        CONST_VTBL struct ISymUnmanagedBinder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedBinder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedBinder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedBinder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedBinder2_GetReaderForFile(This,importer,fileName,searchPath,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile(This,importer,fileName,searchPath,pRetVal)

#define ISymUnmanagedBinder2_GetReaderFromStream(This,importer,pstream,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromStream(This,importer,pstream,pRetVal)


#define ISymUnmanagedBinder2_GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder2_GetReaderForFile2_Proxy( 
    ISymUnmanagedBinder2 * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *fileName,
    /* [in] */ const WCHAR *searchPath,
    /* [in] */ ULONG32 searchPolicy,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder2_GetReaderForFile2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedBinder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corsym_0111 */
/* [local] */ 

static const int E_SYM_DESTROYED = MAKE_HRESULT(1, FACILITY_ITF, 0xdead);


extern RPC_IF_HANDLE __MIDL_itf_corsym_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0111_v0_0_s_ifspec;

#ifndef __ISymUnmanagedDispose_INTERFACE_DEFINED__
#define __ISymUnmanagedDispose_INTERFACE_DEFINED__

/* interface ISymUnmanagedDispose */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDispose;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("969708D2-05E5-4861-A3B0-96E473CDF63F")
    ISymUnmanagedDispose : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDisposeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDispose * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDispose * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDispose * This);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            ISymUnmanagedDispose * This);
        
        END_INTERFACE
    } ISymUnmanagedDisposeVtbl;

    interface ISymUnmanagedDispose
    {
        CONST_VTBL struct ISymUnmanagedDisposeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDispose_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDispose_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDispose_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDispose_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDispose_Destroy_Proxy( 
    ISymUnmanagedDispose * This);


void __RPC_STUB ISymUnmanagedDispose_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDispose_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedDocument_INTERFACE_DEFINED__
#define __ISymUnmanagedDocument_INTERFACE_DEFINED__

/* interface ISymUnmanagedDocument */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08")
    ISymUnmanagedDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [in] */ ULONG32 cchUrl,
            /* [out] */ ULONG32 *pcchUrl,
            /* [length_is][size_is][out] */ WCHAR szUrl[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentType( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageVendor( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSumAlgorithmId( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSum( 
            /* [in] */ ULONG32 cData,
            /* [out] */ ULONG32 *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestLine( 
            /* [in] */ ULONG32 line,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasEmbeddedSource( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceLength( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceRange( 
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn,
            /* [in] */ ULONG32 cSourceBytes,
            /* [out] */ ULONG32 *pcSourceBytes,
            /* [length_is][size_is][out] */ BYTE source[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 cchUrl,
            /* [out] */ ULONG32 *pcchUrl,
            /* [length_is][size_is][out] */ WCHAR szUrl[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentType )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageVendor )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSumAlgorithmId )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSum )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 cData,
            /* [out] */ ULONG32 *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestLine )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 line,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *HasEmbeddedSource )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLength )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceRange )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn,
            /* [in] */ ULONG32 cSourceBytes,
            /* [out] */ ULONG32 *pcSourceBytes,
            /* [length_is][size_is][out] */ BYTE source[  ]);
        
        END_INTERFACE
    } ISymUnmanagedDocumentVtbl;

    interface ISymUnmanagedDocument
    {
        CONST_VTBL struct ISymUnmanagedDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDocument_GetURL(This,cchUrl,pcchUrl,szUrl)	\
    (This)->lpVtbl -> GetURL(This,cchUrl,pcchUrl,szUrl)

#define ISymUnmanagedDocument_GetDocumentType(This,pRetVal)	\
    (This)->lpVtbl -> GetDocumentType(This,pRetVal)

#define ISymUnmanagedDocument_GetLanguage(This,pRetVal)	\
    (This)->lpVtbl -> GetLanguage(This,pRetVal)

#define ISymUnmanagedDocument_GetLanguageVendor(This,pRetVal)	\
    (This)->lpVtbl -> GetLanguageVendor(This,pRetVal)

#define ISymUnmanagedDocument_GetCheckSumAlgorithmId(This,pRetVal)	\
    (This)->lpVtbl -> GetCheckSumAlgorithmId(This,pRetVal)

#define ISymUnmanagedDocument_GetCheckSum(This,cData,pcData,data)	\
    (This)->lpVtbl -> GetCheckSum(This,cData,pcData,data)

#define ISymUnmanagedDocument_FindClosestLine(This,line,pRetVal)	\
    (This)->lpVtbl -> FindClosestLine(This,line,pRetVal)

#define ISymUnmanagedDocument_HasEmbeddedSource(This,pRetVal)	\
    (This)->lpVtbl -> HasEmbeddedSource(This,pRetVal)

#define ISymUnmanagedDocument_GetSourceLength(This,pRetVal)	\
    (This)->lpVtbl -> GetSourceLength(This,pRetVal)

#define ISymUnmanagedDocument_GetSourceRange(This,startLine,startColumn,endLine,endColumn,cSourceBytes,pcSourceBytes,source)	\
    (This)->lpVtbl -> GetSourceRange(This,startLine,startColumn,endLine,endColumn,cSourceBytes,pcSourceBytes,source)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetURL_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 cchUrl,
    /* [out] */ ULONG32 *pcchUrl,
    /* [length_is][size_is][out] */ WCHAR szUrl[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetDocumentType_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetDocumentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetLanguage_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetLanguageVendor_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetLanguageVendor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetCheckSumAlgorithmId_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetCheckSumAlgorithmId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetCheckSum_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 cData,
    /* [out] */ ULONG32 *pcData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_FindClosestLine_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 line,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_FindClosestLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_HasEmbeddedSource_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_HasEmbeddedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetSourceLength_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetSourceLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetSourceRange_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 startLine,
    /* [in] */ ULONG32 startColumn,
    /* [in] */ ULONG32 endLine,
    /* [in] */ ULONG32 endColumn,
    /* [in] */ ULONG32 cSourceBytes,
    /* [out] */ ULONG32 *pcSourceBytes,
    /* [length_is][size_is][out] */ BYTE source[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetSourceRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDocument_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__
#define __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__

/* interface ISymUnmanagedDocumentWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDocumentWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")
    ISymUnmanagedDocumentWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [in] */ ULONG32 sourceSize,
            /* [size_is][in] */ BYTE source[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckSum( 
            /* [in] */ GUID algorithmId,
            /* [in] */ ULONG32 checkSumSize,
            /* [size_is][in] */ BYTE checkSum[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDocumentWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDocumentWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDocumentWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ ULONG32 sourceSize,
            /* [size_is][in] */ BYTE source[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ GUID algorithmId,
            /* [in] */ ULONG32 checkSumSize,
            /* [size_is][in] */ BYTE checkSum[  ]);
        
        END_INTERFACE
    } ISymUnmanagedDocumentWriterVtbl;

    interface ISymUnmanagedDocumentWriter
    {
        CONST_VTBL struct ISymUnmanagedDocumentWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDocumentWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDocumentWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDocumentWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDocumentWriter_SetSource(This,sourceSize,source)	\
    (This)->lpVtbl -> SetSource(This,sourceSize,source)

#define ISymUnmanagedDocumentWriter_SetCheckSum(This,algorithmId,checkSumSize,checkSum)	\
    (This)->lpVtbl -> SetCheckSum(This,algorithmId,checkSumSize,checkSum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDocumentWriter_SetSource_Proxy( 
    ISymUnmanagedDocumentWriter * This,
    /* [in] */ ULONG32 sourceSize,
    /* [size_is][in] */ BYTE source[  ]);


void __RPC_STUB ISymUnmanagedDocumentWriter_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocumentWriter_SetCheckSum_Proxy( 
    ISymUnmanagedDocumentWriter * This,
    /* [in] */ GUID algorithmId,
    /* [in] */ ULONG32 checkSumSize,
    /* [size_is][in] */ BYTE checkSum[  ]);


void __RPC_STUB ISymUnmanagedDocumentWriter_SetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedMethod_INTERFACE_DEFINED__
#define __ISymUnmanagedMethod_INTERFACE_DEFINED__

/* interface ISymUnmanagedMethod */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62B923C-B500-3158-A543-24F307A8B7E1")
    ISymUnmanagedMethod : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [retval][out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequencePointCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootScope( 
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeFromOffset( 
            /* [in] */ ULONG32 offset,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRanges( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cRanges,
            /* [out] */ ULONG32 *pcRanges,
            /* [length_is][size_is][out] */ ULONG32 ranges[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameters( 
            /* [in] */ ULONG32 cParams,
            /* [out] */ ULONG32 *pcParams,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespace( 
            /* [out] */ ISymUnmanagedNamespace **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceStartEnd( 
            /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
            /* [in] */ ULONG32 lines[ 2 ],
            /* [in] */ ULONG32 columns[ 2 ],
            /* [out] */ BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequencePoints( 
            /* [in] */ ULONG32 cPoints,
            /* [out] */ ULONG32 *pcPoints,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequencePointCount )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootScope )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeFromOffset )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 offset,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRanges )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cRanges,
            /* [out] */ ULONG32 *pcRanges,
            /* [length_is][size_is][out] */ ULONG32 ranges[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameters )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 cParams,
            /* [out] */ ULONG32 *pcParams,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespace )( 
            ISymUnmanagedMethod * This,
            /* [out] */ ISymUnmanagedNamespace **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceStartEnd )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
            /* [in] */ ULONG32 lines[ 2 ],
            /* [in] */ ULONG32 columns[ 2 ],
            /* [out] */ BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequencePoints )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 cPoints,
            /* [out] */ ULONG32 *pcPoints,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        END_INTERFACE
    } ISymUnmanagedMethodVtbl;

    interface ISymUnmanagedMethod
    {
        CONST_VTBL struct ISymUnmanagedMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedMethod_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ISymUnmanagedMethod_GetSequencePointCount(This,pRetVal)	\
    (This)->lpVtbl -> GetSequencePointCount(This,pRetVal)

#define ISymUnmanagedMethod_GetRootScope(This,pRetVal)	\
    (This)->lpVtbl -> GetRootScope(This,pRetVal)

#define ISymUnmanagedMethod_GetScopeFromOffset(This,offset,pRetVal)	\
    (This)->lpVtbl -> GetScopeFromOffset(This,offset,pRetVal)

#define ISymUnmanagedMethod_GetOffset(This,document,line,column,pRetVal)	\
    (This)->lpVtbl -> GetOffset(This,document,line,column,pRetVal)

#define ISymUnmanagedMethod_GetRanges(This,document,line,column,cRanges,pcRanges,ranges)	\
    (This)->lpVtbl -> GetRanges(This,document,line,column,cRanges,pcRanges,ranges)

#define ISymUnmanagedMethod_GetParameters(This,cParams,pcParams,params)	\
    (This)->lpVtbl -> GetParameters(This,cParams,pcParams,params)

#define ISymUnmanagedMethod_GetNamespace(This,pRetVal)	\
    (This)->lpVtbl -> GetNamespace(This,pRetVal)

#define ISymUnmanagedMethod_GetSourceStartEnd(This,docs,lines,columns,pRetVal)	\
    (This)->lpVtbl -> GetSourceStartEnd(This,docs,lines,columns,pRetVal)

#define ISymUnmanagedMethod_GetSequencePoints(This,cPoints,pcPoints,offsets,documents,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> GetSequencePoints(This,cPoints,pcPoints,offsets,documents,lines,columns,endLines,endColumns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetToken_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ mdMethodDef *pToken);


void __RPC_STUB ISymUnmanagedMethod_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSequencePointCount_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetSequencePointCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetRootScope_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetRootScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetScopeFromOffset_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 offset,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetScopeFromOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetOffset_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetRanges_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [in] */ ULONG32 cRanges,
    /* [out] */ ULONG32 *pcRanges,
    /* [length_is][size_is][out] */ ULONG32 ranges[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetParameters_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 cParams,
    /* [out] */ ULONG32 *pcParams,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetNamespace_Proxy( 
    ISymUnmanagedMethod * This,
    /* [out] */ ISymUnmanagedNamespace **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSourceStartEnd_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
    /* [in] */ ULONG32 lines[ 2 ],
    /* [in] */ ULONG32 columns[ 2 ],
    /* [out] */ BOOL *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetSourceStartEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSequencePoints_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 cPoints,
    /* [out] */ ULONG32 *pcPoints,
    /* [size_is][in] */ ULONG32 offsets[  ],
    /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
    /* [size_is][in] */ ULONG32 lines[  ],
    /* [size_is][in] */ ULONG32 columns[  ],
    /* [size_is][in] */ ULONG32 endLines[  ],
    /* [size_is][in] */ ULONG32 endColumns[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedMethod_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedNamespace_INTERFACE_DEFINED__
#define __ISymUnmanagedNamespace_INTERFACE_DEFINED__

/* interface ISymUnmanagedNamespace */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedNamespace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DFF7289-54F8-11d3-BD28-0000F80849BD")
    ISymUnmanagedNamespace : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariables( 
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedNamespaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedNamespace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedNamespace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariables )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        END_INTERFACE
    } ISymUnmanagedNamespaceVtbl;

    interface ISymUnmanagedNamespace
    {
        CONST_VTBL struct ISymUnmanagedNamespaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedNamespace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedNamespace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedNamespace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedNamespace_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ISymUnmanagedNamespace_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#define ISymUnmanagedNamespace_GetVariables(This,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetVariables(This,cVars,pcVars,pVars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetName_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetNamespaces_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetVariables_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedNamespace_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedReader_INTERFACE_DEFINED__
#define __ISymUnmanagedReader_INTERFACE_DEFINED__

/* interface ISymUnmanagedReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5")
    ISymUnmanagedReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [in] */ WCHAR *url,
            /* [in] */ GUID language,
            /* [in] */ GUID languageVendor,
            /* [in] */ GUID documentType,
            /* [retval][out] */ ISymUnmanagedDocument **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocuments( 
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserEntryPoint( 
            /* [retval][out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [in] */ mdMethodDef token,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodByVersion( 
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariables( 
            /* [in] */ mdToken parent,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalVariables( 
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodFromDocumentPosition( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymAttribute( 
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *filename,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateSymbolStore( 
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceSymbolStore( 
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolStoreFileName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodsFromDocumentPosition( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentVersion( 
            /* [in] */ ISymUnmanagedDocument *pDoc,
            /* [out] */ int *version,
            /* [out] */ BOOL *pbCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodVersion( 
            /* [in] */ ISymUnmanagedMethod *pMethod,
            /* [out] */ int *version) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            ISymUnmanagedReader * This,
            /* [in] */ WCHAR *url,
            /* [in] */ GUID language,
            /* [in] */ GUID languageVendor,
            /* [in] */ GUID documentType,
            /* [retval][out] */ ISymUnmanagedDocument **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocuments )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserEntryPoint )( 
            ISymUnmanagedReader * This,
            /* [retval][out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdMethodDef token,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodByVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariables )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdToken parent,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariables )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodFromDocumentPosition )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymAttribute )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedReader * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *filename,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSymbolStore )( 
            ISymUnmanagedReader * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceSymbolStore )( 
            ISymUnmanagedReader * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolStoreFileName )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodsFromDocumentPosition )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *pDoc,
            /* [out] */ int *version,
            /* [out] */ BOOL *pbCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedMethod *pMethod,
            /* [out] */ int *version);
        
        END_INTERFACE
    } ISymUnmanagedReaderVtbl;

    interface ISymUnmanagedReader
    {
        CONST_VTBL struct ISymUnmanagedReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedReader_GetDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> GetDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedReader_GetDocuments(This,cDocs,pcDocs,pDocs)	\
    (This)->lpVtbl -> GetDocuments(This,cDocs,pcDocs,pDocs)

#define ISymUnmanagedReader_GetUserEntryPoint(This,pToken)	\
    (This)->lpVtbl -> GetUserEntryPoint(This,pToken)

#define ISymUnmanagedReader_GetMethod(This,token,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,token,pRetVal)

#define ISymUnmanagedReader_GetMethodByVersion(This,token,version,pRetVal)	\
    (This)->lpVtbl -> GetMethodByVersion(This,token,version,pRetVal)

#define ISymUnmanagedReader_GetVariables(This,parent,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetVariables(This,parent,cVars,pcVars,pVars)

#define ISymUnmanagedReader_GetGlobalVariables(This,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetGlobalVariables(This,cVars,pcVars,pVars)

#define ISymUnmanagedReader_GetMethodFromDocumentPosition(This,document,line,column,pRetVal)	\
    (This)->lpVtbl -> GetMethodFromDocumentPosition(This,document,line,column,pRetVal)

#define ISymUnmanagedReader_GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)	\
    (This)->lpVtbl -> GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)

#define ISymUnmanagedReader_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#define ISymUnmanagedReader_Initialize(This,importer,filename,searchPath,pIStream)	\
    (This)->lpVtbl -> Initialize(This,importer,filename,searchPath,pIStream)

#define ISymUnmanagedReader_UpdateSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> UpdateSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader_ReplaceSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> ReplaceSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader_GetSymbolStoreFileName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetSymbolStoreFileName(This,cchName,pcchName,szName)

#define ISymUnmanagedReader_GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)	\
    (This)->lpVtbl -> GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)

#define ISymUnmanagedReader_GetDocumentVersion(This,pDoc,version,pbCurrent)	\
    (This)->lpVtbl -> GetDocumentVersion(This,pDoc,version,pbCurrent)

#define ISymUnmanagedReader_GetMethodVersion(This,pMethod,version)	\
    (This)->lpVtbl -> GetMethodVersion(This,pMethod,version)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocument_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ WCHAR *url,
    /* [in] */ GUID language,
    /* [in] */ GUID languageVendor,
    /* [in] */ GUID documentType,
    /* [retval][out] */ ISymUnmanagedDocument **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocuments_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cDocs,
    /* [out] */ ULONG32 *pcDocs,
    /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]);


void __RPC_STUB ISymUnmanagedReader_GetDocuments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetUserEntryPoint_Proxy( 
    ISymUnmanagedReader * This,
    /* [retval][out] */ mdMethodDef *pToken);


void __RPC_STUB ISymUnmanagedReader_GetUserEntryPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethod_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdMethodDef token,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodByVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdMethodDef token,
    /* [in] */ int version,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethodByVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetVariables_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdToken parent,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedReader_GetVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetGlobalVariables_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedReader_GetGlobalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodFromDocumentPosition_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethodFromDocumentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetSymAttribute_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdToken parent,
    /* [in] */ WCHAR *name,
    /* [in] */ ULONG32 cBuffer,
    /* [out] */ ULONG32 *pcBuffer,
    /* [length_is][size_is][out] */ BYTE buffer[  ]);


void __RPC_STUB ISymUnmanagedReader_GetSymAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetNamespaces_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedReader_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_Initialize_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *filename,
    /* [in] */ const WCHAR *searchPath,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_UpdateSymbolStore_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_UpdateSymbolStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_ReplaceSymbolStore_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_ReplaceSymbolStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetSymbolStoreFileName_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedReader_GetSymbolStoreFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodsFromDocumentPosition_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [in] */ ULONG32 cMethod,
    /* [out] */ ULONG32 *pcMethod,
    /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);


void __RPC_STUB ISymUnmanagedReader_GetMethodsFromDocumentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocumentVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *pDoc,
    /* [out] */ int *version,
    /* [out] */ BOOL *pbCurrent);


void __RPC_STUB ISymUnmanagedReader_GetDocumentVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedMethod *pMethod,
    /* [out] */ int *version);


void __RPC_STUB ISymUnmanagedReader_GetMethodVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedReader_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedScope_INTERFACE_DEFINED__
#define __ISymUnmanagedScope_INTERFACE_DEFINED__

/* interface ISymUnmanagedScope */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68005D0F-B8E0-3B01-84D5-A11A94154942")
    ISymUnmanagedScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [in] */ ULONG32 cChildren,
            /* [out] */ ULONG32 *pcChildren,
            /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocals( 
            /* [in] */ ULONG32 cLocals,
            /* [out] */ ULONG32 *pcLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedScope * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cChildren,
            /* [out] */ ULONG32 *pcChildren,
            /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOffset )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalCount )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocals )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cLocals,
            /* [out] */ ULONG32 *pcLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        END_INTERFACE
    } ISymUnmanagedScopeVtbl;

    interface ISymUnmanagedScope
    {
        CONST_VTBL struct ISymUnmanagedScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedScope_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedScope_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedScope_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedScope_GetMethod(This,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,pRetVal)

#define ISymUnmanagedScope_GetParent(This,pRetVal)	\
    (This)->lpVtbl -> GetParent(This,pRetVal)

#define ISymUnmanagedScope_GetChildren(This,cChildren,pcChildren,children)	\
    (This)->lpVtbl -> GetChildren(This,cChildren,pcChildren,children)

#define ISymUnmanagedScope_GetStartOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetStartOffset(This,pRetVal)

#define ISymUnmanagedScope_GetEndOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetEndOffset(This,pRetVal)

#define ISymUnmanagedScope_GetLocalCount(This,pRetVal)	\
    (This)->lpVtbl -> GetLocalCount(This,pRetVal)

#define ISymUnmanagedScope_GetLocals(This,cLocals,pcLocals,locals)	\
    (This)->lpVtbl -> GetLocals(This,cLocals,pcLocals,locals)

#define ISymUnmanagedScope_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetMethod_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetParent_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetChildren_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cChildren,
    /* [out] */ ULONG32 *pcChildren,
    /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]);


void __RPC_STUB ISymUnmanagedScope_GetChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetStartOffset_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetStartOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetEndOffset_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetEndOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetLocalCount_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetLocalCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetLocals_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cLocals,
    /* [out] */ ULONG32 *pcLocals,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]);


void __RPC_STUB ISymUnmanagedScope_GetLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetNamespaces_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedScope_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedScope_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedVariable_INTERFACE_DEFINED__
#define __ISymUnmanagedVariable_INTERFACE_DEFINED__

/* interface ISymUnmanagedVariable */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedVariable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB")
    ISymUnmanagedVariable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignature( 
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressKind( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField1( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField2( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField3( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedVariableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedVariable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedVariable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedVariable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISymUnmanagedVariable * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignature )( 
            ISymUnmanagedVariable * This,
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressKind )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField1 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField2 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField3 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOffset )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedVariableVtbl;

    interface ISymUnmanagedVariable
    {
        CONST_VTBL struct ISymUnmanagedVariableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedVariable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedVariable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedVariable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedVariable_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ISymUnmanagedVariable_GetAttributes(This,pRetVal)	\
    (This)->lpVtbl -> GetAttributes(This,pRetVal)

#define ISymUnmanagedVariable_GetSignature(This,cSig,pcSig,sig)	\
    (This)->lpVtbl -> GetSignature(This,cSig,pcSig,sig)

#define ISymUnmanagedVariable_GetAddressKind(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressKind(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField1(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField1(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField2(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField2(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField3(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField3(This,pRetVal)

#define ISymUnmanagedVariable_GetStartOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetStartOffset(This,pRetVal)

#define ISymUnmanagedVariable_GetEndOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetEndOffset(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetName_Proxy( 
    ISymUnmanagedVariable * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedVariable_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAttributes_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetSignature_Proxy( 
    ISymUnmanagedVariable * This,
    /* [in] */ ULONG32 cSig,
    /* [out] */ ULONG32 *pcSig,
    /* [length_is][size_is][out] */ BYTE sig[  ]);


void __RPC_STUB ISymUnmanagedVariable_GetSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressKind_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField1_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField2_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField3_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetStartOffset_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetStartOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetEndOffset_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetEndOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedVariable_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedWriter_INTERFACE_DEFINED__
#define __ISymUnmanagedWriter_INTERFACE_DEFINED__

/* interface ISymUnmanagedWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED14AA72-78E2-4884-84E2-334293AE5214")
    ISymUnmanagedWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DefineDocument( 
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserEntryPoint( 
            /* [in] */ mdMethodDef entryMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenMethod( 
            /* [in] */ mdMethodDef method) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseMethod( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenScope( 
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseScope( 
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScopeRange( 
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineLocalVariable( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineParameter( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineField( 
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineGlobalVariable( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSymAttribute( 
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const WCHAR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseNamespace( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UsingNamespace( 
            /* [in] */ const WCHAR *fullName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMethodSourceRange( 
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugInfo( 
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineSequencePoints( 
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemapToken( 
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize2( 
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineConstant( 
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineDocument )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserEntryPoint )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdMethodDef entryMethod);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdMethodDef method);
        
        HRESULT ( STDMETHODCALLTYPE *CloseMethod )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CloseScope )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetScopeRange )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineParameter )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymAttribute )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name);
        
        HRESULT ( STDMETHODCALLTYPE *CloseNamespace )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *UsingNamespace )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *fullName);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodSourceRange )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedWriter * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugInfo )( 
            ISymUnmanagedWriter * This,
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSequencePoints )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemapToken )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            ISymUnmanagedWriter * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISymUnmanagedWriter * This);
        
        END_INTERFACE
    } ISymUnmanagedWriterVtbl;

    interface ISymUnmanagedWriter
    {
        CONST_VTBL struct ISymUnmanagedWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedWriter_DefineDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> DefineDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedWriter_SetUserEntryPoint(This,entryMethod)	\
    (This)->lpVtbl -> SetUserEntryPoint(This,entryMethod)

#define ISymUnmanagedWriter_OpenMethod(This,method)	\
    (This)->lpVtbl -> OpenMethod(This,method)

#define ISymUnmanagedWriter_CloseMethod(This)	\
    (This)->lpVtbl -> CloseMethod(This)

#define ISymUnmanagedWriter_OpenScope(This,startOffset,pRetVal)	\
    (This)->lpVtbl -> OpenScope(This,startOffset,pRetVal)

#define ISymUnmanagedWriter_CloseScope(This,endOffset)	\
    (This)->lpVtbl -> CloseScope(This,endOffset)

#define ISymUnmanagedWriter_SetScopeRange(This,scopeID,startOffset,endOffset)	\
    (This)->lpVtbl -> SetScopeRange(This,scopeID,startOffset,endOffset)

#define ISymUnmanagedWriter_DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter_DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ISymUnmanagedWriter_SetSymAttribute(This,parent,name,cData,data)	\
    (This)->lpVtbl -> SetSymAttribute(This,parent,name,cData,data)

#define ISymUnmanagedWriter_OpenNamespace(This,name)	\
    (This)->lpVtbl -> OpenNamespace(This,name)

#define ISymUnmanagedWriter_CloseNamespace(This)	\
    (This)->lpVtbl -> CloseNamespace(This)

#define ISymUnmanagedWriter_UsingNamespace(This,fullName)	\
    (This)->lpVtbl -> UsingNamespace(This,fullName)

#define ISymUnmanagedWriter_SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)	\
    (This)->lpVtbl -> SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)

#define ISymUnmanagedWriter_Initialize(This,emitter,filename,pIStream,fFullBuild)	\
    (This)->lpVtbl -> Initialize(This,emitter,filename,pIStream,fFullBuild)

#define ISymUnmanagedWriter_GetDebugInfo(This,pIDD,cData,pcData,data)	\
    (This)->lpVtbl -> GetDebugInfo(This,pIDD,cData,pcData,data)

#define ISymUnmanagedWriter_DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)

#define ISymUnmanagedWriter_RemapToken(This,oldToken,newToken)	\
    (This)->lpVtbl -> RemapToken(This,oldToken,newToken)

#define ISymUnmanagedWriter_Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)	\
    (This)->lpVtbl -> Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)

#define ISymUnmanagedWriter_DefineConstant(This,name,value,cSig,signature)	\
    (This)->lpVtbl -> DefineConstant(This,name,value,cSig,signature)

#define ISymUnmanagedWriter_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineDocument_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *url,
    /* [in] */ const GUID *language,
    /* [in] */ const GUID *languageVendor,
    /* [in] */ const GUID *documentType,
    /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);


void __RPC_STUB ISymUnmanagedWriter_DefineDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetUserEntryPoint_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdMethodDef entryMethod);


void __RPC_STUB ISymUnmanagedWriter_SetUserEntryPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenMethod_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdMethodDef method);


void __RPC_STUB ISymUnmanagedWriter_OpenMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseMethod_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_CloseMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenScope_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 startOffset,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedWriter_OpenScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseScope_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_CloseScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetScopeRange_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 scopeID,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_SetScopeRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineLocalVariable_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_DefineLocalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineParameter_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 sequence,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineField_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdTypeDef parent,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineGlobalVariable_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineGlobalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Close_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetSymAttribute_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdToken parent,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 cData,
    /* [size_is][in] */ unsigned char data[  ]);


void __RPC_STUB ISymUnmanagedWriter_SetSymAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenNamespace_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name);


void __RPC_STUB ISymUnmanagedWriter_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseNamespace_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_CloseNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_UsingNamespace_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *fullName);


void __RPC_STUB ISymUnmanagedWriter_UsingNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetMethodSourceRange_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
    /* [in] */ ULONG32 startLine,
    /* [in] */ ULONG32 startColumn,
    /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
    /* [in] */ ULONG32 endLine,
    /* [in] */ ULONG32 endColumn);


void __RPC_STUB ISymUnmanagedWriter_SetMethodSourceRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Initialize_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ IUnknown *emitter,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream,
    /* [in] */ BOOL fFullBuild);


void __RPC_STUB ISymUnmanagedWriter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_GetDebugInfo_Proxy( 
    ISymUnmanagedWriter * This,
    /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
    /* [in] */ DWORD cData,
    /* [out] */ DWORD *pcData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB ISymUnmanagedWriter_GetDebugInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineSequencePoints_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ISymUnmanagedDocumentWriter *document,
    /* [in] */ ULONG32 spCount,
    /* [size_is][in] */ ULONG32 offsets[  ],
    /* [size_is][in] */ ULONG32 lines[  ],
    /* [size_is][in] */ ULONG32 columns[  ],
    /* [size_is][in] */ ULONG32 endLines[  ],
    /* [size_is][in] */ ULONG32 endColumns[  ]);


void __RPC_STUB ISymUnmanagedWriter_DefineSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_RemapToken_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdToken oldToken,
    /* [in] */ mdToken newToken);


void __RPC_STUB ISymUnmanagedWriter_RemapToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Initialize2_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ IUnknown *emitter,
    /* [in] */ const WCHAR *tempfilename,
    /* [in] */ IStream *pIStream,
    /* [in] */ BOOL fFullBuild,
    /* [in] */ const WCHAR *finalfilename);


void __RPC_STUB ISymUnmanagedWriter_Initialize2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineConstant_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ VARIANT value,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ]);


void __RPC_STUB ISymUnmanagedWriter_DefineConstant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Abort_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedWriter_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedWriter2_INTERFACE_DEFINED__
#define __ISymUnmanagedWriter2_INTERFACE_DEFINED__

/* interface ISymUnmanagedWriter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedWriter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B97726E-9E6D-4f05-9A26-424022093CAA")
    ISymUnmanagedWriter2 : public ISymUnmanagedWriter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DefineLocalVariable2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineGlobalVariable2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineConstant2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ mdSignature sigToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedWriter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedWriter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineDocument )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserEntryPoint )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdMethodDef entryMethod);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdMethodDef method);
        
        HRESULT ( STDMETHODCALLTYPE *CloseMethod )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CloseScope )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetScopeRange )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineParameter )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymAttribute )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name);
        
        HRESULT ( STDMETHODCALLTYPE *CloseNamespace )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UsingNamespace )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *fullName);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodSourceRange )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugInfo )( 
            ISymUnmanagedWriter2 * This,
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSequencePoints )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemapToken )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ mdSignature sigToken);
        
        END_INTERFACE
    } ISymUnmanagedWriter2Vtbl;

    interface ISymUnmanagedWriter2
    {
        CONST_VTBL struct ISymUnmanagedWriter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedWriter2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedWriter2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedWriter2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedWriter2_DefineDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> DefineDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedWriter2_SetUserEntryPoint(This,entryMethod)	\
    (This)->lpVtbl -> SetUserEntryPoint(This,entryMethod)

#define ISymUnmanagedWriter2_OpenMethod(This,method)	\
    (This)->lpVtbl -> OpenMethod(This,method)

#define ISymUnmanagedWriter2_CloseMethod(This)	\
    (This)->lpVtbl -> CloseMethod(This)

#define ISymUnmanagedWriter2_OpenScope(This,startOffset,pRetVal)	\
    (This)->lpVtbl -> OpenScope(This,startOffset,pRetVal)

#define ISymUnmanagedWriter2_CloseScope(This,endOffset)	\
    (This)->lpVtbl -> CloseScope(This,endOffset)

#define ISymUnmanagedWriter2_SetScopeRange(This,scopeID,startOffset,endOffset)	\
    (This)->lpVtbl -> SetScopeRange(This,scopeID,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ISymUnmanagedWriter2_SetSymAttribute(This,parent,name,cData,data)	\
    (This)->lpVtbl -> SetSymAttribute(This,parent,name,cData,data)

#define ISymUnmanagedWriter2_OpenNamespace(This,name)	\
    (This)->lpVtbl -> OpenNamespace(This,name)

#define ISymUnmanagedWriter2_CloseNamespace(This)	\
    (This)->lpVtbl -> CloseNamespace(This)

#define ISymUnmanagedWriter2_UsingNamespace(This,fullName)	\
    (This)->lpVtbl -> UsingNamespace(This,fullName)

#define ISymUnmanagedWriter2_SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)	\
    (This)->lpVtbl -> SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)

#define ISymUnmanagedWriter2_Initialize(This,emitter,filename,pIStream,fFullBuild)	\
    (This)->lpVtbl -> Initialize(This,emitter,filename,pIStream,fFullBuild)

#define ISymUnmanagedWriter2_GetDebugInfo(This,pIDD,cData,pcData,data)	\
    (This)->lpVtbl -> GetDebugInfo(This,pIDD,cData,pcData,data)

#define ISymUnmanagedWriter2_DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)

#define ISymUnmanagedWriter2_RemapToken(This,oldToken,newToken)	\
    (This)->lpVtbl -> RemapToken(This,oldToken,newToken)

#define ISymUnmanagedWriter2_Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)	\
    (This)->lpVtbl -> Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)

#define ISymUnmanagedWriter2_DefineConstant(This,name,value,cSig,signature)	\
    (This)->lpVtbl -> DefineConstant(This,name,value,cSig,signature)

#define ISymUnmanagedWriter2_Abort(This)	\
    (This)->lpVtbl -> Abort(This)


#define ISymUnmanagedWriter2_DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineConstant2(This,name,value,sigToken)	\
    (This)->lpVtbl -> DefineConstant2(This,name,value,sigToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineLocalVariable2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ mdSignature sigToken,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter2_DefineLocalVariable2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineGlobalVariable2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ mdSignature sigToken,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter2_DefineGlobalVariable2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineConstant2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ VARIANT value,
    /* [in] */ mdSignature sigToken);


void __RPC_STUB ISymUnmanagedWriter2_DefineConstant2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedWriter2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsym_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:09 2003
 */
/* Compiler settings for corsym.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_CorSymLib,0x7E348441,0x7E1F,0x380E,0xA0,0xF6,0x22,0x66,0x8F,0x0F,0x9E,0x4B);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymWriter,0x108296C1,0x281E,0x11d3,0xBD,0x22,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymReader,0x108296C2,0x281E,0x11d3,0xBD,0x22,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymBinder,0xAA544D41,0x28CB,0x11d3,0xBD,0x22,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymWriter_SxS,0x0AE2DEB0,0xF901,0x478b,0xBB,0x9F,0x88,0x1E,0xE8,0x06,0x67,0x88);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymReader_SxS,0x0A3976C5,0x4529,0x4ef8,0xB0,0xB0,0x42,0xEE,0xD3,0x70,0x82,0xCD);


MIDL_DEFINE_GUID(CLSID, CLSID_CorSymBinder_SxS,0x0A29FF9E,0x7F9C,0x4437,0x8B,0x11,0xF4,0x24,0x49,0x1E,0x39,0x31);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedBinder,0xAA544D42,0x28CB,0x11d3,0xBD,0x22,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedBinder2,0xACCEE350,0x89AF,0x4ccb,0x8B,0x40,0x1C,0x2C,0x4C,0x6F,0x94,0x34);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedDispose,0x969708D2,0x05E5,0x4861,0xA3,0xB0,0x96,0xE4,0x73,0xCD,0xF6,0x3F);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedDocument,0x40DE4037,0x7C81,0x3E1E,0xB0,0x22,0xAE,0x1A,0xBF,0xF2,0xCA,0x08);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedDocumentWriter,0xB01FAFEB,0xC450,0x3A4D,0xBE,0xEC,0xB4,0xCE,0xEC,0x01,0xE0,0x06);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedMethod,0xB62B923C,0xB500,0x3158,0xA5,0x43,0x24,0xF3,0x07,0xA8,0xB7,0xE1);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedNamespace,0x0DFF7289,0x54F8,0x11d3,0xBD,0x28,0x00,0x00,0xF8,0x08,0x49,0xBD);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedReader,0xB4CE6286,0x2A6B,0x3712,0xA3,0xB7,0x1E,0xE1,0xDA,0xD4,0x67,0xB5);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedScope,0x68005D0F,0xB8E0,0x3B01,0x84,0xD5,0xA1,0x1A,0x94,0x15,0x49,0x42);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedVariable,0x9F60EEBE,0x2D9A,0x3F7C,0xBF,0x58,0x80,0xBC,0x99,0x1C,0x60,0xBB);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedWriter,0xED14AA72,0x78E2,0x4884,0x84,0xE2,0x33,0x42,0x93,0xAE,0x52,0x14);


MIDL_DEFINE_GUID(IID, IID_ISymUnmanagedWriter2,0x0B97726E,0x9E6D,0x4f05,0x9A,0x26,0x42,0x40,0x22,0x09,0x3C,0xAA);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cortpoolhdr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+------------------------------------------------------------------------
//
//  Declare DLL entry points for Cor API to threadpool
//
//-------------------------------------------------------------------------

#ifdef EXPORTING_THREADPOOL_API
#define DllExportOrImport extern "C" __declspec (dllexport)
#else
#define DllExportOrImport extern "C" 
#endif

typedef VOID (__stdcall *WAITORTIMERCALLBACK)(PVOID, BOOL); 

DllExportOrImport  BOOL __cdecl CorRegisterWaitForSingleObject(PHANDLE phNewWaitObject,
                                                      HANDLE hWaitObject,
                                                      WAITORTIMERCALLBACK Callback,
                                                      PVOID Context,
                                                      ULONG timeout,
                                                      BOOL  executeOnlyOnce );



DllExportOrImport BOOL __cdecl CorUnregisterWait(HANDLE hWaitObject,HANDLE CompletionEvent);

DllExportOrImport BOOL __cdecl CorQueueUserWorkItem(LPTHREAD_START_ROUTINE Function,
                                          PVOID Context,
                                          BOOL executeOnlyOnce );


DllExportOrImport BOOL __cdecl CorCreateTimer(PHANDLE phNewTimer,
                                     WAITORTIMERCALLBACK Callback,
                                     PVOID Parameter,
                                     DWORD DueTime,
                                     DWORD Period);

DllExportOrImport BOOL __cdecl CorChangeTimer(HANDLE Timer,
                                              ULONG DueTime,
                                              ULONG Period);

DllExportOrImport BOOL __cdecl CorDeleteTimer(HANDLE Timer,
                                              HANDLE CompletionEvent);

DllExportOrImport  VOID __cdecl CorBindIoCompletionCallback(HANDLE fileHandle, LPOVERLAPPED_COMPLETION_ROUTINE callback); 


DllExportOrImport  VOID __cdecl CorDoDelegateInvocation(int cookie);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corzap.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corzap.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corzap_h__
#define __corzap_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorZapPreferences_FWD_DEFINED__
#define __ICorZapPreferences_FWD_DEFINED__
typedef interface ICorZapPreferences ICorZapPreferences;
#endif 	/* __ICorZapPreferences_FWD_DEFINED__ */


#ifndef __ICorZapConfiguration_FWD_DEFINED__
#define __ICorZapConfiguration_FWD_DEFINED__
typedef interface ICorZapConfiguration ICorZapConfiguration;
#endif 	/* __ICorZapConfiguration_FWD_DEFINED__ */


#ifndef __ICorZapBinding_FWD_DEFINED__
#define __ICorZapBinding_FWD_DEFINED__
typedef interface ICorZapBinding ICorZapBinding;
#endif 	/* __ICorZapBinding_FWD_DEFINED__ */


#ifndef __ICorZapRequest_FWD_DEFINED__
#define __ICorZapRequest_FWD_DEFINED__
typedef interface ICorZapRequest ICorZapRequest;
#endif 	/* __ICorZapRequest_FWD_DEFINED__ */


#ifndef __ICorZapCompile_FWD_DEFINED__
#define __ICorZapCompile_FWD_DEFINED__
typedef interface ICorZapCompile ICorZapCompile;
#endif 	/* __ICorZapCompile_FWD_DEFINED__ */


#ifndef __ICorZapStatus_FWD_DEFINED__
#define __ICorZapStatus_FWD_DEFINED__
typedef interface ICorZapStatus ICorZapStatus;
#endif 	/* __ICorZapStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "fusion.h"
#include "fusionpriv.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corzap_0000 */
/* [local] */ 






typedef 
enum CorZapFeatures
    {	CORZAP_FEATURE_PRELOAD_CLASSES	= 0x1,
	CORZAP_FEATURE_PREJIT_CODE	= 0x2
    } 	CorZapFeatures;

typedef 
enum CorZapOptimization
    {	CORZAP_OPTIMIZATION_SPACE	= 0,
	CORZAP_OPTIMIZATION_SPEED	= CORZAP_OPTIMIZATION_SPACE + 1,
	CORZAP_OPTIMIZATION_BLENDED	= CORZAP_OPTIMIZATION_SPEED + 1
    } 	CorZapOptimization;



extern RPC_IF_HANDLE __MIDL_itf_corzap_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corzap_0000_v0_0_s_ifspec;

#ifndef __ICorZapPreferences_INTERFACE_DEFINED__
#define __ICorZapPreferences_INTERFACE_DEFINED__

/* interface ICorZapPreferences */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapPreferences;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F5E5E10-ABEF-4200-84E3-37DF505BF7EC")
    ICorZapPreferences : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFeatures( 
            /* [retval][out] */ CorZapFeatures *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompiler( 
            /* [retval][out] */ ICorZapCompile **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptimization( 
            /* [retval][out] */ CorZapOptimization *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapPreferencesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapPreferences * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapPreferences * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapPreferences * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFeatures )( 
            ICorZapPreferences * This,
            /* [retval][out] */ CorZapFeatures *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompiler )( 
            ICorZapPreferences * This,
            /* [retval][out] */ ICorZapCompile **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptimization )( 
            ICorZapPreferences * This,
            /* [retval][out] */ CorZapOptimization *pResult);
        
        END_INTERFACE
    } ICorZapPreferencesVtbl;

    interface ICorZapPreferences
    {
        CONST_VTBL struct ICorZapPreferencesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapPreferences_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapPreferences_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapPreferences_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapPreferences_GetFeatures(This,pResult)	\
    (This)->lpVtbl -> GetFeatures(This,pResult)

#define ICorZapPreferences_GetCompiler(This,ppResult)	\
    (This)->lpVtbl -> GetCompiler(This,ppResult)

#define ICorZapPreferences_GetOptimization(This,pResult)	\
    (This)->lpVtbl -> GetOptimization(This,pResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapPreferences_GetFeatures_Proxy( 
    ICorZapPreferences * This,
    /* [retval][out] */ CorZapFeatures *pResult);


void __RPC_STUB ICorZapPreferences_GetFeatures_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapPreferences_GetCompiler_Proxy( 
    ICorZapPreferences * This,
    /* [retval][out] */ ICorZapCompile **ppResult);


void __RPC_STUB ICorZapPreferences_GetCompiler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapPreferences_GetOptimization_Proxy( 
    ICorZapPreferences * This,
    /* [retval][out] */ CorZapOptimization *pResult);


void __RPC_STUB ICorZapPreferences_GetOptimization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapPreferences_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corzap_0160 */
/* [local] */ 

typedef 
enum CorZapDebugging
    {	CORZAP_DEBUGGING_FULL	= 0,
	CORZAP_DEBUGGING_OPTIMIZED	= CORZAP_DEBUGGING_FULL + 1,
	CORZAP_DEBUGGING_NONE	= CORZAP_DEBUGGING_OPTIMIZED + 1
    } 	CorZapDebugging;

typedef 
enum CorZapProfiling
    {	CORZAP_PROFILING_ENABLED	= 0,
	CORZAP_PROFILING_DISABLED	= CORZAP_PROFILING_ENABLED + 1
    } 	CorZapProfiling;

typedef 
enum CorZapSharing
    {	CORZAP_SHARING_MULTIPLE	= 0,
	CORZAP_SHARING_SINGLE	= CORZAP_SHARING_MULTIPLE + 1
    } 	CorZapSharing;



extern RPC_IF_HANDLE __MIDL_itf_corzap_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corzap_0160_v0_0_s_ifspec;

#ifndef __ICorZapConfiguration_INTERFACE_DEFINED__
#define __ICorZapConfiguration_INTERFACE_DEFINED__

/* interface ICorZapConfiguration */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D32C2170-AF6E-418f-8110-A498EC971F7F")
    ICorZapConfiguration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSharing( 
            /* [retval][out] */ CorZapSharing *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugging( 
            /* [retval][out] */ CorZapDebugging *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProfiling( 
            /* [retval][out] */ CorZapProfiling *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapConfiguration * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharing )( 
            ICorZapConfiguration * This,
            /* [retval][out] */ CorZapSharing *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugging )( 
            ICorZapConfiguration * This,
            /* [retval][out] */ CorZapDebugging *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfiling )( 
            ICorZapConfiguration * This,
            /* [retval][out] */ CorZapProfiling *pResult);
        
        END_INTERFACE
    } ICorZapConfigurationVtbl;

    interface ICorZapConfiguration
    {
        CONST_VTBL struct ICorZapConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapConfiguration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapConfiguration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapConfiguration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapConfiguration_GetSharing(This,pResult)	\
    (This)->lpVtbl -> GetSharing(This,pResult)

#define ICorZapConfiguration_GetDebugging(This,pResult)	\
    (This)->lpVtbl -> GetDebugging(This,pResult)

#define ICorZapConfiguration_GetProfiling(This,pResult)	\
    (This)->lpVtbl -> GetProfiling(This,pResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapConfiguration_GetSharing_Proxy( 
    ICorZapConfiguration * This,
    /* [retval][out] */ CorZapSharing *pResult);


void __RPC_STUB ICorZapConfiguration_GetSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapConfiguration_GetDebugging_Proxy( 
    ICorZapConfiguration * This,
    /* [retval][out] */ CorZapDebugging *pResult);


void __RPC_STUB ICorZapConfiguration_GetDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapConfiguration_GetProfiling_Proxy( 
    ICorZapConfiguration * This,
    /* [retval][out] */ CorZapProfiling *pResult);


void __RPC_STUB ICorZapConfiguration_GetProfiling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapConfiguration_INTERFACE_DEFINED__ */


#ifndef __ICorZapBinding_INTERFACE_DEFINED__
#define __ICorZapBinding_INTERFACE_DEFINED__

/* interface ICorZapBinding */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("566E08ED-8D46-45fa-8C8E-3D0F6781171B")
    ICorZapBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRef( 
            /* [out] */ IAssemblyName **ppDependencyRef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssembly( 
            /* [out] */ IAssemblyName **ppDependencyAssembly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRef )( 
            ICorZapBinding * This,
            /* [out] */ IAssemblyName **ppDependencyRef);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssembly )( 
            ICorZapBinding * This,
            /* [out] */ IAssemblyName **ppDependencyAssembly);
        
        END_INTERFACE
    } ICorZapBindingVtbl;

    interface ICorZapBinding
    {
        CONST_VTBL struct ICorZapBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapBinding_GetRef(This,ppDependencyRef)	\
    (This)->lpVtbl -> GetRef(This,ppDependencyRef)

#define ICorZapBinding_GetAssembly(This,ppDependencyAssembly)	\
    (This)->lpVtbl -> GetAssembly(This,ppDependencyAssembly)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapBinding_GetRef_Proxy( 
    ICorZapBinding * This,
    /* [out] */ IAssemblyName **ppDependencyRef);


void __RPC_STUB ICorZapBinding_GetRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapBinding_GetAssembly_Proxy( 
    ICorZapBinding * This,
    /* [out] */ IAssemblyName **ppDependencyAssembly);


void __RPC_STUB ICorZapBinding_GetAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapBinding_INTERFACE_DEFINED__ */


#ifndef __ICorZapRequest_INTERFACE_DEFINED__
#define __ICorZapRequest_INTERFACE_DEFINED__

/* interface ICorZapRequest */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C009EE47-8537-4993-9AAA-E292F42CA1A3")
    ICorZapRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [size_is][in] */ ICorZapBinding **ppBindings,
            /* [in] */ DWORD cBindings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Install( 
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [in] */ ICorZapPreferences *pPreferences) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            ICorZapRequest * This,
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [size_is][in] */ ICorZapBinding **ppBindings,
            /* [in] */ DWORD cBindings);
        
        HRESULT ( STDMETHODCALLTYPE *Install )( 
            ICorZapRequest * This,
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [in] */ ICorZapPreferences *pPreferences);
        
        END_INTERFACE
    } ICorZapRequestVtbl;

    interface ICorZapRequest
    {
        CONST_VTBL struct ICorZapRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapRequest_Load(This,pContext,pAssembly,pConfiguration,ppBindings,cBindings)	\
    (This)->lpVtbl -> Load(This,pContext,pAssembly,pConfiguration,ppBindings,cBindings)

#define ICorZapRequest_Install(This,pContext,pAssembly,pConfiguration,pPreferences)	\
    (This)->lpVtbl -> Install(This,pContext,pAssembly,pConfiguration,pPreferences)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapRequest_Load_Proxy( 
    ICorZapRequest * This,
    /* [in] */ IApplicationContext *pContext,
    /* [in] */ IAssemblyName *pAssembly,
    /* [in] */ ICorZapConfiguration *pConfiguration,
    /* [size_is][in] */ ICorZapBinding **ppBindings,
    /* [in] */ DWORD cBindings);


void __RPC_STUB ICorZapRequest_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapRequest_Install_Proxy( 
    ICorZapRequest * This,
    /* [in] */ IApplicationContext *pContext,
    /* [in] */ IAssemblyName *pAssembly,
    /* [in] */ ICorZapConfiguration *pConfiguration,
    /* [in] */ ICorZapPreferences *pPreferences);


void __RPC_STUB ICorZapRequest_Install_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapRequest_INTERFACE_DEFINED__ */


#ifndef __ICorZapCompile_INTERFACE_DEFINED__
#define __ICorZapCompile_INTERFACE_DEFINED__

/* interface ICorZapCompile */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapCompile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C357868B-987F-42c6-B1E3-132164C5C7D3")
    ICorZapCompile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [in] */ ICorZapPreferences *pPreferences,
            /* [in] */ ICorZapStatus *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBound( 
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguratino,
            /* [size_is][in] */ ICorZapBinding **ppBindings,
            /* [in] */ DWORD cBindings,
            /* [in] */ ICorZapPreferences *pPreferences,
            /* [in] */ ICorZapStatus *pStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapCompileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapCompile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapCompile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapCompile * This);
        
        HRESULT ( STDMETHODCALLTYPE *Compile )( 
            ICorZapCompile * This,
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguration,
            /* [in] */ ICorZapPreferences *pPreferences,
            /* [in] */ ICorZapStatus *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *CompileBound )( 
            ICorZapCompile * This,
            /* [in] */ IApplicationContext *pContext,
            /* [in] */ IAssemblyName *pAssembly,
            /* [in] */ ICorZapConfiguration *pConfiguratino,
            /* [size_is][in] */ ICorZapBinding **ppBindings,
            /* [in] */ DWORD cBindings,
            /* [in] */ ICorZapPreferences *pPreferences,
            /* [in] */ ICorZapStatus *pStatus);
        
        END_INTERFACE
    } ICorZapCompileVtbl;

    interface ICorZapCompile
    {
        CONST_VTBL struct ICorZapCompileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapCompile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapCompile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapCompile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapCompile_Compile(This,pContext,pAssembly,pConfiguration,pPreferences,pStatus)	\
    (This)->lpVtbl -> Compile(This,pContext,pAssembly,pConfiguration,pPreferences,pStatus)

#define ICorZapCompile_CompileBound(This,pContext,pAssembly,pConfiguratino,ppBindings,cBindings,pPreferences,pStatus)	\
    (This)->lpVtbl -> CompileBound(This,pContext,pAssembly,pConfiguratino,ppBindings,cBindings,pPreferences,pStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapCompile_Compile_Proxy( 
    ICorZapCompile * This,
    /* [in] */ IApplicationContext *pContext,
    /* [in] */ IAssemblyName *pAssembly,
    /* [in] */ ICorZapConfiguration *pConfiguration,
    /* [in] */ ICorZapPreferences *pPreferences,
    /* [in] */ ICorZapStatus *pStatus);


void __RPC_STUB ICorZapCompile_Compile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapCompile_CompileBound_Proxy( 
    ICorZapCompile * This,
    /* [in] */ IApplicationContext *pContext,
    /* [in] */ IAssemblyName *pAssembly,
    /* [in] */ ICorZapConfiguration *pConfiguratino,
    /* [size_is][in] */ ICorZapBinding **ppBindings,
    /* [in] */ DWORD cBindings,
    /* [in] */ ICorZapPreferences *pPreferences,
    /* [in] */ ICorZapStatus *pStatus);


void __RPC_STUB ICorZapCompile_CompileBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapCompile_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corzap_0164 */
/* [local] */ 

typedef 
enum CorZapLogLevel
    {	CORZAP_LOGLEVEL_ERROR	= 0,
	CORZAP_LOGLEVEL_WARNING	= CORZAP_LOGLEVEL_ERROR + 1,
	CORZAP_LOGLEVEL_SUCCESS	= CORZAP_LOGLEVEL_WARNING + 1,
	CORZAP_LOGLEVEL_INFO	= CORZAP_LOGLEVEL_SUCCESS + 1
    } 	CorZapLogLevel;



extern RPC_IF_HANDLE __MIDL_itf_corzap_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corzap_0164_v0_0_s_ifspec;

#ifndef __ICorZapStatus_INTERFACE_DEFINED__
#define __ICorZapStatus_INTERFACE_DEFINED__

/* interface ICorZapStatus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorZapStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f60-7538-11d3-8d5b-00104b35e7ef")
    ICorZapStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Message( 
            /* [in] */ CorZapLogLevel level,
            /* [in] */ LPCWSTR message) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Progress( 
            /* [in] */ int total,
            /* [in] */ int current) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorZapStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorZapStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorZapStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorZapStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *Message )( 
            ICorZapStatus * This,
            /* [in] */ CorZapLogLevel level,
            /* [in] */ LPCWSTR message);
        
        HRESULT ( STDMETHODCALLTYPE *Progress )( 
            ICorZapStatus * This,
            /* [in] */ int total,
            /* [in] */ int current);
        
        END_INTERFACE
    } ICorZapStatusVtbl;

    interface ICorZapStatus
    {
        CONST_VTBL struct ICorZapStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorZapStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorZapStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorZapStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorZapStatus_Message(This,level,message)	\
    (This)->lpVtbl -> Message(This,level,message)

#define ICorZapStatus_Progress(This,total,current)	\
    (This)->lpVtbl -> Progress(This,total,current)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorZapStatus_Message_Proxy( 
    ICorZapStatus * This,
    /* [in] */ CorZapLogLevel level,
    /* [in] */ LPCWSTR message);


void __RPC_STUB ICorZapStatus_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorZapStatus_Progress_Proxy( 
    ICorZapStatus * This,
    /* [in] */ int total,
    /* [in] */ int current);


void __RPC_STUB ICorZapStatus_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorZapStatus_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corzap_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corzap.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICorZapPreferences,0x9F5E5E10,0xABEF,0x4200,0x84,0xE3,0x37,0xDF,0x50,0x5B,0xF7,0xEC);


MIDL_DEFINE_GUID(IID, IID_ICorZapConfiguration,0xD32C2170,0xAF6E,0x418f,0x81,0x10,0xA4,0x98,0xEC,0x97,0x1F,0x7F);


MIDL_DEFINE_GUID(IID, IID_ICorZapBinding,0x566E08ED,0x8D46,0x45fa,0x8C,0x8E,0x3D,0x0F,0x67,0x81,0x17,0x1B);


MIDL_DEFINE_GUID(IID, IID_ICorZapRequest,0xC009EE47,0x8537,0x4993,0x9A,0xAA,0xE2,0x92,0xF4,0x2C,0xA1,0xA3);


MIDL_DEFINE_GUID(IID, IID_ICorZapCompile,0xC357868B,0x987F,0x42c6,0xB1,0xE3,0x13,0x21,0x64,0xC5,0xC7,0xD3);


MIDL_DEFINE_GUID(IID, IID_ICorZapStatus,0x3d6f5f60,0x7538,0x11d3,0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cortypeinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// This describes information about the COM+ primitive types

// TYPEINFO(enumName, 				className, 			size, 			gcType, 		isEnreg,isArray,isPrim, isFloat,isModifier, isAlias)
TYPEINFO(ELEMENT_TYPE_END,   		0,					-1,				TYPE_GC_NONE,	false,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_VOID,	 		"System.Void",		0, 		 		TYPE_GC_NONE,	false,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_BOOLEAN,   	"System.Boolean",	1, 		 		TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_CHAR,			"System.Char",		2, 		 		TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_I1,			"System.SByte",		1, 	 			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_U1,			"System.Byte",		1,  			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_I2,			"System.Int16",		2,  			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_U2,			"System.UInt16",	2,  			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_I4,			"System.Int32",		4,  			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_U4,			"System.UInt32",	4,  			TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_I8,			"System.Int64",		8,  			TYPE_GC_NONE,	false,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_U8,			"System.UInt64",	8,  			TYPE_GC_NONE,	false,	false,	true,	false,	false,  false)

TYPEINFO(ELEMENT_TYPE_R4,			"System.Single",	4,  			TYPE_GC_NONE,	false,	false,	true,	true,	false,  false)
TYPEINFO(ELEMENT_TYPE_R8,			"System.Double",	8,  			TYPE_GC_NONE,	false,	false,	true,	true,	false,  false)

TYPEINFO(ELEMENT_TYPE_STRING,		"System.String",	sizeof(void*),  TYPE_GC_REF,	true,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_PTR,			0,					sizeof(void*),  TYPE_GC_NONE,	true,	false,	false,	false,	true,  false)
TYPEINFO(ELEMENT_TYPE_BYREF,		0,					sizeof(void*),  TYPE_GC_BYREF,	true,	false,	false,	false,	true,  false)
TYPEINFO(ELEMENT_TYPE_VALUETYPE,	0,					-1,  			TYPE_GC_OTHER,	false,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_CLASS,		0,					sizeof(void*), 	TYPE_GC_REF,	true,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_VAR,			0,					sizeof(void*), 	TYPE_GC_REF,	true,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_ARRAY,		0,					sizeof(void*),  TYPE_GC_REF,	true,	true,	false,	false,	true,  false)

TYPEINFO((CorElementType) 0x15,/* unused placeholder*/0,-1,  			TYPE_GC_NONE,	false,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_TYPEDBYREF,	"System.TypedReference",2*sizeof(void*),TYPE_GC_BYREF,	false,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_VALUEARRAY,	0,					-1,  			TYPE_GC_NONE,	false,	false,	false,	false,	true,  false)

TYPEINFO(ELEMENT_TYPE_I,			"System.IntPtr",	sizeof(void*),  TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_U,			"System.UIntPtr",	sizeof(void*),  TYPE_GC_NONE,	true,	false,	true,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_R,			0,					8,  			TYPE_GC_NONE,	false,	false,	true,	true,	false,  false)

TYPEINFO(ELEMENT_TYPE_FNPTR,		0,					sizeof(void*),	TYPE_GC_NONE,	true,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_OBJECT,		"System.Object",	sizeof(void*), 	TYPE_GC_REF,	true,	false,	false,	false,	false,  false)
TYPEINFO(ELEMENT_TYPE_SZARRAY,		0,					sizeof(void*), 	TYPE_GC_REF,	true,	true,	false,	false,	true,  false)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cpimporteritf_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:15 2003
 */
/* Compiler settings for cpimporteritf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "cpimporteritf.h"

#define TYPE_FORMAT_STRING_SIZE   97                                
#define PROC_FORMAT_STRING_SIZE   137                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEventImporter_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEventImporter_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Initialize */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x6 ),	/* 6 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bVerbose */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RegisterSourceInterface */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter strBaseComponentName */

/* 44 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Parameter strTCEComponentName */

/* 50 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 52 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 54 */	NdrFcShort( 0x28 ),	/* Type Offset=40 */

	/* Parameter strInterfaceName */

/* 56 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 58 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 60 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */

	/* Return value */

/* 62 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 64 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceInterfaceCount */

/* 68 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 70 */	NdrFcLong( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x5 ),	/* 5 */
/* 76 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x24 ),	/* 36 */
/* 82 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter SourceCount */

/* 84 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 86 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 92 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Process */

/* 96 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x6 ),	/* 6 */
/* 104 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 106 */	NdrFcShort( 0x6 ),	/* 6 */
/* 108 */	NdrFcShort( 0x8 ),	/* 8 */
/* 110 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter strInputFile */

/* 112 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 114 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 116 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Parameter strOutputFile */

/* 118 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 120 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 122 */	NdrFcShort( 0x56 ),	/* Type Offset=86 */

	/* Parameter bMerge */

/* 124 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 126 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 128 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 132 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */
/* 36 */	
			0x12, 0x0,	/* FC_UP */
/* 38 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (16) */
/* 40 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 42 */	NdrFcShort( 0x0 ),	/* 0 */
/* 44 */	NdrFcShort( 0x4 ),	/* 4 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (36) */
/* 50 */	
			0x12, 0x0,	/* FC_UP */
/* 52 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (16) */
/* 54 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* 4 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (50) */
/* 64 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 66 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 68 */	
			0x12, 0x0,	/* FC_UP */
/* 70 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (16) */
/* 72 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x4 ),	/* 4 */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (68) */
/* 82 */	
			0x12, 0x0,	/* FC_UP */
/* 84 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (16) */
/* 86 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 88 */	NdrFcShort( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x4 ),	/* 4 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (82) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IEventImporter, ver. 0.0,
   GUID={0x84E045F0,0x0E22,0x11d3,{0x8B,0x9A,0x00,0x00,0xF8,0x08,0x3A,0x57}} */

#pragma code_seg(".orpc")
static const unsigned short IEventImporter_FormatStringOffsetTable[] =
    {
    0,
    28,
    68,
    96
    };

static const MIDL_STUBLESS_PROXY_INFO IEventImporter_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEventImporter_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEventImporter_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEventImporter_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IEventImporterProxyVtbl = 
{
    &IEventImporter_ProxyInfo,
    &IID_IEventImporter,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEventImporter::Initialize */ ,
    (void *) (INT_PTR) -1 /* IEventImporter::RegisterSourceInterface */ ,
    (void *) (INT_PTR) -1 /* IEventImporter::GetSourceInterfaceCount */ ,
    (void *) (INT_PTR) -1 /* IEventImporter::Process */
};

const CInterfaceStubVtbl _IEventImporterStubVtbl =
{
    &IID_IEventImporter,
    &IEventImporter_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _cpimporteritf_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IEventImporterProxyVtbl,
    0
};

const CInterfaceStubVtbl * _cpimporteritf_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IEventImporterStubVtbl,
    0
};

PCInterfaceName const _cpimporteritf_InterfaceNamesList[] = 
{
    "IEventImporter",
    0
};


#define _cpimporteritf_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _cpimporteritf, pIID, n)

int __stdcall _cpimporteritf_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_cpimporteritf_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo cpimporteritf_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _cpimporteritf_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _cpimporteritf_StubVtblList,
    (const PCInterfaceName * ) & _cpimporteritf_InterfaceNamesList,
    0, // no delegation
    & _cpimporteritf_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corzap_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:12 2003
 */
/* Compiler settings for corzap.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "corzap.h"

#define TYPE_FORMAT_STRING_SIZE   479                               
#define PROC_FORMAT_STRING_SIZE   507                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapPreferences_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapPreferences_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapConfiguration_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapConfiguration_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapBinding_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapBinding_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapRequest_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapRequest_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapCompile_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapCompile_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICorZapStatus_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICorZapStatus_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetFeatures */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x22 ),	/* 34 */
/* 14 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pResult */

/* 16 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCompiler */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppResult */

/* 44 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOptimization */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x22 ),	/* 34 */
/* 70 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pResult */

/* 72 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSharing */

/* 84 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x3 ),	/* 3 */
/* 92 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x22 ),	/* 34 */
/* 98 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pResult */

/* 100 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 102 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 104 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugging */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 120 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 124 */	NdrFcShort( 0x22 ),	/* 34 */
/* 126 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pResult */

/* 128 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 130 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 132 */	NdrFcShort( 0x24 ),	/* Type Offset=36 */

	/* Return value */

/* 134 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 136 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 138 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProfiling */

/* 140 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x5 ),	/* 5 */
/* 148 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x22 ),	/* 34 */
/* 154 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pResult */

/* 156 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 160 */	NdrFcShort( 0x28 ),	/* Type Offset=40 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRef */

/* 168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDependencyRef */

/* 184 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 186 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 188 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 190 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 192 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAssembly */

/* 196 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 198 */	NdrFcLong( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x4 ),	/* 4 */
/* 204 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDependencyAssembly */

/* 212 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 214 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 216 */	NdrFcShort( 0x42 ),	/* Type Offset=66 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 220 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Load */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x3 ),	/* 3 */
/* 232 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pContext */

/* 240 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 242 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 244 */	NdrFcShort( 0x58 ),	/* Type Offset=88 */

	/* Parameter pAssembly */

/* 246 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 248 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 250 */	NdrFcShort( 0x6a ),	/* Type Offset=106 */

	/* Parameter pConfiguration */

/* 252 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 254 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 256 */	NdrFcShort( 0x7c ),	/* Type Offset=124 */

	/* Parameter ppBindings */

/* 258 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 260 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 262 */	NdrFcShort( 0xa4 ),	/* Type Offset=164 */

	/* Parameter cBindings */

/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 266 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 272 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Install */

/* 276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x4 ),	/* 4 */
/* 284 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 290 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pContext */

/* 292 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 296 */	NdrFcShort( 0xb6 ),	/* Type Offset=182 */

	/* Parameter pAssembly */

/* 298 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 302 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */

	/* Parameter pConfiguration */

/* 304 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 308 */	NdrFcShort( 0xda ),	/* Type Offset=218 */

	/* Parameter pPreferences */

/* 310 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 312 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 314 */	NdrFcShort( 0xec ),	/* Type Offset=236 */

	/* Return value */

/* 316 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 318 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Compile */

/* 322 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 324 */	NdrFcLong( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x3 ),	/* 3 */
/* 330 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 336 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pContext */

/* 338 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 340 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 342 */	NdrFcShort( 0xfe ),	/* Type Offset=254 */

	/* Parameter pAssembly */

/* 344 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 346 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 348 */	NdrFcShort( 0x110 ),	/* Type Offset=272 */

	/* Parameter pConfiguration */

/* 350 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 352 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 354 */	NdrFcShort( 0x122 ),	/* Type Offset=290 */

	/* Parameter pPreferences */

/* 356 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 358 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 360 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter pStatus */

/* 362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 364 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 366 */	NdrFcShort( 0x146 ),	/* Type Offset=326 */

	/* Return value */

/* 368 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 370 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CompileBound */

/* 374 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x4 ),	/* 4 */
/* 382 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 384 */	NdrFcShort( 0x8 ),	/* 8 */
/* 386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 388 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter pContext */

/* 390 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 394 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Parameter pAssembly */

/* 396 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 400 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pConfiguratino */

/* 402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 406 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Parameter ppBindings */

/* 408 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 410 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 412 */	NdrFcShort( 0x1a4 ),	/* Type Offset=420 */

	/* Parameter cBindings */

/* 414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 416 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pPreferences */

/* 420 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 422 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 424 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Parameter pStatus */

/* 426 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 428 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 430 */	NdrFcShort( 0x1c8 ),	/* Type Offset=456 */

	/* Return value */

/* 432 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 434 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Message */

/* 438 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 440 */	NdrFcLong( 0x0 ),	/* 0 */
/* 444 */	NdrFcShort( 0x3 ),	/* 3 */
/* 446 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 448 */	NdrFcShort( 0x6 ),	/* 6 */
/* 450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 452 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter level */

/* 454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 456 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 458 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter message */

/* 460 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 464 */	NdrFcShort( 0x1dc ),	/* Type Offset=476 */

	/* Return value */

/* 466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 468 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Progress */

/* 472 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 474 */	NdrFcLong( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x4 ),	/* 4 */
/* 480 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 482 */	NdrFcShort( 0x10 ),	/* 16 */
/* 484 */	NdrFcShort( 0x8 ),	/* 8 */
/* 486 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter total */

/* 488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter current */

/* 494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 500 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 502 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 504 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  4 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 12 */	NdrFcLong( 0xc357868b ),	/* -1017674101 */
/* 16 */	NdrFcShort( 0x987f ),	/* -26497 */
/* 18 */	NdrFcShort( 0x42c6 ),	/* 17094 */
/* 20 */	0xb1,		/* 177 */
			0xe3,		/* 227 */
/* 22 */	0x13,		/* 19 */
			0x21,		/* 33 */
/* 24 */	0x64,		/* 100 */
			0xc5,		/* 197 */
/* 26 */	0xc7,		/* 199 */
			0xd3,		/* 211 */
/* 28 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 30 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 34 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 36 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 38 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 40 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 42 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 44 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 46 */	NdrFcShort( 0x2 ),	/* Offset= 2 (48) */
/* 48 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 50 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 54 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 56 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 58 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 60 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 62 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 64 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 66 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 68 */	NdrFcShort( 0x2 ),	/* Offset= 2 (70) */
/* 70 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 72 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 76 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 78 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 80 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 82 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 84 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 86 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 88 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 90 */	NdrFcLong( 0x7c23ff90 ),	/* 2082733968 */
/* 94 */	NdrFcShort( 0x33af ),	/* 13231 */
/* 96 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 98 */	0x95,		/* 149 */
			0xda,		/* 218 */
/* 100 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 102 */	0x24,		/* 36 */
			0xa8,		/* 168 */
/* 104 */	0x5b,		/* 91 */
			0x51,		/* 81 */
/* 106 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 108 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 112 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 114 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 116 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 118 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 120 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 122 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 124 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 126 */	NdrFcLong( 0xd32c2170 ),	/* -752082576 */
/* 130 */	NdrFcShort( 0xaf6e ),	/* -20626 */
/* 132 */	NdrFcShort( 0x418f ),	/* 16783 */
/* 134 */	0x81,		/* 129 */
			0x10,		/* 16 */
/* 136 */	0xa4,		/* 164 */
			0x98,		/* 152 */
/* 138 */	0xec,		/* 236 */
			0x97,		/* 151 */
/* 140 */	0x1f,		/* 31 */
			0x7f,		/* 127 */
/* 142 */	
			0x11, 0x0,	/* FC_RP */
/* 144 */	NdrFcShort( 0x14 ),	/* Offset= 20 (164) */
/* 146 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 148 */	NdrFcLong( 0x566e08ed ),	/* 1450051821 */
/* 152 */	NdrFcShort( 0x8d46 ),	/* -29370 */
/* 154 */	NdrFcShort( 0x45fa ),	/* 17914 */
/* 156 */	0x8c,		/* 140 */
			0x8e,		/* 142 */
/* 158 */	0x3d,		/* 61 */
			0xf,		/* 15 */
/* 160 */	0x67,		/* 103 */
			0x81,		/* 129 */
/* 162 */	0x17,		/* 23 */
			0x1b,		/* 27 */
/* 164 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 170 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 172 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 176 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 178 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (146) */
/* 180 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 182 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 184 */	NdrFcLong( 0x7c23ff90 ),	/* 2082733968 */
/* 188 */	NdrFcShort( 0x33af ),	/* 13231 */
/* 190 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 192 */	0x95,		/* 149 */
			0xda,		/* 218 */
/* 194 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 196 */	0x24,		/* 36 */
			0xa8,		/* 168 */
/* 198 */	0x5b,		/* 91 */
			0x51,		/* 81 */
/* 200 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 202 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 206 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 208 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 210 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 212 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 214 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 216 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 218 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 220 */	NdrFcLong( 0xd32c2170 ),	/* -752082576 */
/* 224 */	NdrFcShort( 0xaf6e ),	/* -20626 */
/* 226 */	NdrFcShort( 0x418f ),	/* 16783 */
/* 228 */	0x81,		/* 129 */
			0x10,		/* 16 */
/* 230 */	0xa4,		/* 164 */
			0x98,		/* 152 */
/* 232 */	0xec,		/* 236 */
			0x97,		/* 151 */
/* 234 */	0x1f,		/* 31 */
			0x7f,		/* 127 */
/* 236 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 238 */	NdrFcLong( 0x9f5e5e10 ),	/* -1621205488 */
/* 242 */	NdrFcShort( 0xabef ),	/* -21521 */
/* 244 */	NdrFcShort( 0x4200 ),	/* 16896 */
/* 246 */	0x84,		/* 132 */
			0xe3,		/* 227 */
/* 248 */	0x37,		/* 55 */
			0xdf,		/* 223 */
/* 250 */	0x50,		/* 80 */
			0x5b,		/* 91 */
/* 252 */	0xf7,		/* 247 */
			0xec,		/* 236 */
/* 254 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 256 */	NdrFcLong( 0x7c23ff90 ),	/* 2082733968 */
/* 260 */	NdrFcShort( 0x33af ),	/* 13231 */
/* 262 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 264 */	0x95,		/* 149 */
			0xda,		/* 218 */
/* 266 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 268 */	0x24,		/* 36 */
			0xa8,		/* 168 */
/* 270 */	0x5b,		/* 91 */
			0x51,		/* 81 */
/* 272 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 274 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 278 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 280 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 282 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 284 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 286 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 288 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 290 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 292 */	NdrFcLong( 0xd32c2170 ),	/* -752082576 */
/* 296 */	NdrFcShort( 0xaf6e ),	/* -20626 */
/* 298 */	NdrFcShort( 0x418f ),	/* 16783 */
/* 300 */	0x81,		/* 129 */
			0x10,		/* 16 */
/* 302 */	0xa4,		/* 164 */
			0x98,		/* 152 */
/* 304 */	0xec,		/* 236 */
			0x97,		/* 151 */
/* 306 */	0x1f,		/* 31 */
			0x7f,		/* 127 */
/* 308 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 310 */	NdrFcLong( 0x9f5e5e10 ),	/* -1621205488 */
/* 314 */	NdrFcShort( 0xabef ),	/* -21521 */
/* 316 */	NdrFcShort( 0x4200 ),	/* 16896 */
/* 318 */	0x84,		/* 132 */
			0xe3,		/* 227 */
/* 320 */	0x37,		/* 55 */
			0xdf,		/* 223 */
/* 322 */	0x50,		/* 80 */
			0x5b,		/* 91 */
/* 324 */	0xf7,		/* 247 */
			0xec,		/* 236 */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x3d6f5f60 ),	/* 1030709088 */
/* 332 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 334 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 336 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 338 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 340 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 342 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x7c23ff90 ),	/* 2082733968 */
/* 350 */	NdrFcShort( 0x33af ),	/* 13231 */
/* 352 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 354 */	0x95,		/* 149 */
			0xda,		/* 218 */
/* 356 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 358 */	0x24,		/* 36 */
			0xa8,		/* 168 */
/* 360 */	0x5b,		/* 91 */
			0x51,		/* 81 */
/* 362 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 364 */	NdrFcLong( 0xcd193bc0 ),	/* -853984320 */
/* 368 */	NdrFcShort( 0xb4bc ),	/* -19268 */
/* 370 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 372 */	0x98,		/* 152 */
			0x33,		/* 51 */
/* 374 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 376 */	0x4f,		/* 79 */
			0xc3,		/* 195 */
/* 378 */	0x1d,		/* 29 */
			0x2e,		/* 46 */
/* 380 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 382 */	NdrFcLong( 0xd32c2170 ),	/* -752082576 */
/* 386 */	NdrFcShort( 0xaf6e ),	/* -20626 */
/* 388 */	NdrFcShort( 0x418f ),	/* 16783 */
/* 390 */	0x81,		/* 129 */
			0x10,		/* 16 */
/* 392 */	0xa4,		/* 164 */
			0x98,		/* 152 */
/* 394 */	0xec,		/* 236 */
			0x97,		/* 151 */
/* 396 */	0x1f,		/* 31 */
			0x7f,		/* 127 */
/* 398 */	
			0x11, 0x0,	/* FC_RP */
/* 400 */	NdrFcShort( 0x14 ),	/* Offset= 20 (420) */
/* 402 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 404 */	NdrFcLong( 0x566e08ed ),	/* 1450051821 */
/* 408 */	NdrFcShort( 0x8d46 ),	/* -29370 */
/* 410 */	NdrFcShort( 0x45fa ),	/* 17914 */
/* 412 */	0x8c,		/* 140 */
			0x8e,		/* 142 */
/* 414 */	0x3d,		/* 61 */
			0xf,		/* 15 */
/* 416 */	0x67,		/* 103 */
			0x81,		/* 129 */
/* 418 */	0x17,		/* 23 */
			0x1b,		/* 27 */
/* 420 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 426 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 428 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 432 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 434 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (402) */
/* 436 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 438 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 440 */	NdrFcLong( 0x9f5e5e10 ),	/* -1621205488 */
/* 444 */	NdrFcShort( 0xabef ),	/* -21521 */
/* 446 */	NdrFcShort( 0x4200 ),	/* 16896 */
/* 448 */	0x84,		/* 132 */
			0xe3,		/* 227 */
/* 450 */	0x37,		/* 55 */
			0xdf,		/* 223 */
/* 452 */	0x50,		/* 80 */
			0x5b,		/* 91 */
/* 454 */	0xf7,		/* 247 */
			0xec,		/* 236 */
/* 456 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 458 */	NdrFcLong( 0x3d6f5f60 ),	/* 1030709088 */
/* 462 */	NdrFcShort( 0x7538 ),	/* 30008 */
/* 464 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 466 */	0x8d,		/* 141 */
			0x5b,		/* 91 */
/* 468 */	0x0,		/* 0 */
			0x10,		/* 16 */
/* 470 */	0x4b,		/* 75 */
			0x35,		/* 53 */
/* 472 */	0xe7,		/* 231 */
			0xef,		/* 239 */
/* 474 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 476 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_corzap_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICorZapPreferences, ver. 0.0,
   GUID={0x9F5E5E10,0xABEF,0x4200,{0x84,0xE3,0x37,0xDF,0x50,0x5B,0xF7,0xEC}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapPreferences_FormatStringOffsetTable[] =
    {
    0,
    28,
    56
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapPreferences_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapPreferences_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapPreferences_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapPreferences_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICorZapPreferencesProxyVtbl = 
{
    &ICorZapPreferences_ProxyInfo,
    &IID_ICorZapPreferences,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapPreferences::GetFeatures */ ,
    (void *) (INT_PTR) -1 /* ICorZapPreferences::GetCompiler */ ,
    (void *) (INT_PTR) -1 /* ICorZapPreferences::GetOptimization */
};

const CInterfaceStubVtbl _ICorZapPreferencesStubVtbl =
{
    &IID_ICorZapPreferences,
    &ICorZapPreferences_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_corzap_0160, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorZapConfiguration, ver. 0.0,
   GUID={0xD32C2170,0xAF6E,0x418f,{0x81,0x10,0xA4,0x98,0xEC,0x97,0x1F,0x7F}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapConfiguration_FormatStringOffsetTable[] =
    {
    84,
    112,
    140
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapConfiguration_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapConfiguration_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapConfiguration_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapConfiguration_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICorZapConfigurationProxyVtbl = 
{
    &ICorZapConfiguration_ProxyInfo,
    &IID_ICorZapConfiguration,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapConfiguration::GetSharing */ ,
    (void *) (INT_PTR) -1 /* ICorZapConfiguration::GetDebugging */ ,
    (void *) (INT_PTR) -1 /* ICorZapConfiguration::GetProfiling */
};

const CInterfaceStubVtbl _ICorZapConfigurationStubVtbl =
{
    &IID_ICorZapConfiguration,
    &ICorZapConfiguration_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorZapBinding, ver. 0.0,
   GUID={0x566E08ED,0x8D46,0x45fa,{0x8C,0x8E,0x3D,0x0F,0x67,0x81,0x17,0x1B}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapBinding_FormatStringOffsetTable[] =
    {
    168,
    196
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapBinding_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapBinding_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapBinding_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapBinding_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorZapBindingProxyVtbl = 
{
    &ICorZapBinding_ProxyInfo,
    &IID_ICorZapBinding,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapBinding::GetRef */ ,
    (void *) (INT_PTR) -1 /* ICorZapBinding::GetAssembly */
};

const CInterfaceStubVtbl _ICorZapBindingStubVtbl =
{
    &IID_ICorZapBinding,
    &ICorZapBinding_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorZapRequest, ver. 0.0,
   GUID={0xC009EE47,0x8537,0x4993,{0x9A,0xAA,0xE2,0x92,0xF4,0x2C,0xA1,0xA3}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapRequest_FormatStringOffsetTable[] =
    {
    224,
    276
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapRequest_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapRequest_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapRequest_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapRequest_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorZapRequestProxyVtbl = 
{
    &ICorZapRequest_ProxyInfo,
    &IID_ICorZapRequest,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapRequest::Load */ ,
    (void *) (INT_PTR) -1 /* ICorZapRequest::Install */
};

const CInterfaceStubVtbl _ICorZapRequestStubVtbl =
{
    &IID_ICorZapRequest,
    &ICorZapRequest_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICorZapCompile, ver. 0.0,
   GUID={0xC357868B,0x987F,0x42c6,{0xB1,0xE3,0x13,0x21,0x64,0xC5,0xC7,0xD3}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapCompile_FormatStringOffsetTable[] =
    {
    322,
    374
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapCompile_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapCompile_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapCompile_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapCompile_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorZapCompileProxyVtbl = 
{
    &ICorZapCompile_ProxyInfo,
    &IID_ICorZapCompile,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapCompile::Compile */ ,
    (void *) (INT_PTR) -1 /* ICorZapCompile::CompileBound */
};

const CInterfaceStubVtbl _ICorZapCompileStubVtbl =
{
    &IID_ICorZapCompile,
    &ICorZapCompile_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_corzap_0164, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorZapStatus, ver. 0.0,
   GUID={0x3d6f5f60,0x7538,0x11d3,{0x8d,0x5b,0x00,0x10,0x4b,0x35,0xe7,0xef}} */

#pragma code_seg(".orpc")
static const unsigned short ICorZapStatus_FormatStringOffsetTable[] =
    {
    438,
    472
    };

static const MIDL_STUBLESS_PROXY_INFO ICorZapStatus_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICorZapStatus_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICorZapStatus_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICorZapStatus_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICorZapStatusProxyVtbl = 
{
    &ICorZapStatus_ProxyInfo,
    &IID_ICorZapStatus,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ICorZapStatus::Message */ ,
    (void *) (INT_PTR) -1 /* ICorZapStatus::Progress */
};

const CInterfaceStubVtbl _ICorZapStatusStubVtbl =
{
    &IID_ICorZapStatus,
    &ICorZapStatus_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _corzap_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICorZapPreferencesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorZapRequestProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorZapStatusProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorZapConfigurationProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorZapCompileProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICorZapBindingProxyVtbl,
    0
};

const CInterfaceStubVtbl * _corzap_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICorZapPreferencesStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorZapRequestStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorZapStatusStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorZapConfigurationStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorZapCompileStubVtbl,
    ( CInterfaceStubVtbl *) &_ICorZapBindingStubVtbl,
    0
};

PCInterfaceName const _corzap_InterfaceNamesList[] = 
{
    "ICorZapPreferences",
    "ICorZapRequest",
    "ICorZapStatus",
    "ICorZapConfiguration",
    "ICorZapCompile",
    "ICorZapBinding",
    0
};


#define _corzap_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _corzap, pIID, n)

int __stdcall _corzap_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _corzap, 6, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _corzap, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _corzap, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _corzap, 6, *pIndex )
    
}

const ExtendedProxyFileInfo corzap_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _corzap_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _corzap_StubVtblList,
    (const PCInterfaceName * ) & _corzap_InterfaceNamesList,
    0, // no delegation
    & _corzap_IID_Lookup, 
    6,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cpimporteritf.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:15 2003
 */
/* Compiler settings for cpimporteritf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cpimporteritf_h__
#define __cpimporteritf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEventImporter_FWD_DEFINED__
#define __IEventImporter_FWD_DEFINED__
typedef interface IEventImporter IEventImporter;
#endif 	/* __IEventImporter_FWD_DEFINED__ */


#ifndef __COMEventImp__FWD_DEFINED__
#define __COMEventImp__FWD_DEFINED__

#ifdef __cplusplus
typedef class COMEventImp_ COMEventImp_;
#else
typedef struct COMEventImp_ COMEventImp_;
#endif /* __cplusplus */

#endif 	/* __COMEventImp__FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IEventImporter_INTERFACE_DEFINED__
#define __IEventImporter_INTERFACE_DEFINED__

/* interface IEventImporter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEventImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84E045F0-0E22-11d3-8B9A-0000F8083A57")
    IEventImporter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ VARIANT_BOOL bVerbose) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterSourceInterface( 
            /* [in] */ BSTR strBaseComponentName,
            /* [in] */ BSTR strTCEComponentName,
            /* [in] */ BSTR strInterfaceName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSourceInterfaceCount( 
            /* [retval][out] */ LONG *SourceCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Process( 
            /* [in] */ BSTR strInputFile,
            /* [in] */ BSTR strOutputFile,
            /* [in] */ VARIANT_BOOL bMerge) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventImporterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEventImporter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEventImporter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEventImporter * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IEventImporter * This,
            /* [in] */ VARIANT_BOOL bVerbose);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterSourceInterface )( 
            IEventImporter * This,
            /* [in] */ BSTR strBaseComponentName,
            /* [in] */ BSTR strTCEComponentName,
            /* [in] */ BSTR strInterfaceName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSourceInterfaceCount )( 
            IEventImporter * This,
            /* [retval][out] */ LONG *SourceCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Process )( 
            IEventImporter * This,
            /* [in] */ BSTR strInputFile,
            /* [in] */ BSTR strOutputFile,
            /* [in] */ VARIANT_BOOL bMerge);
        
        END_INTERFACE
    } IEventImporterVtbl;

    interface IEventImporter
    {
        CONST_VTBL struct IEventImporterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEventImporter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEventImporter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEventImporter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEventImporter_Initialize(This,bVerbose)	\
    (This)->lpVtbl -> Initialize(This,bVerbose)

#define IEventImporter_RegisterSourceInterface(This,strBaseComponentName,strTCEComponentName,strInterfaceName)	\
    (This)->lpVtbl -> RegisterSourceInterface(This,strBaseComponentName,strTCEComponentName,strInterfaceName)

#define IEventImporter_GetSourceInterfaceCount(This,SourceCount)	\
    (This)->lpVtbl -> GetSourceInterfaceCount(This,SourceCount)

#define IEventImporter_Process(This,strInputFile,strOutputFile,bMerge)	\
    (This)->lpVtbl -> Process(This,strInputFile,strOutputFile,bMerge)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventImporter_Initialize_Proxy( 
    IEventImporter * This,
    /* [in] */ VARIANT_BOOL bVerbose);


void __RPC_STUB IEventImporter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventImporter_RegisterSourceInterface_Proxy( 
    IEventImporter * This,
    /* [in] */ BSTR strBaseComponentName,
    /* [in] */ BSTR strTCEComponentName,
    /* [in] */ BSTR strInterfaceName);


void __RPC_STUB IEventImporter_RegisterSourceInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventImporter_GetSourceInterfaceCount_Proxy( 
    IEventImporter * This,
    /* [retval][out] */ LONG *SourceCount);


void __RPC_STUB IEventImporter_GetSourceInterfaceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEventImporter_Process_Proxy( 
    IEventImporter * This,
    /* [in] */ BSTR strInputFile,
    /* [in] */ BSTR strOutputFile,
    /* [in] */ VARIANT_BOOL bMerge);


void __RPC_STUB IEventImporter_Process_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEventImporter_INTERFACE_DEFINED__ */



#ifndef __CPImporterItfLib_LIBRARY_DEFINED__
#define __CPImporterItfLib_LIBRARY_DEFINED__

/* library CPImporterItfLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CPImporterItfLib;

EXTERN_C const CLSID CLSID_COMEventImp_;

#ifdef __cplusplus

class DECLSPEC_UUID("A1991A1E-0E22-11d3-8B9A-0000F8083A57")
COMEventImp_;
#endif
#endif /* __CPImporterItfLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\cpimporteritf_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:15 2003
 */
/* Compiler settings for cpimporteritf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventImporter,0x84E045F0,0x0E22,0x11d3,0x8B,0x9A,0x00,0x00,0xF8,0x08,0x3A,0x57);


MIDL_DEFINE_GUID(IID, LIBID_CPImporterItfLib,0x945D2C8C,0x0E22,0x11d3,0x8B,0x9A,0x00,0x00,0xF8,0x08,0x3A,0x57);


MIDL_DEFINE_GUID(CLSID, CLSID_COMEventImp_,0xA1991A1E,0x0E22,0x11d3,0x8B,0x9A,0x00,0x00,0xF8,0x08,0x3A,0x57);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dbgalloc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DBGALLOC_H_INCLUDED
#define __DBGALLOC_H_INCLUDED

//
// DbgAlloc.h
//
//  Routines layered on top of allocation primitives to provide debugging
//  support.
//

#include "switches.h"


void * __stdcall DbgAlloc(size_t n, void **ppvCallstack);
void __stdcall DbgFree(void *b, void **ppvCallstack);
void __stdcall DbgAllocReport(char *pString = NULL, BOOL fDone = TRUE, BOOL fDoPrintf = TRUE);
void __stdcall DbgCallstack(void **ppvBuffer);
#define CDA_MAX_CALLSTACK 16
#define CDA_DECL_CALLSTACK() void *_rpvCallstack[CDA_MAX_CALLSTACK]; DbgCallstack(_rpvCallstack)
#define CDA_GET_CALLSTACK() _rpvCallstack

// Routines to verify locks are being opened/closed ok
void DbgIncLock(char* info);
void DbgDecLock(char* info);
void DbgIncBCrstLock();
void DbgIncECrstLock();
void DbgIncBCrstUnLock();
void DbgIncECrstUnLock();

#ifdef SHOULD_WE_CLEANUP
BOOL isThereOpenLocks();
#endif /* SHOULD_WE_CLEANUP */

void LockLog(char*);


#ifdef _DEBUG
#define LOCKCOUNTINC            LOCKCOUNTINCL("No info");
#define LOCKCOUNTDEC            LOCKCOUNTDECL("No info");
#define LOCKCOUNTINCL(string)   { DbgIncLock(string); };
#define LOCKCOUNTDECL(string)	{ DbgDecLock(string); };

// Special Routines for CRST locks
#define CRSTBLOCKCOUNTINCL()   { DbgIncBCrstLock(); };
#define CRSTELOCKCOUNTINCL()   { DbgIncECrstLock(); };
#define CRSTBUNLOCKCOUNTINCL()   { DbgIncBCrstUnLock(); };
#define CRSTEUNLOCKCOUNTINCL()   { DbgIncECrstUnLock(); };


#define LOCKLOG(string)         { LockLog(string); };
#else
#define LOCKCOUNTINCL
#define LOCKCOUNTDECL
#define CRSTBLOCKCOUNTINCL()
#define CRSTELOCKCOUNTINCL()
#define CRSTBUNLOCKCOUNTINCL()
#define CRSTEUNLOCKCOUNTINCL()
#define LOCKCOUNTINC
#define LOCKCOUNTDEC
#define LOCKLOG

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\crtwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CrtWrap.h
//
// Wrapper code for the C runtime library.
//
//*****************************************************************************
#ifndef __CrtWrap_h__
#define __CrtWrap_h__


//*****************************************************************************
// The following macros may be used to free memory which is typically always
// allocated and used until process shut down.  Use only in cases where
// the data will never get freed except on process cleanup, and you want to
// avoid the add'l overhead of freeing data on shut down.  For example,
// allocating and leaking a large heap you plan to suballocate from might be
// useful to speed up process unload.  The macros are here so that in debug
// mode, or memory checking mode, leak tools can be used to find errors in
// code logic without polluting the list with a bunch of "known" leaks.
//*****************************************************************************
#if defined(_DEBUG) || defined(_CHECK_MEM)
#define _FREE_OPTIONAL(func, ptr) func(ptr)
#define FREE_OPTIONAL(ptr) _FREE_OPTIONAL(free, ptr)
#define DELETE_OPTIONAL(ptr) delete ptr
#define DELETE_ARRAY_OPTIONAL(ptr) delete [] ptr
#else
#define _FREE_OPTIONAL(func, ptr) ((void) 0)
#define FREE_OPTIONAL(ptr) ((void) 0)
#define DELETE_OPTIONAL(ptr) ((void) 0)
#define DELETE_ARRAY_OPTIONAL(ptr) ((void) 0)
#endif


//*****************************************************************************
// If the CRT is allowed in the current compiland, then just include the
// correct CRT header files.
//*****************************************************************************
#ifndef NO_CRT

#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include "DebugMacros.h"
#include <stdlib.h>
#include <malloc.h>
#include <stdio.h>

//*****************************************************************************
// Else no CRT references are allowed.	Provide stubs and macros for common
// functionality, and otherwise abstract the CRT from the user.
//*****************************************************************************
#else // NO_CRT

// Fake out include directive on stdlib.h.
#ifdef _INC_STDLIB
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_STDLIB
#define _INC_STDLIB

#ifdef _INC_MALLOC
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_MALLOC
#define _INC_MALLOC

#ifdef _INC_TIME
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_TIME
#define _INC_TIME

#ifdef _INC_STDIO
#error "Include crtwrap.h before any other include files."
#endif
#undef _INC_STDIO
#define _INC_STDIO


#if !defined( _CRTBLD ) && defined( _DLL )
#define _CRTIMP_TODO __declspec(dllimport)
#else
#define _CRTIMP_TODO
#endif



// ---------------------------------------------------------------- //
//																	//
// $$  $$  $$	$$ $$$$$   $$$$$$$ $$$$$$			 $$$$  $$$$$$$	//
// $$  $$  $$$	$$	$$ $$	$$	 $	$$	$$			$$	$$	$$	 $	//
// $$  $$  $$$$ $$	$$	$$	$$ $	$$	$$		   $$		$$ $	//
// $$  $$  $$ $$$$	$$	$$	$$$$	$$$$$		   $$		$$$$	//
// $$  $$  $$  $$$	$$	$$	$$ $	$$ $$		   $$		$$ $	//
// $$  $$  $$	$$	$$ $$	$$	 $	$$	$$			$$	$$	$$	 $	//
// $$$$$$  $$	$$ $$$$$   $$$$$$$ $$$	$$ $$$$$$$	 $$$$  $$$$$$$	//
//																	//
// ---------------------------------------------------------------- //

#ifdef PLATFORM_CE

#ifndef _SIZE_T_DEFINED
#	define _SIZE_T_DEFINED
	typedef unsigned int size_t ;
#endif//_SIZE_T_DEFINED

#ifndef _WCHAR_T_DEFINED
#	define _WCHAR_T_DEFINED
	typedef unsigned short wchar_t;
#endif//_WCHAR_T_DEFINED


#ifndef _CRTIMP
#if defined(COREDLL)
#define _CRTIMP
#else
#define _CRTIMP __declspec(dllimport)
#endif
#endif

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

typedef struct _EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;

typedef wchar_t        wint_t;

typedef char *va_list;
// @FUTURE: - Multi-Platform, This is only the x86 version
#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)	( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)		( ap = (va_list)0 )

// Limits originally from LIMITS.H
#define CHAR_BIT	 8		  /* number of bits in a char */
#define SCHAR_MIN	 (-128) 	   /* minimum signed char value */
#define SCHAR_MAX	 127		/* maximum signed char value */
#define UCHAR_MAX	 0xff		 /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	 /* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	 /* maximum char value */
#else
#define CHAR_MIN	0
#define CHAR_MAX	UCHAR_MAX
#endif	  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX	2		 /* max. # bytes in multibyte char */
#define SHRT_MIN	(-32768)	/* minimum (signed) short value */
#define SHRT_MAX	32767	  /* maximum (signed) short value */
#define USHRT_MAX	0xffff	  /* maximum unsigned short value */
#define INT_MIN 	(-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX 	2147483647	  /* maximum (signed) int value */
#define UINT_MAX	0xffffffff	  /* maximum unsigned int value */
#define LONG_MIN	(-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX	2147483647L    /* maximum (signed) long value */
#define ULONG_MAX	0xffffffffUL	/* maximum unsigned long value */

#ifdef __cplusplus
extern "C"{
#endif 

// Extended logical Ops functions, STDLIB.H
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
unsigned int  __cdecl _rotl(unsigned int, int);
unsigned int  __cdecl _rotr(unsigned int, int);

// ANSI String formatting functions
_CRTIMP int    __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int    __cdecl sprintf(char *, const char *, ...);
_CRTIMP int    __cdecl vsprintf(char *, const char *, va_list);

size_t __cdecl strlen(const char *);
int    __cdecl strcmp(const char *, const char *);
char * __cdecl strcat(char *, const char *);
char * __cdecl strcpy(char *, const char *);

_CRTIMP char * __cdecl strchr(const char *, int);
_CRTIMP size_t __cdecl strcspn(const char *, const char *);
_CRTIMP char * __cdecl strncat(char *, const char *, size_t);
_CRTIMP int    __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl strstr(const char *, const char *);
_CRTIMP char * __cdecl strtok(char *, const char *);

_CRTIMP size_t	  __cdecl wcslen(const wchar_t *); 
_CRTIMP int 	  __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *string, wchar_t c);
_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int 	  __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int 	  __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);

int    __cdecl _finite(double);
int    __cdecl _isnan(double);
double	  __cdecl fmod(double, double);

// Mem functions, originally from MEMORY.H
int    __cdecl memcmp(const void *, const void *, size_t);
void * __cdecl memcpy(void *, const void *, size_t);
void * __cdecl memset(void *, int, size_t);

_CRTIMP void * __cdecl memchr(const void *, int, size_t);
_CRTIMP int    __cdecl _memicmp(const void *, const void *, unsigned int);
_CRTIMP void * __cdecl _memccpy(void *, const void *, int, unsigned int);
_CRTIMP void * __cdecl memmove(void *, const void *, size_t);

// Bit masks used by iswXXX macros, CTYPE.H
#define _UPPER		0x1    /* upper case letter */
#define _LOWER		0x2    /* lower case letter */
#define _DIGIT		0x4    /* digit[0-9] */
#define _SPACE		0x8    /* tab, carriage return, newline, */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */
#define _ALPHA		(0x0100|_UPPER|_LOWER)	  /* alphabetic character */
#define islower(_c) 	 ( iswlower(_c) )
#define iswlower(_c)	 ( iswctype(_c,_LOWER) )
_CRTIMP int 	iswctype(wchar_t, wchar_t);
_CRTIMP int    __cdecl tolower(int);
_CRTIMP int    __cdecl toupper(int);

//@todo (billev) remove/move to winfix.h
char *	__cdecl strrchr(const char *, int);
// _CRTIMP char * __cdecl strchr(const char *, int);
int 	__cdecl _stricmp(const char *, const char *);
int	   __cdecl _strnicmp(const char *, const char *, size_t);

// FILE is an opaque handle in Win CE. Users have no access to the internals
#ifndef _FILE_DEFINED
typedef void FILE;
#define _FILE_DEFINED
#endif

// functions for general buffered file handling in either ANSI or Wide
_CRTIMP FILE*  __cdecl _getstdfilex(int);

// Std handle defns
#define stdin  _getstdfilex(0)
#define stdout _getstdfilex(1)
#define stderr _getstdfilex(2)

// Used by the GetStdHandle macro in winwrap.h
_CRTIMP void*  __cdecl _fileno(FILE *);

_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef __cplusplus
}
#endif 

//	$$$$  $$  $ $$$ 	 $$  $$$$
//	$	  $$  $ $  $	$  $ $
//	$$$   $ $ $ $	$	$	 $$$
//	$	  $  $$ $  $	$  $ $
//	$$$$  $  $$ $$$ 	 $$  $$$$

#endif // PLATFORM_CE

#include <windows.h>
#include <objbase.h>
#include <intrinsic.h>
#include "DebugMacros.h"



/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#ifndef _MAC
#define _MAX_PATH	260 /* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256 /* max. length of path component */
#define _MAX_FNAME	256 /* max. length of file name component */
#define _MAX_EXT	256 /* max. length of extension component */
#else	/* def _MAC */
#define _MAX_PATH	256 /* max. length of full pathname */
#define _MAX_DIR	32	/* max. length of path component */
#define _MAX_FNAME	64	/* max. length of file name component */
#endif	/* _MAC */


#ifndef __min
#define __min(x, y) ((x) < (y) ? (x) : (y))
#endif
#ifndef __max
#define __max(x, y) ((x) > (y) ? (x) : (y))
#endif


#define sprintf 	wsprintfA
#define vsprintf	wvsprintfA
#define _strnicmp(s1, s2, slen) (CompareStringA(LOCALE_USER_DEFAULT, NORM_IGNORECASE, s1, slen, s2, slen) - 2)

#if defined(UNICODE) || defined(_UNICODE)

#define _tcscat 	wcscat
#define _tcslen 	wcslen
#define _tcscmp 	wcscmp
#define _tcsicmp	wcsicmp
#define _tcsncmp(s1, s2, slen)	memcmp(s1, s2, (slen) * sizeof(wchar_t))
#define _tcsnccmp(s1, s2, slen)   memcmp(s1, s2, (slen) * sizeof(wchar_t))
#define _tcsnicmp	_wcsnicmp
#define _tcsncicmp	_wcsnicmp
#define _tprintf	wprintf
#define _stprintf	swprintf
#define _tcscpy 	wcscpy
#define _tcsncpy(s1, s2, slen)	memcpy(s1, s2, (slen) * sizeof(wchar_t))

#else	// Note: you really are supposed to be using UNICODE here

#define _tcscat 	strcat
#define _tcslen 	strlen
#define _tcscmp 	strcmp
#define _tcsicmp	stricmp
#define _tcsncmp(s1, s2, slen)	memcmp(s1, s2, (slen))
#define _tcsnccmp(s1, s2, slen)   memcmp(s1, s2, (slen))
#define _tcsnicmp	_strnicmp
#define _tcsncicmp	_strnicmp
#define _tprintf	printf
#define _stprintf	sprintf
#define _tcscpy 	strcpy
#define _tcsncpy(s1, s2, slen)	memcpy(s1, s2, slen)

#endif


#ifdef __cplusplus
extern "C"{
#endif 


// Memory.
void	__cdecl free(void *);
void *	__cdecl malloc(size_t);
void *	__cdecl realloc(void *, size_t);
void *	__cdecl _alloca(size_t);
size_t	__cdecl _msize(void *);
void *	__cdecl _expand(void *, size_t);
void * __cdecl calloc(size_t num, size_t size);


#if !__STDC__
/* Non-ANSI names for compatibility */
#define alloca	_alloca
#endif	/* !__STDC__ */

#if defined (_M_MRX000) || defined (_M_PPC) || defined (_M_ALPHA)
#pragma intrinsic(_alloca)
#endif	/* defined (_M_MRX000) || defined (_M_PPC) || defined (_M_ALPHA) */


// Time.

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

// 4 byte time, no check for daylight savings
_CRTIMP time_t __cdecl time(time_t *timeptr);


// Strings.
_CRTIMP int __cdecl _vsnwprintf(wchar_t *szOutput, size_t iSize, const wchar_t *szFormat, va_list args);
_CRTIMP int __cdecl vswprintf(wchar_t *szOutput, const wchar_t *szFormat, va_list args);
_CRTIMP int __cdecl wprintf(const wchar_t *format, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *szOutput, size_t iSize, const wchar_t *szFormat, ...);
_CRTIMP int __cdecl _snprintf(char *szOutput, size_t iSize, const char *szFormat, ...);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t * string, wchar_t ch);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t * wcs1, const wchar_t * wcs2);
_CRTIMP int __cdecl swprintf(wchar_t *szOutput, const wchar_t *szFormat, ...);
_CRTIMP long __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);


_CRTIMP int __cdecl _vsnprintf(char *szOutput, size_t iSize, const char *szFormat, va_list args);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl printf(const char *, ...);



// Utilities.
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);

_CRTIMP long __cdecl atol(const char *nptr);
_CRTIMP int __cdecl atoi(const char *nptr);
_CRTIMP __int64 __cdecl _atoi64(const char *nptr);
_CRTIMP char *__cdecl _ltoa( long value, char *string, int radix );

_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);

_CRTIMP void __cdecl qsort(void *base, unsigned num, unsigned width,
	int (__cdecl *comp)(const void *, const void *));

#ifdef _CRT_DEPENDENCY_

#define EOF 	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
		char *_ptr;
		int   _cnt;
		char *_base;
		int   _flag;
		int   _file;
		int   _charbuf;
		int   _bufsiz;
		char *_tmpfname;
		};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

#define _IOB_ENTRIES 20

#ifndef _STDIO_DEFINED
_CRTIMP_TODO extern FILE _iob[];
#endif	/* _STDIO_DEFINED */

#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])

_CRTIMP_TODO FILE * __cdecl fopen(const char *, const char *);
_CRTIMP_TODO FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP_TODO size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP_TODO long __cdecl ftell(FILE *);
_CRTIMP_TODO int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP_TODO int __cdecl fflush(FILE *);


#endif // _CRT_DEPENDENCY_


#ifdef __cplusplus
}
#endif 



#ifdef __cplusplus

void* __cdecl operator new(size_t cb);
void __cdecl operator delete(void *p);

#endif // __cplusplus




/*
 *
 * Template helpers.
 *
 */

#ifdef __cplusplus

#ifndef _HELPER_TEMPLATES_
#define _HELPER_TEMPLATES_

#ifndef ATLASSERT
#define ATLASSERT _ASSERTE
#endif



/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

inline IUnknown* AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

inline IUnknown* AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}


template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr()
	{
		p=NULL;
	}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.	If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
#if _MSC_VER >= 1200 // VC60 change
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp) const
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
#endif
	T* p;
};


/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	/*explicit*/ CComBSTR(REFGUID src)
	{
		LPOLESTR szGuid;
		StringFromCLSID(src, &szGuid);
		m_str = ::SysAllocString(szGuid);
		CoTaskMemFree(szGuid);
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			if (m_str)
				::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}

	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	HRESULT CopyTo(BSTR* pbstr)
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
			return E_POINTER;
		*pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
		if (*pbstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, (int)wcslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen)
	{
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}
#if 0
	HRESULT ToLower()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharLower(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	HRESULT ToUpper()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharUpper(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}
	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	bool operator<(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return false;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) < 0;
		return m_str == NULL;
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false;
	}
	bool operator<(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return false;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) < 0;
		return m_str == NULL;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false;
	}
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc)
	{
		m_str = A2WBSTR(pSrc);
	}

	CComBSTR(int nSize, LPCSTR sz)
	{
		m_str = A2WBSTR(sz, nSize);
	}

	void Append(LPCSTR lpsz)
	{
		USES_CONVERSION;
		LPCOLESTR lpo = A2COLE(lpsz);
		Append(lpo, wcslen(lpo));
	}

	CComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		return *this;
	}
#endif
#endif
	HRESULT WriteToStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ULONG cb;
		ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			return hr;
		return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
	}
	HRESULT ReadFromStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ATLASSERT(m_str == NULL); // should be empty
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
		if ((hr == S_OK) && (cbStrLen != 0))
		{
			//subtract size for terminating NULL which we wrote out
			//since SysAllocStringByteLen overallocates for the NULL
			m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
			if (m_str == NULL)
				hr = E_OUTOFMEMORY;
			else
				hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		}
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		vt = VT_EMPTY;
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#if 0
#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif
#endif

	CComVariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	CComVariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

#if 0
	#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif
#endif

	CComVariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	CComVariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	CComVariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
	bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_LT;}
	bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_GT;}

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to CComVariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	ATLASSERT(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (hr == S_FALSE)
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}


#endif	// _HELPER_TEMPLATES_

#endif // __cplusplus

#endif // NO_CRT

#endif // __CrtWrap_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\corsym_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:09 2003
 */
/* Compiler settings for corsym.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "corsym.h"

#define TYPE_FORMAT_STRING_SIZE   2933                              
#define PROC_FORMAT_STRING_SIZE   3565                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedBinder_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedBinder_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedBinder2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedBinder2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedDispose_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDispose_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedDocument_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDocument_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedDocumentWriter_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDocumentWriter_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedMethod_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedMethod_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedNamespace_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedNamespace_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedReader_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedReader_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedScope_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedScope_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedVariable_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedVariable_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedWriter_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedWriter_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISymUnmanagedWriter2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedWriter2_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetReaderForFile */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 10 */	NdrFcShort( 0x34 ),	/* 52 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter importer */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fileName */

/* 22 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter searchPath */

/* 28 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 34 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Return value */

/* 40 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 42 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 44 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReaderFromStream */

/* 46 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 48 */	NdrFcLong( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x4 ),	/* 4 */
/* 54 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x8 ),	/* 8 */
/* 60 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter importer */

/* 62 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 64 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 66 */	NdrFcShort( 0x32 ),	/* Type Offset=50 */

	/* Parameter pstream */

/* 68 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 70 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 72 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Parameter pRetVal */

/* 74 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 76 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 78 */	NdrFcShort( 0x56 ),	/* Type Offset=86 */

	/* Return value */

/* 80 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 82 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 84 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReaderForFile2 */

/* 86 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 88 */	NdrFcLong( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x5 ),	/* 5 */
/* 94 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 96 */	NdrFcShort( 0x3c ),	/* 60 */
/* 98 */	NdrFcShort( 0x8 ),	/* 8 */
/* 100 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter importer */

/* 102 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 106 */	NdrFcShort( 0x6c ),	/* Type Offset=108 */

	/* Parameter fileName */

/* 108 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 110 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 112 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter searchPath */

/* 114 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 118 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter searchPolicy */

/* 120 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 122 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 126 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 128 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 130 */	NdrFcShort( 0x86 ),	/* Type Offset=134 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 134 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Destroy */

/* 138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 156 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetURL */

/* 160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x3 ),	/* 3 */
/* 168 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 170 */	NdrFcShort( 0x8 ),	/* 8 */
/* 172 */	NdrFcShort( 0x24 ),	/* 36 */
/* 174 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchUrl */

/* 176 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchUrl */

/* 182 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szUrl */

/* 188 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 190 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 192 */	NdrFcShort( 0xa0 ),	/* Type Offset=160 */

	/* Return value */

/* 194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 196 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentType */

/* 200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x4 ),	/* 4 */
/* 208 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x4c ),	/* 76 */
/* 214 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 216 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 220 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Return value */

/* 222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 224 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLanguage */

/* 228 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 230 */	NdrFcLong( 0x0 ),	/* 0 */
/* 234 */	NdrFcShort( 0x5 ),	/* 5 */
/* 236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x4c ),	/* 76 */
/* 242 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 244 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 248 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Return value */

/* 250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLanguageVendor */

/* 256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x6 ),	/* 6 */
/* 264 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0x4c ),	/* 76 */
/* 270 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 272 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 276 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Return value */

/* 278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCheckSumAlgorithmId */

/* 284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 290 */	NdrFcShort( 0x7 ),	/* 7 */
/* 292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 296 */	NdrFcShort( 0x4c ),	/* 76 */
/* 298 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 300 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 304 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCheckSum */

/* 312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 320 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	NdrFcShort( 0x24 ),	/* 36 */
/* 326 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cData */

/* 328 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcData */

/* 334 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 336 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter data */

/* 340 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 342 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 344 */	NdrFcShort( 0xd4 ),	/* Type Offset=212 */

	/* Return value */

/* 346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 348 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FindClosestLine */

/* 352 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x9 ),	/* 9 */
/* 360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 362 */	NdrFcShort( 0x8 ),	/* 8 */
/* 364 */	NdrFcShort( 0x24 ),	/* 36 */
/* 366 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter line */

/* 368 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 374 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure HasEmbeddedSource */

/* 386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 392 */	NdrFcShort( 0xa ),	/* 10 */
/* 394 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x24 ),	/* 36 */
/* 400 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 402 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceLength */

/* 414 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 420 */	NdrFcShort( 0xb ),	/* 11 */
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 426 */	NdrFcShort( 0x24 ),	/* 36 */
/* 428 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 430 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 432 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 434 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 436 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 438 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceRange */

/* 442 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 448 */	NdrFcShort( 0xc ),	/* 12 */
/* 450 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 452 */	NdrFcShort( 0x28 ),	/* 40 */
/* 454 */	NdrFcShort( 0x24 ),	/* 36 */
/* 456 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x8,		/* 8 */

	/* Parameter startLine */

/* 458 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 460 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter startColumn */

/* 464 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 466 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endLine */

/* 470 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 472 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 474 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endColumn */

/* 476 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 478 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 480 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cSourceBytes */

/* 482 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 484 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 486 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcSourceBytes */

/* 488 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 490 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter source */

/* 494 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 496 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 498 */	NdrFcShort( 0xf2 ),	/* Type Offset=242 */

	/* Return value */

/* 500 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 502 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 504 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSource */

/* 506 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 508 */	NdrFcLong( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x3 ),	/* 3 */
/* 514 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 516 */	NdrFcShort( 0x8 ),	/* 8 */
/* 518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 520 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter sourceSize */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter source */

/* 528 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 532 */	NdrFcShort( 0x100 ),	/* Type Offset=256 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetCheckSum */

/* 540 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x4 ),	/* 4 */
/* 548 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 550 */	NdrFcShort( 0x38 ),	/* 56 */
/* 552 */	NdrFcShort( 0x8 ),	/* 8 */
/* 554 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter algorithmId */

/* 556 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 558 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 560 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter checkSumSize */

/* 562 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 564 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 566 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter checkSum */

/* 568 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 570 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 572 */	NdrFcShort( 0x10a ),	/* Type Offset=266 */

	/* Return value */

/* 574 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 576 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 578 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetToken */

/* 580 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 582 */	NdrFcLong( 0x0 ),	/* 0 */
/* 586 */	NdrFcShort( 0x3 ),	/* 3 */
/* 588 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x24 ),	/* 36 */
/* 594 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pToken */

/* 596 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 602 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSequencePointCount */

/* 608 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 610 */	NdrFcLong( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x4 ),	/* 4 */
/* 616 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0x24 ),	/* 36 */
/* 622 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 624 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 626 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 632 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRootScope */

/* 636 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 638 */	NdrFcLong( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x5 ),	/* 5 */
/* 644 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0x8 ),	/* 8 */
/* 650 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 652 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 656 */	NdrFcShort( 0x11c ),	/* Type Offset=284 */

	/* Return value */

/* 658 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetScopeFromOffset */

/* 664 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 666 */	NdrFcLong( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x6 ),	/* 6 */
/* 672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 674 */	NdrFcShort( 0x8 ),	/* 8 */
/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 678 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter offset */

/* 680 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 682 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 684 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 686 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 688 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 690 */	NdrFcShort( 0x132 ),	/* Type Offset=306 */

	/* Return value */

/* 692 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 694 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 696 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOffset */

/* 698 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 700 */	NdrFcLong( 0x0 ),	/* 0 */
/* 704 */	NdrFcShort( 0x7 ),	/* 7 */
/* 706 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 708 */	NdrFcShort( 0x10 ),	/* 16 */
/* 710 */	NdrFcShort( 0x24 ),	/* 36 */
/* 712 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter document */

/* 714 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 716 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 718 */	NdrFcShort( 0x148 ),	/* Type Offset=328 */

	/* Parameter line */

/* 720 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 722 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter column */

/* 726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 728 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 732 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 734 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 738 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 740 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRanges */

/* 744 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 746 */	NdrFcLong( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 752 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 754 */	NdrFcShort( 0x18 ),	/* 24 */
/* 756 */	NdrFcShort( 0x24 ),	/* 36 */
/* 758 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter document */

/* 760 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 762 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 764 */	NdrFcShort( 0x15e ),	/* Type Offset=350 */

	/* Parameter line */

/* 766 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 768 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter column */

/* 772 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 774 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 776 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cRanges */

/* 778 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 780 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcRanges */

/* 784 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 786 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 788 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ranges */

/* 790 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 792 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 794 */	NdrFcShort( 0x174 ),	/* Type Offset=372 */

	/* Return value */

/* 796 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 798 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 800 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetParameters */

/* 802 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 804 */	NdrFcLong( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x9 ),	/* 9 */
/* 810 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 814 */	NdrFcShort( 0x24 ),	/* 36 */
/* 816 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cParams */

/* 818 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 820 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 822 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcParams */

/* 824 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 826 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 828 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter params */

/* 830 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 832 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 834 */	NdrFcShort( 0x198 ),	/* Type Offset=408 */

	/* Return value */

/* 836 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 838 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNamespace */

/* 842 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 844 */	NdrFcLong( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0xa ),	/* 10 */
/* 850 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 852 */	NdrFcShort( 0x0 ),	/* 0 */
/* 854 */	NdrFcShort( 0x8 ),	/* 8 */
/* 856 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 858 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 860 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 862 */	NdrFcShort( 0x1aa ),	/* Type Offset=426 */

	/* Return value */

/* 864 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 866 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceStartEnd */

/* 870 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 872 */	NdrFcLong( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0xb ),	/* 11 */
/* 878 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 880 */	NdrFcShort( 0x30 ),	/* 48 */
/* 882 */	NdrFcShort( 0x24 ),	/* 36 */
/* 884 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter docs */

/* 886 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 888 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 890 */	NdrFcShort( 0x1d2 ),	/* Type Offset=466 */

	/* Parameter lines */

/* 892 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 894 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 896 */	NdrFcShort( 0x1e4 ),	/* Type Offset=484 */

	/* Parameter columns */

/* 898 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 900 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 902 */	NdrFcShort( 0x1ea ),	/* Type Offset=490 */

	/* Parameter pRetVal */

/* 904 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 906 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 910 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 912 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSequencePoints */

/* 916 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 918 */	NdrFcLong( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0xc ),	/* 12 */
/* 924 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 928 */	NdrFcShort( 0x24 ),	/* 36 */
/* 930 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x9,		/* 9 */

	/* Parameter cPoints */

/* 932 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 934 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 936 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcPoints */

/* 938 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 940 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter offsets */

/* 944 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 946 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 948 */	NdrFcShort( 0x1f8 ),	/* Type Offset=504 */

	/* Parameter documents */

/* 950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 952 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 954 */	NdrFcShort( 0x214 ),	/* Type Offset=532 */

	/* Parameter lines */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 960 */	NdrFcShort( 0x226 ),	/* Type Offset=550 */

	/* Parameter columns */

/* 962 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 964 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 966 */	NdrFcShort( 0x230 ),	/* Type Offset=560 */

	/* Parameter endLines */

/* 968 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 970 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 972 */	NdrFcShort( 0x23a ),	/* Type Offset=570 */

	/* Parameter endColumns */

/* 974 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 976 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 978 */	NdrFcShort( 0x244 ),	/* Type Offset=580 */

	/* Return value */

/* 980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 982 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 986 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 992 */	NdrFcShort( 0x3 ),	/* 3 */
/* 994 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 996 */	NdrFcShort( 0x8 ),	/* 8 */
/* 998 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1000 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 1002 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1004 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 1008 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1010 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1012 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 1014 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1016 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1018 */	NdrFcShort( 0x252 ),	/* Type Offset=594 */

	/* Return value */

/* 1020 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1022 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1024 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNamespaces */

/* 1026 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1028 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1032 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1034 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1038 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1040 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cNameSpaces */

/* 1042 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1044 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1046 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcNameSpaces */

/* 1048 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1050 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1052 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter namespaces */

/* 1054 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1056 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1058 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Return value */

/* 1060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1062 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVariables */

/* 1066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1074 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1076 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1078 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1080 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cVars */

/* 1082 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1084 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcVars */

/* 1088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1090 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVars */

/* 1094 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1096 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1098 */	NdrFcShort( 0x29e ),	/* Type Offset=670 */

	/* Return value */

/* 1100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1102 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocument */

/* 1106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1114 */	NdrFcShort( 0x40 ),	/* x86 Stack size/offset = 64 */
/* 1116 */	NdrFcShort( 0xaa ),	/* 170 */
/* 1118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1120 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter url */

/* 1122 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1124 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1126 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter language */

/* 1128 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1130 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1132 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter languageVendor */

/* 1134 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1136 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1138 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter documentType */

/* 1140 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1142 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1144 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter pRetVal */

/* 1146 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1148 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 1150 */	NdrFcShort( 0x2b4 ),	/* Type Offset=692 */

	/* Return value */

/* 1152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1154 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 1156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocuments */

/* 1158 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1160 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1166 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1170 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1172 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cDocs */

/* 1174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcDocs */

/* 1180 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDocs */

/* 1186 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1190 */	NdrFcShort( 0x2e0 ),	/* Type Offset=736 */

	/* Return value */

/* 1192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1194 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetUserEntryPoint */

/* 1198 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1204 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1206 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1212 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pToken */

/* 1214 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1216 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethod */

/* 1226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1234 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1240 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter token */

/* 1242 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 1248 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1252 */	NdrFcShort( 0x2f6 ),	/* Type Offset=758 */

	/* Return value */

/* 1254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethodByVersion */

/* 1260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1266 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1268 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1270 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1274 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter token */

/* 1276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter version */

/* 1282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 1288 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1292 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1296 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetVariables */

/* 1300 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1306 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1308 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1310 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1312 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1314 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter parent */

/* 1316 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1318 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cVars */

/* 1322 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1324 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcVars */

/* 1328 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1330 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVars */

/* 1334 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1336 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1338 */	NdrFcShort( 0x338 ),	/* Type Offset=824 */

	/* Return value */

/* 1340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1342 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetGlobalVariables */

/* 1346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1352 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1354 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1358 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1360 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cVars */

/* 1362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1364 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcVars */

/* 1368 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVars */

/* 1374 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1378 */	NdrFcShort( 0x360 ),	/* Type Offset=864 */

	/* Return value */

/* 1380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1382 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethodFromDocumentPosition */

/* 1386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0xa ),	/* 10 */
/* 1394 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1400 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter document */

/* 1402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1406 */	NdrFcShort( 0x372 ),	/* Type Offset=882 */

	/* Parameter line */

/* 1408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter column */

/* 1414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 1420 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1424 */	NdrFcShort( 0x384 ),	/* Type Offset=900 */

	/* Return value */

/* 1426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1428 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSymAttribute */

/* 1432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1438 */	NdrFcShort( 0xb ),	/* 11 */
/* 1440 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1442 */	NdrFcShort( 0x2a ),	/* 42 */
/* 1444 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1446 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter parent */

/* 1448 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1450 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1452 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter name */

/* 1454 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1456 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1458 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter cBuffer */

/* 1460 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1462 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcBuffer */

/* 1466 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter buffer */

/* 1472 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1474 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1476 */	NdrFcShort( 0x3a2 ),	/* Type Offset=930 */

	/* Return value */

/* 1478 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1480 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNamespaces */

/* 1484 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1490 */	NdrFcShort( 0xc ),	/* 12 */
/* 1492 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1494 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1496 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1498 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cNameSpaces */

/* 1500 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1502 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1504 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcNameSpaces */

/* 1506 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1508 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter namespaces */

/* 1512 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1514 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1516 */	NdrFcShort( 0x3c6 ),	/* Type Offset=966 */

	/* Return value */

/* 1518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1520 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 1524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0xd ),	/* 13 */
/* 1532 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1534 */	NdrFcShort( 0x34 ),	/* 52 */
/* 1536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1538 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter importer */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1544 */	NdrFcShort( 0x3d8 ),	/* Type Offset=984 */

	/* Parameter filename */

/* 1546 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1548 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1550 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter searchPath */

/* 1552 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1554 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1556 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pIStream */

/* 1558 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1560 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1562 */	NdrFcShort( 0x3f2 ),	/* Type Offset=1010 */

	/* Return value */

/* 1564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1566 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateSymbolStore */

/* 1570 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1572 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0xe ),	/* 14 */
/* 1578 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1580 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1584 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter filename */

/* 1586 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1588 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1590 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pIStream */

/* 1592 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1594 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1596 */	NdrFcShort( 0x408 ),	/* Type Offset=1032 */

	/* Return value */

/* 1598 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1600 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1602 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReplaceSymbolStore */

/* 1604 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1606 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1610 */	NdrFcShort( 0xf ),	/* 15 */
/* 1612 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1614 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1618 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter filename */

/* 1620 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 1622 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1624 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pIStream */

/* 1626 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1628 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1630 */	NdrFcShort( 0x41e ),	/* Type Offset=1054 */

	/* Return value */

/* 1632 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1634 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSymbolStoreFileName */

/* 1638 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1640 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1644 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1646 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1648 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1650 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1652 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 1654 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1656 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1658 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 1660 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1662 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 1666 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1668 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1670 */	NdrFcShort( 0x434 ),	/* Type Offset=1076 */

	/* Return value */

/* 1672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1674 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethodsFromDocumentPosition */

/* 1678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1684 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1686 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1688 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1690 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1692 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter document */

/* 1694 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1696 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1698 */	NdrFcShort( 0x442 ),	/* Type Offset=1090 */

	/* Parameter line */

/* 1700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1702 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1704 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter column */

/* 1706 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1708 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1710 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cMethod */

/* 1712 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1714 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcMethod */

/* 1718 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1720 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1722 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 1724 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1726 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1728 */	NdrFcShort( 0x46a ),	/* Type Offset=1130 */

	/* Return value */

/* 1730 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1732 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentVersion */

/* 1736 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1738 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1742 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1744 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1748 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1750 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pDoc */

/* 1752 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1754 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1756 */	NdrFcShort( 0x47c ),	/* Type Offset=1148 */

	/* Parameter version */

/* 1758 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1760 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbCurrent */

/* 1764 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1766 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1772 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethodVersion */

/* 1776 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1778 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1784 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1788 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1790 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pMethod */

/* 1792 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1796 */	NdrFcShort( 0x496 ),	/* Type Offset=1174 */

	/* Parameter version */

/* 1798 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1804 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethod */

/* 1810 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1812 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1818 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1820 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1822 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1824 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 1826 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1828 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1830 */	NdrFcShort( 0x4ac ),	/* Type Offset=1196 */

	/* Return value */

/* 1832 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1834 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1836 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetParent */

/* 1838 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1840 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1844 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1846 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1850 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1852 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 1854 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1856 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1858 */	NdrFcShort( 0x4c2 ),	/* Type Offset=1218 */

	/* Return value */

/* 1860 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1862 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1864 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetChildren */

/* 1866 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1868 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1872 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1874 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1876 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1878 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1880 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cChildren */

/* 1882 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1884 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcChildren */

/* 1888 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1890 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter children */

/* 1894 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1896 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1898 */	NdrFcShort( 0x4ee ),	/* Type Offset=1262 */

	/* Return value */

/* 1900 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1902 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1904 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStartOffset */

/* 1906 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1908 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1912 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1914 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1916 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1918 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1920 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 1922 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1924 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1928 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1930 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1932 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEndOffset */

/* 1934 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1936 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1940 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1942 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1946 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1948 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 1950 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1952 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1954 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1956 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1958 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1960 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalCount */

/* 1962 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1964 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1968 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1970 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1974 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1976 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 1978 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1980 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1986 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocals */

/* 1990 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1996 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1998 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2002 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2004 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cLocals */

/* 2006 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2008 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2010 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcLocals */

/* 2012 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2014 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2016 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter locals */

/* 2018 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2020 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2022 */	NdrFcShort( 0x522 ),	/* Type Offset=1314 */

	/* Return value */

/* 2024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2026 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNamespaces */

/* 2030 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2036 */	NdrFcShort( 0xa ),	/* 10 */
/* 2038 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2040 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2042 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2044 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cNameSpaces */

/* 2046 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2048 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2050 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcNameSpaces */

/* 2052 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2054 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2056 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter namespaces */

/* 2058 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2060 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2062 */	NdrFcShort( 0x54a ),	/* Type Offset=1354 */

	/* Return value */

/* 2064 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2066 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 2070 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2072 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2076 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2078 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2080 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2082 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2084 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cchName */

/* 2086 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2088 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcchName */

/* 2092 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2094 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 2098 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2100 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2102 */	NdrFcShort( 0x560 ),	/* Type Offset=1376 */

	/* Return value */

/* 2104 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2106 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAttributes */

/* 2110 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2112 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2116 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2118 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2122 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2124 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2126 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2128 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2134 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSignature */

/* 2138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2144 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2146 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2150 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2152 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter cSig */

/* 2154 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2156 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcSig */

/* 2160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2162 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter sig */

/* 2166 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2170 */	NdrFcShort( 0x576 ),	/* Type Offset=1398 */

	/* Return value */

/* 2172 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2174 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2176 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressKind */

/* 2178 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2180 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2184 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2186 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2190 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2192 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2194 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2196 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2200 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2202 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressField1 */

/* 2206 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2208 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2212 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2214 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2218 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2220 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressField2 */

/* 2234 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2246 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2248 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2250 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2252 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2256 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2258 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2260 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressField3 */

/* 2262 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2264 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2268 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2270 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2274 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2276 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2278 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2280 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2286 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStartOffset */

/* 2290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2296 */	NdrFcShort( 0xa ),	/* 10 */
/* 2298 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2304 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2306 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEndOffset */

/* 2318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2324 */	NdrFcShort( 0xb ),	/* 11 */
/* 2326 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2330 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2332 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRetVal */

/* 2334 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2336 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2342 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineDocument */

/* 2346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2352 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2354 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2356 */	NdrFcShort( 0xe6 ),	/* 230 */
/* 2358 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2360 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter url */

/* 2362 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2364 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2366 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter language */

/* 2368 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2372 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter languageVendor */

/* 2374 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2378 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter documentType */

/* 2380 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2382 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2384 */	NdrFcShort( 0xb8 ),	/* Type Offset=184 */

	/* Parameter pRetVal */

/* 2386 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2388 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2390 */	NdrFcShort( 0x5ac ),	/* Type Offset=1452 */

	/* Return value */

/* 2392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2394 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetUserEntryPoint */

/* 2398 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2406 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2412 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter entryMethod */

/* 2414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2416 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2422 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OpenMethod */

/* 2426 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2428 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2432 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2434 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2438 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2440 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter method */

/* 2442 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2446 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2448 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2450 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2452 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CloseMethod */

/* 2454 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2456 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2460 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2464 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2468 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2470 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2472 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2474 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OpenScope */

/* 2476 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2478 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2482 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2484 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2486 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2488 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2490 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter startOffset */

/* 2492 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2494 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2496 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pRetVal */

/* 2498 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2500 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2502 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2504 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2506 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2508 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CloseScope */

/* 2510 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2512 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2516 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2518 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2522 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2524 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter endOffset */

/* 2526 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2528 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2530 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2532 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2534 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetScopeRange */

/* 2538 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2540 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2544 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2546 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2548 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2550 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2552 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter scopeID */

/* 2554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2556 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter startOffset */

/* 2560 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2562 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2564 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endOffset */

/* 2566 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2568 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2570 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2572 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2574 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2576 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineLocalVariable */

/* 2578 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2580 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2584 */	NdrFcShort( 0xa ),	/* 10 */
/* 2586 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 2588 */	NdrFcShort( 0x5a ),	/* 90 */
/* 2590 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2592 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xb,		/* 11 */

	/* Parameter name */

/* 2594 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2596 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2598 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 2600 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2602 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cSig */

/* 2606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2608 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter signature */

/* 2612 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2614 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2616 */	NdrFcShort( 0x5ca ),	/* Type Offset=1482 */

	/* Parameter addrKind */

/* 2618 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2620 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 2624 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2626 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 2630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2632 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 2636 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2638 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter startOffset */

/* 2642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2644 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endOffset */

/* 2648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2650 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2654 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2656 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2658 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineParameter */

/* 2660 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2662 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2666 */	NdrFcShort( 0xb ),	/* 11 */
/* 2668 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2670 */	NdrFcShort( 0x4a ),	/* 74 */
/* 2672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2674 */	0x4,		/* Oi2 Flags:  has return, */
			0x8,		/* 8 */

	/* Parameter name */

/* 2676 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2678 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2680 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 2682 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2684 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2686 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter sequence */

/* 2688 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2690 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2692 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addrKind */

/* 2694 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2696 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 2700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2702 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2704 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 2706 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2708 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2710 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 2712 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2714 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2718 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2720 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2722 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineField */

/* 2724 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2726 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2730 */	NdrFcShort( 0xc ),	/* 12 */
/* 2732 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2734 */	NdrFcShort( 0x52 ),	/* 82 */
/* 2736 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2738 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter parent */

/* 2740 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2742 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2744 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter name */

/* 2746 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2748 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2750 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 2752 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2754 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2756 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cSig */

/* 2758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2760 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter signature */

/* 2764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2766 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2768 */	NdrFcShort( 0x5dc ),	/* Type Offset=1500 */

	/* Parameter addrKind */

/* 2770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2772 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 2776 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2778 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 2782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2784 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 2788 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2790 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2794 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2796 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineGlobalVariable */

/* 2800 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2802 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2806 */	NdrFcShort( 0xd ),	/* 13 */
/* 2808 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2810 */	NdrFcShort( 0x4a ),	/* 74 */
/* 2812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2814 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x9,		/* 9 */

	/* Parameter name */

/* 2816 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2820 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 2822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cSig */

/* 2828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter signature */

/* 2834 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2838 */	NdrFcShort( 0x5ea ),	/* Type Offset=1514 */

	/* Parameter addrKind */

/* 2840 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2842 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 2846 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2848 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2850 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 2852 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2854 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2856 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 2858 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2860 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2864 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2866 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Close */

/* 2870 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2872 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2876 */	NdrFcShort( 0xe ),	/* 14 */
/* 2878 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2882 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2884 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2886 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2888 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2890 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSymAttribute */

/* 2892 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2894 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2898 */	NdrFcShort( 0xf ),	/* 15 */
/* 2900 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2902 */	NdrFcShort( 0x2a ),	/* 42 */
/* 2904 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2906 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter parent */

/* 2908 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter name */

/* 2914 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2916 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2918 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter cData */

/* 2920 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2922 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2924 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter data */

/* 2926 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2928 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2930 */	NdrFcShort( 0x5f8 ),	/* Type Offset=1528 */

	/* Return value */

/* 2932 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2934 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2936 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OpenNamespace */

/* 2938 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2940 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2944 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2946 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2948 */	NdrFcShort( 0x1a ),	/* 26 */
/* 2950 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2952 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter name */

/* 2954 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2956 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2958 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Return value */

/* 2960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2962 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CloseNamespace */

/* 2966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2972 */	NdrFcShort( 0x11 ),	/* 17 */
/* 2974 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2978 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2980 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2982 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2984 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2986 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UsingNamespace */

/* 2988 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2990 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2994 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2996 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2998 */	NdrFcShort( 0x1a ),	/* 26 */
/* 3000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3002 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter fullName */

/* 3004 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3006 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3008 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Return value */

/* 3010 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3012 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetMethodSourceRange */

/* 3016 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3018 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3022 */	NdrFcShort( 0x13 ),	/* 19 */
/* 3024 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3026 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3030 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter startDoc */

/* 3032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3036 */	NdrFcShort( 0x60a ),	/* Type Offset=1546 */

	/* Parameter startLine */

/* 3038 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter startColumn */

/* 3044 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3046 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endDoc */

/* 3050 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3052 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3054 */	NdrFcShort( 0x61c ),	/* Type Offset=1564 */

	/* Parameter endLine */

/* 3056 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3058 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endColumn */

/* 3062 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3064 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3068 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3070 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 3074 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3076 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3080 */	NdrFcShort( 0x14 ),	/* 20 */
/* 3082 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3084 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3086 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3088 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter emitter */

/* 3090 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3092 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3094 */	NdrFcShort( 0x62e ),	/* Type Offset=1582 */

	/* Parameter filename */

/* 3096 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3098 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3100 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pIStream */

/* 3102 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3106 */	NdrFcShort( 0x644 ),	/* Type Offset=1604 */

	/* Parameter fFullBuild */

/* 3108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3110 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3116 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugInfo */

/* 3120 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3122 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3126 */	NdrFcShort( 0x15 ),	/* 21 */
/* 3128 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3130 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3132 */	NdrFcShort( 0x40 ),	/* 64 */
/* 3134 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter pIDD */

/* 3136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 3138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cData */

/* 3142 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcData */

/* 3148 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter data */

/* 3154 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3158 */	NdrFcShort( 0x65e ),	/* Type Offset=1630 */

	/* Return value */

/* 3160 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3162 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineSequencePoints */

/* 3166 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3168 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3172 */	NdrFcShort( 0x16 ),	/* 22 */
/* 3174 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3176 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3180 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter document */

/* 3182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3186 */	NdrFcShort( 0x66c ),	/* Type Offset=1644 */

	/* Parameter spCount */

/* 3188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter offsets */

/* 3194 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3198 */	NdrFcShort( 0x67e ),	/* Type Offset=1662 */

	/* Parameter lines */

/* 3200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3204 */	NdrFcShort( 0x688 ),	/* Type Offset=1672 */

	/* Parameter columns */

/* 3206 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3210 */	NdrFcShort( 0x692 ),	/* Type Offset=1682 */

	/* Parameter endLines */

/* 3212 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3214 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3216 */	NdrFcShort( 0x69c ),	/* Type Offset=1692 */

	/* Parameter endColumns */

/* 3218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3220 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3222 */	NdrFcShort( 0x6a6 ),	/* Type Offset=1702 */

	/* Return value */

/* 3224 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3226 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemapToken */

/* 3230 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3232 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3236 */	NdrFcShort( 0x17 ),	/* 23 */
/* 3238 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3244 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter oldToken */

/* 3246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3248 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter newToken */

/* 3252 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3254 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3258 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3260 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3262 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize2 */

/* 3264 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3266 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3270 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3272 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3274 */	NdrFcShort( 0x3c ),	/* 60 */
/* 3276 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3278 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter emitter */

/* 3280 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3282 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3284 */	NdrFcShort( 0x6b0 ),	/* Type Offset=1712 */

	/* Parameter tempfilename */

/* 3286 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3288 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3290 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter pIStream */

/* 3292 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3294 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3296 */	NdrFcShort( 0x6c6 ),	/* Type Offset=1734 */

	/* Parameter fFullBuild */

/* 3298 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3300 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3302 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter finalfilename */

/* 3304 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3306 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3308 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Return value */

/* 3310 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3312 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineConstant */

/* 3316 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3318 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3322 */	NdrFcShort( 0x19 ),	/* 25 */
/* 3324 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3326 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3330 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter name */

/* 3332 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3334 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3336 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter value */

/* 3338 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3340 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3342 */	NdrFcShort( 0xb46 ),	/* Type Offset=2886 */

	/* Parameter cSig */

/* 3344 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3346 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3348 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter signature */

/* 3350 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3352 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3354 */	NdrFcShort( 0xb50 ),	/* Type Offset=2896 */

	/* Return value */

/* 3356 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3358 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Abort */

/* 3362 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3364 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3368 */	NdrFcShort( 0x1a ),	/* 26 */
/* 3370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3376 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 3378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3380 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineLocalVariable2 */

/* 3384 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3390 */	NdrFcShort( 0x1b ),	/* 27 */
/* 3392 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 3394 */	NdrFcShort( 0x5a ),	/* 90 */
/* 3396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3398 */	0x4,		/* Oi2 Flags:  has return, */
			0xa,		/* 10 */

	/* Parameter name */

/* 3400 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3402 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3404 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 3406 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3408 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter sigToken */

/* 3412 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3414 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addrKind */

/* 3418 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3420 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 3424 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3426 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 3430 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3432 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3434 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 3436 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3438 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter startOffset */

/* 3442 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3444 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3446 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter endOffset */

/* 3448 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3450 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3452 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3454 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3456 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3458 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineGlobalVariable2 */

/* 3460 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3462 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3466 */	NdrFcShort( 0x1c ),	/* 28 */
/* 3468 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3470 */	NdrFcShort( 0x4a ),	/* 74 */
/* 3472 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3474 */	0x4,		/* Oi2 Flags:  has return, */
			0x8,		/* 8 */

	/* Parameter name */

/* 3476 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3478 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3480 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter attributes */

/* 3482 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3484 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3486 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter sigToken */

/* 3488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3490 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addrKind */

/* 3494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3496 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr1 */

/* 3500 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3502 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3504 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr2 */

/* 3506 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3508 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter addr3 */

/* 3512 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3514 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3520 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineConstant2 */

/* 3524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3530 */	NdrFcShort( 0x1d ),	/* 29 */
/* 3532 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3534 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3538 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter name */

/* 3540 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3542 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3544 */	0x5,		/* FC_WCHAR */
			0x0,		/* 0 */

	/* Parameter value */

/* 3546 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 3548 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3550 */	NdrFcShort( 0xb6a ),	/* Type Offset=2922 */

	/* Parameter sigToken */

/* 3552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3554 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3560 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 18 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 20 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 22 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 24 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 26 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 30 */	NdrFcShort( 0x2 ),	/* Offset= 2 (32) */
/* 32 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 34 */	NdrFcLong( 0xb4ce6286 ),	/* -1261542778 */
/* 38 */	NdrFcShort( 0x2a6b ),	/* 10859 */
/* 40 */	NdrFcShort( 0x3712 ),	/* 14098 */
/* 42 */	0xa3,		/* 163 */
			0xb7,		/* 183 */
/* 44 */	0x1e,		/* 30 */
			0xe1,		/* 225 */
/* 46 */	0xda,		/* 218 */
			0xd4,		/* 212 */
/* 48 */	0x67,		/* 103 */
			0xb5,		/* 181 */
/* 50 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 62 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 64 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 66 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 68 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 70 */	NdrFcLong( 0xc ),	/* 12 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x0 ),	/* 0 */
/* 78 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 80 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 82 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 84 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 86 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 88 */	NdrFcShort( 0x2 ),	/* Offset= 2 (90) */
/* 90 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 92 */	NdrFcLong( 0xb4ce6286 ),	/* -1261542778 */
/* 96 */	NdrFcShort( 0x2a6b ),	/* 10859 */
/* 98 */	NdrFcShort( 0x3712 ),	/* 14098 */
/* 100 */	0xa3,		/* 163 */
			0xb7,		/* 183 */
/* 102 */	0x1e,		/* 30 */
			0xe1,		/* 225 */
/* 104 */	0xda,		/* 218 */
			0xd4,		/* 212 */
/* 106 */	0x67,		/* 103 */
			0xb5,		/* 181 */
/* 108 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 120 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 122 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 124 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 126 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 128 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 130 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 132 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 134 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (138) */
/* 138 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 140 */	NdrFcLong( 0xb4ce6286 ),	/* -1261542778 */
/* 144 */	NdrFcShort( 0x2a6b ),	/* 10859 */
/* 146 */	NdrFcShort( 0x3712 ),	/* 14098 */
/* 148 */	0xa3,		/* 163 */
			0xb7,		/* 183 */
/* 150 */	0x1e,		/* 30 */
			0xe1,		/* 225 */
/* 152 */	0xda,		/* 218 */
			0xd4,		/* 212 */
/* 154 */	0x67,		/* 103 */
			0xb5,		/* 181 */
/* 156 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 158 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 160 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 162 */	NdrFcShort( 0x2 ),	/* 2 */
/* 164 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 166 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 168 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 170 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 172 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 174 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 176 */	NdrFcShort( 0x8 ),	/* Offset= 8 (184) */
/* 178 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 184 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 186 */	NdrFcShort( 0x10 ),	/* 16 */
/* 188 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 190 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 192 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (178) */
			0x5b,		/* FC_END */
/* 196 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 198 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (184) */
/* 200 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 202 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (184) */
/* 204 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 206 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (184) */
/* 208 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 210 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 212 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 214 */	NdrFcShort( 0x1 ),	/* 1 */
/* 216 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 218 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 220 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 224 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 226 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 228 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 230 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 232 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 234 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 236 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 238 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 240 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 242 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 244 */	NdrFcShort( 0x1 ),	/* 1 */
/* 246 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 248 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 250 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 252 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 254 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 256 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 258 */	NdrFcShort( 0x1 ),	/* 1 */
/* 260 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 264 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 266 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0x1 ),	/* 1 */
/* 270 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 272 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 274 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 276 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 278 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 280 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 282 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 284 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (288) */
/* 288 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 290 */	NdrFcLong( 0x68005d0f ),	/* 1744854287 */
/* 294 */	NdrFcShort( 0xb8e0 ),	/* -18208 */
/* 296 */	NdrFcShort( 0x3b01 ),	/* 15105 */
/* 298 */	0x84,		/* 132 */
			0xd5,		/* 213 */
/* 300 */	0xa1,		/* 161 */
			0x1a,		/* 26 */
/* 302 */	0x94,		/* 148 */
			0x15,		/* 21 */
/* 304 */	0x49,		/* 73 */
			0x42,		/* 66 */
/* 306 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 308 */	NdrFcShort( 0x2 ),	/* Offset= 2 (310) */
/* 310 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 312 */	NdrFcLong( 0x68005d0f ),	/* 1744854287 */
/* 316 */	NdrFcShort( 0xb8e0 ),	/* -18208 */
/* 318 */	NdrFcShort( 0x3b01 ),	/* 15105 */
/* 320 */	0x84,		/* 132 */
			0xd5,		/* 213 */
/* 322 */	0xa1,		/* 161 */
			0x1a,		/* 26 */
/* 324 */	0x94,		/* 148 */
			0x15,		/* 21 */
/* 326 */	0x49,		/* 73 */
			0x42,		/* 66 */
/* 328 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 330 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 334 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 336 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 338 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 340 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 342 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 344 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 346 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 348 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 350 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 352 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 356 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 358 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 360 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 362 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 364 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 366 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 368 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 370 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 372 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x4 ),	/* 4 */
/* 376 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 380 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 382 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 384 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 386 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 388 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 390 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 392 */	NdrFcLong( 0x9f60eebe ),	/* -1621037378 */
/* 396 */	NdrFcShort( 0x2d9a ),	/* 11674 */
/* 398 */	NdrFcShort( 0x3f7c ),	/* 16252 */
/* 400 */	0xbf,		/* 191 */
			0x58,		/* 88 */
/* 402 */	0x80,		/* 128 */
			0xbc,		/* 188 */
/* 404 */	0x99,		/* 153 */
			0x1c,		/* 28 */
/* 406 */	0x60,		/* 96 */
			0xbb,		/* 187 */
/* 408 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 412 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 414 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 416 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 418 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 420 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 422 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (390) */
/* 424 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 426 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 428 */	NdrFcShort( 0x2 ),	/* Offset= 2 (430) */
/* 430 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 432 */	NdrFcLong( 0xdff7289 ),	/* 234844809 */
/* 436 */	NdrFcShort( 0x54f8 ),	/* 21752 */
/* 438 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 440 */	0xbd,		/* 189 */
			0x28,		/* 40 */
/* 442 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 444 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 446 */	0x49,		/* 73 */
			0xbd,		/* 189 */
/* 448 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 450 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 454 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 456 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 458 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 460 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 462 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 464 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 466 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 468 */	NdrFcShort( 0x2 ),	/* 2 */
/* 470 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 474 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 478 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 480 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (448) */
/* 482 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 484 */	
			0x1d,		/* FC_SMFARRAY */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
/* 488 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 490 */	
			0x1d,		/* FC_SMFARRAY */
			0x3,		/* 3 */
/* 492 */	NdrFcShort( 0x8 ),	/* 8 */
/* 494 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 496 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 498 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 500 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 502 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 504 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 506 */	NdrFcShort( 0x4 ),	/* 4 */
/* 508 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 510 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 512 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 514 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 516 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 520 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 522 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 524 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 526 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 528 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 530 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 532 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 538 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 540 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 544 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 546 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (514) */
/* 548 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 550 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x4 ),	/* 4 */
/* 554 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 556 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 558 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 560 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 562 */	NdrFcShort( 0x4 ),	/* 4 */
/* 564 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 566 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 568 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 570 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x4 ),	/* 4 */
/* 574 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 576 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 578 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 580 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 582 */	NdrFcShort( 0x4 ),	/* 4 */
/* 584 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 586 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 588 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 590 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 592 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 594 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 596 */	NdrFcShort( 0x2 ),	/* 2 */
/* 598 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 600 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 602 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 606 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 608 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 610 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 612 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 614 */	NdrFcLong( 0xdff7289 ),	/* 234844809 */
/* 618 */	NdrFcShort( 0x54f8 ),	/* 21752 */
/* 620 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 622 */	0xbd,		/* 189 */
			0x28,		/* 40 */
/* 624 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 626 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 628 */	0x49,		/* 73 */
			0xbd,		/* 189 */
/* 630 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x0 ),	/* 0 */
/* 634 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 636 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 638 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 640 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 642 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 644 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (612) */
/* 646 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 648 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 650 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 652 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 654 */	NdrFcLong( 0x9f60eebe ),	/* -1621037378 */
/* 658 */	NdrFcShort( 0x2d9a ),	/* 11674 */
/* 660 */	NdrFcShort( 0x3f7c ),	/* 16252 */
/* 662 */	0xbf,		/* 191 */
			0x58,		/* 88 */
/* 664 */	0x80,		/* 128 */
			0xbc,		/* 188 */
/* 666 */	0x99,		/* 153 */
			0x1c,		/* 28 */
/* 668 */	0x60,		/* 96 */
			0xbb,		/* 187 */
/* 670 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 676 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 678 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 682 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 684 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (652) */
/* 686 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 688 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 690 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 694 */	NdrFcShort( 0x2 ),	/* Offset= 2 (696) */
/* 696 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 698 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 702 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 704 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 706 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 708 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 710 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 712 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 714 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 716 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 718 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 720 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 724 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 726 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 728 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 730 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 732 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 734 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 736 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 742 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 744 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 746 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 748 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 750 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (718) */
/* 752 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 754 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 756 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 758 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 760 */	NdrFcShort( 0x2 ),	/* Offset= 2 (762) */
/* 762 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 764 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 768 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 770 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 772 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 774 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 776 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 778 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 780 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 782 */	NdrFcShort( 0x2 ),	/* Offset= 2 (784) */
/* 784 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 786 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 790 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 792 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 794 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 796 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 798 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 800 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 802 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 804 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 806 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 808 */	NdrFcLong( 0x9f60eebe ),	/* -1621037378 */
/* 812 */	NdrFcShort( 0x2d9a ),	/* 11674 */
/* 814 */	NdrFcShort( 0x3f7c ),	/* 16252 */
/* 816 */	0xbf,		/* 191 */
			0x58,		/* 88 */
/* 818 */	0x80,		/* 128 */
			0xbc,		/* 188 */
/* 820 */	0x99,		/* 153 */
			0x1c,		/* 28 */
/* 822 */	0x60,		/* 96 */
			0xbb,		/* 187 */
/* 824 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 832 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 834 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 836 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 838 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (806) */
/* 840 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 842 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 844 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 846 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 848 */	NdrFcLong( 0x9f60eebe ),	/* -1621037378 */
/* 852 */	NdrFcShort( 0x2d9a ),	/* 11674 */
/* 854 */	NdrFcShort( 0x3f7c ),	/* 16252 */
/* 856 */	0xbf,		/* 191 */
			0x58,		/* 88 */
/* 858 */	0x80,		/* 128 */
			0xbc,		/* 188 */
/* 860 */	0x99,		/* 153 */
			0x1c,		/* 28 */
/* 862 */	0x60,		/* 96 */
			0xbb,		/* 187 */
/* 864 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
/* 868 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 870 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 872 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 874 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 876 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 878 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (846) */
/* 880 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 882 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 884 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 888 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 890 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 892 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 894 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 896 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 898 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 900 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 902 */	NdrFcShort( 0x2 ),	/* Offset= 2 (904) */
/* 904 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 906 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 910 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 912 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 914 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 916 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 918 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 920 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 922 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 924 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 926 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 928 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 930 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 932 */	NdrFcShort( 0x1 ),	/* 1 */
/* 934 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 936 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 938 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 940 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 942 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 944 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 946 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 948 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 950 */	NdrFcLong( 0xdff7289 ),	/* 234844809 */
/* 954 */	NdrFcShort( 0x54f8 ),	/* 21752 */
/* 956 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 958 */	0xbd,		/* 189 */
			0x28,		/* 40 */
/* 960 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 962 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 964 */	0x49,		/* 73 */
			0xbd,		/* 189 */
/* 966 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 970 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 972 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 974 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 976 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 978 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 980 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (948) */
/* 982 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 984 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0x0 ),	/* 0 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 996 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 998 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1000 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1002 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1004 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1006 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1008 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1010 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1012 */	NdrFcLong( 0xc ),	/* 12 */
/* 1016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1018 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1020 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1022 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1024 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1026 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1028 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1030 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1032 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1034 */	NdrFcLong( 0xc ),	/* 12 */
/* 1038 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1042 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1044 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1046 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1048 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1050 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1052 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1054 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1056 */	NdrFcLong( 0xc ),	/* 12 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1064 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1066 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1068 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1070 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1072 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1074 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1076 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 1078 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1080 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1082 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1084 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1086 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1088 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1090 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1092 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 1096 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 1098 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 1100 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 1102 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 1104 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 1106 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 1108 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1110 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1112 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1114 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 1118 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 1120 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 1122 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 1124 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 1126 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 1128 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 1130 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1134 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1136 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1138 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1140 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1142 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1144 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1112) */
/* 1146 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1148 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1150 */	NdrFcLong( 0x40de4037 ),	/* 1088307255 */
/* 1154 */	NdrFcShort( 0x7c81 ),	/* 31873 */
/* 1156 */	NdrFcShort( 0x3e1e ),	/* 15902 */
/* 1158 */	0xb0,		/* 176 */
			0x22,		/* 34 */
/* 1160 */	0xae,		/* 174 */
			0x1a,		/* 26 */
/* 1162 */	0xbf,		/* 191 */
			0xf2,		/* 242 */
/* 1164 */	0xca,		/* 202 */
			0x8,		/* 8 */
/* 1166 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1168 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1170 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1172 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1174 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1176 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 1180 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 1182 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 1184 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 1186 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 1188 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 1190 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 1192 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1194 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1196 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1200) */
/* 1200 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1202 */	NdrFcLong( 0xb62b923c ),	/* -1238658500 */
/* 1206 */	NdrFcShort( 0xb500 ),	/* -19200 */
/* 1208 */	NdrFcShort( 0x3158 ),	/* 12632 */
/* 1210 */	0xa5,		/* 165 */
			0x43,		/* 67 */
/* 1212 */	0x24,		/* 36 */
			0xf3,		/* 243 */
/* 1214 */	0x7,		/* 7 */
			0xa8,		/* 168 */
/* 1216 */	0xb7,		/* 183 */
			0xe1,		/* 225 */
/* 1218 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1220 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1222) */
/* 1222 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1224 */	NdrFcLong( 0x68005d0f ),	/* 1744854287 */
/* 1228 */	NdrFcShort( 0xb8e0 ),	/* -18208 */
/* 1230 */	NdrFcShort( 0x3b01 ),	/* 15105 */
/* 1232 */	0x84,		/* 132 */
			0xd5,		/* 213 */
/* 1234 */	0xa1,		/* 161 */
			0x1a,		/* 26 */
/* 1236 */	0x94,		/* 148 */
			0x15,		/* 21 */
/* 1238 */	0x49,		/* 73 */
			0x42,		/* 66 */
/* 1240 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1242 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1244 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1246 */	NdrFcLong( 0x68005d0f ),	/* 1744854287 */
/* 1250 */	NdrFcShort( 0xb8e0 ),	/* -18208 */
/* 1252 */	NdrFcShort( 0x3b01 ),	/* 15105 */
/* 1254 */	0x84,		/* 132 */
			0xd5,		/* 213 */
/* 1256 */	0xa1,		/* 161 */
			0x1a,		/* 26 */
/* 1258 */	0x94,		/* 148 */
			0x15,		/* 21 */
/* 1260 */	0x49,		/* 73 */
			0x42,		/* 66 */
/* 1262 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1266 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1268 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1270 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1274 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1276 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1244) */
/* 1278 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1280 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1282 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1284 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1286 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1288 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1290 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1292 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1294 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1296 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1298 */	NdrFcLong( 0x9f60eebe ),	/* -1621037378 */
/* 1302 */	NdrFcShort( 0x2d9a ),	/* 11674 */
/* 1304 */	NdrFcShort( 0x3f7c ),	/* 16252 */
/* 1306 */	0xbf,		/* 191 */
			0x58,		/* 88 */
/* 1308 */	0x80,		/* 128 */
			0xbc,		/* 188 */
/* 1310 */	0x99,		/* 153 */
			0x1c,		/* 28 */
/* 1312 */	0x60,		/* 96 */
			0xbb,		/* 187 */
/* 1314 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1318 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1320 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1322 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1324 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1326 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1328 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1296) */
/* 1330 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1332 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1334 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1336 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1338 */	NdrFcLong( 0xdff7289 ),	/* 234844809 */
/* 1342 */	NdrFcShort( 0x54f8 ),	/* 21752 */
/* 1344 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 1346 */	0xbd,		/* 189 */
			0x28,		/* 40 */
/* 1348 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1350 */	0xf8,		/* 248 */
			0x8,		/* 8 */
/* 1352 */	0x49,		/* 73 */
			0xbd,		/* 189 */
/* 1354 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1360 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1362 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1364 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1368 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1336) */
/* 1370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1372 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1374 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1376 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 1378 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1380 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1382 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1384 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1386 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1388 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1390 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1392 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1394 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1396 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1398 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1400 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1402 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1406 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1408 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1410 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1412 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1414 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1416 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1418 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1420 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1422 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1424 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1426 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1428 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1430 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1432 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1434 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1436 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1438 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1440 */	
			0x11, 0x0,	/* FC_RP */
/* 1442 */	NdrFcShort( 0xfffffb16 ),	/* Offset= -1258 (184) */
/* 1444 */	
			0x11, 0x0,	/* FC_RP */
/* 1446 */	NdrFcShort( 0xfffffb12 ),	/* Offset= -1262 (184) */
/* 1448 */	
			0x11, 0x0,	/* FC_RP */
/* 1450 */	NdrFcShort( 0xfffffb0e ),	/* Offset= -1266 (184) */
/* 1452 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1454 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1456) */
/* 1456 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1458 */	NdrFcLong( 0xb01fafeb ),	/* -1340100629 */
/* 1462 */	NdrFcShort( 0xc450 ),	/* -15280 */
/* 1464 */	NdrFcShort( 0x3a4d ),	/* 14925 */
/* 1466 */	0xbe,		/* 190 */
			0xec,		/* 236 */
/* 1468 */	0xb4,		/* 180 */
			0xce,		/* 206 */
/* 1470 */	0xec,		/* 236 */
			0x1,		/* 1 */
/* 1472 */	0xe0,		/* 224 */
			0x6,		/* 6 */
/* 1474 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1476 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1478 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1480 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1482 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1484 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1486 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1490 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1492 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1494 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1496 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1498 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1500 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1502 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1504 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1506 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1508 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1510 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1512 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1514 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1516 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1518 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1522 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1524 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1526 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1528 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1530 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1532 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1534 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1536 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1538 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1540 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1542 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1544 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1546 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1548 */	NdrFcLong( 0xb01fafeb ),	/* -1340100629 */
/* 1552 */	NdrFcShort( 0xc450 ),	/* -15280 */
/* 1554 */	NdrFcShort( 0x3a4d ),	/* 14925 */
/* 1556 */	0xbe,		/* 190 */
			0xec,		/* 236 */
/* 1558 */	0xb4,		/* 180 */
			0xce,		/* 206 */
/* 1560 */	0xec,		/* 236 */
			0x1,		/* 1 */
/* 1562 */	0xe0,		/* 224 */
			0x6,		/* 6 */
/* 1564 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1566 */	NdrFcLong( 0xb01fafeb ),	/* -1340100629 */
/* 1570 */	NdrFcShort( 0xc450 ),	/* -15280 */
/* 1572 */	NdrFcShort( 0x3a4d ),	/* 14925 */
/* 1574 */	0xbe,		/* 190 */
			0xec,		/* 236 */
/* 1576 */	0xb4,		/* 180 */
			0xce,		/* 206 */
/* 1578 */	0xec,		/* 236 */
			0x1,		/* 1 */
/* 1580 */	0xe0,		/* 224 */
			0x6,		/* 6 */
/* 1582 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1584 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1594 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1596 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1598 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1600 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1602 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1604 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1606 */	NdrFcLong( 0xc ),	/* 12 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1614 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1616 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1618 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1620 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1622 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1624 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1626 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 1628 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1630 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 1632 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1634 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1636 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1638 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1640 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1642 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1644 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1646 */	NdrFcLong( 0xb01fafeb ),	/* -1340100629 */
/* 1650 */	NdrFcShort( 0xc450 ),	/* -15280 */
/* 1652 */	NdrFcShort( 0x3a4d ),	/* 14925 */
/* 1654 */	0xbe,		/* 190 */
			0xec,		/* 236 */
/* 1656 */	0xb4,		/* 180 */
			0xce,		/* 206 */
/* 1658 */	0xec,		/* 236 */
			0x1,		/* 1 */
/* 1660 */	0xe0,		/* 224 */
			0x6,		/* 6 */
/* 1662 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1664 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1666 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1670 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1672 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1674 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1676 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1678 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1680 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1682 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1684 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1686 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1688 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1690 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1692 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1694 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1696 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1698 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1700 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1702 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1704 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1706 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1708 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1710 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1712 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1714 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1722 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1724 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1726 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1728 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1730 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1732 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1734 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1736 */	NdrFcLong( 0xc ),	/* 12 */
/* 1740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1744 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1746 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1748 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1750 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1752 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1754 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1756 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1758 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 1760 */	
			0x12, 0x0,	/* FC_UP */
/* 1762 */	NdrFcShort( 0x450 ),	/* Offset= 1104 (2866) */
/* 1764 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1766 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1768 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 1770 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1772) */
/* 1772 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1774 */	NdrFcShort( 0x2f ),	/* 47 */
/* 1776 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1780 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 1782 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1786 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1788 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1792 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 1794 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1798 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1800 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1804 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1806 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1810 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1812 */	NdrFcLong( 0xb ),	/* 11 */
/* 1816 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1818 */	NdrFcLong( 0xa ),	/* 10 */
/* 1822 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1824 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1828 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (2060) */
/* 1830 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1834 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1836 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1840 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (2066) */
/* 1842 */	NdrFcLong( 0xd ),	/* 13 */
/* 1846 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (2090) */
/* 1848 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1852 */	NdrFcShort( 0x100 ),	/* Offset= 256 (2108) */
/* 1854 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 1858 */	NdrFcShort( 0x10c ),	/* Offset= 268 (2126) */
/* 1860 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1864 */	NdrFcShort( 0x350 ),	/* Offset= 848 (2712) */
/* 1866 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 1870 */	NdrFcShort( 0x34a ),	/* Offset= 842 (2712) */
/* 1872 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 1876 */	NdrFcShort( 0x348 ),	/* Offset= 840 (2716) */
/* 1878 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 1882 */	NdrFcShort( 0x346 ),	/* Offset= 838 (2720) */
/* 1884 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 1888 */	NdrFcShort( 0x344 ),	/* Offset= 836 (2724) */
/* 1890 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 1894 */	NdrFcShort( 0x342 ),	/* Offset= 834 (2728) */
/* 1896 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 1900 */	NdrFcShort( 0x340 ),	/* Offset= 832 (2732) */
/* 1902 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 1906 */	NdrFcShort( 0x33e ),	/* Offset= 830 (2736) */
/* 1908 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 1912 */	NdrFcShort( 0x33c ),	/* Offset= 828 (2740) */
/* 1914 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 1918 */	NdrFcShort( 0x33a ),	/* Offset= 826 (2744) */
/* 1920 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 1924 */	NdrFcShort( 0x338 ),	/* Offset= 824 (2748) */
/* 1926 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 1930 */	NdrFcShort( 0x336 ),	/* Offset= 822 (2752) */
/* 1932 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 1936 */	NdrFcShort( 0x334 ),	/* Offset= 820 (2756) */
/* 1938 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 1942 */	NdrFcShort( 0x336 ),	/* Offset= 822 (2764) */
/* 1944 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 1948 */	NdrFcShort( 0x346 ),	/* Offset= 838 (2786) */
/* 1950 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 1954 */	NdrFcShort( 0x356 ),	/* Offset= 854 (2808) */
/* 1956 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 1960 */	NdrFcShort( 0x35c ),	/* Offset= 860 (2820) */
/* 1962 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1966 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1968 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1972 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1974 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1978 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1980 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1984 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 1986 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1990 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1992 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1996 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1998 */	NdrFcLong( 0xe ),	/* 14 */
/* 2002 */	NdrFcShort( 0x33a ),	/* Offset= 826 (2828) */
/* 2004 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2008 */	NdrFcShort( 0x33e ),	/* Offset= 830 (2838) */
/* 2010 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2014 */	NdrFcShort( 0x33c ),	/* Offset= 828 (2842) */
/* 2016 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2020 */	NdrFcShort( 0x33a ),	/* Offset= 826 (2846) */
/* 2022 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2026 */	NdrFcShort( 0x338 ),	/* Offset= 824 (2850) */
/* 2028 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 2032 */	NdrFcShort( 0x336 ),	/* Offset= 822 (2854) */
/* 2034 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2038 */	NdrFcShort( 0x334 ),	/* Offset= 820 (2858) */
/* 2040 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2044 */	NdrFcShort( 0x332 ),	/* Offset= 818 (2862) */
/* 2046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2050 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2050) */
/* 2052 */	NdrFcLong( 0x1 ),	/* 1 */
/* 2056 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2056) */
/* 2058 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2057) */
/* 2060 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 2062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2064 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 2066 */	
			0x12, 0x0,	/* FC_UP */
/* 2068 */	NdrFcShort( 0xc ),	/* Offset= 12 (2080) */
/* 2070 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 2072 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2074 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 2076 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 2078 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 2080 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 2082 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2084 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (2070) */
/* 2086 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2088 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2090 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2092 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2100 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2102 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2104 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2106 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2108 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2110 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 2114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2118 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2120 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2122 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2124 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2126 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2128 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2130) */
/* 2130 */	
			0x12, 0x0,	/* FC_UP */
/* 2132 */	NdrFcShort( 0x232 ),	/* Offset= 562 (2694) */
/* 2134 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 2136 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2138 */	NdrFcShort( 0xa ),	/* 10 */
/* 2140 */	NdrFcLong( 0x8 ),	/* 8 */
/* 2144 */	NdrFcShort( 0x58 ),	/* Offset= 88 (2232) */
/* 2146 */	NdrFcLong( 0xd ),	/* 13 */
/* 2150 */	NdrFcShort( 0x8a ),	/* Offset= 138 (2288) */
/* 2152 */	NdrFcLong( 0x9 ),	/* 9 */
/* 2156 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (2340) */
/* 2158 */	NdrFcLong( 0xc ),	/* 12 */
/* 2162 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (2386) */
/* 2164 */	NdrFcLong( 0x24 ),	/* 36 */
/* 2168 */	NdrFcShort( 0x138 ),	/* Offset= 312 (2480) */
/* 2170 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 2174 */	NdrFcShort( 0x166 ),	/* Offset= 358 (2532) */
/* 2176 */	NdrFcLong( 0x10 ),	/* 16 */
/* 2180 */	NdrFcShort( 0x17e ),	/* Offset= 382 (2562) */
/* 2182 */	NdrFcLong( 0x2 ),	/* 2 */
/* 2186 */	NdrFcShort( 0x196 ),	/* Offset= 406 (2592) */
/* 2188 */	NdrFcLong( 0x3 ),	/* 3 */
/* 2192 */	NdrFcShort( 0x1ae ),	/* Offset= 430 (2622) */
/* 2194 */	NdrFcLong( 0x14 ),	/* 20 */
/* 2198 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2652) */
/* 2200 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2199) */
/* 2202 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2206 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2210 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2212 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2218 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2224 */	0x12, 0x0,	/* FC_UP */
/* 2226 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (2080) */
/* 2228 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2232 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2236 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2238 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2240 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2242 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2244 */	0x11, 0x0,	/* FC_RP */
/* 2246 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (2202) */
/* 2248 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2250 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2252 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2264 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2266 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2268 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2270 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2282 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2284 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2252) */
/* 2286 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2288 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2290 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2294 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2300) */
/* 2296 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2298 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2300 */	
			0x11, 0x0,	/* FC_RP */
/* 2302 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2270) */
/* 2304 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2306 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 2310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2316 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2318 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2320 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2322 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2326 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2330 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2334 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2336 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2304) */
/* 2338 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2340 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2346 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2352) */
/* 2348 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2350 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2352 */	
			0x11, 0x0,	/* FC_RP */
/* 2354 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2322) */
/* 2356 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2358 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2360 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2364 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2366 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2368 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2372 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2378 */	0x12, 0x0,	/* FC_UP */
/* 2380 */	NdrFcShort( 0x1e6 ),	/* Offset= 486 (2866) */
/* 2382 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2384 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2386 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2388 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2392 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2398) */
/* 2394 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2396 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2398 */	
			0x11, 0x0,	/* FC_RP */
/* 2400 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (2356) */
/* 2402 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2404 */	NdrFcLong( 0x2f ),	/* 47 */
/* 2408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2412 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2414 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2416 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2418 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2420 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 2422 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2424 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2426 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2428 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 2430 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2432 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2436 */	NdrFcShort( 0xa ),	/* Offset= 10 (2446) */
/* 2438 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2440 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2442 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (2402) */
/* 2444 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2446 */	
			0x12, 0x0,	/* FC_UP */
/* 2448 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (2420) */
/* 2450 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2452 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2454 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2458 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2460 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 2462 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2464 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2466 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2472 */	0x12, 0x0,	/* FC_UP */
/* 2474 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (2430) */
/* 2476 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2478 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2480 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2486 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2492) */
/* 2488 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2490 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2492 */	
			0x11, 0x0,	/* FC_RP */
/* 2494 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (2450) */
/* 2496 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2498 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2506 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2508 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2510 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2512 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2514 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2516 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2518 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2522 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2526 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2528 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2496) */
/* 2530 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2532 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2534 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2538 */	NdrFcShort( 0xa ),	/* Offset= 10 (2548) */
/* 2540 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2542 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2544 */	NdrFcShort( 0xfffff6c8 ),	/* Offset= -2360 (184) */
/* 2546 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2548 */	
			0x11, 0x0,	/* FC_RP */
/* 2550 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2514) */
/* 2552 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 2554 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2556 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2560 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 2562 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2564 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2566 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2568 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2570 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2572 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2574 */	0x12, 0x0,	/* FC_UP */
/* 2576 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (2552) */
/* 2578 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2580 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2582 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 2584 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2586 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2590 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 2592 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2594 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2596 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2598 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2600 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2602 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2604 */	0x12, 0x0,	/* FC_UP */
/* 2606 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (2582) */
/* 2608 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2610 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2612 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2614 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2616 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2620 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2622 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2624 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2626 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2628 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2630 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2632 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2634 */	0x12, 0x0,	/* FC_UP */
/* 2636 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (2612) */
/* 2638 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2640 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2642 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 2644 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2646 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2650 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 2652 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 2654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2656 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 2658 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 2660 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2662 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2664 */	0x12, 0x0,	/* FC_UP */
/* 2666 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (2642) */
/* 2668 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 2670 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2672 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 2674 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2676 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2678 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2680 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2682 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2684 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 2686 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 2688 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2690 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (2672) */
/* 2692 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2694 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2696 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2698 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (2680) */
/* 2700 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2700) */
/* 2702 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 2704 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2706 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2708 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (2134) */
/* 2710 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2712 */	
			0x12, 0x0,	/* FC_UP */
/* 2714 */	NdrFcShort( 0xfffffee4 ),	/* Offset= -284 (2430) */
/* 2716 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2718 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 2720 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2722 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 2724 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2726 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2728 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2730 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2732 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2734 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 2736 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2738 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 2740 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2742 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 2744 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2746 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2748 */	
			0x12, 0x0,	/* FC_UP */
/* 2750 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (2060) */
/* 2752 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2754 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 2756 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2758 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2760) */
/* 2760 */	
			0x12, 0x0,	/* FC_UP */
/* 2762 */	NdrFcShort( 0xfffffd56 ),	/* Offset= -682 (2080) */
/* 2764 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2766 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2768) */
/* 2768 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2770 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2778 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2780 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2782 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2784 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2786 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2788 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2790) */
/* 2790 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2792 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 2796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2800 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2802 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2804 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2806 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2808 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2810 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2812) */
/* 2812 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2814 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2816) */
/* 2816 */	
			0x12, 0x0,	/* FC_UP */
/* 2818 */	NdrFcShort( 0xffffff84 ),	/* Offset= -124 (2694) */
/* 2820 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2822 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2824) */
/* 2824 */	
			0x12, 0x0,	/* FC_UP */
/* 2826 */	NdrFcShort( 0x28 ),	/* Offset= 40 (2866) */
/* 2828 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 2830 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2832 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2834 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 2836 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 2838 */	
			0x12, 0x0,	/* FC_UP */
/* 2840 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (2828) */
/* 2842 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2844 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 2846 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2848 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 2850 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2852 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2854 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2856 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 2858 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2860 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2862 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2864 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2866 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2868 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2872 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2872) */
/* 2874 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2876 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 2878 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 2880 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2882 */	NdrFcShort( 0xfffffba2 ),	/* Offset= -1118 (1764) */
/* 2884 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2886 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 2888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2890 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2894 */	NdrFcShort( 0xfffffb92 ),	/* Offset= -1134 (1760) */
/* 2896 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 2898 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2900 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2902 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2904 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 2906 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2908 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 2910 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2912 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 2914 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2916 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/* 2918 */	
			0x12, 0x0,	/* FC_UP */
/* 2920 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (2866) */
/* 2922 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 2924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2926 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2928 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2930 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (2918) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };



/* Standard interface: __MIDL_itf_corsym_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISymUnmanagedBinder, ver. 0.0,
   GUID={0xAA544D42,0x28CB,0x11d3,{0xBD,0x22,0x00,0x00,0xF8,0x08,0x49,0xBD}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedBinder_FormatStringOffsetTable[] =
    {
    0,
    46
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedBinder_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedBinder_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedBinder_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedBinder_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ISymUnmanagedBinderProxyVtbl = 
{
    &ISymUnmanagedBinder_ProxyInfo,
    &IID_ISymUnmanagedBinder,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedBinder::GetReaderForFile */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedBinder::GetReaderFromStream */
};

const CInterfaceStubVtbl _ISymUnmanagedBinderStubVtbl =
{
    &IID_ISymUnmanagedBinder,
    &ISymUnmanagedBinder_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_corsym_0110, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISymUnmanagedBinder2, ver. 0.0,
   GUID={0xACCEE350,0x89AF,0x4ccb,{0x8B,0x40,0x1C,0x2C,0x4C,0x6F,0x94,0x34}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedBinder2_FormatStringOffsetTable[] =
    {
    0,
    46,
    86
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedBinder2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedBinder2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedBinder2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedBinder2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ISymUnmanagedBinder2ProxyVtbl = 
{
    &ISymUnmanagedBinder2_ProxyInfo,
    &IID_ISymUnmanagedBinder2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedBinder::GetReaderForFile */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedBinder::GetReaderFromStream */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedBinder2::GetReaderForFile2 */
};

const CInterfaceStubVtbl _ISymUnmanagedBinder2StubVtbl =
{
    &IID_ISymUnmanagedBinder2,
    &ISymUnmanagedBinder2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_corsym_0111, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISymUnmanagedDispose, ver. 0.0,
   GUID={0x969708D2,0x05E5,0x4861,{0xA3,0xB0,0x96,0xE4,0x73,0xCD,0xF6,0x3F}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedDispose_FormatStringOffsetTable[] =
    {
    138
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDispose_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDispose_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedDispose_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDispose_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ISymUnmanagedDisposeProxyVtbl = 
{
    &ISymUnmanagedDispose_ProxyInfo,
    &IID_ISymUnmanagedDispose,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDispose::Destroy */
};

const CInterfaceStubVtbl _ISymUnmanagedDisposeStubVtbl =
{
    &IID_ISymUnmanagedDispose,
    &ISymUnmanagedDispose_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedDocument, ver. 0.0,
   GUID={0x40DE4037,0x7C81,0x3E1E,{0xB0,0x22,0xAE,0x1A,0xBF,0xF2,0xCA,0x08}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedDocument_FormatStringOffsetTable[] =
    {
    160,
    200,
    228,
    256,
    284,
    312,
    352,
    386,
    414,
    442
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDocument_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDocument_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedDocument_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDocument_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _ISymUnmanagedDocumentProxyVtbl = 
{
    &ISymUnmanagedDocument_ProxyInfo,
    &IID_ISymUnmanagedDocument,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetURL */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetDocumentType */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetLanguage */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetLanguageVendor */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetCheckSumAlgorithmId */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetCheckSum */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::FindClosestLine */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::HasEmbeddedSource */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetSourceLength */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocument::GetSourceRange */
};

const CInterfaceStubVtbl _ISymUnmanagedDocumentStubVtbl =
{
    &IID_ISymUnmanagedDocument,
    &ISymUnmanagedDocument_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedDocumentWriter, ver. 0.0,
   GUID={0xB01FAFEB,0xC450,0x3A4D,{0xBE,0xEC,0xB4,0xCE,0xEC,0x01,0xE0,0x06}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedDocumentWriter_FormatStringOffsetTable[] =
    {
    506,
    540
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedDocumentWriter_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDocumentWriter_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedDocumentWriter_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedDocumentWriter_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ISymUnmanagedDocumentWriterProxyVtbl = 
{
    &ISymUnmanagedDocumentWriter_ProxyInfo,
    &IID_ISymUnmanagedDocumentWriter,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocumentWriter::SetSource */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedDocumentWriter::SetCheckSum */
};

const CInterfaceStubVtbl _ISymUnmanagedDocumentWriterStubVtbl =
{
    &IID_ISymUnmanagedDocumentWriter,
    &ISymUnmanagedDocumentWriter_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedMethod, ver. 0.0,
   GUID={0xB62B923C,0xB500,0x3158,{0xA5,0x43,0x24,0xF3,0x07,0xA8,0xB7,0xE1}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedMethod_FormatStringOffsetTable[] =
    {
    580,
    608,
    636,
    664,
    698,
    744,
    802,
    842,
    870,
    916
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedMethod_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedMethod_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedMethod_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedMethod_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _ISymUnmanagedMethodProxyVtbl = 
{
    &ISymUnmanagedMethod_ProxyInfo,
    &IID_ISymUnmanagedMethod,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetToken */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetSequencePointCount */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetRootScope */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetScopeFromOffset */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetOffset */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetRanges */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetParameters */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetSourceStartEnd */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedMethod::GetSequencePoints */
};

const CInterfaceStubVtbl _ISymUnmanagedMethodStubVtbl =
{
    &IID_ISymUnmanagedMethod,
    &ISymUnmanagedMethod_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedNamespace, ver. 0.0,
   GUID={0x0DFF7289,0x54F8,0x11d3,{0xBD,0x28,0x00,0x00,0xF8,0x08,0x49,0xBD}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedNamespace_FormatStringOffsetTable[] =
    {
    986,
    1026,
    1066
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedNamespace_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedNamespace_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedNamespace_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedNamespace_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ISymUnmanagedNamespaceProxyVtbl = 
{
    &ISymUnmanagedNamespace_ProxyInfo,
    &IID_ISymUnmanagedNamespace,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedNamespace::GetName */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedNamespace::GetNamespaces */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedNamespace::GetVariables */
};

const CInterfaceStubVtbl _ISymUnmanagedNamespaceStubVtbl =
{
    &IID_ISymUnmanagedNamespace,
    &ISymUnmanagedNamespace_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedReader, ver. 0.0,
   GUID={0xB4CE6286,0x2A6B,0x3712,{0xA3,0xB7,0x1E,0xE1,0xDA,0xD4,0x67,0xB5}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedReader_FormatStringOffsetTable[] =
    {
    1106,
    1158,
    1198,
    1226,
    1260,
    1300,
    1346,
    1386,
    1432,
    1484,
    1524,
    1570,
    1604,
    1638,
    1678,
    1736,
    1776
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedReader_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedReader_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedReader_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedReader_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(20) _ISymUnmanagedReaderProxyVtbl = 
{
    &ISymUnmanagedReader_ProxyInfo,
    &IID_ISymUnmanagedReader,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetDocument */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetDocuments */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetUserEntryPoint */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetMethodByVersion */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetVariables */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetGlobalVariables */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetMethodFromDocumentPosition */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetSymAttribute */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetNamespaces */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::Initialize */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::UpdateSymbolStore */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::ReplaceSymbolStore */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetSymbolStoreFileName */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetMethodsFromDocumentPosition */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetDocumentVersion */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedReader::GetMethodVersion */
};

const CInterfaceStubVtbl _ISymUnmanagedReaderStubVtbl =
{
    &IID_ISymUnmanagedReader,
    &ISymUnmanagedReader_ServerInfo,
    20,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedScope, ver. 0.0,
   GUID={0x68005D0F,0xB8E0,0x3B01,{0x84,0xD5,0xA1,0x1A,0x94,0x15,0x49,0x42}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedScope_FormatStringOffsetTable[] =
    {
    1810,
    1838,
    1866,
    1906,
    1934,
    1962,
    1990,
    2030
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedScope_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedScope_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedScope_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedScope_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _ISymUnmanagedScopeProxyVtbl = 
{
    &ISymUnmanagedScope_ProxyInfo,
    &IID_ISymUnmanagedScope,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetParent */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetChildren */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetStartOffset */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetEndOffset */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetLocalCount */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetLocals */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedScope::GetNamespaces */
};

const CInterfaceStubVtbl _ISymUnmanagedScopeStubVtbl =
{
    &IID_ISymUnmanagedScope,
    &ISymUnmanagedScope_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedVariable, ver. 0.0,
   GUID={0x9F60EEBE,0x2D9A,0x3F7C,{0xBF,0x58,0x80,0xBC,0x99,0x1C,0x60,0xBB}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedVariable_FormatStringOffsetTable[] =
    {
    2070,
    2110,
    2138,
    2178,
    2206,
    2234,
    2262,
    2290,
    2318
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedVariable_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedVariable_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedVariable_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedVariable_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _ISymUnmanagedVariableProxyVtbl = 
{
    &ISymUnmanagedVariable_ProxyInfo,
    &IID_ISymUnmanagedVariable,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetName */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetAttributes */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetSignature */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetAddressKind */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetAddressField1 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetAddressField2 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetAddressField3 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetStartOffset */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedVariable::GetEndOffset */
};

const CInterfaceStubVtbl _ISymUnmanagedVariableStubVtbl =
{
    &IID_ISymUnmanagedVariable,
    &ISymUnmanagedVariable_ServerInfo,
    12,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedWriter, ver. 0.0,
   GUID={0xED14AA72,0x78E2,0x4884,{0x84,0xE2,0x33,0x42,0x93,0xAE,0x52,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedWriter_FormatStringOffsetTable[] =
    {
    2346,
    2398,
    2426,
    2454,
    2476,
    2510,
    2538,
    2578,
    2660,
    2724,
    2800,
    2870,
    2892,
    2938,
    2966,
    2988,
    3016,
    3074,
    3120,
    3166,
    3230,
    3264,
    3316,
    3362
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedWriter_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedWriter_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedWriter_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedWriter_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(27) _ISymUnmanagedWriterProxyVtbl = 
{
    &ISymUnmanagedWriter_ProxyInfo,
    &IID_ISymUnmanagedWriter,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineDocument */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetUserEntryPoint */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenScope */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseScope */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetScopeRange */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineLocalVariable */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineParameter */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineField */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineGlobalVariable */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Close */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetSymAttribute */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::UsingNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetMethodSourceRange */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Initialize */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::GetDebugInfo */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineSequencePoints */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::RemapToken */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Initialize2 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineConstant */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Abort */
};

const CInterfaceStubVtbl _ISymUnmanagedWriterStubVtbl =
{
    &IID_ISymUnmanagedWriter,
    &ISymUnmanagedWriter_ServerInfo,
    27,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISymUnmanagedWriter2, ver. 0.0,
   GUID={0x0B97726E,0x9E6D,0x4f05,{0x9A,0x26,0x42,0x40,0x22,0x09,0x3C,0xAA}} */

#pragma code_seg(".orpc")
static const unsigned short ISymUnmanagedWriter2_FormatStringOffsetTable[] =
    {
    2346,
    2398,
    2426,
    2454,
    2476,
    2510,
    2538,
    2578,
    2660,
    2724,
    2800,
    2870,
    2892,
    2938,
    2966,
    2988,
    3016,
    3074,
    3120,
    3166,
    3230,
    3264,
    3316,
    3362,
    3384,
    3460,
    3524
    };

static const MIDL_STUBLESS_PROXY_INFO ISymUnmanagedWriter2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedWriter2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISymUnmanagedWriter2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISymUnmanagedWriter2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(30) _ISymUnmanagedWriter2ProxyVtbl = 
{
    &ISymUnmanagedWriter2_ProxyInfo,
    &IID_ISymUnmanagedWriter2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineDocument */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetUserEntryPoint */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseMethod */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenScope */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseScope */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetScopeRange */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineLocalVariable */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineParameter */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineField */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineGlobalVariable */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Close */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetSymAttribute */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::OpenNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::CloseNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::UsingNamespace */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::SetMethodSourceRange */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Initialize */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::GetDebugInfo */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineSequencePoints */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::RemapToken */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Initialize2 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::DefineConstant */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter::Abort */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter2::DefineLocalVariable2 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter2::DefineGlobalVariable2 */ ,
    (void *) (INT_PTR) -1 /* ISymUnmanagedWriter2::DefineConstant2 */
};

const CInterfaceStubVtbl _ISymUnmanagedWriter2StubVtbl =
{
    &IID_ISymUnmanagedWriter2,
    &ISymUnmanagedWriter2_ServerInfo,
    30,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _corsym_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedScopeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedDocumentProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedMethodProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedBinderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedBinder2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedWriter2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedWriterProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedReaderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedNamespaceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedVariableProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedDisposeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISymUnmanagedDocumentWriterProxyVtbl,
    0
};

const CInterfaceStubVtbl * _corsym_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISymUnmanagedScopeStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedDocumentStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedMethodStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedBinderStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedBinder2StubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedWriter2StubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedWriterStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedReaderStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedNamespaceStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedVariableStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedDisposeStubVtbl,
    ( CInterfaceStubVtbl *) &_ISymUnmanagedDocumentWriterStubVtbl,
    0
};

PCInterfaceName const _corsym_InterfaceNamesList[] = 
{
    "ISymUnmanagedScope",
    "ISymUnmanagedDocument",
    "ISymUnmanagedMethod",
    "ISymUnmanagedBinder",
    "ISymUnmanagedBinder2",
    "ISymUnmanagedWriter2",
    "ISymUnmanagedWriter",
    "ISymUnmanagedReader",
    "ISymUnmanagedNamespace",
    "ISymUnmanagedVariable",
    "ISymUnmanagedDispose",
    "ISymUnmanagedDocumentWriter",
    0
};


#define _corsym_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _corsym, pIID, n)

int __stdcall _corsym_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _corsym, 12, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _corsym, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _corsym, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _corsym, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _corsym, 12, *pIndex )
    
}

const ExtendedProxyFileInfo corsym_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _corsym_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _corsym_StubVtblList,
    (const PCInterfaceName * ) & _corsym_InterfaceNamesList,
    0, // no delegation
    & _corsym_IID_Lookup, 
    12,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( codeproc )
EXTERN_PROXY_FILE( cordebug )
EXTERN_PROXY_FILE( corprof )
EXTERN_PROXY_FILE( corpub )
EXTERN_PROXY_FILE( corsvc )
EXTERN_PROXY_FILE( corsym )
EXTERN_PROXY_FILE( corzap )
EXTERN_PROXY_FILE( cpimporteritf )
EXTERN_PROXY_FILE( fusion )
EXTERN_PROXY_FILE( fusionpriv )
EXTERN_PROXY_FILE( gchost )
EXTERN_PROXY_FILE( ivalidator )
EXTERN_PROXY_FILE( ivehandler )
EXTERN_PROXY_FILE( license )
EXTERN_PROXY_FILE( mscoree )
EXTERN_PROXY_FILE( mscormmc )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( codeproc ),
  REFERENCE_PROXY_FILE( cordebug ),
  REFERENCE_PROXY_FILE( corprof ),
  REFERENCE_PROXY_FILE( corpub ),
  REFERENCE_PROXY_FILE( corsvc ),
  REFERENCE_PROXY_FILE( corsym ),
  REFERENCE_PROXY_FILE( corzap ),
  REFERENCE_PROXY_FILE( cpimporteritf ),
  REFERENCE_PROXY_FILE( fusion ),
  REFERENCE_PROXY_FILE( fusionpriv ),
  REFERENCE_PROXY_FILE( gchost ),
  REFERENCE_PROXY_FILE( ivalidator ),
  REFERENCE_PROXY_FILE( ivehandler ),
  REFERENCE_PROXY_FILE( license ),
  REFERENCE_PROXY_FILE( mscoree ),
  REFERENCE_PROXY_FILE( mscormmc ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\debugblobs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for debug.clb
// 6/29/1998  16:12:38
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iCOMDebugTables = 4;
extern const BYTE DECLSPEC_SELECTANY g_rgCOMDebugSchemaDataRW[] = 
{
	0x04,0x00,0x00,0x00,0xE8,0x01,0x00,0x00,0x18,0x00,0x00,0x00,0x6C,0x00,0x00,0x00,0xB0,0x00,0x00,0x00,
	0x44,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x3A,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x0C,0x00,0x54,0x00,0x15,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1E,0x00,0x00,0x00,
	0x03,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x27,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x08,0x00,0x01,0x02,0x24,0x58,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x22,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0x50,0x00,0x00,0x00,0x01,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x5A,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x65,0x00,0x00,0x00,0x03,0x00,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x70,0x00,0x00,0x00,
	0x02,0x00,0x02,0x3A,0x06,0x01,0x01,0x54,0x01,0x00,0x14,0x00,0x20,0x00,0x94,0x00,0x15,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x00,0x00,0x00,0x03,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0x00,0x43,0x86,0x00,0x00,0x00,0x04,0x02,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x8D,0x00,0x00,0x00,0x05,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x97,0x00,0x00,0x00,
	0x06,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x9F,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x18,0x00,0x01,0x02,0x00,0x58,0xB4,0x00,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x1C,0x00,
	0x01,0x04,0x00,0x58,0xC8,0x00,0x00,0x00,0x03,0x00,0x02,0x3A,0x07,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x20,0x00,0xA4,0x00,0x15,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xDF,0x00,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE5,0x00,0x00,0x00,0x04,0x00,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xEA,0x00,0x00,0x00,0x05,0x00,0x82,0x00,0x10,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xF4,0x00,0x00,0x00,0x06,0x00,0x80,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x02,0x01,0x00,0x00,0x07,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x07,0x01,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x18,0x00,0x01,0x02,0x00,0x58,0x24,0x01,0x00,0x00,0x08,0x00,0x02,0x01,
	0x11,0xFF,0x1C,0x00,0x01,0x03,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCOMDebugSchemaRW = 488;
extern const DECLSPEC_SELECTANY BYTE g_rgCOMDebugSchemaStringHeap[] = 
{
	0x00,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x53,0x6F,0x75,0x72,0x63,0x65,0x46,0x69,0x6C,0x65,
	0x00,0x5F,0x72,0x69,0x64,0x00,0x6F,0x69,0x64,0x00,0x46,0x69,0x6C,0x65,0x4E,0x61,0x6D,0x65,0x00,0x23,
	0x23,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x53,0x6F,0x75,0x72,0x63,0x65,0x46,0x69,0x6C,0x65,
	0x5F,0x44,0x65,0x78,0x00,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x42,0x6C,0x6F,0x63,0x6B,0x00,
	0x4D,0x65,0x74,0x68,0x6F,0x64,0x44,0x65,0x66,0x00,0x53,0x6F,0x75,0x72,0x63,0x65,0x46,0x69,0x6C,0x65,
	0x00,0x4C,0x69,0x6E,0x65,0x4E,0x75,0x6D,0x62,0x65,0x72,0x00,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,
	0x2E,0x53,0x63,0x6F,0x70,0x65,0x00,0x50,0x61,0x72,0x65,0x6E,0x74,0x00,0x4D,0x65,0x74,0x68,0x6F,0x64,
	0x00,0x53,0x74,0x61,0x72,0x74,0x4C,0x69,0x6E,0x65,0x00,0x45,0x6E,0x64,0x4C,0x69,0x6E,0x65,0x00,0x23,
	0x23,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x53,0x63,0x6F,0x70,0x65,0x5F,0x44,0x65,0x78,0x00,
	0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x4D,0x65,0x74,0x68,0x6F,0x64,0x5F,0x44,0x65,0x78,0x00,
	0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x4C,0x6F,0x63,0x61,0x6C,0x56,0x61,0x72,0x69,0x61,0x62,
	0x6C,0x65,0x00,0x53,0x63,0x6F,0x70,0x65,0x00,0x4E,0x61,0x6D,0x65,0x00,0x53,0x69,0x67,0x6E,0x61,0x74,
	0x75,0x72,0x65,0x00,0x53,0x69,0x67,0x6E,0x61,0x74,0x75,0x72,0x65,0x42,0x6C,0x6F,0x62,0x00,0x53,0x6C,
	0x6F,0x74,0x00,0x23,0x23,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,0x2E,0x4C,0x6F,0x63,0x61,0x6C,0x56,
	0x61,0x72,0x69,0x61,0x62,0x6C,0x65,0x5F,0x44,0x65,0x78,0x00,0x43,0x4F,0x4D,0x44,0x65,0x62,0x75,0x67,
	0x2E,0x53,0x63,0x6F,0x70,0x65,0x5F,0x44,0x65,0x78,0x00,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbCOMDebugSchemaStringHeap = g_rgCOMDebugSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbCOMDebugSchemaStringHeap = 312;
extern const BYTE DECLSPEC_SELECTANY g_rgCOMDebugSchemaDataRO[] = 
{
	0x04,0x00,0x00,0x00,0xE8,0x01,0x00,0x00,0x18,0x00,0x00,0x00,0x6C,0x00,0x00,0x00,0xB0,0x00,0x00,0x00,
	0x44,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x3A,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x0C,0x00,0x54,0x00,0x15,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1E,0x00,0x00,0x00,
	0x03,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x27,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x08,0x00,0x01,0x02,0x24,0x58,0x41,0x00,0x00,0x00,0x01,0x00,0x00,0x22,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0x50,0x00,0x00,0x00,0x01,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x5A,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x65,0x00,0x00,0x00,0x03,0x00,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x70,0x00,0x00,0x00,
	0x02,0x00,0x02,0x3A,0x06,0x01,0x01,0x54,0x01,0x00,0x14,0x00,0x20,0x00,0x94,0x00,0x15,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x00,0x00,0x00,0x03,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0x00,0x43,0x86,0x00,0x00,0x00,0x04,0x02,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x8D,0x00,0x00,0x00,0x05,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x97,0x00,0x00,0x00,
	0x06,0x00,0x13,0x00,0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x9F,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x18,0x00,0x01,0x02,0x00,0x58,0xB4,0x00,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x1C,0x00,
	0x01,0x04,0x00,0x58,0xC8,0x00,0x00,0x00,0x03,0x00,0x02,0x3A,0x07,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x20,0x00,0xA4,0x00,0x15,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xDF,0x00,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE5,0x00,0x00,0x00,0x04,0x00,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xEA,0x00,0x00,0x00,0x05,0x00,0x82,0x00,0x10,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0xF4,0x00,0x00,0x00,0x06,0x00,0x80,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x02,0x01,0x00,0x00,0x07,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x07,0x01,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x18,0x00,0x01,0x02,0x00,0x58,0x24,0x01,0x00,0x00,0x08,0x00,0x02,0x01,
	0x11,0xFF,0x1C,0x00,0x01,0x03,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCOMDebugSchemaRO = 488;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY COMDebugSchemaBlob = 
{
	&COMDebugSchema,
	COMDebug_TABLE_COUNT,
	0,
	g_rgCOMDebugSchemaDataRW,
	g_cbCOMDebugSchemaRW,
	g_rgCOMDebugSchemaDataRO,
	g_cbCOMDebugSchemaRO,
	g_rgCOMDebugSchemaStringHeap,
	g_cbCOMDebugSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dump-type-info.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Defines macros which turn the contents of "dump-types.h" into class offsets
 * and member offsets to use with GetMemberOffset().
 */

#include <clear-class-dump-defs.h>

#define BEGIN_CLASS_DUMP_INFO(klass) \
  struct offset_member_ ## klass  { \
    enum members {

#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent) \
    BEGIN_CLASS_DUMP_INFO(klass)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass) \
    BEGIN_CLASS_DUMP_INFO(klass)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent) \
    BEGIN_CLASS_DUMP_INFO(klass)

#define CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(field) \
      field,

#define CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(field) \
      field,

/* we don't need to inject anything */
#define CDI_CLASS_INJECT(foo)

#define CDI_CLASS_MEMBER_OFFSET(member) \
      member,

#define CDI_CLASS_MEMBER_OFFSET_BITFIELD(member, size) \
      member,

/* Debug members are always present in the table, but they'll have an 0 for
 * their offset value. */
#define CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(member) \
      member,

#define CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(member) \
      member,

#define CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(member) \
      member,

#define CDI_CLASS_STATIC_ADDRESS(member) \
      member,

#define CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(member) \
      member,

#define CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(member) \
      member,

#define CDI_GLOBAL_ADDRESS(name) \
      name,

#define CDI_GLOBAL_ADDRESS_DEBUG_ONLY(name) \
      name,

#define END_CLASS_DUMP_INFO(klass) \
      end_of_members \
    }; /* end of enum */ \
  }; /* end of struct */ 

#define END_CLASS_DUMP_INFO_DERIVED(klass, parent) \
    END_CLASS_DUMP_INFO(klass)

#define END_ABSTRACT_CLASS_DUMP_INFO(klass) \
    END_CLASS_DUMP_INFO(klass)

#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent) \
    END_CLASS_DUMP_INFO(klass)

#define BEGIN_CLASS_DUMP_TABLE(tbl_name) \
  enum tbl_name ## _classes {
 
#define CDT_CLASS_ENTRY(klass) \
  offset_class_ ## klass,
 
#define END_CLASS_DUMP_TABLE(tbl_name) \
  end_of_ ## tbl_name ## _classes };


#ifndef INC_DUMP_TYPE_INFO
#define INC_DUMP_TYPE_INFO

/* generate the offsets */
#include <dump-types.h>

#endif // INC_DUMP_TYPE_INFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dump-tables.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef INC_DUMP_TABLES
#define INC_DUMP_TABLES

struct ClassDumpInfo
{
    SIZE_T  classSize;
    SIZE_T  nmembers;
    SIZE_T* memberOffsets;
};


struct ClassDumpTable
{
    /** The top 3 entries can't change without changing ``vm/dump-tables.cpp''. */
    SIZE_T version;
    SIZE_T nentries;
    ClassDumpInfo** classes;

    ULONG_PTR pEEJitManagerVtable;
    ULONG_PTR pEconoJitManagerVtable;
    ULONG_PTR pMNativeJitManagerVtable;

#include <clear-class-dump-defs.h>

#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent) DWORD_PTR p ## klass ## Vtable;
#define END_CLASS_DUMP_INFO_DERIVED(klass, parent)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)
#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO(klass)

#define CDI_CLASS_MEMBER_OFFSET(member)

#include "frame-types.h"

#include <clear-class-dump-defs.h>
};

/** Keep this name in sync with the Class Dump Table name in <dump-types.h> */
extern "C" ClassDumpTable g_ClassDumpData;

struct ClassDumpTableBlock
{
    ClassDumpTable* table;
};

#endif /* ndef INC_DUMP_TABLES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\debugstructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for ..\..\inc\debugStructs.h
// 6/29/1998  16:12:38
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define COMDebugTABLENAMELIST() \
	TABLENAME( SourceFile ) \
	TABLENAME( Block ) \
	TABLENAME( Scope ) \
	TABLENAME( LocalVariable ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_COMDebug_##TblName, 
enum
{
	COMDebugTABLENAMELIST()
};

#define COMDebug_TABLE_COUNT 4
extern const GUID DECLSPEC_SELECTANY SCHEMA_COMDebug = { 0x83368794, 0xCF1E, 0x11D1, {  0x94, 0x05, 0x00, 0x00, 0xF8, 0x08, 0x34, 0x60 }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY COMDebugSchema = 
{
	&SCHEMA_COMDebug,
	2
};


#define SCHEMA_COMDebug_Name "COMDebug"


#include "pshpack1.h"


//*****************************************************************************
//  COMDebug.SourceFile
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    ULONG cbFileNameLen;
    wchar_t FileName[260];

    void Init()
    {
         memset(this, 0, sizeof(COMDebug_SourceFile));
    }

} COMDebug_SourceFile;

#define COLID_COMDebug_SourceFile__rid 1
#define COLID_COMDebug_SourceFile_oid 2
#define COLID_COMDebug_SourceFile_FileName 3




//*****************************************************************************
//  COMDebug.Block
//*****************************************************************************
typedef struct
{
    OID MethodDef;
    OID SourceFile;
    ULONG cbLineNumberLen;
    BYTE LineNumber[260];

    void Init()
    {
         memset(this, 0, sizeof(COMDebug_Block));
    }

} COMDebug_Block;

#define COLID_COMDebug_Block_MethodDef 1
#define COLID_COMDebug_Block_SourceFile 2
#define COLID_COMDebug_Block_LineNumber 3




//*****************************************************************************
//  COMDebug.Scope
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long _rid;
    OID oid;
    OID Parent;
    OID Method;
    unsigned long StartLine;
    unsigned long EndLine;

	inline int IsParentNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetParentNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMDebug_Scope));
         fNullFlags = (ULONG) -1;
    }

} COMDebug_Scope;

#define COLID_COMDebug_Scope__rid 1
#define COLID_COMDebug_Scope_oid 2
#define COLID_COMDebug_Scope_Parent 3
#define COLID_COMDebug_Scope_Method 4
#define COLID_COMDebug_Scope_StartLine 5
#define COLID_COMDebug_Scope_EndLine 6

#define Index_COMDebug_Method_Dex "COMDebug.Method_Dex"



//*****************************************************************************
//  COMDebug.LocalVariable
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Scope;
    ULONG cbNameLen;
    wchar_t Name[260];
    ULONG cbSignatureLen;
    wchar_t Signature[260];
    ULONG cbSignatureBlobLen;
    BYTE SignatureBlob[260];
    unsigned long Slot;

    void Init()
    {
         memset(this, 0, sizeof(COMDebug_LocalVariable));
    }

} COMDebug_LocalVariable;

#define COLID_COMDebug_LocalVariable__rid 1
#define COLID_COMDebug_LocalVariable_oid 2
#define COLID_COMDebug_LocalVariable_Scope 3
#define COLID_COMDebug_LocalVariable_Name 4
#define COLID_COMDebug_LocalVariable_Signature 5
#define COLID_COMDebug_LocalVariable_SignatureBlob 6
#define COLID_COMDebug_LocalVariable_Slot 7

#define Index_COMDebug_Scope_Dex "COMDebug.Scope_Dex"



#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\declsec.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * COM+99 Declarative Security Header
 *
 * HISTORY: Created, 4/15/98 brianbec.
 */

#ifndef _DECLSEC_H
#define _DECLSEC_H
//
// PSECURITY_PROPS and PSECURITY_VALUES are opaque types (void*s) defined in cor.h
// so that cor.h does not need to know about these structures.  This file relates
// the opaque types in cor.h to concrete types, which are also defined here. 
//
// a PSECURITY_PROPS is a pSecurityProperties
// a PSECURITY_VALUE is a pSecurityValue
//

#include "cor.h"

// First, some flag values

#define  DECLSEC_DEMANDS                0x00000001
#define  DECLSEC_ASSERTIONS             0x00000002
#define  DECLSEC_DENIALS                0x00000004
#define  DECLSEC_INHERIT_CHECKS         0x00000008
#define  DECLSEC_LINK_CHECKS            0x00000010
#define  DECLSEC_PERMITONLY             0x00000020
#define  DECLSEC_REQUESTS               0x00000040
#define	 DECLSEC_UNMNGD_ACCESS_DEMAND   0x00000080	// Used by PInvoke/Interop
#define  DECLSEC_NONCAS_DEMANDS         0x00000100
#define  DECLSEC_NONCAS_LINK_DEMANDS    0x00000200
#define  DECLSEC_NONCAS_INHERITANCE     0x00000400


#define  DECLSEC_NULL_OFFSET        8

#define  DECLSEC_NULL_DEMANDS               (DECLSEC_DEMANDS                << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_ASSERTIONS            (DECLSEC_ASSERTIONS             << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_DENIALS               (DECLSEC_DENIALS                << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_INHERIT_CHECKS        (DECLSEC_INHERIT_CHECKS         << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_LINK_CHECKS           (DECLSEC_LINK_CHECKS            << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_PERMITONLY            (DECLSEC_PERMITONLY             << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_REQUESTS              (DECLSEC_REQUESTS               << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_NONCAS_DEMANDS        (DECLSEC_NONCAS_DEMANDS         << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_NONCAS_LINK_DEMANDS   (DECLSEC_NONCAS_LINK_DEMANDS    << DECLSEC_NULL_OFFSET)
#define  DECLSEC_NULL_NONCAS_INHERITANCE    (DECLSEC_NONCAS_INHERITANCE     << DECLSEC_NULL_OFFSET)

#define  DECLSEC_RUNTIME_ACTIONS        (DECLSEC_DEMANDS        | \
                                         DECLSEC_NONCAS_DEMANDS | \
                                         DECLSEC_ASSERTIONS     | \
                                         DECLSEC_DENIALS        | \
                                         DECLSEC_PERMITONLY     | \
                                         DECLSEC_UNMNGD_ACCESS_DEMAND)


#define  DECLSEC_FRAME_ACTIONS          (DECLSEC_ASSERTIONS | \
                                         DECLSEC_DENIALS    | \
                                         DECLSEC_PERMITONLY)

#define  DECLSEC_NON_RUNTIME_ACTIONS    (DECLSEC_REQUESTS               | \
                                         DECLSEC_INHERIT_CHECKS         | \
                                         DECLSEC_LINK_CHECKS            | \
                                         DECLSEC_NONCAS_LINK_DEMANDS    | \
                                         DECLSEC_NONCAS_INHERITANCE)


__declspec(selectany) extern const DWORD DCL_FLAG_MAP[] =
{
    0,                      // dclActionNil
    DECLSEC_REQUESTS,       // dclRequest
    DECLSEC_DEMANDS,        // dclDemand
    DECLSEC_ASSERTIONS,     //
    DECLSEC_DENIALS,        //
    DECLSEC_PERMITONLY,     //
    DECLSEC_LINK_CHECKS,    //
    DECLSEC_INHERIT_CHECKS, // dclInheritanceCheck
    DECLSEC_REQUESTS,
    DECLSEC_REQUESTS,
    DECLSEC_REQUESTS,
    0,
    0,
    DECLSEC_NONCAS_DEMANDS,
    DECLSEC_NONCAS_LINK_DEMANDS,
    DECLSEC_NONCAS_INHERITANCE,
};

#define  DclToFlag(dcl) DCL_FLAG_MAP[dcl]

#define  BIT_TST(I,B)  ((I) &    (B))
#define  BIT_SET(I,B)  ((I) |=   (B))
#define  BIT_CLR(I,B)  ((I) &= (~(B)))

class LoaderHeap;

class SecurityProperties
{
private:
    DWORD   dwFlags    ;
//    PermList    plDemands ;
    
public:
    void *operator new(size_t size, LoaderHeap *pHeap);
    void operator delete(void *pMem);

    SecurityProperties ()   {dwFlags = 0 ;}
    ~SecurityProperties ()  {dwFlags = 0 ;}

    inline BOOL FDeclarationsExist       () {return dwFlags                                ;}
    inline BOOL FDemandsExist            () {return BIT_TST(dwFlags, DECLSEC_DEMANDS)        ;}
    inline void SetDemandsExist          () {       BIT_SET(dwFlags, DECLSEC_DEMANDS)        ;}
    inline void ResetDemandsExist        () {       BIT_CLR(dwFlags, DECLSEC_DEMANDS)        ;}

    inline BOOL FAssertionsExist         () {return BIT_TST(dwFlags, DECLSEC_ASSERTIONS)     ;}
    inline void SetAssertionsExist       () {       BIT_SET(dwFlags, DECLSEC_ASSERTIONS)     ;}
    inline void ResetAssertionsExist     () {       BIT_CLR(dwFlags, DECLSEC_ASSERTIONS)     ;}

    inline BOOL FDenialsExist            () {return BIT_TST(dwFlags, DECLSEC_DENIALS)        ;}
    inline void SetDenialsExist          () {       BIT_SET(dwFlags, DECLSEC_DENIALS)        ;}
    inline void ResetDenialsExist        () {       BIT_CLR(dwFlags, DECLSEC_DENIALS)        ;}

    inline BOOL FInherit_ChecksExist     () {return BIT_TST(dwFlags, DECLSEC_INHERIT_CHECKS) ;}
    inline void SetInherit_ChecksExist   () {       BIT_SET(dwFlags, DECLSEC_INHERIT_CHECKS) ;}
    inline void ResetInherit_ChecksExist () {       BIT_CLR(dwFlags, DECLSEC_INHERIT_CHECKS) ;}

    // The class requires an inheritance check only if there are inherit checks and
    // they aren't null.
    inline BOOL RequiresInheritanceCheck () {return ((dwFlags & (DECLSEC_INHERIT_CHECKS | DECLSEC_NULL_INHERIT_CHECKS))
                                                     == DECLSEC_INHERIT_CHECKS) ||
                                                 ((dwFlags & (DECLSEC_NONCAS_INHERITANCE | DECLSEC_NULL_NONCAS_INHERITANCE))
                                                  == DECLSEC_NONCAS_INHERITANCE) ;}

    inline BOOL RequiresCasInheritanceCheck () {return (dwFlags & (DECLSEC_INHERIT_CHECKS | DECLSEC_NULL_INHERIT_CHECKS))
                                                    == DECLSEC_INHERIT_CHECKS ;}

    inline BOOL RequiresNonCasInheritanceCheck () {return (dwFlags & (DECLSEC_NONCAS_INHERITANCE | DECLSEC_NULL_NONCAS_INHERITANCE))
                                                       == DECLSEC_NONCAS_INHERITANCE ;}

    inline BOOL FLink_ChecksExist        () {return BIT_TST(dwFlags, DECLSEC_LINK_CHECKS)    ;}
    inline void SetLink_ChecksExist      () {       BIT_SET(dwFlags, DECLSEC_LINK_CHECKS)    ;}
    inline void ResetLink_ChecksExist    () {       BIT_CLR(dwFlags, DECLSEC_LINK_CHECKS)    ;}

    inline BOOL RequiresLinktimeCheck    () {return ((dwFlags & (DECLSEC_LINK_CHECKS | DECLSEC_NULL_LINK_CHECKS))
                                                     == DECLSEC_LINK_CHECKS) ||
                                                 ((dwFlags & (DECLSEC_NONCAS_LINK_DEMANDS | DECLSEC_NULL_NONCAS_LINK_DEMANDS))
                                                     == DECLSEC_NONCAS_LINK_DEMANDS) ;}

    inline BOOL RequiresCasLinktimeCheck () {return (dwFlags & (DECLSEC_LINK_CHECKS | DECLSEC_NULL_LINK_CHECKS))
                                                 == DECLSEC_LINK_CHECKS ;}

    inline BOOL RequiresNonCasLinktimeCheck () {return (dwFlags & (DECLSEC_NONCAS_LINK_DEMANDS | DECLSEC_NULL_NONCAS_LINK_DEMANDS))
                                                    == DECLSEC_NONCAS_LINK_DEMANDS ;}

    inline BOOL FPermitOnlyExist         () {return BIT_TST(dwFlags, DECLSEC_PERMITONLY)     ;}
    inline void SetPermitOnlyExist       () {       BIT_SET(dwFlags, DECLSEC_PERMITONLY)     ;}
    inline void ResetPermitOnlyExist     () {       BIT_CLR(dwFlags, DECLSEC_PERMITONLY)     ;}

    inline void SetDeclaration(DWORD dcl)   { BIT_SET(dwFlags, DclToFlag(dcl)); }
    inline void ResetDeclaration(DWORD dcl) { BIT_CLR(dwFlags, DclToFlag(dcl)); }

    inline void SetFlags(DWORD dw) { dwFlags = dw; }

    inline void SetFlags(DWORD dw, DWORD dwNull)
    {
        dwFlags = (dw | (dwNull << DECLSEC_NULL_OFFSET));
    }

    inline DWORD GetRuntimeActions()              
    { 
        return dwFlags & DECLSEC_RUNTIME_ACTIONS;
    }

    inline DWORD GetNullRuntimeActions()        
    {
        return (dwFlags >> DECLSEC_NULL_OFFSET) & DECLSEC_RUNTIME_ACTIONS;
    }
} ;

class SecurityValue
{

} ;

typedef SecurityProperties * PSecurityProperties, ** PpSecurityProperties ;
typedef SecurityValue      * PSecurityValue,      ** PpSecurityValue      ;

// Three-letter acronyms are very handy for keeping the rest of the code tidy.

typedef SecurityProperties SPS, *PSPS, **PPSPS ;
typedef SecurityValue      SVU, *PSVU, **PPSVU ;

// We need some simple macros to convert from the opaque types to the real thing
// and back. 

#define PSPS_FROM_PSECURITY_PROPS(x)   ((PSPS)x)
#define PSVU_FROM_PSECURITY_VALUE(x)   ((PSVU)x)

#define PSECURITY_PROPS_FROM_PSPS(x)   ((PSECURITY_PROPS)(x))
#define PSECURITY_VALUE_FROM_PSVU(x)   ((PSECURITY_VALUE)(x))

#define PPSPS_FROM_PPSECURITY_PROPS(x) ((PPSPS)x)
#define PPSVU_FROM_PPSECURITY_VALUE(x) ((PPSVU)x)

#define PPSECURITY_PROPS_FROM_PPSPS(x) ((PPSECURITY_PROPS)(x))
#define PPSECURITY_VALUE_FROM_PPSVU(x) ((PPSECURITY_VALUE)(x))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dbgmeta.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * DbgMeta.h - header file for debugger metadata routines
 * ------------------------------------------------------------------------- */

#ifndef _DbgMeta_h_
#define _DbgMeta_h_

#include <cor.h>

/* ------------------------------------------------------------------------- *
 * Structs to support line numbers and variables
 * ------------------------------------------------------------------------- */

class DebuggerLexicalScope;

//
// DebuggerLineIPRangePair
//
// Relates a single line to a range of IP's. Used to help coorleate
// a source line to all the possibly disjoint sets of instructions
// that it generated.
//
struct DebuggerLineIPRangePair
{
    ULONG32      line;
    ULONG32      rangeStart;
    ULONG32      rangeEnd;
    mdMethodDef  method;
};

//
// DebuggerVarInfo
//
// Holds basic information about local variables, method arguments,
// and class static and instance variables.
//
struct DebuggerVarInfo
{
    LPCSTR                 name;
    PCCOR_SIGNATURE        sig;
    unsigned long          varNumber;  // placement info for IL code
    DebuggerLexicalScope*  scope;      // containing scope

    DebuggerVarInfo() : name(NULL), sig(NULL), varNumber(0),
                        scope(NULL) {}
};

#endif /* _DbgMeta_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\debugmacros.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DebugMacros.h
//
// Wrappers for Debugging purposes.
//
//*****************************************************************************
#ifndef __DebugMacros_h__
#define __DebugMacros_h__

#include "StackTrace.h"

#undef _ASSERTE
#undef VERIFY

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#ifdef GOLDEN
#error Do not turn on GOLDEN for V1 RTM!!! See ASURT#98459 for more info.
#endif





// A macro to execute a statement only in _DEBUG.
#ifdef _DEBUG

#define DEBUG_STMT(stmt)    stmt
int _cdecl DbgWrite(LPCTSTR szFmt, ...);
int _cdecl DbgWriteEx(LPCTSTR szFmt, ...);
#define BAD_FOOD    ((void *)0x0df0adba) // 0xbaadf00d
int _DbgBreakCheck(LPCSTR szFile, int iLine, LPCSTR szExpr);

#if     defined(_M_IX86)
#define _DbgBreak() __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

#define DebugBreakNotGolden() DebugBreak()

#define TRACE_BUFF_SIZE (cchMaxAssertStackLevelStringLen * cfrMaxAssertStackLevels + cchMaxAssertExprLen + 1)
extern char g_szExprWithStack[TRACE_BUFF_SIZE];
extern int g_BufferLock;

#define PRE_ASSERTE         /* if you need to change modes before doing asserts override */
#define POST_ASSERTE        /* put it back */

extern VOID DbgAssertDialog(char *szFile, int iLine, char *szExpr);

#define _ASSERTE(expr)                                                      \
        do {                                                                \
             if (!(expr)) {                                                 \
                PRE_ASSERTE                                                 \
                DbgAssertDialog(__FILE__, __LINE__, #expr);                 \
                POST_ASSERTE                                                \
             }                                                              \
        } while (0)



#define VERIFY(stmt) _ASSERTE((stmt))

#define _ASSERTE_ALL_BUILDS(expr) _ASSERTE((expr))

extern VOID DebBreak();
extern VOID DebBreakHr(HRESULT hr);
extern int _DbgBreakCount;

#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { DebBreakHr(hr); goto LABEL; } } while (0)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) \
do { hr = (EXPR); if(FAILED(hr)) { DebBreakHr(hr); return (hr); } } while (0)
#endif

#ifndef IfFailWin32Goto
#define IfFailWin32Goto(EXPR, LABEL) \
do { hr = (EXPR); if(hr != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(hr); DebBreakHr(hr); goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailWin32Go
#define IfFailWin32Go(EXPR) IfFailWin32Goto(EXPR, ErrExit)
#endif

#else // _DEBUG

#ifdef GOLDEN
#define DebugBreakNotGolden() {}
#else

#define DebugBreakNotGolden() DebugBreak()

#define _DbgBreakCount  0

#define _DbgBreak() {}

#define DEBUG_STMT(stmt)
#define BAD_FOOD
#define _ASSERTE(expr) ((void)0)
#define VERIFY(stmt) (stmt)

#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)

#define IfFailRet(EXPR) \
do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)

#define IfFailWin32Goto(EXPR, LABEL) \
do { hr = (EXPR); if(hr != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(hr); goto LABEL; } } while (0)

#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)

#define IfFailWin32Go(EXPR) IfFailWin32Goto(EXPR, ErrExit)

#endif // GOLDEN

#endif // _DEBUG

#ifdef _DEBUG
#define FreeBuildDebugBreak() DebugBreak()
#else
void __FreeBuildDebugBreak();
#define FreeBuildDebugBreak() __FreeBuildDebugBreak()
#define _ASSERTE_ALL_BUILDS(expr) if (!(expr)) __FreeBuildDebugBreak();
#endif


#define IfNullGo(EXPR) \
do {if ((EXPR) == 0) {OutOfMemory(); IfFailGo(E_OUTOFMEMORY);} } while (0)

#ifdef __cplusplus
}
#endif // __cplusplus


#undef assert
#define assert _ASSERTE
#undef _ASSERT
#define _ASSERT _ASSERTE


#ifdef _DEBUG
    // This function returns the EXE time stamp (effectively a random number)
    // Under retail it always returns 0.  This is meant to be used in the
    // RandomOnExe macro
unsigned DbgGetEXETimeStamp();

    // returns true 'fractionOn' amount of the time using the EXE timestamp
    // as the random number seed.  For example DbgRandomOnExe(.1) returns true 1/10
    // of the time.  We use the line number so that different uses of DbgRandomOnExe
    // will not be coorelated with each other (9973 is prime).  Returns false on a retail build
#define DbgRandomOnExe(fractionOn) \
    (((DbgGetEXETimeStamp() * __LINE__) % 9973) >= unsigned(fractionOn * 9973))
#else
#define DbgRandomOnExe(frantionOn)  0
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ehencoder.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name: EHEncoder.h

Abstract: Defines the EH encoder interface that is used by both the VM (for decoding) 
          and JITters (for encoding)

  Date        Author      Comments
----        ------      --------
2/17/99     sanjaybh     Created     


--*/

#include "corjit.h"

class EHEncoder
{
public:

#ifdef USE_EH_ENCODER
static	void encode(BYTE** dest, unsigned val);
static	void encode(BYTE** dest, CORINFO_EH_CLAUSE val);
#endif

#ifdef USE_EH_DECODER
static	unsigned decode(const BYTE* src, unsigned* val);
static	unsigned decode(const BYTE* src, CORINFO_EH_CLAUSE *clause);
#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ehencoder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name: EHEncoder.cpp

Abstract: Implementation of EH encoding interface that is used by both the VM (for decoding) 
          and JITters (for encoding)

  Date        Author      Comments
----        ------      --------
2/17/99     sanjaybh     Created     


--*/

#include "EHEncoder.h"

#ifdef USE_EH_ENCODER

void EHEncoder::encode(BYTE** dest, unsigned val) {
	BYTE bits;
	while (val > 0x7f) {
		bits = (val & 0x7f) | 0x80;
		val = val >> 7;
		**dest = bits;
		(*dest)++;
		
	}
	**dest = (BYTE) val;
	(*dest)++;
	
}


void EHEncoder::encode(BYTE** dest, CORINFO_EH_CLAUSE val) {
    encode(dest,(unsigned) val.Flags);
	encode(dest,(unsigned) val.TryOffset);
	encode(dest,(unsigned) val.TryLength);
	encode(dest,(unsigned) val.HandlerOffset);
	encode(dest,(unsigned) val.HandlerLength);
	encode(dest,(unsigned) val.FilterOffset);
	}
#endif



#ifdef USE_EH_DECODER

unsigned  EHEncoder::decode(const BYTE *src, unsigned* val)
{
    unsigned  size = 1;
    BYTE     byte  = *src++;
    unsigned value = byte & 0x7f;
    while (byte & 0x80) {
        byte    = *src++;
        //value <<= 7;
        value  += (unsigned)((byte & 0x7f) << (7*size));
        size++;
    }
    *val = value;
    return size;
}


unsigned EHEncoder::decode(const BYTE *src, CORINFO_EH_CLAUSE* val)
{
    unsigned size = 0;
    unsigned temp;
    size += decode(src, &temp);
    val->Flags = (CORINFO_EH_CLAUSE_FLAGS) temp;
    size += decode(src+size, (unsigned*) &(val->TryOffset));
    size += decode(src+size, (unsigned*) &(val->TryLength));
    size += decode(src+size, (unsigned*) &(val->HandlerOffset));
    size += decode(src+size, (unsigned*) &(val->HandlerLength));
    size += decode(src+size, (unsigned*) &(val->FilterOffset));
    return size;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\frame-types.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef BEGIN_CLASS_DUMP_INFO
#define BEGIN_CLASS_DUMP_INFO(klass)
#endif

#ifndef END_CLASS_DUMP_INFO
#define END_CLASS_DUMP_INFO(klass)
#endif

#ifndef BEGIN_CLASS_DUMP_INFO_DERIVED
#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent)
#endif

#ifndef END_CLASS_DUMP_INFO_DERIVED
#define END_CLASS_DUMP_INFO_DERIVED(klass, parent)
#endif

#ifndef BEGIN_ABSTRACT_CLASS_DUMP_INFO
#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass)
#endif

#ifndef END_ABSTRACT_CLASS_DUMP_INFO
#define END_ABSTRACT_CLASS_DUMP_INFO(klass)
#endif

#ifndef BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)
#endif

#ifndef END_ABSTRACT_CLASS_DUMP_INFO_DERIVED
#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)
#endif

#ifndef CDI_CLASS_MEMBER_OFFSET
#define CDI_CLASS_MEMBER_OFFSET(member)
#endif


BEGIN_ABSTRACT_CLASS_DUMP_INFO(Frame)
    CDI_CLASS_MEMBER_OFFSET(m_Next)
END_ABSTRACT_CLASS_DUMP_INFO(Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ResumableFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_Regs)
END_CLASS_DUMP_INFO_DERIVED(ResumableFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(RedirectedThreadFrame, ResumableFrame)
END_CLASS_DUMP_INFO_DERIVED(RedirectedThreadFrame, ResumableFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(TransitionFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_Datum)
    CDI_CLASS_MEMBER_OFFSET(m_ReturnAddress)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(TransitionFrame, Frame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ExceptionFrame, Frame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ExceptionFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(FaultingExceptionFrame, ExceptionFrame)
    CDI_CLASS_MEMBER_OFFSET(m_Esp)
    CDI_CLASS_MEMBER_OFFSET(m_regs)
END_CLASS_DUMP_INFO_DERIVED(FaultingExceptionFrame, ExceptionFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(FuncEvalFrame, TransitionFrame)
END_CLASS_DUMP_INFO_DERIVED(FuncEvalFrame, TransitionFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame, TransitionFrame)
    CDI_CLASS_MEMBER_OFFSET(m_Attribs)
    CDI_CLASS_MEMBER_OFFSET(m_MachState)
    CDI_CLASS_MEMBER_OFFSET(m_RegArgs)
    CDI_CLASS_MEMBER_OFFSET(m_pThread)
    CDI_CLASS_MEMBER_OFFSET(m_FCallEntry)
END_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame, TransitionFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_1OBJ, HelperMethodFrame)
    CDI_CLASS_MEMBER_OFFSET(gcPtrs)
END_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_1OBJ, HelperMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_2OBJ, HelperMethodFrame)
    CDI_CLASS_MEMBER_OFFSET(gcPtrs)
END_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_2OBJ, HelperMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_4OBJ, HelperMethodFrame)
    CDI_CLASS_MEMBER_OFFSET(gcPtrs)
END_CLASS_DUMP_INFO_DERIVED(HelperMethodFrame_4OBJ, HelperMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(FramedMethodFrame, TransitionFrame)
END_CLASS_DUMP_INFO_DERIVED(FramedMethodFrame, TransitionFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(TPMethodFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(TPMethodFrame, FramedMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ECallMethodFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(ECallMethodFrame, FramedMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(FCallMethodFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(FCallMethodFrame, FramedMethodFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrame, FramedMethodFrame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrame, FramedMethodFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameEx, NDirectMethodFrame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameEx, NDirectMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameGeneric, NDirectMethodFrameEx)
END_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameGeneric, NDirectMethodFrameEx)

BEGIN_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameSlim, NDirectMethodFrameEx)
END_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameSlim, NDirectMethodFrameEx)

BEGIN_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameStandalone, NDirectMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameStandalone, NDirectMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameStandaloneCleanup, NDirectMethodFrameEx)
END_CLASS_DUMP_INFO_DERIVED(NDirectMethodFrameStandaloneCleanup, NDirectMethodFrameEx)

BEGIN_CLASS_DUMP_INFO_DERIVED(MulticastFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(MulticastFrame, FramedMethodFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(UnmanagedToManagedFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_pvDatum)
    CDI_CLASS_MEMBER_OFFSET(m_ReturnAddress)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(UnmanagedToManagedFrame, Frame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(UnmanagedToManagedCallFrame, UnmanagedToManagedFrame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(UnmanagedToManagedCallFrame, UnmanagedToManagedFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ComMethodFrame, UnmanagedToManagedCallFrame)
END_CLASS_DUMP_INFO_DERIVED(ComMethodFrame, UnmanagedToManagedCallFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrame, FramedMethodFrame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrame, FramedMethodFrame)

BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameEx, ComPlusMethodFrame)
END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameEx, ComPlusMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameGeneric, ComPlusMethodFrameEx)
END_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameGeneric, ComPlusMethodFrameEx)

BEGIN_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameStandalone, ComPlusMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameStandalone, ComPlusMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameStandaloneCleanup, ComPlusMethodFrameEx)
END_CLASS_DUMP_INFO_DERIVED(ComPlusMethodFrameStandaloneCleanup, ComPlusMethodFrameEx)

BEGIN_CLASS_DUMP_INFO_DERIVED(PInvokeCalliFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(PInvokeCalliFrame, FramedMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(HijackFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_ReturnAddress)
    CDI_CLASS_MEMBER_OFFSET(m_Thread)
    CDI_CLASS_MEMBER_OFFSET(m_Args)
END_CLASS_DUMP_INFO_DERIVED(HijackFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(SecurityFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(SecurityFrame, FramedMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(PrestubMethodFrame, FramedMethodFrame)
END_CLASS_DUMP_INFO_DERIVED(PrestubMethodFrame, FramedMethodFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(InterceptorFrame, SecurityFrame)
END_CLASS_DUMP_INFO_DERIVED(InterceptorFrame, SecurityFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ComPrestubMethodFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_pFuncDesc)
    CDI_CLASS_MEMBER_OFFSET(m_ReturnAddress)
END_CLASS_DUMP_INFO_DERIVED(ComPrestubMethodFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(GCFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_pObjRefs)
    CDI_CLASS_MEMBER_OFFSET(m_numObjRefs)
    CDI_CLASS_MEMBER_OFFSET(m_pCurThread)
    CDI_CLASS_MEMBER_OFFSET(m_MaybeInterior)
END_CLASS_DUMP_INFO_DERIVED(GCFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ProtectByRefsFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_brInfo)
    CDI_CLASS_MEMBER_OFFSET(m_pThread)
END_CLASS_DUMP_INFO_DERIVED(ProtectByRefsFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ProtectValueClassFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_pVCInfo)
    CDI_CLASS_MEMBER_OFFSET(m_pThread)
END_CLASS_DUMP_INFO_DERIVED(ProtectValueClassFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(DebuggerClassInitMarkFrame, Frame)
END_CLASS_DUMP_INFO_DERIVED(DebuggerClassInitMarkFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(DebuggerSecurityCodeMarkFrame, Frame)
END_CLASS_DUMP_INFO_DERIVED(DebuggerSecurityCodeMarkFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(DebuggerExitFrame, Frame)
END_CLASS_DUMP_INFO_DERIVED(DebuggerExitFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(UMThkCallFrame, UnmanagedToManagedCallFrame)
END_CLASS_DUMP_INFO_DERIVED(UMThkCallFrame, UnmanagedToManagedCallFrame)

BEGIN_CLASS_DUMP_INFO_DERIVED(InlinedCallFrame, Frame)
    CDI_CLASS_MEMBER_OFFSET(m_Datum)
    CDI_CLASS_MEMBER_OFFSET(m_pCallSiteTracker)
    CDI_CLASS_MEMBER_OFFSET(m_pCallerReturnAddress)
    CDI_CLASS_MEMBER_OFFSET(m_pCalleeSavedRegisters)
END_CLASS_DUMP_INFO_DERIVED(InlinedCallFrame, Frame)

BEGIN_CLASS_DUMP_INFO_DERIVED(ContextTransitionFrame, Frame)
END_CLASS_DUMP_INFO_DERIVED(ContextTransitionFrame, Frame)


#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
    #error "Need to change this file."
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusion.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IInstallReferenceItem_FWD_DEFINED__
#define __IInstallReferenceItem_FWD_DEFINED__
typedef interface IInstallReferenceItem IInstallReferenceItem;
#endif 	/* __IInstallReferenceItem_FWD_DEFINED__ */


#ifndef __IInstallReferenceEnum_FWD_DEFINED__
#define __IInstallReferenceEnum_FWD_DEFINED__
typedef interface IInstallReferenceEnum IInstallReferenceEnum;
#endif 	/* __IInstallReferenceEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#pragma once




EXTERN_C const IID IID_IAssemblyCache;      
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IAssemblyEnum;       
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0001
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4
    } 	ASM_CACHE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
DEFINE_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
DEFINE_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
 // {25df0fc1-7f97-4070-add7-4b13bbfd7cb8} // this GUID cannot be used for installing into GAC.
DEFINE_GUID(FUSION_REFCOUNT_MSI_GUID,  0x25df0fc1, 0x7f97, 0x4070, 0xad, 0xd7, 0x4b, 0x13, 0xbb, 0xfd, 0x7c, 0xb8); 
 // {d16d444c-56d8-11d5-882d-0080c847b195}
DEFINE_GUID(FUSION_REFCOUNT_OSINSTALL_GUID, 0xd16d444c, 0x56d8, 0x11d5, 0x88, 0x2d, 0x00, 0x80, 0xc8, 0x47, 0xb1, 0x95); 
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const FUSION_INSTALL_REFERENCE *LPCFUSION_INSTALL_REFERENCE;

typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_INSTALL_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES (5)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND (6)
#define QUERYASMINFO_FLAG_VALIDATE        (0x00000001)
#define QUERYASMINFO_FLAG_GETSIZE         (0x00000002)
#define ASSEMBLYINFO_FLAG_INSTALLED       (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)

EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IUnknown **ppUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppUnkReserved)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppUnkReserved)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IUnknown **ppUnkReserved);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)

EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_FILE_MAJOR_VERSION	= ASM_NAME_MVID + 1,
	ASM_NAME_FILE_MINOR_VERSION	= ASM_NAME_FILE_MAJOR_VERSION + 1,
	ASM_NAME_FILE_BUILD_NUMBER	= ASM_NAME_FILE_MINOR_VERSION + 1,
	ASM_NAME_FILE_REVISION_NUMBER	= ASM_NAME_FILE_BUILD_NUMBER + 1,
	ASM_NAME_RETARGET	= ASM_NAME_FILE_REVISION_NUMBER + 1,
	ASM_NAME_SIGNATURE_BLOB	= ASM_NAME_RETARGET + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_SIGNATURE_BLOB + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40,
	ASM_DISPLAYF_RETARGET	= 0x80
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_DEFAULT	= 0x100,
	ASM_CMPF_RETARGET	= 0x200,
	ASM_CMPF_ALL	= ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM | ASM_CMPF_RETARGET
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)	\
    (This)->lpVtbl -> BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_BindToObject_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IUnknown *pUnkSink,
    /* [in] */ IUnknown *pUnkContext,
    /* [in] */ LPCOLESTR szCodeBase,
    /* [in] */ LONGLONG llFlags,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyName_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,pvReserved,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,pvReserved,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [in] */ LPVOID pvReserved,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceItem_INTERFACE_DEFINED__
#define __IInstallReferenceItem_INTERFACE_DEFINED__

/* interface IInstallReferenceItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("582dac66-e678-449f-aba6-6faaec8a9394")
    IInstallReferenceItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IInstallReferenceItem * This,
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceItemVtbl;

    interface IInstallReferenceItem
    {
        CONST_VTBL struct IInstallReferenceItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceItem_GetReference(This,ppRefData,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetReference(This,ppRefData,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceItem_GetReference_Proxy( 
    IInstallReferenceItem * This,
    /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceItem_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceItem_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceEnum_INTERFACE_DEFINED__
#define __IInstallReferenceEnum_INTERFACE_DEFINED__

/* interface IInstallReferenceEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")
    IInstallReferenceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextInstallReferenceItem( 
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInstallReferenceItem )( 
            IInstallReferenceEnum * This,
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceEnumVtbl;

    interface IInstallReferenceEnum
    {
        CONST_VTBL struct IInstallReferenceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceEnum_GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceEnum_GetNextInstallReferenceItem_Proxy( 
    IInstallReferenceEnum * This,
    /* [out] */ IInstallReferenceItem **ppRefItem,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceEnum_GetNextInstallReferenceItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0118 */
/* [local] */ 

STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IUnknown *pUnkReserved, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath); 


extern RPC_IF_HANDLE __MIDL_itf_fusion_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0118_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\eetwain.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//
// EETwain.h
//
// This file has the definition of ICodeManager and EECodeManager.
//
// ICorJitCompiler compiles the IL of a method to native code, and stores
// auxilliary data called as GCInfo (via ICorJitInfo::allocGCInfo()).
// The data is used by the EE to manage the method's garbage collection,
// exception handling, stack-walking etc.
// This data can be parsed by an ICodeManager corresponding to that
// ICorJitCompiler.
//
// EECodeManager is an implementation of ICodeManager for a default format
// of GCInfo. Various ICorJitCompiler's are free to share this format so that
// they do not need to provide their own implementation of ICodeManager
// (though they are permitted to, if they want).
//
//*****************************************************************************
#ifndef _EETWAIN_H
#define _EETWAIN_H
//*****************************************************************************

#include "regdisp.h"
#include "corjit.h"     // For NativeVarInfo

struct EHContext;

typedef void (*GCEnumCallback)(
    LPVOID          hCallback,      // callback data
    OBJECTREF*      pObject,        // address of obect-reference we are reporting
    DWORD           flags           // is this a pinned and/or interior pointer
);

/******************************************************************************
  The stackwalker maintains some state on behalf of ICodeManager.
*/

const int CODEMAN_STATE_SIZE = 256;

struct CodeManState
{
    DWORD       dwIsSet; // Is set to 0 by the stackwalk as appropriate
    BYTE        stateBuf[CODEMAN_STATE_SIZE];
};

/******************************************************************************
   These flags are used by some functions, although not all combinations might
   make sense for all functions.
*/

enum ICodeManagerFlags 
{
    ActiveStackFrame =  0x0001, // this is the currently active function
    ExecutionAborted =  0x0002, // execution of this function has been aborted
                                    // (i.e. it will not continue execution at the
                                    // current location)
    AbortingCall    =   0x0004, // The current call will never return
    UpdateAllRegs   =   0x0008, // update full register set
    CodeAltered     =   0x0010, // code of that function might be altered
                                    // (e.g. by debugger), need to call EE
                                    // for original code
};

//*****************************************************************************
//
// This interface is used by ICodeManager to get information about the
// method whose GCInfo is being processed.
// It is useful so that some information which is available elsewhere does
// not need to be cached in the GCInfo.
// It is similar to corinfo.h - ICorMethodInfo
//

class ICodeInfo
{
public:

    // this function is for debugging only.  It returns the method name
    // and if 'moduleName' is non-null, it sets it to something that will
    // says which method (a class name, or a module name)
    virtual const char* __stdcall getMethodName(const char **moduleName /* OUT */ ) = 0;

    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getMethodAttribs() = 0;

    // Returns the  CorInfoFlag's from corinfo.h
    virtual DWORD       __stdcall getClassAttribs() = 0;

    virtual void        __stdcall getMethodSig(CORINFO_SIG_INFO *sig /* OUT */ ) = 0;

    // Start IP of the method
    virtual LPVOID      __stdcall getStartAddress() = 0;

    // Get the MethodDesc of the method. This is a hack as MethodDescs are
    // not exposed in the public APIs. However, it is currently used by
    // the EJIT to report vararg arguments to GC.
    // @TODO : Fix the EJIT to not use the MethodDesc directly.
    virtual void *                getMethodDesc_HACK() = 0;
};

//*****************************************************************************
//
// ICodeManager is the abstract class that all CodeManagers 
// must inherit from.  This will probably need to move into
// cor.h and become a real com interface.
// 
//*****************************************************************************

class ICodeManager
{
public:

/*
    First chance for the runtime support to suppress conversion
    from a win32 fault to a COM+ exception. Instead it could
    fixup the faulting context and request the continuation
    of execution
*/
virtual bool FilterException (PCONTEXT        pContext,
                              unsigned        win32Fault,
                              LPVOID          methodInfoPtr,
                              LPVOID          methodStart) = 0;

/*
    Last chance for the runtime support to do fixups in the context
    before execution continues inside a filter, catch handler, or fault/finally
*/

enum ContextType
{
    FILTER_CONTEXT,
    CATCH_CONTEXT,
    FINALLY_CONTEXT
};

/* Type of funclet corresponding to a shadow stack-pointer */

enum
{
    SHADOW_SP_IN_FILTER = 0x1,
    SHADOW_SP_FILTER_DONE = 0x2,
    SHADOW_SP_BITS = 0x3
};

virtual void FixContext(ContextType     ctxType,
                        EHContext      *ctx,
                        LPVOID          methodInfoPtr,
                        LPVOID          methodStart,
                        DWORD           nestingLevel,
                        OBJECTREF       thrownObject,
                        CodeManState   *pState,
                        size_t       ** ppShadowSP,             // OUT
                        size_t       ** ppEndRegion) = 0;       // OUT

/*
    Last chance for the runtime support to do fixups in the context
    before execution continues inside an EnC updated function.
*/

enum EnC_RESULT
{
    EnC_OK,                     // EnC can continue
                                
    EnC_INFOLESS_METHOD,        // Method was not JITed in EnC mode
    EnC_NESTED_HANLDERS,        // Frame cant be updated due to change in max nesting of handlers
    EnC_IN_FUNCLET,             // Method is in a callable handler/filter. Cant grow stack
    EnC_LOCALLOC,               // Frame cant be updated due to localloc
    EnC_FAIL,                   // EnC fails due to unknown/other reason

    EnC_COUNT
};

virtual EnC_RESULT FixContextForEnC(void           *pMethodDescToken,
                                    PCONTEXT        ctx,
                                    LPVOID          oldMethodInfoPtr,
                                    SIZE_T          oldMethodOffset,
               const ICorDebugInfo::NativeVarInfo * oldMethodVars,
                                    SIZE_T          oldMethodVarsCount,
                                    LPVOID          newMethodInfoPtr,
                                    SIZE_T          newMethodOffset,
               const ICorDebugInfo::NativeVarInfo * newMethodVars,
                                    SIZE_T          newMethodVarsCount) = 0;


/*
    Unwind the current stack frame, i.e. update the virtual register
    set in pContext. This will be similar to the state after the function
    returns back to caller (IP points to after the call, Frame and Stack
    pointer has been reset, callee-saved registers restored 
    (if UpdateAllRegs), callee-UNsaved registers are trashed)
    Returns success of operation.
*/
virtual bool UnwindStackFrame(PREGDISPLAY     pContext,
                              LPVOID          methodInfoPtr,
                              ICodeInfo      *pCodeInfo,
                              unsigned        flags,
						      CodeManState   *pState) = 0;
/*
    Is the function currently at a "GC safe point" ? 
    Can call EnumGcRefs() successfully
*/
virtual bool IsGcSafe(PREGDISPLAY     pContext,
                      LPVOID          methodInfoPtr,
                      ICodeInfo      *pCodeInfo,
                      unsigned        flags) = 0;

/*
    Enumerate all live object references in that function using
    the virtual register set. Same reference location cannot be enumerated 
    multiple times (but all differenct references pointing to the same
    object have to be individually enumerated).
    Returns success of operation.
*/
virtual bool EnumGcRefs(PREGDISPLAY     pContext,
                        LPVOID          methodInfoPtr,
                        ICodeInfo      *pCodeInfo,
                        unsigned        curOffs,
                        unsigned        flags,
                        GCEnumCallback  pCallback,
                        LPVOID          hCallBack) = 0;

/*
    Return the address of the local security object reference
    (if available).
*/
virtual OBJECTREF* GetAddrOfSecurityObject(PREGDISPLAY     pContext,
                                           LPVOID          methodInfoPtr,
                                           unsigned        relOffset,
            						       CodeManState   *pState) = 0;

/*
    Returns "this" pointer if it is a non-static method AND
    the object is still alive.
    Returns NULL in all other cases.
*/
virtual OBJECTREF GetInstance(PREGDISPLAY     pContext,
                              LPVOID          methodInfoPtr,
                              ICodeInfo      *pCodeInfo,
                              unsigned        relOffset) = 0;

/*
  Returns true if the given IP is in the given method's prolog or an epilog.
*/
virtual bool IsInPrologOrEpilog(DWORD  relPCOffset,
                                LPVOID methodInfoPtr,
                                size_t* prologSize) = 0;

/*
  Returns the size of a given function.
*/
virtual size_t GetFunctionSize(LPVOID methodInfoPtr) = 0;

/*
  Returns the size of the frame (barring localloc)
*/
virtual unsigned int GetFrameSize(LPVOID methodInfoPtr) = 0;

/* Debugger API */

virtual const BYTE*     GetFinallyReturnAddr(PREGDISPLAY pReg)=0;

virtual BOOL            IsInFilter(void *methodInfoPtr,
                                   unsigned offset,    
                                   PCONTEXT pCtx,
                                   DWORD curNestLevel) = 0;

virtual BOOL            LeaveFinally(void *methodInfoPtr,
                                     unsigned offset,    
                                     PCONTEXT pCtx,
                                     DWORD curNestLevel) = 0;

virtual void            LeaveCatch(void *methodInfoPtr,
                                   unsigned offset,    
                                   PCONTEXT pCtx)=0;

/*
  This is called before the EnC is actually performed.  If this
  returns FALSE, then the debugger won't EnC this method
*/
virtual HRESULT			JITCanCommitChanges(LPVOID methodInfoPtr,
								   DWORD oldMaxEHLevel,
						     	   DWORD newMaxEHLevel)=0;                                   
};


//*****************************************************************************
//
// EECodeManager is the EE's implementation of the ICodeManager which
// supports the default format of GCInfo.
// 
//*****************************************************************************

class EECodeManager : public ICodeManager {



/*
    First chance for the runtime support to suppress conversion
    from a win32 fault to a COM+ exception. Instead it could
    fixup the faulting context and request the continuation
    of execution
*/
public:

virtual 
bool FilterException (
                PCONTEXT        pContext,
                unsigned        win32Fault,
                LPVOID          methodInfoPtr,
                LPVOID          methodStart);

/*
    Last chance for the runtime support to do fixups in the context
    before execution continues inside a filter, catch handler, or finally
*/
virtual
void FixContext(ContextType     ctxType,
                EHContext      *ctx,
                LPVOID          methodInfoPtr,
                LPVOID          methodStart,
                DWORD           nestingLevel, 
                OBJECTREF       thrownObject,
                CodeManState   *pState,
                size_t       ** ppShadowSP,             // OUT
                size_t       ** ppEndRegion);           // OUT

/*
    Last chance for the runtime support to do fixups in the context
    before execution continues inside an EnC updated function.
*/
virtual 
EnC_RESULT FixContextForEnC(void           *pMethodDescToken,
                            PCONTEXT        ctx,
                            LPVOID          oldMethodInfoPtr,
                            SIZE_T          oldMethodOffset,
       const ICorDebugInfo::NativeVarInfo * oldMethodVars,
                            SIZE_T          oldMethodVarsCount,
                            LPVOID          newMethodInfoPtr,
                            SIZE_T          newMethodOffset,
       const ICorDebugInfo::NativeVarInfo * newMethodVars,
                            SIZE_T          newMethodVarsCount);

/*
    Unwind the current stack frame, i.e. update the virtual register
    set in pContext. This will be similar to the state after the function
    returns back to caller (IP points to after the call, Frame and Stack
    pointer has been reset, callee-saved registers restored 
    (if UpdateAllRegs), callee-UNsaved registers are trashed)
    Returns success of operation.
*/
virtual
bool UnwindStackFrame(
                PREGDISPLAY     pContext,
                LPVOID          methodInfoPtr,
                ICodeInfo      *pCodeInfo,
                unsigned        flags,
				CodeManState   *pState);
/*
    Is the function currently at a "GC safe point" ?
    Can call EnumGcRefs() successfully
*/
virtual
bool IsGcSafe(  PREGDISPLAY     pContext,
                LPVOID          methodInfoPtr,
                ICodeInfo      *pCodeInfo,
                unsigned        flags);

/*
    Enumerate all live object references in that function using
    the virtual register set. Same reference location cannot be enumerated 
    multiple times (but all differenct references pointing to the same
    object have to be individually enumerated).
    Returns success of operation.
*/
virtual
bool EnumGcRefs(PREGDISPLAY     pContext,
                LPVOID          methodInfoPtr,
                ICodeInfo      *pCodeInfo,
                unsigned        pcOffset,
                unsigned        flags,
                GCEnumCallback  pCallback,
                LPVOID          hCallBack);

/*
    Return the address of the local security object reference
    (if available).
*/
virtual
OBJECTREF* GetAddrOfSecurityObject(
                PREGDISPLAY     pContext,
                LPVOID          methodInfoPtr,
                unsigned        relOffset,
				CodeManState   *pState);

/*
    Returns "this" pointer if it is a non-static method AND
    the object is still alive.
    Returns NULL in all other cases.
*/
virtual
OBJECTREF GetInstance(
                PREGDISPLAY     pContext,
                LPVOID          methodInfoPtr,
                ICodeInfo      *pCodeInfo,
                unsigned        relOffset);

/*
  Returns true if the given IP is in the given method's prolog or an epilog.
*/
virtual
bool IsInPrologOrEpilog(
                DWORD           relOffset,
                LPVOID          methodInfoPtr,
                size_t*         prologSize);

/*
  Returns the size of a given function.
*/
virtual
size_t GetFunctionSize(
                LPVOID          methodInfoPtr);

/*
  Returns the size of the frame (barring localloc)
*/
virtual
unsigned int GetFrameSize(
                LPVOID          methodInfoPtr);

virtual const BYTE* GetFinallyReturnAddr(PREGDISPLAY pReg);
virtual BOOL LeaveFinally(void *methodInfoPtr,
                          unsigned offset,    
                          PCONTEXT pCtx,
                          DWORD curNestLevel);
virtual BOOL IsInFilter(void *methodInfoPtr,
                        unsigned offset,    
                        PCONTEXT pCtx,
                          DWORD curNestLevel);
virtual void LeaveCatch(void *methodInfoPtr,
                         unsigned offset,    
                         PCONTEXT pCtx);

virtual HRESULT JITCanCommitChanges(LPVOID methodInfoPtr,
                              DWORD oldMaxEHLevel,
                              DWORD newMaxEHLevel);

    private:
        unsigned dummy;
};


/*****************************************************************************
 ToDo: Do we want to include JIT/IL/target.h? 
 */

enum regNum
{
        REGI_EAX, REGI_ECX, REGI_EDX, REGI_EBX,
        REGI_ESP, REGI_EBP, REGI_ESI, REGI_EDI,
        REGI_COUNT,
        REGI_NA = REGI_COUNT
};

/*****************************************************************************
 Register masks
 */

enum RegMask
{
    RM_EAX = 0x01,
    RM_ECX = 0x02,
    RM_EDX = 0x04,
    RM_EBX = 0x08,
    RM_ESP = 0x10,
    RM_EBP = 0x20,
    RM_ESI = 0x40,
    RM_EDI = 0x80,

    RM_NONE = 0x00,
    RM_ALL = (RM_EAX|RM_ECX|RM_EDX|RM_EBX|RM_ESP|RM_EBP|RM_ESI|RM_EDI),
    RM_CALLEE_SAVED = (RM_EBP|RM_EBX|RM_ESI|RM_EDI),
    RM_CALLEE_TRASHED = (RM_ALL & ~RM_CALLEE_SAVED),
};

/*****************************************************************************
 *
 *  Helper to extract basic info from a method info block.
 */

struct hdrInfo
{
    unsigned int        methodSize;     // native code bytes
    unsigned int        argSize;        // in bytes
    unsigned int        stackSize;      /* including callee saved registers */
    unsigned int        rawStkSize;     /* excluding callee saved registers */

    unsigned int        prologSize;
    unsigned int        epilogSize;

    unsigned char       epilogCnt;
    bool                epilogEnd;      // is the epilog at the end of the method
    bool                ebpFrame;       // locals addressed relative to EBP
    bool                interruptible;  // intr. at all times (excluding prolog/epilog), not just call sites

    bool                securityCheck;  // has a slot for security object
    bool                handlers;       // has callable handlers
    bool                localloc;       // uses localloc
    bool                editNcontinue;  // has been compiled in EnC mode
    bool                varargs;        // is this a varargs routine
    bool                doubleAlign;    // is the stack double-aligned
    union
    {
        unsigned char       savedRegMask_begin;
        RegMask             savedRegMask:8; // which callee-saved regs are saved on stack
    };

    unsigned short      untrackedCnt;
    unsigned short      varPtrTableSize;

    int                 prologOffs;     // -1 if not in prolog
    int                 epilogOffs;     // -1 if not in epilog (is never 0)

    //
    // Results passed back from scanArgRegTable
    //
    regNum              thisPtrResult;  // register holding "this"
    RegMask             regMaskResult;  // registers currently holding GC ptrs
    RegMask            iregMaskResult;  // iptr qualifier for regMaskResult
    unsigned            argMaskResult;  // pending arguments mask
    unsigned           iargMaskResult;  // iptr qualifier for argMaskResult
    unsigned            argHnumResult;
    BYTE *               argTabResult;  // Table of encoded offsets of pending ptr args
    unsigned              argTabBytes;  // Number of bytes in argTabResult[]
};

/*****************************************************************************
  How the stackwalkers buffer will be interpreted
*/

struct CodeManStateBuf
{
    DWORD       hdrInfoSize;
    hdrInfo     hdrInfoBody;
};

//*****************************************************************************
#endif // _EETWAIN_H
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\enc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __ENC_INCLUDED__
#define __ENC_INCLUDED__

// Forward declaration of VM class
class Module;
class DebuggerModule;

/*
 * This struct contains information for each contained PE
 */
struct EnCEntry
{
    ULONG32 offset;         // Offset into struct of PE image
    ULONG32 peSize;         // Size of the PE image
    ULONG32 symSize;        // Size of the symbol image

    // On the right side, it's a token, on the left side it's a DebuggerModule*
    union
    {
        void*           mdbgtoken;
        DebuggerModule *dbgmodule;
    };

    Module         *module;     // After translation, the is the VM Module pointer

};

struct EnCInfo
{
    ULONG32 count;
    // EnCEntry[count] placed here
    // PE data placed here
};

#define ENC_GET_HEADER_SIZE(numElems) \
    (sizeof(EnCInfo) + (sizeof(EnCEntry) * numElems))

interface IEnCErrorCallback : IUnknown
{
    /*
     * This is the callback entrypoint used by the implementation of ApplyEnC.
     * It is used to post an error back to the debugger.
     */
    virtual HRESULT STDMETHODCALLTYPE PostError(HRESULT hr, DWORD helpfile,
                                                DWORD helpID, ...) PURE;
};

/*
 * Given an EnCInfo struct and an error callback, this will attempt to commit
 * the changes found within pEncInfo, calling pIEnCError with any errors
 * encountered.
 */
HRESULT EnCCommit(EnCInfo *pEnCInfo, IEnCErrorCallback *pIEnCError,
                  BOOL checkOnly);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\endian.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Endian.h
//
// Functions to convert to things to little-endian values. The constants in the
// PE file are stored in little-endian format.
//
// Also, alignment-neutral memory access.
//
//*****************************************************************************

#ifndef __ENDIAN_H__
#define __ENDIAN_H__

#include <windef.h>

#ifndef QWORD
typedef unsigned __int64		QWORD;
#endif


#ifdef _MAC_ // and any other big-endian machines
#define BIG_ENDIAN
#else
#define LITTLE_ENDIAN
#endif

//*****************************************************************************

// Convert data-types from platform-endian to little-endian

BYTE    littleEndianByte(BYTE x); // just for symmetry
WORD    littleEndianWord(WORD x);
DWORD   littleEndianDWord(DWORD x);
QWORD   littleEndianQWord(QWORD x);

//*****************************************************************************

// Read data in an alignment-safe way.

BYTE   readByte (const BYTE * src); // just for symmetry
WORD   readWord (const BYTE * src);
DWORD  readDWord(const BYTE * src);
QWORD  readQWord(const BYTE * src);

// Convert to little-endian, and read data in an alignment-safe way.

BYTE   readByteSmallEndian (const BYTE * src); // just for symmetry
WORD   readWordSmallEndian (const BYTE * src);
DWORD  readDWordSmallEndian(const BYTE * src);
QWORD  readQWordSmallEndian(const BYTE * src);

//*****************************************************************************

// Store data in an alignment-safe way.

void   storeByte (BYTE * dest, const  BYTE * src); // just for symmetry
void   storeWord (BYTE * dest, const  WORD * src);
void   storeDWord(BYTE * dest, const DWORD * src);
void   storeQWord(BYTE * dest, const QWORD * src);

// Convert to little-endian, and store data in an alignment-safe way.

void   storeByteSmallEndian (BYTE * dest, const  BYTE * src); // just for symmetry
void   storeWordSmallEndian (BYTE * dest, const  WORD * src);
void   storeDWordSmallEndian(BYTE * dest, const DWORD * src);
void   storeQWordSmallEndian(BYTE * dest, const QWORD * src);



//*****************************************************************************
//
//                          Inline implementations
//
//*****************************************************************************


#ifdef LITTLE_ENDIAN

// For little-endian machines, do nothing

inline BYTE    littleEndianByte(BYTE x)     { return x; }
inline WORD    littleEndianWord(WORD x)     { return x; }
inline DWORD   littleEndianDWord(DWORD x)   { return x; }
inline QWORD   littleEndianQWord(QWORD x)   { return x; }

#else // BIG_ENDIAN

// For big-endian machines, swap the endian-order

inline BYTE    littleEndianByte(BYTE x)     
{ 
    return x; 
}

inline WORD    littleEndianWord(WORD x)
{
    return ( ((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8) );
}

inline DWORD   littleEndianDWord(DWORD x)
{
    return( ((x & 0xFF000000L) >> 24) |               
            ((x & 0x00FF0000L) >>  8) |              
            ((x & 0x0000FF00L) <<  8) |              
            ((x & 0x000000FFL) << 24) );
}

inline QWORD   littleEndianQWord(QWORD x)   
{
    return( ((x & (QWORD)0xFF00000000000000) >> 56) | 
            ((x & (QWORD)0x00FF000000000000) >> 40) | 
            ((x & (QWORD)0x0000FF0000000000) >> 24) | 
            ((x & (QWORD)0x000000FF00000000) >>  8) | 
            ((x & (QWORD)0x00000000FF000000) <<  8) | 
            ((x & (QWORD)0x0000000000FF0000) << 24) | 
            ((x & (QWORD)0x000000000000FF00) << 40) | 
            ((x & (QWORD)0x00000000000000FF) << 56) );
}

#endif // LITTLE_ENDIAN



//*****************************************************************************

// Read data in an alignment-safe way.

#ifdef _X86_ // or any machine which allows unaligned access

inline BYTE   readByte (const BYTE * src) { return *( BYTE*)src; }
inline WORD   readWord (const BYTE * src) { return *( WORD*)src; }
inline DWORD  readDWord(const BYTE * src) { return *(DWORD*)src; }
inline QWORD  readQWord(const BYTE * src) { return *(QWORD*)src; }

#else // _X86_

#ifdef LITTLE_ENDIAN

inline BYTE   readByte (const BYTE * src) { return readByteSmallEndian (src); }
inline WORD   readWord (const BYTE * src) { return readWordSmallEndian (src); }
inline DWORD  readDWord(const BYTE * src) { return readDWordSmallEndian(src); }
inline QWORD  readQWord(const BYTE * src) { return readQWordSmallEndian(src); }

#else

inline BYTE   readByte (const BYTE * src)
{
    return *src;
}

inline WORD   readWord (const BYTE * src)
{
    return (src[0] << 8) | src[1];
}

inline DWORD  readDWord(const BYTE * src)
{
    return (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
}

inline QWORD  readQWord(const BYTE * src)
{
    return (src[0] << 56) | (src[1] << 48) | (src[2] << 40) | (src[3] << 32) |
           (src[4] << 24) | (src[5] << 16) | (src[6] <<  8) |  src[7];
}

#endif // LITTLE_ENDIAN

#endif // _X86_

//*****************************************************************************

// Convert to little-endian, and read data in an alignment-safe way.

#ifdef _X86_ // or any Little endian machine which allows unaligned access

inline BYTE   readByteSmallEndian (const BYTE * src) { return *( BYTE*)src; }
inline WORD   readWordSmallEndian (const BYTE * src) { return *( WORD*)src; }
inline DWORD  readDWordSmallEndian(const BYTE * src) { return *(DWORD*)src; }
inline QWORD  readQWordSmallEndian(const BYTE * src) { return *(QWORD*)src; }

#else // _X86_

inline BYTE   readByteSmallEndian (const BYTE * src)
{
    return *src;
}

inline WORD   readWordSmallEndian (const BYTE * src)
{
    return (src[1] << 8) | src[0];
}

inline DWORD  readDWordSmallEndian(const BYTE * src)
{
    return (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
}

inline QWORD  readQWordSmallEndian(const BYTE * src)
{
    return (src[7] << 56) | (src[6] << 48) | (src[5] << 40) | (src[4] << 32) |
           (src[3] << 24) | (src[2] << 16) | (src[1] <<  8) |  src[0];
}

#endif // _X86_

//*****************************************************************************

#ifdef _X86_ // or any machine which allows unaligned access

inline void   storeByte (BYTE * dest, const  BYTE * src)   { *( BYTE*)dest = *src; }
inline void   storeWord (BYTE * dest, const  WORD * src)   { *( WORD*)dest = *src; }
inline void   storeDWord(BYTE * dest, const DWORD * src)   { *(DWORD*)dest = *src; }
inline void   storeQWord(BYTE * dest, const QWORD * src)   { *(QWORD*)dest = *src; }

#else // ! _X86_

// As non-aligned DWORD access might not be allowed, store individual bytes

inline void   storeByte (BYTE * dest, const  BYTE * src)
{ const BYTE * src_ = (const BYTE *) src;
  dest[0] = src_[0]; }

inline void   storeWord (BYTE * dest, const  WORD * src)
{ const BYTE * src_ = (const BYTE *) src;
  dest[0] = src_[0]; dest[1] = src_[1]; }

inline void   storeDWord(BYTE * dest, const DWORD * src)
{ const BYTE * src_ = (const BYTE *) src;
  dest[0] = src_[0]; dest[1] = src_[1]; dest[2] = src_[2]; dest[3] = src_[3]; }

inline void   storeQWord(BYTE * dest, const QWORD * src)
{ const BYTE * src_ = (const BYTE *) src;
  dest[0] = src_[0]; dest[1] = src_[1]; dest[2] = src_[2]; dest[3] = src_[3];
  dest[4] = src_[4]; dest[5] = src_[5]; dest[6] = src_[6]; dest[7] = src_[7]; }

#endif // _X86_




#ifdef LITTLE_ENDIAN

inline void   storeByteSmallEndian (BYTE * dest, const  BYTE * src) 
{ storeByte(dest, src); }

inline void   storeWordSmallEndian (BYTE * dest, const  WORD * src)
{ storeWord(dest, src); }

inline void   storeDWordSmallEndian(BYTE * dest, const DWORD * src)
{ storeDWord(dest, src); }

inline void   storeQWordSmallEndian(BYTE * dest, const QWORD * src)
{ storeQWord(dest, src); }

#else // BIG_ENDIAN

inline void   storeByteSmallEndian (BYTE * dest, const  BYTE * src)
{ BYTE * src_ = (BYTE *) src;
  dest[0] = src_[0]; }

inline void   storeWordSmallEndian (BYTE * dest, const  WORD * src)
{ BYTE * src_ = (BYTE *) src;
  dest[0] = src_[1]; dest[1] = src_[0]; }

inline void   storeDWordSmallEndian(BYTE * dest, const DWORD * src)
{ BYTE * src_ = (BYTE *) src;
  dest[0] = src_[3]; dest[1] = src_[2]; dest[2] = src_[1]; dest[3] = src_[0]; }

inline void   storeQWordSmallEndian(BYTE * dest, const QWORD * src)
{ BYTE * src_ = (BYTE *) src;
  dest[0] = src_[7]; dest[1] = src_[6]; dest[2] = src_[5]; dest[3] = src_[4];
  dest[4] = src_[3]; dest[5] = src_[2]; dest[6] = src_[1]; dest[7] = src_[0]; }

#endif // LITTLE_ENDIAN



//*****************************************************************************

#endif // __ENDIAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\dump-types.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* Tables needed by Minidump & Strike */

/*
 * Before processing this file, the following macro's must be defined:
 *
 * BEGIN_CLASS_DUMP_INFO(name)
 *    - Set things up to accept CDI_* entries
 *
 * END_CLASS_DUMP_INFO(name)
 *    - clean things up from BEGIN_CLASS_DUMP_INFO
 *
 * CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(name)
 *    - Certain class fields (currently in the gc_heap class) are non-static
 *      members on Server builds, and static members on workstation builds.
 *      This macro is for them.
 *    - ``name'' is the name of the member.
 *    - YAGH (Yet Another Glorious Hack, which also includes _INJECT,
 *      _DEBUG_ONLY, _MH_AND_NIH_ONLY, and possibly others)
 *
 * CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(name)
 *    - Like CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS
 *      - On Server builds, it's an offset.
 *      - On Workstation builds, it's a /global/ variable, not a class-static.
 *      - Only used in gc_heap
 *
 * CDI_CLASS_INJECT(misc)
 *    - ``misc'' contains literal code that may be copied directly into the
 *      resulting output, if desired.
 *    - By convention, ``misc'' should be another macro, specifying what the
 *      injected code is for.  Currently, ``FOR_STRIKE'' is the only one.
 *      This is done so that only some parts of the injected code is used.
 *
 * CDI_CLASS_MEMBER_OFFSET(member)
 *    - ``member'' is the name of a member that resides within the class
 *      ``name'' used in BEGIN_CLASS_DUMP_INFO.
 *
 * CDI_CLASS_MEMBER_OFFSET_BITFIELD(member, size)
 *    - ``member'' is the name of the bitfield
 *    - ``size'' is the size (in BITS) of the bitfield
 *
 * CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(member)
 *    - ``member'' is a field present only when _DEBUG is defined.
 *
 * CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(member)
 *    - ``member'' is a field present only when _DEBUG is not defined.
 *    - Currently only applies to the PerfUtil & related classes.
 *
 * CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(member)
 *    - only for: defined(MULTIPLE_HEAPS) && !defined(ISOLATED_HEAPS)
 *
 * CDI_CLASS_STATIC_ADDRESS(member)
 *    - ``member'' is a static member of the class
 *
 * CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(member)
 *    - ``member'' is a static member of the class
 *    - This is present only in retail builds.
 *
 * CDI_GLOBAL_ADDRESS(global)
 *    - ``global'' is a global variable.
 *
 * CDI_GLOBAL_ADDRESS_DEBUG_ONLY(global)
 *    - ``global'' is present only on debug builds
 *
 * BEGIN_CLASS_DUMP_TABLE(name)
 * END_CLASS_DUMP_TABLE(class-name)
 * CDT_CLASS_ENTRY(klass)
 *
 *
 * Care And Feeding:
 * ----------------
 * The entries in this file are used in 3 (future: 4) different places for
 * effectively 1 purpose: to remove Strike's dependency on PDB files.
 *
 * For Strike to function, it needs to know various things which it uses PDB
 * files for: offsets of class members (so it can crawl the GC heap, locks,
 * etc.) and the address of global/class-static variables.
 *
 * Of course, a PDB requirement is evil, especially if we want customers to
 * use Strike (which we do).
 *
 * The solution is to create a table hosted inside the runtime, which Strike
 * can read to determine the offsets/addresses.  To reduce IP leaks, all the
 * table contains is offsets, addresses, class sizes, a version number, and
 * miscellaneous members (see <dump-tables.h>).  There's no way to determine
 * what table element goes with which class without using this file.
 *
 * So, the 3 places this file is used (and macros are provided) are:
 *  1: <dump-type-tables.h>, which generates indexes into the table.
 *  2: ``vm/dump-table.cpp'', which generates the table in the runtime
 *  3: ``tools/strike/eestructs.cpp'', which generates "Fill" functions for
 *    each class listed here.
 *  4: (future): ``minidump/???'', which can act much like Strike (or simply
 *    use strike, as appropriate).
 *
 * The use of all these locations *must* be coordinated, or the build will
 * break.  This is due because they all use this file, so if this file
 * changes, they *may* have to change.  For example, adding classes/data
 * members won't require changes in (1) and (2), but may require changes to
 * (3).  Changing the name of a macro will require changes everywhere.
 *
 * Additionally, all of these macro's are cleared in
 * <clear-class-dump-defs.h>, so that if you want to provide a new
 * implementation of the macros, including this file will clear all previous
 * defs.  The existing implementations use this file.
 *
 * If you add new macros, all locations must be updated (the 3-4 different
 * implemenation locations + <clear-class-dump-defs.h>), lest the anger of the
 * compiler gods come upon you (with errors of duplicated macro
 * definitions...).
 *
 * Note that for maximum utility, the table must remain binary-compatible from
 * release to release (or use a different version number).  This is so that
 * older versions of strike can be used with the most recent builds of the
 * runtime.
 *
 * If new fields must be added, they should be added to the end of the class.
 * If new classes are added, they should be added to the end of the Class Dump
 * Table.
 */

BEGIN_CLASS_DUMP_INFO(alloc_context)
  /* only for: defined(MULTIPLE_HEAPS) && !defined(ISOLATED_HEAPS) */
  CDI_CLASS_MEMBER_OFFSET_MH_AND_NIH_ONLY(alloc_heap)
END_CLASS_DUMP_INFO(alloc_context)

BEGIN_CLASS_DUMP_INFO(AppDomain)
  CDI_CLASS_MEMBER_OFFSET(m_pwzFriendlyName)
  CDI_CLASS_MEMBER_OFFSET(m_pDefaultContext)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      BaseDomain::Fill (dwAddr);
      if (!CallStatus)
        return;}))
  CDI_CLASS_INJECT(FOR_STRIKE(if(false) {))
  CDI_CLASS_MEMBER_OFFSET(m_sDomainLocalBlock)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      ULONG v = GetFieldOffset (offset_member_AppDomain::m_sDomainLocalBlock);
      DWORD_PTR dwAddr = dwStartAddr + v;
      m_sDomainLocalBlock.Fill (dwAddr);}))
END_CLASS_DUMP_INFO(AppDomain)

BEGIN_CLASS_DUMP_INFO(ArrayClass)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(m_dwRank, 8)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(m_ElementType, 8)
  CDI_CLASS_MEMBER_OFFSET(m_ElementTypeHnd)
END_CLASS_DUMP_INFO(ArrayClass)

BEGIN_CLASS_DUMP_INFO(ArrayList)
  CDI_CLASS_MEMBER_OFFSET(m_count)
  CDI_CLASS_MEMBER_OFFSET(m_firstBlock)
  CDI_CLASS_INJECT(FOR_STRIKE(
      if (m_firstBlock.m_blockSize != ARRAY_BLOCK_SIZE_START)
      {
          dprintf("strike error: unexpected block size in ArrayList\n");
          return;
      }))
END_CLASS_DUMP_INFO(ArrayList)

BEGIN_CLASS_DUMP_INFO(Assembly)
  CDI_CLASS_MEMBER_OFFSET(m_pDomain)
  CDI_CLASS_MEMBER_OFFSET(m_psName)
  CDI_CLASS_MEMBER_OFFSET(m_pClassLoader)
END_CLASS_DUMP_INFO(Assembly)

BEGIN_CLASS_DUMP_INFO(AwareLock)
  CDI_CLASS_MEMBER_OFFSET(m_MonitorHeld)
  CDI_CLASS_MEMBER_OFFSET(m_Recursion)
  CDI_CLASS_MEMBER_OFFSET(m_HoldingThread)
END_CLASS_DUMP_INFO(AwareLock)

BEGIN_CLASS_DUMP_INFO(BaseDomain)
  CDI_CLASS_MEMBER_OFFSET(m_pLowFrequencyHeap)
  CDI_CLASS_MEMBER_OFFSET(m_pHighFrequencyHeap)
  CDI_CLASS_MEMBER_OFFSET(m_pStubHeap)
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(m_Assemblies)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      size_t v = GetFieldOffset (offset_member_BaseDomain::m_Assemblies);
      DWORD_PTR dwAddr = dwStartAddr + v;
      m_Assemblies.Fill (dwAddr);}))
END_CLASS_DUMP_INFO(BaseDomain)

BEGIN_CLASS_DUMP_INFO(Bucket)
  CDI_CLASS_MEMBER_OFFSET(m_rgKeys)
  CDI_CLASS_MEMBER_OFFSET(m_rgValues)
  CDI_CLASS_INJECT(FOR_STRIKE(
      /* We believe that the top bit is collision info, and we 
       * need to clear it. */
      for (int i = 0; i < 4; i++)
        m_rgValues[i] &= VALUE_MASK;
      ))
END_CLASS_DUMP_INFO(Bucket)

BEGIN_CLASS_DUMP_INFO(CFinalize)
  CDI_CLASS_MEMBER_OFFSET(m_Array)
  CDI_CLASS_MEMBER_OFFSET(m_FillPointers)
  CDI_CLASS_MEMBER_OFFSET(m_EndArray)
END_CLASS_DUMP_INFO(CFinalize)

BEGIN_CLASS_DUMP_INFO(ClassLoader)
  CDI_CLASS_MEMBER_OFFSET(m_pAssembly)
  CDI_CLASS_MEMBER_OFFSET(m_pNext)
  CDI_CLASS_MEMBER_OFFSET(m_pHeadModule)
END_CLASS_DUMP_INFO(ClassLoader)

BEGIN_CLASS_DUMP_INFO(ComPlusApartmentCleanupGroup)
  CDI_CLASS_MEMBER_OFFSET(m_pSTAThread)
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(m_CtxCookieToContextCleanupGroupMap)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      DWORD_PTR dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_CtxCookieToContextCleanupGroupMap);
      m_CtxCookieToContextCleanupGroupMap.Fill (dwAddr);
      if (!CallStatus)
        return;
      }))
END_CLASS_DUMP_INFO(ComPlusApartmentCleanupGroup)

BEGIN_CLASS_DUMP_INFO(ComPlusContextCleanupGroup)
  CDI_CLASS_MEMBER_OFFSET(m_pNext)
  CDI_CLASS_MEMBER_OFFSET(m_apWrapper)
  CDI_CLASS_MEMBER_OFFSET(m_dwNumWrappers)
END_CLASS_DUMP_INFO(ComPlusContextCleanupGroup)

BEGIN_CLASS_DUMP_INFO(ComPlusWrapperCleanupList)
  CDI_CLASS_MEMBER_OFFSET(m_pMTACleanupGroup)
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(m_STAThreadToApartmentCleanupGroupMap)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      DWORD_PTR dwAddr = dwStartAddr + 
        GetFieldOffset(_member_offsets::m_STAThreadToApartmentCleanupGroupMap);
      m_STAThreadToApartmentCleanupGroupMap.Fill (dwAddr);
      if (!CallStatus)
        return;
      }))
END_CLASS_DUMP_INFO(ComPlusWrapperCleanupList)

BEGIN_CLASS_DUMP_INFO(Context)
  CDI_CLASS_MEMBER_OFFSET(m_pUnsharedStaticData)
  CDI_CLASS_MEMBER_OFFSET(m_pSharedStaticData)
  CDI_CLASS_MEMBER_OFFSET(m_pDomain)
END_CLASS_DUMP_INFO(Context)

BEGIN_CLASS_DUMP_INFO(CORCOMPILE_METHOD_HEADER)
  CDI_CLASS_MEMBER_OFFSET(gcInfo)
  CDI_CLASS_MEMBER_OFFSET(methodDesc)
END_CLASS_DUMP_INFO(CORCOMPILE_METHOD_HEADER)

BEGIN_CLASS_DUMP_INFO(Crst)
  /* m_criticalsection isn't initialized in Crst::Fill */
  CDI_CLASS_MEMBER_OFFSET(m_criticalsection)
END_CLASS_DUMP_INFO(Crst)

BEGIN_CLASS_DUMP_INFO(CRWLock)
  CDI_CLASS_MEMBER_OFFSET(_pMT)
  CDI_CLASS_MEMBER_OFFSET(_hWriterEvent)
  CDI_CLASS_MEMBER_OFFSET(_hReaderEvent)
  CDI_CLASS_MEMBER_OFFSET(_dwState)
  CDI_CLASS_MEMBER_OFFSET(_dwULockID)
  CDI_CLASS_MEMBER_OFFSET(_dwLLockID)
  CDI_CLASS_MEMBER_OFFSET(_dwWriterID)
  CDI_CLASS_MEMBER_OFFSET(_dwWriterSeqNum)
  CDI_CLASS_MEMBER_OFFSET(_wFlags)
  CDI_CLASS_MEMBER_OFFSET(_wWriterLevel)
END_CLASS_DUMP_INFO(CRWLock);

BEGIN_CLASS_DUMP_INFO(DomainLocalBlock)
  CDI_CLASS_MEMBER_OFFSET(m_pSlots)
END_CLASS_DUMP_INFO(DomainLocalBlock)

BEGIN_CLASS_DUMP_INFO(EconoJitManager)
  CDI_CLASS_STATIC_ADDRESS(m_CodeHeap)
  CDI_CLASS_STATIC_ADDRESS(m_CodeHeapCommittedSize)
  CDI_CLASS_STATIC_ADDRESS(m_JittedMethodInfoHdr)
  CDI_CLASS_STATIC_ADDRESS(m_PcToMdMap)
  CDI_CLASS_STATIC_ADDRESS(m_PcToMdMap_len)
END_CLASS_DUMP_INFO(EconoJitManager)

BEGIN_CLASS_DUMP_INFO(EEClass)
  CDI_CLASS_MEMBER_OFFSET(m_cl)
  CDI_CLASS_MEMBER_OFFSET(m_pParentClass)
  CDI_CLASS_MEMBER_OFFSET(m_pLoader)
  CDI_CLASS_MEMBER_OFFSET(m_pMethodTable)
  CDI_CLASS_MEMBER_OFFSET(m_wNumVtableSlots)
  CDI_CLASS_MEMBER_OFFSET(m_wNumMethodSlots)
  CDI_CLASS_MEMBER_OFFSET(m_dwAttrClass)
  CDI_CLASS_MEMBER_OFFSET(m_VMFlags)
  CDI_CLASS_MEMBER_OFFSET(m_wNumInstanceFields)
  CDI_CLASS_MEMBER_OFFSET(m_wNumStaticFields)
  CDI_CLASS_MEMBER_OFFSET(m_wThreadStaticOffset)
  CDI_CLASS_MEMBER_OFFSET(m_wContextStaticOffset)
  CDI_CLASS_MEMBER_OFFSET(m_wThreadStaticsSize)
  CDI_CLASS_MEMBER_OFFSET(m_wContextStaticsSize)
  CDI_CLASS_MEMBER_OFFSET(m_pFieldDescList)
  CDI_CLASS_MEMBER_OFFSET(m_SiblingsChain)
  CDI_CLASS_MEMBER_OFFSET(m_ChildrenChain)
  CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m_szDebugClassName)
END_CLASS_DUMP_INFO(EEClass)

BEGIN_CLASS_DUMP_INFO(EEJitManager)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      IJitManager::Fill (dwAddr);}))
  CDI_CLASS_MEMBER_OFFSET(m_pCodeHeap)
END_CLASS_DUMP_INFO(EEJitManager)

BEGIN_CLASS_DUMP_INFO(MNativeJitManager)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      IJitManager::Fill (dwAddr);}))
END_CLASS_DUMP_INFO(MNativeJitManager)

BEGIN_CLASS_DUMP_INFO(EEHashEntry)
  CDI_CLASS_MEMBER_OFFSET(pNext)
  CDI_CLASS_MEMBER_OFFSET(Data)
  CDI_CLASS_MEMBER_OFFSET(Key)
END_CLASS_DUMP_INFO(EEHashEntry)

BEGIN_CLASS_DUMP_INFO(EEHashTableOfEEClass)
  CDI_CLASS_MEMBER_OFFSET(m_BucketTable)
  CDI_CLASS_MEMBER_OFFSET(m_pVolatileBucketTable)
  CDI_CLASS_INJECT(FOR_STRIKE(m_pFirstBucketTable=dwStartAddr+
    GetFieldOffset(offset_member_EEHashTableOfEEClass::m_BucketTable);))
  CDI_CLASS_MEMBER_OFFSET(m_dwNumEntries)
END_CLASS_DUMP_INFO(EEHashTableOfEEClass)

BEGIN_CLASS_DUMP_INFO(ExecutionManager)
  CDI_CLASS_STATIC_ADDRESS(m_pJitList)
  CDI_CLASS_STATIC_ADDRESS(m_RangeTree)
END_CLASS_DUMP_INFO(ExecutionManager)

BEGIN_CLASS_DUMP_INFO(FieldDesc)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(m_mb, 32)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(m_dwOffset, 32)
  CDI_CLASS_MEMBER_OFFSET(m_pMTOfEnclosingClass)
END_CLASS_DUMP_INFO(FieldDesc)

BEGIN_CLASS_DUMP_INFO(Fjit_hdrInfo)
  CDI_CLASS_MEMBER_OFFSET(prologSize)
  CDI_CLASS_MEMBER_OFFSET(methodSize)
  CDI_CLASS_MEMBER_OFFSET(epilogSize)
  CDI_CLASS_MEMBER_OFFSET(methodArgsSize)
END_CLASS_DUMP_INFO(Fjit_hdrInfo)

BEGIN_CLASS_DUMP_INFO(gc_heap)
  CDI_CLASS_STATIC_ADDRESS(g_max_generation)
  CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(alloc_allocated)
  CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(ephemeral_heap_segment)
  CDI_CLASS_FIELD_SVR_OFFSET_WKS_ADDRESS(finalize_queue)
  CDI_CLASS_FIELD_SVR_OFFSET_WKS_GLOBAL(generation_table)

  /* other static members used in strike/utils.cpp; ignored */
  CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(g_heaps)
  CDI_CLASS_STATIC_ADDRESS_MH_AND_NIH_ONLY(n_heaps)
END_CLASS_DUMP_INFO(gc_heap)

BEGIN_CLASS_DUMP_INFO(GCHeap)
  CDI_CLASS_STATIC_ADDRESS(FinalizerThread)
  CDI_CLASS_STATIC_ADDRESS(GcThread)
END_CLASS_DUMP_INFO(GCHeap)

BEGIN_CLASS_DUMP_INFO(generation)
  CDI_CLASS_MEMBER_OFFSET(allocation_context)
  CDI_CLASS_MEMBER_OFFSET(start_segment)
  CDI_CLASS_MEMBER_OFFSET(allocation_start)
END_CLASS_DUMP_INFO(generation)

BEGIN_CLASS_DUMP_INFO(Global_Variables)
  CDI_GLOBAL_ADDRESS(g_HandleTableMap)
  CDI_GLOBAL_ADDRESS(g_pFreeObjectMethodTable)
  CDI_GLOBAL_ADDRESS(g_pObjectClass)
  CDI_GLOBAL_ADDRESS(g_pRCWCleanupList)
  CDI_GLOBAL_ADDRESS(g_pStringClass)
  CDI_GLOBAL_ADDRESS(g_pSyncTable)
  CDI_GLOBAL_ADDRESS(g_pThreadStore)
  CDI_GLOBAL_ADDRESS(g_SyncBlockCacheInstance)
  CDI_GLOBAL_ADDRESS(g_Version)
  CDI_GLOBAL_ADDRESS(QueueUserWorkItemCallback)
  CDI_GLOBAL_ADDRESS(hlpFuncTable)
  CDI_GLOBAL_ADDRESS_DEBUG_ONLY(g_DbgEnabled)
END_CLASS_DUMP_INFO(Global_Variables)

BEGIN_CLASS_DUMP_INFO(HandleTable)
  CDI_CLASS_MEMBER_OFFSET(pSegmentList)
END_CLASS_DUMP_INFO(HandleTable)

BEGIN_CLASS_DUMP_INFO(HandleTableMap)
  CDI_CLASS_MEMBER_OFFSET(pTable)
  CDI_CLASS_MEMBER_OFFSET(pNext)
  CDI_CLASS_MEMBER_OFFSET(dwMaxIndex)
END_CLASS_DUMP_INFO(HandleTableMap)

BEGIN_CLASS_DUMP_INFO(HashMap)
  CDI_CLASS_MEMBER_OFFSET(m_rgBuckets)
END_CLASS_DUMP_INFO(HashMap)

BEGIN_CLASS_DUMP_INFO(heap_segment)
  CDI_CLASS_MEMBER_OFFSET(allocated)
  CDI_CLASS_MEMBER_OFFSET(next)
  CDI_CLASS_MEMBER_OFFSET(mem)
END_CLASS_DUMP_INFO(heap_segment)

BEGIN_CLASS_DUMP_INFO(HeapList)
  CDI_CLASS_MEMBER_OFFSET(hpNext)
  CDI_CLASS_MEMBER_OFFSET(pHeap)
  CDI_CLASS_MEMBER_OFFSET(startAddress)
  CDI_CLASS_MEMBER_OFFSET(endAddress)
  CDI_CLASS_MEMBER_OFFSET(changeStart)
  CDI_CLASS_MEMBER_OFFSET(changeEnd)
  CDI_CLASS_MEMBER_OFFSET(mapBase)
  CDI_CLASS_MEMBER_OFFSET(pHdrMap)
  CDI_CLASS_MEMBER_OFFSET(cBlocks)
END_CLASS_DUMP_INFO(HeapList)

BEGIN_CLASS_DUMP_INFO(IJitManager)
  CDI_CLASS_MEMBER_OFFSET(m_jit)
  CDI_CLASS_MEMBER_OFFSET(m_next)
END_CLASS_DUMP_INFO(IJitManager)

BEGIN_CLASS_DUMP_INFO(LoaderHeap)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      UnlockedLoaderHeap::Fill(dwAddr);
      if (!CallStatus)
        return;
      CallStatus = FALSE;}))
  CDI_CLASS_MEMBER_OFFSET(m_CriticalSection)
END_CLASS_DUMP_INFO(LoaderHeap)

BEGIN_CLASS_DUMP_INFO(LoaderHeapBlock)
  CDI_CLASS_MEMBER_OFFSET(pNext)
  CDI_CLASS_MEMBER_OFFSET(pVirtualAddress)
  CDI_CLASS_MEMBER_OFFSET(dwVirtualSize)
END_CLASS_DUMP_INFO(LoaderHeapBlock)

BEGIN_CLASS_DUMP_INFO(LockEntry)
  CDI_CLASS_MEMBER_OFFSET(pNext)
  CDI_CLASS_MEMBER_OFFSET(dwULockID)
  CDI_CLASS_MEMBER_OFFSET(dwLLockID)
  CDI_CLASS_MEMBER_OFFSET(wReaderLevel)
END_CLASS_DUMP_INFO(LockEntry)

BEGIN_CLASS_DUMP_INFO(LookupMap)
  CDI_CLASS_MEMBER_OFFSET(dwMaxIndex)
  CDI_CLASS_MEMBER_OFFSET(pTable)
  CDI_CLASS_MEMBER_OFFSET(pNext)
END_CLASS_DUMP_INFO(LookupMap)

BEGIN_CLASS_DUMP_INFO(MethodDesc)
  CDI_CLASS_MEMBER_OFFSET(m_wFlags)
  CDI_CLASS_MEMBER_OFFSET(m_CodeOrIL)
  CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m_pDebugEEClass)
  CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m_pszDebugMethodSignature)
  CDI_CLASS_MEMBER_OFFSET_DEBUG_ONLY(m_pszDebugMethodName)
  CDI_CLASS_INJECT(FOR_STRIKE({FillMdcAndSdi(dwStartAddr);}))
END_CLASS_DUMP_INFO(MethodDesc)

BEGIN_CLASS_DUMP_INFO(MethodDescChunk)
  CDI_CLASS_MEMBER_OFFSET(m_tokrange)
  CDI_CLASS_MEMBER_OFFSET(m_count)
END_CLASS_DUMP_INFO(MethodDescChunk)

BEGIN_CLASS_DUMP_INFO(MethodTable)
  CDI_CLASS_MEMBER_OFFSET(m_pEEClass)
  CDI_CLASS_MEMBER_OFFSET(m_pModule)
  CDI_CLASS_MEMBER_OFFSET(m_wFlags)
  CDI_CLASS_MEMBER_OFFSET(m_BaseSize)
  CDI_CLASS_MEMBER_OFFSET(m_ComponentSize)
  CDI_CLASS_MEMBER_OFFSET(m_wNumInterface)
  CDI_CLASS_MEMBER_OFFSET(m_pIMap)
  CDI_CLASS_MEMBER_OFFSET(m_cbSlots)
  CDI_CLASS_MEMBER_OFFSET(m_Vtable)
  CDI_CLASS_INJECT(FOR_STRIKE({FillVtableInit(dwStartAddr);}))
END_CLASS_DUMP_INFO(MethodTable)

BEGIN_CLASS_DUMP_INFO(Module)
  CDI_CLASS_MEMBER_OFFSET(m_dwFlags)
  CDI_CLASS_MEMBER_OFFSET(m_pAssembly)
  CDI_CLASS_MEMBER_OFFSET(m_file)
  CDI_CLASS_MEMBER_OFFSET(m_zapFile)
  CDI_CLASS_MEMBER_OFFSET(m_pLookupTableHeap)
  CDI_CLASS_MEMBER_OFFSET(m_pNextModule)
  CDI_CLASS_MEMBER_OFFSET(m_dwBaseClassIndex)

  /* we don't want to copy the following members, as we want to Fill them. */
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(m_TypeDefToMethodTableMap)
  CDI_CLASS_MEMBER_OFFSET(m_TypeRefToMethodTableMap)
  CDI_CLASS_MEMBER_OFFSET(m_MethodDefToDescMap)
  CDI_CLASS_MEMBER_OFFSET(m_FieldDefToDescMap)
  CDI_CLASS_MEMBER_OFFSET(m_MemberRefToDescMap)
  CDI_CLASS_MEMBER_OFFSET(m_FileReferencesMap)
  CDI_CLASS_MEMBER_OFFSET(m_AssemblyReferencesMap)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      DWORD_PTR dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_TypeDefToMethodTableMap);
      m_TypeDefToMethodTableMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_TypeRefToMethodTableMap);
      m_TypeRefToMethodTableMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_MethodDefToDescMap);
      m_MethodDefToDescMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_FieldDefToDescMap);
      m_FieldDefToDescMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_MemberRefToDescMap);
      m_MemberRefToDescMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_FileReferencesMap);
      m_FileReferencesMap.Fill (dwAddr);

      dwAddr = dwStartAddr + 
        GetFieldOffset (_member_offsets::m_AssemblyReferencesMap);
      m_AssemblyReferencesMap.Fill (dwAddr);
    }))
END_CLASS_DUMP_INFO(Module)

BEGIN_CLASS_DUMP_INFO(ParamTypeDesc)
  CDI_CLASS_INJECT(FOR_STRIKE(
      DWORD_PTR dwAddr = dwStartAddr;
      TypeDesc::Fill (dwAddr);
      if (!CallStatus)
          return;
      ))
  CDI_CLASS_MEMBER_OFFSET(m_Arg)
END_CLASS_DUMP_INFO(ParamTypeDesc)

BEGIN_CLASS_DUMP_INFO(PEFile)
  CDI_CLASS_MEMBER_OFFSET(m_wszSourceFile)
  CDI_CLASS_MEMBER_OFFSET(m_hModule)
  CDI_CLASS_MEMBER_OFFSET(m_base)
  CDI_CLASS_MEMBER_OFFSET(m_pNT)
END_CLASS_DUMP_INFO(PEFile)

BEGIN_CLASS_DUMP_INFO(PerfAllocHeader)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m_Length)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m_Next)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m_Prev)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(m_AllocEIP)
END_CLASS_DUMP_INFO(PerfAllocHeader)

BEGIN_CLASS_DUMP_INFO(PerfAllocVars)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(g_PerfEnabled)
  CDI_CLASS_MEMBER_OFFSET_PERF_TRACKING_ONLY(g_AllocListFirst)
END_CLASS_DUMP_INFO(PerfAllocVars)

BEGIN_CLASS_DUMP_INFO(PerfUtil)
  CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(g_PerfAllocHeapInitialized)
  CDI_CLASS_STATIC_ADDRESS_PERF_TRACKING_ONLY(g_PerfAllocVariables)
END_CLASS_DUMP_INFO(PerfUtil)

BEGIN_CLASS_DUMP_INFO(PtrHashMap)
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(m_HashMap)
  CDI_CLASS_INJECT(FOR_STRIKE(}else {))
  CDI_CLASS_INJECT(FOR_STRIKE(m_HashMap.Fill(dwStartAddr);
      }))
END_CLASS_DUMP_INFO(PtrHashMap)

BEGIN_CLASS_DUMP_INFO(RangeSection)
  CDI_CLASS_MEMBER_OFFSET(LowAddress)
  CDI_CLASS_MEMBER_OFFSET(HighAddress)
  CDI_CLASS_MEMBER_OFFSET(pjit)
  CDI_CLASS_MEMBER_OFFSET(ptable)
  CDI_CLASS_MEMBER_OFFSET(pright)
  CDI_CLASS_MEMBER_OFFSET(pleft)
END_CLASS_DUMP_INFO(RangeSection)

BEGIN_CLASS_DUMP_INFO(SharedDomain)
  CDI_CLASS_INJECT(FOR_STRIKE(
      DWORD_PTR dwAddr = dwStartAddr;
      BaseDomain::Fill (dwAddr);
      if (!CallStatus)
        return;
      CallStatus = FALSE;
      ULONG v = GetFieldOffset (offset_member_SharedDomain::m_assemblyMap);
      dwAddr = dwStartAddr + v;
      m_assemblyMap.Fill (dwAddr);
      if (!CallStatus)
        return;
      if (false) {
      ))
  CDI_CLASS_MEMBER_OFFSET(m_assemblyMap)
  CDI_CLASS_INJECT(FOR_STRIKE(}))

  CDI_CLASS_MEMBER_OFFSET(m_pDLSRecords)
  CDI_CLASS_MEMBER_OFFSET(m_cDLSRecords)
  CDI_CLASS_STATIC_ADDRESS(m_pSharedDomain)
END_CLASS_DUMP_INFO(SharedDomain)

BEGIN_CLASS_DUMP_INFO(StubCallInstrs)
  CDI_CLASS_MEMBER_OFFSET(m_wTokenRemainder)
  CDI_CLASS_MEMBER_OFFSET(m_chunkIndex)
END_CLASS_DUMP_INFO(StubCallInstrs)

BEGIN_CLASS_DUMP_INFO(SyncBlock)
  CDI_CLASS_MEMBER_OFFSET(m_Monitor)
  CDI_CLASS_MEMBER_OFFSET(m_pComData)
  CDI_CLASS_MEMBER_OFFSET(m_Link)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      m_Monitor.Fill (dwAddr);}))
END_CLASS_DUMP_INFO(SyncBlock)

BEGIN_CLASS_DUMP_INFO(SyncBlockCache)
  CDI_CLASS_MEMBER_OFFSET(m_pCleanupBlockList)
  CDI_CLASS_MEMBER_OFFSET(m_FreeSyncTableIndex)
END_CLASS_DUMP_INFO(SyncBlockCache)

BEGIN_CLASS_DUMP_INFO(SyncTableEntry)
  CDI_CLASS_MEMBER_OFFSET(m_SyncBlock)
  CDI_CLASS_MEMBER_OFFSET(m_Object)
END_CLASS_DUMP_INFO(SyncTableEntry)

BEGIN_CLASS_DUMP_INFO(SystemDomain)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {DWORD_PTR dwAddr = dwStartAddr;
      BaseDomain::Fill (dwAddr);
      if (!CallStatus)
        return;
      /* to get rid of compiler warning */
      moffset = 0;
      }))
  CDI_CLASS_STATIC_ADDRESS(m_appDomainIndexList)
  CDI_CLASS_STATIC_ADDRESS(m_pSystemDomain)
END_CLASS_DUMP_INFO(SystemDomain)

BEGIN_CLASS_DUMP_INFO(SystemNative)
  CDI_CLASS_STATIC_ADDRESS(GetVersionString)
END_CLASS_DUMP_INFO(SystemNative)

BEGIN_CLASS_DUMP_INFO(TableSegment)
  CDI_CLASS_MEMBER_OFFSET(rgBlockType)
  CDI_CLASS_MEMBER_OFFSET(pNextSegment)
  CDI_CLASS_MEMBER_OFFSET(bEmptyLine)
  CDI_CLASS_INJECT(FOR_STRIKE(if (false) {))
  CDI_CLASS_MEMBER_OFFSET(rgValue)
  CDI_CLASS_INJECT(FOR_STRIKE(} else {
      size_t nHandles = bEmptyLine * HANDLE_HANDLES_PER_BLOCK;
      ULONG v = GetFieldOffset (offset_member_TableSegment::rgValue);
      firstHandle = dwStartAddr + v;
      moveBlock (rgValue[0], firstHandle, nHandles*HANDLE_SIZE);
      }))
END_CLASS_DUMP_INFO(TableSegment)

BEGIN_CLASS_DUMP_INFO(Thread)
  CDI_CLASS_INJECT(FOR_STRIKE(
      {_ASSERTE(::GetMemberInformation(offset_class_alloc_context, 
          offset_member_alloc_context::alloc_heap) >= 0);}))
  CDI_CLASS_MEMBER_OFFSET(m_ThreadId)
  CDI_CLASS_MEMBER_OFFSET(m_dwLockCount)
  CDI_CLASS_MEMBER_OFFSET(m_State)
  CDI_CLASS_MEMBER_OFFSET(m_pFrame)
  CDI_CLASS_MEMBER_OFFSET(m_LinkStore)
  CDI_CLASS_MEMBER_OFFSET(m_pDomain)
  CDI_CLASS_MEMBER_OFFSET(m_Context)
  CDI_CLASS_MEMBER_OFFSET(m_fPreemptiveGCDisabled)
  CDI_CLASS_MEMBER_OFFSET(m_LastThrownObjectHandle)
  CDI_CLASS_MEMBER_OFFSET(m_pTEB)
  CDI_CLASS_MEMBER_OFFSET(m_ThreadHandle)
  CDI_CLASS_MEMBER_OFFSET(m_pHead)
  CDI_CLASS_MEMBER_OFFSET(m_pUnsharedStaticData)
  CDI_CLASS_MEMBER_OFFSET(m_pSharedStaticData)
  CDI_CLASS_MEMBER_OFFSET(m_alloc_context)
  CDI_CLASS_MEMBER_OFFSET(m_debuggerWord1)
  CDI_CLASS_MEMBER_OFFSET(m_debuggerWord2)
END_CLASS_DUMP_INFO(Thread);

BEGIN_CLASS_DUMP_INFO(ThreadpoolMgr)
  CDI_CLASS_STATIC_ADDRESS(cpuUtilization)
  CDI_CLASS_STATIC_ADDRESS(NumWorkerThreads)
  CDI_CLASS_STATIC_ADDRESS(NumRunningWorkerThreads)
  CDI_CLASS_STATIC_ADDRESS(NumIdleWorkerThreads)
  CDI_CLASS_STATIC_ADDRESS(MaxLimitTotalWorkerThreads)
  CDI_CLASS_STATIC_ADDRESS(MinLimitTotalWorkerThreads)
  CDI_CLASS_STATIC_ADDRESS(NumQueuedWorkRequests)
  CDI_CLASS_STATIC_ADDRESS(AsyncCallbackCompletion)
  CDI_CLASS_STATIC_ADDRESS(AsyncTimerCallbackCompletion)
  CDI_CLASS_STATIC_ADDRESS(WorkRequestHead)
  CDI_CLASS_STATIC_ADDRESS(WorkRequestTail)
  CDI_CLASS_STATIC_ADDRESS(NumTimers)
  CDI_CLASS_STATIC_ADDRESS(NumCPThreads)
  CDI_CLASS_STATIC_ADDRESS(NumFreeCPThreads)
  CDI_CLASS_STATIC_ADDRESS(MaxFreeCPThreads)
  CDI_CLASS_STATIC_ADDRESS(CurrentLimitTotalCPThreads)
  CDI_CLASS_STATIC_ADDRESS(MaxLimitTotalCPThreads)
  CDI_CLASS_STATIC_ADDRESS(MinLimitTotalCPThreads)
END_CLASS_DUMP_INFO(ThreadpoolMgr)

BEGIN_CLASS_DUMP_INFO(ThreadStore)
  CDI_CLASS_MEMBER_OFFSET(m_ThreadList)
  CDI_CLASS_MEMBER_OFFSET(m_ThreadCount)
  CDI_CLASS_MEMBER_OFFSET(m_UnstartedThreadCount)
  CDI_CLASS_MEMBER_OFFSET(m_BackgroundThreadCount)
  CDI_CLASS_MEMBER_OFFSET(m_PendingThreadCount)
  CDI_CLASS_MEMBER_OFFSET(m_DeadThreadCount)
END_CLASS_DUMP_INFO(ThreadStore)

BEGIN_CLASS_DUMP_INFO(TimerNative)
  CDI_CLASS_MEMBER_OFFSET(timerDeleteWorkItem)
END_CLASS_DUMP_INFO(TimerNative)

BEGIN_CLASS_DUMP_INFO(TypeDesc)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(m_Type, 8)
END_CLASS_DUMP_INFO(TypeDesc)

BEGIN_CLASS_DUMP_INFO(UnlockedLoaderHeap)
  CDI_CLASS_MEMBER_OFFSET(m_pFirstBlock)
  CDI_CLASS_MEMBER_OFFSET(m_pCurBlock)
  CDI_CLASS_MEMBER_OFFSET(m_pPtrToEndOfCommittedRegion)
END_CLASS_DUMP_INFO(UnlockedLoaderHeap)

BEGIN_CLASS_DUMP_INFO(VMHELPDEF)
  CDI_CLASS_MEMBER_OFFSET(pfnHelper)
END_CLASS_DUMP_INFO(VMHELPDEF)

BEGIN_CLASS_DUMP_INFO(WaitEventLink)
  CDI_CLASS_MEMBER_OFFSET(m_Thread)
  CDI_CLASS_MEMBER_OFFSET(m_LinkSB)
END_CLASS_DUMP_INFO(WaitEventLink)

BEGIN_CLASS_DUMP_INFO(WorkRequest)
  CDI_CLASS_MEMBER_OFFSET(next)
  CDI_CLASS_MEMBER_OFFSET(Function)
  CDI_CLASS_MEMBER_OFFSET(Context)
END_CLASS_DUMP_INFO(WorkRequest)

BEGIN_CLASS_DUMP_INFO(CodeHeader)
  CDI_CLASS_MEMBER_OFFSET(hdrMDesc)
  CDI_CLASS_MEMBER_OFFSET(phdrJitGCInfo)
END_CLASS_DUMP_INFO(CodeHeader)

BEGIN_CLASS_DUMP_INFO(EECodeInfo)
  CDI_CLASS_MEMBER_OFFSET(m_methodToken)
  CDI_CLASS_MEMBER_OFFSET(m_pMD)
  CDI_CLASS_MEMBER_OFFSET(m_pJM)
END_CLASS_DUMP_INFO(EECodeInfo)

BEGIN_CLASS_DUMP_INFO(hdrInfo)
  CDI_CLASS_MEMBER_OFFSET(methodSize)
  CDI_CLASS_MEMBER_OFFSET(argSize)
  CDI_CLASS_MEMBER_OFFSET(stackSize)
  CDI_CLASS_MEMBER_OFFSET(rawStkSize)
  CDI_CLASS_MEMBER_OFFSET(prologSize)
  CDI_CLASS_MEMBER_OFFSET(epilogSize)
  CDI_CLASS_MEMBER_OFFSET(epilogCnt)
  CDI_CLASS_MEMBER_OFFSET(epilogEnd)
  CDI_CLASS_MEMBER_OFFSET(ebpFrame)
  CDI_CLASS_MEMBER_OFFSET(interruptible)
  CDI_CLASS_MEMBER_OFFSET(securityCheck)
  CDI_CLASS_MEMBER_OFFSET(handlers)
  CDI_CLASS_MEMBER_OFFSET(localloc)
  CDI_CLASS_MEMBER_OFFSET(editNcontinue)
  CDI_CLASS_MEMBER_OFFSET(varargs)
  CDI_CLASS_MEMBER_OFFSET(doubleAlign)
  CDI_CLASS_MEMBER_OFFSET_BITFIELD(savedRegMask, 8)
  CDI_CLASS_MEMBER_OFFSET(untrackedCnt)
  CDI_CLASS_MEMBER_OFFSET(varPtrTableSize)
  CDI_CLASS_MEMBER_OFFSET(prologOffs)
  CDI_CLASS_MEMBER_OFFSET(epilogOffs)
  CDI_CLASS_MEMBER_OFFSET(thisPtrResult)
  CDI_CLASS_MEMBER_OFFSET(regMaskResult)
  CDI_CLASS_MEMBER_OFFSET(iregMaskResult)
  CDI_CLASS_MEMBER_OFFSET(argMaskResult)
  CDI_CLASS_MEMBER_OFFSET(iargMaskResult)
  CDI_CLASS_MEMBER_OFFSET(argHnumResult)
  CDI_CLASS_MEMBER_OFFSET(argTabResult)
  CDI_CLASS_MEMBER_OFFSET(argTabBytes)
END_CLASS_DUMP_INFO(hdrInfo)

BEGIN_CLASS_DUMP_INFO(CodeManStateBuf)
  CDI_CLASS_MEMBER_OFFSET(hdrInfoSize)
  CDI_CLASS_MEMBER_OFFSET(hdrInfoBody)
END_CLASS_DUMP_INFO(CodeManStateBuf)

/*
BEGIN_CLASS_DUMP_INFO(DebuggerEval)
  CDI_CLASS_MEMBER_OFFSET(m_evalDuringException)
END_CLASS_DUMP_INFO(DebuggerEval)
*/

BEGIN_CLASS_DUMP_INFO(VASigCookie)
  CDI_CLASS_MEMBER_OFFSET(sizeOfArgs)
END_CLASS_DUMP_INFO(VASigCookie)

BEGIN_CLASS_DUMP_INFO(NDirectMethodDesc)
  CDI_CLASS_MEMBER_OFFSET(ndirect)
END_CLASS_DUMP_INFO(NDirectMethodDesc)

#include <frame-types.h>

BEGIN_CLASS_DUMP_TABLE(g_ClassDumpData)
  CDT_CLASS_ENTRY(alloc_context)
  CDT_CLASS_ENTRY(AppDomain)
  CDT_CLASS_ENTRY(ArrayClass)
  CDT_CLASS_ENTRY(ArrayList)
  CDT_CLASS_ENTRY(Assembly)
  CDT_CLASS_ENTRY(AwareLock)
  CDT_CLASS_ENTRY(BaseDomain)
  CDT_CLASS_ENTRY(Bucket)
  CDT_CLASS_ENTRY(CFinalize)
  CDT_CLASS_ENTRY(ClassLoader)
  CDT_CLASS_ENTRY(ComPlusApartmentCleanupGroup)
  CDT_CLASS_ENTRY(ComPlusContextCleanupGroup)
  CDT_CLASS_ENTRY(ComPlusWrapperCleanupList)
  CDT_CLASS_ENTRY(Context)
  CDT_CLASS_ENTRY(CORCOMPILE_METHOD_HEADER)
  CDT_CLASS_ENTRY(Crst)
  CDT_CLASS_ENTRY(CRWLock)
  CDT_CLASS_ENTRY(DomainLocalBlock)
  CDT_CLASS_ENTRY(EconoJitManager)
  CDT_CLASS_ENTRY(EEClass)
  CDT_CLASS_ENTRY(EEJitManager)
  CDT_CLASS_ENTRY(MNativeJitManager)
  CDT_CLASS_ENTRY(EEHashEntry)
  CDT_CLASS_ENTRY(EEHashTableOfEEClass)
  CDT_CLASS_ENTRY(ExecutionManager)
  CDT_CLASS_ENTRY(FieldDesc)
  CDT_CLASS_ENTRY(Fjit_hdrInfo)
  CDT_CLASS_ENTRY(gc_heap)
  CDT_CLASS_ENTRY(GCHeap)
  CDT_CLASS_ENTRY(generation)
  CDT_CLASS_ENTRY(Global_Variables)
  CDT_CLASS_ENTRY(HandleTable)
  CDT_CLASS_ENTRY(HandleTableMap)
  CDT_CLASS_ENTRY(HashMap)
  CDT_CLASS_ENTRY(heap_segment)
  CDT_CLASS_ENTRY(HeapList)
  CDT_CLASS_ENTRY(IJitManager)
  CDT_CLASS_ENTRY(LoaderHeap)
  CDT_CLASS_ENTRY(LoaderHeapBlock)
  CDT_CLASS_ENTRY(LockEntry)
  CDT_CLASS_ENTRY(LookupMap)
  CDT_CLASS_ENTRY(MethodDesc)
  CDT_CLASS_ENTRY(MethodDescChunk)
  CDT_CLASS_ENTRY(MethodTable)
  CDT_CLASS_ENTRY(Module)
  CDT_CLASS_ENTRY(ParamTypeDesc)
  CDT_CLASS_ENTRY(PEFile)
  CDT_CLASS_ENTRY(PerfAllocHeader)
  CDT_CLASS_ENTRY(PerfAllocVars)
  CDT_CLASS_ENTRY(PerfUtil)
  CDT_CLASS_ENTRY(PtrHashMap)
  CDT_CLASS_ENTRY(RangeSection)
  CDT_CLASS_ENTRY(SharedDomain)
  CDT_CLASS_ENTRY(StubCallInstrs)
  CDT_CLASS_ENTRY(SyncBlock)
  CDT_CLASS_ENTRY(SyncBlockCache)
  CDT_CLASS_ENTRY(SyncTableEntry)
  CDT_CLASS_ENTRY(SystemDomain)
  CDT_CLASS_ENTRY(SystemNative)
  CDT_CLASS_ENTRY(TableSegment)
  CDT_CLASS_ENTRY(Thread)
  CDT_CLASS_ENTRY(ThreadpoolMgr)
  CDT_CLASS_ENTRY(ThreadStore)
  CDT_CLASS_ENTRY(TimerNative)
  CDT_CLASS_ENTRY(TypeDesc)
  CDT_CLASS_ENTRY(UnlockedLoaderHeap)
  CDT_CLASS_ENTRY(VMHELPDEF)
  CDT_CLASS_ENTRY(WaitEventLink)
  CDT_CLASS_ENTRY(WorkRequest)
  CDT_CLASS_ENTRY(CodeHeader)
  CDT_CLASS_ENTRY(EECodeInfo)
  CDT_CLASS_ENTRY(hdrInfo)
  CDT_CLASS_ENTRY(CodeManStateBuf)
//  CDT_CLASS_ENTRY(DebuggerEval)
  CDT_CLASS_ENTRY(VASigCookie)
  CDT_CLASS_ENTRY(NDirectMethodDesc)
//
// Frames
//
  CDT_CLASS_ENTRY(Frame)
  CDT_CLASS_ENTRY(ResumableFrame)
  CDT_CLASS_ENTRY(RedirectedThreadFrame)
  CDT_CLASS_ENTRY(TransitionFrame)
  CDT_CLASS_ENTRY(ExceptionFrame)
  CDT_CLASS_ENTRY(FaultingExceptionFrame)
  CDT_CLASS_ENTRY(FuncEvalFrame)
  CDT_CLASS_ENTRY(HelperMethodFrame)
  CDT_CLASS_ENTRY(HelperMethodFrame_1OBJ)
  CDT_CLASS_ENTRY(HelperMethodFrame_2OBJ)
  CDT_CLASS_ENTRY(HelperMethodFrame_4OBJ)
  CDT_CLASS_ENTRY(FramedMethodFrame)
  CDT_CLASS_ENTRY(TPMethodFrame)
  CDT_CLASS_ENTRY(ECallMethodFrame)
  CDT_CLASS_ENTRY(FCallMethodFrame)
  CDT_CLASS_ENTRY(NDirectMethodFrame)
  CDT_CLASS_ENTRY(NDirectMethodFrameEx)
  CDT_CLASS_ENTRY(NDirectMethodFrameGeneric)
  CDT_CLASS_ENTRY(NDirectMethodFrameSlim)
  CDT_CLASS_ENTRY(NDirectMethodFrameStandalone)
  CDT_CLASS_ENTRY(NDirectMethodFrameStandaloneCleanup)
  CDT_CLASS_ENTRY(MulticastFrame)
  CDT_CLASS_ENTRY(UnmanagedToManagedFrame)
  CDT_CLASS_ENTRY(UnmanagedToManagedCallFrame)
  CDT_CLASS_ENTRY(ComMethodFrame)
  CDT_CLASS_ENTRY(ComPlusMethodFrame)
  CDT_CLASS_ENTRY(ComPlusMethodFrameEx)
  CDT_CLASS_ENTRY(ComPlusMethodFrameGeneric)
  CDT_CLASS_ENTRY(ComPlusMethodFrameStandalone)
  CDT_CLASS_ENTRY(ComPlusMethodFrameStandaloneCleanup)
  CDT_CLASS_ENTRY(PInvokeCalliFrame)
  CDT_CLASS_ENTRY(HijackFrame)
  CDT_CLASS_ENTRY(SecurityFrame)
  CDT_CLASS_ENTRY(PrestubMethodFrame)
  CDT_CLASS_ENTRY(InterceptorFrame)
  CDT_CLASS_ENTRY(ComPrestubMethodFrame)
  CDT_CLASS_ENTRY(GCFrame)
  CDT_CLASS_ENTRY(ProtectByRefsFrame)
  CDT_CLASS_ENTRY(ProtectValueClassFrame)
  CDT_CLASS_ENTRY(DebuggerClassInitMarkFrame)
  CDT_CLASS_ENTRY(DebuggerSecurityCodeMarkFrame)
  CDT_CLASS_ENTRY(DebuggerExitFrame)
  CDT_CLASS_ENTRY(UMThkCallFrame)
  CDT_CLASS_ENTRY(InlinedCallFrame)
  CDT_CLASS_ENTRY(ContextTransitionFrame)
END_CLASS_DUMP_TABLE(g_ClassDumpData)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionsetup.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  FusionSetup.h
**
** Purpose: Defines that are used in both managed and unmanged
**          code
**
** Date:  Jan1, 2001
**
===========================================================*/
#ifndef _FUSIONSETUP_H
#define _FUSIONSETUP_H

#define DYNAMIC_DIRECTORY                   L"DYNAMIC_DIRECTORY"
#define LOADER_OPTIMIZATION                 L"LOADER_OPTIMIZATION"
#define LICENSE_FILE                        L"LICENSE_FILE"
#define APPENV_BASE                         L"APPBASE"
#define APPENV_RELATIVEPATH                 L"RELPATH"
#define APPENV_GLOBALPATH                   L"CORPATH"
#define APPENV_DEVPATH                      L"DEVPATH"
#define APPENV_RUNFROMSOURCE                L"__FUSION_RUN_FROM_SOURCE__"
#define CONFIGURATION_EXTENSION             L".config"
#define MACHINE_CONFIGURATION_FILE          L"config\\machine.config"

#ifndef ACTAG_HOST_CONFIG_FILE
#define ACTAG_HOST_CONFIG_FILE              L"HOST_CONFIG"
#endif 

// These are defines instead of enums because they are
// used to change FusionSetup.cs as well as being used in
// unmanaged code
#define  LOADER_APPLICATION_BASE            0
#define  LOADER_CONFIGURATION_BASE          1
#define  LOADER_DYNAMIC_BASE                2
#define  LOADER_DEVPATH                     3
#define  LOADER_APPLICATION_NAME            4
#define  LOADER_PRIVATE_PATH                5 
#define  LOADER_PRIVATE_BIN_PATH_PROBE      6
#define  LOADER_SHADOW_COPY_DIRECTORIES     7
#define  LOADER_SHADOW_COPY_FILES           8
#define  LOADER_CACHE_PATH                  9
#define  LOADER_LICENSE_FILE               10
#define  LOADER_DISALLOW_PUBLISHER_POLICY  11
#define  LOADER_DISALLOW_CODE_DOWNLOAD     12
#define  LOADER_DISALLOW_BINDING_REDIRECTS 13
#define  LOADER_MAXIMUM                    14

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionbind.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  FusionBind.hpp
**
** Purpose: Implements FusionBind (loader domain) architecture
**
** Date:  Oct 26, 1998
**
===========================================================*/
#ifndef _FUSIONBIND_H
#define _FUSIONBIND_H

#include <fusion.h>
#include <fusionpriv.h>
#include "MetaData.h"
#include "FusionSink.h"
#include "UtilCode.h"
#include "FusionSetup.h"

class CodeBaseInfo
{
    IAssembly* m_pParentAssembly; // The assembly that has the reference.
public:
    LPCWSTR m_pszCodeBase;        // URL to the code
    DWORD   m_dwCodeBase;         // length of URL INCLUDING NULL TERMINATOR!
    BOOL m_fLoadFromParent;       // TRUE if m_pParentAssembly is in the LoadFrom context
    
    CodeBaseInfo() :
        m_pszCodeBase(NULL),
        m_dwCodeBase(0),
        m_pParentAssembly(NULL),
        m_fLoadFromParent(FALSE)
    {
    }

    ~CodeBaseInfo()
    {
        ReleaseParent();
    }

    // Note: the hint and parent assembly cannot both be set. The Parent Assembly takes
    // precedence. The parent assembly provides the context in which to bind. Fusion
    // has two context's per ApplicationContext, one for normal binds and one for 
    // where-ref binds. The number-one rule for normal binds is order will not affect
    // which assemblies are loaded. The where-ref binds is completely dependent on 
    // order. Where-ref binds to not influence normal binds but where-refs can bind to
    // assemblies in the normal context.
    
    void SetParentAssembly(IAssembly* pAssembly)
    {
        if(m_pParentAssembly)
            ReleaseParent();
        m_pParentAssembly = pAssembly;
        if(m_pParentAssembly) {
            m_pParentAssembly->AddRef();

            IFusionLoadContext *pLoadContext;
            HRESULT hr = m_pParentAssembly->GetFusionLoadContext(&pLoadContext);
            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) {
                m_fLoadFromParent = (pLoadContext->GetContextType() == LOADCTX_TYPE_LOADFROM);
                pLoadContext->Release();
            }
        }
    }

    IAssembly* GetParentAssembly()
    {
        return m_pParentAssembly;
    }

    void ReleaseParent();
};


class FusionBind
{
private:
    static BOOL m_fBeforeFusionShutdown;

protected:
    BOOL                        m_fParsed;
    AssemblyMetaDataInternal    m_context;
    LPCSTR                      m_pAssemblyName; 
    PBYTE                       m_pbPublicKeyOrToken;
    DWORD                       m_cbPublicKeyOrToken;
    DWORD                       m_dwFlags;
    CodeBaseInfo                m_CodeInfo;
    int                         m_ownedFlags;

public:
    enum 
    {
        NAME_OWNED                  = 0x01,
        PUBLIC_KEY_OR_TOKEN_OWNED   = 0x02,
        CODE_BASE_OWNED             = 0x04,
        CODE_BASE_HINT_OWNED        = 0x08,
        LOCALE_OWNED                = 0x10,
        ALL_OWNED                   = 0xFF,
    };


    FusionBind()
    {
        ZeroMemory(this, sizeof(*this));
    }
    ~FusionBind();

    HRESULT Init(LPCSTR pAssemblyDisplayName);
    HRESULT Init(LPCSTR pAssemblyName,
                 AssemblyMetaDataInternal* pContext, 
                 PBYTE pbPublicKeyOrToken, DWORD cbPublicKeyOrToken,
                 DWORD dwFlags);
    HRESULT Init(IAssemblyName *pName);
    HRESULT Init(FusionBind *pSpec,BOOL bCloneFields=TRUE);

    HRESULT Init(PBYTE pbData, DWORD cbData);
    HRESULT Save(PBYTE pbBuf, DWORD cbBuf, DWORD *pcbReq);
    
    HRESULT CloneFields(int flags);
    HRESULT CloneFieldsToLoaderHeap(int flags, LoaderHeap *pHeap);

    HRESULT ParseName();

    void SetCodeBase(LPCWSTR szCodeBase, DWORD dwCodeBase);
    
    DWORD Hash();

    BOOL Compare(FusionBind *pSpec);

    //****************************************************************************************
    //
    static void DontReleaseFusionInterfaces()
    {
        m_fBeforeFusionShutdown = FALSE;
    }

    static BOOL BeforeFusionShutdown()
    {
        return m_fBeforeFusionShutdown;
    }

    static HRESULT GetVersion(LPWSTR pVersion, DWORD* pdwVersion);

    static HRESULT 
    FindAssemblyByName(LPCWSTR  szAppBase,          // [IN] optional - can be NULL
                       LPCWSTR  szPrivateBin,       // [IN] optional - can be NULL
                       LPCWSTR  szAssemblyName,
                       LPWSTR   szName,             // [OUT] buffer - to hold name 
                       ULONG    cchName,            // [IN] the name buffer's size
                       ULONG    *pcName);           // [OUT] the number of characters returned

    static HRESULT 
    FindModule(LPCWSTR  szAppBase,          // [IN] optional - can be NULL
               LPCWSTR  szPrivateBin,       // [IN] optional - can be NULL
               LPCWSTR  szAssemblyName,     // [IN] The assembly name 
               LPCWSTR  szModuleName,       // [IN] The module in the assembly
               LPWSTR   szName,             // [OUT] buffer - to hold name 
               ULONG    cchName,            // [IN]  the name buffer's size
               ULONG    *pcName);           // [OUT] the number of characters returned
    
    HRESULT EmitToken(IMetaDataAssemblyEmit *pEmitter, mdAssemblyRef *pToken);

    LPCSTR GetName() { return m_pAssemblyName; }
    AssemblyMetaDataInternal *GetContext() { &m_context; }
    CodeBaseInfo* GetCodeBase() { return &m_CodeInfo; }
    BOOL IsStronglyNamed() { return m_cbPublicKeyOrToken; }

    //****************************************************************************************
    //
    HRESULT LoadAssembly(IApplicationContext *pFusionContext, 
                         IAssembly** ppFusionAssembly);

    //****************************************************************************************
    //
    HRESULT GetAssemblyFromFusion(IApplicationContext* pFusionContext,
                                  FusionSink* pSink,
                                  IAssemblyName* pFusionAssemblyName,
                                  CodeBaseInfo* pCodeBase,
                                  IAssembly** ppFusionAssembly);

    
        
    //****************************************************************************************
    //
    // Creates a fusion context for the application domain. All ApplicationContext properties
    // must be set in the AppDomain store prior to this call. Any changes or additions to the
    // AppDomain store are ignored.
    static HRESULT CreateFusionContext(LPCWSTR szName, IApplicationContext** ppFusionContext);


    //****************************************************************************************
    //
    // Loads an environmental value into the fusion context
    static HRESULT AddEnvironmentProperty(LPWSTR variable, 
                                          LPWSTR pProperty, 
                                          IApplicationContext* pFusionContext);
    

    // Helper routines to retrieve Assemblies and modules that are part of the assembly
    static HRESULT
    FindAssemblyByName(LPCWSTR  szAppBase,          // [IN] optional - can be NULL
                       LPCWSTR  szPrivateBin,       // [IN] optional - can be NULL
                       LPCWSTR  szAssemblyName,     // [IN] Name of the assembly (must not be null)
                       IAssembly** pAssembly,                 // [OUT] Fusion assembly
                       IApplicationContext** pFusionContext); // [OUT] optional - context built from appbase, etc.


    static HRESULT 
    FindModule(IAssembly* pFusionAssembly,           // [IN] Fusion assembly
               IApplicationContext* pFusionContext,  // [IN] Fusion context for the assembly
               LPCWSTR  szModuleName,           // [IN] The module in the assembly
               LPWSTR   szName,                 // [OUT] buffer - to hold name 
               ULONG    cchName,                // [IN]  the name buffer's size
               ULONG    *pcName);               // [OUT] the number of characters returned
    
    //****************************************************************************************
    //
    // Creates and loads an assembly based on the name and context.
    HRESULT CreateFusionName(IAssemblyName **ppName, BOOL fIncludeHash = FALSE);

    //****************************************************************************************
    //
    static HRESULT SetupFusionContext(LPCWSTR szAppBase,
                                      LPCWSTR szPrivateBin,
                                      IApplicationContext** ppFusionContext);

    // Starts remote load of an assembly. The thread is parked on 
    // an event waiting for fusion to report success or failure.
    HRESULT RemoteLoad(CodeBaseInfo* pCodeBase,                   
                       IApplicationContext * pFusionContext, 
                       LPASSEMBLYNAME pName, 
                       FusionSink* pSink, 
                       IAssembly** ppFusionAssembly);

    static HRESULT RemoteLoadModule(IApplicationContext * pFusionContext, 
                                    IAssemblyModuleImport* pModule, 
                                    FusionSink *pSink,
                                    IAssemblyModuleImport** pResult);

    static BOOL VerifyBindingStringW(LPWSTR pwStr) {
        if (wcschr(pwStr, '\\') ||
            wcschr(pwStr, '/') ||
            wcschr(pwStr, ':') ||
            (RunningOnWin95() && ContainsUnmappableANSIChars(pwStr)))
            return FALSE;

        return TRUE;
    }

    static HRESULT VerifyBindingString(LPCSTR pName) {
        DWORD dwStrLen = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, pName, -1, NULL, NULL);
        CQuickString qb;
        LPWSTR pwStr = (LPWSTR) qb.Alloc(dwStrLen);
        
        if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, pName, -1, pwStr, dwStrLen))
            return HRESULT_FROM_WIN32(GetLastError());

        if (VerifyBindingStringW(pwStr))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionpriv_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusionpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "fusionpriv.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_fusionpriv_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IHistoryAssembly, ver. 0.0,
   GUID={0xe6096a07,0xe188,0x4a49,{0x8d,0x50,0x2a,0x01,0x72,0xa0,0xd2,0x05}} */


/* Object interface: IHistoryReader, ver. 0.0,
   GUID={0x1d23df4d,0xa1e2,0x4b8b,{0x93,0xd6,0x6e,0xa3,0xdc,0x28,0x5a,0x54}} */


/* Object interface: IMetaDataAssemblyImportControl, ver. 0.0,
   GUID={0xcc8529d9,0xf336,0x471b,{0xb6,0x0a,0xc7,0xc8,0xee,0x9b,0x84,0x92}} */


/* Standard interface: __MIDL_itf_fusionpriv_0124, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IFusionLoadContext, ver. 0.0,
   GUID={0x022AB2BA,0x7367,0x49fc,{0xA1,0xC5,0x0E,0x7C,0xC0,0x37,0xCA,0xAB}} */


/* Object interface: IFusionBindLog, ver. 0.0,
   GUID={0x67E9F87D,0x8B8A,0x4a90,{0x9D,0x3E,0x85,0xED,0x5B,0x2D,0xCC,0x83}} */


/* Object interface: IAssemblyManifestImport, ver. 0.0,
   GUID={0xde9a68ba,0x0fa2,0x11d3,{0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff}} */


/* Object interface: IApplicationContext, ver. 0.0,
   GUID={0x7c23ff90,0x33af,0x11d3,{0x95,0xda,0x00,0xa0,0x24,0xa8,0x5b,0x51}} */


/* Object interface: IAssembly, ver. 0.0,
   GUID={0xff08d7d4,0x04c2,0x11d3,{0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff}} */


/* Object interface: IAssemblyBindSink, ver. 0.0,
   GUID={0xaf0bc960,0x0b9a,0x11d3,{0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51}} */


/* Object interface: IAssemblyBinding, ver. 0.0,
   GUID={0xcfe52a80,0x12bd,0x11d3,{0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51}} */


/* Object interface: ISequentialStream, ver. 0.0,
   GUID={0x0c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IStream, ver. 0.0,
   GUID={0x0000000c,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAssemblyModuleImport, ver. 0.0,
   GUID={0xda0cd4b0,0x1117,0x11d3,{0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51}} */


/* Object interface: IAssemblyScavenger, ver. 0.0,
   GUID={0x21b8916c,0xf28e,0x11d2,{0xa4,0x73,0x00,0xcc,0xff,0x8e,0xf4,0x48}} */


/* Object interface: IAssemblySignature, ver. 0.0,
   GUID={0xC7A63E29,0xEE15,0x437a,{0x90,0xB2,0x1C,0xF3,0xDF,0x98,0x63,0xFF}} */


/* Standard interface: __MIDL_itf_fusionpriv_0134, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _fusionpriv_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _fusionpriv_StubVtblList[] = 
{
    0
};

PCInterfaceName const _fusionpriv_InterfaceNamesList[] = 
{
    0
};


#define _fusionpriv_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _fusionpriv, pIID, n)

int __stdcall _fusionpriv_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo fusionpriv_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _fusionpriv_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _fusionpriv_StubVtblList,
    (const PCInterfaceName * ) & _fusionpriv_InterfaceNamesList,
    0, // no delegation
    & _fusionpriv_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionpriv.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusionpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusionpriv_h__
#define __fusionpriv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IHistoryAssembly_FWD_DEFINED__
#define __IHistoryAssembly_FWD_DEFINED__
typedef interface IHistoryAssembly IHistoryAssembly;
#endif 	/* __IHistoryAssembly_FWD_DEFINED__ */


#ifndef __IHistoryReader_FWD_DEFINED__
#define __IHistoryReader_FWD_DEFINED__
typedef interface IHistoryReader IHistoryReader;
#endif 	/* __IHistoryReader_FWD_DEFINED__ */


#ifndef __IMetaDataAssemblyImportControl_FWD_DEFINED__
#define __IMetaDataAssemblyImportControl_FWD_DEFINED__
typedef interface IMetaDataAssemblyImportControl IMetaDataAssemblyImportControl;
#endif 	/* __IMetaDataAssemblyImportControl_FWD_DEFINED__ */


#ifndef __IFusionLoadContext_FWD_DEFINED__
#define __IFusionLoadContext_FWD_DEFINED__
typedef interface IFusionLoadContext IFusionLoadContext;
#endif 	/* __IFusionLoadContext_FWD_DEFINED__ */


#ifndef __IFusionBindLog_FWD_DEFINED__
#define __IFusionBindLog_FWD_DEFINED__
typedef interface IFusionBindLog IFusionBindLog;
#endif 	/* __IFusionBindLog_FWD_DEFINED__ */


#ifndef __IAssemblyManifestImport_FWD_DEFINED__
#define __IAssemblyManifestImport_FWD_DEFINED__
typedef interface IAssemblyManifestImport IAssemblyManifestImport;
#endif 	/* __IAssemblyManifestImport_FWD_DEFINED__ */


#ifndef __IApplicationContext_FWD_DEFINED__
#define __IApplicationContext_FWD_DEFINED__
typedef interface IApplicationContext IApplicationContext;
#endif 	/* __IApplicationContext_FWD_DEFINED__ */


#ifndef __IAssembly_FWD_DEFINED__
#define __IAssembly_FWD_DEFINED__
typedef interface IAssembly IAssembly;
#endif 	/* __IAssembly_FWD_DEFINED__ */


#ifndef __IAssemblyBindSink_FWD_DEFINED__
#define __IAssemblyBindSink_FWD_DEFINED__
typedef interface IAssemblyBindSink IAssemblyBindSink;
#endif 	/* __IAssemblyBindSink_FWD_DEFINED__ */


#ifndef __IAssemblyBinding_FWD_DEFINED__
#define __IAssemblyBinding_FWD_DEFINED__
typedef interface IAssemblyBinding IAssemblyBinding;
#endif 	/* __IAssemblyBinding_FWD_DEFINED__ */


#ifndef __IAssemblyModuleImport_FWD_DEFINED__
#define __IAssemblyModuleImport_FWD_DEFINED__
typedef interface IAssemblyModuleImport IAssemblyModuleImport;
#endif 	/* __IAssemblyModuleImport_FWD_DEFINED__ */


#ifndef __IAssemblyScavenger_FWD_DEFINED__
#define __IAssemblyScavenger_FWD_DEFINED__
typedef interface IAssemblyScavenger IAssemblyScavenger;
#endif 	/* __IAssemblyScavenger_FWD_DEFINED__ */


#ifndef __IAssemblySignature_FWD_DEFINED__
#define __IAssemblySignature_FWD_DEFINED__
typedef interface IAssemblySignature IAssemblySignature;
#endif 	/* __IAssemblySignature_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "fusion.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusionpriv_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#pragma once











EXTERN_C const IID IID_IApplicationContext;       
EXTERN_C const IID IID_IAssembly;           
EXTERN_C const IID IID_IAssemblyBindSink;   
EXTERN_C const IID IID_IAssemblyBinding;   
EXTERN_C const IID IID_IAssemblyManifestImport;
EXTERN_C const IID IID_IAssemblyModuleImport;  
EXTERN_C const IID IID_IHistoryAssembly;      
EXTERN_C const IID IID_IHistoryReader;      
EXTERN_C const IID IID_IMetaDataAssemblyImportControl;      
EXTERN_C const IID IID_IFusionLoadContext;      
EXTERN_C const IID IID_IAssemblyScavenger;  
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusionpriv_0000_0001
    {	ASM_BINDF_FORCE_CACHE_INSTALL	= 0x1,
	ASM_BINDF_RFS_INTEGRITY_CHECK	= 0x2,
	ASM_BINDF_RFS_MODULE_CHECK	= 0x4,
	ASM_BINDF_BINPATH_PROBE_ONLY	= 0x8,
	ASM_BINDF_SHARED_BINPATH_HINT	= 0x10,
	ASM_BINDF_PARENT_ASM_HINT	= 0x20,
	ASM_BINDF_DISALLOW_APPLYPUBLISHERPOLICY	= 0x40,
	ASM_BINDF_DISALLOW_APPBINDINGREDIRECTS	= 0x80
    } 	ASM_BIND_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0000_v0_0_s_ifspec;

#ifndef __IHistoryAssembly_INTERFACE_DEFINED__
#define __IHistoryAssembly_INTERFACE_DEFINED__

/* interface IHistoryAssembly */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6096a07-e188-4a49-8d50-2a0172a0d205")
    IHistoryAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyName( 
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublicKeyToken( 
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCulture( 
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceVersion( 
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCfgVersion( 
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublisherCfgVersion( 
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdminCfgVersion( 
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyName )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublicKeyToken )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCulture )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublisherCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdminCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        END_INTERFACE
    } IHistoryAssemblyVtbl;

    interface IHistoryAssembly
    {
        CONST_VTBL struct IHistoryAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryAssembly_GetAssemblyName(This,wzAsmName,pdwSize)	\
    (This)->lpVtbl -> GetAssemblyName(This,wzAsmName,pdwSize)

#define IHistoryAssembly_GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)	\
    (This)->lpVtbl -> GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)

#define IHistoryAssembly_GetCulture(This,wzCulture,pdwSize)	\
    (This)->lpVtbl -> GetCulture(This,wzCulture,pdwSize)

#define IHistoryAssembly_GetReferenceVersion(This,wzVerRef,pdwSize)	\
    (This)->lpVtbl -> GetReferenceVersion(This,wzVerRef,pdwSize)

#define IHistoryAssembly_GetActivationDate(This,wzActivationDate,pdwSize)	\
    (This)->lpVtbl -> GetActivationDate(This,wzActivationDate,pdwSize)

#define IHistoryAssembly_GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)	\
    (This)->lpVtbl -> GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)

#define IHistoryAssembly_GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)	\
    (This)->lpVtbl -> GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)

#define IHistoryAssembly_GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)	\
    (This)->lpVtbl -> GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAssemblyName_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzAsmName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAssemblyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublicKeyToken_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzPublicKeyToken,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublicKeyToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetCulture_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzCulture,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetCulture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetReferenceVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzVerRef,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetReferenceVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetActivationDate_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzActivationDate,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAppCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerAppCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAppCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublisherCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerPublisherCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublisherCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAdminCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzAdminCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAdminCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryAssembly_INTERFACE_DEFINED__ */


#ifndef __IHistoryReader_INTERFACE_DEFINED__
#define __IHistoryReader_INTERFACE_DEFINED__

/* interface IHistoryReader */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1d23df4d-a1e2-4b8b-93d6-6ea3dc285a54")
    IHistoryReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationName( 
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEXEModulePath( 
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumActivations( 
            /* [out] */ DWORD *pdwNumActivations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunTimeVersion( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumAssemblies( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHistoryAssembly( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationName )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEXEModulePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumActivations )( 
            IHistoryReader * This,
            /* [out] */ DWORD *pdwNumActivations);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryReader * This,
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunTimeVersion )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumAssemblies )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms);
        
        HRESULT ( STDMETHODCALLTYPE *GetHistoryAssembly )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm);
        
        END_INTERFACE
    } IHistoryReaderVtbl;

    interface IHistoryReader
    {
        CONST_VTBL struct IHistoryReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryReader_GetFilePath(This,wzFilePath,pdwSize)	\
    (This)->lpVtbl -> GetFilePath(This,wzFilePath,pdwSize)

#define IHistoryReader_GetApplicationName(This,wzAppName,pdwSize)	\
    (This)->lpVtbl -> GetApplicationName(This,wzAppName,pdwSize)

#define IHistoryReader_GetEXEModulePath(This,wzExePath,pdwSize)	\
    (This)->lpVtbl -> GetEXEModulePath(This,wzExePath,pdwSize)

#define IHistoryReader_GetNumActivations(This,pdwNumActivations)	\
    (This)->lpVtbl -> GetNumActivations(This,pdwNumActivations)

#define IHistoryReader_GetActivationDate(This,dwIdx,pftDate)	\
    (This)->lpVtbl -> GetActivationDate(This,dwIdx,pftDate)

#define IHistoryReader_GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)	\
    (This)->lpVtbl -> GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)

#define IHistoryReader_GetNumAssemblies(This,pftActivationDate,pdwNumAsms)	\
    (This)->lpVtbl -> GetNumAssemblies(This,pftActivationDate,pdwNumAsms)

#define IHistoryReader_GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)	\
    (This)->lpVtbl -> GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryReader_GetFilePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzFilePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetApplicationName_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzAppName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetEXEModulePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzExePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetEXEModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumActivations_Proxy( 
    IHistoryReader * This,
    /* [out] */ DWORD *pdwNumActivations);


void __RPC_STUB IHistoryReader_GetNumActivations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetActivationDate_Proxy( 
    IHistoryReader * This,
    /* [in] */ DWORD dwIdx,
    /* [out] */ FILETIME *pftDate);


void __RPC_STUB IHistoryReader_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetRunTimeVersion_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ LPWSTR wzRunTimeVersion,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetRunTimeVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumAssemblies_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ DWORD *pdwNumAsms);


void __RPC_STUB IHistoryReader_GetNumAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetHistoryAssembly_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [in] */ DWORD dwIdx,
    /* [out] */ IHistoryAssembly **ppHistAsm);


void __RPC_STUB IHistoryReader_GetHistoryAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryReader_INTERFACE_DEFINED__ */


#ifndef __IMetaDataAssemblyImportControl_INTERFACE_DEFINED__
#define __IMetaDataAssemblyImportControl_INTERFACE_DEFINED__

/* interface IMetaDataAssemblyImportControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMetaDataAssemblyImportControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cc8529d9-f336-471b-b60a-c7c8ee9b8492")
    IMetaDataAssemblyImportControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReleaseMetaDataAssemblyImport( 
            /* [out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaDataAssemblyImportControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetaDataAssemblyImportControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetaDataAssemblyImportControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetaDataAssemblyImportControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseMetaDataAssemblyImport )( 
            IMetaDataAssemblyImportControl * This,
            /* [out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IMetaDataAssemblyImportControlVtbl;

    interface IMetaDataAssemblyImportControl
    {
        CONST_VTBL struct IMetaDataAssemblyImportControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaDataAssemblyImportControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMetaDataAssemblyImportControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMetaDataAssemblyImportControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMetaDataAssemblyImportControl_ReleaseMetaDataAssemblyImport(This,ppUnk)	\
    (This)->lpVtbl -> ReleaseMetaDataAssemblyImport(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMetaDataAssemblyImportControl_ReleaseMetaDataAssemblyImport_Proxy( 
    IMetaDataAssemblyImportControl * This,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IMetaDataAssemblyImportControl_ReleaseMetaDataAssemblyImport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMetaDataAssemblyImportControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusionpriv_0124 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_fusionpriv_0124_0001
    {	LOADCTX_TYPE_DEFAULT	= 0,
	LOADCTX_TYPE_LOADFROM	= LOADCTX_TYPE_DEFAULT + 1
    } 	LOADCTX_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0124_v0_0_s_ifspec;

#ifndef __IFusionLoadContext_INTERFACE_DEFINED__
#define __IFusionLoadContext_INTERFACE_DEFINED__

/* interface IFusionLoadContext */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFusionLoadContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("022AB2BA-7367-49fc-A1C5-0E7CC037CAAB")
    IFusionLoadContext : public IUnknown
    {
    public:
        virtual LOADCTX_TYPE STDMETHODCALLTYPE GetContextType( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFusionLoadContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFusionLoadContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFusionLoadContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFusionLoadContext * This);
        
        LOADCTX_TYPE ( STDMETHODCALLTYPE *GetContextType )( 
            IFusionLoadContext * This);
        
        END_INTERFACE
    } IFusionLoadContextVtbl;

    interface IFusionLoadContext
    {
        CONST_VTBL struct IFusionLoadContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFusionLoadContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFusionLoadContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFusionLoadContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFusionLoadContext_GetContextType(This)	\
    (This)->lpVtbl -> GetContextType(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



LOADCTX_TYPE STDMETHODCALLTYPE IFusionLoadContext_GetContextType_Proxy( 
    IFusionLoadContext * This);


void __RPC_STUB IFusionLoadContext_GetContextType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFusionLoadContext_INTERFACE_DEFINED__ */


#ifndef __IFusionBindLog_INTERFACE_DEFINED__
#define __IFusionBindLog_INTERFACE_DEFINED__

/* interface IFusionBindLog */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFusionBindLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67E9F87D-8B8A-4a90-9D3E-85ED5B2DCC83")
    IFusionBindLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultCode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindLog( 
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPWSTR pwzDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFusionBindLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFusionBindLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFusionBindLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultCode )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindLog )( 
            IFusionBindLog * This,
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPWSTR pwzDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog);
        
        END_INTERFACE
    } IFusionBindLogVtbl;

    interface IFusionBindLog
    {
        CONST_VTBL struct IFusionBindLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFusionBindLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFusionBindLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFusionBindLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFusionBindLog_GetResultCode(This)	\
    (This)->lpVtbl -> GetResultCode(This)

#define IFusionBindLog_GetBindLog(This,dwDetailLevel,pwzDebugLog,pcbDebugLog)	\
    (This)->lpVtbl -> GetBindLog(This,dwDetailLevel,pwzDebugLog,pcbDebugLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFusionBindLog_GetResultCode_Proxy( 
    IFusionBindLog * This);


void __RPC_STUB IFusionBindLog_GetResultCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFusionBindLog_GetBindLog_Proxy( 
    IFusionBindLog * This,
    /* [in] */ DWORD dwDetailLevel,
    /* [out] */ LPWSTR pwzDebugLog,
    /* [out][in] */ DWORD *pcbDebugLog);


void __RPC_STUB IFusionBindLog_GetBindLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFusionBindLog_INTERFACE_DEFINED__ */


#ifndef __IAssemblyManifestImport_INTERFACE_DEFINED__
#define __IAssemblyManifestImport_INTERFACE_DEFINED__

/* interface IAssemblyManifestImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyManifestImport *LPASSEMBLY_MANIFEST_IMPORT;


EXTERN_C const IID IID_IAssemblyManifestImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("de9a68ba-0fa2-11d3-94aa-00c04fc308ff")
    IAssemblyManifestImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyManifestImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyManifestImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyManifestImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyManifestImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssemblyManifestImport * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssemblyManifestImport * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssemblyManifestImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        END_INTERFACE
    } IAssemblyManifestImportVtbl;

    interface IAssemblyManifestImport
    {
        CONST_VTBL struct IAssemblyManifestImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyManifestImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyManifestImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyManifestImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyManifestImport_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyModule(This,nIndex,ppImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppImport)

#define IAssemblyManifestImport_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssemblyManifestImport_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetAssemblyNameDef_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyNameRef_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyModule_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppImport);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetModuleByName_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssemblyManifestImport_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetManifestModulePath_Proxy( 
    IAssemblyManifestImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyManifestImport_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyManifestImport_INTERFACE_DEFINED__ */


#ifndef __IApplicationContext_INTERFACE_DEFINED__
#define __IApplicationContext_INTERFACE_DEFINED__

/* interface IApplicationContext */
/* [unique][uuid][object][local] */ 

// App context configuration variables
#define ACTAG_APP_BASE_URL            L"APPBASE"
#define ACTAG_MACHINE_CONFIG          L"MACHINE_CONFIG"
#define ACTAG_APP_PRIVATE_BINPATH     L"PRIVATE_BINPATH"
#define ACTAG_APP_SHARED_BINPATH      L"SHARED_BINPATH"
#define ACTAG_APP_SNAPSHOT_ID         L"SNAPSHOT_ID"
#define ACTAG_APP_CONFIG_FILE         L"APP_CONFIG_FILE"
#define ACTAG_APP_ID                  L"APPLICATION_ID"
#define ACTAG_APP_SHADOW_COPY_DIRS    L"SHADOW_COPY_DIRS"
#define ACTAG_APP_DYNAMIC_BASE        L"DYNAMIC_BASE"
#define ACTAG_APP_CACHE_BASE          L"CACHE_BASE"
#define ACTAG_APP_NAME                L"APP_NAME"
#define ACTAG_DEV_PATH                L"DEV_PATH"
#define ACTAG_HOST_CONFIG_FILE        L"HOST_CONFIG"
#define ACTAG_SXS_ACTIVATION_CONTEXT  L"SXS_ACTIVATION_CONTEXT"
#define ACTAG_APP_CFG_LOCAL_FILEPATH  L"APP_CFG_LOCAL_FILEPATH"
// App context flag overrides
#define ACTAG_FORCE_CACHE_INSTALL     L"FORCE_CACHE_INSTALL"
#define ACTAG_RFS_INTEGRITY_CHECK     L"RFS_INTEGRITY_CHECK"
#define ACTAG_RFS_MODULE_CHECK        L"RFS_MODULE_CHECK"
#define ACTAG_BINPATH_PROBE_ONLY      L"BINPATH_PROBE_ONLY"
#define ACTAG_DISALLOW_APPLYPUBLISHERPOLICY  L"DISALLOW_APP"
#define ACTAG_DISALLOW_APP_BINDING_REDIRECTS  L"DISALLOW_APP_REDIRECTS"
#define ACTAG_CODE_DOWNLOAD_DISABLED  L"CODE_DOWNLOAD_DISABLED"
#define ACTAG_DISABLE_FX_ASM_UNIFICATION  L"DISABLE_FX_ASM_UNIFICATION"
typedef /* [unique] */ IApplicationContext *LPAPPLICATIONCONTEXT;

typedef /* [public] */ 
enum __MIDL_IApplicationContext_0001
    {	APP_CTX_FLAGS_INTERFACE	= 0x1
    } 	APP_FLAGS;


EXTERN_C const IID IID_IApplicationContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c23ff90-33af-11d3-95da-00a024a85b51")
    IApplicationContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContextNameObject( 
            /* [in] */ LPASSEMBLYNAME pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextNameObject( 
            /* [out] */ LPASSEMBLYNAME *ppName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDynamicDirectory( 
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCacheDirectory( 
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterKnownAssembly( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ LPCWSTR pwzAsmURL,
            /* [out] */ IAssembly **ppAsmOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrefetchAppConfigFile( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SxsActivateContext( 
            ULONG_PTR *lpCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SxsDeactivateContext( 
            ULONG_PTR ulCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextNameObject )( 
            IApplicationContext * This,
            /* [in] */ LPASSEMBLYNAME pName);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextNameObject )( 
            IApplicationContext * This,
            /* [out] */ LPASSEMBLYNAME *ppName);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCacheDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterKnownAssembly )( 
            IApplicationContext * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ LPCWSTR pwzAsmURL,
            /* [out] */ IAssembly **ppAsmOut);
        
        HRESULT ( STDMETHODCALLTYPE *PrefetchAppConfigFile )( 
            IApplicationContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SxsActivateContext )( 
            IApplicationContext * This,
            ULONG_PTR *lpCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SxsDeactivateContext )( 
            IApplicationContext * This,
            ULONG_PTR ulCookie);
        
        END_INTERFACE
    } IApplicationContextVtbl;

    interface IApplicationContext
    {
        CONST_VTBL struct IApplicationContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationContext_SetContextNameObject(This,pName)	\
    (This)->lpVtbl -> SetContextNameObject(This,pName)

#define IApplicationContext_GetContextNameObject(This,ppName)	\
    (This)->lpVtbl -> GetContextNameObject(This,ppName)

#define IApplicationContext_Set(This,szName,pvValue,cbValue,dwFlags)	\
    (This)->lpVtbl -> Set(This,szName,pvValue,cbValue,dwFlags)

#define IApplicationContext_Get(This,szName,pvValue,pcbValue,dwFlags)	\
    (This)->lpVtbl -> Get(This,szName,pvValue,pcbValue,dwFlags)

#define IApplicationContext_GetDynamicDirectory(This,wzDynamicDir,pdwSize)	\
    (This)->lpVtbl -> GetDynamicDirectory(This,wzDynamicDir,pdwSize)

#define IApplicationContext_GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)	\
    (This)->lpVtbl -> GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)

#define IApplicationContext_RegisterKnownAssembly(This,pName,pwzAsmURL,ppAsmOut)	\
    (This)->lpVtbl -> RegisterKnownAssembly(This,pName,pwzAsmURL,ppAsmOut)

#define IApplicationContext_PrefetchAppConfigFile(This)	\
    (This)->lpVtbl -> PrefetchAppConfigFile(This)

#define IApplicationContext_SxsActivateContext(This,lpCookie)	\
    (This)->lpVtbl -> SxsActivateContext(This,lpCookie)

#define IApplicationContext_SxsDeactivateContext(This,ulCookie)	\
    (This)->lpVtbl -> SxsDeactivateContext(This,ulCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IApplicationContext_SetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPASSEMBLYNAME pName);


void __RPC_STUB IApplicationContext_SetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPASSEMBLYNAME *ppName);


void __RPC_STUB IApplicationContext_GetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Set_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [in] */ LPVOID pvValue,
    /* [in] */ DWORD cbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Get_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [out] */ LPVOID pvValue,
    /* [out][in] */ LPDWORD pcbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetDynamicDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzDynamicDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetDynamicDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetAppCacheDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzAppCacheDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetAppCacheDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_RegisterKnownAssembly_Proxy( 
    IApplicationContext * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ LPCWSTR pwzAsmURL,
    /* [out] */ IAssembly **ppAsmOut);


void __RPC_STUB IApplicationContext_RegisterKnownAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_PrefetchAppConfigFile_Proxy( 
    IApplicationContext * This);


void __RPC_STUB IApplicationContext_PrefetchAppConfigFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_SxsActivateContext_Proxy( 
    IApplicationContext * This,
    ULONG_PTR *lpCookie);


void __RPC_STUB IApplicationContext_SxsActivateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_SxsDeactivateContext_Proxy( 
    IApplicationContext * This,
    ULONG_PTR ulCookie);


void __RPC_STUB IApplicationContext_SxsDeactivateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationContext_INTERFACE_DEFINED__ */


#ifndef __IAssembly_INTERFACE_DEFINED__
#define __IAssembly_INTERFACE_DEFINED__

/* interface IAssembly */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssembly *LPASSEMBLY;

#define ASMLOC_LOCATION_MASK          0x00000003
#define ASMLOC_UNKNOWN                0x00000000
#define ASMLOC_GAC                    0x00000001
#define ASMLOC_DOWNLOAD_CACHE         0x00000002
#define ASMLOC_RUN_FROM_SOURCE        0x00000003
#define ASMLOC_CODEBASE_HINT          0x00000004

EXTERN_C const IID IID_IAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff08d7d4-04c2-11d3-94aa-00c04fc308ff")
    IAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyPath( 
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyLocation( 
            /* [out] */ DWORD *pdwAsmLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFusionLoadContext( 
            /* [out] */ IFusionLoadContext **ppLoadContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssembly * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssembly * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyPath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyLocation )( 
            IAssembly * This,
            /* [out] */ DWORD *pdwAsmLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetFusionLoadContext )( 
            IAssembly * This,
            /* [out] */ IFusionLoadContext **ppLoadContext);
        
        END_INTERFACE
    } IAssemblyVtbl;

    interface IAssembly
    {
        CONST_VTBL struct IAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssembly_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssembly_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssembly_GetNextAssemblyModule(This,nIndex,ppModImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppModImport)

#define IAssembly_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssembly_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#define IAssembly_GetAssemblyPath(This,pStr,lpcwBuffer)	\
    (This)->lpVtbl -> GetAssemblyPath(This,pStr,lpcwBuffer)

#define IAssembly_GetAssemblyLocation(This,pdwAsmLocation)	\
    (This)->lpVtbl -> GetAssemblyLocation(This,pdwAsmLocation)

#define IAssembly_GetFusionLoadContext(This,ppLoadContext)	\
    (This)->lpVtbl -> GetFusionLoadContext(This,ppLoadContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyNameDef_Proxy( 
    IAssembly * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyNameRef_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyModule_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetModuleByName_Proxy( 
    IAssembly * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetManifestModulePath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssembly_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyPath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR pStr,
    /* [out][in] */ LPDWORD lpcwBuffer);


void __RPC_STUB IAssembly_GetAssemblyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyLocation_Proxy( 
    IAssembly * This,
    /* [out] */ DWORD *pdwAsmLocation);


void __RPC_STUB IAssembly_GetAssemblyLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetFusionLoadContext_Proxy( 
    IAssembly * This,
    /* [out] */ IFusionLoadContext **ppLoadContext);


void __RPC_STUB IAssembly_GetFusionLoadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssembly_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBindSink_INTERFACE_DEFINED__
#define __IAssemblyBindSink_INTERFACE_DEFINED__

/* interface IAssemblyBindSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBindSink *LPASSEMBLY_BIND_SINK;

typedef /* [public] */ 
enum __MIDL_IAssemblyBindSink_0001
    {	ASM_NOTIFICATION_START	= 0,
	ASM_NOTIFICATION_PROGRESS	= ASM_NOTIFICATION_START + 1,
	ASM_NOTIFICATION_SUSPEND	= ASM_NOTIFICATION_PROGRESS + 1,
	ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE	= ASM_NOTIFICATION_SUSPEND + 1,
	ASM_NOTIFICATION_BIND_LOG	= ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE + 1,
	ASM_NOTIFICATION_DONE	= ASM_NOTIFICATION_BIND_LOG + 1
    } 	ASM_NOTIFICATION;


EXTERN_C const IID IID_IAssemblyBindSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af0bc960-0b9a-11d3-95ca-00a024a85b51")
    IAssemblyBindSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBindSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBindSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBindSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IAssemblyBindSink * This,
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IAssemblyBindSinkVtbl;

    interface IAssemblyBindSink
    {
        CONST_VTBL struct IAssemblyBindSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBindSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBindSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBindSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBindSink_OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)	\
    (This)->lpVtbl -> OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBindSink_OnProgress_Proxy( 
    IAssemblyBindSink * This,
    /* [in] */ DWORD dwNotification,
    /* [in] */ HRESULT hrNotification,
    /* [in] */ LPCWSTR szNotification,
    /* [in] */ DWORD dwProgress,
    /* [in] */ DWORD dwProgressMax,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IAssemblyBindSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBindSink_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBinding_INTERFACE_DEFINED__
#define __IAssemblyBinding_INTERFACE_DEFINED__

/* interface IAssemblyBinding */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBinding *LPASSEMBLY_BINDINDING;


EXTERN_C const IID IID_IAssemblyBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cfe52a80-12bd-11d3-95ca-00a024a85b51")
    IAssemblyBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Control( 
            /* [in] */ HRESULT hrControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDefaultUI( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Control )( 
            IAssemblyBinding * This,
            /* [in] */ HRESULT hrControl);
        
        HRESULT ( STDMETHODCALLTYPE *DoDefaultUI )( 
            IAssemblyBinding * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAssemblyBindingVtbl;

    interface IAssemblyBinding
    {
        CONST_VTBL struct IAssemblyBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBinding_Control(This,hrControl)	\
    (This)->lpVtbl -> Control(This,hrControl)

#define IAssemblyBinding_DoDefaultUI(This,hWnd,dwFlags)	\
    (This)->lpVtbl -> DoDefaultUI(This,hWnd,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBinding_Control_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HRESULT hrControl);


void __RPC_STUB IAssemblyBinding_Control_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyBinding_DoDefaultUI_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyBinding_DoDefaultUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBinding_INTERFACE_DEFINED__ */


#ifndef __IAssemblyModuleImport_INTERFACE_DEFINED__
#define __IAssemblyModuleImport_INTERFACE_DEFINED__

/* interface IAssemblyModuleImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyModuleImport *LPASSEMBLY_MODULE_IMPORT;


EXTERN_C const IID IID_IAssemblyModuleImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da0cd4b0-1117-11d3-95ca-00a024a85b51")
    IAssemblyModuleImport : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModuleName( 
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashAlgId( 
            /* [out] */ LPDWORD pdwHashAlgId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashValue( 
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ LPDWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsAvailable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyModuleImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyModuleImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyModuleImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyModuleImport * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IAssemblyModuleImport * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IAssemblyModuleImport * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAssemblyModuleImport * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IAssemblyModuleImport * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyModuleImport * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IAssemblyModuleImport * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyModuleImport * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleName )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashAlgId )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwHashAlgId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashValue )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulePath )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        BOOL ( STDMETHODCALLTYPE *IsAvailable )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyModuleImport * This,
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv);
        
        END_INTERFACE
    } IAssemblyModuleImportVtbl;

    interface IAssemblyModuleImport
    {
        CONST_VTBL struct IAssemblyModuleImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyModuleImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyModuleImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyModuleImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyModuleImport_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IAssemblyModuleImport_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IAssemblyModuleImport_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IAssemblyModuleImport_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IAssemblyModuleImport_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IAssemblyModuleImport_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IAssemblyModuleImport_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IAssemblyModuleImport_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IAssemblyModuleImport_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define IAssemblyModuleImport_GetModuleName(This,szModuleName,pccModuleName)	\
    (This)->lpVtbl -> GetModuleName(This,szModuleName,pccModuleName)

#define IAssemblyModuleImport_GetHashAlgId(This,pdwHashAlgId)	\
    (This)->lpVtbl -> GetHashAlgId(This,pdwHashAlgId)

#define IAssemblyModuleImport_GetHashValue(This,pbHashValue,pcbHashValue)	\
    (This)->lpVtbl -> GetHashValue(This,pbHashValue,pcbHashValue)

#define IAssemblyModuleImport_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IAssemblyModuleImport_GetModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetModulePath(This,szModulePath,pccModulePath)

#define IAssemblyModuleImport_IsAvailable(This)	\
    (This)->lpVtbl -> IsAvailable(This)

#define IAssemblyModuleImport_BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)	\
    (This)->lpVtbl -> BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModuleName_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModuleName,
    /* [out][in] */ LPDWORD pccModuleName);


void __RPC_STUB IAssemblyModuleImport_GetModuleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashAlgId_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwHashAlgId);


void __RPC_STUB IAssemblyModuleImport_GetHashAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashValue_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ BYTE *pbHashValue,
    /* [out][in] */ LPDWORD pcbHashValue);


void __RPC_STUB IAssemblyModuleImport_GetHashValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetFlags_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwFlags);


void __RPC_STUB IAssemblyModuleImport_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModulePath_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyModuleImport_GetModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IAssemblyModuleImport_IsAvailable_Proxy( 
    IAssemblyModuleImport * This);


void __RPC_STUB IAssemblyModuleImport_IsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_BindToObject_Proxy( 
    IAssemblyModuleImport * This,
    /* [in] */ IAssemblyBindSink *pBindSink,
    /* [in] */ IApplicationContext *pAppCtx,
    /* [in] */ LONGLONG llFlags,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyModuleImport_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyModuleImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyScavenger_INTERFACE_DEFINED__
#define __IAssemblyScavenger_INTERFACE_DEFINED__

/* interface IAssemblyScavenger */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyScavenger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00ccff8ef448")
    IAssemblyScavenger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScavengeAssemblyCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheDiskQuotas( 
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCacheDiskQuotas( 
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCacheUsage( 
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyScavengerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyScavenger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyScavenger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScavengeAssemblyCache )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentCacheUsage )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage);
        
        END_INTERFACE
    } IAssemblyScavengerVtbl;

    interface IAssemblyScavenger
    {
        CONST_VTBL struct IAssemblyScavengerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyScavenger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyScavenger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyScavenger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyScavenger_ScavengeAssemblyCache(This)	\
    (This)->lpVtbl -> ScavengeAssemblyCache(This)

#define IAssemblyScavenger_GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)	\
    (This)->lpVtbl -> GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)

#define IAssemblyScavenger_SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)	\
    (This)->lpVtbl -> SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)

#define IAssemblyScavenger_GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)	\
    (This)->lpVtbl -> GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyScavenger_ScavengeAssemblyCache_Proxy( 
    IAssemblyScavenger * This);


void __RPC_STUB IAssemblyScavenger_ScavengeAssemblyCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *pdwZapQuotaInGAC,
    /* [out] */ DWORD *pdwDownloadQuotaAdmin,
    /* [out] */ DWORD *pdwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_GetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_SetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [in] */ DWORD dwZapQuotaInGAC,
    /* [in] */ DWORD dwDownloadQuotaAdmin,
    /* [in] */ DWORD dwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_SetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCurrentCacheUsage_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *dwZapUsage,
    /* [out] */ DWORD *dwDownloadUsage);


void __RPC_STUB IAssemblyScavenger_GetCurrentCacheUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyScavenger_INTERFACE_DEFINED__ */


#ifndef __IAssemblySignature_INTERFACE_DEFINED__
#define __IAssemblySignature_INTERFACE_DEFINED__

/* interface IAssemblySignature */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblySignature;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7A63E29-EE15-437a-90B2-1CF3DF9863FF")
    IAssemblySignature : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblySignature( 
            /* [out][in] */ BYTE *pbSig,
            /* [out][in] */ DWORD *pcbSig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblySignatureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblySignature * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblySignature * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblySignature * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblySignature )( 
            IAssemblySignature * This,
            /* [out][in] */ BYTE *pbSig,
            /* [out][in] */ DWORD *pcbSig);
        
        END_INTERFACE
    } IAssemblySignatureVtbl;

    interface IAssemblySignature
    {
        CONST_VTBL struct IAssemblySignatureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblySignature_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblySignature_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblySignature_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblySignature_GetAssemblySignature(This,pbSig,pcbSig)	\
    (This)->lpVtbl -> GetAssemblySignature(This,pbSig,pcbSig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblySignature_GetAssemblySignature_Proxy( 
    IAssemblySignature * This,
    /* [out][in] */ BYTE *pbSig,
    /* [out][in] */ DWORD *pcbSig);


void __RPC_STUB IAssemblySignature_GetAssemblySignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblySignature_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusionpriv_0134 */
/* [local] */ 

STDAPI CreateHistoryReader(LPCWSTR wzFilePath, IHistoryReader **ppHistReader);
STDAPI LookupHistoryAssembly(LPCWSTR pwzFilePath, FILETIME *pftActivationDate, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR wzCulture, LPCWSTR pwzVerRef, IHistoryAssembly **pHistAsm);
STDAPI GetHistoryFileDirectory(LPWSTR wzDir, DWORD *pdwSize);
STDAPI PreBindAssembly(IApplicationContext *pAppCtx, IAssemblyName *pName, IAssembly *pAsmParent, IAssemblyName **ppNamePostPolicy, LPVOID pvReserved); 
STDAPI CreateApplicationContext(IAssemblyName *pName, LPAPPLICATIONCONTEXT *ppCtx);             


extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0134_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusionpriv_0134_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusion_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAssemblyCache,0xe707dcde,0xd1cd,0x11d2,0xba,0xb9,0x00,0xc0,0x4f,0x8e,0xce,0xae);


MIDL_DEFINE_GUID(IID, IID_IAssemblyCacheItem,0x9e3aaeb4,0xd1cd,0x11d2,0xba,0xb9,0x00,0xc0,0x4f,0x8e,0xce,0xae);


MIDL_DEFINE_GUID(IID, IID_IAssemblyName,0xCD193BC0,0xB4BC,0x11d2,0x98,0x33,0x00,0xC0,0x4F,0xC3,0x1D,0x2E);


MIDL_DEFINE_GUID(IID, IID_IAssemblyEnum,0x21b8916c,0xf28e,0x11d2,0xa4,0x73,0x00,0xc0,0x4f,0x8e,0xf4,0x48);


MIDL_DEFINE_GUID(IID, IID_IInstallReferenceItem,0x582dac66,0xe678,0x449f,0xab,0xa6,0x6f,0xaa,0xec,0x8a,0x93,0x94);


MIDL_DEFINE_GUID(IID, IID_IInstallReferenceEnum,0x56b1a988,0x7c0c,0x4aa2,0x86,0x39,0xc3,0xeb,0x5a,0x90,0x22,0x6f);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionpriv_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusionpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IHistoryAssembly,0xe6096a07,0xe188,0x4a49,0x8d,0x50,0x2a,0x01,0x72,0xa0,0xd2,0x05);


MIDL_DEFINE_GUID(IID, IID_IHistoryReader,0x1d23df4d,0xa1e2,0x4b8b,0x93,0xd6,0x6e,0xa3,0xdc,0x28,0x5a,0x54);


MIDL_DEFINE_GUID(IID, IID_IMetaDataAssemblyImportControl,0xcc8529d9,0xf336,0x471b,0xb6,0x0a,0xc7,0xc8,0xee,0x9b,0x84,0x92);


MIDL_DEFINE_GUID(IID, IID_IFusionLoadContext,0x022AB2BA,0x7367,0x49fc,0xA1,0xC5,0x0E,0x7C,0xC0,0x37,0xCA,0xAB);


MIDL_DEFINE_GUID(IID, IID_IFusionBindLog,0x67E9F87D,0x8B8A,0x4a90,0x9D,0x3E,0x85,0xED,0x5B,0x2D,0xCC,0x83);


MIDL_DEFINE_GUID(IID, IID_IAssemblyManifestImport,0xde9a68ba,0x0fa2,0x11d3,0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff);


MIDL_DEFINE_GUID(IID, IID_IApplicationContext,0x7c23ff90,0x33af,0x11d3,0x95,0xda,0x00,0xa0,0x24,0xa8,0x5b,0x51);


MIDL_DEFINE_GUID(IID, IID_IAssembly,0xff08d7d4,0x04c2,0x11d3,0x94,0xaa,0x00,0xc0,0x4f,0xc3,0x08,0xff);


MIDL_DEFINE_GUID(IID, IID_IAssemblyBindSink,0xaf0bc960,0x0b9a,0x11d3,0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51);


MIDL_DEFINE_GUID(IID, IID_IAssemblyBinding,0xcfe52a80,0x12bd,0x11d3,0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51);


MIDL_DEFINE_GUID(IID, IID_IAssemblyModuleImport,0xda0cd4b0,0x1117,0x11d3,0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51);


MIDL_DEFINE_GUID(IID, IID_IAssemblyScavenger,0x21b8916c,0xf28e,0x11d2,0xa4,0x73,0x00,0xcc,0xff,0x8e,0xf4,0x48);


MIDL_DEFINE_GUID(IID, IID_IAssemblySignature,0xC7A63E29,0xEE15,0x437a,0x90,0xB2,0x1C,0xF3,0xDF,0x98,0x63,0xFF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusionsink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  FusionSink.hpp
**
** Purpose: Implements FusionSink 
**
** Date:  Oct 26, 1998
**
===========================================================*/
#ifndef _FUSIONSINK_H
#define _FUSIONSINK_H

#include <fusion.h>
#include <fusionpriv.h>

class FusionSink : public IAssemblyBindSink
{
public:
    
    FusionSink() :
        m_hEvent(NULL),
        m_punk(NULL),
        m_pAbortUnk(NULL),
        m_cRef(1),
        pFusionLog(NULL)
    {
        Reset();
    }

    void Reset()
    {
        if(m_pAbortUnk) {
            m_pAbortUnk->Release();
            m_pAbortUnk = NULL;
        }

        if(m_punk) {
            m_punk->Release();
            m_punk = NULL;
        }
        m_LastResult = S_OK;
    }

    ~FusionSink()
    {
        if(m_hEvent)
            CloseHandle(m_hEvent);
    }

    HRESULT AssemblyResetEvent();
    HRESULT LastResult()
    {
        return m_LastResult;
    }

    STDMETHODIMP QueryInterface(REFIID riid, void **ppInterface);
    ULONG STDMETHODCALLTYPE AddRef(void); 
    ULONG STDMETHODCALLTYPE Release(void);
    
    STDMETHODIMP OnProgress(DWORD dwNotification,
                            HRESULT hrNotification,
                            LPCWSTR szNotification,
                            DWORD dwProgress,
                            DWORD dwProgressMax,
                            IUnknown* punk);

    // Wait on the event.
    virtual HRESULT Wait();

    IUnknown*    m_punk;      // Getting an assembly
    IUnknown*    m_pAbortUnk; // PUnk for aborting a bind
    CQuickString* pFusionLog;
    CQuickString m_wszCodeBase;
    BOOL         m_fProbed;
    BOOL         m_fCheckCodeBase;
    BOOL         m_fAborted;

protected:
    HRESULT AssemblyCreateEvent();

    ULONG       m_cRef;    // Ref count.
    HANDLE      m_hEvent;  // Event to block thread.
    HRESULT     m_LastResult; // Last notification result
};

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblyName = 
{ 0xcd193bc0, 0xb4bc, 0x11d2, {0x98, 0x33, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x2e } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssembly = 
{ 0xff08d7d4, 0x04c2, 0x11d3, {0x94, 0xaa, 0x00, 0xc0, 0x4f, 0xc3, 0x08, 0xff } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblyBindSink = 
{ 0xaf0bc960, 0x0b9a, 0x11d3, {0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51 } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblyModuleImport = 
{ 0xda0cd4b0, 0x1117, 0x11d3, {0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51 } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblyManifestImport = 
{ 0xde9a68ba, 0x0fa2, 0x11d3, {0x94, 0xaa, 0x00, 0xc0, 0x4f, 0xc3, 0x08, 0xff } };

extern const GUID DECLSPEC_SELECT_ANY IID_IFusionBindLog = 
{ 0x67e9f87d, 0x8b8a, 0x4a90, {0x9d, 0x3e, 0x85, 0xed, 0x5b, 0x2d, 0xcc, 0x83 } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblyBinding = 
{ 0xcfe52a80, 0x12bd, 0x11d3, {0x95, 0xca, 0x00, 0xa0, 0x24, 0xa8, 0x5b, 0x51 } };

extern const GUID DECLSPEC_SELECT_ANY IID_IAssemblySignature = 
{ 0xC7A63E29, 0xEE15, 0x437a, {0x90, 0xB2, 0x1C, 0xF3, 0xDF, 0x98, 0x63, 0xFF } };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gcdecoder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          GCDecode                                         XX
XX                                                                           XX
XX   Logic to decode the JIT method header and GC pointer tables             XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/* This file is shared between the VM and JIT/IL directories */

#include "GCInfo.h"

/*****************************************************************************/
/*
 *   This entire file depends upon GC2_ENCODING being set to 1
 *
 *****************************************************************************/

size_t FASTCALL decodeUnsigned(const BYTE *src, unsigned* val)
{
    size_t   size  = 1;
    BYTE     byte  = *src++;
    unsigned value = byte & 0x7f;
    while (byte & 0x80) {
        size++;
        byte    = *src++;
        value <<= 7;
        value  += byte & 0x7f;
    }
    *val = value;
    return size;
}

size_t FASTCALL decodeUDelta(const BYTE *src, unsigned* value, unsigned lastValue)
{
    unsigned delta;
    size_t size = decodeUnsigned(src, &delta);
    *value = lastValue + delta;
    return size;
}

size_t FASTCALL decodeSigned(const BYTE *src, int* val)
{
    size_t   size  = 1;
    BYTE     byte  = *src++;
    bool     cont  = (byte & 0x80) ? true : false;
    bool     neg   = (byte & 0x40) ? true : false;
    unsigned value = (byte & 0x3f);
    while (cont) {
        size++;
        byte = *src++;
        if ((byte & 0x80) == 0)
            cont = false;
        value <<= 7;
        value  += (byte & 0x7f);
    }
    // negation of unsigned performed via two's complement + 1
    *val = (neg) ? ((~value)+1) : value;
    return size;
}

/*****************************************************************************/

void FASTCALL decodeHeaderFirst(BYTE encoding, InfoHdr* header)
{
    *header = infoHdrShortcut[encoding&0x7f];
}

void FASTCALL decodeHeaderNext(BYTE encoding, InfoHdr* header)
{
    encoding &= 0x7f;
    if (encoding < NEXT_FOUR_START)
    {
        if (encoding < SET_ARGCOUNT)
        {
            header->frameSize = encoding - SET_FRAMESIZE;
        }
        else if (encoding < SET_PROLOGSIZE)
        {
            header->argCount = encoding - SET_ARGCOUNT;
        }
        else if (encoding < SET_EPILOGSIZE)
        {
            header->prologSize = encoding - SET_PROLOGSIZE;
        }
        else if (encoding < SET_EPILOGCNT)
        {
            header->epilogSize = encoding - SET_EPILOGSIZE;
        }
        else if (encoding < SET_UNTRACKED)
        {
            header->epilogCount = (encoding - SET_EPILOGCNT) / 2;
            header->epilogAtEnd = ((encoding - SET_EPILOGCNT) & 1) == 1;
            assert(!header->epilogAtEnd || (header->epilogCount == 1));
        }
        else if (encoding < FIRST_FLIP)
        {
            header->untrackedCnt = encoding - SET_UNTRACKED;
        }
        else switch (encoding)
        {
          default:
            assert(!"Unexpected encoding");
            break;
          case FLIP_EDI_SAVED:
            header->ediSaved ^= 1;
            break;
          case FLIP_ESI_SAVED:
            header->esiSaved ^= 1;
            break;
          case FLIP_EBX_SAVED:
            header->ebxSaved ^= 1;
            break;
          case FLIP_EBP_SAVED:
            header->ebpSaved ^= 1;
            break;
          case FLIP_EBP_FRAME:
            header->ebpFrame  ^= 1;
            break;
          case FLIP_INTERRUPTIBLE:
            header->interruptible  ^= 1;
            break;
          case FLIP_DOUBLE_ALIGN:
            header->doubleAlign  ^= 1;
            break;
          case FLIP_SECURITY:
            header->security  ^= 1;
            break;
          case FLIP_HANDLERS:
            header->handlers  ^= 1;
            break;
          case FLIP_LOCALLOC:
            header->localloc  ^= 1;
            break;
          case FLIP_EDITnCONTINUE:
            header->editNcontinue ^= 1;
            break;
          case FLIP_VARPTRTABLESZ:
            header->varPtrTableSize ^= 0xffff;
            break;
          case FFFF_UNTRACKEDCNT:
            header->untrackedCnt = 0xffff;
            break;
          case FLIP_VARARGS:
            header->varargs  ^= 1;
            break;
        }
    }
    else
    {
        unsigned lowBits;
        switch (encoding >> 4)
        {
          default:
            assert(!"Unexpected encoding");
            break;
          case 5:
            assert(NEXT_FOUR_FRAMESIZE == 0x50);
            lowBits = encoding & 0xf;
            header->frameSize  <<= 4;
            header->frameSize   += lowBits;
            break;
          case 6:
            assert(NEXT_FOUR_ARGCOUNT == 0x60);
            lowBits = encoding & 0xf;
            header->argCount   <<= 4;
            header->argCount    += lowBits;
            break;
          case 7:
            if ((encoding & 0x8) == 0)
            {
                assert(NEXT_THREE_PROLOGSIZE == 0x70);
                lowBits = encoding & 0x7;
                header->prologSize <<= 3;
                header->prologSize  += lowBits;
            }
            else
            {
                assert(NEXT_THREE_EPILOGSIZE == 0x78);
                lowBits = encoding & 0x7;
                header->epilogSize <<= 3;
                header->epilogSize  += lowBits;
            }
            break;
        }
    }
}

void FASTCALL decodeCallPattern(int          pattern,
                       unsigned *   argCnt,
                       unsigned *   regMask,
                       unsigned *   argMask,
                       unsigned *   codeDelta)
{
    assert((pattern>=0) && (pattern<80));
    CallPattern pat;
    pat.val    = callPatternTable[pattern];
    *argCnt    = pat.fld.argCnt;
    *regMask   = pat.fld.regMask;      // EBP,EBX,ESI,EDI
    *argMask   = pat.fld.argMask;
    *codeDelta = pat.fld.codeDelta;
}

InfoHdr infoHdrShortcut[128] = {
//        Prolog size
//        |
//        |   Epilog size
//        |   |
//        |   |  Epilog count
//        |   |  |
//        |   |  |  Epilog at end
//        |   |  |  |
//        |   |  |  |  EDI saved
//        |   |  |  |  |
//        |   |  |  |  |  ESI saved
//        |   |  |  |  |  |
//        |   |  |  |  |  |  EBX saved
//        |   |  |  |  |  |  |
//        |   |  |  |  |  |  |  EBP saved
//        |   |  |  |  |  |  |  |
//        |   |  |  |  |  |  |  |  EBP-frame
//        |   |  |  |  |  |  |  |  |
//        |   |  |  |  |  |  |  |  |  Interruptible method
//        |   |  |  |  |  |  |  |  |  |
//        |   |  |  |  |  |  |  |  |  |  doubleAlign
//        |   |  |  |  |  |  |  |  |  |  |
//        |   |  |  |  |  |  |  |  |  |  |  security flag
//        |   |  |  |  |  |  |  |  |  |  |  | 
//        |   |  |  |  |  |  |  |  |  |  |  |  handlers
//        |   |  |  |  |  |  |  |  |  |  |  |  |  
//        |   |  |  |  |  |  |  |  |  |  |  |  |  localloc
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  edit and continue
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  | 
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  varargs
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   Arg count
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   Frame size
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |                      Counted occurances
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |   untrackedCnt       | 
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |   |                  |
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |   |   varPtrTable    |   Header encoding
//        |   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   |   |   |              |   |
//        v   v  v  v  v  v  v  v  v  v  v  v  v  v  v  v   v   v   v   v              v   v
       {  0,  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    1139  00
       {  0,  1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //  128738  01
       {  0,  1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    3696  02
       {  0,  1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     402  03
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    4259  04
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  1,  0 },  //    3379  05
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //    2058  06
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  1,  0 },  //     728  07
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  2,  0 },  //     984  08
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  3,  0,  0,  0 },  //     606  09
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  4,  0,  0,  0 },  //    1110  0a
       {  0,  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  4,  0,  1,  0 },  //     414  0b
       {  1,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //    1553  0c
       {  1,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  1,  0, -1 },  //     584  0d
       {  1,  2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //    2182  0e
       {  1,  2, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    3445  0f
       {  1,  2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1369  10
       {  1,  2, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     515  11
       {  1,  2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //   21127  12
       {  1,  2, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    3517  13
       {  1,  2, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     750  14
       {  1,  4, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1876  15
       {  1,  4, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  1,  0 },  //    1665  16
       {  1,  4, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     729  17
       {  1,  4, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  2,  0 },  //     484  18
       {  1,  4, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //     331  19
       {  2,  3, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //     361  1a
       {  2,  3, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     964  1b
       {  2,  3, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    3713  1c
       {  2,  3, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     466  1d
       {  2,  3, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1325  1e
       {  2,  3, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //     712  1f
       {  2,  3, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     588  20
       {  2,  3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //   20542  21
       {  2,  3, 2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    3802  22
       {  2,  3, 3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     798  23
       {  2,  5, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1900  24
       {  2,  5, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     385  25
       {  2,  5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1617  26
       {  2,  5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  1,  0 },  //    1743  27
       {  2,  5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     909  28
       {  2,  5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  1,  0 },  //     602  29
       {  2,  5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  2,  0 },  //     352  2a
       {  2,  6, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //     657  2b
       {  2,  7, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  0,  0, -1 },  //    1283  2c
       {  2,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  1,  0, -1 },  //    1286  2d
       {  3,  4, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1495  2e
       {  3,  4, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    1989  2f
       {  3,  4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1154  30
       {  3,  4, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    9300  31
       {  3,  4, 2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //     392  32
       {  3,  4, 2, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    1720  33
       {  3,  6, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1246  34
       {  3,  6, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     800  35
       {  3,  6, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1179  36
       {  3,  6, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  1,  0 },  //    1368  37
       {  3,  6, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     349  38
       {  3,  6, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  2,  0 },  //     505  39
       {  3,  6, 2, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //     629  3a
       {  3,  8, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,  0,  9,  2, -1 },  //     365  3b
       {  4,  5, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //     487  3c
       {  4,  5, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    1752  3d
       {  4,  5, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1959  3e
       {  4,  5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    2436  3f
       {  4,  5, 2, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     861  40
       {  4,  7, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1459  41
       {  4,  7, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     950  42
       {  4,  7, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //    1491  43
       {  4,  7, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  0,  1,  0 },  //     879  44
       {  4,  7, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  0,  0,  0 },  //     408  45
       {  5,  4, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //    4870  46
       {  5,  6, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //     359  47
       {  5,  6, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0,  0 },  //     915  48
       {  5,  6, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  4,  0,  0 },  //     412  49
       {  5,  6, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1288  4a
       {  5,  6, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //    1591  4b
       {  5,  6, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  1,  0, -1 },  //     361  4c
       {  5,  6, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  1,  0,  0 },  //     623  4d
       {  5,  8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  1,  0,  0 },  //    1239  4e
       {  6,  0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     457  4f
       {  6,  0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     606  50
       {  6,  4, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0, -1 },  //    1073  51
       {  6,  4, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0, -1 },  //     508  52
       {  6,  6, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //     330  53
       {  6,  6, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0,  0 },  //    1709  54
       {  6,  7, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0,  0 },  //    1164  55
       {  7,  4, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0 },  //     556  56
       {  7,  5, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  3,  0, -1 },  //     529  57
       {  7,  5, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  5,  0, -1 },  //    1423  58
       {  7,  8, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  3,  0, -1 },  //    2455  59
       {  7,  8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0,  0 },  //     956  5a
       {  7,  8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0, -1 },  //    1399  5b
       {  7,  8, 2, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  3,  0, -1 },  //     587  5c
       {  7, 10, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  6,  1, -1 },  //     743  5d
       {  7, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  2,  0,  0 },  //    1004  5e
       {  7, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  1,  2,  1, -1 },  //     487  5f
       {  7, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  2,  0,  0 },  //     337  60
       {  7, 10, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  2,  3,  0, -1 },  //     361  61
       {  8,  3, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  0 },  //     560  62
       {  8,  6, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0,  0 },  //    1377  63
       {  9,  4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  0 },  //     877  64
       {  9,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  2,  0,  0 },  //    3041  65
       {  9,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  0,  0, -1 },  //     349  66
       { 10,  5, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  4,  1,  0 },  //    2061  67
       { 10,  5, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  0 },  //     577  68
       { 11,  6, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  4,  1,  0 },  //    1195  69
       { 12,  5, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0,  0,  1,  0,  0 },  //     491  6a
       { 13,  8, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,  0,  9,  0, -1 },  //     627  6b
       { 13,  8, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0,  2,  1,  0 },  //    1099  6c
       { 13, 10, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0,  2,  6,  1, -1 },  //     488  6d
       { 14,  7, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //     574  6e
       { 16,  7, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  4,  0, -1 },  //    1281  6f
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  0,  0, -1 },  //    1881  70
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  1,  0, -1 },  //     339  71
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  3,  0,  0 },  //    2594  72
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  4,  0,  0 },  //     339  73
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  4,  0, -1 },  //    2107  74
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  5,  0, -1 },  //    2372  75
       { 16,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  6,  0, -1 },  //    1078  76
       { 16,  7, 2, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  4,  0, -1 },  //     384  77
       { 16,  9, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  1,  4,  1, -1 },  //    1541  78
       { 16,  9, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  2,  4,  1, -1 },  //     975  79
       { 19,  7, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,  0,  5,  0, -1 },  //     546  7a
       { 24,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0,  0,  5,  0, -1 },  //     675  7b
       { 45,  9, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  1,  0,  0,  0 },  //     902  7c
       { 51,  7, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0, 13,  0, -1 },  //     432  7d
       { 51,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0,  1,  0, -1 },  //     361  7e
       { 51,  7, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0, 11,  0,  0 },  //     703  7f
};

 // The first call to encodeHeaderFirst will fill in this table
int infoHdrLookup[IH_MAX_PROLOG_SIZE+2] = { 0xff };

unsigned callCommonDelta[4] = { 6,8,10,12 };

/*
 *  In the callPatternTable each 32-bit unsigned value represents four bytes:
 *
 *  byte0,byte1,byte2,byte3 => codeDelta,argMask,regMask,argCnt
 *  for example 0x0c000301  => codeDelta of 12, argMask of 0,
 *                             regMask of 0x3,  argCnt of 1
 *
 *  Furthermore within the table the following maximum values are in place:
 *
 *  codeDelta <= CP_MAX_CODE_DELTA  // (0x23)
 *  argCnt    <= CP_MAX_ARG_CNT     // (0x02)
 *  argMask   <= CP_MAX_ARG_MASK    // (0x00)
 *
 *  Note that ARG_CNT is the count of pushed args for a nested call site.
 *   And since the first two arguments are always passed in registers
 *   an ARG_CNT of 1 would mean that the nested call site had three arguments
 * 
 *  Note that ARG_MASK is the mask of pushed args that contain GC pointers
 *   since the first two arguments are always passed in registers it is
 *   a fairly rare occurance to push a GC pointer as an argument, since it
 *   only occurs for nested calls, when the third or later argument for the
 *   outer call contains a GC ref.
 *
 *  Additionally the encoding of the regMask uses the following bits:
 *   EDI = 0x1, ESI = 0x2, EBX = 0x4, EBP = 0x8
 *
 */
unsigned callPatternTable[80] = {               // # of occurances
	0x0a000200,	//   30109
	0x0c000200,	//   22970
	0x0c000201,	//   19005
	0x0a000300,	//   12193
	0x0c000300,	//   10614
	0x0e000200,	//   10253
	0x10000200,	//    9746
	0x0b000200,	//    9698
	0x0d000200,	//    9625
	0x08000200,	//    8909
	0x0c000301,	//    8522
	0x11000200,	//    7382
	0x0e000300,	//    7357
	0x12000200,	//    7139
	0x10000300,	//    7062
	0x11000300,	//    6970
	0x0a000201,	//    6842
	0x0a000100,	//    6803
	0x0f000200,	//    6795
	0x13000200,	//    6559
	0x08000300,	//    6079
	0x15000200,	//    5874
	0x0d000201,	//    5492
	0x0c000100,	//    5193
	0x0d000300,	//    5165
	0x23000200,	//    5143
	0x1b000200,	//    5035
	0x14000200,	//    4872
	0x0f000300,	//    4850
	0x0a000700,	//    4781
	0x09000200,	//    4560
	0x12000300,	//    4496
	0x16000200,	//    4180
	0x07000200,	//    4021
	0x09000300,	//    4012
	0x0c000700,	//    3988
	0x0c000600,	//    3946
	0x0e000100,	//    3823
	0x1a000200,	//    3764
	0x18000200,	//    3744
	0x17000200,	//    3736
	0x1f000200,	//    3671
	0x13000300,	//    3559
	0x0a000600,	//    3214
	0x0e000600,	//    3109
	0x08000201,	//    2984
	0x0b000300,	//    2928
	0x0a000301,	//    2859
	0x07000100,	//    2826
	0x13000100,	//    2782
	0x09000301,	//    2644
	0x19000200,	//    2638
	0x11000700,	//    2618
	0x21000200,	//    2518
	0x0d000202,	//    2484
	0x10000100,	//    2480
	0x0f000600,	//    2413
	0x14000300,	//    2363
	0x0c000500,	//    2362
	0x08000301,	//    2285
	0x20000200,	//    2245
	0x10000700,	//    2240
	0x0f000100,	//    2236
	0x1e000200,	//    2214
	0x0c000400,	//    2193
	0x16000300,	//    2171
	0x12000600,	//    2132
	0x22000200,	//    2011
	0x1d000200,	//    2011
	0x0c000f00,	//    1996
	0x0e000700,	//    1971
	0x0a000400,	//    1970
	0x09000201,	//    1932
	0x10000600,	//    1903
	0x15000300,	//    1847
	0x0a000101,	//    1814
	0x0a000b00,	//    1771
	0x0c000601,	//    1737
	0x09000700,	//    1737
	0x07000300,	//    1684
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gchost_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:21 2003
 */
/* Compiler settings for gchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IGCHost,0xFAC34F6E,0x0DCD,0x47b5,0x80,0x21,0x53,0x1B,0xC5,0xEC,0xCA,0x63);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gcdump.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *                                  GCDump.h
 *
 * Defines functions to display the GCInfo as defined by the GC-encoding 
 * spec. The GC information may be either dynamically created by a 
 * Just-In-Time compiler conforming to the standard code-manager spec,
 * or may be persisted by a managed native code compiler conforming
 * to the standard code-manager spec.
 */

/*****************************************************************************/
#ifndef __GCDUMP_H__
#define __GCDUMP_H__
/*****************************************************************************/

#include "GCInfo.h"     // For InfoHdr

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif


class GCDump
{
public:

    GCDump                          (bool           encBytes     = true, 
                                     unsigned       maxEncBytes  = 5, 
                                     bool           dumpCodeOffs = true);

    /*-------------------------------------------------------------------------
     * Dumps the InfoHdr to 'stdout'
     * table            : Start of the GC info block
     * verifyGCTables   : If the JIT has been compiled with VERIFY_GC_TABLES
     * Return value     : Size in bytes of the header encoding
     */

    unsigned FASTCALL   DumpInfoHdr (const BYTE *   table,
                                     InfoHdr    *   header,         /* OUT */
                                     unsigned   *   methodSize,     /* OUT */
                                     bool           verifyGCTables = false);

    /*-------------------------------------------------------------------------
     * Dumps the GC tables to 'stdout'
     * table            : Ptr to the start of the table part of the GC info.
     *                      This immediately follows the GCinfo header
     * verifyGCTables   : If the JIT has been compiled with VERIFY_GC_TABLES
     * Return value     : Size in bytes of the GC table encodings
     */

    unsigned FASTCALL   DumpGCTable (const BYTE *   table,
                                     const InfoHdr& header,
                                     unsigned       methodSize,
                                     bool           verifyGCTables = false);

    /*-------------------------------------------------------------------------
     * Dumps the location of ptrs for the given code offset
     * verifyGCTables   : If the JIT has been compiled with VERIFY_GC_TABLES
     */

    void     FASTCALL   DumpPtrsInFrame(const void *infoBlock,
                                     const void *   codeBlock,
                                     unsigned       offs,
                                     bool           verifyGCTables = false);


public:
	typedef void (*printfFtn)(const char* fmt, ...);
	printfFtn gcPrintf;	
    //-------------------------------------------------------------------------
protected:

    bool                fDumpEncBytes;
    unsigned            cMaxEncBytes;

    bool                fDumpCodeOffsets;

    /* Helper methods */

    const BYTE    *     DumpEncoding(const BYTE *   table, 
                                     int            cDumpBytes);
    void                DumpOffset  (unsigned       o);
    void                DumpOffsetEx(unsigned       o);

};

/*****************************************************************************/
#endif // __GC_DUMP_H__
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gchost.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:21 2003
 */
/* Compiler settings for gchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gchost_h__
#define __gchost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGCHost_FWD_DEFINED__
#define __IGCHost_FWD_DEFINED__
typedef interface IGCHost IGCHost;
#endif 	/* __IGCHost_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_gchost_0000 */
/* [local] */ 

#ifndef _BASETSD_H_
#pragma once
typedef signed char INT8;

typedef signed char *PINT8;

typedef short INT16;

typedef short *PINT16;

typedef int INT32;

typedef int *PINT32;

typedef __int64 INT64;

typedef __int64 *PINT64;

typedef unsigned char UINT8;

typedef unsigned char *PUINT8;

typedef unsigned short UINT16;

typedef unsigned short *PUINT16;

typedef unsigned int UINT32;

typedef unsigned int *PUINT32;

typedef unsigned __int64 UINT64;

typedef unsigned __int64 *PUINT64;

typedef int LONG32;

typedef int *PLONG32;

typedef unsigned int ULONG32;

typedef unsigned int *PULONG32;

typedef unsigned int DWORD32;

typedef unsigned int *PDWORD32;

typedef /* [public] */ __int3264 INT_PTR;

typedef /* [public] */ __int3264 *PINT_PTR;

typedef /* [public] */ unsigned __int3264 UINT_PTR;

typedef /* [public] */ unsigned __int3264 *PUINT_PTR;

typedef /* [public] */ __int3264 LONG_PTR;

typedef /* [public] */ __int3264 *PLONG_PTR;

typedef /* [public] */ unsigned __int3264 ULONG_PTR;

typedef /* [public] */ unsigned __int3264 *PULONG_PTR;

typedef unsigned short UHALF_PTR;

typedef unsigned short *PUHALF_PTR;

typedef short HALF_PTR;

typedef short *PHALF_PTR;

typedef long SHANDLE_PTR;

typedef unsigned long HANDLE_PTR;

typedef ULONG_PTR SIZE_T;

typedef ULONG_PTR *PSIZE_T;

typedef LONG_PTR SSIZE_T;

typedef LONG_PTR *PSSIZE_T;

typedef ULONG_PTR DWORD_PTR;

typedef ULONG_PTR *PDWORD_PTR;

typedef __int64 LONG64;

typedef __int64 *PLONG64;

typedef unsigned __int64 ULONG64;

typedef unsigned __int64 *PULONG64;

typedef unsigned __int64 DWORD64;

typedef unsigned __int64 *PDWORD64;

typedef ULONG_PTR KAFFINITY;

typedef KAFFINITY *PKAFFINITY;

#endif // _BASETSD_H_
typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0001
    {	COR_GC_COUNTS	= 0x1,
	COR_GC_MEMORYUSAGE	= 0x2
    } 	COR_GC_STAT_TYPES;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0002
    {	COR_GC_THREAD_HAS_PROMOTED_BYTES	= 0x1
    } 	COR_GC_THREAD_STATS_TYPES;

typedef struct _COR_GC_STATS
    {
    ULONG Flags;
    SIZE_T ExplicitGCCount;
    SIZE_T GenCollectionsTaken[ 3 ];
    SIZE_T CommittedKBytes;
    SIZE_T ReservedKBytes;
    SIZE_T Gen0HeapSizeKBytes;
    SIZE_T Gen1HeapSizeKBytes;
    SIZE_T Gen2HeapSizeKBytes;
    SIZE_T LargeObjectHeapSizeKBytes;
    SIZE_T KBytesPromotedFromGen0;
    SIZE_T KBytesPromotedFromGen1;
    } 	COR_GC_STATS;

typedef struct _COR_GC_THREAD_STATS
    {
    ULONGLONG PerThreadAllocation;
    ULONG Flags;
    } 	COR_GC_THREAD_STATS;



extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_s_ifspec;

#ifndef __IGCHost_INTERFACE_DEFINED__
#define __IGCHost_INTERFACE_DEFINED__

/* interface IGCHost */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IGCHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC34F6E-0DCD-47b5-8021-531BC5ECCA63")
    IGCHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGCStartupLimits( 
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collect( 
            /* [in] */ long Generation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStats( 
            /* [out][in] */ COR_GC_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadStats( 
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMemLimit( 
            /* [in] */ SIZE_T sztMaxVirtualMemMB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCStartupLimits )( 
            IGCHost * This,
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size);
        
        HRESULT ( STDMETHODCALLTYPE *Collect )( 
            IGCHost * This,
            /* [in] */ long Generation);
        
        HRESULT ( STDMETHODCALLTYPE *GetStats )( 
            IGCHost * This,
            /* [out][in] */ COR_GC_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadStats )( 
            IGCHost * This,
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetVirtualMemLimit )( 
            IGCHost * This,
            /* [in] */ SIZE_T sztMaxVirtualMemMB);
        
        END_INTERFACE
    } IGCHostVtbl;

    interface IGCHost
    {
        CONST_VTBL struct IGCHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCHost_SetGCStartupLimits(This,SegmentSize,MaxGen0Size)	\
    (This)->lpVtbl -> SetGCStartupLimits(This,SegmentSize,MaxGen0Size)

#define IGCHost_Collect(This,Generation)	\
    (This)->lpVtbl -> Collect(This,Generation)

#define IGCHost_GetStats(This,pStats)	\
    (This)->lpVtbl -> GetStats(This,pStats)

#define IGCHost_GetThreadStats(This,pFiberCookie,pStats)	\
    (This)->lpVtbl -> GetThreadStats(This,pFiberCookie,pStats)

#define IGCHost_SetVirtualMemLimit(This,sztMaxVirtualMemMB)	\
    (This)->lpVtbl -> SetVirtualMemLimit(This,sztMaxVirtualMemMB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCHost_SetGCStartupLimits_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD SegmentSize,
    /* [in] */ DWORD MaxGen0Size);


void __RPC_STUB IGCHost_SetGCStartupLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_Collect_Proxy( 
    IGCHost * This,
    /* [in] */ long Generation);


void __RPC_STUB IGCHost_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetStats_Proxy( 
    IGCHost * This,
    /* [out][in] */ COR_GC_STATS *pStats);


void __RPC_STUB IGCHost_GetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetThreadStats_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD *pFiberCookie,
    /* [out][in] */ COR_GC_THREAD_STATS *pStats);


void __RPC_STUB IGCHost_GetThreadStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_SetVirtualMemLimit_Proxy( 
    IGCHost * This,
    /* [in] */ SIZE_T sztMaxVirtualMemMB);


void __RPC_STUB IGCHost_SetVirtualMemLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCHost_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\fusion_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:07 2003
 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "fusion.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_fusion_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAssemblyCache, ver. 0.0,
   GUID={0xe707dcde,0xd1cd,0x11d2,{0xba,0xb9,0x00,0xc0,0x4f,0x8e,0xce,0xae}} */


/* Object interface: IAssemblyCacheItem, ver. 0.0,
   GUID={0x9e3aaeb4,0xd1cd,0x11d2,{0xba,0xb9,0x00,0xc0,0x4f,0x8e,0xce,0xae}} */


/* Object interface: IAssemblyName, ver. 0.0,
   GUID={0xCD193BC0,0xB4BC,0x11d2,{0x98,0x33,0x00,0xC0,0x4F,0xC3,0x1D,0x2E}} */


/* Object interface: IAssemblyEnum, ver. 0.0,
   GUID={0x21b8916c,0xf28e,0x11d2,{0xa4,0x73,0x00,0xc0,0x4f,0x8e,0xf4,0x48}} */


/* Object interface: IInstallReferenceItem, ver. 0.0,
   GUID={0x582dac66,0xe678,0x449f,{0xab,0xa6,0x6f,0xaa,0xec,0x8a,0x93,0x94}} */


/* Object interface: IInstallReferenceEnum, ver. 0.0,
   GUID={0x56b1a988,0x7c0c,0x4aa2,{0x86,0x39,0xc3,0xeb,0x5a,0x90,0x22,0x6f}} */


/* Standard interface: __MIDL_itf_fusion_0118, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _fusion_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _fusion_StubVtblList[] = 
{
    0
};

PCInterfaceName const _fusion_InterfaceNamesList[] = 
{
    0
};


#define _fusion_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _fusion, pIID, n)

int __stdcall _fusion_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo fusion_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _fusion_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _fusion_StubVtblList,
    (const PCInterfaceName * ) & _fusion_InterfaceNamesList,
    0, // no delegation
    & _fusion_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\guidfromname.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef GUIDFROMNAME_H_
#define GUIDFROMNAME_H_

// GuidFromName.h - function prototype

void CorGuidFromNameW
(
    GUID *  pGuidResult,        // resulting GUID
    LPCWSTR wzName,             // the unicode name from which to generate a GUID
    SIZE_T  cchName             // name length in count of unicode character
);

void CorIIDFromCLSID
(
    GUID *  pGuidResult,        // resulting GUID
    REFGUID GuidClsid           // CLSID from which to derive GUID.
);

#endif // GUIDFROMNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gcinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _GCINFO_H_
#define _GCINFO_H_
/*****************************************************************************/

#include <stdlib.h>     // For memcmp()
#include "windef.h"     // For BYTE

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

enum infoHdrAdjustConstants {
  // Constants
  SET_FRAMESIZE_MAX  =  7,
  SET_ARGCOUNT_MAX   =  8,	// Change to 6
  SET_PROLOGSIZE_MAX = 16,
  SET_EPILOGSIZE_MAX = 10,	// Change to 6
  SET_EPILOGCNT_MAX  =  4,
  SET_UNTRACKED_MAX  =  3
};

//
// Enum to define the 128 codes that are used to incrementally adjust the InfoHdr structure
//
enum infoHdrAdjust {

  SET_FRAMESIZE    = 0,                                            // 0x00
  SET_ARGCOUNT     = SET_FRAMESIZE  + SET_FRAMESIZE_MAX  + 1,      // 0x08
  SET_PROLOGSIZE   = SET_ARGCOUNT   + SET_ARGCOUNT_MAX   + 1,      // 0x11
  SET_EPILOGSIZE   = SET_PROLOGSIZE + SET_PROLOGSIZE_MAX + 1,      // 0x22
  SET_EPILOGCNT    = SET_EPILOGSIZE + SET_EPILOGSIZE_MAX + 1,      // 0x2d
  SET_UNTRACKED    = SET_EPILOGCNT  + (SET_EPILOGCNT_MAX + 1) * 2, // 0x37

  FIRST_FLIP       = SET_UNTRACKED  + SET_UNTRACKED_MAX + 1,

  FLIP_EDI_SAVED   = FIRST_FLIP, // 0x3b
  FLIP_ESI_SAVED,      // 0x3c
  FLIP_EBX_SAVED,      // 0x3d
  FLIP_EBP_SAVED,      // 0x3e
  FLIP_EBP_FRAME,      // 0x3f
  FLIP_INTERRUPTIBLE,  // 0x40
  FLIP_DOUBLE_ALIGN,   // 0x41
  FLIP_SECURITY,       // 0x42
  FLIP_HANDLERS,       // 0x43
  FLIP_LOCALLOC,       // 0x44
  FLIP_EDITnCONTINUE,  // 0x45
  FLIP_VARPTRTABLESZ,  // 0x46
  FFFF_UNTRACKEDCNT,   // 0x47
  FLIP_VARARGS,        // 0x48
                       // 0x49 .. 0x4f unused

  NEXT_FOUR_START       = 0x50,
  NEXT_FOUR_FRAMESIZE   = 0x50,
  NEXT_FOUR_ARGCOUNT    = 0x60,
  NEXT_THREE_PROLOGSIZE = 0x70,
  NEXT_THREE_EPILOGSIZE = 0x78
};

#pragma pack(push, 1)

struct InfoHdr {
    unsigned char  prologSize;        // 0
    unsigned char  epilogSize;        // 1
    unsigned char  epilogCount   : 3; // 2 [0:2]
    unsigned char  epilogAtEnd   : 1; // 2 [3]
    unsigned char  ediSaved      : 1; // 2 [4]      which callee-saved regs are pushed onto stack
    unsigned char  esiSaved      : 1; // 2 [5]
    unsigned char  ebxSaved      : 1; // 2 [6]
    unsigned char  ebpSaved      : 1; // 2 [7]
    unsigned char  ebpFrame      : 1; // 3 [0]      locals accessed relative to ebp
    unsigned char  interruptible : 1; // 3 [1]      is intr. at all points (except prolog/epilog), not just call-sites
    unsigned char  doubleAlign   : 1; // 3 [2]      uses double-aligned stack
    unsigned char  security      : 1; // 3 [3]      has slot for security object
    unsigned char  handlers      : 1; // 3 [4]      has callable handlers
    unsigned char  localloc      : 1; // 3 [5]      uses localloc
    unsigned char  editNcontinue : 1; // 3 [6]      was JITed in EnC mode
    unsigned char  varargs       : 1; // 3 [7]      function uses varargs calling convention
    unsigned short argCount;          // 4,5        in DWORDs
    unsigned short frameSize;         // 6,7        in DWORDs
    unsigned short untrackedCnt;      // 8,9
    unsigned short varPtrTableSize;   //10,11
                                      // 12 bytes total
    bool isMatch(const InfoHdr& x) {
        if (memcmp(this, &x, sizeof(InfoHdr)-4) != 0)
            return false;
        bool needChk1;
        bool needChk2;
        if (untrackedCnt == x.untrackedCnt) {
            if (varPtrTableSize == x.varPtrTableSize)
                return true;
            else {
                needChk1 = false;
                needChk2 = true;
            }
        }
        else if (varPtrTableSize == x.varPtrTableSize) {
            needChk1 = true;
            needChk2 = false;
        }
        else {
            needChk1 = true;
            needChk2 = true;
        }
        if (needChk1) {
            if ((untrackedCnt != 0xffff) && (x.untrackedCnt < 4))
                return false;
            else if ((x.untrackedCnt != 0xffff) && (untrackedCnt < 4))
                return false;
        }
        if (needChk2) {
            if ((varPtrTableSize == 0xffff) && (x.varPtrTableSize != 0))
                return true;
            else if ((x.varPtrTableSize == 0xffff) && (varPtrTableSize != 0))
                return true;
            else
                return false;
        }
        return true;
    }
};

union CallPattern {
    struct {
        unsigned char argCnt;
        unsigned char regMask;  // EBP=0x8, EBX=0x4, ESI=0x2, EDI=0x1
        unsigned char argMask;
        unsigned char codeDelta;
    }            fld;
    unsigned     val;
};

#pragma pack(pop)

#define IH_MAX_PROLOG_SIZE (51)

extern InfoHdr infoHdrShortcut[];
extern int     infoHdrLookup[];

void FASTCALL decodeHeaderFirst(BYTE encoding, InfoHdr* header);
void FASTCALL decodeHeaderNext (BYTE encoding, InfoHdr* header);

BYTE FASTCALL encodeHeaderFirst(const InfoHdr& header, InfoHdr* state, int* more);
BYTE FASTCALL encodeHeaderNext (const InfoHdr& header, InfoHdr* state);

size_t FASTCALL decodeUnsigned (const BYTE *src, unsigned* value);
size_t FASTCALL decodeUDelta   (const BYTE *src, unsigned* value, unsigned lastValue);
size_t FASTCALL decodeSigned   (const BYTE *src, int     * value);

#define CP_MAX_CODE_DELTA  (0x23)
#define CP_MAX_ARG_CNT     (0x02)
#define CP_MAX_ARG_MASK    (0x00)

extern unsigned callPatternTable[];
extern unsigned callCommonDelta[];


int  FASTCALL lookupCallPattern(unsigned    argCnt,
                                unsigned    regMask,
                                unsigned    argMask,
                                unsigned    codeDelta);

void FASTCALL decodeCallPattern(int         pattern,
                                unsigned *  argCnt,
                                unsigned *  regMask,
                                unsigned *  argMask,
                                unsigned *  codeDelta);


// Use the lower 2 bits of the offsets stored in the tables
// to encode properties

const unsigned        OFFSET_MASK  = 0x3;  // mask to access the low 2 bits

//
//  Note for untracked locals the flags allowed are "pinned" and "byref"
//   and for tracked locals the flags allowed are "this" and "byref"
//  Note that these definitions should also match the definitions of
//   GC_CALL_INTERIOR and GC_CALL_PINNED in VM/gc.h
//
const unsigned  byref_OFFSET_FLAG  = 0x1;  // the offset is an interior ptr
const unsigned pinned_OFFSET_FLAG  = 0x2;  // the offset is a pinned ptr
const unsigned   this_OFFSET_FLAG  = 0x2;  // the offset is "this"


/*****************************************************************************/
#endif //_GCINFO_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\gchost_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:21 2003
 */
/* Compiler settings for gchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "gchost.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_gchost_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IGCHost, ver. 0.0,
   GUID={0xFAC34F6E,0x0DCD,0x47b5,{0x80,0x21,0x53,0x1B,0xC5,0xEC,0xCA,0x63}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _gchost_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _gchost_StubVtblList[] = 
{
    0
};

PCInterfaceName const _gchost_InterfaceNamesList[] = 
{
    0
};


#define _gchost_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _gchost, pIID, n)

int __stdcall _gchost_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo gchost_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _gchost_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _gchost_StubVtblList,
    (const PCInterfaceName * ) & _gchost_InterfaceNamesList,
    0, // no delegation
    & _gchost_IID_Lookup, 
    0,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\hrex.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _HREX_H
#define _HREX_H

/* --------------------------------------------------------------------------- *
 * HR <-> SEH exception functions.
 * --------------------------------------------------------------------------- */

#ifndef IfFailThrow
#define IfFailThrow(hr) \
	do { HRESULT _hr = hr; if (FAILED(_hr)) ThrowHR(_hr); } while (0)
#endif

#define HR_EXCEPTION_CODE (0xe0000000 | ' HR')

inline void ThrowHR(HRESULT hr)
{
#ifdef _WIN64
	ULONG_PTR parameter = hr;
#else
	ULONG parameter = hr;
#endif
	RaiseException(HR_EXCEPTION_CODE, 0, 1, &parameter);
}

inline void ThrowError(DWORD error)
{
	ThrowHR(HRESULT_FROM_WIN32(error));
}

inline void ThrowLastError()
{
	ThrowError(GetLastError());
}

inline IsHRException(EXCEPTION_RECORD *record) 
{
	return record->ExceptionCode == HR_EXCEPTION_CODE;
}

inline GetHRException(EXCEPTION_RECORD *record)
{
	return (HRESULT) record->ExceptionInformation[0];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\iceefilegen.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** ICeeFileGen.h - code generator interface.                               **
 **                                                                         **
 *****************************************************************************/


#ifndef _ICEEFILEGEN_H_
#define _ICEEFILEGEN_H_

#include <ole2.h>
#include "cor.h"

class ICeeFileGen;

typedef void *HCEEFILE;

HRESULT __stdcall CreateICeeFileGen(ICeeFileGen **ceeFileGen); // call this to instantiate
HRESULT __stdcall DestroyICeeFileGen(ICeeFileGen **ceeFileGen); // call this to delete

class ICeeFileGen {
  public:
    virtual HRESULT CreateCeeFile(HCEEFILE *ceeFile); // call this to instantiate

	// @FUTURE: remove this function. We no longer support mdScope.
    virtual HRESULT EmitMetaData (HCEEFILE ceeFile, IMetaDataEmit *emitter, mdScope scope);
    virtual HRESULT EmitLibraryName (HCEEFILE ceeFile, IMetaDataEmit *emitter, mdScope scope);
    virtual HRESULT EmitMethod (); // @FUTURE: remove
    virtual HRESULT GetMethodRVA (HCEEFILE ceeFile, ULONG codeOffset, ULONG *codeRVA); 
    virtual HRESULT EmitSignature (); // @FUTURE: remove

    virtual HRESULT EmitString (HCEEFILE ceeFile,LPWSTR strValue, ULONG *strRef);
    virtual HRESULT GenerateCeeFile (HCEEFILE ceeFile);

    virtual HRESULT SetOutputFileName (HCEEFILE ceeFile, LPWSTR outputFileName);
    virtual HRESULT GetOutputFileName (HCEEFILE ceeFile, LPWSTR *outputFileName);

    virtual HRESULT SetResourceFileName (HCEEFILE ceeFile, LPWSTR resourceFileName);
    virtual HRESULT GetResourceFileName (HCEEFILE ceeFile, LPWSTR *resourceFileName);

    virtual HRESULT SetImageBase(HCEEFILE ceeFile, size_t imageBase);

    virtual HRESULT SetSubsystem(HCEEFILE ceeFile, DWORD subsystem, DWORD major, DWORD minor);

    virtual HRESULT SetEntryClassToken (); //@FUTURE: remove
    virtual HRESULT GetEntryClassToken (); //@FUTURE: remove

    virtual HRESULT SetEntryPointDescr (); //@FUTURE: remove
    virtual HRESULT GetEntryPointDescr (); //@FUTURE: remove

    virtual HRESULT SetEntryPointFlags (); //@FUTURE: remove
    virtual HRESULT GetEntryPointFlags (); //@FUTURE: remove

    virtual HRESULT SetDllSwitch (HCEEFILE ceeFile, BOOL dllSwitch);
    virtual HRESULT GetDllSwitch (HCEEFILE ceeFile, BOOL *dllSwitch);

    virtual HRESULT SetLibraryName (HCEEFILE ceeFile, LPWSTR LibraryName);
    virtual HRESULT GetLibraryName (HCEEFILE ceeFile, LPWSTR *LibraryName);

    virtual HRESULT SetLibraryGuid (HCEEFILE ceeFile, LPWSTR LibraryGuid);

    virtual HRESULT DestroyCeeFile(HCEEFILE *ceeFile); // call this to instantiate

    virtual HRESULT GetSectionCreate (HCEEFILE ceeFile, const char *name, DWORD flags, HCEESECTION *section);
    virtual HRESULT GetIlSection (HCEEFILE ceeFile, HCEESECTION *section);
    virtual HRESULT GetRdataSection (HCEEFILE ceeFile, HCEESECTION *section);

    virtual HRESULT GetSectionDataLen (HCEESECTION section, ULONG *dataLen);
    virtual HRESULT GetSectionBlock (HCEESECTION section, ULONG len, ULONG align=1, void **ppBytes=0);
    virtual HRESULT TruncateSection (HCEESECTION section, ULONG len);
    virtual HRESULT AddSectionReloc (HCEESECTION section, ULONG offset, HCEESECTION relativeTo, CeeSectionRelocType relocType);

    // deprecated: use SetDirectoryEntry instead
    virtual HRESULT SetSectionDirectoryEntry (HCEESECTION section, ULONG num);

    virtual HRESULT CreateSig (); //@FUTURE: Remove
    virtual HRESULT AddSigArg (); //@FUTURE: Remove
    virtual HRESULT SetSigReturnType (); //@FUTURE: Remove
    virtual HRESULT SetSigCallingConvention (); //@FUTURE: Remove
    virtual HRESULT DeleteSig (); //@FUTURE: Remove

    virtual HRESULT SetEntryPoint (HCEEFILE ceeFile, mdMethodDef method);
    virtual HRESULT GetEntryPoint (HCEEFILE ceeFile, mdMethodDef *method);

    virtual HRESULT SetComImageFlags (HCEEFILE ceeFile, DWORD mask);
    virtual HRESULT GetComImageFlags (HCEEFILE ceeFile, DWORD *mask);

    // get IMapToken interface for tracking mapped tokens
    virtual HRESULT GetIMapTokenIface(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken);
    virtual HRESULT SetDirectoryEntry (HCEEFILE ceeFile, HCEESECTION section, ULONG num, ULONG size, ULONG offset = 0);

    virtual HRESULT EmitMetaDataEx (HCEEFILE ceeFile, IMetaDataEmit *emitter); 
    virtual HRESULT EmitLibraryNameEx (HCEEFILE ceeFile, IMetaDataEmit *emitter);
    virtual HRESULT GetIMapTokenIfaceEx(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken);

    virtual HRESULT EmitMacroDefinitions(HCEEFILE ceeFile, void *pData, DWORD cData);
    virtual HRESULT CreateCeeFileFromICeeGen(ICeeGen *pFromICeeGen, HCEEFILE *ceeFile); // call this to instantiate

    virtual HRESULT SetManifestEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);

    virtual HRESULT SetEnCRVABase(HCEEFILE ceeFile, ULONG dataBase, ULONG rdataBase);
    virtual HRESULT GenerateCeeMemoryImage (HCEEFILE ceeFile, void **ppImage);

	virtual HRESULT ComputeSectionOffset(HCEESECTION section, char *ptr,
										 unsigned *offset);

	virtual HRESULT ComputeOffset(HCEEFILE file, char *ptr,
								  HCEESECTION *pSection, unsigned *offset);

	virtual HRESULT GetCorHeader(HCEEFILE ceeFile, 
								 IMAGE_COR20_HEADER **header);

    virtual HRESULT LinkCeeFile (HCEEFILE ceeFile);
    virtual HRESULT FixupCeeFile (HCEEFILE ceeFile);

    virtual HRESULT GetSectionRVA (HCEESECTION section, ULONG *rva);

	virtual HRESULT ComputeSectionPointer(HCEESECTION section, ULONG offset,
										  char **ptr);

    virtual HRESULT SetObjSwitch (HCEEFILE ceeFile, BOOL objSwitch);
    virtual HRESULT GetObjSwitch (HCEEFILE ceeFile, BOOL *objSwitch);
    virtual HRESULT SetVTableEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);

    virtual HRESULT SetStrongNameEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);

		// Emit the data.  If 'section != 0, it will put the data in 'buffer'.  This
		// buffer is assumed to be in 'section' at 'offset' and of size 'buffLen'
		// (should use GetSaveSize to insure that buffer is big enough
    virtual HRESULT EmitMetaDataAt (HCEEFILE ceeFile, IMetaDataEmit *emitter, HCEESECTION section, DWORD offset, BYTE* buffer, unsigned buffLen);

    virtual HRESULT GetFileTimeStamp (HCEEFILE ceeFile, time_t *pTimeStamp);

    // Add a notification handler. If it implements an interface that
    // the ICeeFileGen understands, S_OK is returned. Otherwise,
    // E_NOINTERFACE.
    virtual HRESULT AddNotificationHandler(HCEEFILE ceeFile,
                                           IUnknown *pHandler);

    virtual HRESULT SetFileAlignment(HCEEFILE ceeFile, ULONG fileAlignment);

    virtual HRESULT ClearComImageFlags (HCEEFILE ceeFile, DWORD mask);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\iappdomainsetup.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// ********************************************************
// ********************************************************
// ********************************************************
//
// !!!! DON'T USE THIS FILE, IT WILL BE OBSOLETE SOON !!!!
//
// ********************************************************
// ********************************************************
// ********************************************************







#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* at Wed Jan 17 16:59:41 2001
 */
/* Compiler settings for IAppDomainSetup.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __IAppDomainSetup_h__
#define __IAppDomainSetup_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAppDomainSetup_FWD_DEFINED__
#define __IAppDomainSetup_FWD_DEFINED__
typedef interface IAppDomainSetup IAppDomainSetup;
#endif 	/* __IAppDomainSetup_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IAppDomainSetup_INTERFACE_DEFINED__
#define __IAppDomainSetup_INTERFACE_DEFINED__

/* interface IAppDomainSetup */
/* [object][oleautomation][version][uuid] */ 


EXTERN_C const IID IID_IAppDomainSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27FFF232-A7A8-40DD-8D4A-734AD59FCD41")
    IAppDomainSetup : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT __stdcall get_ApplicationBase( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_ApplicationBase( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_ApplicationName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_ApplicationName( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_CachePath( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_CachePath( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_ConfigurationFile( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_ConfigurationFile( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_DynamicBase( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_DynamicBase( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_LicenseFile( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_LicenseFile( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_PrivateBinPath( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_PrivateBinPath( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_PrivateBinPathProbe( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_PrivateBinPathProbe( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_ShadowCopyDirectories( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_ShadowCopyDirectories( 
            /* [in] */ BSTR pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT __stdcall get_ShadowCopyFiles( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [propput] */ HRESULT __stdcall put_ShadowCopyFiles( 
            /* [in] */ BSTR pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppDomainSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppDomainSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppDomainSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppDomainSetup * This);
        
        /* [propget] */ HRESULT ( __stdcall *get_ApplicationBase )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_ApplicationBase )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_ApplicationName )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_ApplicationName )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_CachePath )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_CachePath )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_ConfigurationFile )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_ConfigurationFile )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_DynamicBase )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_DynamicBase )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_LicenseFile )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_LicenseFile )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_PrivateBinPath )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_PrivateBinPath )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_PrivateBinPathProbe )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_PrivateBinPathProbe )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_ShadowCopyDirectories )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_ShadowCopyDirectories )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        /* [propget] */ HRESULT ( __stdcall *get_ShadowCopyFiles )( 
            IAppDomainSetup * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [propput] */ HRESULT ( __stdcall *put_ShadowCopyFiles )( 
            IAppDomainSetup * This,
            /* [in] */ BSTR pRetVal);
        
        END_INTERFACE
    } IAppDomainSetupVtbl;

    interface IAppDomainSetup
    {
        CONST_VTBL struct IAppDomainSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppDomainSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppDomainSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppDomainSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppDomainSetup_get_ApplicationBase(This,pRetVal)	\
    (This)->lpVtbl -> get_ApplicationBase(This,pRetVal)

#define IAppDomainSetup_put_ApplicationBase(This,pRetVal)	\
    (This)->lpVtbl -> put_ApplicationBase(This,pRetVal)

#define IAppDomainSetup_get_ApplicationName(This,pRetVal)	\
    (This)->lpVtbl -> get_ApplicationName(This,pRetVal)

#define IAppDomainSetup_put_ApplicationName(This,pRetVal)	\
    (This)->lpVtbl -> put_ApplicationName(This,pRetVal)

#define IAppDomainSetup_get_CachePath(This,pRetVal)	\
    (This)->lpVtbl -> get_CachePath(This,pRetVal)

#define IAppDomainSetup_put_CachePath(This,pRetVal)	\
    (This)->lpVtbl -> put_CachePath(This,pRetVal)

#define IAppDomainSetup_get_ConfigurationFile(This,pRetVal)	\
    (This)->lpVtbl -> get_ConfigurationFile(This,pRetVal)

#define IAppDomainSetup_put_ConfigurationFile(This,pRetVal)	\
    (This)->lpVtbl -> put_ConfigurationFile(This,pRetVal)

#define IAppDomainSetup_get_DynamicBase(This,pRetVal)	\
    (This)->lpVtbl -> get_DynamicBase(This,pRetVal)

#define IAppDomainSetup_put_DynamicBase(This,pRetVal)	\
    (This)->lpVtbl -> put_DynamicBase(This,pRetVal)

#define IAppDomainSetup_get_LicenseFile(This,pRetVal)	\
    (This)->lpVtbl -> get_LicenseFile(This,pRetVal)

#define IAppDomainSetup_put_LicenseFile(This,pRetVal)	\
    (This)->lpVtbl -> put_LicenseFile(This,pRetVal)

#define IAppDomainSetup_get_PrivateBinPath(This,pRetVal)	\
    (This)->lpVtbl -> get_PrivateBinPath(This,pRetVal)

#define IAppDomainSetup_put_PrivateBinPath(This,pRetVal)	\
    (This)->lpVtbl -> put_PrivateBinPath(This,pRetVal)

#define IAppDomainSetup_get_PrivateBinPathProbe(This,pRetVal)	\
    (This)->lpVtbl -> get_PrivateBinPathProbe(This,pRetVal)

#define IAppDomainSetup_put_PrivateBinPathProbe(This,pRetVal)	\
    (This)->lpVtbl -> put_PrivateBinPathProbe(This,pRetVal)

#define IAppDomainSetup_get_ShadowCopyDirectories(This,pRetVal)	\
    (This)->lpVtbl -> get_ShadowCopyDirectories(This,pRetVal)

#define IAppDomainSetup_put_ShadowCopyDirectories(This,pRetVal)	\
    (This)->lpVtbl -> put_ShadowCopyDirectories(This,pRetVal)

#define IAppDomainSetup_get_ShadowCopyFiles(This,pRetVal)	\
    (This)->lpVtbl -> get_ShadowCopyFiles(This,pRetVal)

#define IAppDomainSetup_put_ShadowCopyFiles(This,pRetVal)	\
    (This)->lpVtbl -> put_ShadowCopyFiles(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_ApplicationBase_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_ApplicationBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_ApplicationBase_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_ApplicationBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_ApplicationName_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_ApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_ApplicationName_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_ApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_CachePath_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_CachePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_CachePath_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_CachePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_ConfigurationFile_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_ConfigurationFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_ConfigurationFile_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_ConfigurationFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_DynamicBase_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_DynamicBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_DynamicBase_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_DynamicBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_LicenseFile_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_LicenseFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_LicenseFile_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_LicenseFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_PrivateBinPath_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_PrivateBinPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_PrivateBinPath_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_PrivateBinPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_PrivateBinPathProbe_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_PrivateBinPathProbe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_PrivateBinPathProbe_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_PrivateBinPathProbe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_ShadowCopyDirectories_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_ShadowCopyDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_ShadowCopyDirectories_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_ShadowCopyDirectories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT __stdcall IAppDomainSetup_get_ShadowCopyFiles_Proxy( 
    IAppDomainSetup * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IAppDomainSetup_get_ShadowCopyFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT __stdcall IAppDomainSetup_put_ShadowCopyFiles_Proxy( 
    IAppDomainSetup * This,
    /* [in] */ BSTR pRetVal);


void __RPC_STUB IAppDomainSetup_put_ShadowCopyFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppDomainSetup_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\holder.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// Various resource Holders 
//
// General idea is to have a templatized class who's ctor and dtor call
// allocation management functions. This makes the holders type-safe, and
// the compiler can inline most/all of the holder code.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Smart Pointer
//-----------------------------------------------------------------------------
template <class TYPE>
class ComWrap
{
  private:
    TYPE *m_value;
  public:
    ComWrap<TYPE>() : m_value(NULL) {}
    ComWrap<TYPE>(TYPE *value) : m_value(value) {}
    ~ComWrap<TYPE>() { if (m_value != NULL) m_value->Release(); }
    operator TYPE*() { return m_value; }
    TYPE** operator&() { return &m_value; }
    void operator=(TYPE *value) { m_value = value; }
    int operator==(TYPE *value) { return value == m_value; }
    int operator!=(TYPE *value) { return value != m_value; }
    TYPE* operator->() { return m_value; }
    const TYPE* operator->() const { return m_value; }
    void Release() { if (m_value != NULL) m_value->Release(); m_value = NULL; }
};

//-----------------------------------------------------------------------------
// wrap new & delete
//-----------------------------------------------------------------------------
template <class TYPE>
class NewWrap
{
  private:
    TYPE *m_value;
  public:
    NewWrap<TYPE>() : m_value(NULL) {}
    NewWrap<TYPE>(TYPE *value) : m_value(value) {}
    ~NewWrap<TYPE>() { if (m_value != NULL) delete m_value; }
    operator TYPE*() { return m_value; }
    TYPE** operator&() { return &m_value; }
    void operator=(TYPE *value) { m_value = value; }
    int operator==(TYPE *value) { return value == m_value; }
    int operator!=(TYPE *value) { return value != m_value; }
    TYPE* operator->() { return m_value; }
    const TYPE* operator->() const { return m_value; }
};

//-----------------------------------------------------------------------------
// wrap new[] & delete []
//-----------------------------------------------------------------------------
template <class TYPE>
class NewArrayWrap
{
  private:
    TYPE *m_value;
  public:
    NewArrayWrap<TYPE>() : m_value(NULL) {}
    NewArrayWrap<TYPE>(TYPE *value) : m_value(value) {}
    ~NewArrayWrap<TYPE>() { if (m_value != NULL) delete [] m_value; }
    operator TYPE*() { return m_value; }
    TYPE** operator&() { return &m_value; }
    void operator=(TYPE *value) { m_value = value; }
    int operator==(TYPE *value) { return value == m_value; }
    int operator!=(TYPE *value) { return value != m_value; }
};

//-----------------------------------------------------------------------------
// Wrap win32 functions using HANDLE
//-----------------------------------------------------------------------------
template <BOOL (*CLOSE)(HANDLE)>
class HWrap
{
  private:
    HANDLE m_value;
  public:
    HWrap() : m_value(INVALID_HANDLE_VALUE) {}
    HWrap(HANDLE h) : m_value(h) {}
    ~HWrap() { if (m_value != INVALID_HANDLE_VALUE) CLOSE(m_value); }
    operator HANDLE() { return m_value; }
    HANDLE *operator&() { return &m_value; }
    void operator=(HANDLE value) { m_value = value; }
    int operator==(HANDLE value) { return value == m_value; }
    int operator!=(HANDLE value) { return value != m_value; }
    void Close() { if (m_value != INVALID_HANDLE_VALUE) CLOSE(m_value); m_value = INVALID_HANDLE_VALUE; }
};

typedef HWrap<CloseHandle> HandleWrap;
typedef HWrap<FindClose> FindHandleWrap;

//-----------------------------------------------------------------------------
// Wrapper, dtor calls a non-member function to cleanup
//----------------------------------------------------------------------------- 
template <class TYPE, void (*DESTROY)(TYPE), TYPE NULLVALUE>
class Wrap
{
  private:
    TYPE m_value;
  public:
    Wrap<TYPE, DESTROY, NULLVALUE>() : m_value(NULLVALUE) {}
    Wrap<TYPE, DESTROY, NULLVALUE>(TYPE value) : m_value(value) {}

    ~Wrap<TYPE, DESTROY, NULLVALUE>() 
    { 
        if (m_value != NULLVALUE) 
            DESTROY(m_value);
    }

    operator TYPE() { return m_value; }
    TYPE* operator&() { return &m_value; }
    void operator=(TYPE value) { m_value = value; }
    int operator==(TYPE value) { return value == m_value; }
    int operator!=(TYPE value) { return value != m_value; }
};


//-----------------------------------------------------------------------------
// Wrapper. Dtor calls a member function for exit
//-----------------------------------------------------------------------------
template <class TYPE>
class ExitWrap
{
public:
    typedef void (TYPE::*FUNCPTR)(void);

    template<FUNCPTR funcExit>
    class Funcs
    {
        TYPE *m_ptr;
    public:
        inline Funcs(TYPE * ptr) : m_ptr(ptr) {  }; 
        inline ~Funcs () { (m_ptr->*funcExit)(); }
    };
};
 

#define EXIT_HOLDER_CLASS(c, f) ExitWrap<c>::Funcs<&c::f>


//-----------------------------------------------------------------------------
// Wrapper, ctor calls an member-function on enter, dtor calls a 
// member-function on exit.
//-----------------------------------------------------------------------------
template <class TYPE>
class EnterExitWrap
{
public:
    typedef void (TYPE::*FUNCPTR)(void);

    template<FUNCPTR funcEnter, FUNCPTR funcExit>
    class Funcs
    {
        TYPE *m_ptr;
    public:
        inline Funcs(TYPE * ptr) : m_ptr(ptr) { (m_ptr->*funcEnter)(); }; 
        inline ~Funcs () { (m_ptr->*funcExit)(); }
    };
};

#define ENTEREXIT_HOLDER_CLASS(c, fEnter, fExit) EnterExitWrap<c>::Funcs<&c::fEnter, &c::fExit>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\icmprecs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************************
 **                                                                                  **
 ** ICmpRecs.h - this file is used to give direct access to the storage engine.      **
 **              It bypasses the OLE DB layer.                                       **
 **                                                                                  **
 **************************************************************************************/


#pragma once

#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
enum CorSaveSize
{
	cssAccurate = 0x0000,			// Find exact save size, accurate but slower.
	cssQuick = 0x0001				// Estimate save size, may pad estimate, but faster.
};
#endif

#include <basetsd.h>	 // BUGBUG VC6.0 hack

//********** Types ************************************************************
extern const GUID __declspec(selectany) IID_IComponentRecords =
{ 0x259a8e8, 0xcf25, 0x11d1, { 0x8c, 0xcf, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0xf8 } };

extern const GUID __declspec(selectany) IID_ITSComponentRecords =
{ 0x22ad41d1, 0xd96a, 0x11d1, { 0x88, 0xc1, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };

extern const GUID __declspec(selectany) IID_IComponentRecordsSchema =
{ 0x58769c81, 0xa8cc, 0x11d1, { 0x88, 0x46, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };

extern const GUID __declspec(selectany) IID_ITSComponentRecordsSchema =
{ 0x22ad41d2, 0xd96a, 0x11d1, { 0x88, 0xc1, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


extern const GUID __declspec(selectany) IID_ICallDescrSection =
{ 0x2b137007, 0xf02d, 0x11d1, { 0x8c, 0xe3, 0x0, 0xa0, 0xc9, 0xb0, 0xa0, 0x63 } };


// These data types are basically castable place holders for non-engine code.
#if !defined(__MSCORCLB_CODE__) && !defined(_STGAPI_H_)
class CRCURSOR
{
	char b[32];
};
class RECORDLIST;
#endif


//*****************************************************************************
// Use the following to give a hint to QueryRowsByColumns.	When passed in, the
// query code will use the index given to do the query.  If a hint is not given,
// then no index is used.  While index choosing code is in the driver (for OLE
// DB clients), internal engine use will be faster if the index is indentified
// up front.
//*****************************************************************************

#define QUERYHINT_PK_MULTICOLUMN	0xffffffff // A multiple column primary key.

enum QUERYHINTTYPE
{
	QH_COLUMN,							// Hint is a RID or primary key column.
	QH_INDEX							// Use the index given.
};

struct QUERYHINT
{
	QUERYHINTTYPE	iType;				// What type of hint to use.
	union
	{
		ULONG		columnid;			// Which column contains the hint.
		const char	*szIndex;			// Name of index.
	};
};


//*****************************************************************************
// Support for IComponentRecordsSchema, which can be used to get the definition
// of a table, its columns, and indexes.
//*****************************************************************************
#ifndef __ICR_SCHEMA__
#define __ICR_SCHEMA__

#ifndef __COMPLIB_NAME_LENGTHS__
#define __COMPLIB_NAME_LENGTHS__
const int MAXCOLNAME = 32;
const int MAXSCHEMANAME = 32;
const int MAXINDEXNAME = 32 + MAXSCHEMANAME;
const int MAXTABLENAME = 32 + MAXSCHEMANAME;
const int MAXDESC = 256;
const int MAXTYPENAME = 36;
#endif


// Each table is described as follows.
struct ICRSCHEMA_TABLE
{
	WCHAR		rcTable[MAXTABLENAME];	// Name of the table.
	ULONG		fFlags; 				// ICRSCHEMA_TBL_xxx flags.
	USHORT		Columns;				// How many columns are in the table.
	USHORT		Indexes;				// How many indexes are in the table.
	USHORT		RecordStart;			// Start offset for a RID column.
	USHORT		Pad;
};

#define ICRSCHEMA_TBL_TEMPORARY 	0x00000001	// Table is temporary.
#define ICRSCHEMA_TBL_HASPKEYCOL	0x00000008	// Table has a primary key.
#define ICRSCHEMA_TBL_HASRIDCOL 	0x00000010	// Table has a RID column.
#define ICRSCHEMA_TBL_MASK			0x00000019

// Each column is described by the following structure.
struct ICRSCHEMA_COLUMN
{
	WCHAR		rcColumn[MAXCOLNAME];	// Name of the column.
	DBTYPE		wType;					// Type of column.
	USHORT		Ordinal;				// Ordinal of this column.
	ULONG		fFlags; 				// ICRSCHEMA_COL_xxx flags
	ULONG		cbSize; 				// Maximum size a column can be.
};

#define ICRSCHEMA_COL_NULLABLE		0x00000001	// Column allows the NULL value.
#define ICRSCHEMA_COL_PK			0x00000004	// Primary key column.
#define ICRSCHEMA_COL_ROWID 		0x00000008	// Column is the record id for table.
#define ICRSCHEMA_COL_FIXEDLEN		0x00001000	// Column is fixed length.
#define ICRSCHEMA_COL_MASK			0x0000100D


// Each index can be retrieved using this structure.  The Keys field conains
// the size of the rgKeys array on input, and on output contains the total
// number of keys on the index.  If the size is larger on return then going
// in, the array was not large enough.	Simply call again wtih an array of
// the correct size to get the total list.
struct ICRSCHEMA_INDEX
{
	WCHAR		rcIndex[MAXINDEXNAME];	// Name of the index.
	ULONG		fFlags; 				// Flags describing the index.
	USHORT		RowThreshold;			// Minimum rows required before index is built.
	USHORT		IndexOrdinal;			// Ordinal of the index.
	USHORT		Type;					// What type of index is this.
	USHORT		Keys;					// [In] Max size of rgKeys, [Out] Total keys there are
	USHORT		*rgKeys;				// Array of key values to fill out.
};

enum
{
	ICRSCHEMA_TYPE_HASHED			= 0x01, 	// Hashed index.
	ICRSCHEMA_TYPE_SORTED			= 0x02		// Sorted index.
};

#define ICRSCHEMA_DEX_UNIQUE		0x00000002	// Unique index.
#define ICRSCHEMA_DEX_PK			0x00000004	// Primary key.
#define ICRSCHEMA_DEX_MASK			0x00000006	// Mask.


// Used for GetColumnDefinitions.
enum ICRCOLUMN_GET
{
	ICRCOLUMN_GET_ALL,					// Retrieve every column.
	ICRCOLUMN_GET_BYORDINAL 			// Retrieve according to ordinal.
};

#endif // __ICR_SCHEMA__


//*****************************************************************************
// Flags for record creation.
//*****************************************************************************
#define ICR_RECORD_NORMAL	0x00000000			// Normal, persisted record (default).
#define ICR_RECORD_TEMP		0x00000001			// Record is transient.




//********** Macros ***********************************************************

//*****************************************************************************
// Helper macros for Set/GetColumns, Set/GetStruct.
//*****************************************************************************
#ifndef __ColumnBitMacros__
#define __ColumnBitMacros__
#define CheckColumnBit(flags, x)	(flags & (1 << x))
#define SetColumnBit(x) 			(1 << x)
#define UnsetColumnBit(x)			(~(1 << x))

#define COLUMN_ORDINAL_MASK			0x80000000
#define COLUMN_ORDINAL_LIST(x)		(COLUMN_ORDINAL_MASK | x)
inline int IsOrdinalList(ULONG i)
{
	return ((COLUMN_ORDINAL_MASK & i) == COLUMN_ORDINAL_MASK);
}
#endif

inline ULONG SetBit(ULONG &val, int iBit, int bSet)
{
	if (bSet)
		val |= (1 << iBit);
	else
		val &= ~(1 << iBit);
	return (val);
}

inline ULONG GetBit(ULONG val, int iBit)
{
	return (val & (1 << iBit));
}

#ifdef _M_ALPHA
#define DEFAULT_ALIGNMENT			8
#else
#define DEFAULT_ALIGNMENT			4
#endif
#define DFT_MAX_VARCOL				260

#define MAXSHMEM					32

//*****************************************************************************
// This interface is access special data from a record (ie: data that could
// be variable sized or otherwise changed).
//*****************************************************************************
interface IComponentRecords : public IUnknown
{

//*****************************************************************************
//
//********** Record creation functions.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE NewRecord( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column, 0 means none.
		ULONG		*pRecordID) = 0;		// Optionally return the record id.

	virtual HRESULT STDMETHODCALLTYPE NewTempRecord( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) = 0;		// Optionally return the record id.

//*****************************************************************************
// This function will insert a new record into the given table and set all of
// the data for the columns.  In cases where a primary key and/or unique indexes
// need to be specified, this is the only function that can be used.
//
// Please see the SetColumns function for a description of the rest of the
// parameters to this function.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE NewRecordAndData( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		ULONG		*pRecordID, 			// Optionally return the record id.
		int			fFlags,					// ICR_RECORD_xxx value, 0 default.
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns



//*****************************************************************************
//
//********** Full struct functions.  The SchemaGen tool will generate a
//				structure for a table that matches the full layout.  Use these
//				structures with the following functions to do very fast get, set,
//				and inserts of data without binding information.
//
//*****************************************************************************

//**************************************************************************************
// GetStruct
//		Retrieve the fields specified by fFieldMask, for the array of iRows row pointers
//		of size cbRowStruct and place it into the memory chunk pointed to by rgpbBuf.
//		rgResult[] is any array of the HRESULTs for each row if the user is interested in
//		knowing.
//		The function will bail out on the first error. In this case it is the
//		responsibility of the user to walk through the rgResults[] array to figure out
//		when the error happened. Warnings generated by the lower level functions are placed
//		rgResults[] array, but the function continues with the next row.
//
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetStruct(	//Return Code
		TABLEID 	tableid,				// Which table to work on.
		int 		iRows,					// number of rows for bulk fetch.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS structure.
		void		*rgpbBuf,				// pointer to the chunk of memory where the
											// retrieved data will be placed.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask) = 0;		// mask to specify a subset of fields.

//**************************************************************************************
// SetStruct:
//		given an array of iRows row pointers, set the data the user provided in the
//		specified fields of the row. cbRowStruct has been provided
//		to be able to embed the RowStruct (as defined by pagedump) in a user defined structure.
//		fNullFieldMask specifies fields that the user wants to set to NULL.
//		The user provides rgResult[] array if interested in the outcome of each row.
//
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetStruct(	// Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) = 0;	// fields which need to be set to null.

//**************************************************************************************
// InsertStruct:
//		Creates new records first and then calls SetStruct.
//		See SetStruct() for details on the parameters.
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE InsertStruct( // Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// Return pointer to new values.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) = 0;	// fields which need to be set to null.



//*****************************************************************************
//
//********** Generic column get and set functions.	Provides fast get and set
//				speed for many columns in your own layout.
//
//*****************************************************************************

//*****************************************************************************
// Similar to GetStruct(), this function retrieves the specified columns 
// of 1 record pointer. The major difference between GetColumns() and 
// GetStruct() is that GetColumns() let's the caller specify a individual 
// buffer for each field. Hence, the caller does not have to allocate the row 
// structure like you would with GetStruct(). Refer to the GetStruct() header 
// for details on the parameters.
//
// fFieldMask can be one of two types.  If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF may be given for the data type on the get.	In this case, 
// rgpbBuf will the address of an array of void * pointers that will be filled
// out with pointers to the actual data for the column.  These pointers point
// to the internal data structures of the engine and must never be written to.
// If the column was null, then the pointer value will be set to NULL.	Finally,
// the pcbBuf entry for the column contains the length of the data pointed to
// by rgpbBuf.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		const void	*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		ULONG		cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns

//*****************************************************************************
// Similar to SetStruct(), this function puts the specified columns of 1 record
// pointer. The major difference between SetColumns() and SetStruct() is that 
// SetColumns() let's the caller specify a individual buffer for each field. 
// Hence, the caller does not have to allocate the row structure like you would 
// with SetStruct(). Refer to the SetStruct() hearder for details on the 
// parameters.
//
// fFieldMask can be one of two types.  If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF is not allowed by this function since this function must 
// always make a copy of the data for it to be saved to disk with the database.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		void		*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] CLDB_S_NULL array [out] HRESULT array.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns




//*****************************************************************************
//
//********** Query functions.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE GetRecordCount( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		ULONG		*piCount) = 0;			// Not including deletes.

	virtual HRESULT STDMETHODCALLTYPE GetRowByOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		OID 		_oid,					// Value for keyed lookup.
		ULONG		iColumn,				// 1 based column number (logical).
		void		**ppStruct) = 0;		// Return pointer to record.

	virtual HRESULT STDMETHODCALLTYPE GetRowByRID( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid,					// Record id.
		void		**ppStruct) = 0;		// Return pointer to record.

	virtual HRESULT STDMETHODCALLTYPE GetRIDForRow( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// The record we want RID for.
		ULONG		*pirid) = 0;			// Return the RID for the given row.

	virtual HRESULT STDMETHODCALLTYPE GetRowByColumn( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG 		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		RECORDLIST	*pRecords,				// If variable rows desired.
		int 		*piFetched) = 0;		// How many records were fetched.

//*****************************************************************************
// This query function allows you to do lookups on one or more column at a
// time.  It does not expose the full OLE DB view-filter mechanism which is
// very flexible, but rather exposes multiple column AND conditions with
// equality.  A record must match all of the criteria to be returned to
// in the cursor.
//
// User data - For each column, rgiColumn, rgpbData, and rgiType contain the
//		pointer information to the user data to filter on.
//
// Query hints - Queries will run faster if it is known that some of the
//		columns are indexed.  While there is code in the engine to scan query
//		lists for target indexes, this internal function bypasses that code in
//		favor of performance.  If you know that a column is a RID or PK, or that
//		there is an index, then these columns need to be the first set passed
//		in.  Fill out a QUERYHINT and pass this value in.  Pass NULL if you
//		know there is no index information, and the table will be scanned.
//
//		Note that you may follow indexes columns with non-indexed columns,
//		in which case all records in the index are found first, and then those
//		are scanned for the rest of the criteria.
//
// Returned cursor - Data may be returned in two mutually exclusive ways:
//		(1) Pass an array of record pointers in rgRecords and set iMaxRecords
//			to the count of this array.  Only that many rows are brought back.
//			This requires to heap allocations and is good for cases where you
//			can predict cardinality up front.
//		(2) Pass the address of a CRCURSOR to get a dynamic list.  Then use
//			the cursor functions on this interface to fetch data and close
//			the cursor.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE QueryByColumns( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		const QUERYHINT *pQryHint,			// What index to use, NULL valid.
		int 		iColumns,				// How many columns to query on.
		const ULONG rgiColumn[],			// 1 based column numbers.
		const DBCOMPAREOP rgfCompare[], 	// Comparison operators, NULL means ==.
		const void	*rgpbData[],			// User data.
		const ULONG rgcbData[], 			// Size of data (blobs)
		const DBTYPE rgiType[], 			// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		CRCURSOR	*psCursor,				// Buffer for the cursor handle.
		int 		*piFetched) = 0;		// How many records were fetched.

	virtual HRESULT STDMETHODCALLTYPE OpenCursorByColumn( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		CRCURSOR	*psCursor) = 0; 		// Buffer for the cursor handle.



//*****************************************************************************
//
//********** Cursor manipulation functions.
//
//*****************************************************************************


//*****************************************************************************
// Reads the next set of records from the cursor into the given buffer.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE ReadCursor(// Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		void		*rgRecords[],			// Return array of records here.
		int 		*piRecords) = 0;		// Max that will fit in rgRecords.

//*****************************************************************************
// Move the cursor location to the index given.  The next ReadCursor will start
// fetching records at that index.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE MoveTo( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		iIndex) = 0;			// New index.

//*****************************************************************************
// Get the count of items in the cursor.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetCount( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		*piCount) = 0;			// Return the count.

//*****************************************************************************
// Close the cursor and clean up the resources we've allocated.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE CloseCursor(// Return code.
		CRCURSOR	*psCursor) = 0; 		// The cursor handle.



//*****************************************************************************
//
//********** Singleton get and put functions for heaped data types.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE GetStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPCSTR		*pszOutBuffer) = 0; 	// Where put string pointer.

	virtual HRESULT STDMETHODCALLTYPE GetStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) = 0;		// Size of string is put here.

	virtual HRESULT STDMETHODCALLTYPE GetStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPWSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) = 0;		// Size of string is put here.

	virtual HRESULT STDMETHODCALLTYPE GetBstr( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BSTR		*pBstr) = 0;			// Output for bstring on success.

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BYTE		*pOutBuffer,			// Where to write blob.
		ULONG		cbOutBuffer,			// Size of output buffer.
		ULONG		*pcbOutBuffer) = 0; 	// Return amount of data available.

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const BYTE	**ppBlob,				// Pointer to blob.
		ULONG		*pcbSize) = 0;			// Size of blob.

	virtual HRESULT STDMETHODCALLTYPE GetOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		OID 		*poid) = 0; 			// Return id here.

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARIANT 	*pValue) = 0;			// The variant to write.

	// Retrieve a variant column that contains a blob.
	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const void	**ppBlob,				// Put pointer to blob here.
		ULONG		*pcbSize) = 0;			// Put Size of blob.

	virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARTYPE 	*pType) = 0;			// Put variant type here.

	virtual HRESULT STDMETHODCALLTYPE GetGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		GUID		*pGuid) = 0;			// Return guid here.

	virtual HRESULT STDMETHODCALLTYPE IsNull( // S_OK yes, S_FALSE no.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// Record with data.
		ULONG		iColumn) = 0;			// 1 based column number (logical).

	virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCWSTR 	szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes (not characters) in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const BYTE	*pBuffer,				// User data.
		ULONG		cbBuffer) = 0;			// Size of buffer.

	virtual HRESULT STDMETHODCALLTYPE PutOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		OID 		oid) = 0;				// Return id here.

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const VARIANT *pValue) = 0; 		// The variant to write.

	// Store a blob in a variant column.
	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const void	*pBuffer,				// User data.
		ULONG		cbBuffer) = 0;			// Size of buffer.

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		VARTYPE 	vt, 					// Type of data.
		const void	*pValue) = 0;			// The actual data.

	virtual HRESULT STDMETHODCALLTYPE PutGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		REFGUID 	guid) = 0;				// Guid to put.

	virtual void STDMETHODCALLTYPE SetNull(
		TABLEID 	tableid,				// Which table to work with.
		void		*pRecord,				// Record with data.
		ULONG		iColumn) = 0;			// 1 based column number (logical).

	virtual HRESULT STDMETHODCALLTYPE DeleteRowByRID(
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid) = 0;				// Record id.

	virtual HRESULT STDMETHODCALLTYPE GetCPVARIANT( // Return code.
		USHORT		ixCP,					// 1 based Constant Pool index.
		VARIANT 	*pValue) = 0;			// Put the data here.

	virtual HRESULT STDMETHODCALLTYPE AddCPVARIANT( // Return code.
		VARIANT 	*pValue,				// The variant to write.
		ULONG		*pixCP) = 0;			// Put 1 based Constant Pool index here.


//*****************************************************************************
//
//********** Schema functions.
//
//*****************************************************************************


//*****************************************************************************
// Add a refernece to the given schema to the database we have open right now
// You must have the database opened for write for this to work.  If this
// schema extends another schema, then that schema must have been added first
// or an error will occur.	It is not an error to add a schema when it was
// already in the database.
//
// Adding a new version of a schema to the current file is not supported in the
// '98 product.  In the future this ability will be added and will invovle a
// forced migration of the current file into the new format.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaAdd( // Return code.
		const COMPLIBSCHEMABLOB *pSchema) = 0;	// The schema to add.

//*****************************************************************************
// Deletes a reference to a schema from the database.  You must have opened the
// database in write mode for this to work.  An error is returned if another
// schema still exists in the file which extends the schema you are trying to
// remove.	To fix this problem remove any schemas which extend you first.
// All of the table data associated with this schema will be purged from the
// database on Save, so use this function very carefully.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaDelete( // Return code.
		const COMPLIBSCHEMABLOB *pSchema) = 0;	// The schema to add.

//*****************************************************************************
// Returns the list of schema references in the current database.  Only
// iMaxSchemas can be returned to the caller.  *piTotal tells how many were
// actually copied.  If all references schemas were returned in the space
// given, then S_OK is returned.  If there were more to return, S_FALSE is
// returned and *piTotal contains the total number of entries the database has.
// The caller may then make the array of that size and call the function again
// to get all of the entries.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaGetList( // S_OK, S_FALSE, or error.
		int 		iMaxSchemas,			// How many can rgSchema handle.
		int 		*piTotal,				// Return how many we found.
		COMPLIBSCHEMADESC rgSchema[]) = 0;	// Return list here.

//*****************************************************************************
// Before you can work with a table, you must retrieve its TABLEID.  The
// TABLEID changes for each open of the database.  The ID should be retrieved
// only once per open, there is no check for a double open of a table.
// Doing multiple opens will cause unpredictable results.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE OpenTable( // Return code.
		const COMPLIBSCHEMA *pSchema,		// Schema identifier.
		ULONG		iTableNum,				// Table number to open.
		TABLEID 	*pTableID) = 0; 		// Return ID on successful open.


//*****************************************************************************
//
//********** Save/open functions.
//
//*****************************************************************************

//*****************************************************************************
// Figures out how big the persisted version of the current scope would be.
// This is used by the linker to save room in the PE file format.  After
// calling this function, you may only call the SaveToStream or Save method.
// Any other function will product unpredictable results.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		CorSaveSize fSave,					// cssQuick or cssAccurate.
		DWORD		*pdwSaveSize) = 0;		// Return size of saved item.

	virtual HRESULT STDMETHODCALLTYPE SaveToStream(// Return code.
		IStream 	*pIStream) = 0; 		// Where to save the data.

	virtual HRESULT STDMETHODCALLTYPE Save( // Return code.
		LPCWSTR 	szFile) = 0;			// Path for save.


//*****************************************************************************
// After a successful open, this function will return the size of the in-memory
// database being used.  This is meant to be used by code that has opened a
// shared memory database and needs the exact size to init the system.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetDBSize( // Return code.
		ULONG		*pcbSize) = 0;			// Return size on success.


//*****************************************************************************
// Call this method only after calling LightWeightClose.  This method will try
// to reaquire the shared view of a database that was given on the call to
// OpenComponentLibrarySharedEx.  If the data is no longer available, then an
// error will result and no data is valid.	If the memory cannot be loaded into
// exactly the same address range as on the open, CLDB_E_RELOCATED will be
// returned.  In either of these cases, the only valid operation is to free
// this instant of the database and redo the OpenComponentLibrarySharedEx.	There
// is no automatic relocation scheme in the engine.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE LightWeightOpen() = 0;


//*****************************************************************************
// This method will close any resources related to the file or shared memory
// which were allocated on the OpenComponentLibrary*Ex call.  No other memory
// or resources are freed.	The intent is solely to free lock handles on the
// disk allowing another process to get in and change the data.  The shared
// view of the file can be reopened by calling LightWeightOpen.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE LightWeightClose() = 0;



//*****************************************************************************
//
//********** Misc.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE NewOid(
		OID *poid) = 0;

//*****************************************************************************
// Return the current total number of objects allocated.  This is essentially
// the highest OID value allocated in the system.  It does not look for deleted
// items, so the count is approximate.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetObjectCount(
		ULONG		*piCount) = 0;

//*****************************************************************************
// Allow the user to create a stream that is independent of the database.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE OpenSection(
		LPCWSTR 	szName, 				// Name of the stream.
		DWORD		dwFlags,				// Open flags.
		REFIID		riid,					// Interface to the stream.
		IUnknown	**ppUnk) = 0;			// Put the interface here.

//*****************************************************************************
// Allow the user to query write state.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetOpenFlags(
		DWORD		*pdwFlags) = 0;

//*****************************************************************************
// Allow the user to provide a custom handler.  The purpose of the handler
//  may be determined dynamically.  Initially, it will be for save-time 
//  callback notification to the caller.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetHandler(
		IUnknown	*pHandler) = 0;			// The handler.



};



//*****************************************************************************
// This is a light weight interface that allows an ICR client to get at the
// meta data for a schema.	One can also retrieve this information using the
// format OLE DB interfaces, such as IDBSchemaRowset.
//*****************************************************************************
interface IComponentRecordsSchema : public IUnknown
{

//*****************************************************************************
// Lookup the given table and return its table definition information in
// the given struct.
//*****************************************************************************
	virtual HRESULT GetTableDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_TABLE *pTableDef) = 0;	// Return table definition data.

//*****************************************************************************
// Lookup the list of columns for the given table and return description of
// each of them.  If GetType is ICRCOLUMN_GET_ALL, then this function will
// return the data for each column in ascending order for the table in the
// corresponding rgColumns element.  If it is ICRCOLUMN_GET_BYORDINAL, then
// the caller has initialized the Ordianl field of the column structure to
// indicate which columns data is to be retrieved.	The latter allows for ad-hoc
// retrieval of column definitions.
//*****************************************************************************
	virtual HRESULT GetColumnDefinitions(	// Return code.
		ICRCOLUMN_GET GetType,				// How to retrieve the columns.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_COLUMN rgColumns[],		// Return array of columns.
		int 		ColCount) = 0;			// Size of the rgColumns array, which
											//	should always match count from GetTableDefinition.

//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
	virtual HRESULT GetIndexDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		LPCWSTR 	szIndex,				// Name of the index to retrieve.
		ICRSCHEMA_INDEX *pIndex) = 0;		// Return index description here.
											//	should always match count from GetTableDefinition.

//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
	virtual HRESULT GetIndexDefinitionByNum( // Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		int 		IndexNum,				// 0 based index to return.
		ICRSCHEMA_INDEX *pIndex) = 0;		// Return index description here.
};


#if 0 // left to show user section interface example
//*****************************************************************************
// Interface definition of a user section for Call Signatures.
//*****************************************************************************
struct _COR_CALLDESCR;
interface ICallDescrSection : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE InsertCallDescr(
		ULONG		ulDescr,				// Index of Descr.
    	ULONG		ulGroup,				// Which group is Descr in?
		ULONG		cDescr,					// Count of descrs to insert.
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE AppendCallDescr(
    	ULONG		ulGroup,				// Which group is Descr in?
		ULONG		*pulDescr,				// Put relative index of first one here.
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescr(
		ULONG		ulDescr,				// Index of Descr.
    	ULONG		ulGroup,				// Which group is Descr in?
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescrGroups(
		ULONG		*pcGroups,				// How many groups?
    	ULONG		**pprcGroup) = 0;		// Count in each group.

    virtual HRESULT STDMETHODCALLTYPE AddCallSig(
        const void  *pVal,                  // The value to store.
        ULONG       iLen,                   // Count of bytes in signature.
        ULONG       *piOffset) = 0;         // The offset of the new item.

    virtual HRESULT STDMETHODCALLTYPE GetCallSig(
        ULONG       iOffset,                // Offset of the item to get.
        const void  **ppVal,                // Put pointer to Signature here.
        ULONG       *piLen) = 0;            // Put length of signature here.

    virtual HRESULT STDMETHODCALLTYPE GetCallSigBuf(
        const void  **ppVal) = 0;           // Put pointer to Signatures here.
};
#endif
//*****************************************************************************
// These interfaces provide a thread safe version of the ICR interfaces.  The
// v-table is exactly the same as the not TS versions.	Calls through the 
// TS interface will serialize calls as required.  To get the TS version,
// simply do a QueryInterface on the ICR pointer returned from the open/create
// function.
//*****************************************************************************
typedef IComponentRecordsSchema ITSComponentRecordsSchema;
typedef IComponentRecords ITSComponentRecords;



// Internal versions of the load functions.

extern "C" {

HRESULT STDMETHODCALLTYPE CreateComponentLibraryEx(
	LPCWSTR szName,
	long fFlags,
	IComponentRecords **ppIComponentRecords);

HRESULT STDMETHODCALLTYPE OpenComponentLibraryEx(
	LPCWSTR szName,
	long fFlags,
	IComponentRecords **ppIComponentRecords);


//*****************************************************************************
// This version of open will open the component library allows a shared copy
// of the database to be used.	A shared copy reduces overall overhead on the
// system by keeping just one view of the data which can be efficiently shared
// into other processes.
//
// CREATING THE INITIAL VIEW:
//	To do the initial open, pass the name of the file and the DBPROP_TMODEF_SMEMCREATE
//	flag.  This will open the data file on disk and create a file mapping with
//	the name contained in szSharedMemory.
//
// OPENING SECONDARY VIEWS:
//	To open a shared view already in memory, pass the DBPROP_TMODEF_SMEMOPEN
//	flag.  The view must already exist in memory as a shared object.  If not
//	found, an error will occur.
//
// LIGHTWEIGHT CLOSE:
//	A secondary view can be closed by calling LightWeightClose which will free
//	the shared memory handle but leave everything else intact.	Then the
//	database can be "rebound" to the shared memory by calling the
//	LightWeightOpen method.  See these methods in the ICR docs for details.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedEx(
	LPCWSTR 	szName, 				// Name of file on create, NULL on open.
	LPCWSTR 	szSharedMemory, 		// Name of shared memory.
	ULONG		cbSize, 				// Size of shared memory, 0 on create.
	LPSECURITY_ATTRIBUTES pAttributes,	// Security token.
	long		fFlags, 				// Open modes, must be read only.
	IComponentRecords **ppIComponentRecords); // Return database on success.


HRESULT STDMETHODCALLTYPE OpenComponentLibraryOnStreamEx(
	IStream *pIStream,
	long fFlags,
	IComponentRecords **ppIComponentRecords);


HRESULT STDMETHODCALLTYPE OpenComponentLibraryOnMemEx(
	ULONG cbData,
	LPCVOID pbData,
	IComponentRecords **ppIComponentRecords);


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ilformatter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                             ILFormatter.h                               */
/***************************************************************************/

#ifndef ILFormatter_h
#define ILFormatter_h

#include "OpInfo.h"
#include "OutString.h"

struct IMetaDataImport;

#ifdef _IA64_
#define INVALID_IL_OFFSET 0x8000000000000000
#else
#define INVALID_IL_OFFSET 0x80000000
#endif

/***************************************************************************/
class ILFormatter {
public:
	ILFormatter() : start(0), stackStart(0), targetStart(0) {}

	ILFormatter(IMetaDataImport* aMeta, const BYTE* aStart, 
                const BYTE* aLimit, unsigned maxStack, const COR_ILMETHOD_SECT_EH* eh) 
		: stackStart(0), targetStart(0) {
		init(aMeta, aStart, aLimit, maxStack, eh);
		}
    ~ILFormatter() { delete [] stackStart; delete [] targetStart; }

	void init(IMetaDataImport* aMeta, const BYTE* aStart, 
              const BYTE* aLimit, unsigned maxStack, const COR_ILMETHOD_SECT_EH* eh);
	const BYTE* formatStatement(const BYTE* stmtIL, OutString* out);
	const BYTE* formatInstr(const BYTE* instrIL, OutString* out);
private:

	void formatInstrArgs(OpInfo op, OpArgsVal arg, OutString* out, size_t curIP=INVALID_IL_OFFSET);
    void formatArgs(unsigned numArgs, OutString* out);
    void spillStack(OutString* out);
    void setStackAsTarget(size_t ilOffset);
    void setTarget(size_t ilOffset, size_t depth);

private:
	const BYTE* start;				// keeps us sane
	const BYTE* limit;
	IMetaDataImport* meta;			// used to parse tokens etc

    struct StackEntry {
        OutString val;
        int prec;
    };

    struct Target {
        size_t ilOffset;
        size_t stackDepth;
    };

    Target* targetStart;
    Target* targetEnd;
    Target* targetCur;

    size_t stackDepth();
    void pushAndClear(OutString* val, int prec);
	OutString* pop(int prec = 0);
	OutString* top();
    void popN(size_t num);

	StackEntry* stackStart;
	StackEntry* stackEnd;
	StackEntry* stackCur;   	// points at the next slot to fill

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\il_kywd.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//
// COM+ IL keywords, symbols and values
//
// This is the master table used in ILASM (asmparse.y)
// and ILDASM (dis.cpp)
// symbols and values are defined in asmparse.y 
// and not used in dis.cpp
//

#ifndef __IL_KYWD_H_
#define __IL_KYWD_H_

    KYWD( "void",           VOID_,              NO_VALUE )
    KYWD( "bool",           BOOL_,              NO_VALUE )
    KYWD( "char",           CHAR_,              NO_VALUE )
    KYWD( "wchar",          CHAR_,              NO_VALUE )
    KYWD( "int",            INT_,               NO_VALUE )
    KYWD( "int8",           INT8_,              NO_VALUE )
    KYWD( "int16",          INT16_,             NO_VALUE )
    KYWD( "int32",          INT32_,             NO_VALUE )
    KYWD( "int64",          INT64_,             NO_VALUE )
    KYWD( "float",          FLOAT_,             NO_VALUE )
    KYWD( "float32",        FLOAT32_,           NO_VALUE )
    KYWD( "float64",        FLOAT64_,           NO_VALUE )
    KYWD( "refany",         TYPEDREF_,          NO_VALUE )
    KYWD( "typedref",       TYPEDREF_,          NO_VALUE )
    KYWD( "object",         OBJECT_,            NO_VALUE )
    KYWD( "string",         STRING_,            NO_VALUE )
    KYWD( "native",         NATIVE_,            NO_VALUE )
    KYWD( "unsigned",       UNSIGNED_,          NO_VALUE )
    KYWD( "value",          VALUE_,             NO_VALUE )
    KYWD( "valuetype",      VALUETYPE_,         NO_VALUE )
    KYWD( "class",          CLASS_,             NO_VALUE )
    KYWD( "vararg",         VARARG_,            NO_VALUE )
    KYWD( "default",        DEFAULT_,           NO_VALUE )
    KYWD( "stdcall",        STDCALL_,           NO_VALUE )
    KYWD( "thiscall",       THISCALL_,          NO_VALUE )
    KYWD( "fastcall",       FASTCALL_,          NO_VALUE )
    KYWD( "unmanaged",      UNMANAGED_,         NO_VALUE )
    KYWD( "beforefieldinit",BEFOREFIELDINIT_,   NO_VALUE )
    KYWD( "instance",       INSTANCE_,          NO_VALUE )
    KYWD( "filter",         FILTER_,            NO_VALUE )
    KYWD( "catch",          CATCH_,             NO_VALUE )
    KYWD( "static",         STATIC_ ,           NO_VALUE )
    KYWD( "public",         PUBLIC_,            NO_VALUE )
    KYWD( "private",        PRIVATE_,           NO_VALUE )
    KYWD( "synchronized",   SYNCHRONIZED_,      NO_VALUE )
    KYWD( "interface",      INTERFACE_,         NO_VALUE )
    KYWD( "extends",        EXTENDS_,           NO_VALUE )
    KYWD( "implements",     IMPLEMENTS_,        NO_VALUE )
    KYWD( "handler",        HANDLER_,           NO_VALUE )
    KYWD( "finally",        FINALLY_,           NO_VALUE )
    KYWD( "fault",          FAULT_,             NO_VALUE )
    KYWD( "to",             TO_,                NO_VALUE )
    KYWD( "abstract",       ABSTRACT_,          NO_VALUE )
    KYWD( "auto",           AUTO_,              NO_VALUE )
    KYWD( "sequential",     SEQUENTIAL_,        NO_VALUE )
    KYWD( "explicit",       EXPLICIT_,          NO_VALUE )
    KYWD( "ansi",           ANSI_,              NO_VALUE )
    KYWD( "unicode",        UNICODE_,           NO_VALUE )
    KYWD( "autochar",       AUTOCHAR_,          NO_VALUE )
    KYWD( "import",         IMPORT_,            NO_VALUE )
    KYWD( "enum",           ENUM_,              NO_VALUE )
    KYWD( "virtual",        VIRTUAL_,           NO_VALUE )
    KYWD( "strict",         STRICT_,            NO_VALUE )
    KYWD( "il",             CIL_,               NO_VALUE )
    KYWD( "cil",            CIL_,               NO_VALUE )
    KYWD( "optil",          OPTIL_,             NO_VALUE )
    KYWD( "managed",        MANAGED_,           NO_VALUE )
    KYWD( "preservesig",    PRESERVESIG_,       NO_VALUE )
    KYWD( "runtime",        RUNTIME_,           NO_VALUE )
    KYWD( "method",         METHOD_,            NO_VALUE )
    KYWD( "field",          FIELD_,             NO_VALUE )
    KYWD( "bytearray",      BYTEARRAY_,         NO_VALUE )
    KYWD( "final",          FINAL_,             NO_VALUE )
    KYWD( "sealed",         SEALED_,            NO_VALUE )
    KYWD( "specialname",    SPECIALNAME_,       NO_VALUE )
    KYWD( "family",         FAMILY_,            NO_VALUE )
    KYWD( "assembly",       ASSEMBLY_,          NO_VALUE )
    KYWD( "famandassem",    FAMANDASSEM_,       NO_VALUE )
    KYWD( "famorassem",     FAMORASSEM_,        NO_VALUE )
    KYWD( "privatescope",   PRIVATESCOPE_,      NO_VALUE )
    KYWD( "nested",         NESTED_,            NO_VALUE )
    KYWD( "hidebysig",      HIDEBYSIG_,         NO_VALUE )
    KYWD( "newslot",        NEWSLOT_,           NO_VALUE )
    KYWD( "rtspecialname",  RTSPECIALNAME_,     NO_VALUE )
    KYWD( "pinvokeimpl",    PINVOKEIMPL_,       NO_VALUE )
    KYWD( "unmanagedexp",   UNMANAGEDEXP_,      NO_VALUE )
    KYWD( "reqsecobj",		REQSECOBJ_,         NO_VALUE )
    KYWD( ".ctor",          _CTOR,              NO_VALUE )
    KYWD( ".cctor",         _CCTOR,             NO_VALUE )
    KYWD( "initonly",       INITONLY_,          NO_VALUE )
    KYWD( "literal",        LITERAL_,           NO_VALUE )
    KYWD( "notserialized",  NOTSERIALIZED_,     NO_VALUE )
    KYWD( "forwardref",     FORWARDREF_,        NO_VALUE )
    KYWD( "internalcall",   INTERNALCALL_,      NO_VALUE )
    KYWD( "noinlining",     NOINLINING_,        NO_VALUE )
    KYWD( "nomangle",       NOMANGLE_,          NO_VALUE )
    KYWD( "lasterr",        LASTERR_,           NO_VALUE )
    KYWD( "winapi",         WINAPI_,            NO_VALUE )
    KYWD( "cdecl",          CDECL_,             NO_VALUE )
    KYWD( "as",             AS_,                NO_VALUE )
    KYWD( "pinned",         PINNED_,            NO_VALUE )
    KYWD( "modreq",         MODREQ_,            NO_VALUE )
    KYWD( "modopt",         MODOPT_,            NO_VALUE )
    KYWD( "serializable",   SERIALIZABLE_,      NO_VALUE )
    KYWD( "at",             AT_,                NO_VALUE )
    KYWD( "tls",            TLS_,               NO_VALUE )
    KYWD( "true",           TRUE_,              NO_VALUE )
    KYWD( "false",          FALSE_,             NO_VALUE )
    KYWD( "on",             ON_,                NO_VALUE )
    KYWD( "off",            OFF_,               NO_VALUE )
    KYWD( "bestfit",        BESTFIT_,           NO_VALUE )
    KYWD( "charmaperror",   CHARMAPERROR_,      NO_VALUE )

        /* assembler directives */
    KYWD( ".class",         _CLASS,             NO_VALUE )
    KYWD( ".namespace",     _NAMESPACE,         NO_VALUE )
    KYWD( ".method",        _METHOD,            NO_VALUE )
    KYWD( ".field",         _FIELD,             NO_VALUE )
    KYWD( ".emitbyte",      _EMITBYTE,          NO_VALUE )
    KYWD( ".try",           _TRY,               NO_VALUE )
    KYWD( ".maxstack",      _MAXSTACK,          NO_VALUE )
    KYWD( ".locals",        _LOCALS,            NO_VALUE )
    KYWD( ".entrypoint",    _ENTRYPOINT,        NO_VALUE )
    KYWD( ".zeroinit",      _ZEROINIT,          NO_VALUE )
    KYWD( ".data",          _DATA,              NO_VALUE )

    KYWD( ".event",         _EVENT,             NO_VALUE )
    KYWD( ".addon",         _ADDON,             NO_VALUE )
    KYWD( ".removeon",      _REMOVEON,          NO_VALUE )
    KYWD( ".fire",          _FIRE,              NO_VALUE )
    KYWD( ".other",         _OTHER,             NO_VALUE )
    
    KYWD( ".property",      _PROPERTY,          NO_VALUE )
    KYWD( ".set",           _SET,               NO_VALUE )
    KYWD( ".get",           _GET,               NO_VALUE )

    KYWD( ".permission",    _PERMISSION,        NO_VALUE )
    KYWD( ".permissionset", _PERMISSIONSET,     NO_VALUE )

        /* security actions */
    KYWD( "request",        REQUEST_,           NO_VALUE )
    KYWD( "demand",         DEMAND_,            NO_VALUE )
    KYWD( "assert",         ASSERT_,            NO_VALUE )
    KYWD( "deny",           DENY_,              NO_VALUE )
    KYWD( "permitonly",     PERMITONLY_,        NO_VALUE )
    KYWD( "linkcheck",      LINKCHECK_,         NO_VALUE )
    KYWD( "inheritcheck",   INHERITCHECK_,      NO_VALUE )
    KYWD( "reqmin",         REQMIN_,            NO_VALUE )
    KYWD( "reqopt",         REQOPT_,            NO_VALUE )
    KYWD( "reqrefuse",      REQREFUSE_,         NO_VALUE )
    KYWD( "prejitgrant",    PREJITGRANT_,       NO_VALUE )
    KYWD( "prejitdeny",     PREJITDENY_,        NO_VALUE )
    KYWD( "noncasdemand",   NONCASDEMAND_,      NO_VALUE )
    KYWD( "noncaslinkdemand",NONCASLINKDEMAND_, NO_VALUE )
    KYWD( "noncasinheritance",NONCASINHERITANCE_,NO_VALUE )

        /* extern debug data specifier */
    KYWD( ".line",          _LINE,              NO_VALUE )
    KYWD( ".language",      _LANGUAGE,          NO_VALUE )
    KYWD( "#line",          P_LINE,             NO_VALUE )
        /* custom value specifier */
    KYWD( ".custom",        _CUSTOM,            NO_VALUE )
        /* IL method attribute */
    KYWD( "init",           INIT_,              NO_VALUE )
        /* Class layout directives */
    KYWD( ".size",          _SIZE,              NO_VALUE )
    KYWD( ".pack",          _PACK,              NO_VALUE )
        /* Manifest-related keywords */
    KYWD( ".file",          _FILE,              NO_VALUE )
    KYWD( "nometadata",     NOMETADATA_,            NO_VALUE )
    KYWD( ".hash",          _HASH,              NO_VALUE )
    KYWD( ".assembly",      _ASSEMBLY,          NO_VALUE )
    KYWD( "noappdomain",    NOAPPDOMAIN_,       NO_VALUE )
    KYWD( "noprocess",      NOPROCESS_,         NO_VALUE )
    KYWD( "nomachine",      NOMACHINE_,         NO_VALUE )
    KYWD( "retargetable",   RETARGETABLE_,      NO_VALUE )
    KYWD( ".publickey",     _PUBLICKEY,         NO_VALUE )
    KYWD( ".publickeytoken",_PUBLICKEYTOKEN,    NO_VALUE )
    KYWD( "algorithm",      ALGORITHM_,         NO_VALUE )
    KYWD( ".ver",           _VER,               NO_VALUE )
    KYWD( ".locale",        _LOCALE,            NO_VALUE )
    KYWD( "extern",         EXTERN_,            NO_VALUE )
    KYWD( ".export",        _EXPORT,            NO_VALUE )
    KYWD( ".manifestres",   _MRESOURCE,         NO_VALUE )
    KYWD( ".mresource",     _MRESOURCE,         NO_VALUE )
    KYWD( ".module",        _MODULE,            NO_VALUE )
        /* Field marshaling keywords */
    KYWD( "marshal",        MARSHAL_,           NO_VALUE )
    KYWD( "custom",         CUSTOM_,            NO_VALUE )
    KYWD( "sysstring",      SYSSTRING_,         NO_VALUE )
    KYWD( "fixed",          FIXED_,             NO_VALUE )
    KYWD( "variant",        VARIANT_,           NO_VALUE )
    KYWD( "currency",       CURRENCY_,          NO_VALUE )
    KYWD( "syschar",        SYSCHAR_,           NO_VALUE )
    KYWD( "decimal",        DECIMAL_,           NO_VALUE )
    KYWD( "date",           DATE_,              NO_VALUE )
    KYWD( "bstr",           BSTR_,              NO_VALUE )
    KYWD( "tbstr",          TBSTR_,             NO_VALUE )
    KYWD( "lpstr",          LPSTR_,             NO_VALUE )
    KYWD( "lpwstr",         LPWSTR_,            NO_VALUE )
    KYWD( "lptstr",         LPTSTR_,            NO_VALUE )
    KYWD( "objectref",      OBJECTREF_,         NO_VALUE )
    KYWD( "iunknown",       IUNKNOWN_,          NO_VALUE )
    KYWD( "idispatch",      IDISPATCH_,         NO_VALUE )
    KYWD( "struct",         STRUCT_,            NO_VALUE )
    KYWD( "safearray",      SAFEARRAY_,         NO_VALUE )
    KYWD( "byvalstr",       BYVALSTR_,          NO_VALUE )
    KYWD( "lpvoid",         LPVOID_,            NO_VALUE )
    KYWD( "any",            ANY_,               NO_VALUE )
    KYWD( "array",          ARRAY_,             NO_VALUE )
    KYWD( "lpstruct",       LPSTRUCT_,          NO_VALUE )
        /* VTable fixup keywords */
    KYWD( ".vtfixup",       _VTFIXUP,           NO_VALUE )
    KYWD( "fromunmanaged",  FROMUNMANAGED_,     NO_VALUE )
    KYWD( "retainappdomain",RETAINAPPDOMAIN_,   NO_VALUE )
    KYWD( "callmostderived",CALLMOSTDERIVED_,   NO_VALUE )
    KYWD( ".vtentry",       _VTENTRY,           NO_VALUE )
        /* Parameter attributes */
    KYWD( "in",             IN_,                NO_VALUE )
    KYWD( "out",            OUT_,               NO_VALUE )
    KYWD( "opt",            OPT_,               NO_VALUE )
    KYWD( ".param",         _PARAM,             NO_VALUE )
        /* Method implementations */
    KYWD( ".override",      _OVERRIDE,          NO_VALUE )
    KYWD( "with",           WITH_,              NO_VALUE )
        /* VariantType keywords */
    KYWD( "null",           NULL_,              NO_VALUE )
    KYWD( "error",          ERROR_,             NO_VALUE )
    KYWD( "hresult",        HRESULT_,           NO_VALUE )
    KYWD( "carray",         CARRAY_,            NO_VALUE )
    KYWD( "userdefined",    USERDEFINED_,       NO_VALUE )
    KYWD( "record",         RECORD_,            NO_VALUE )
    KYWD( "filetime",       FILETIME_,          NO_VALUE )
    KYWD( "blob",           BLOB_,              NO_VALUE )
    KYWD( "stream",         STREAM_,            NO_VALUE )
    KYWD( "storage",        STORAGE_,           NO_VALUE )
    KYWD( "streamed_object",STREAMED_OBJECT_,   NO_VALUE )
    KYWD( "stored_object",  STORED_OBJECT_,     NO_VALUE )
    KYWD( "blob_object",    BLOB_OBJECT_,       NO_VALUE )
    KYWD( "cf",             CF_,                NO_VALUE )
    KYWD( "clsid",          CLSID_,             NO_VALUE )
    KYWD( "vector",         VECTOR_,            NO_VALUE )
		/* Null reference keyword for InitOpt */
    KYWD( "nullref",        NULLREF_,           NO_VALUE )
		/* Header flags keywords */
    KYWD( ".subsystem",     _SUBSYSTEM,         NO_VALUE )
    KYWD( ".corflags",      _CORFLAGS,          NO_VALUE )
    KYWD( "alignment",      ALIGNMENT_,         NO_VALUE )
    KYWD( ".imagebase",     _IMAGEBASE,         NO_VALUE )

        /* Deprecated keywords */
    KYWD( ".vtable",        _VTABLE,            NO_VALUE )


    KYWD( "^THE_END^",      0,                  NO_VALUE )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\inifile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * inifile.h - Initialization file processing module description.
 */

#ifndef _INIFILE_H_
#define _INIFILE_H_

/* bit flag manipulation */
#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))


#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))


#define MAX_INI_SWITCH_RHS_LEN      MAX_PATH

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT
}
INISWITCHTYPE;

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   PCSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   PCSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   PCSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;




/* Prototypes
 *************/

/* inifile.c */

extern BOOL SetIniSwitches(const void **, UINT);

extern char                *g_pcszIniFile;
extern char                *g_pcszIniSection;

#endif _INIFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\intrinsic.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Intrinsic.h
//
// Force several very useful functions to be intrinsic, which means that the
// compiler will generate code inline for the functions instead of generating
// a call to the function.
//
//*****************************************************************************
#ifndef __intrinsic_h__
#define __intrinsic_h__

#pragma intrinsic(memcmp)
#pragma intrinsic(memcpy)
#pragma intrinsic(memset)
#pragma intrinsic(strcmp)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)

#endif // __intrinsic_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivalidator.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:17 2003
 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivalidator_h__
#define __ivalidator_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IValidator_FWD_DEFINED__
#define __IValidator_FWD_DEFINED__
typedef interface IValidator IValidator;
#endif 	/* __IValidator_FWD_DEFINED__ */


/* header files for imported files */
#include "ivehandler.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ivalidator_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_s_ifspec;

#ifndef __IValidator_INTERFACE_DEFINED__
#define __IValidator_INTERFACE_DEFINED__

/* interface IValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FAC")
    IValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ byte *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValidator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IValidator * This,
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ byte *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            IValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa);
        
        END_INTERFACE
    } IValidatorVtbl;

    interface IValidator
    {
        CONST_VTBL struct IValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValidator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IValidator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IValidator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IValidator_Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    (This)->lpVtbl -> Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)

#define IValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IValidator_Validate_Proxy( 
    IValidator * This,
    /* [in] */ IVEHandler *veh,
    /* [in] */ IUnknown *pAppDomain,
    /* [in] */ unsigned long ulFlags,
    /* [in] */ unsigned long ulMaxError,
    /* [in] */ unsigned long token,
    /* [in] */ LPWSTR fileName,
    /* [size_is][in] */ byte *pe,
    /* [in] */ unsigned long ulSize);


void __RPC_STUB IValidator_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IValidator_FormatEventInfo_Proxy( 
    IValidator * This,
    /* [in] */ HRESULT hVECode,
    /* [in] */ VEContext Context,
    /* [out][in] */ LPWSTR msg,
    /* [in] */ unsigned long ulMaxLength,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB IValidator_FormatEventInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IValidator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ipcfunccall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCFuncCall.h
//
// Define class to support a cross process function call. 
//
//*****************************************************************************

#ifndef _IPCFUNCCALLIMPL_H_
#define _IPCFUNCCALLIMPL_H_

//-----------------------------------------------------------------------------
// 1. Handler creates a IPCFuncCallHandler object and inits it with
// a callback function.
// 2. Source calls IPCFuncCallSource::DoThreadSafeCall(). This will pause the
// thread and trigger the callback on the handlers side.
// 
// This mechanism is very robust. See the error return codes on 
// DoThreadSafeCall() for more details.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Send the call
//-----------------------------------------------------------------------------
class IPCFuncCallSource
{
public:
//.............................................................................
// Error return codes for members.
// Our biggest error concerns are timeouts and no handlers. HRESULTS won't
// help us with these, so we'll have to use our own codes.
//.............................................................................
	enum EError
	{
	// (Common) the function was called, and we waited for the full duration.
		Ok,

	// (Common) The function MAY have been called, but we timed out before it 
	// finished This means either: The function was called, but took too long 
	// to finish or The handler died on us right after we hooked up to it and 
	// so the function never even got called.
		Fail_Timeout_Call,

	// (Common) There was no handler for us to call
		Fail_NoHandler,

	// (rare) The function was never called. We successfully connected to the handler,
	// but we timed out waiting for the mutex.
		Fail_Timeout_Lock,	
			
	// (very rare) We were unable to create the mutex to serialize
		Fail_CreateMutex,

	// (very rare) Catch-all General Failure. 
		Failed
		
	};


// Make a call, wrapped in a mutex
	static EError DoThreadSafeCall();


protected:
	
};


//-----------------------------------------------------------------------------
// AuxThread Callback
//-----------------------------------------------------------------------------
DWORD WINAPI HandlerAuxThreadProc(LPVOID lpParameter);


//-----------------------------------------------------------------------------
// Callback for handler. AuxThread will call this.
//-----------------------------------------------------------------------------
typedef void (*HANDLER_CALLBACK)();

//-----------------------------------------------------------------------------
// Receieves the call. This should be in a different process than the source
//-----------------------------------------------------------------------------
class IPCFuncCallHandler
{
public:
	HRESULT InitFCHandler(HANDLER_CALLBACK pfnCallback);
	void TerminateFCHandler();

	IPCFuncCallHandler();
	~IPCFuncCallHandler();
protected:	
	HANDLE m_hStartEnum;	// event to notify start call
	HANDLE m_hDoneEnum;		// event to notify end call

	HANDLE m_hAuxThread;	// thread to listen for m_hStartEnum

	HANDLER_CALLBACK m_pfnCallback;
    
    BOOL m_fShutdownAuxThread; // flag the Aux thread to finish up gracefully
    HANDLE m_hShutdownThread; // Event to signal the Aux thread to finish up gracefully
    HANDLE m_hAuxThreadShutdown; // Unnamed event to signal to the main thread that the 
                                 // aux thread is about to exit and wont call the callback anymore

    HMODULE m_hCallbackModule; // Hold the module's ref to make sure that the
                               // aux thread's code doesn't get unmapped.
// Make auxthread our friend so he can access all our eventing objects
	friend DWORD WINAPI HandlerAuxThreadProc(LPVOID);
};


#endif // _IPCFUNCCALLIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivalidator_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:17 2003
 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IValidator,0x63DF8730,0xDC81,0x4062,0x84,0xA2,0x1F,0xF9,0x43,0xF5,0x9F,0xAC);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\internaldebug.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// InternalDebug.h
//
// This is internal code for debug mode which will turn on memory dump checking
// and other settings.  Call the api's according to:
//		_DbgInit		On startup to init the system.
//		_DbgRecord		Call this when you are sure you want dump checking.
//		_DbgUninit		Call at process shutdown to force the dump.
//
// The reason not to enable dumping under all circumstance is one might want
// to pre-empt the dump when you hit Ctrl+C or otherwise terminate the process.
// This is actually pretty common while unit testing code, and seeing a dump
// when you obviously did not free resources is annoying.
//
//*****************************************************************************
#ifndef __InternalDebug_h__
#define __InternalDebug_h__

#include "switches.h"

#ifdef _DEBUG

// Internal support for debugging the EE.
void _DbgInit(HINSTANCE hInstance);
void _DbgRecord();
void _DbgUninit();
#ifdef SHOULD_WE_CLEANUP
void SetReportingOfCRTMemoryLeaks(BOOL fShouldWeReport);
#endif /* SHOULD_WE_CLEANUP */


#else

#define _DbgInit(p)
#define _DbgRecord()
#define _DbgUninit()

#endif

#endif // __InternalDebug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ipcmanagerinterface.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCManagerInterface.h
//
// Interface for InterProcess Communication with a COM+ process.
//
//*****************************************************************************

#ifndef _IPCMANAGERINTERFACE_H_
#define _IPCMANAGERINTERFACE_H_

enum EPrivateIPCClient;
struct PerfCounterIPCControlBlock;
struct DebuggerIPCControlBlock;
struct AppDomainEnumerationIPCBlock;
struct ServiceIPCControlBlock;
struct MiniDumpBlock;
struct ClassDumpTableBlock;

#include "..\IPCMan\IPCManagerImpl.h"

//-----------------------------------------------------------------------------
// Interface to the IPCManager for COM+.
// This is a little backwards. To avoid the overhead of a vtable (since
// we don't need it).
// Implementation - the base class with all data and private helper functions
// Interface - derive from base, provide public functions to access impl's data
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Writer - create a COM+ IPC Block with security attributes.
//-----------------------------------------------------------------------------
class IPCWriterInterface : public IPCWriterImpl
{
public:
    //.............................................................................
    // Creation / Destruction only on implementation
    //.............................................................................
	HRESULT Init();
	void Terminate();

    //.............................................................................
    // Create the private IPC block. If this fails because the IPC block has already been
    // created by another module then the phInstIPCBlockOwner argument will be set to the
    // HINSTANCE of the module that created the IPC block.
    // Set inService to TRUE if creating from within a service on behalf of a process.
    //.............................................................................
	HRESULT CreatePrivateBlockOnPid(DWORD PID, BOOL inService, HINSTANCE *phInstIPCBlockOwner);

    //.............................................................................
    // Open the private IPC block that has alread been created.
    //.............................................................................
	HRESULT OpenPrivateBlockOnPid(DWORD PID);

    //.............................................................................
    // Accessors - return info from header
    //.............................................................................
	DWORD		GetBlockVersion();
    DWORD       GetBlockSize();
	HINSTANCE	GetInstance();
	USHORT		GetBuildYear();
	USHORT		GetBuildNumber();
    PVOID       GetBlockStart();

    //.............................................................................
    // Accessors to get each clients' blocks
    //.............................................................................
	PerfCounterIPCControlBlock *	GetPerfBlock();
	DebuggerIPCControlBlock *	GetDebugBlock();
	AppDomainEnumerationIPCBlock * GetAppDomainBlock();
    ServiceIPCControlBlock *GetServiceBlock();
    MiniDumpBlock * GetMiniDumpBlock();
    ClassDumpTableBlock* GetClassDumpTableBlock();


    //.............................................................................
    // Get Security attributes for a block for a given process. This can be used
    // to create other kernal objects with the same security level.
    //
    // Note: there is no caching, the SD is formed every time, and its not cheap.
    // Note: you must destroy the result with DestroySecurityAttributes().
    //.............................................................................
	HRESULT GetSecurityAttributes(DWORD pid, SECURITY_ATTRIBUTES **ppSA);
    void DestroySecurityAttributes(SECURITY_ATTRIBUTES *pSA);
};


//-----------------------------------------------------------------------------
// IPCReader class connects to a COM+ IPC block and reads from it
// @FUTURE - make global & private readers
//-----------------------------------------------------------------------------
class IPCReaderInterface : public IPCReaderImpl
{
public:	

    //.............................................................................
    // Create & Destroy
    //.............................................................................
	HRESULT OpenPrivateBlockOnPid(DWORD pid);
    HRESULT OpenPrivateBlockOnPid(DWORD pid, DWORD dwDesiredAccess);
    HRESULT OpenPrivateBlockOnPidReadWrite(DWORD pid);
    HRESULT OpenPrivateBlockOnPidReadOnly(DWORD pid);
	void ClosePrivateBlock();

    //.............................................................................
    // Accessors - return info from header
    // @FUTURE - factor this into IPCWriterInterface as well.
    //.............................................................................
	DWORD		GetBlockVersion();
    DWORD       GetBlockSize();
	HINSTANCE	GetInstance();
	USHORT		GetBuildYear();
	USHORT		GetBuildNumber();
    PVOID       GetBlockStart();

    //.............................................................................
    // Check the Block to see if it's corrupted. Returns true if the block is safe
    //.............................................................................
	bool IsValid();

    //.............................................................................
    // Get different sections of the IPC 
    //.............................................................................
	void * GetPrivateBlock(EPrivateIPCClient eClient);

	PerfCounterIPCControlBlock *	GetPerfBlock();
	DebuggerIPCControlBlock * GetDebugBlock();
	AppDomainEnumerationIPCBlock * GetAppDomainBlock();
    ServiceIPCControlBlock * GetServiceBlock();
    MiniDumpBlock * GetMiniDumpBlock();
    ClassDumpTableBlock* GetClassDumpTableBlock();

    //.............................................................................
    // Return true if we're connected to a memory-mapped file, else false.
    //.............................................................................
	bool IsPrivateBlockOpen() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivalidator_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:17 2003
 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "ivalidator.h"

#define TYPE_FORMAT_STRING_SIZE   1255                              
#define PROC_FORMAT_STRING_SIZE   123                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IValidator_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IValidator_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Validate */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x20 ),	/* 32 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x9,		/* 9 */

	/* Parameter veh */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter pAppDomain */

/* 22 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ulFlags */

/* 28 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulMaxError */

/* 34 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter token */

/* 40 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 42 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 44 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fileName */

/* 46 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 48 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 50 */	NdrFcShort( 0x28 ),	/* Type Offset=40 */

	/* Parameter pe */

/* 52 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 54 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 56 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Parameter ulSize */

/* 58 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 60 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 62 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 64 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 66 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 68 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure FormatEventInfo */

/* 70 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 72 */	NdrFcLong( 0x0 ),	/* 0 */
/* 76 */	NdrFcShort( 0x4 ),	/* 4 */
/* 78 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 80 */	NdrFcShort( 0x70 ),	/* 112 */
/* 82 */	NdrFcShort( 0x8 ),	/* 8 */
/* 84 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter hVECode */

/* 86 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 88 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 90 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Context */

/* 92 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 94 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 96 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter msg */

/* 98 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 100 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 102 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */

	/* Parameter ulMaxLength */

/* 104 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 106 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psa */

/* 110 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 112 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 114 */	NdrFcShort( 0x4dc ),	/* Type Offset=1244 */

	/* Return value */

/* 116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 118 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x856ca1b2 ),	/* -2056478286 */
/*  8 */	NdrFcShort( 0x7dab ),	/* 32171 */
/* 10 */	NdrFcShort( 0x11d3 ),	/* 4563 */
/* 12 */	0xac,		/* 172 */
			0xec,		/* 236 */
/* 14 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 16 */	0x4f,		/* 79 */
			0x86,		/* 134 */
/* 18 */	0xc3,		/* 195 */
			0x9,		/* 9 */
/* 20 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 32 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 34 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 36 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 38 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 40 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 42 */	
			0x11, 0x0,	/* FC_RP */
/* 44 */	NdrFcShort( 0x2 ),	/* Offset= 2 (46) */
/* 46 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 48 */	NdrFcShort( 0x1 ),	/* 1 */
/* 50 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 52 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 54 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 56 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 58 */	NdrFcShort( 0x20 ),	/* 32 */
/* 60 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 62 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 64 */	NdrFcShort( 0x14 ),	/* 20 */
/* 66 */	NdrFcShort( 0x14 ),	/* 20 */
/* 68 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 70 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 72 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 74 */	NdrFcShort( 0x1c ),	/* 28 */
/* 76 */	NdrFcShort( 0x1c ),	/* 28 */
/* 78 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 80 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 82 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 84 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 86 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 88 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 94 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 96 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 98 */	NdrFcShort( 0x2 ),	/* Offset= 2 (100) */
/* 100 */	
			0x12, 0x0,	/* FC_UP */
/* 102 */	NdrFcShort( 0x464 ),	/* Offset= 1124 (1226) */
/* 104 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 106 */	NdrFcShort( 0x18 ),	/* 24 */
/* 108 */	NdrFcShort( 0xa ),	/* 10 */
/* 110 */	NdrFcLong( 0x8 ),	/* 8 */
/* 114 */	NdrFcShort( 0x6c ),	/* Offset= 108 (222) */
/* 116 */	NdrFcLong( 0xd ),	/* 13 */
/* 120 */	NdrFcShort( 0x9e ),	/* Offset= 158 (278) */
/* 122 */	NdrFcLong( 0x9 ),	/* 9 */
/* 126 */	NdrFcShort( 0xcc ),	/* Offset= 204 (330) */
/* 128 */	NdrFcLong( 0xc ),	/* 12 */
/* 132 */	NdrFcShort( 0x330 ),	/* Offset= 816 (948) */
/* 134 */	NdrFcLong( 0x24 ),	/* 36 */
/* 138 */	NdrFcShort( 0x358 ),	/* Offset= 856 (994) */
/* 140 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 144 */	NdrFcShort( 0x398 ),	/* Offset= 920 (1064) */
/* 146 */	NdrFcLong( 0x10 ),	/* 16 */
/* 150 */	NdrFcShort( 0x3b0 ),	/* Offset= 944 (1094) */
/* 152 */	NdrFcLong( 0x2 ),	/* 2 */
/* 156 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1124) */
/* 158 */	NdrFcLong( 0x3 ),	/* 3 */
/* 162 */	NdrFcShort( 0x3e0 ),	/* Offset= 992 (1154) */
/* 164 */	NdrFcLong( 0x14 ),	/* 20 */
/* 168 */	NdrFcShort( 0x3f8 ),	/* Offset= 1016 (1184) */
/* 170 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (169) */
/* 172 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 174 */	NdrFcShort( 0x2 ),	/* 2 */
/* 176 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 178 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 180 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 182 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 186 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (172) */
/* 188 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 190 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 192 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 194 */	NdrFcShort( 0x4 ),	/* 4 */
/* 196 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 202 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x1 ),	/* 1 */
/* 210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	0x12, 0x0,	/* FC_UP */
/* 216 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (182) */
/* 218 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 220 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 222 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 224 */	NdrFcShort( 0x8 ),	/* 8 */
/* 226 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 228 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 230 */	NdrFcShort( 0x4 ),	/* 4 */
/* 232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 234 */	0x11, 0x0,	/* FC_RP */
/* 236 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (192) */
/* 238 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 240 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 242 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 254 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 256 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 258 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 260 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 274 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (242) */
/* 276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 278 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x6 ),	/* Offset= 6 (290) */
/* 286 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x11, 0x0,	/* FC_RP */
/* 292 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (260) */
/* 294 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 296 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 306 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 308 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 310 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 312 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 324 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 326 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (294) */
/* 328 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 330 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 332 */	NdrFcShort( 0x8 ),	/* 8 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x6 ),	/* Offset= 6 (342) */
/* 338 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 340 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 342 */	
			0x11, 0x0,	/* FC_RP */
/* 344 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (312) */
/* 346 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 348 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 350 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 352 */	NdrFcShort( 0x2 ),	/* Offset= 2 (354) */
/* 354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 356 */	NdrFcShort( 0x2f ),	/* 47 */
/* 358 */	NdrFcLong( 0x14 ),	/* 20 */
/* 362 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 364 */	NdrFcLong( 0x3 ),	/* 3 */
/* 368 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 370 */	NdrFcLong( 0x11 ),	/* 17 */
/* 374 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 376 */	NdrFcLong( 0x2 ),	/* 2 */
/* 380 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 382 */	NdrFcLong( 0x4 ),	/* 4 */
/* 386 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 388 */	NdrFcLong( 0x5 ),	/* 5 */
/* 392 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 394 */	NdrFcLong( 0xb ),	/* 11 */
/* 398 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 400 */	NdrFcLong( 0xa ),	/* 10 */
/* 404 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 406 */	NdrFcLong( 0x6 ),	/* 6 */
/* 410 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (642) */
/* 412 */	NdrFcLong( 0x7 ),	/* 7 */
/* 416 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 418 */	NdrFcLong( 0x8 ),	/* 8 */
/* 422 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (648) */
/* 424 */	NdrFcLong( 0xd ),	/* 13 */
/* 428 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (652) */
/* 430 */	NdrFcLong( 0x9 ),	/* 9 */
/* 434 */	NdrFcShort( 0xec ),	/* Offset= 236 (670) */
/* 436 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 440 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (688) */
/* 442 */	NdrFcLong( 0x24 ),	/* 36 */
/* 446 */	NdrFcShort( 0xfa ),	/* Offset= 250 (696) */
/* 448 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 452 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (696) */
/* 454 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 458 */	NdrFcShort( 0x122 ),	/* Offset= 290 (748) */
/* 460 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 464 */	NdrFcShort( 0x120 ),	/* Offset= 288 (752) */
/* 466 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 470 */	NdrFcShort( 0x11e ),	/* Offset= 286 (756) */
/* 472 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 476 */	NdrFcShort( 0x11c ),	/* Offset= 284 (760) */
/* 478 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 482 */	NdrFcShort( 0x11a ),	/* Offset= 282 (764) */
/* 484 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 488 */	NdrFcShort( 0x118 ),	/* Offset= 280 (768) */
/* 490 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 494 */	NdrFcShort( 0x116 ),	/* Offset= 278 (772) */
/* 496 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 500 */	NdrFcShort( 0x114 ),	/* Offset= 276 (776) */
/* 502 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 506 */	NdrFcShort( 0x112 ),	/* Offset= 274 (780) */
/* 508 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 512 */	NdrFcShort( 0x110 ),	/* Offset= 272 (784) */
/* 514 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 518 */	NdrFcShort( 0x10e ),	/* Offset= 270 (788) */
/* 520 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 524 */	NdrFcShort( 0x110 ),	/* Offset= 272 (796) */
/* 526 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 530 */	NdrFcShort( 0x120 ),	/* Offset= 288 (818) */
/* 532 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 536 */	NdrFcShort( 0x130 ),	/* Offset= 304 (840) */
/* 538 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 542 */	NdrFcShort( 0x136 ),	/* Offset= 310 (852) */
/* 544 */	NdrFcLong( 0x10 ),	/* 16 */
/* 548 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 550 */	NdrFcLong( 0x12 ),	/* 18 */
/* 554 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 556 */	NdrFcLong( 0x13 ),	/* 19 */
/* 560 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 562 */	NdrFcLong( 0x15 ),	/* 21 */
/* 566 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 568 */	NdrFcLong( 0x16 ),	/* 22 */
/* 572 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 574 */	NdrFcLong( 0x17 ),	/* 23 */
/* 578 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 580 */	NdrFcLong( 0xe ),	/* 14 */
/* 584 */	NdrFcShort( 0x114 ),	/* Offset= 276 (860) */
/* 586 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 590 */	NdrFcShort( 0x118 ),	/* Offset= 280 (870) */
/* 592 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 596 */	NdrFcShort( 0x116 ),	/* Offset= 278 (874) */
/* 598 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 602 */	NdrFcShort( 0x114 ),	/* Offset= 276 (878) */
/* 604 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 608 */	NdrFcShort( 0x112 ),	/* Offset= 274 (882) */
/* 610 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 614 */	NdrFcShort( 0x110 ),	/* Offset= 272 (886) */
/* 616 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 620 */	NdrFcShort( 0x10e ),	/* Offset= 270 (890) */
/* 622 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 626 */	NdrFcShort( 0x10c ),	/* Offset= 268 (894) */
/* 628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 632 */	NdrFcShort( 0x0 ),	/* Offset= 0 (632) */
/* 634 */	NdrFcLong( 0x1 ),	/* 1 */
/* 638 */	NdrFcShort( 0x0 ),	/* Offset= 0 (638) */
/* 640 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (639) */
/* 642 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 644 */	NdrFcShort( 0x8 ),	/* 8 */
/* 646 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 648 */	
			0x12, 0x0,	/* FC_UP */
/* 650 */	NdrFcShort( 0xfffffe2c ),	/* Offset= -468 (182) */
/* 652 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 654 */	NdrFcLong( 0x0 ),	/* 0 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 664 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 666 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 668 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 670 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 672 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 682 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 684 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 686 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 688 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 690 */	NdrFcShort( 0x2 ),	/* Offset= 2 (692) */
/* 692 */	
			0x12, 0x0,	/* FC_UP */
/* 694 */	NdrFcShort( 0x214 ),	/* Offset= 532 (1226) */
/* 696 */	
			0x12, 0x0,	/* FC_UP */
/* 698 */	NdrFcShort( 0x1e ),	/* Offset= 30 (728) */
/* 700 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 702 */	NdrFcLong( 0x2f ),	/* 47 */
/* 706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 710 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 712 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 714 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 716 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 718 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 720 */	NdrFcShort( 0x1 ),	/* 1 */
/* 722 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 724 */	NdrFcShort( 0x4 ),	/* 4 */
/* 726 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 728 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 730 */	NdrFcShort( 0x10 ),	/* 16 */
/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 734 */	NdrFcShort( 0xa ),	/* Offset= 10 (744) */
/* 736 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 738 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 740 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (700) */
/* 742 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 744 */	
			0x12, 0x0,	/* FC_UP */
/* 746 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (718) */
/* 748 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 750 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 752 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 754 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 756 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 758 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 760 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 762 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 764 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 766 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 768 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 770 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 772 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 774 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 776 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 778 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x12, 0x0,	/* FC_UP */
/* 782 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (642) */
/* 784 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 786 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 788 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 790 */	NdrFcShort( 0x2 ),	/* Offset= 2 (792) */
/* 792 */	
			0x12, 0x0,	/* FC_UP */
/* 794 */	NdrFcShort( 0xfffffd9c ),	/* Offset= -612 (182) */
/* 796 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 798 */	NdrFcShort( 0x2 ),	/* Offset= 2 (800) */
/* 800 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 802 */	NdrFcLong( 0x0 ),	/* 0 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */
/* 810 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 812 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 814 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 816 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 818 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 820 */	NdrFcShort( 0x2 ),	/* Offset= 2 (822) */
/* 822 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 824 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 834 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 836 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 838 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 840 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 842 */	NdrFcShort( 0x2 ),	/* Offset= 2 (844) */
/* 844 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 846 */	NdrFcShort( 0x2 ),	/* Offset= 2 (848) */
/* 848 */	
			0x12, 0x0,	/* FC_UP */
/* 850 */	NdrFcShort( 0x178 ),	/* Offset= 376 (1226) */
/* 852 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 854 */	NdrFcShort( 0x2 ),	/* Offset= 2 (856) */
/* 856 */	
			0x12, 0x0,	/* FC_UP */
/* 858 */	NdrFcShort( 0x28 ),	/* Offset= 40 (898) */
/* 860 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 862 */	NdrFcShort( 0x10 ),	/* 16 */
/* 864 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 866 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 868 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 870 */	
			0x12, 0x0,	/* FC_UP */
/* 872 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (860) */
/* 874 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 876 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 878 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 880 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 882 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 884 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 886 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 888 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 890 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 892 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 900 */	NdrFcShort( 0x20 ),	/* 32 */
/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 904 */	NdrFcShort( 0x0 ),	/* Offset= 0 (904) */
/* 906 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 908 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 910 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 912 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 914 */	NdrFcShort( 0xfffffdc8 ),	/* Offset= -568 (346) */
/* 916 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 918 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x4 ),	/* 4 */
/* 922 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 926 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 928 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 930 */	NdrFcShort( 0x4 ),	/* 4 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	NdrFcShort( 0x1 ),	/* 1 */
/* 936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	0x12, 0x0,	/* FC_UP */
/* 942 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (898) */
/* 944 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 946 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 948 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 950 */	NdrFcShort( 0x8 ),	/* 8 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x6 ),	/* Offset= 6 (960) */
/* 956 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 958 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 960 */	
			0x11, 0x0,	/* FC_RP */
/* 962 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (918) */
/* 964 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 966 */	NdrFcShort( 0x4 ),	/* 4 */
/* 968 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 972 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 974 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 976 */	NdrFcShort( 0x4 ),	/* 4 */
/* 978 */	NdrFcShort( 0x0 ),	/* 0 */
/* 980 */	NdrFcShort( 0x1 ),	/* 1 */
/* 982 */	NdrFcShort( 0x0 ),	/* 0 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	0x12, 0x0,	/* FC_UP */
/* 988 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (728) */
/* 990 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 992 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 994 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 996 */	NdrFcShort( 0x8 ),	/* 8 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1006) */
/* 1002 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1004 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1006 */	
			0x11, 0x0,	/* FC_RP */
/* 1008 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (964) */
/* 1010 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 1012 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1014 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1016 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1018 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1020 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 1022 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1024 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (1010) */
			0x5b,		/* FC_END */
/* 1028 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1030 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1040 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1042 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1044 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1046 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1050 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1054 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1058 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1060 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1028) */
/* 1062 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1064 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1070 */	NdrFcShort( 0xa ),	/* Offset= 10 (1080) */
/* 1072 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1074 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1076 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (1016) */
/* 1078 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1080 */	
			0x11, 0x0,	/* FC_RP */
/* 1082 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1046) */
/* 1084 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1086 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1088 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1094 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1096 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1098 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1100 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1102 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1104 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1106 */	0x12, 0x0,	/* FC_UP */
/* 1108 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1084) */
/* 1110 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1112 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1114 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1118 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1122 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1124 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1128 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1130 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1132 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1134 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1136 */	0x12, 0x0,	/* FC_UP */
/* 1138 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1114) */
/* 1140 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1142 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1144 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1148 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1152 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1154 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1158 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1160 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1162 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1166 */	0x12, 0x0,	/* FC_UP */
/* 1168 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1144) */
/* 1170 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1172 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1174 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1176 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1178 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1182 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1184 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1188 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1190 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1192 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1194 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1196 */	0x12, 0x0,	/* FC_UP */
/* 1198 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1174) */
/* 1200 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1202 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1204 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1208 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1210 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1212 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1214 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1216 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1218 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1220 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1222 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1204) */
/* 1224 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1226 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1228 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1230 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1212) */
/* 1232 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1232) */
/* 1234 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1236 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xfffffb90 ),	/* Offset= -1136 (104) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0xfffffb7c ),	/* Offset= -1156 (96) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };



/* Standard interface: __MIDL_itf_ivalidator_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IValidator, ver. 0.0,
   GUID={0x63DF8730,0xDC81,0x4062,{0x84,0xA2,0x1F,0xF9,0x43,0xF5,0x9F,0xAC}} */

#pragma code_seg(".orpc")
static const unsigned short IValidator_FormatStringOffsetTable[] =
    {
    0,
    70
    };

static const MIDL_STUBLESS_PROXY_INFO IValidator_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IValidator_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IValidator_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IValidator_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IValidatorProxyVtbl = 
{
    &IValidator_ProxyInfo,
    &IID_IValidator,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IValidator::Validate */ ,
    (void *) (INT_PTR) -1 /* IValidator::FormatEventInfo */
};

const CInterfaceStubVtbl _IValidatorStubVtbl =
{
    &IID_IValidator,
    &IValidator_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _ivalidator_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IValidatorProxyVtbl,
    0
};

const CInterfaceStubVtbl * _ivalidator_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IValidatorStubVtbl,
    0
};

PCInterfaceName const _ivalidator_InterfaceNamesList[] = 
{
    "IValidator",
    0
};


#define _ivalidator_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _ivalidator, pIID, n)

int __stdcall _ivalidator_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_ivalidator_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo ivalidator_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _ivalidator_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _ivalidator_StubVtblList,
    (const PCInterfaceName * ) & _ivalidator_InterfaceNamesList,
    0, // no delegation
    & _ivalidator_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivehandler.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:16 2003
 */
/* Compiler settings for ivehandler.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivehandler_h__
#define __ivehandler_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __VEHandlerClass_FWD_DEFINED__
#define __VEHandlerClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class VEHandlerClass VEHandlerClass;
#else
typedef struct VEHandlerClass VEHandlerClass;
#endif /* __cplusplus */

#endif 	/* __VEHandlerClass_FWD_DEFINED__ */


#ifndef __IVEHandler_FWD_DEFINED__
#define __IVEHandler_FWD_DEFINED__
typedef interface IVEHandler IVEHandler;
#endif 	/* __IVEHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ivehandler_0000 */
/* [local] */ 

#pragma once
typedef struct tag_VerError
    {
    unsigned long flags;
    unsigned long opcode;
    unsigned long uOffset;
    unsigned long Token;
    unsigned long item1_flags;
    int *item1_data;
    unsigned long item2_flags;
    int *item2_data;
    } 	_VerError;

typedef _VerError VEContext;




extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_v0_0_s_ifspec;


#ifndef __VEHandlerLib_LIBRARY_DEFINED__
#define __VEHandlerLib_LIBRARY_DEFINED__

/* library VEHandlerLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VEHandlerLib;

EXTERN_C const CLSID CLSID_VEHandlerClass;

#ifdef __cplusplus

class DECLSPEC_UUID("856CA1B1-7DAB-11d3-ACEC-00C04F86C309")
VEHandlerClass;
#endif
#endif /* __VEHandlerLib_LIBRARY_DEFINED__ */

#ifndef __IVEHandler_INTERFACE_DEFINED__
#define __IVEHandler_INTERFACE_DEFINED__

/* interface IVEHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVEHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("856CA1B2-7DAB-11d3-ACEC-00C04F86C309")
    IVEHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VEHandler( 
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ SAFEARRAY * psa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReporterFtn( 
            /* [in] */ __int64 lFnPtr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVEHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVEHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVEHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVEHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *VEHandler )( 
            IVEHandler * This,
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ SAFEARRAY * psa);
        
        HRESULT ( STDMETHODCALLTYPE *SetReporterFtn )( 
            IVEHandler * This,
            /* [in] */ __int64 lFnPtr);
        
        END_INTERFACE
    } IVEHandlerVtbl;

    interface IVEHandler
    {
        CONST_VTBL struct IVEHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVEHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVEHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVEHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVEHandler_VEHandler(This,VECode,Context,psa)	\
    (This)->lpVtbl -> VEHandler(This,VECode,Context,psa)

#define IVEHandler_SetReporterFtn(This,lFnPtr)	\
    (This)->lpVtbl -> SetReporterFtn(This,lFnPtr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVEHandler_VEHandler_Proxy( 
    IVEHandler * This,
    /* [in] */ HRESULT VECode,
    /* [in] */ VEContext Context,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB IVEHandler_VEHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVEHandler_SetReporterFtn_Proxy( 
    IVEHandler * This,
    /* [in] */ __int64 lFnPtr);


void __RPC_STUB IVEHandler_SetReporterFtn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVEHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivehandler_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:16 2003
 */
/* Compiler settings for ivehandler.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_VEHandlerLib,0x856CA1B0,0x7DAB,0x11d3,0xAC,0xEC,0x00,0xC0,0x4F,0x86,0xC3,0x09);


MIDL_DEFINE_GUID(CLSID, CLSID_VEHandlerClass,0x856CA1B1,0x7DAB,0x11d3,0xAC,0xEC,0x00,0xC0,0x4F,0x86,0xC3,0x09);


MIDL_DEFINE_GUID(IID, IID_IVEHandler,0x856CA1B2,0x7DAB,0x11d3,0xAC,0xEC,0x00,0xC0,0x4F,0x86,0xC3,0x09);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\license.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:19 2003
 */
/* Compiler settings for license.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __license_h__
#define __license_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILicense_FWD_DEFINED__
#define __ILicense_FWD_DEFINED__
typedef interface ILicense ILicense;
#endif 	/* __ILicense_FWD_DEFINED__ */


#ifndef __License_FWD_DEFINED__
#define __License_FWD_DEFINED__

#ifdef __cplusplus
typedef class License License;
#else
typedef struct License License;
#endif /* __cplusplus */

#endif 	/* __License_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ILicense_INTERFACE_DEFINED__
#define __ILicense_INTERFACE_DEFINED__

/* interface ILicense */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ILicense;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B93F97E9-782F-11d3-9951-0000F805BFB0")
    ILicense : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeKey( 
            /* [retval][out] */ BSTR *pbKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLicenseVerified( 
            /* [retval][out] */ BOOL *pLicenseVerified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRuntimeKeyAvailable( 
            /* [retval][out] */ BOOL *pKeyAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILicenseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILicense * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILicense * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILicense * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeKey )( 
            ILicense * This,
            /* [retval][out] */ BSTR *pbKey);
        
        HRESULT ( STDMETHODCALLTYPE *IsLicenseVerified )( 
            ILicense * This,
            /* [retval][out] */ BOOL *pLicenseVerified);
        
        HRESULT ( STDMETHODCALLTYPE *IsRuntimeKeyAvailable )( 
            ILicense * This,
            /* [retval][out] */ BOOL *pKeyAvailable);
        
        END_INTERFACE
    } ILicenseVtbl;

    interface ILicense
    {
        CONST_VTBL struct ILicenseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILicense_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILicense_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILicense_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILicense_GetRuntimeKey(This,pbKey)	\
    (This)->lpVtbl -> GetRuntimeKey(This,pbKey)

#define ILicense_IsLicenseVerified(This,pLicenseVerified)	\
    (This)->lpVtbl -> IsLicenseVerified(This,pLicenseVerified)

#define ILicense_IsRuntimeKeyAvailable(This,pKeyAvailable)	\
    (This)->lpVtbl -> IsRuntimeKeyAvailable(This,pKeyAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILicense_GetRuntimeKey_Proxy( 
    ILicense * This,
    /* [retval][out] */ BSTR *pbKey);


void __RPC_STUB ILicense_GetRuntimeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILicense_IsLicenseVerified_Proxy( 
    ILicense * This,
    /* [retval][out] */ BOOL *pLicenseVerified);


void __RPC_STUB ILicense_IsLicenseVerified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILicense_IsRuntimeKeyAvailable_Proxy( 
    ILicense * This,
    /* [retval][out] */ BOOL *pKeyAvailable);


void __RPC_STUB ILicense_IsRuntimeKeyAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILicense_INTERFACE_DEFINED__ */



#ifndef __LicenseLib_LIBRARY_DEFINED__
#define __LicenseLib_LIBRARY_DEFINED__

/* library LicenseLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_LicenseLib;

EXTERN_C const CLSID CLSID_License;

#ifdef __cplusplus

class DECLSPEC_UUID("B1923C48-8D9F-11d3-995F-0000F805BFB0")
License;
#endif
#endif /* __LicenseLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\license_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:19 2003
 */
/* Compiler settings for license.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format