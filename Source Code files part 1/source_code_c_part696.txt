MyExit;
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl), (void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIFrameRateControl=0x%08lX", _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the format control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(IID_IAMStreamConfig, (void **)&m_pIAMStreamConfig)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIAMStreamConfig=0x%08lX", _fx_, m_pIAMStreamConfig));
	}
	else
	{
		m_pIAMStreamConfig = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the video control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IVideoControl), (void **)&m_pIVideoControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIVideoControl=0x%08lX", _fx_, m_pIVideoControl));
	}
	else
	{
		m_pIVideoControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnDisconnect()
{
	FX_ENTRY("CPreviewProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIFrameRateControl", _fx_));
	}

	if (!m_pIAMStreamConfig)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMStreamConfig->Release();
		m_pIAMStreamConfig = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMStreamConfig", _fx_));
	}

	if (!m_pIVideoControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIVideoControl->Release();
		m_pIVideoControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIVideoControl", _fx_));
	}

	// Release format memory
	if (m_CurrentMediaType)
	{
		DeleteMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	int		j;
	TCHAR	buf[32];

	FX_ENTRY("CPreviewProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Initialize format control structures
	m_hWndFormat = GetDlgItem(m_hWnd, IDC_FORMAT_Compression);

	// Disable everything if we didn't initialize correctly
	if (!m_pIAMStreamConfig || (FAILED (Hr = InitialRangeScan())))
	{
		EnableWindow(m_hWndFormat, FALSE);
	}
	else
	{
		// Update the content of the format combo box
		ComboBox_ResetContent(m_hWndFormat);
		for (j = 0; j < m_RangeCount; j++)
		{
			if (IsEqualGUID(m_SubTypeList[j], MEDIASUBTYPE_H263_V1))
				wsprintf (buf, "%s %ldx%ld", "H.263", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_H263_V2))
				wsprintf (buf, "%s %ldx%ld", "H.263+", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_H261))
				wsprintf (buf, "%s %ldx%ld", "H.261", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YVU9))
				wsprintf (buf, "%s %ldx%ld", "YVU9", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YUY2))
				wsprintf (buf, "%s %ldx%ld", "YUY2", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YVYU))
				wsprintf (buf, "%s %ldx%ld", "YVYU", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_UYVY))
				wsprintf (buf, "%s %ldx%ld", "UYVY", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YV12))
				wsprintf (buf, "%s %ldx%ld", "YV12", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_I420))
				wsprintf (buf, "%s %ldx%ld", "I420", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_IYUV))
				wsprintf (buf, "%s %ldx%ld", "IYUV", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YV12))
				wsprintf (buf, "%s %ldx%ld", "YV12", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB4))
				wsprintf (buf, "%s %ldx%ld", "RGB4", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB8))
				wsprintf (buf, "%s %ldx%ld", "RGB8", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB555))
				wsprintf (buf, "%s %ldx%ld", "RGB16", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB565))
				wsprintf (buf, "%s %ldx%ld", "RGB16", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB24))
				wsprintf (buf, "%s %ldx%ld", "RGB24", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_UYVY))
				wsprintf (buf, "%s %ldx%ld", "UYVY", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else
				wsprintf (buf, "%s %ldx%ld", "Unknown", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);

			ComboBox_AddString(m_hWndFormat, buf);

			if (m_CurrentMediaType->subtype == m_SubTypeList[j] && HEADER(m_CurrentMediaType->pbFormat)->biWidth == m_FrameSizeList[j].cx  && HEADER(m_CurrentMediaType->pbFormat)->biHeight == m_FrameSizeList[j].cy)
			{
				ComboBox_SetCurSel(m_hWndFormat, j);
				m_SubTypeCurrent = m_SubTypeList[j];
				m_FrameSizeCurrent = m_FrameSizeList[j];
			}
		}

		// Update current format
		OnFormatChanged();

		// Remember the original format
		m_OriginalFormat = m_CurrentFormat;
	}

	// Create the controls for the properties
	if (m_Controls[0] = new CPreviewProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, IDC_Preview_FrameRate, m_pIFrameRateControl, m_pIVideoControl))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[0]=0x%08lX", _fx_, m_Controls[0]));

		if (m_Controls[1] = new CPreviewProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipVertical, 0, 0, IDC_Preview_FlipVertical, m_pIFrameRateControl, m_pIVideoControl))
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[1]=0x%08lX", _fx_, m_Controls[1]));

			if (m_Controls[2] = new CPreviewProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipHorizontal, 0, 0, IDC_Preview_FlipHorizontal, m_pIFrameRateControl, m_pIVideoControl))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[2]=0x%08lX", _fx_, m_Controls[2]));

				if (m_Controls[3] = new CPreviewProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, IDC_Preview_CurrentFrameRate, m_pIFrameRateControl, m_pIVideoControl))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[2]=0x%08lX", _fx_, m_Controls[2]));
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
					delete m_Controls[0], m_Controls[0] = NULL;
					delete m_Controls[1], m_Controls[1] = NULL;
					delete m_Controls[2], m_Controls[2] = NULL;
					Hr = E_OUTOFMEMORY;
					goto MyExit;
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				delete m_Controls[0], m_Controls[0] = NULL;
				delete m_Controls[1], m_Controls[1] = NULL;
				Hr = E_OUTOFMEMORY;
				goto MyExit;
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
			delete m_Controls[0], m_Controls[0] = NULL;
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = TRUE;
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CPreviewProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnDeactivate | This
 *    method is used to retrieve the current media format used by the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::GetCurrentMediaType(void)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CPreviewProperties::GetCurrentMediaType")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (m_CurrentMediaType)
	{
		DeleteMediaType (m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (FAILED (Hr = m_pIAMStreamConfig->GetFormat((AM_MEDIA_TYPE **)&m_CurrentMediaType)))
	{
		// Otherwise, just get the first enumerated media type
		VIDEO_STREAM_CONFIG_CAPS RangeCaps;

		if (FAILED (Hr = m_pIAMStreamConfig->GetStreamCaps(0, (AM_MEDIA_TYPE **)&m_CurrentMediaType, (BYTE *)&RangeCaps)))
		{
			m_CurrentMediaType = NULL;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnFormatChanged | This
 *    method is used to retrieve the format selected by the user.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnFormatChanged()
{
	HRESULT	Hr = E_UNEXPECTED;
	int		j;

	FX_ENTRY("CPreviewProperties::OnFormatChanged")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIAMStreamConfig)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Associate the current compression index with the right range index
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	ASSERT (m_CurrentFormat >= 0 && m_CurrentFormat < m_RangeCount);
	if (m_CurrentFormat >= 0 && m_CurrentFormat < m_RangeCount)
	{
		m_SubTypeCurrent = m_SubTypeList[m_CurrentFormat];
		m_FrameSizeCurrent = m_FrameSizeList[m_CurrentFormat];

		for (j = 0; j < m_RangeCount; j++)
		{
			if (m_SubTypeList[j] == m_SubTypeCurrent)
			{
				CMediaType *pmt = NULL;

				Hr = m_pIAMStreamConfig->GetStreamCaps(j, (AM_MEDIA_TYPE **)&pmt, (BYTE *)&m_RangeCaps);

				DeleteMediaType (pmt);
			}
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | InitialRangeScan | This
 *    method is used to retrieve the list of supported formats on the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::InitialRangeScan()
{
	HRESULT			Hr = NOERROR;
	int				lSize;
	int				j;
	AM_MEDIA_TYPE	*pmt = NULL;

	FX_ENTRY("CPreviewProperties::InitialRangeScan")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIAMStreamConfig)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	Hr = m_pIAMStreamConfig->GetNumberOfCapabilities(&m_RangeCount, &lSize);
	ASSERT (lSize >= sizeof (VIDEO_STREAM_CONFIG_CAPS) && SUCCEEDED (Hr));
	if (lSize < sizeof (VIDEO_STREAM_CONFIG_CAPS) || !SUCCEEDED(Hr))
	{
		Hr = E_FAIL;
		goto MyExit;
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   NumberOfRanges=%d", _fx_, m_RangeCount));

	if (!(m_SubTypeList = new GUID [m_RangeCount]))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: new failed", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	if (!(m_FrameSizeList = new SIZE [m_RangeCount]))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: new failed", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	for (j = 0; j < m_RangeCount; j++)
	{
		pmt = NULL;

		Hr = m_pIAMStreamConfig->GetStreamCaps(j, (AM_MEDIA_TYPE **)&pmt, (BYTE *)&m_RangeCaps);

		ASSERT(SUCCEEDED (Hr));
		ASSERT(pmt);
		ASSERT(pmt->majortype == MEDIATYPE_Video);
		ASSERT(pmt->formattype == FORMAT_VideoInfo);

		m_SubTypeList[j] = pmt->subtype;
		m_FrameSizeList[j].cx = HEADER(pmt->pbFormat)->biWidth;
		m_FrameSizeList[j].cy = HEADER(pmt->pbFormat)->biHeight;

		DeleteMediaType(pmt);
	}

	// Get default format
	Hr = GetCurrentMediaType();

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;

	FX_ENTRY("CPreviewProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Apply format changes on video stream
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	
	// Only apply change if the format is different
	if (m_CurrentFormat != m_OriginalFormat)
	{
		if (SUCCEEDED (Hr = m_pIAMStreamConfig->GetStreamCaps(m_CurrentFormat, (AM_MEDIA_TYPE **) &pmt, (BYTE *)&m_RangeCaps)))
		{
			ASSERT(pmt && *pmt->FormatType() == FORMAT_VideoInfo);

			if (pmt && *pmt->FormatType() == FORMAT_VideoInfo)
			{
				if (FAILED(Hr = m_pIAMStreamConfig->SetFormat(pmt)))
				{
					TCHAR TitleBuf[80];
					TCHAR TextBuf[80];

					LoadString(g_hInst, IDS_ERROR_CONNECTING_TITLE, TitleBuf, sizeof (TitleBuf));
					LoadString(g_hInst, IDS_ERROR_CONNECTING, TextBuf, sizeof (TextBuf));
					MessageBox (NULL, TextBuf, TitleBuf, MB_OK);
				}
			}

			// Free some memory that was allocated by GetStreamCaps
			if (pmt)
				DeleteMediaType(pmt);

			// Update our copy of the current format
			GetCurrentMediaType();

			// Update original format
			m_OriginalFormat = m_CurrentFormat;
		}
	}

	// Apply target frame rate changes on video stream
	for (j = 0; j < m_NumProperties; j++)
	{
		ASSERT(m_Controls[j]);
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc BOOL | CPreviewProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CPreviewProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// This is called before Activate...
			m_hWnd = hWnd;
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
						SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.
			if (m_fActivated)
			{
				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					case IDC_FORMAT_Compression:
						if (HIWORD(wParam) == CBN_SELCHANGE)
						{
							OnFormatChanged();
						}
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc BOOL | CPreviewProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CPreviewProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\procampp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.cpp | Source file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | CProcAmpProperty | This
 *    method is the constructor for video proc amp control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i IAMVideoProcAmp> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IAMVideoProcAmp* | pInterface | Specifies a pointer to the
 *    <i IAMVideoProcAmp> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CProcAmpProperty::CProcAmpProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | ~CProcAmpProperty | This
 *    method is the destructor for video proc amp control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::~CProcAmpProperty()
{
	FX_ENTRY("CProcAmpProperty::~CProcAmpProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get(m_IDProperty, &m_CurrentValue, &m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set(m_IDProperty, m_CurrentValue, m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange(m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CProcAmpProperty::CanAutoControl(void)
{
	FX_ENTRY("CProcAmpProperty::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_CapsFlags & VideoProcAmp_Flags_Auto;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | CanAutoControl | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CProcAmpProperty::GetAuto(void)
{
	FX_ENTRY("CProcAmpProperty::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	GetValue();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_CurrentFlags & VideoProcAmp_Flags_Auto; 
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CProcAmpProperty::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CProcAmpProperty::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_CurrentFlags = (fAuto ? VideoProcAmp_Flags_Auto : 0);
	SetValue();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc CUnknown* | CProcAmpProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a Network Statistics
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CProcAmpPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CProcAmpPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CProcAmpProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CProcAmpProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CProcAmpProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | CProcAmpProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Video Proc Amp Property Page"), pUnk, IDD_VideoProcAmpProperties, IDS_PROCAMPPROPNAME)
{
	FX_ENTRY("CProcAmpProperties::CProcAmpProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIAMVideoProcAmp = NULL;
	m_NumProperties = NUM_PROCAMP_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | ~CProcAmpProperties | This
 *    method is the destructor for the video proc amp control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::~CProcAmpProperties()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::~CProcAmpProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the video proc amp interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(IID_IAMVideoProcAmp,(void **)&m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIAMVideoProcAmp=0x%08lX", _fx_, m_pIAMVideoProcAmp));
	}
	else
	{
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDisconnect()
{
	FX_ENTRY("CProcAmpProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIAMVideoProcAmp)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMVideoProcAmp->Release();
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMVideoProcAmp", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CProcAmpProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CProcAmpProperty(m_hwnd, IDC_Brightness_Label, IDC_Brightness_Minimum, IDC_Brightness_Maximum, IDC_Brightness_Default, IDC_Brightness_Stepping, IDC_Brightness_Edit, IDC_Brightness_Slider, 0, VideoProcAmp_Brightness, IDC_Brightness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Brightness] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Brightness]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CProcAmpProperty(m_hwnd, IDC_Contrast_Label, IDC_Contrast_Minimum, IDC_Contrast_Maximum, IDC_Contrast_Default, IDC_Contrast_Stepping, IDC_Contrast_Edit, IDC_Contrast_Slider, 0, VideoProcAmp_Contrast, IDC_Contrast_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Contrast] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Contrast]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CProcAmpProperty(m_hwnd, IDC_Hue_Label, IDC_Hue_Minimum, IDC_Hue_Maximum, IDC_Hue_Default, IDC_Hue_Stepping, IDC_Hue_Edit, IDC_Hue_Slider, 0, VideoProcAmp_Hue, IDC_Hue_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Hue] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Hue]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CProcAmpProperty(m_hwnd, IDC_Saturation_Label, IDC_Saturation_Minimum, IDC_Saturation_Maximum, IDC_Saturation_Default, IDC_Saturation_Stepping, IDC_Saturation_Edit, IDC_Saturation_Slider, 0, VideoProcAmp_Saturation, IDC_Saturation_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Saturation] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Saturation]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CProcAmpProperty(m_hwnd, IDC_Sharpness_Label, IDC_Sharpness_Minimum, IDC_Sharpness_Maximum, IDC_Sharpness_Default, IDC_Sharpness_Stepping, IDC_Sharpness_Edit, IDC_Sharpness_Slider, 0, VideoProcAmp_Sharpness, IDC_Sharpness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Sharpness] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Sharpness]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CProcAmpProperty(m_hwnd, IDC_Gamma_Label, IDC_Gamma_Minimum, IDC_Gamma_Maximum, IDC_Gamma_Default, IDC_Gamma_Stepping, IDC_Gamma_Edit, IDC_Gamma_Slider, 0, VideoProcAmp_Gamma, IDC_Gamma_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Gamma] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Gamma]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CProcAmpProperty(m_hwnd, IDC_ColorEnable_Label, IDC_ColorEnable_Minimum, IDC_ColorEnable_Maximum, IDC_ColorEnable_Default, IDC_ColorEnable_Stepping, IDC_ColorEnable_Edit, IDC_ColorEnable_Slider, 0, VideoProcAmp_ColorEnable, IDC_ColorEnable_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_ColorEnable] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_ColorEnable]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CProcAmpProperty(m_hwnd, IDC_WhiteBalance_Label, IDC_WhiteBalance_Minimum, IDC_WhiteBalance_Maximum, IDC_WhiteBalance_Default, IDC_WhiteBalance_Stepping, IDC_WhiteBalance_Edit, IDC_WhiteBalance_Slider, 0, VideoProcAmp_WhiteBalance, IDC_WhiteBalance_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_WhiteBalance] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_WhiteBalance]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[8] = new CProcAmpProperty(m_hwnd, IDC_BacklightComp_Label, IDC_BacklightComp_Minimum, IDC_BacklightComp_Maximum, IDC_BacklightComp_Default, IDC_BacklightComp_Stepping, IDC_BacklightComp_Edit, IDC_BacklightComp_Slider, 0, VideoProcAmp_BacklightCompensation, IDC_BacklightComp_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_BacklightComp] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_BacklightComp]=0x%08lX", _fx_, m_Controls[6]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		ASSERT(m_Controls[j]);
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CProcAmpProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			// Process all of the Trackbar messages
			for (j = 0; j < m_NumProperties; j++)
			{
				ASSERT(m_Controls[j]);
				if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
				{
					m_Controls[j]->OnScroll(uMsg, wParam, lParam);
					SetDirty();
				}
			}
			OnApplyChanges();
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			// Process all of the auto checkbox messages
			for (j = 0; j < m_NumProperties; j++)
			{
				if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
				{
					m_Controls[j]->OnAuto(uMsg, wParam, lParam);
					SetDirty();
					break;
				}
			}

			// Process all of the edit box messages
			for (j = 0; j < m_NumProperties; j++)
			{
				if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
				{
					m_Controls[j]->OnEdit(uMsg, wParam, lParam);
					SetDirty();
					break;
				}
			}

			switch (LOWORD(wParam))
			{
				case IDC_CONTROL_DEFAULT:
					for (j = 0; j < m_NumProperties; j++)
					{
						if (m_Controls[j])
							m_Controls[j]->OnDefault();
					}
					break;

				default:
					break;
			}

			OnApplyChanges();
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CProcAmpProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\procampp.h ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.h | Header file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _PROCAMPP_H_
#define _PROCAMPP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_PROCAMP_CONTROLS (VideoProcAmp_BacklightCompensation + 1)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperty | This class implements handling of a
 *    single video proc amp control property in a property page.
 *
 *  @mdata int | CProcAmpProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperty | m_pInterface | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperty : public CPropertyEditor 
{
	public:
	CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface);
	~CProcAmpProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IAMVideoProcAmp *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i IAMVideoProcAmp> implementation.
 *
 *  @mdata int | CProcAmpProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperties | m_pIAMVideoProcAmp | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @mdata CProcAmpProperty * | CProcAmpProperties | m_Controls[NUM_PROCAMP_CONTROLS] | Array
 *    of video proc amp properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperties : public CBasePropertyPage
{
	public:
	CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CProcAmpProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IAMVideoProcAmp *m_pIAMVideoProcAmp;
	CProcAmpProperty *m_Controls[NUM_PROCAMP_CONTROLS];
};

#endif // USE_PROPERTY_PAGES

#endif // _PROCAMPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\procutil.h ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.h | Header file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#ifndef _PROCUTIL_H_
#define _PROCUTIL_H_

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed);

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

// CallWithSEH is a utility function to call a function with structured exception handling
extern "C" DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void* pv, INEXCEPTION InException);
extern "C" WORD _cdecl is_cyrix(void);
extern "C" DWORD _cdecl get_nxcpu_type(void);

#endif // _PROCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\progref.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROGREF
 *
 *  @module ProgRef.cpp | Source file for the <c CCapturePin> class methods
 *    used to implement the video capture output pin progressive refinement
 *    methods.
 *
 *  @comm Understand how to make this work on a still-pin
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROGRESSIVE_REFINEMENT

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | doOneProgression | This
 *    method is used to command the compressed still-image output pin to
 *    begin producing a progressive refinement sequence for one picture.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::doOneProgression()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::doOneProgression")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | doContinuousProgressions | This
 *    method is used to command the compressed still-image output pin to
 *    begin producing progressive refinement sequences for several pictures.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::doContinuousProgressions()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::doContinuousProgressions")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | doOneIndependentProgression | This
 *    method is used to command the compressed still-image output pin to begin
 *    an independent progressive refinement sequence for one Intra picture.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::doOneIndependentProgression()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::doOneIndependentProgression")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | doContinuousIndependentProgressions | This
 *    method is used to command the compressed still-image output pin to
 *    begin an independent progressive refinement sequence several Intra
 *    pictures.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::doContinuousIndependentProgressions()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::doContinuousIndependentProgressions")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | progressiveRefinementAbortOne | This
 *    method is used to command the compressed still-image output pin to
 *    terminate a progressive refinement sequence for the current picture.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::progressiveRefinementAbortOne()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::progressiveRefinementAbortOne")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPROGREFMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | progressiveRefinementAbortContinuous | This
 *    method is used to command the compressed still-image output pin to
 *    terminate a progressive refinement sequence for all pictures.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::progressiveRefinementAbortContinuous()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::progressiveRefinementAbortContinuous")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\progrefp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROGREFP
 *
 *  @module ProgRefP.cpp | Source file for the <c CProgRefProperties>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i IProgressiveRefinement>.
 *
 *  @comm This code tests the TAPI Capture Pin <i IProgressiveRefinement>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_PROGRESSIVE_REFINEMENT

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc CUnknown* | CProgRefProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a Progressive Refinement
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CProgRefPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CProgRefPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CProgRefProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CProgRefProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CProgRefProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc void | CProgRefProperties | CProgRefProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProgRefProperties::CProgRefProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Progressive Refinement Property Page"), pUnk, IDD_ProgRefinemntProperties, IDS_PROGREFPROPNAME)
{
	FX_ENTRY("CProgRefProperties::CProgRefProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIProgRef = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc void | CProgRefProperties | ~CProgRefProperties | This
 *    method is the destructor for progressive refinement property page. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProgRefProperties::~CProgRefProperties()
{
	FX_ENTRY("CProgRefProperties::~CProgRefProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIProgRef)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already released!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIProgRef->Release();
		m_pIProgRef = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIProgRef", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc HRESULT | CProgRefProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProgRefProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProgRefProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the progressive refinement interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IProgressiveRefinement),(void **)&m_pIProgRef)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIProgRef=0x%08lX", _fx_, m_pIProgRef));
	}
	else
	{
		m_pIProgRef = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc HRESULT | CProgRefProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProgRefProperties::OnDisconnect()
{
	FX_ENTRY("CProgRefProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIProgRef)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIProgRef->Release();
		m_pIProgRef = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIProgRef", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROGREFPMETHOD
 *
 *  @mfunc BOOL | CProgRefProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CProgRefProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_OneProg), (BOOL)m_pIProgRef);
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_ContProg), (BOOL)m_pIProgRef);
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_IndProg), (BOOL)m_pIProgRef);
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_ContIndProg), (BOOL)m_pIProgRef);
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_AbortOne), (BOOL)m_pIProgRef);
			EnableWindow(GetDlgItem(hWnd, IDC_ProgRef_AbortCont), (BOOL)m_pIProgRef);
			return TRUE; // Don't call setfocus

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			switch (LOWORD(wParam))
			{
				case IDC_ProgRef_OneProg:
					if (m_pIProgRef)
						m_pIProgRef->doOneProgression();
					break;

				case IDC_ProgRef_ContProg:
					if (m_pIProgRef)
						m_pIProgRef->doContinuousProgressions();
					break;

				case IDC_ProgRef_IndProg:
					if (m_pIProgRef)
						m_pIProgRef->doOneIndependentProgression();
					break;

				case IDC_ProgRef_ContIndProg:
					if (m_pIProgRef)
						m_pIProgRef->doContinuousIndependentProgressions();
					break;

				case IDC_ProgRef_AbortOne:
					if (m_pIProgRef)
						m_pIProgRef->progressiveRefinementAbortOne();
					break;

				case IDC_ProgRef_AbortCont:
					if (m_pIProgRef)
						m_pIProgRef->progressiveRefinementAbortContinuous();
					break;

				default:
					break;
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\progrefp.h ===
/****************************************************************************
 *  @doc INTERNAL PROGREFP
 *
 *  @module ProgRefP.h | Header file for the <c CProgRefProperties>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i IProgressiveRefinement>.
 *
 *  @comm This code tests the TAPI Capture Pin <i IProgressiveRefinement>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _PROGREFP_H_
#define _PROGREFP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_PROGRESSIVE_REFINEMENT

/****************************************************************************
 *  @doc INTERNAL CPROGREFPCLASS
 *
 *  @class CProgRefProperties | This class implements a property page
 *    to test the new TAPI internal interface <i IProgressiveRefinement>.
 *
 *  @mdata IProgressiveRefinement* | CProgRefProperties | m_pIProgRef | Pointer
 *    to the <i IProgressiveRefinement> interface.
 *
 *  @comm This code tests the TAPI Capture Pin <i IProgressiveRefinement>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/
class CProgRefProperties : public CBasePropertyPage
{
	public:
	CProgRefProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CProgRefProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	IProgressiveRefinement *m_pIProgRef;
};

#endif // USE_PROGRESSIVE_REFINEMENT

#endif // USE_PROPERTY_PAGES

#endif // _PROGREFP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\procutil.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.cpp | Source file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#include "Precomp.h"

#define LEGACY_DIVISOR	8

DWORD __stdcall FindTSC (LPVOID pvRefData)
{
	   _asm
	   {
		   mov     eax,1
		   _emit   00Fh     ;; CPUID
		   _emit   0A2h

    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family
		   mov     ecx,pvRefData
		   mov     [ecx],edx
		   mov	   [ecx][4],eax
	   }

	   return 1;
}

DWORD __stdcall NoCPUID (LPEXCEPTION_RECORD per,PCONTEXT pctx)
{
    return 0;
}
//
//  GetProcessorSpeed(dwFamily)
//
//  get the processor speed in MHz, only works on Pentium or better
//  machines.
//
//  Will put 3, or 4 in dwFamily for 386/486, but no speed.
//  returns speed and family for 586+
//
//  - thanks to toddla, modified by mikeg
//

int __stdcall GetProcessorSpeed(int *pdwFamily)
{
    SYSTEM_INFO si;
    __int64	start, end, freq;
    int 	flags,family;
    int 	time;
    int 	clocks;
    DWORD	oldclass;
    HANDLE      hprocess;
    int     pRef[2];

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {
	*pdwFamily=si.wProcessorLevel;
    }else {
    	//Ok, we're on Win95
    	switch (si.dwProcessorType) {
    	       case PROCESSOR_INTEL_386:
    		   *pdwFamily=3;
    		   break;

    	       case PROCESSOR_INTEL_486:
    		   *pdwFamily=4;
    		   break;
    	       default:
    		   *pdwFamily=0;
    		   break;
    	}
    }

    // make sure this is a INTEL Pentium (or clone) or higher.
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    // see if this chip supports rdtsc before using it.
    if (!CallWithSEH (FindTSC,&pRef,NoCPUID))     {
        flags=0;
    } else {
    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family. Pull them out and use them
        flags=pRef[0];
        family=pRef[1];
    }

    if (!(flags & 0x10))
        return 0;

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*pdwFamily)) {
       *pdwFamily=(family& 0x0F00) >> 8;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    return (clocks + time/2) / time;
}

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed)
{
	int dwProcessorSpeed;
	int dwFamily;

	dwProcessorSpeed=GetProcessorSpeed(&dwFamily);

	*pdwNormalizedSpeed=dwProcessorSpeed;

	if (dwFamily > 5) {
	   //Ok, TWO things.
	   // ONE DO NOT DO FP!
	   // Two for the same Mhz assume a 686 is 1.3 times as fast as a 586 and a 786 is 1.6 times, etc.
	   *pdwNormalizedSpeed=(ULONG) (((10+3*(dwFamily-5))*dwProcessorSpeed)/10);
	}

	if (dwFamily < 5) {
	  //until we have 386/486 timing code, assume 486=50,386=37
	  //11/17/2000(Fri): 386/486 anyway not supported anymore at the OS level
	  if (dwFamily > 3) {
           //Cyrix, (5x86)? check before making default assignment
           if (is_cyrix()) {
               if (*pdwNormalizedSpeed==0) {
                   dwFamily=5;
                   *pdwNormalizedSpeed=100;
                   return NOERROR;
               }
           }
      }

	  *pdwNormalizedSpeed= (dwFamily*100)/LEGACY_DIVISOR;

      if (get_nxcpu_type ()) {
        //Double the perceived value on a NexGen
        *pdwNormalizedSpeed *=2;
      }
   }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TAPIVCap.rc
//
#define IDD_CAMERA_CONTROL             1000
#define IDD_VIDEO_SETTINGS             1001
#define IDD_TEST_CAPTURE_PIN_PROPERTIES	102
#define IDD_TEST_PREVIEW_PIN_PROPERTIES	103
#define IDD_TEST_STILL_IMAGE_PIN_PROPERTIES 104
#define IDD_TEST_RTPPD_PIN_PROPERTIES	105
#define IDC_DEFAULT                     106
#define IDC_DEVICE_SETTINGS             107
#define IDC_CAMERA_CONTROLS             108
#define IDC_BRIGHTNESS                  110
#define IDC_CONTRAST                    111
#define IDC_HUE                         112
#define IDC_SATURATION                  113
#define IDC_SHARPNESS                   114
#define IDC_WHITE                       115
#define IDC_PAN                         116
#define IDC_TILT                        117
#define IDC_ROLL                        118
#define IDC_HUE_STATIC                  120
#define IDC_BRIGHTNESS_STATIC           121
#define IDC_CONTRAST_STATIC             122
#define IDC_SATURATION_STATIC           123
#define IDC_SHARPNESS_STATIC            124
#define IDC_WHITE_STATIC                125
#define IDC_GAMMA_STATIC                126
#define IDC_BACKLIGHT_STATIC            127
#define IDC_ZOOM_STATIC                 128
#define IDC_FOCUS_STATIC                129
#define IDC_TILT_STATIC                 130
#define IDC_EXPOSURE_STATIC             131
#define IDC_IRIS_STATIC                 132
#define IDC_PAN_STATIC                  133
#define IDC_ROLL_STATIC                 134
#define IDC_SLIDER_WHITEBAL             140
#define IDC_SLIDER_BRIGHTNESS           141
#define IDC_SLIDER_CONTRAST             142
#define IDC_SLIDER_HUE                  143
#define IDC_SLIDER_SATURATION           144
#define IDC_SLIDER_SHARPNESS            145
#define IDC_SLIDER_FOCUS                146
#define IDC_SLIDER_GAMMA                147
#define IDC_SLIDER_BACKLIGHT            148
#define IDC_SLIDER_ZOOM                 149
#define IDC_SLIDER_TILT                 150
#define IDC_SLIDER_EXPOSURE             151
#define IDC_SLIDER_IRIS                 152
#define IDC_SLIDER_PAN                  153
#define IDC_SLIDER_ROLL                 154
#define IDC_TXT_HUE_CURRENT             160
#define IDC_TXT_BRIGHTNESS_CURRENT      161
#define IDC_TXT_CONTRAST_CURRENT        162
#define IDC_TXT_SATURATION_CURRENT      163
#define IDC_TXT_SHARPNESS_CURRENT       164
#define IDC_TXT_ZOOM_CURRENT            165
#define IDC_TXT_WHITE_CURRENT           166
#define IDC_TXT_FOCUS_CURRENT           167
#define IDC_TXT_GAMMA_CURRENT           168
#define IDC_TXT_BACKLIGHT_CURRENT       169
#define IDC_TXT_TILT_CURRENT            170
#define IDC_TXT_EXPOSURE_CURRENT        171
#define IDC_TXT_IRIS_CURRENT            172
#define IDC_TXT_PAN_CURRENT             173
#define IDC_TXT_ROLL_CURRENT            174
#define IDC_CB_AUTO_BRIGHTNESS          180
#define IDC_CB_AUTO_CONTRAST            181
#define IDC_CB_AUTO_HUE                 182
#define IDC_CB_AUTO_SATURATION          183
#define IDC_CB_AUTO_SHARPNESS           184
#define IDC_CB_AUTO_WHITEBAL            185
#define IDC_CB_AUTO_GAMMA               186
#define IDC_CB_AUTO_BACKLIGHT           187
#define IDC_CB_AUTO_ZOOM                188
#define IDC_CB_AUTO_FOCUS               189
#define IDC_CB_AUTO_TILT                190
#define IDC_CB_AUTO_EXPOSURE            191
#define IDC_CB_AUTO_IRIS                192
#define IDC_CB_AUTO_PAN                 193
#define IDC_CB_AUTO_ROLL                194
#define IDS_ZOOM                        200
#define IDS_FOCUS                       201
#define IDS_TILT                        202
#define IDS_EXPOSURE                    203
#define IDS_IRIS                        204
#define IDS_PAN                         205
#define IDS_ROLL                        206
#define IDS_BRIGHTNESS                  207
#define IDS_CONTRAST                    208
#define IDS_HUE                         209
#define IDS_SATURATION                  210
#define IDS_SHARPNESS                   211
#define IDS_WHITEBAL                    212
#define IDS_GAMMA                       213
#define IDS_BACKLIGHT                   214
#define IDS_UNKNOWN_DEVICE_NAME         215

#define IDC_STATIC                      -1

#define IDS_M263_Capture_QCIF			20
#define IDS_M263_Capture_CIF			21
#define IDS_M263_Capture_SQCIF			22
#define IDS_M261_Capture_QCIF			23
#define IDS_M261_Capture_CIF			24

#ifdef USE_PROPERTY_PAGES

#define IDS_BITRATECONTROLPROPNAME      1
#define IDS_NETWORKSTATSPROPNAME        2
#define IDS_PROGREFPROPNAME             3
#define IDS_CAMERACONTROLPROPNAME       4
#define IDS_CAPTUREFORMATSPROPNAME      5
#define IDS_PREVIEWFORMATSPROPNAME      6
#define IDS_DEVICEPROPNAME              7
#define IDS_CPUCPROPNAME                8
#define IDS_PROCAMPPROPNAME				9
#define IDS_RTPPDPROPNAME				10
#define IDS_ERROR_CONNECTING_TITLE      11
#define IDS_ERROR_CONNECTING            12

#ifdef USE_NETWORK_STATISTICS
#define IDD_NetworkStatsProperties      100
#endif
#define IDD_CaptureFormatProperties     101
#define IDD_PreviewFormatProperties     102
#define IDD_CameraControlProperties     103
#ifdef USE_PROGRESSIVE_REFINEMENT
#define IDD_ProgRefinemntProperties     104
#endif
#define IDD_CaptureDeviceProperties     105
#ifdef USE_CPU_CONTROL
#define IDD_CPUControlProperties        106
#endif
#define IDD_VideoProcAmpProperties      107
#define IDD_RtpPdControlProperties      108

#define IDC_BitrateControl_Label        200
#define IDC_BitrateControl_Minimum      201
#define IDC_BitrateControl_Maximum      202
#define IDC_BitrateControl_Default      203
#define IDC_BitrateControl_Stepping     204
#define IDC_BitrateControl_Edit         205
#define IDC_BitrateControl_Slider       206
#define IDC_BitrateControl_Meter        207
#define IDC_BitrateControl_Actual       208

#define IDC_FrameRateControl_Label      210
#define IDC_FrameRateControl_Minimum    211
#define IDC_FrameRateControl_Maximum    212
#define IDC_FrameRateControl_Default    213
#define IDC_FrameRateControl_Stepping   214
#define IDC_FrameRateControl_Edit       215
#define IDC_FrameRateControl_Slider     216
#define IDC_FrameRateControl_Meter      217
#define IDC_FrameRateControl_Actual     218

#define IDC_CONTROL_DEFAULT             230

#define IDC_FORMAT_Compression          240
#define IDC_FORMAT_FlipVertical         241
#define IDC_FORMAT_FlipHorizontal       242

#define IDC_PacketLossRate_Label        300
#define IDC_PacketLossRate_Minimum      301
#define IDC_PacketLossRate_Maximum      302
#define IDC_PacketLossRate_Default      303
#define IDC_PacketLossRate_Stepping     304
#define IDC_PacketLossRate_Edit         305
#define IDC_PacketLossRate_Slider       306

#define IDC_RandomBitErrorRate_Label    310
#define IDC_RandomBitErrorRate_Minimum  311
#define IDC_RandomBitErrorRate_Maximum  312
#define IDC_RandomBitErrorRate_Default  313
#define IDC_RandomBitErrorRate_Stepping 314
#define IDC_RandomBitErrorRate_Edit     315
#define IDC_RandomBitErrorRate_Slider   316

#define IDC_BurstErrorDuration_Label    320
#define IDC_BurstErrorDuration_Minimum  321
#define IDC_BurstErrorDuration_Maximum  322
#define IDC_BurstErrorDuration_Default  323
#define IDC_BurstErrorDuration_Stepping 324
#define IDC_BurstErrorDuration_Edit     325
#define IDC_BurstErrorDuration_Slider   326

#define IDC_BurstErrorMaxFrequency_Label 330
#define IDC_BurstErrorMaxFrequency_Minimum 331
#define IDC_BurstErrorMaxFrequency_Maximum 332
#define IDC_BurstErrorMaxFrequency_Default 333
#define IDC_BurstErrorMaxFrequency_Stepping 334
#define IDC_BurstErrorMaxFrequency_Edit 335
#define IDC_BurstErrorMaxFrequency_Slider 336

#define IDC_Pan_Label                   400
#define IDC_Pan_Minimum                 0
#define IDC_Pan_Maximum                 0
#define IDC_Pan_Default                 0
#define IDC_Pan_Stepping                0
#define IDC_Pan_Edit                    405
#define IDC_Pan_Slider                  406
#define IDC_Pan_Auto                    407

#define IDC_Tilt_Label                  410
#define IDC_Tilt_Minimum                0
#define IDC_Tilt_Maximum                0
#define IDC_Tilt_Default                0
#define IDC_Tilt_Stepping               0
#define IDC_Tilt_Edit                   415
#define IDC_Tilt_Slider                 416
#define IDC_Tilt_Auto                   417

#define IDC_Roll_Label                  420
#define IDC_Roll_Minimum                0
#define IDC_Roll_Maximum                0
#define IDC_Roll_Default                0
#define IDC_Roll_Stepping               0
#define IDC_Roll_Edit                   425
#define IDC_Roll_Slider                 426
#define IDC_Roll_Auto                   427

#define IDC_Zoom_Label                  430
#define IDC_Zoom_Minimum                0
#define IDC_Zoom_Maximum                0
#define IDC_Zoom_Default                0
#define IDC_Zoom_Stepping               0
#define IDC_Zoom_Edit                   435
#define IDC_Zoom_Slider                 436
#define IDC_Zoom_Auto                   437

#define IDC_Exposure_Label              440
#define IDC_Exposure_Minimum            0
#define IDC_Exposure_Maximum            0
#define IDC_Exposure_Default            0
#define IDC_Exposure_Stepping           0
#define IDC_Exposure_Edit               445
#define IDC_Exposure_Slider             446
#define IDC_Exposure_Auto               447

#define IDC_Iris_Label                  450
#define IDC_Iris_Minimum                0
#define IDC_Iris_Maximum                0
#define IDC_Iris_Default                0
#define IDC_Iris_Stepping               0
#define IDC_Iris_Edit                   455
#define IDC_Iris_Slider                 456
#define IDC_Iris_Auto                   457

#define IDC_Focus_Label                 460
#define IDC_Focus_Minimum               0
#define IDC_Focus_Maximum               0
#define IDC_Focus_Default               0
#define IDC_Focus_Stepping              0
#define IDC_Focus_Edit                  465
#define IDC_Focus_Slider                466
#define IDC_Focus_Auto                  467

#define IDC_FlipVertical_Edit           470

#define IDC_FlipHorizontal_Edit         480

#define IDC_Brightness_Label            500
#define IDC_Brightness_Minimum          0
#define IDC_Brightness_Maximum          0
#define IDC_Brightness_Default          0
#define IDC_Brightness_Stepping         0
#define IDC_Brightness_Edit             505
#define IDC_Brightness_Slider           506
#define IDC_Brightness_Auto             507

#define IDC_Contrast_Label              510
#define IDC_Contrast_Minimum            0
#define IDC_Contrast_Maximum            0
#define IDC_Contrast_Default            0
#define IDC_Contrast_Stepping           0
#define IDC_Contrast_Edit               515
#define IDC_Contrast_Slider             516
#define IDC_Contrast_Auto               517

#define IDC_Hue_Label                   520
#define IDC_Hue_Minimum                 0
#define IDC_Hue_Maximum                 0
#define IDC_Hue_Default                 0
#define IDC_Hue_Stepping                0
#define IDC_Hue_Edit                    525
#define IDC_Hue_Slider                  526
#define IDC_Hue_Auto                    527

#define IDC_Saturation_Label            530
#define IDC_Saturation_Minimum          0
#define IDC_Saturation_Maximum          0
#define IDC_Saturation_Default          0
#define IDC_Saturation_Stepping         0
#define IDC_Saturation_Edit             535
#define IDC_Saturation_Slider           536
#define IDC_Saturation_Auto             537

#define IDC_Sharpness_Label             540
#define IDC_Sharpness_Minimum           0
#define IDC_Sharpness_Maximum           0
#define IDC_Sharpness_Default           0
#define IDC_Sharpness_Stepping          0
#define IDC_Sharpness_Edit              545
#define IDC_Sharpness_Slider            546
#define IDC_Sharpness_Auto              547

#define IDC_Gamma_Label                 550
#define IDC_Gamma_Minimum               0
#define IDC_Gamma_Maximum               0
#define IDC_Gamma_Default               0
#define IDC_Gamma_Stepping              0
#define IDC_Gamma_Edit                  555
#define IDC_Gamma_Slider                556
#define IDC_Gamma_Auto                  557

#define IDC_ColorEnable_Label           560
#define IDC_ColorEnable_Minimum         0
#define IDC_ColorEnable_Maximum         0
#define IDC_ColorEnable_Default         0
#define IDC_ColorEnable_Stepping        0
#define IDC_ColorEnable_Edit            565
#define IDC_ColorEnable_Slider          566
#define IDC_ColorEnable_Auto            567

#define IDC_WhiteBalance_Label          570
#define IDC_WhiteBalance_Minimum        0
#define IDC_WhiteBalance_Maximum        0
#define IDC_WhiteBalance_Default        0
#define IDC_WhiteBalance_Stepping       0
#define IDC_WhiteBalance_Edit           575
#define IDC_WhiteBalance_Slider         576
#define IDC_WhiteBalance_Auto           577

#define IDC_BacklightComp_Label         580
#define IDC_BacklightComp_Minimum       0
#define IDC_BacklightComp_Maximum       0
#define IDC_BacklightComp_Default       0
#define IDC_BacklightComp_Stepping      0
#define IDC_BacklightComp_Edit          585
#define IDC_BacklightComp_Slider        586
#define IDC_BacklightComp_Auto          587

#define IDC_Device_SourceDlg            600
#define IDC_Device_FormatDlg            601
#define IDC_Device_DisplayDlg           602
#define IDC_Capture_Mode                603
#define IDC_Overlay_Support             604
#define IDC_Device_Version              605
#define IDC_Device_Type                 606
#define IDC_Device_Selection            607

#define IDC_CPULoad_Label               700
#define IDC_CPULoad_Minimum             701
#define IDC_CPULoad_Maximum             702
#define IDC_CPULoad_Default             703
#define IDC_CPULoad_Stepping            704
#define IDC_CPULoad_Edit                705
#define IDC_CPULoad_Slider              706
#define IDC_CPULoad_Meter               707
#define IDC_CPULoad_Actual              708

#define IDC_MaxProcessingTime_Label     710
#define IDC_MaxProcessingTime_Minimum   711
#define IDC_MaxProcessingTime_Maximum   712
#define IDC_MaxProcessingTime_Default   713
#define IDC_MaxProcessingTime_Stepping  714
#define IDC_MaxProcessingTime_Edit      715
#define IDC_MaxProcessingTime_Slider    716
#define IDC_MaxProcessingTime_Meter     717
#define IDC_MaxProcessingTime_Actual    718

#define IDC_ProgRef_OneProg             801
#define IDC_ProgRef_ContProg            802
#define IDC_ProgRef_IndProg             803
#define IDC_ProgRef_ContIndProg         804
#define IDC_ProgRef_AbortOne            805
#define IDC_ProgRef_AbortCont           806

#define IDC_RtpPd_Label                 900
#define IDC_RtpPd_Minimum               901
#define IDC_RtpPd_Maximum               902
#define IDC_RtpPd_Default               903
#define IDC_RtpPd_Stepping              904
#define IDC_RtpPd_Edit                  905
#define IDC_RtpPd_Slider                906

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         341
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\propedit.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.cpp | Source file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | CPropertyEditor | This
 *    method is the constructor for property objects.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the property.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl)
: m_hDlg (hDlg), m_hWndMin (NULL), m_hWndMax (NULL), m_hWndDefault (NULL), m_hWndStep (NULL), m_hWndEdit (NULL), m_hWndTrackbar (NULL), m_hWndProgress (NULL), m_IDLabel (IDLabel), m_hWndAuto (NULL), m_IDAutoControl (IDAutoControl)
, m_IDMinControl (IDMinControl), m_IDMaxControl (IDMaxControl), m_IDDefaultControl (IDDefaultControl), m_IDStepControl (IDStepControl), m_IDTrackbarControl (IDTrackbarControl), m_IDProgressControl (IDProgressControl)
, m_IDEditControl (IDEditControl), m_IDProperty (IDProperty), m_Active (FALSE), m_Min (0), m_Max (0), m_DefaultValue (0), m_DefaultFlags (0), m_SteppingDelta (0), m_CurrentValue (0), m_TrackbarOffset (0), m_ProgressOffset (0), m_fCheckBox (0)
, m_CurrentFlags (0), m_CanAutoControl (FALSE)

{
	FX_ENTRY("CPropertyEditor::CPropertyEditor")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | Init | This initializes the controls.
 *
 *  @rdesc TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::Init()
{
	HRESULT Hr = NOERROR;
	BOOL	fRes = TRUE;

	FX_ENTRY("CPropertyEditor::Init")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// For now disable all controls, and re-enable only the ones that make sense
	// at the end of this initialization function

	// Those GetDlgItem calls 'd better not fail ;)
	if (m_IDLabel)
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), FALSE);
	if (m_IDMinControl)
		EnableWindow(m_hWndMin = GetDlgItem(m_hDlg, m_IDMinControl), FALSE);
	if (m_IDMaxControl)
		EnableWindow(m_hWndMax = GetDlgItem(m_hDlg, m_IDMaxControl), FALSE);
	if (m_IDDefaultControl)
		EnableWindow(m_hWndDefault = GetDlgItem(m_hDlg, m_IDDefaultControl), FALSE);
	if (m_IDStepControl)
		EnableWindow(m_hWndStep = GetDlgItem(m_hDlg, m_IDStepControl), FALSE);
	if (m_IDEditControl)
		EnableWindow(m_hWndEdit = GetDlgItem(m_hDlg, m_IDEditControl), FALSE);
	if (m_IDTrackbarControl)
		EnableWindow(m_hWndTrackbar = GetDlgItem(m_hDlg, m_IDTrackbarControl), FALSE);
	if (m_IDProgressControl)
		EnableWindow(m_hWndProgress = GetDlgItem(m_hDlg, m_IDProgressControl), FALSE);
	if (m_IDAutoControl)
		EnableWindow(m_hWndAuto = GetDlgItem(m_hDlg, m_IDAutoControl), FALSE);

	// Only enable the control if we can read the current value
	if (FAILED(Hr = GetValue()))
	{
		fRes = FALSE;
		goto MyExit;
	}

	// Save original value in case user clicks Cancel
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Get the range, stepping, default, and capabilities
	if (FAILED(Hr = GetRange()))
	{
		// Special case, if no trackbar and no edit box, treat the
		// autocheck box as a boolean to control the property
		if (m_hWndTrackbar || m_hWndEdit || m_hWndProgress)
		{
			fRes = FALSE;
			goto MyExit;
		}
	}
	else
	{
		ASSERT(!(m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min));
		if (m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min)
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: Invalid range or current value", _fx_));
			fRes = FALSE;
			goto MyExit;
		}

		if (m_Min == 0 && m_Max == 1 && m_SteppingDelta == 1)
			m_fCheckBox = TRUE;
	}

	// We're ready to rock & roll
	m_Active = TRUE;

	// Re-enable appropriate controls
	if (m_IDLabel)
	{
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), TRUE);
	}
	if (m_hWndMin)
	{
		SetDlgItemInt(m_hDlg, m_IDMinControl, m_Min, TRUE);
		EnableWindow(m_hWndMin, TRUE);
	}
	if (m_hWndMax)
	{
		SetDlgItemInt(m_hDlg, m_IDMaxControl, m_Max, TRUE);
		EnableWindow(m_hWndMax, TRUE);
	}
	if (m_hWndDefault)
	{
		SetDlgItemInt(m_hDlg, m_IDDefaultControl, m_DefaultValue, TRUE);
		EnableWindow(m_hWndDefault, TRUE);
	}
	if (m_hWndStep)
	{
		SetDlgItemInt(m_hDlg, m_IDStepControl, m_SteppingDelta, TRUE);
		EnableWindow(m_hWndStep, TRUE);
	}
	if (m_hWndEdit)
	{
		UpdateEditBox();
		EnableWindow(m_hWndEdit, TRUE);
	}
	if (m_hWndTrackbar)
	{
		EnableWindow(m_hWndTrackbar, TRUE);

		// Trackbars don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_TrackbarOffset = -m_Min;

		SendMessage(m_hWndTrackbar, TBM_SETRANGEMAX, FALSE, m_Max + m_TrackbarOffset);
		SendMessage(m_hWndTrackbar, TBM_SETRANGEMIN, FALSE, m_Min + m_TrackbarOffset);

		// Have fun with the keyboards Page Up, Page Down, and arrows
		SendMessage(m_hWndTrackbar, TBM_SETLINESIZE, FALSE, (LPARAM) m_SteppingDelta);
		SendMessage(m_hWndTrackbar, TBM_SETPAGESIZE, FALSE, (LPARAM) m_SteppingDelta);

		UpdateTrackbar();
	}
	if (m_hWndProgress)
	{
		EnableWindow(m_hWndProgress, TRUE);

		// Progress controls don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_ProgressOffset = -m_Min;

		SendMessage(m_hWndProgress, PBM_SETRANGE32, m_Min + m_ProgressOffset, m_Max + m_ProgressOffset);

		UpdateProgress();

		// Set a timer to update the progress regularly
		SetTimer(m_hDlg, 123456, 250, NULL);
	}
	if (m_hWndAuto)
	{
		// If the control has an auto setting, enable the auto checkbox
		m_CanAutoControl = CanAutoControl();
		EnableWindow (m_hWndAuto, m_CanAutoControl);
		if (m_CanAutoControl)
		{
			Button_SetCheck (m_hWndAuto, GetAuto ());
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | ~CPropertyEditor | Destructor for this class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::~CPropertyEditor()
{
	FX_ENTRY("CPropertyEditor::~CPropertyEditor")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Kill timer if we have a progress bar
	if (m_hWndProgress)
		KillTimer(m_hDlg, 123456);

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | OnApply | This member function is
 *    called by the framework when the user chooses the OK or the Apply Now
 *    button. When the framework calls this member function, changes made on
 *    all property pages in the property sheet are accepted, the property
 *    sheet retains focus.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnApply()
{
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnApply")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
	{
		nCurrentValue = m_CurrentValue;
		m_CurrentValue = m_CurrentValue / m_SteppingDelta * m_SteppingDelta;
		if (m_CurrentValue != nCurrentValue)
		{
			UpdateEditBox();
			UpdateTrackbar();
		}
	}

	// Backup current value in order to only apply changes if something has really changed
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Set the value on the device
	SetValue();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | HasChanged | This member tests for a
 *    change in value.
 *
 *  @rdesc Returns TRUE if value has changed.
 ***************************************************************************/
BOOL CPropertyEditor::HasChanged()
{
	FX_ENTRY("CPropertyEditor::HasChanged")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return (m_CurrentValue != m_OriginalValue);
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnDefault | Resets the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    pressed the Default button.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnDefault()
{
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnDefault")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_Active)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Backup value in case user goes for the Cancel button
	m_CurrentValue = m_DefaultValue;
    m_CurrentFlags = m_DefaultFlags;

	// Update appropriate controls
	UpdateEditBox();
	UpdateTrackbar();
	UpdateAuto();

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnScroll | Reads the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    has messed with the slide bar.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	int pos;
	int command = LOWORD(wParam);
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnScroll")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input params
	if (command != TB_ENDTRACK && command != TB_THUMBTRACK && command != TB_LINEDOWN && command != TB_LINEUP && command != TB_PAGEUP && command != TB_PAGEDOWN)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: Invalid input parameter!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}
	ASSERT (IsWindow((HWND) lParam));
	if (!m_Active)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Retrieve position in slide bar
	pos = (int)SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
		m_CurrentValue = (pos - m_TrackbarOffset) / m_SteppingDelta * m_SteppingDelta;
	else
		m_CurrentValue = pos - m_TrackbarOffset;

	// Sync edit box to the slide bar
	UpdateEditBox();

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnEdit | Reads the content of the
 *    Target window and updates the postion of the slider after the user
 *    has messed with the Target edit control.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	BOOL fTranslated;
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnEdit")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// We get called even before init has been done -> test for m_Active
	if (m_Active)
	{
		if (!m_fCheckBox)
		{
			// Read the value from the control
			if (m_hWndEdit)
				nCurrentValue = GetDlgItemInt(m_hDlg, m_IDEditControl, &fTranslated, TRUE);

			// Is the value garbage?
			if (fTranslated)
			{
				if (nCurrentValue > m_Max)
				{
					// The value is already large than its max -> clamp it and update the control
					m_CurrentValue = m_Max;
					UpdateEditBox();
				}
				else if (nCurrentValue < m_Min)
				{
					// The value is already smaller than its min -> clamp it and update the control
					m_CurrentValue = m_Min;
					UpdateEditBox();
				}
				else
					m_CurrentValue = nCurrentValue;
			}
			else
			{
				// It's garbage -> Reset the control to its minimum value
				m_CurrentValue = m_Min;
				UpdateEditBox();
			}

			// Sync slide bar to edit box
			UpdateTrackbar();
		}
		else
		{
			// Read the value from the control
			if (m_hWndEdit)
				m_CurrentValue = Button_GetCheck(m_hWndEdit);
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnAuto | Gets the status of the
 *    checkbox.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	SetAuto(Button_GetCheck(m_hWndAuto));

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetTrackbarHWnd | Helper method to allow
 *    the property page code to access the slide bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the slide bar window.
 ***************************************************************************/
HWND CPropertyEditor::GetTrackbarHWnd()
{
	return m_hWndTrackbar;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetProgressHWnd | Helper method to allow
 *    the property page code to access the progress bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the progress window.
 ***************************************************************************/
HWND CPropertyEditor::GetProgressHWnd()
{
	return m_hWndProgress;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetEditHWnd | Helper method to allow
 *    the property page code to access the Target window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the Target window.
 ***************************************************************************/
HWND CPropertyEditor::GetEditHWnd()
{
	return m_hWndEdit;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetAutoHWnd | Helper method to allow
 *    the property page code to access the auto window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the auto window.
 ***************************************************************************/
HWND CPropertyEditor::GetAutoHWnd()
{
	return m_hWndAuto;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateEditBox | Updates the content of
 *    the Target window after user has moved the slide bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateEditBox()
{
	if (m_hWndEdit)
	{
		if (!m_fCheckBox)
			SetDlgItemInt(m_hDlg, m_IDEditControl, m_CurrentValue, TRUE);
		else
			Button_SetCheck(m_hWndEdit, m_CurrentValue);
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateTrackbar | Updates the position of
 *    the slide bar after user has messed with the Target window.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateTrackbar()
{
	if (m_hWndTrackbar)
		SendMessage(m_hWndTrackbar, TBM_SETPOS, TRUE, (LPARAM) m_CurrentValue + m_TrackbarOffset);

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateProgress | Updates the position of
 *    the progress bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateProgress()
{
	// Get current value from the device
	GetValue();

	if (m_hWndProgress)
		SendMessage(m_hWndProgress, PBM_SETPOS, (WPARAM) m_CurrentValue + m_ProgressOffset, 0);

	UpdateEditBox();

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateAuto | Updates the auto checkbox
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateAuto()
{
	if (m_hWndAuto && CanAutoControl())
	{
		m_CanAutoControl = GetAuto();
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::CanAutoControl(void)
{
	FX_ENTRY("CPropertyEditor::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_CapsFlags & TAPIControl_Flags_Auto;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::GetAuto(void)
{
	FX_ENTRY("CPropertyEditor::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	GetValue();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_CurrentFlags & TAPIControl_Flags_Auto; 
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CPropertyEditor::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_CurrentFlags = (fAuto ? TAPIControl_Flags_Auto : (m_CapsFlags & TAPIControl_Flags_Manual) ? TAPIControl_Flags_Manual : TAPIControl_Flags_None);

	SetValue();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\propedit.h ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.h | Header file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code tests the Ks interface handlers. This code is only
 *    compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _PROPEDIT_H_
#define _PROPEDIT_H_

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITCLASS
 *
 *  @class CPropertyEditor | This class implements behavior of a single
 *    property to be displayed in a property page.
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProperty | Property ID
 *
 *  @mdata LONG | CPropertyEditor | m_CurrentValue | Property current value
 *
 *  @mdata LONG | CPropertyEditor | m_Min | Property minimum value
 *
 *  @mdata LONG | CPropertyEditor | m_Max | Property maximum value
 *
 *  @mdata LONG | CPropertyEditor | m_SteppingDelta | Property stepping delta
 *
 *  @mdata LONG | CPropertyEditor | m_DefaultValue | Property default value
 *
 *  @mdata BOOL | CPropertyEditor | m_Active | Set to TRUE after all property values have been initialized
 *
 *  @mdata LONG | CPropertyEditor | m_OriginalValue | Backup of the original value
 *
 *  @mdata HWND | CPropertyEditor | m_hDlg | Window handle to the Parent dialog
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMin | Window handle to the Minimum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMax | Window handle to the Maximum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndDefault | Window handle to the Default dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndStep | Window handle to the Stepping Delta dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndEdit | Window handle to the Target dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndTrackbar | Window handle to the slide bar
 *
 *  @mdata HWND | CPropertyEditor | m_hWndProgress | Window handle to the progress bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDLabel | Resource ID of the property label
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMinControl | Resource ID of the Minimum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMaxControl | Resource ID of the Maximum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDStepControl | Resource ID of the Stepping Delta dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDDefaultControl | Resource ID of the Default dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDEditControl | Resource ID of the Target dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDTrackbarControl | Resource ID of the slide bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProgressControl | Resource ID of the progress bar
 ***************************************************************************/
class CPropertyEditor
{
	public:
	CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl);
	virtual ~CPropertyEditor();

	BOOL Init();

	HWND GetTrackbarHWnd();
	HWND GetProgressHWnd();
	HWND GetEditHWnd();
	HWND GetAutoHWnd();

	BOOL UpdateEditBox();
	BOOL UpdateTrackbar();
	BOOL UpdateProgress();
	BOOL UpdateAuto();

	BOOL OnApply();
	BOOL OnDefault();
	BOOL OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL HasChanged();

	protected:

	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	// Pure virtual functions to set/get actual property values, and the ranges
	virtual HRESULT GetValue(void) PURE;
	virtual HRESULT SetValue(void) PURE;
	virtual HRESULT GetRange(void) PURE; 

	ULONG	m_IDProperty;	// Property ID

	// The following are used by GetValue and SetValue
	LONG	m_CurrentValue;
	LONG	m_CurrentFlags;

	// The following must be set by GetRange
	LONG	m_Min;
	LONG	m_Max;
	LONG	m_SteppingDelta;
	LONG	m_DefaultValue;
	LONG	m_DefaultFlags;
	LONG	m_CapsFlags;

	private:
	BOOL	m_Active;
	BOOL	m_fCheckBox;
	LONG	m_OriginalValue;
	LONG	m_OriginalFlags;
	HWND	m_hDlg;				// Parent
	HWND	m_hWndMin;			// Min window
	HWND	m_hWndMax;			// Max window
	HWND	m_hWndDefault;		// Default window
	HWND	m_hWndStep;			// Step window
	HWND	m_hWndEdit;			// Edit window
	HWND	m_hWndTrackbar;		// Slider
	HWND	m_hWndProgress;		// Progress
	HWND	m_hWndAuto;			// Auto checkbox
	ULONG	m_IDLabel;			// ID of label
	ULONG	m_IDMinControl;		// ID of min control
	ULONG	m_IDMaxControl;		// ID of max control
	ULONG	m_IDStepControl;	// ID of step control
	ULONG	m_IDDefaultControl;	// ID of default control
	ULONG	m_IDEditControl;	// ID of edit control
	ULONG	m_IDTrackbarControl;// ID of trackbar
	ULONG	m_IDProgressControl;// ID of trackbar
	ULONG	m_IDAutoControl;	// ID of auto checkbox
	LONG	m_TrackbarOffset;	// Handles negative trackbar offsets
	LONG	m_ProgressOffset;	// Handles negative trackbar offsets
	BOOL	m_CanAutoControl;

};

#endif // USE_PROPERTY_PAGES

#endif // _PROPEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\rtppdp.cpp ===
/****************************************************************************
 *  @doc INTERNAL RTPPDP
 *
 *  @module RtpPdP.cpp | Source file for the <c CRtpPdProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interfaces <i IRTPPDControl>.
 *
 *  @comm This code tests the TAPI Rtp Pd Output Pins <i IRTPPDControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc void | CRtpPdProperty | CRtpPdProperty | This
 *    method is the constructor for Rtp Pd property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i IRTPPDControl> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IRTPPDControl* | pIRTPPDControl | Specifies a pointer to the
 *    <i IRTPPDControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdProperty::CRtpPdProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IRTPPDControl *pIRTPPDControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CRtpPdProperty::CRtpPdProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pIRTPPDControl = pIRTPPDControl;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc void | CRtpPdProperty | ~CRtpPdProperty | This
 *    method is the destructor for Rtp Pd control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdProperty::~CRtpPdProperty()
{
	FX_ENTRY("CRtpPdProperty::~CRtpPdProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CRtpPdProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{									
		case IDC_RtpPd_MaxPacketSize:
			if (m_pIRTPPDControl && SUCCEEDED (Hr = m_pIRTPPDControl->GetMaxRTPPacketSize((LPDWORD)&m_CurrentValue, 0)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMaxRTPPacketSize=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown Rtp Pd control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CRtpPdProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_RtpPd_MaxPacketSize:
			if (m_pIRTPPDControl && SUCCEEDED (Hr = m_pIRTPPDControl->SetMaxRTPPacketSize((DWORD)m_CurrentValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: dwMaxRTPPacketSize=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown Rtp Pd control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CRtpPdProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_RtpPd_MaxPacketSize:
			if (m_pIRTPPDControl && SUCCEEDED (Hr = m_pIRTPPDControl->GetMaxRTPPacketSizeRange((LPDWORD)&m_Min, (LPDWORD)&m_Max, (LPDWORD)&m_SteppingDelta, (LPDWORD)&m_DefaultValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown Rtp Pd control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CRtpPdProperty::CanAutoControl(void)
{
	FX_ENTRY("CRtpPdProperty::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CRtpPdProperty::GetAuto(void)
{
	FX_ENTRY("CRtpPdProperty::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE; 
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperty | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CRtpPdProperty::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CRtpPdProperty::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc CUnknown* | CRtpPdProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a TAPI Rtp Pd Control
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CRtpPdPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CRtpPdPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CRtpPdProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CRtpPdProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CRtpPdProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc void | CRtpPdProperties | CRtpPdProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdProperties::CRtpPdProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("TAPI Rtp Pd Control Property Page"), pUnk, IDD_RtpPdControlProperties, IDS_RTPPDPROPNAME)
{
	FX_ENTRY("CRtpPdProperties::CRtpPdProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIRTPPDControl = NULL;
	m_NumProperties = NUM_RTPPD_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc void | CRtpPdProperties | ~CRtpPdProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdProperties::~CRtpPdProperties()
{
	int		j;

	FX_ENTRY("CRtpPdProperties::~CRtpPdProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CRtpPdProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the CPU control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IRTPPDControl), (void **)&m_pIRTPPDControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIRTPPDControl=0x%08lX", _fx_, m_pIRTPPDControl));
	}
	else
	{
		m_pIRTPPDControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperties::OnDisconnect()
{
	FX_ENTRY("CRtpPdProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIRTPPDControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIRTPPDControl->Release();
		m_pIRTPPDControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIRTPPDControl", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	int		j;

	FX_ENTRY("CRtpPdProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (m_Controls[0] = new CRtpPdProperty(m_hwnd, IDC_RtpPd_Label, IDC_RtpPd_Minimum, IDC_RtpPd_Maximum, IDC_RtpPd_Default, IDC_RtpPd_Stepping, IDC_RtpPd_Edit, IDC_RtpPd_Slider, 0, IDC_RtpPd_MaxPacketSize, m_pIRTPPDControl))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[0]=0x%08lX", _fx_, m_Controls[0]));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		goto MyExit;
		Hr = E_OUTOFMEMORY;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = TRUE;
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CRtpPdProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc HRESULT | CRtpPdProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;

	FX_ENTRY("CRtpPdProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Apply new targets on video stream
	for (j = 0; j < m_NumProperties; j++)
	{
		ASSERT(m_Controls[j]);
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc BOOL | CRtpPdProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CRtpPdProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// This is called before Activate...
			m_hWnd = hWnd;
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.
			if (m_fActivated)
			{
				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;
					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPMETHOD
 *
 *  @mfunc BOOL | CRtpPdProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CRtpPdProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\rtppd.h ===
/****************************************************************************
 *  @doc INTERNAL RTPPD
 *
 *  @module RtpPd.h | Header file for the <c CRtpPdPin> class methods
 *    used to implement the RTP packetization descriptor output pin.
 ***************************************************************************/

#ifndef _RTPPD_H_
#define _RTPPD_H_

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 1350 | MAX_RTP_PACKET_SIZE | Maximum RTP packet size.
 *
 * @const 512 | MIN_RTP_PACKET_SIZE | Minimum RTP packet size.
 *
 * @const 1350 | DEFAULT_RTP_PACKET_SIZE | Default RTP packet size.
 *
 * @const 4096 | MAX_RTP_PD_BUFFER_SIZE | Maximum RTP packetization descriptor
 *    buffer size.
 ****************************************************************************/
#define MAX_RTP_PACKET_SIZE 1350
#define MIN_RTP_PACKET_SIZE 512
#define DEFAULT_RTP_PACKET_SIZE MAX_RTP_PACKET_SIZE
#define MAX_RTP_PD_BUFFER_SIZE 4096

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD | The <t RTP_PD> structure is used
 *    to specify the details of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the next <t RTP_PD>
 *    structure, if there is one, or the start of the payload headers.
 *
 *  @field DWORD | dwPayloadHeaderOffset | Specifies the offset from the start
 *    of the RTP packetization descriptor data to the first byte of the payload
 *    header.
 *
 *  @field DWORD | dwPayloadHeaderLength | Specifies the length, in bytes, of
 *    the payload header.
 *
 *  @field DWORD | dwPayloadStartBitOffset | Specifies the offset from the
 *    start of the corresponding compressed video buffer to the first bit of
 *    the payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | dwPayloadEndBitOffset | Specifies the offset from the start
 *    of the corresponding compressed video buffer to the last bit of the
 *    payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | fEndMarkerBit | If set to TRUE, this flag signals that
 *    this structure applies to the last chunk of a video frame. Typically,
 *    only the last packet descriptor in a series of descriptors would have
 *    this flag turned on. However, this may not be the case for devices
 *    that do not respect frame boundaries and fill video capture buffers
 *    with truncated or multiple video frames.
 *
 *  @field DWORD | dwLayerId | Specifies the ID of the encoding layer this
 *    descriptor applies to. For standard video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc.
 *
 *  @field DWORD | dwTimestamp | Specifies the value of the timestamp field
 *    to be set by the downstream filter when creating the RTP header for
 *    this packet. The units and ranges for this field shall adhere to the
 *    definition of timestamp given in section 5.1 of RFC 1889.
 *
 *  @field DWORD | dwAudioAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the audio stream associated to this
 *    RTP packetization descriptor. This field shall always be set to 0,
 *    unless the audio sample described by this RTP packetization descriptor
 *    structure is a silent frame, in which case, this field shall be set
 *    to AUDIO_SILENT (defined as 1).
 *
 *  @field DWORD | dwVideoAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the video stream associated to this
 *    RTP packetization descriptor. There are no video attributes defined at
 *    this time. Therefore, this field shall always be set to 0.
 *
 *  @field DWORD | dwReserved | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD
{
    DWORD dwThisHeaderLength;
    DWORD dwPayloadHeaderOffset;
    DWORD dwPayloadHeaderLength;
    DWORD dwPayloadStartBitOffset;
    DWORD dwPayloadEndBitOffset;
	BOOL  fEndMarkerBit;
    DWORD dwLayerId;
    DWORD dwTimestamp;
	union {
	DWORD dwAudioAttributes;
	DWORD dwVideoAttributes;
	};
    DWORD dwReserved;
} RTP_PD, *PRTP_PD;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_HEADER | The <t RTP_PD_HEADER> structure is used
 *    to specify the details of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the first <t RTP_PD>
 *    structure.
 *
 *  @field DWORD | dwTotalByteLength | Specifies the length, in bytes, of the
 *    entire data. This includes this structure, the <t RTP_PD> structures,
 *    and the payload information.
 *
 *  @field DWORD | dwNumHeaders | Specifies the number of <t RTP_PD>
 *    structures.
 *
 *  @field DWORD | dwReserved | Reserved. Shall be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_HEADER
{
    DWORD dwThisHeaderLength;
    DWORD dwTotalByteLength;
    DWORD dwNumHeaders;
    DWORD dwReserved;
} RTP_PD_HEADER, *PRTP_PD_HEADER;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_INFO | The <t RTP_PD_INFO> structure is used
 *    to specify the details of the RTP Pd format.
 *
 *  @field REFERENCE_TIME | AvgTimePerSample | Specifies the average time per
 *    list of RTP packet descriptor, in 100ns units. This value shall be
 *    identical to the value of the <p AvgTimePerFrame> field of the video
 *    info header of the related compressed video stream format.
 *
 *  @field DWORD | dwMaxRTPPacketizationDescriptorBufferSize | Specifies the
 *    maximum size in bytes of the entire RTP packetization descriptor buffer.
 *    The format of this buffer is described in the following section. The
 *    maximum size of the entire RTP packetization descriptor buffer rarely
 *    needs to exceed a few hundred bytes.
 *
 *  @field DWORD | dwMaxRTPPayloadHeaderSize | Specifies the maximum size in
 *    bytes of the payload header data for one RTP packet. For example, the
 *    maximum size of a payload header for H.263 version 1 is 12 bytes (Mode
 *    C header).
 *
 *  @field DWORD | dwMaxRTPPacketSize | Specifies the maximum RTP packet
 *    size in bytes to be described by the list of packetization descriptor.
 *    Typically, this number is just below the MTU size of the network.
 *
 *  @field DWORD | dwNumLayers | Specifies the number of encoding layers to
 *    be described by the list of packetization descriptor. Typically, this
 *    number is equal to 1. Only in the case of multi-layered encoders would
 *    this number be higher than 1.
 *
 *  @field DWORD | dwPayloadType | Specifies the static payload type the
 *    stream describes. If the RTP packetization descriptors do not apply to
 *    an existing static payload type but a dynamic payload type, this field
 *    shall be set to DYNAMIC_PAYLOAD_TYPE (defined as MAXDWORD).
 *
 *  @field DWORD | dwDescriptorVersion | Specifies a version identifier
 *    qualifying the format of packetization descriptors. This field shall
 *    be set to VERSION_1 (defined as 1UL) to identify the packetization
 *    descriptor structures described in the next section.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_INFO {
	REFERENCE_TIME	AvgTimePerSample;
	DWORD			dwMaxRTPPacketizationDescriptorBufferSize;
	DWORD			dwMaxRTPPayloadHeaderSize;
	DWORD			dwMaxRTPPacketSize;
	DWORD			dwNumLayers;
	DWORD			dwPayloadType;
	DWORD			dwDescriptorVersion;
    DWORD			dwReserved[4];
} RTP_PD_INFO, *PRTP_PD_INFO;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_CONFIG_CAPS | The <t RTP_PD_CONFIG_CAPS> structure is used
 *    to store the RTP packetization descriptor configuration capabilities.
 *
 *  @field DWORD | dwSmallestRTPPacketSize | Specifies the size in bytes of the
 *    smallest RTP packet the stream can describe (typically, 512 bytes on Modem).
 *
 *  @field DWORD | dwLargestRTPPacketSize | Specifies the size in bytes of the
 *    largest packet the stream can describe (typically, 1350 bytes on LAN).
 *
 *  @field DWORD | dwRTPPacketSizeGranularity | Specifies the granularity of
 *    the increments between the smallest and largest packet size the stream
 *    supports (ex. 1).
 *
 *  @field DWORD | dwSmallestNumLayers | Specifies the smallest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwLargestNumLayers | Specifies the largest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwNumLayersGranularity | Specifies the granularity of the
 *    increments between the smallest and largest number of encoding layers
 *    the stream supports (ex. 0).
 *
 *  @field DWORD | dwNumStaticPayloadTypes | Specifies the number of static
 *    payload types the stream supports. This value is valid between 0 and
 *    4  (ex. 2 if it supports RFC 2190 and 2429 with H.263, but typically
 *    only 1).
 *
 *  @field DWORD | dwStaticPayloadTypes[4] | Specifies an array of static
 *    payload types the stream supports. A stream can support at most 4
 *    static payload types. The number of valid entries in this array is
 *    indicated by the <p dwNumStaticPayloadTypes> field (ex. 34 for H.263).
 *
 *  @field DWORD | dwNumDescriptorVersions | Specifies the number of
 *    packetization descriptor versions the stream supports. This value is
 *    valid between 1 and 4 (typically 1).
 *
 *  @field DWORD | dwDescriptorVersions[4] | Specifies an array of version
 *    identifiers qualifying the format of packetization descriptors. A
 *    stream can support at most 4 packetization descriptor versions. The
 *    number of valid entries in this array is indicated by the
 *    <p dwNumDescriptorVersions> field (ex. VERION_1).
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_CONFIG_CAPS  {
	DWORD dwSmallestRTPPacketSize;
	DWORD dwLargestRTPPacketSize;
    DWORD dwRTPPacketSizeGranularity;
	DWORD dwSmallestNumLayers;
	DWORD dwLargestNumLayers;
    DWORD dwNumLayersGranularity;
	DWORD dwNumStaticPayloadTypes;
	DWORD dwStaticPayloadTypes[4];
	DWORD dwNumDescriptorVersions;
	DWORD dwDescriptorVersions[4];
    DWORD dwReserved[4];
} RTP_PD_CONFIG_CAPS, *PRTP_PD_CONFIG_CAPS;

class CRtpPdSample : public CMediaSample
{
	public:
	CRtpPdSample(IMemAllocator *pAllocator, HRESULT *phr, LPTHKVIDEOHDR ptvh, LPBYTE pBuffer, LONG length) : m_ptvh(ptvh), CMediaSample(NAME("Video Frame"), (CBaseAllocator *)pAllocator, phr, pBuffer, length){};
	LPTHKVIDEOHDR GetFrameHeader() {return m_ptvh;};

	private:
	const LPTHKVIDEOHDR m_ptvh;
};

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINCLASS
 *
 *  @class CRtpPdPin | This class implements the RTP packetization descriptor
 *    output pin.
 *
 *  @mdata CTAPIVCap* | CRtpPdPin | m_pCaptureFilter | Reference to the
 *    parent capture filter.
 *
 *  @mdata ALLOCATOR_PROPERTIES | CTAPIBasePin | m_parms | Out allocator
 *    properties.
 *
 *  @comm Supports IPin. Never created by COM, so no CreateInstance or entry
 *    in global FactoryTemplate table. Only ever created by a <c CTAPIVCap>
 *    object and returned via the EnumPins interface
 ***************************************************************************/
class CRtpPdPin : public CBaseOutputPin, public CBaseStreamControl, public IRTPPDControl, public IMemAllocator
#ifdef USE_PROPERTY_PAGES
, public ISpecifyPropertyPages
#endif
{
	public:
	DECLARE_IUNKNOWN
	CRtpPdPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName);
	virtual ~CRtpPdPin();
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	static HRESULT CALLBACK CreateRtpPdPin(CTAPIVCap *pCaptureFilter, CRtpPdPin **ppRtpPdPin);

#ifdef USE_PROPERTY_PAGES
	// ISpecifyPropertyPages methods
	STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

	// Override CBasePin base class methods
	HRESULT GetMediaType(IN int iPosition, OUT CMediaType *pMediaType);
	HRESULT CheckMediaType(IN const CMediaType *pMediaType);
	HRESULT SetMediaType(IN CMediaType *pMediaType);

	// Implement IMemAllocator
	STDMETHODIMP SetProperties(IN ALLOCATOR_PROPERTIES *pRequest, OUT ALLOCATOR_PROPERTIES *pActual);
	STDMETHODIMP GetProperties(OUT ALLOCATOR_PROPERTIES *pProps);
	STDMETHODIMP Commit();
	STDMETHODIMP Decommit();
	STDMETHODIMP GetBuffer(OUT IMediaSample **ppBuffer, IN REFERENCE_TIME *pStartTime, IN REFERENCE_TIME *pEndTime, IN DWORD dwFlags);
	STDMETHODIMP ReleaseBuffer(IN IMediaSample *pBuffer);

	// Override CBaseOutputPin base class methods
	HRESULT DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest);
	HRESULT DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc);

	// Override IQualityControl interface method to receive Notification messages
	STDMETHODIMP Notify(IN IBaseFilter *pSelf, IN Quality q) {return E_NOTIMPL;};

	HRESULT ActiveRun(IN REFERENCE_TIME tStart);
	HRESULT ActivePause();
	HRESULT Flush();
	HRESULT SendFrame(IN CFrameSample *pSample, IN CRtpPdSample *pRSample, IN DWORD dwBytesExtent, IN BOOL bDiscon);

	// Implement IRTPPDControl
	STDMETHODIMP SetMaxRTPPacketSize(IN DWORD dwMaxRTPPacketSize, IN DWORD dwLayerId);
	STDMETHODIMP GetMaxRTPPacketSize(OUT LPDWORD pdwMaxRTPPacketSize, IN DWORD dwLayerId);
	STDMETHODIMP GetMaxRTPPacketSizeRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId);

	private:

	friend class CTAPIVCap;
	friend class CCapturePin;
	friend class CTAPIBasePin;
	friend class CICMConverter;
	friend class CH26XEncoder;

	HRESULT CapturePinActive(BOOL fActive);
	BOOL			m_fCapturing;	// Is the streaming pin active?

	CTAPIVCap *m_pCaptureFilter;

	// Allocator properties
	ALLOCATOR_PROPERTIES m_parms;

	// Target RTP packet size
	DWORD	m_dwMaxRTPPacketSize;
	BOOL	m_fRunning;

	// Payload type
	DWORD	m_dwRTPPayloadType;

    BOOL	Committed() {return m_pCaptureFilter->m_cs.paHdr != NULL;};
};

#endif // _RTPPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\rtppdp.h ===
/****************************************************************************
 *  @doc INTERNAL RTPPDP
 *
 *  @module RtpPdP.h | Header file for the <c CRtpPdProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interfaces <i IRTPPDControl>.
 *
 *  @comm This code tests the TAPI Rtp Pd Output Pins <i IRTPPDControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _RTPPDP_H_
#define _RTPPDP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_RTPPD_CONTROLS				1
#define IDC_RtpPd_MaxPacketSize			0

/****************************************************************************
 *  @doc INTERNAL CRTPPDPCLASS
 *
 *  @class CRtpPdProperty | This class implements handling of a
 *    single Rtp Pd control property in a property page.
 *
 *  @mdata int | CRtpPdProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IRTPPDControl* | CRtpPdProperty | m_pIRTPPDControl | Pointer
 *    to the <i IRTPPDControl> interface.
 *
 *  @comm This code tests the TAPI Rtp Pd Output Pins <i IRTPPDControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CRtpPdProperty : public CPropertyEditor 
{
	public:
	CRtpPdProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IRTPPDControl *pIRTPPDControl);
	~CRtpPdProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IRTPPDControl *m_pIRTPPDControl;
};

/****************************************************************************
 *  @doc INTERNAL CRTPPDPCLASS
 *
 *  @class CRtpPdProperties | This class implements a property page
 *    to test the new TAPI internal interfaces <i IRTPPDControl>.
 *
 *  @mdata int | CRtpPdProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IRTPPDControl* | CRtpPdProperties | m_pInterface | Pointer
 *    to the <i IRTPPDControl> interface.
 *
 *  @mdata CRtpPdProperty* | CRtpPdProperties | m_Controls[NUM_RTPPD_CONTROLS] | Array
 *    of Rtp Pd control properties.
 *
 *  @comm This code tests the TAPI Rtp Pd Output Pins <i IRTPPDControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CRtpPdProperties : public CBasePropertyPage
{
	public:
	CRtpPdProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CRtpPdProperties();

	// Implement CBasePropertyPage virtual methods
	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	HWND			m_hWnd;
	int				m_NumProperties;
	BOOL			m_fActivated;
	IRTPPDControl	*m_pIRTPPDControl;
	CRtpPdProperty	*m_Controls[NUM_RTPPD_CONTROLS];
};

#endif // USE_PROPERTY_PAGES

#endif // _RTPPDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\rtppd.cpp ===
/****************************************************************************
 *  @doc INTERNAL RTPPD
 *
 *  @module RtpPd.cpp | Source file for the <c CRtpPdPin> class methods
 *    used to implement the RTP packetization descriptor pin.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc CRtpPdPin* | CRtpPdPin | CreateRtpPdPin | This helper
 *    function creates an output pin for RTP packetization descriptors.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CRtpPdPin** | ppRtpPdPin | Specifies that address of a pointer
 *    to a <c CRtpPdPin> object to receive the a pointer to the newly
 *    created pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CRtpPdPin::CreateRtpPdPin(CTAPIVCap *pCaptureFilter, CRtpPdPin **ppRtpPdPin)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::CreateRtpPdPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pCaptureFilter);
        ASSERT(ppRtpPdPin);
        if (!pCaptureFilter || !ppRtpPdPin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (!(*ppRtpPdPin = (CRtpPdPin *) new CRtpPdPin(NAME("RTP Packetization Descriptor Stream"), pCaptureFilter, &Hr, PNAME_RTPPD)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppRtpPdPin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppRtpPdPin, *ppRtpPdPin = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | CRtpPdPin | This method is the
 *  constructor for the <c CRtpPdPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdPin::CRtpPdPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPin(pObjectName, pCaptureFilter, &pCaptureFilter->m_lock, pHr, pName), m_pCaptureFilter(pCaptureFilter)
{
        FX_ENTRY("CRtpPdPin::CRtpPdPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        ASSERT(pCaptureFilter);
        if (!pCaptureFilter || !pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                if (pHr)
                        *pHr = E_POINTER;
        }

        if (pHr && FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

        // Default inits
        m_dwMaxRTPPacketSize = DEFAULT_RTP_PACKET_SIZE;
        if (m_pCaptureFilter->m_pCapturePin)
                m_dwRTPPayloadType = m_pCaptureFilter->m_pCapturePin->m_dwRTPPayloadType;
        else
                m_dwRTPPayloadType = H263_PAYLOAD_TYPE;
        m_fRunning = FALSE;
        m_fCapturing = FALSE;
        ZeroMemory(&m_parms, sizeof(m_parms));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc void | CRtpPdPin | ~CRtpPdPin | This method is the destructor
 *    for the <c CRtpPdPin> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CRtpPdPin::~CRtpPdPin()
{
        FX_ENTRY("CRtpPdPin::~CRtpPdPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IRTPPDControl>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IRTPPDControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IRTPPDControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IRTPPDControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IRTPPDControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif

        if (FAILED(Hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::GetPages")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        pPages->cElems = 1;
        if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
        }
        else
        {
                pPages->pElems[0] = __uuidof(RtpPdPropertyPage);
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetMediaType | This method retrieves one
 *    of the media types supported by the pin, which is used by enumerators.
 *
 *  @parm int | iPosition | Specifies a position in the media type list.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type at
 *    the <p iPosition> position in the list of supported media types.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_S_NO_MORE_ITEMS | End of the list of media types has been reached
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::GetMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(iPosition >= 0);
        ASSERT(pMediaType);
        if (iPosition < 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid iPosition argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        if (iPosition >= NUM_RTP_PD_FORMATS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: End of the list of media types has been reached", _fx_));
                Hr = VFW_S_NO_MORE_ITEMS;
                goto MyExit;
        }
        if (!pMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return our media type
        *pMediaType = *Rtp_Pd_Formats[iPosition];

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | CheckMediaType | This method is used to
 *    determine if the pin can support a specific media type.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_INVALIDMEDIATYPE | An invalid media type was specified
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::CheckMediaType(IN const CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;
    CMediaType mt;
        BOOL fFormatMatch = FALSE;
        DWORD dwIndex;

        FX_ENTRY("CRtpPdPin::CheckMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pMediaType);
        if (!pMediaType || !pMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Checking Max RTP packet size %d", _fx_, ((RTP_PD_INFO *)pMediaType->pbFormat)->dwMaxRTPPacketSize));

        // We only support KSDATAFORMAT_TYPE_RTP_PD and KSDATAFORMAT_SPECIFIER_NONE
        if (*pMediaType->Type() != KSDATAFORMAT_TYPE_RTP_PD || *pMediaType->FormatType() != KSDATAFORMAT_SPECIFIER_NONE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Media type or format type not recognized!", _fx_));
                Hr = VFW_E_INVALIDMEDIATYPE;
                goto MyExit;
        }

    // Quickly test to see if this is the current format (what we provide in GetMediaType). We accept that
    GetMediaType(0,&mt);
    if (mt == *pMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Identical to current format", _fx_));
                goto MyExit;
    }

        // Check the media subtype and image resolution
        // Don't test the payload type: we may be asked to use a dynamic payload type
        for (dwIndex=0; dwIndex < NUM_RTP_PD_FORMATS && !fFormatMatch;  dwIndex++)
        {
                if ((((RTP_PD_INFO *)pMediaType->pbFormat)->dwMaxRTPPacketizationDescriptorBufferSize == ((RTP_PD_INFO *)Rtp_Pd_Formats[dwIndex]->pbFormat)->dwMaxRTPPacketizationDescriptorBufferSize)
                && (((RTP_PD_INFO *)pMediaType->pbFormat)->dwMaxRTPPacketSize >= Rtp_Pd_Caps[dwIndex]->dwSmallestRTPPacketSize)
                && (((RTP_PD_INFO *)pMediaType->pbFormat)->dwMaxRTPPacketSize <= Rtp_Pd_Caps[dwIndex]->dwLargestRTPPacketSize)
                && (((RTP_PD_INFO *)pMediaType->pbFormat)->dwNumLayers >= Rtp_Pd_Caps[dwIndex]->dwSmallestNumLayers)
                && (((RTP_PD_INFO *)pMediaType->pbFormat)->dwNumLayers <= Rtp_Pd_Caps[dwIndex]->dwSmallestNumLayers)
                && (((RTP_PD_INFO *)pMediaType->pbFormat)->dwDescriptorVersion == VERSION_1))
                        fFormatMatch = TRUE;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   %s", _fx_, fFormatMatch ? "SUCCESS: Format supported" : "ERROR: Format notsupported"));

        if (!fFormatMatch)
                Hr = E_FAIL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::SetMediaType(IN CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::SetMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        Hr = E_NOTIMPL;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | ActiveRun | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from paused to
 *    running mode.
 *
 *  @parm REFERENCE_TIME | tStart | ???.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::ActiveRun(IN REFERENCE_TIME tStart)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::ActiveRun")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    ASSERT(IsConnected());
        if (!IsConnected())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pin not connected yet!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

    m_fRunning = TRUE;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | ActivePause | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from running to
 *    paused mode.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::ActivePause()
{
        FX_ENTRY("CRtpPdPin::ActivePause")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    m_fRunning = FALSE;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | SetMaxRTPPacketSize | This method is used to
 *    dynamically adjust the maximum RTP packet size (in bytes) to be
 *    described by the list of packetization descriptor. Typically, this
 *    number is just below the MTU size of the network.
 *
 *  @parm DWORD | dwMaxRTPPacketSize | Specifies the maximum RTP packet size
 *    (in bytes) to be described by the list of packetization descriptors.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::SetMaxRTPPacketSize(IN DWORD dwMaxRTPPacketSize, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::SetMaxRTPPacketSize")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(dwMaxRTPPacketSize > 0);
        ASSERT(dwMaxRTPPacketSize <= 2048);
        ASSERT(dwLayerId == 0);
        if (dwLayerId || dwMaxRTPPacketSize == 0 || dwMaxRTPPacketSize > 2048)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Save new target packet size
        m_dwMaxRTPPacketSize = dwMaxRTPPacketSize;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   New target RTP packet size: %ld", _fx_, m_dwMaxRTPPacketSize));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetMaxRTPPacketSize | This method is used to
 *    supply to the network sink filter the maximum RTP packet size (in bytes)
 *    described by the list of packetization descriptors.
 *
 *  @parm LPDWORD | pdwMaxRTPPacketSize | Specifies a pointer to a DWORD to
 *    receive the maximum RTP packet size (in bytes) described by the list of
 *    packetization descriptors.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::GetMaxRTPPacketSize(OUT LPDWORD pdwMaxRTPPacketSize, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::GetMaxRTPPacketSize")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pdwMaxRTPPacketSize);
        if (!pdwMaxRTPPacketSize)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return maximum packet size
        *pdwMaxRTPPacketSize = m_dwMaxRTPPacketSize;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Current target RTP packet size: %ld", _fx_, m_dwMaxRTPPacketSize));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetMaxRTPPacketSizeRange | This method is
 *    used to supply to the network sink filter the minimum, maximum, and
 *    default values for the RTP packet size (in bytes) described by the list
 *    of packetization descriptors.
 *
 *  @parm LPDWORD | pdwMin | Used to retrieve the minimum RTP packet size (in
 *    bytes) described by the list of packetization descriptors.
 *
 *  @parm LPDWORD | pdwMax | Used to retrieve the maximum RTP packet size (in
 *    bytes) described by the list of packetization descriptors.
 *
 *  @parm LPDWORD | pdwSteppingDelta | Used to retrieve the stepping delta in
 *    RTP packet size (in bytes) described by the list of packetization
 *    descriptors.
 *
 *  @parm LPDWORD | pdwDefault | Used to retrieve the default RTP packet size
 *    (in bytes) described by the list of packetization descriptors.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::GetMaxRTPPacketSizeRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::GetMaxRTPPacketSizeRange")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pdwMin);
        ASSERT(pdwMax);
        ASSERT(pdwSteppingDelta);
        ASSERT(pdwDefault);
        if (!pdwMin || !pdwMax || !pdwSteppingDelta || !pdwDefault)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return relevant values
        *pdwMin = 0;
        *pdwMax = MAX_RTP_PACKET_SIZE;
        *pdwSteppingDelta = 1;
        *pdwDefault = DEFAULT_RTP_PACKET_SIZE;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, *pdwMin, *pdwMax, *pdwSteppingDelta, *pdwDefault));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | CapturePinActive | This method is called by the
 *    capture pin to let the RTPPD pin know that the capture pin is active.
 *
 *  @parm BOOL | fActive | Specifies the status of the capture pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::CapturePinActive(BOOL fActive)
{
        FX_ENTRY("CRtpPdPin::CapturePinActive")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (fActive == m_fCapturing)
                goto MyExit;

        m_fCapturing = fActive;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Capture pin says Active=%s", _fx_, fActive ? "TRUE" : "FALSE"));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc DWORD | CRtpPdPin | Flush | Called when stopping. Flush any
 *    buffers that may be still downstream.
 *
 *  @rdesc Returns NOERROR
 ***************************************************************************/
HRESULT CRtpPdPin::Flush()
{
        FX_ENTRY("CRtpPdPin::Flush")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        BeginFlush();
        EndFlush();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return NOERROR;
}


#ifdef DEBUG
//#define LOGPAYLOAD_ON 1
//#define LOGPAYLOAD_TOFILE 1
#endif
#ifdef LOGPAYLOAD_ON
int g_dbg_LOGPAYLOAD_RtpPd=-1;
#endif


/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | SendFrame | This method is used to
 *    send a a media sample downstream.
 *
 *  @parm CFrameSample | pSample | Specifies a pointer to the video media
 *    sample associated to the current Rtp Pd media sample.
 *
 *  @parm CRtpPdSample | pRSample | Specifies a pointer to the media sample
 *    to send downstream.
 *
 *  @parm BOOL | bDiscon | Set to TRUE if this is the first frame we ever
 *    sent downstream.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag S_OK | No error
 *  @flag S_FALSE | If the pin is off (IAMStreamControl)
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::SendFrame(IN CFrameSample *pSample, IN CRtpPdSample *pRSample, IN DWORD dwBytesExtent, IN BOOL bDiscon)
{
        HRESULT                                         Hr = NOERROR;
    LPBYTE                                              pbySrc = NULL;
    LPBYTE                                              pbyDst;
    DWORD                                               dwDstBufferSize;
        int                                                     iStreamState;
        PH26X_RTP_BSINFO_TRAILER        pbsiT;
        PRTP_H263_BSINFO                        pbsi263;
        PRTP_H261_BSINFO                        pbsi261;
        BOOL                                            bOneFrameOnePacket = FALSE;
        DWORD                                           dwPktCount = 0;
        DWORD                                           dwHeaderHigh; // most significant
        DWORD                                           dwHeaderLow; // least significant
        PRTP_PD_HEADER                          pRtpPdHeader;
        PRTP_PD                                         pRtpPd;
        PBYTE                                           pbyPayloadHeader;
        REFERENCE_TIME                          rtSample;
        REFERENCE_TIME                          rtEnd;
        int                                                     i;
#if defined(LOGPAYLOAD_ON) || defined(LOGPAYLOAD_TOFILE)
        DWORD                                           dwPktSize;
        char                                            szDebug[256];
        HANDLE                                          g_DebugFile = (HANDLE)NULL;
        HANDLE                                          g_TDebugFile = (HANDLE)NULL;
        PBYTE                                           p;
        DWORD                                           d, GOBn;
        int                                                     wPrevOffset;
#endif

        FX_ENTRY("CRtpPdPin::SendFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        RTPPayloadHeaderMode RTPPayloadHeaderModeValue=m_pCaptureFilter->m_RTPPayloadHeaderMode; //initial this is RTPPayloadHeaderMode_Draft;


        // Validate input parameters
        ASSERT(pSample);
        ASSERT(pRSample);
        if (!pSample || !pRSample)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // The information we need is at the end of the compressed video buffer
        if (!(SUCCEEDED(Hr = pSample->GetPointer(&pbySrc)) && pbySrc && SUCCEEDED(Hr = pRSample->GetPointer(&pbyDst)) && pbyDst && dwBytesExtent && (dwDstBufferSize = pRSample->GetSize())))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Point to the output buffer
        pRtpPdHeader = (PRTP_PD_HEADER)pbyDst;
        pRtpPdHeader->dwThisHeaderLength = sizeof(RTP_PD_HEADER);
        pRtpPdHeader->dwReserved = 0;
        pRtpPdHeader->dwNumHeaders = 0;
        pRtpPd = (PRTP_PD)(pbyDst + sizeof(RTP_PD_HEADER));

        // Let's break up that H.263 frame...
        if (HEADER(m_pCaptureFilter->m_pCapturePin->m_mt.pbFormat)->biCompression == FOURCC_M263)
        {
                // Look for the bitstream info trailer
                pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pbySrc + dwBytesExtent - sizeof(H26X_RTP_BSINFO_TRAILER));

                // Point in the buffer for the worst case
                pbyPayloadHeader = pbyDst + sizeof(RTP_PD_HEADER) + sizeof(RTP_PD) * pbsiT->dwNumOfPackets;

                // If the whole frame can fit in m_dwMaxRTPPacketSize, send it non fragmented
                if ((pbsiT->dwCompressedSize + 4) < m_dwMaxRTPPacketSize)
                        bOneFrameOnePacket = TRUE;

                // Look for the packet to receive a H.263 payload header
                while ((dwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && dwPktCount))
                {
                        pRtpPd->dwThisHeaderLength = sizeof(RTP_PD);
                        pRtpPd->dwLayerId = 0;
                        pRtpPd->dwVideoAttributes = 0;
                        pRtpPd->dwReserved = 0;
                        // @todo Update the timestamp field!
                        pRtpPd->dwTimestamp = 0xFFFFFFFF;
                        pRtpPd->dwPayloadHeaderOffset = pbyPayloadHeader - pbyDst;
                        pRtpPd->fEndMarkerBit = TRUE;

#ifdef LOGPAYLOAD_TOFILE
                        // Dump the whole frame in the debug window for comparison with receive side
                        if (!dwPktCount)
                        {
                                g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                                SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
                                wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
                                WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
                                wsprintf(szDebug, "Frame #%03ld has %1ld packets of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
                                OutputDebugString(szDebug);
                                pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H263_BSINFO));
                                for (wPrevOffset=0, i=1; i<(long)pbsiT->dwNumOfPackets; i++)
                                {
                                        wPrevOffset = pbsi263->dwBitOffset;
                                        pbsi263++;
                                        wsprintf(szDebug, "%04ld (S: %ld E: %ld), ", (DWORD)(pbsi263->dwBitOffset - wPrevOffset) >> 3, wPrevOffset, pbsi263->dwBitOffset);
                                        OutputDebugString(szDebug);
                                }
                                wsprintf(szDebug, "%04ld (S: %ld E: %ld)\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset) >> 3, pbsi263->dwBitOffset, pbsiT->dwCompressedSize * 8);
                                OutputDebugString(szDebug);
                                for (i=pbsiT->dwCompressedSize, p=pbySrc; i>0; i-=4, p+=4)
                                {
                                        wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
                                        WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
                                }
                                CloseHandle(g_DebugFile);
                        }
#endif

                        // Look for the bitstream info structure
                        pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - dwPktCount) * sizeof(RTP_H263_BSINFO));

                        // Set the marker bit: as long as this is not the last packet of the frame
                        // this bit needs to be set to 0
                        if (!bOneFrameOnePacket)
                        {
                                // Count the number of GOBS that could fit in m_dwMaxRTPPacketSize
                                for (i=1; (i<(long)(pbsiT->dwNumOfPackets - dwPktCount)) && (pbsi263->byMode != RTP_H263_MODE_B); i++)
                                {
                                        // Don't try to add a Mode B packet to the end of another Mode A or Mode B packet
                                        if (((pbsi263+i)->dwBitOffset - pbsi263->dwBitOffset > (m_dwMaxRTPPacketSize * 8)) || ((pbsi263+i)->byMode == RTP_H263_MODE_B))
                                                break;
                                }

                                if (i < (long)(pbsiT->dwNumOfPackets - dwPktCount))
                                {
                                        pRtpPd->fEndMarkerBit = FALSE;
                                        if (i>1)
                                                i--;
                                }
                                else
                                {
                                        // Hey! You 're forgetting the last GOB! It could make the total
                                        // size of the last packet larger than m_dwMaxRTPPacketSize... Imbecile!
                                        if ((pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset > (m_dwMaxRTPPacketSize * 8)) && (i>1))
                                        {
                                                pRtpPd->fEndMarkerBit = FALSE;
                                                i--;
                                        }
                                }
                        }

                        // Go to the beginning of the data
                        pRtpPd->dwPayloadStartBitOffset = pbsi263->dwBitOffset;

                        // Look for the kind of header to be built
                        if (pbsi263->byMode == RTP_H263_MODE_A)
                        {
                                // Build a header in mode A

                                // Header in mode A (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                // But that's the network byte order...

                                // Header in mode A (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC |I|U|S|A|R      |DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                // F bit set to 0
                                dwHeaderHigh = 0x00000000;

                                // Set the SRC bits
                                dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

                                // R bits already set to 0

                                // Set the P bit
                                dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

                                if(RTPPayloadHeaderModeValue==RTPPayloadHeaderMode_Draft) {  // 0 is the default mode
                                    // Set the I bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

                                    // Set the A bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

                                    // Set the S bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;
                                } else {
                                    // Set the I bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 20;

                                    // Set the U bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_UMV) << 15;

                                    // Set the S bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 15;

                                    // Set the A bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 15;
                                }

                                // Set the DBQ bits
                                dwHeaderHigh |= ((DWORD)(pbsiT->byDBQ)) << 11;

                                // Set the TRB bits
                                dwHeaderHigh |= ((DWORD)(pbsiT->byTRB)) << 8;

                                // Set the TR bits
                                dwHeaderHigh |= ((DWORD)(pbsiT->byTR));

                                // Special case: 1 frame = 1 packet
                                if (bOneFrameOnePacket)
                                {
                                        // SBIT is already set to 0

                                        // EBIT is already set to 0

                                        // Update the packet size
#ifdef LOGPAYLOAD_ON
                                        dwPktSize = pbsiT->dwCompressedSize + 4;
#endif
                                        pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;

                                        // Update the packet count
                                        dwPktCount = pbsiT->dwNumOfPackets;
                                }
                                else
                                {
                                        // Set the SBIT bits
                                        dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

                                        // Set the EBIT bits
                                        if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                        {
                                                dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;
                                                pRtpPd->dwPayloadEndBitOffset = (pbsi263+i)->dwBitOffset - 1;
                                        }
                                        else
                                        {
                                                pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;
                                        }

#ifdef LOGPAYLOAD_ON
                                        // Update the packet size
                                        if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                                dwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 4;
                                        else
                                                dwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 4;
#endif
                                        // Update the packet count
                                        dwPktCount += i;
                                }

                                // Save the payload header
                                pRtpPd->dwPayloadHeaderLength = 4;

                if ((DWORD)(pbyPayloadHeader - pbyDst) + pRtpPd->dwPayloadHeaderLength > dwDstBufferSize)
                {
                            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: buffer too small. size:%d", _fx_, dwDstBufferSize));
                            Hr = S_FALSE;
                            goto MyExit;
                }

                                // Convert to network byte order
                                *(pbyPayloadHeader+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
                                *(pbyPayloadHeader+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
                                *(pbyPayloadHeader+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
                                *(pbyPayloadHeader) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);

#ifdef LOGPAYLOAD_ON
                                // Output some debug stuff
                                wsprintf(szDebug, "Header content:\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, (*pbyPayloadHeader & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, (*pbyPayloadHeader & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*pbyPayloadHeader & 0x38) >> 3));
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*pbyPayloadHeader & 0x07));
                                OutputDebugString(szDebug);
                                switch ((DWORD)(*(pbyPayloadHeader+1) >> 5))
                                {
                                        case 0:
                                                wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*(pbyPayloadHeader+1) >> 5));
                                                break;
                                }
                                OutputDebugString(szDebug);

                                if(RTPPayloadHeaderModeValue==RTPPayloadHeaderMode_Draft) {
                                    OutputDebugString("Draft Style Payload Header flags (MODE A):\r\n");
                                    wsprintf(szDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbyPayloadHeader[1] & 0x1F)); // no need for ">> 5"
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                } else {
                                    OutputDebugString("RFC 2190 Style Payload Header flags (MODE A):\r\n");
                                    wsprintf(szDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((pbyPayloadHeader[1] & 0x01) << 3) | (DWORD)((pbyPayloadHeader[2] & 0xE0) >> 5));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[1] & 0x10) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[1] & 0x08) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '0' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[1] & 0x04) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[1] & 0x02) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                }

                                wsprintf(szDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((*(pbyPayloadHeader+2) & 0x18) >> 3));
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(*(pbyPayloadHeader+2) & 0x07));
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "    TR:  %03ld\r\n", (DWORD)(*(pbyPayloadHeader+3)));
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n", dwPktCount, *(pbyPayloadHeader), *(pbyPayloadHeader+1), *(pbyPayloadHeader+2), *(pbyPayloadHeader+3));
                                OutputDebugString(szDebug);
                                if (pRtpPd->fEndMarkerBit == TRUE)
                                        wsprintf(szDebug, " Marker: ON\r\n");
                                else
                                        wsprintf(szDebug, " Marker: OFF\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, dwPktSize);
                                OutputDebugString(szDebug);
                                if(g_dbg_LOGPAYLOAD_RtpPd > 0)
                                        g_dbg_LOGPAYLOAD_RtpPd--;
                                else if(g_dbg_LOGPAYLOAD_RtpPd == 0)
                                        DebugBreak();
#endif
                        }
                        else if (pbsi263->byMode == RTP_H263_MODE_B)
                        {
                                // Build a header in mode B

                                // Header in mode B (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |I|A|S|  GOBN   |   MBA         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //| HMV1          |  VMV1         |  HMV2         |   VMV2        |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                // But that's the network byte order...

                                // Header in mode B (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |  GOBN   |   MBA           | R |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|I|U|S|A| HMV1        |  VMV1       |  HMV2       |   VMV2      |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                                // Set the F bit to 1
                                dwHeaderHigh = 0x80000000;
                                dwHeaderLow  = 0x00000000;

                                // Set the SRC bits
                                dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

                                // Set the QUANT bits
                                dwHeaderHigh |= ((DWORD)(pbsi263->byQuant)) << 16;

                                // Set the P bit
                                dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

                                if(RTPPayloadHeaderModeValue==RTPPayloadHeaderMode_Draft) {
                                    // Set the I bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

                                    // Set the A bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

                                    // Set the S bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;

                                    // Set the GOBN bits
                                    dwHeaderHigh |= ((DWORD)(pbsi263->byGOBN)) << 8;

                                    // Set the TR bits
                                    dwHeaderHigh |= ((DWORD)(pbsi263->byMBA));

                                    // Set the HMV1 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV1)) << 24;

                                    // Set the VMV1 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV1)) << 16;

                                    // Set the HMV2 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV2)) << 8;

                                    // Set the VMV2 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV2));
                                } else {
                                    // Set the I bit
                                    dwHeaderLow |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 31;

                                    // Set the U bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_UMV) << 26;

                                    // Set the S bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 26;

                                    // Set the A bit
                                    dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 26;

                                    // Set the GOBN bits
                                    dwHeaderHigh |= ((DWORD)(pbsi263->byGOBN)) << 11;

                                    // Set the TR bits
                                    dwHeaderHigh |= ((DWORD)(pbsi263->byMBA)) << 2;

                                    // Set the HMV1 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV1) & 0x7F) << 21;

                                    // Set the VMV1 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV1) & 0x7F) << 14;

                                    // Set the HMV2 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV2) & 0x7F) << 7;

                                    // Set the VMV2 bits
                                    dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV2) & 0x7F);
                                }

                                // Special case: 1 frame = 1 packet
                                if (bOneFrameOnePacket)
                                {
                                        // SBIT is already set to 0

                                        // EBIT is already set to 0

                                        // Update the packet size
#ifdef LOGPAYLOAD_ON
                                        dwPktSize = pbsiT->dwCompressedSize + 8;
#endif
                                        pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;

                                        // Update the packet count
                                        dwPktCount = pbsiT->dwNumOfPackets;
                                }
                                else
                                {
                                        // Set the SBIT bits
                                        dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

                                        // Set the EBIT bits
                                        if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                        {
                                                dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;
                                                pRtpPd->dwPayloadEndBitOffset = (pbsi263+i)->dwBitOffset - 1;
                                        }
                                        else
                                        {
                                                pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;
                                        }

#ifdef LOGPAYLOAD_ON
                                        // Update the packet size
                                        if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                                dwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 8;
                                        else
                                                dwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 8;
#endif
                                        // Update the packet count
                                        dwPktCount += i;
                                }

                                // Save the payload header
                                pRtpPd->dwPayloadHeaderLength = 8;

                if ((DWORD)(pbyPayloadHeader - pbyDst) + pRtpPd->dwPayloadHeaderLength > dwDstBufferSize)
                {
                            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: buffer too small. size:%d", _fx_, dwDstBufferSize));
                            Hr = S_FALSE;
                            goto MyExit;
                }

                                // Convert to network byte order
                                *(pbyPayloadHeader+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
                                *(pbyPayloadHeader+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
                                *(pbyPayloadHeader+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
                                *(pbyPayloadHeader) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
                                *(pbyPayloadHeader+7) = (BYTE)(dwHeaderLow & 0x000000FF);
                                *(pbyPayloadHeader+6) = (BYTE)((dwHeaderLow >> 8) & 0x000000FF);
                                *(pbyPayloadHeader+5) = (BYTE)((dwHeaderLow >> 16) & 0x000000FF);
                                *(pbyPayloadHeader+4) = (BYTE)((dwHeaderLow >> 24) & 0x000000FF);

#ifdef LOGPAYLOAD_ON
                                // Output some info
                                wsprintf(szDebug, "Header content:\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, (*pbyPayloadHeader & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, (*pbyPayloadHeader & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*pbyPayloadHeader & 0x38) >> 3));
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*pbyPayloadHeader & 0x07));
                                OutputDebugString(szDebug);
                                switch ((DWORD)(*(pbyPayloadHeader+1) >> 5))
                                {
                                        case 0:
                                                wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*(pbyPayloadHeader+1) >> 5));
                                                break;
                                }
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, " QUANT:   %02ld\r\n", (DWORD)((*(pbyPayloadHeader+1) & 0x1F) >> 5));
                                OutputDebugString(szDebug);

                                if(RTPPayloadHeaderModeValue==RTPPayloadHeaderMode_Draft) {
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbyPayloadHeader[2] & 0x1F));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "   MBA:  %03ld\r\n", (DWORD)(pbyPayloadHeader[3]));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  HMV1:  %03ld\r\n", (DWORD)(pbyPayloadHeader[7]));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  VMV1:  %03ld\r\n", (DWORD)(pbyPayloadHeader[6]));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  HMV2:  %03ld\r\n", (DWORD)(pbyPayloadHeader[5]));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbyPayloadHeader[4]));
                                    OutputDebugString(szDebug);
                                } else {
                                    wsprintf(szDebug, (pbyPayloadHeader[4] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[4] & 0x40) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '0' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[4] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, (pbyPayloadHeader[4] & 0x10) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbyPayloadHeader[2] & 0xF8) >>3);
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "   MBA:  %03ld\r\n", (DWORD)((pbyPayloadHeader[2] & 0x07) << 6) | (DWORD)((pbyPayloadHeader[3] & 0xFC) >> 2));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbyPayloadHeader[3] & 0x03));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  HMV1:  %03ld\r\n", (DWORD)((pbyPayloadHeader[4] & 0x0F) << 3) | (DWORD)((pbyPayloadHeader[5] & 0xE0) >> 5));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  VMV1:  %03ld\r\n", (DWORD)((pbyPayloadHeader[5] & 0x1F) << 2) | (DWORD)((pbyPayloadHeader[6] & 0xC0) >> 6));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  HMV2:  %03ld\r\n", (DWORD)((pbyPayloadHeader[6] & 0x3F) << 1) | (DWORD)((pbyPayloadHeader[7] & 0x80) >> 7));
                                    OutputDebugString(szDebug);
                                    wsprintf(szDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbyPayloadHeader[7] & 0x7F));
                                    OutputDebugString(szDebug);
                                }

                                wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX %02lX %02lX %02lX %02lX\r\n", dwPktCount, *(pbyPayloadHeader), *(pbyPayloadHeader+1), *(pbyPayloadHeader+2), *(pbyPayloadHeader+3), *(pbyPayloadHeader+4), *(pbyPayloadHeader+5), *(pbyPayloadHeader+6), *(pbyPayloadHeader+7));
                                OutputDebugString(szDebug);

                                if (pRtpPd->fEndMarkerBit == TRUE)
                                        wsprintf(szDebug, " Marker: ON\r\n");
                                else
                                        wsprintf(szDebug, " Marker: OFF\r\n");
                                OutputDebugString(szDebug);
                                wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, dwPktSize);
                                OutputDebugString(szDebug);
#endif
                        }

                        // Move to the next potential header position
                        pbyPayloadHeader += pRtpPd->dwPayloadHeaderLength;
                        pRtpPd++;
                }

                // Update the number of headers
                pRtpPdHeader->dwNumHeaders = ((long)((PBYTE)pRtpPd - pbyDst) + sizeof(RTP_PD_HEADER)) / sizeof(RTP_PD);
                pRtpPdHeader->dwTotalByteLength = (DWORD)(pbyPayloadHeader - pbyDst);
        }
        else // Let's break up that H.261 frame...
        {
                // Look for the bitstream info trailer
                pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pbySrc + dwBytesExtent - sizeof(H26X_RTP_BSINFO_TRAILER));

                // Point in the buffer for the worst case
                pbyPayloadHeader = pbyDst + sizeof(RTP_PD_HEADER) + sizeof(RTP_PD) * pbsiT->dwNumOfPackets;

                // If the whole frame can fit in m_dwMaxRTPPacketSize, send it non fragmented
                if ((pbsiT->dwCompressedSize + 4) < m_dwMaxRTPPacketSize)
                        bOneFrameOnePacket = TRUE;

                // Look for the packet to receive a H.263 payload header
                while ((dwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && dwPktCount))
                {
                        pRtpPd->dwThisHeaderLength = sizeof(RTP_PD);
                        pRtpPd->dwLayerId = 0;
                        pRtpPd->dwVideoAttributes = 0;
                        pRtpPd->dwReserved = 0;
                        // @todo Update the timestamp field!
                        pRtpPd->dwTimestamp = 0xFFFFFFFF;
                        pRtpPd->dwPayloadHeaderOffset = pbyPayloadHeader - pbyDst;
                        pRtpPd->fEndMarkerBit = TRUE;

#ifdef LOGPAYLOAD_ON
                        // Dump the whole frame in the debug window for comparison with receive side
                        if (!dwPktCount)
                        {
                                g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                                SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
                                wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
                                WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
                                wsprintf(szDebug, "Frame #%03ld has %1ld GOBs of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
                                OutputDebugString(szDebug);
                                pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H261_BSINFO));
                                for (wPrevOffset=0, i=1; i<(long)pbsiT->dwNumOfPackets; i++)
                                {
                                        wPrevOffset = pbsi261->dwBitOffset;
                                        pbsi261++;
                                        wsprintf(szDebug, "%04ld, ", (DWORD)(pbsi261->dwBitOffset - wPrevOffset) >> 3);
                                        OutputDebugString(szDebug);
                                }
                                wsprintf(szDebug, "%04ld\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset) >> 3);
                                OutputDebugString(szDebug);
                                for (i=pbsiT->dwCompressedSize, p=pbySrc; i>0; i-=4, p+=4)
                                {
                                        wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
                                        WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
                                }
                                CloseHandle(g_DebugFile);
                        }
#endif

                        // Look for the bitstream info structure
                        pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - dwPktCount) * sizeof(RTP_H261_BSINFO));

                        // Set the marker bit: as long as this is not the last packet of the frame
                        // this bit needs to be set to 0
                        if (!bOneFrameOnePacket)
                        {
                                // Count the number of GOBS that could fit in m_dwMaxRTPPacketSize
                                for (i=1; i<(long)(pbsiT->dwNumOfPackets - dwPktCount); i++)
                                {
                                        if ((pbsi261+i)->dwBitOffset - pbsi261->dwBitOffset > (m_dwMaxRTPPacketSize * 8))
                                                break;
                                }

                                if (i < (long)(pbsiT->dwNumOfPackets - dwPktCount))
                                {
                                        pRtpPd->fEndMarkerBit = FALSE;
                                        if (i>1)
                                                i--;
                                }
                                else
                                {
                                        // Hey! You 're forgetting the last GOB! It could make the total
                                        // size of the last packet larger than dwMaxFragSize... Imbecile!
                                        if ((pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset > (m_dwMaxRTPPacketSize * 8)) && (i>1))
                                        {
                                                pRtpPd->fEndMarkerBit = FALSE;
                                                i--;
                                        }
                                }
                        }

                        // Go to the beginning of the data
                        pRtpPd->dwPayloadStartBitOffset = pbsi261->dwBitOffset;

                        // Build a header to this thing!

                        // 0                   1                   2                   3
                        // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        //|SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        // But that's the network byte order...

                        // Set the V bit to 1
                        dwHeaderHigh = 0x01000000;

                        // Set the I bit
                        dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 25;

                        // Set the GOBn bits
                        dwHeaderHigh |= ((DWORD)(pbsi261->byGOBN)) << 20;

                        // Set the MBAP bits
                        dwHeaderHigh |= ((DWORD)(pbsi261->byMBA)) << 15;

                        // Set the QUANT bits
                        dwHeaderHigh |= ((DWORD)(pbsi261->byQuant)) << 10;

                        // Set the HMVD bits
                        dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cHMV)) << 5;

                        // Set the VMVD bits
                        dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cVMV));

                        // Special case: 1 frame = 1 packet
                        if (bOneFrameOnePacket)
                        {
                                // SBIT is already set to 0

                                // EBIT is already set to 0

                                // Update the packet size
#ifdef LOGPAYLOAD_ON
                                dwPktSize = pbsiT->dwCompressedSize + 4;
#endif
                                pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;

                                // Update the packet count
                                dwPktCount = pbsiT->dwNumOfPackets;
                        }
                        else
                        {
                                // Set the SBIT bits
                                dwHeaderHigh |= (pbsi261->dwBitOffset % 8) << 29;

                                // Set the EBIT bits
                                if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                {
                                        dwHeaderHigh |= (DWORD)((8UL - ((pbsi261+i)->dwBitOffset % 8)) & 0x00000007) << 26;
                                        pRtpPd->dwPayloadEndBitOffset = (pbsi261+i)->dwBitOffset - 1;
                                }
                                else
                                {
                                        pRtpPd->dwPayloadEndBitOffset = pbsiT->dwCompressedSize * 8 - 1;
                                }

#ifdef LOGPAYLOAD_ON
                                // Update the packet size
                                if ((pbsiT->dwNumOfPackets - dwPktCount - i) >= 1)
                                        dwPktSize = (((pbsi261+i)->dwBitOffset - 1) / 8) - (pbsi261->dwBitOffset / 8) + 1 + 4;
                                else
                                        dwPktSize = pbsiT->dwCompressedSize - pbsi261->dwBitOffset / 8 + 4;
#endif
                                // Update the packet count
                                dwPktCount += i;
                        }

                        // Save the payload header
                        pRtpPd->dwPayloadHeaderLength = 4;

            if ((DWORD)(pbyPayloadHeader - pbyDst) + pRtpPd->dwPayloadHeaderLength > dwDstBufferSize)
            {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: buffer too small. size:%d", _fx_, dwDstBufferSize));
                        Hr = S_FALSE;
                        goto MyExit;
            }

                        // Convert to network byte order
                        *(pbyPayloadHeader+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
                        *(pbyPayloadHeader+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
                        *(pbyPayloadHeader+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
                        *(pbyPayloadHeader) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);

#ifdef LOGPAYLOAD_ON
                        // Output some debug stuff
                        wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n", dwPktCount, *(pbyPayloadHeader), *(pbyPayloadHeader+1), *(pbyPayloadHeader+2), *(pbyPayloadHeader+3));
                        OutputDebugString(szDebug);
                        if (pRtpPd->fEndMarkerBit == TRUE)
                                wsprintf(szDebug, " Marker: ON\r\n");
                        else
                                wsprintf(szDebug, " Marker: OFF\r\n");
                        OutputDebugString(szDebug);
                        wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, dwPktSize);
                        OutputDebugString(szDebug);
#endif

                        // Move to the next potential header position
                        pbyPayloadHeader += pRtpPd->dwPayloadHeaderLength;
                        pRtpPd++;
                }

                // Update the number of headers
                pRtpPdHeader->dwNumHeaders = ((long)((PBYTE)pRtpPd - pbyDst) + sizeof(RTP_PD_HEADER)) / sizeof(RTP_PD);
                pRtpPdHeader->dwTotalByteLength = (DWORD)(pbyPayloadHeader - pbyDst);
        }

        pRSample->SetSyncPoint (TRUE);
        pRSample->SetActualDataLength (pbyPayloadHeader - pbyDst);
        pRSample->SetDiscontinuity(bDiscon);
        pRSample->SetPreroll(FALSE);

        // Get the timestamps from the video sample.
        pSample->GetTime(&rtSample, &rtEnd);
        pRSample->SetTime(&rtSample, &rtEnd);

        // IAMStreamControl stuff. Has somebody turned us off for now?
        iStreamState = CheckStreamState(pRSample);
        if (iStreamState == STREAM_FLOWING)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Sending frame", _fx_));
                if (m_pCaptureFilter->m_cs.fLastRtpPdSampleDiscarded)
                        pRSample->SetDiscontinuity(TRUE);
                m_pCaptureFilter->m_cs.fLastRtpPdSampleDiscarded = FALSE;
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Discarding frame", _fx_));
                m_pCaptureFilter->m_cs.fLastRtpPdSampleDiscarded = TRUE;
                Hr = S_FALSE;           // discarding
        }

        // Don't deliver it if the stream is off for now
        if (iStreamState == STREAM_FLOWING)
        {
                if ((Hr = Deliver (pRSample)) == S_FALSE)
                        Hr = E_FAIL;    // stop delivering anymore, this is serious
        }
#ifdef DEBUG
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Frame wasn't delivered!", _fx_));
        }
#endif

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | SetProperties | This method is used to
 *    specify the size, number, and alignment of blocks.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pRequest | Specifies a pointer to the
 *    requested allocator properties.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pActual | Specifies a pointer to the
 *    allocator properties actually set.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::SetProperties(IN ALLOCATOR_PROPERTIES *pRequest, OUT ALLOCATOR_PROPERTIES *pActual)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::SetProperties")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pRequest);
        ASSERT(pActual);
        if (!pRequest || !pActual)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // If we have already allocated headers & buffers ignore the
        // requested and return the actual numbers. Otherwise, make a
        // note of the requested so that we can honour it later.
        if (!Committed())
        {
                m_parms.cBuffers  = pRequest->cBuffers;
                m_parms.cbBuffer  = pRequest->cbBuffer;
                m_parms.cbAlign   = pRequest->cbAlign;
                m_parms.cbPrefix  = pRequest->cbPrefix;
        }

        pActual->cBuffers   = (long)m_parms.cBuffers;
        pActual->cbBuffer   = (long)m_parms.cbBuffer;
        pActual->cbAlign    = (long)m_parms.cbAlign;
        pActual->cbPrefix   = (long)m_parms.cbPrefix;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetProperties | This method is used to
 *    retrieve the properties being used on this allocator.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pProps | Specifies a pointer to the
 *    requested allocator properties.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::GetProperties(ALLOCATOR_PROPERTIES *pProps)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CRtpPdPin::GetProperties")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pProps);
        if (!pProps)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        pProps->cBuffers = (long)m_parms.cBuffers;
        pProps->cbBuffer = (long)m_parms.cbBuffer;
        pProps->cbAlign  = (long)m_parms.cbAlign;
        pProps->cbPrefix = (long)m_parms.cbPrefix;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | Commit | This method is used to
 *    commit the memory for the specified buffers.
 *
 *  @rdesc This method returns S_OK.
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::Commit()
{
        FX_ENTRY("CRtpPdPin::Commit")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | Decommit | This method is used to
 *    release the memory for the specified buffers.
 *
 *  @rdesc This method returns S_OK.
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::Decommit()
{
        FX_ENTRY("CRtpPdPin::Decommit")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | GetBuffer | This method is used to
 *    retrieve a container for a sample.
 *
 *  @rdesc This method returns E_FAIL.
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime, REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
        FX_ENTRY("CRtpPdPin::GetBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return E_FAIL;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | ReleaseBuffer | This method is used to
 *    release the <c CMediaSample> object. The final call to Release() on
 *    <i IMediaSample> will call this method.
 *
 *  @parm IMediaSample* | pSample | Specifies a pointer to the buffer to
 *    release.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag S_OK | No error
 ***************************************************************************/
STDMETHODIMP CRtpPdPin::ReleaseBuffer(IMediaSample *pSample)
{
        HRESULT Hr = S_OK;
        LPTHKVIDEOHDR ptvh;

        FX_ENTRY("CRtpPdPin::ReleaseBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pSample);
        if (!pSample)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (ptvh = ((CRtpPdSample *)pSample)->GetFrameHeader())
                Hr = m_pCaptureFilter->ReleaseFrame(ptvh);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | DecideBufferSize | This method is
 *    used to retrieve the number and size of buffers required for transfer.
 *
 *  @parm IMemAllocator* | pAlloc | Specifies a pointer to the allocator
 *    assigned to the transfer.
 *
 *  @parm ALLOCATOR_PROPERTIES* | ppropInputRequest | Specifies a pointer to an
 *    <t ALLOCATOR_PROPERTIES> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest)
{
        HRESULT Hr = NOERROR;
        ALLOCATOR_PROPERTIES Actual;

        FX_ENTRY("CRtpPdPin::DecideBufferSize")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pAlloc);
        ASSERT(ppropInputRequest);
        if (!pAlloc || !ppropInputRequest)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // @todo We shouldn't need that many buffers and you probably need a different number
        // of buffers if you are capturing in streaming mode of frame grabbing mode
        // You also need to decouple this number from the number of video capture buffers: only
        // if you need to ship the video capture buffer downstream (possible on the preview pin)
        // should you make those number equal.
        ppropInputRequest->cBuffers = MAX_VIDEO_BUFFERS;
        ppropInputRequest->cbPrefix = 0;
        ppropInputRequest->cbAlign  = 1;
        ppropInputRequest->cbBuffer = MAX_RTP_PD_BUFFER_SIZE;

        // Validate alignment
        ppropInputRequest->cbBuffer = (long)ALIGNUP(ppropInputRequest->cbBuffer + ppropInputRequest->cbPrefix, ppropInputRequest->cbAlign) - ppropInputRequest->cbPrefix;

        ASSERT(ppropInputRequest->cbBuffer);
        if (!ppropInputRequest->cbBuffer)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Buffer size is 0!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Using %d buffers, prefix %d size %d align %d", _fx_, ppropInputRequest->cBuffers, ppropInputRequest->cbPrefix, ppropInputRequest->cbBuffer, ppropInputRequest->cbAlign));

        Hr = pAlloc->SetProperties(ppropInputRequest,&Actual);

        // It's our allocator, we know we'll be happy with what it decided

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CRTPPDPINMETHOD
 *
 *  @mfunc HRESULT | CRtpPdPin | DecideAllocator | This method is
 *    used to negotiate the allocator to use.
 *
 *  @parm IMemInputPin* | pPin | Specifies a pointer to the IPin interface
 *    of the connecting pin.
 *
 *  @parm IMemAllocator** | ppAlloc | Specifies a pointer to the negotiated
 *    IMemAllocator interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpPdPin::DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc)
{
        HRESULT Hr = NOERROR;
        ALLOCATOR_PROPERTIES prop;

        FX_ENTRY("CRtpPdPin::DecideAllocator")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPin);
        ASSERT(ppAlloc);
        if (!pPin || !ppAlloc)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (FAILED(GetInterface(static_cast<IMemAllocator*>(this), (void **)ppAlloc)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetInterface failed!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Get downstream allocator property requirement
        ZeroMemory(&prop, sizeof(prop));

        if (SUCCEEDED(Hr = DecideBufferSize(*ppAlloc, &prop)))
        {
                // Our buffers are not read only
                if (SUCCEEDED(Hr = pPin->NotifyAllocator(*ppAlloc, FALSE)))
                        goto MyExit;
        }

        (*ppAlloc)->Release();
        *ppAlloc = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\tapivcap.cpp ===
/****************************************************************************
 *  @doc INTERNAL TAPIVCAP
 *
 *  @module TAPIVCap.cpp | Source file for the <c VCfWCapture>
 *    class used to implement the TAPI Capture Source filter.
 ***************************************************************************/

#include "Precomp.h"

#if DEBUG_MULTIPROCESS
#include <process.h>
#endif //DEBUG_MULTIPROCESS


#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif
#define TAPIVCAP_DEBUG
//#include "dbgutil.h" // this defines the __DBGUTIL_H__ below
#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef TAPIVCAP_DEBUG
    DEFINE_DBG_VARS(tapivcap, (NTSD_OUT | LOG_OUT), 0x0);
  #else
    DEFINE_DBG_VARS(tapivcap, 0, 0);
  #endif
  #define D(f) if(g_dbg_tapivcap & (f))

#else
  #undef TAPIVCAP_DEBUG

  #define D(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


#ifdef DEBUG
// Setup data
const AMOVIESETUP_MEDIATYPE sudCaptureType[] =
{
        {
                &MEDIATYPE_Video,       // Major type
                &MEDIASUBTYPE_NULL      // Minor type
        }
};

const AMOVIESETUP_MEDIATYPE sudRTPPDType[] =
{
        {
                &KSDATAFORMAT_TYPE_RTP_PD,      // Major type
                &MEDIASUBTYPE_NULL                      // Minor type
        }
};

const AMOVIESETUP_PIN sudCapturePins[] =
{
        {
                L"Capture",                     // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudCaptureType  // Pin details
        },
        {
                L"Preview",                     // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudCaptureType  // Pin details
        },
#ifdef USE_OVERLAY
        {
                L"Overlay",                     // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudCaptureType  // Pin details
        },
#endif
        {
                L"RTP PD",                      // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudRTPPDType            // Pin details
        }
};

const AMOVIESETUP_FILTER sudVideoCapture =
{
        &__uuidof(TAPIVideoCapture),// Filter CLSID
        L"TAPI Video Capture",  // String name
        MERIT_DO_NOT_USE,               // Filter merit
#ifdef USE_OVERLAY
        4,                                              // Number pins
#else
        3,                                              // Number pins
#endif
        sudCapturePins                  // Pin details
};
#endif



#include "CritSec.h"

extern "C" {
int                     g_IsNT = FALSE;

// we don't want to share out any global var
// #pragma data_seg(".shared")
VIDEOCAPTUREDEVICEINFO  g_aDeviceInfo[MAX_CAPTURE_DEVICES] = {0};
DWORD           g_dwNumDevices = (DWORD)-1L;
// #pragma data_seg()


//------ xtra debug activated if XTRA_TRACE is defined
#include "dbgxtra.h"
//----------------------------------------------------
}

// critical section to protect global var
CRITICAL_SECTION g_CritSec;

#if DXMRTP <= 0

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    VIDEO_CAPTURE_TEMPLATE

#ifdef USE_PROPERTY_PAGES
    /* Begin properties */

#ifdef USE_SOFTWARE_CAMERA_CONTROL
    ,CAPCAMERA_CONTROL_TEMPLATE
#endif

#ifdef USE_NETWORK_STATISTICS
    ,NETWORK_STATISTICS_TEMPLATE
#endif

#ifdef USE_PROGRESSIVE_REFINEMENT
    .CAPTURE_PIN_TEMPLATE
#endif

    ,CAPTURE_PIN_PROP_TEMPLATE
    ,PREVIEW_PIN_TEMPLATE
    ,CAPTURE_DEV_PROP_TEMPLATE

#ifdef USE_CPU_CONTROL
    ,CPU_CONTROL_TEMPLATE
#endif

    ,RTP_PD_PROP_TEMPLATE

    /* End properties */
#endif /* USE_PROPERTY_PAGES */
};
int g_cTemplates = SIZEOF_ARRAY(g_Templates);

STDAPI DllRegisterServer()
{
        return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
        return AMovieDllRegisterServer2(FALSE);
}

EXTERN_C BOOL WINAPI DllEntryPoint(HANDLE hInst, ULONG lReason, LPVOID lpReserved);

BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
{
        switch (dwReason)
        {
                case DLL_PROCESS_ATTACH:
                {
                        OSVERSIONINFO OSVer;

                        OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                        GetVersionEx((LPOSVERSIONINFO)&OSVer);

                        g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

            __try
            {
                InitializeCriticalSection (&g_CritSec);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                return FALSE;
            }

                        if (!g_IsNT)
                        {
                                ThunkInit();
                        }
                        else
                        {
                                if (!NTvideoInitHandleList())
                {
                    return FALSE;
                }
                        }
                        break;
                }

                case DLL_PROCESS_DETACH:
                {
                        if (!g_IsNT)
                        {
                                // We're going away - Disconnect the thunking stuff
                                ThunkTerm();
                        }
                        else
                        {
                                NTvideoDeleteHandleList();
                        }

            DeleteCriticalSection (&g_CritSec);

                        break;
                }
        }

        // Pass the call onto the DShow SDK initialization
        return DllEntryPoint(hInst, dwReason, lpReserved);
}
#else /* DXMRTP <= 0 */
BOOL VideoInit(DWORD dwReason)
{
        switch (dwReason)
        {
                case DLL_PROCESS_ATTACH:
                {
                        OSVERSIONINFO OSVer;

                        OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                        GetVersionEx((LPOSVERSIONINFO)&OSVer);

                        g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

            __try
            {
                InitializeCriticalSection (&g_CritSec);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                return FALSE;
            }

                        if (!g_IsNT)
                        {
                                ThunkInit();
                        }
                        else
                        {
                                if (!NTvideoInitHandleList())
                {
                    return FALSE;
                }
                        }
                        break;
                }

                case DLL_PROCESS_DETACH:
                {
                        if (!g_IsNT)
                        {
                                // We're going away - Disconnect the thunking stuff
                                ThunkTerm();
                        }
                        else
                        {
                                NTvideoDeleteHandleList();
                        }

            DeleteCriticalSection (&g_CritSec);

                        break;
                }
        }
    return TRUE;
}
#endif /* DXMRTP <= 0 */

#if DBG
DWORD g_dwVideoCaptureTraceID = INVALID_TRACEID;
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc void | CTAPIVCap | CTAPIVCap | This method is the constructor
 *    for the <c CTAPIVCap> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVCap::CTAPIVCap(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr)
: m_lock(), CBaseFilter(pName, pUnkOuter, &m_lock, __uuidof(TAPIVideoCapture))
{
        FX_ENTRY("CTAPIVCap::CTAPIVCap")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Provide defaults
        m_pCapturePin = NULL;
#ifdef USE_OVERLAY
        m_pOverlayPin = NULL;
#endif
        m_pPreviewPin = NULL;
        m_pRtpPdPin = NULL;
        m_pCapDev = NULL;
        m_fAvoidOverlay = TRUE;
        m_fPreviewCompressedData = TRUE;
        m_dwDeviceIndex = -1;

        // Capture thread management
        m_hThread = NULL;
        m_state = TS_Not;
        m_tid = 0;
        m_hEvtPause = NULL;
        m_hEvtRun = NULL;
        m_pBufferQueue = NULL;
        ZeroMemory(&m_user, sizeof(m_user));
        ZeroMemory(&m_cs, sizeof(m_cs));

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        m_RTPPayloadHeaderMode = RTPPayloadHeaderMode_Draft;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc void | CTAPIVCap | ~CTAPIVCap | This method is the destructor
 *    for the <c CTAPIVCap> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVCap::~CTAPIVCap()
{
        FX_ENTRY("CTAPIVCap::~CTAPIVCap")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Ensure that all streams are inactive
        Stop();

        // Release the pins
        if (m_pCapturePin)
                delete m_pCapturePin, m_pCapturePin = NULL;
        if (m_pPreviewPin)
                delete m_pPreviewPin, m_pPreviewPin = NULL;
#ifdef USE_OVERLAY
        if (m_pOverlayPin)
                delete m_pOverlayPin, m_pOverlayPin = NULL;
#endif
        if (m_pRtpPdPin)
                delete m_pRtpPdPin, m_pRtpPdPin = NULL;

        // Release the capture device
        if (m_pCapDev)
                delete m_pCapDev, m_pCapDev = NULL;
        if (m_dwDeviceIndex != -1)
                g_aDeviceInfo[m_dwDeviceIndex].fInUse = FALSE;

        if (m_hThread)
                CloseHandle (m_hThread);
        m_hThread = NULL;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc CUnknown* | CTAPIVCap | CreateInstance | This
 *    method is called by DShow to create an instance of the TAPI Video Capture
 *    Source filter referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown *CALLBACK CreateTAPIVCapInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr)
{
#if DBG
    if (g_dwVideoCaptureTraceID == INVALID_TRACEID)
    {
        // if two threads happen to call this method at the same time, it is
        // serialized inside TraceRegister.
        g_dwVideoCaptureTraceID = TraceRegister(TEXT("dxmrtp_VideoCapture"));
    }
#endif

    CUnknown *pUnknown = NULL;
        DWORD dwNumDevices = 0UL;

        FX_ENTRY("CTAPIVCap::CreateInstance")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        if (!pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        if (!(pUnknown = new CTAPIVCap(pUnkOuter, NAME("TAPI Video Capture"), pHr)))
        {
                *pHr = E_OUTOFMEMORY;
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CTAPIVCap failed", _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CTAPIVCap created", _fx_));
        }

        // Make sure that there is at least one capture device installed before creating this filter
        if (FAILED(GetNumVideoCapDevicesInternal(&dwNumDevices,FALSE)) || !dwNumDevices)
        {
                delete pUnknown, pUnknown = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVfwCaptureDialogs>, <i IAMVideoProcAmp>,
 *    <i ICameraControl>, <i IH245VideoCapability>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IAMVfwCaptureDialogs))
        {
                if (m_pCapDev)
                        Hr = m_pCapDev->NonDelegatingQueryInterface(riid, ppv);
                else
                {
                        Hr = E_FAIL;
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: NDQI for IAMVfwCaptureDialogs failed Hr=0x%08lX because device hasn't been opened yet or it is not a VfW device", _fx_, Hr));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IAMVideoControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IAMVideoControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMVideoControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMVideoControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
        else if (riid == __uuidof(IVideoProcAmp))
        {
                if (m_pCapDev)
                        Hr = m_pCapDev->NonDelegatingQueryInterface(riid, ppv);
                else
                {
                        Hr = E_FAIL;
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: NDQI for IAMVideoProcAmp failed Hr=0x%08lX because device hasn't been opened yet or it is not a WDM device", _fx_, Hr));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(ICameraControl))
        {
                if (m_pCapDev)
                        Hr = m_pCapDev->NonDelegatingQueryInterface(riid, ppv);
                else
                {
                        Hr = E_FAIL;
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: NDQI for ICameraControl failed Hr=0x%08lX because device hasn't been opened yet or it is not a WDM device", _fx_, Hr));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IVideoDeviceControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IVideoDeviceControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IVideoDeviceControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IVideoDeviceControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        // Retrieve interface pointer
        else if (riid == __uuidof(IRTPPayloadHeaderMode))
        {
                if (FAILED(Hr = GetInterface(static_cast<IRTPPayloadHeaderMode*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IRTPPayloadHeaderMode failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IRTPPayloadHeaderMode*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }

        if (FAILED(Hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv)))
        {
                if (FAILED(Hr = CUnknown::NonDelegatingQueryInterface(riid, ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::GetPages")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        pPages->cElems = 2;
#else
        pPages->cElems = 1;
#endif
        if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_OUTOFMEMORY;
        }
        else
        {
                pPages->pElems[0] = __uuidof(CaptureDevicePropertyPage);
#ifdef USE_SOFTWARE_CAMERA_CONTROL
                pPages->pElems[1] = __uuidof(TAPICameraControlPropertyPage);
#endif
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetPinCount | This method returns the pin
 *    count. There is typically a Capture Pin, a Preview pin, and sometimes
 *    an Overlay pin.
 *
 *  @rdesc This method returns the number of pins.
 ***************************************************************************/
int CTAPIVCap::GetPinCount()
{
        DWORD dwNumPins = 0;

        FX_ENTRY("CTAPIVCap::GetPinCount")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Count the number of active pins
        if (m_pCapturePin)
                dwNumPins++;
        if (m_pPreviewPin)
                dwNumPins++;
        if (m_pRtpPdPin)
                dwNumPins++;
#ifdef USE_OVERLAY
        if (m_pOverlayPin)
                dwNumPins++;
#endif

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: dwNumPins=%ld", _fx_, dwNumPins));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return dwNumPins;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetPin | This method returns a non-addrefed
 *    pointer to the <c cBasePin> of a pin.
 *
 *  @parm int | n | Specifies the number of the pin.
 *
 *  @rdesc This method returns NULL or a pointer to a <c CBasePin> object.
 ***************************************************************************/
CBasePin *CTAPIVCap::GetPin(IN int n)
{
        CBasePin *pCBasePin;

        FX_ENTRY("CTAPIVCap::GetPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        switch(n)
        {
                case 0:
                        pCBasePin = m_pCapturePin;
                        break;

                case 1:
                        pCBasePin = m_pPreviewPin;
                        break;

                case 2:
                        pCBasePin = m_pRtpPdPin;
                        break;

#ifdef USE_OVERLAY
                case 3:
                        pCBasePin = m_pOverlayPin;
                        break;
#endif
                default:
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid pin number n=%ld", _fx_, n));
                        pCBasePin = NULL;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: pCBasePin=0x%08lX", _fx_, pCBasePin));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return pCBasePin;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | Run | This method transitions the filter
 *    from paused to running state if it is not in this state already.
 *
 *  @parm REFERENCE_TIME | tStart | Specifies the reference time value
 *    corresponding to stream time 0.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::Run(IN REFERENCE_TIME tStart)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::Run")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin (tStart=%ld)", _fx_, (LONG)((CRefTime)tStart).Millisecs()));

        CAutoLock cObjectLock(m_pLock);

        // Remember the stream time offset before notifying the pins
        m_tStart = tStart;

        // If we are in the stopped state, first pause the filter.
        if (m_State == State_Stopped)
        {
                // If the real Pause got an error, this will try a second time
                if (FAILED(Hr = Pause()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pause failed Hr=0x%08lX", _fx_, Hr));
                        goto MyExit;
                }
        }

        // Tell the Stream Control stuff what's going on
        if (m_pPreviewPin)
                m_pPreviewPin->NotifyFilterState(State_Running, tStart);
        if (m_pCapturePin)
                m_pCapturePin->NotifyFilterState(State_Running, tStart);
        if (m_pRtpPdPin)
                m_pRtpPdPin->NotifyFilterState(State_Running, tStart);

        // Now put our streaming video pin into the Run state
        if (m_State == State_Paused)
        {
                int cPins = GetPinCount();

                // Do we have at least a pin?
                if (cPins > 0)
                {
                        if (m_pCapturePin && m_pCapturePin->IsConnected())
                        {
                                if (FAILED(Hr = m_pCapturePin->ActiveRun(tStart)))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActiveRun failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }

                        if (m_pRtpPdPin && m_pRtpPdPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pRtpPdPin->ActiveRun(tStart)))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActiveRun failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }

#ifdef USE_OVERLAY
                        if (m_pOverlayPin && m_pOverlayPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pOverlayPin->ActiveRun(tStart)))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActiveRun failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }
#endif
                        if (m_pPreviewPin && m_pPreviewPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pPreviewPin->ActiveRun(tStart)))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActiveRun failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }
                }
        }

        m_State = State_Running;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | Pause | This method transitions the filter
 *    the filter to State_Paused state if it is not in this state already.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::Pause()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::Pause")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock cObjectLock(m_pLock);

        // We have a driver dialog up that is about to change the capture settings.
        // Now is NOT a good time to start streaming.
        if (m_State == State_Stopped && m_pCapDev->m_fDialogUp)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Dialog up. SORRY!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // Tell the Stream Control stuff what's going on
        if (m_pPreviewPin)
                m_pPreviewPin->NotifyFilterState(State_Paused, 0);
        if (m_pCapturePin)
                m_pCapturePin->NotifyFilterState(State_Paused, 0);
        if (m_pRtpPdPin)
                m_pRtpPdPin->NotifyFilterState(State_Paused, 0);

        // Notify the pins of the change from Run-->Pause
        if (m_State == State_Running)
        {
                int cPins = GetPinCount();

                // Make sure we have pins
                if (cPins > 0)
                {
                        if (m_pCapturePin && m_pCapturePin->IsConnected())
                        {
                                if (FAILED(Hr = m_pCapturePin->ActivePause()))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActivePause failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }

                        if (m_pRtpPdPin && m_pRtpPdPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pRtpPdPin->ActivePause()))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActivePause failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }

#ifdef USE_OVERLAY
                        if (m_pOverlayPin && m_pOverlayPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pOverlayPin->ActivePause()))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActivePause failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }
#endif
                        if (m_pPreviewPin && m_pPreviewPin->IsConnected())
                        {
                                if (FAILED(Hr = m_pPreviewPin->ActivePause()))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ActivePause failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }
                }
        }

        // notify all pins BACKWARDS! so the overlay pin is started first, so the
        // overlay channel is intitialized before the capture channel (this is the
        // order AVICap did things in and we have to do the same thing or buggy
        // drivers like the Broadway or BT848 based drivers won't preview while
        // capturing.
        if (m_State == State_Stopped)
        {
                int cPins = GetPinCount();
                for (int c = cPins - 1; c >=  0; c--)
                {
                        CBasePin *pPin = GetPin(c);

                        // Disconnected pins are not activated - this saves pins
                        // worrying about this state themselves
                        if (pPin->IsConnected())
                        {
                                if (FAILED(Hr = pPin->Active()))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Active failed Hr=0x%08lX", _fx_, Hr));
                                        goto MyExit;
                                }
                        }
                }
        }

        m_State = State_Paused;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | Stop | This method transitions the filter
 *    the filter to State_Stopped state if it is not in this state already.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::Stop()
{
        HRESULT Hr = NOERROR, Hr2;

        FX_ENTRY("CTAPIVCap::Stop")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock cObjectLock(m_pLock);

        // Shame on the base classes
        if (m_State == State_Running)
        {
                if (FAILED(Hr = Pause()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pause failed Hr=0x%08lX", _fx_, Hr));
                        goto MyExit;
                }
        }

        // Tell the Stream Control stuff what's going on
        if (m_pPreviewPin)
                m_pPreviewPin->NotifyFilterState(State_Stopped, 0);
        if (m_pCapturePin)
                m_pCapturePin->NotifyFilterState(State_Stopped, 0);
        if (m_pRtpPdPin)
                m_pRtpPdPin->NotifyFilterState(State_Stopped, 0);

MyExit:
    Hr2 = CBaseFilter::Stop();

    if (SUCCEEDED(Hr))
    {
        Hr = Hr2;
    }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | SetSyncSource | This method identifies the
 *    reference clock to which the filter should synchronize activity.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm The <p pClock> parameter can be NULL, meaning that the filter
 *    should run as fast as possible at its current quality settings
 *    without any attempt to synchronize...
***************************************************************************/
STDMETHODIMP CTAPIVCap::SetSyncSource(IN IReferenceClock *pClock)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::SetSyncSource")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        if (!pClock)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (m_pCapturePin)
                m_pCapturePin->SetSyncSource(pClock);
        if (m_pPreviewPin)
                m_pPreviewPin->SetSyncSource(pClock);
        if (m_pRtpPdPin)
                m_pRtpPdPin->SetSyncSource(pClock);

        Hr = CBaseFilter::SetSyncSource(pClock);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::SetMode(IN RTPPayloadHeaderMode rtpphmMode)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::SetMode")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190);
        if (!(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Save new target packet size
        m_RTPPayloadHeaderMode = rtpphmMode;

        dout(1, g_dwVideoCaptureTraceID, TRCE, "%s:   New RTP Payload Header mode: %s\n", _fx_, (rtpphmMode == RTPPayloadHeaderMode_RFC2190)?"RFC2190":"Draft");
        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   New RTP Payload Header mode: %s", _fx_, (rtpphmMode == RTPPayloadHeaderMode_RFC2190)?"RFC2190":"Draft"));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | JoinFilterGraph | This method is used to
 *    inform a filter that it has joined a filter graph.
 *
 *  @parm IFilterGraph | pGraph | Specifies a pointer to the filter graph to
 *    join.
 *
 *  @parm LPCWSTR | pName | Specifies the name of the filter being added.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't validate input parameters as both pointers can be
 *    NULL when we leave the graph.
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices = 0UL;

        FX_ENTRY("CTAPIVCap::JoinFilterGraph")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    EnterCriticalSection (&g_CritSec);

#if DEBUG_MULTIPROCESS
    char Buf[100];
    wsprintfA(Buf, "\nPID:%x, %p entered\n", _getpid(), this);
    OutputDebugStringA(Buf);
#endif //DEBUG_MULTIPROCESS


        if(pGraph != NULL) { // only for a true join operation we are interested in having any devices to join to ...
                // Get the number of installed capture devices
                if (FAILED(Hr = GetNumDevices(&dwNumDevices)))          // || !dwNumDevices) <--- this is tested below anyway
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get number of installed devices!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                // Make sure that there is at least one capture device installed before proceeding
                if (!dwNumDevices)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: There are not capture device installed!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
        }

        // Only grab capture device and create the pins when in a graph
        if (m_pCapturePin == NULL && pGraph != NULL)
        {
                dprintf("JoinFilterGraph : ........... m_pCapturePin == NULL && pGraph != NULL\n");
                if (m_dwDeviceIndex == -1)
                {
                        // Use the default capture device
                        if (FAILED(Hr = GetCurrentDevice(&m_dwDeviceIndex)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get current device ID", _fx_, Hr));
                                goto MyExit;
                        }
                }

                // Only open the capture device if it isn't in use
                if (g_aDeviceInfo[m_dwDeviceIndex].fInUse)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Device already in use", _fx_, Hr));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                // Reserve the device
                g_aDeviceInfo[m_dwDeviceIndex].fInUse = TRUE;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Reserving device with index m_dwDeviceIndex = %d", _fx_, m_dwDeviceIndex));
                // What's the VfW device Id for this device?
                m_user.uVideoID = g_aDeviceInfo[m_dwDeviceIndex].dwVfWIndex;

                // Create the capture device object
                if (g_aDeviceInfo[m_dwDeviceIndex].nDeviceType == DeviceType_VfW)
                {
                        if (FAILED(Hr = CVfWCapDev::CreateVfWCapDev(this, m_dwDeviceIndex, &m_pCapDev)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture device object couldn't be created!", _fx_));
                                goto MyExit;
                        }
                }
                else if (g_aDeviceInfo[m_dwDeviceIndex].nDeviceType == DeviceType_WDM)
                {
                        if (FAILED(Hr = CWDMCapDev::CreateWDMCapDev(this, m_dwDeviceIndex, &m_pCapDev)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture device object couldn't be created!", _fx_));
                                goto MyExit;
                        }
                }
                else 
                {
                    ASSERT(g_aDeviceInfo[m_dwDeviceIndex].nDeviceType == DeviceType_DShow);
                    if (FAILED(Hr = CDShowCapDev::CreateDShowCapDev(this, m_dwDeviceIndex, &m_pCapDev)))
                    {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture device object couldn't be created!", _fx_));
                        goto MyExit;
                    }
                }


                // Open the device and get the capabilities of the device
                if (FAILED(Hr = m_pCapDev->ConnectToDriver()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ConnectToDriver failed!", _fx_));
                        goto MyExit;
                }


                // Create compressed output pin
                if (FAILED(Hr = CCapturePin::CreateCapturePin(this, &m_pCapturePin)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture pin couldn't be created!", _fx_));
                        goto MyError;
                }



                // If we can do h/w preview with overlay, great, otherwise we'll do a non-overlay preview
#ifdef USE_OVERLAY
                if (m_fAvoidOverlay || !m_cs.bHasOverlay || FAILED(Hr = COverlayPin::CreateOverlayPin(this, &m_pOverlayPin)))
                {
                        // We'll use regular preview if we don't get overlay
                        if (FAILED(Hr = CPreviewPin::CreatePreviewPin(this, &m_pPreviewPin)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Preview pin couldn't be created!", _fx_));
                                goto MyError;
                        }
                }
#else
                if (FAILED(Hr = CPreviewPin::CreatePreviewPin(this, &m_pPreviewPin)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Preview pin couldn't be created!", _fx_));
                        goto MyError;
                }
#endif

                // Create the RTP packetization descriptor pin
                if (FAILED(Hr = CRtpPdPin::CreateRtpPdPin(this, &m_pRtpPdPin)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Rtp Pd pin couldn't be created!", _fx_));
                        goto MyError;
                }

                D(1) dprintf("%s : m_pPreviewPin @ %p -> m_fFlipHorizontal = %d , m_fFlipVertical = %d\n", _fx_, m_pPreviewPin, m_pPreviewPin->m_fFlipHorizontal, m_pPreviewPin->m_fFlipVertical);
                D(1) dprintf("%s : m_pCapturePin @ %p -> m_fFlipHorizontal = %d , m_fFlipVertical = %d\n", _fx_, m_pCapturePin, m_pCapturePin->m_fFlipHorizontal, m_pCapturePin->m_fFlipVertical);
                D(2) DebugBreak();

#ifdef TEST_H245_VID_CAPS
                m_pCapturePin->TestH245VidC();
#endif
#ifdef TEST_ISTREAMCONFIG
                m_pCapturePin->TestIStreamConfig();
#endif

                // Initialize the driver format with the capture pin information
                if (FAILED(Hr = m_pCapDev->SendFormatToDriver(
                     HEADER(m_pCapturePin->m_mt.pbFormat)->biWidth,
                     HEADER(m_pCapturePin->m_mt.pbFormat)->biHeight,
                     HEADER(m_pCapturePin->m_mt.pbFormat)->biCompression,
                     HEADER(m_pCapturePin->m_mt.pbFormat)->biBitCount,
                     ((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame,
                     FALSE
                     )))
                           {
                                   DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: SendFormatToDriver failed! (1)", _fx_));
                                   goto MyExit;
                           }

                // Update the capture mode field for this device
                if (!m_pCapDev->m_dwStreamingMode || (m_pCapDev->m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_user.pvi->bmiHeader.biHeight < 240 && m_user.pvi->bmiHeader.biWidth < 320))
                        g_aDeviceInfo[m_dwDeviceIndex].nCaptureMode = CaptureMode_Streaming;
                else
                        g_aDeviceInfo[m_dwDeviceIndex].nCaptureMode = CaptureMode_FrameGrabbing;

                // If the frame rate is lower than expected, remember this
                ((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lAvgTimePerFrameRangeMin = max(m_pCapturePin->m_lAvgTimePerFrameRangeMin, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lMaxAvgTimePerFrame = max(m_pCapturePin->m_lMaxAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lAvgTimePerFrameRangeDefault = max(m_pCapturePin->m_lAvgTimePerFrameRangeDefault, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lCurrentAvgTimePerFrame = max(m_pCapturePin->m_lCurrentAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);

                if (m_user.pvi!=NULL && HEADER(m_user.pvi)->biCompression == VIDEO_FORMAT_YUY2) {
                        HKEY    hRTCDeviceKey  = NULL;
                        DWORD   dwSize, dwType, dwDisableYUY2VFlip=0;

                        dprintf("dwDisableYUY2VFlip check...\n");
                        // Check if the RTC key is there
                        if (RegOpenKey(RTCKEYROOT, szRegRTCKey, &hRTCDeviceKey) == ERROR_SUCCESS)
                        {
                                dwSize = sizeof(DWORD);
                                RegQueryValueEx(hRTCDeviceKey, (LPTSTR)szDisableYUY2VFlipKey, NULL, &dwType, (LPBYTE)&dwDisableYUY2VFlip, &dwSize);
                                //if above fails, just do nothing, we'll use the initialized value for dwDisableYUY2VFlip, that is 0
                                RegCloseKey(hRTCDeviceKey);
                        }
                        if(!dwDisableYUY2VFlip) {
                                dprintf("------------------------- Enable Vertical FLIP ...\a\n");
                                m_pCapturePin->m_fFlipVertical = TRUE;
                        }
                }


                if ((VIDEOINFOHEADER *)m_pPreviewPin->m_mt.pbFormat)
                        {
                                    ((VIDEOINFOHEADER *)m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                        }
                m_pPreviewPin->m_lAvgTimePerFrameRangeMin = max(m_pPreviewPin->m_lAvgTimePerFrameRangeMin, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lMaxAvgTimePerFrame = max(m_pPreviewPin->m_lMaxAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lAvgTimePerFrameRangeDefault = max(m_pPreviewPin->m_lAvgTimePerFrameRangeDefault, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lCurrentAvgTimePerFrame = max(m_pPreviewPin->m_lCurrentAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);

                // Set the size of the VIDEOINFOHEADER to the size of valid data for this format.
                m_user.cbFormat = GetBitmapFormatSize(&m_user.pvi->bmiHeader);

                // Set number of buffers
                // @todo This should be adjusted on the available memory and the
                // type of capture (streaming 4 buffs vs. frame grabbing 1 buff)
                m_user.nMinBuffers = MIN_VIDEO_BUFFERS;
                if (g_aDeviceInfo[m_dwDeviceIndex].nDeviceType == DeviceType_DShow) {
                    // this device type doesn't need more than 2 (save memory)
                    m_user.nMaxBuffers = 2;
                } else {
                    m_user.nMaxBuffers = MAX_VIDEO_BUFFERS;
                }
                m_user.dwTickScale = 10000UL;
                m_user.dwTickRate = (DWORD)m_pCapturePin->m_lAvgTimePerFrameRangeDefault;

                IncrementPinVersion();

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Creating pins", _fx_));

                //** cache in the CCapDev instance the chosen VIDEOCAPTUREDEVICEINFO from the global array
                if (FAILED(Hr = GetVideoCapDeviceInfo(m_dwDeviceIndex, &(m_pCapDev->m_vcdi))))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot cache the global VIDEOCAPTUREDEVICEINFO !", _fx_));
                        goto MyExit;
                }
                m_pCapDev->m_bCached_vcdi = TRUE;
        }
        else if (pGraph != NULL)
        {
                dprintf("JoinFilterGraph : ........... pGraph != NULL\n");
                // Take resources only when in the filter graph
                if (!m_pCapDev || FAILED(Hr = m_pCapDev->ConnectToDriver()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ConnectToDriver failed Hr=0x%08lX", _fx_, Hr));
                        goto MyExit;
                }

                // Initialize the driver format with the capture pin information
                if (FAILED(Hr = m_pCapDev->SendFormatToDriver(
            HEADER(m_pCapturePin->m_mt.pbFormat)->biWidth,
            HEADER(m_pCapturePin->m_mt.pbFormat)->biHeight,
            HEADER(m_pCapturePin->m_mt.pbFormat)->biCompression,
            HEADER(m_pCapturePin->m_mt.pbFormat)->biBitCount,
            ((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame,
            FALSE
            )))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: SendFormatToDriver failed! (2)", _fx_));
                        goto MyExit;
                }

#if DEBUG_MULTIPROCESS
        wsprintfA(Buf, "\nPID:%x, %p, PreviewPin:%p\n", _getpid(), this, m_pPreviewPin);
        OutputDebugStringA(Buf);
#endif // DEBUG_MULTIPROCESS

        // If the frame rate is lower than expected, remember this
                ((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lAvgTimePerFrameRangeMin = max(m_pCapturePin->m_lAvgTimePerFrameRangeMin, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lMaxAvgTimePerFrame = max(m_pCapturePin->m_lMaxAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lAvgTimePerFrameRangeDefault = max(m_pCapturePin->m_lAvgTimePerFrameRangeDefault, (long)m_user.pvi->AvgTimePerFrame);
                m_pCapturePin->m_lCurrentAvgTimePerFrame = max(m_pCapturePin->m_lCurrentAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                ((VIDEOINFOHEADER *)m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lAvgTimePerFrameRangeMin = max(m_pPreviewPin->m_lAvgTimePerFrameRangeMin, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lMaxAvgTimePerFrame = max(m_pPreviewPin->m_lMaxAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lAvgTimePerFrameRangeDefault = max(m_pPreviewPin->m_lAvgTimePerFrameRangeDefault, (long)m_user.pvi->AvgTimePerFrame);
                m_pPreviewPin->m_lCurrentAvgTimePerFrame = max(m_pPreviewPin->m_lCurrentAvgTimePerFrame, (long)m_user.pvi->AvgTimePerFrame);

                // Set the size of the VIDEOINFOHEADER to the size of valid data for this format.
                m_user.cbFormat = GetBitmapFormatSize(&m_user.pvi->bmiHeader);

                // Set number of buffers
                // @todo This should be adjusted on the available memory and the
                // type of capture (streaming 4 buffs vs. frame grabbing 1 buff)
                m_user.nMinBuffers = MIN_VIDEO_BUFFERS;
                if (g_aDeviceInfo[m_dwDeviceIndex].nDeviceType == DeviceType_DShow) {
                    // this device type doesn't need more than 2 (save memory)
                    m_user.nMaxBuffers = 2;
                } else {
                    m_user.nMaxBuffers = MAX_VIDEO_BUFFERS;
                }
                m_user.dwTickScale = 10000UL;
                m_user.dwTickRate = (DWORD)m_pCapturePin->m_lAvgTimePerFrameRangeDefault;

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Reconnecting pins", _fx_));
        }
        else if (m_pCapturePin)
        {
                dprintf("JoinFilterGraph : ........... m_pCapturePin (!= NULL) .... unjoin...\n");
                // Give back resources when not in graph
                if (m_pCapDev)
                        m_pCapDev->DisconnectFromDriver();

                // Release format structure
                if (m_user.pvi)
                        delete m_user.pvi, m_user.pvi = NULL;

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Disconnecting pins", _fx_));
        }

        if (FAILED(Hr = CBaseFilter::JoinFilterGraph(pGraph, pName)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class JoinFilterGraph failed Hr=0x%08lX", _fx_, Hr));
                goto MyExit;
        }

        if (m_pCapturePin)
                m_pCapturePin->SetFilterGraph(m_pSink);
        if (m_pRtpPdPin)
                m_pRtpPdPin->SetFilterGraph(m_pSink);
        if (m_pPreviewPin)
                m_pPreviewPin->SetFilterGraph(m_pSink);

        goto MyExit;

MyError:
        // Release the pins
        if (m_pCapturePin)
                delete m_pCapturePin, m_pCapturePin = NULL;
        if (m_pPreviewPin)
                delete m_pPreviewPin, m_pPreviewPin = NULL;
#ifdef USE_OVERLAY
        if (m_pOverlayPin)
                delete m_pOverlayPin, m_pOverlayPin = NULL;
#endif
        if (m_pRtpPdPin)
                delete m_pRtpPdPin, m_pRtpPdPin = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

#if DEBUG_MULTIPROCESS
    wsprintfA(Buf, "\nPID:%x, %p left, hr=%x\n", _getpid(), this, Hr);
    OutputDebugStringA(Buf);
#endif  // DEBUG_MULTIPROCESS

    LeaveCriticalSection (&g_CritSec);

        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetState | This method is used to
 *    retrieve the current state of the filter. We don't send any data during
 *    PAUSE, so to avoid hanging renderers, we need to return VFW_S_CANT_CUE
 *    when paused.
 *
 *  @parm DWORD | dwMilliSecsTimeout | Specifies the duration of the time-out,
 *    in milliseconds.
 *
 *  @parm FILTER_STATE* | State | Specifies the name of the filter being added.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetState(IN DWORD dwMilliSecsTimeout, OUT FILTER_STATE *State)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::GetState")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(State);
        if (!State)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        *State = m_State;

        if (m_State == State_Paused)
                Hr = VFW_S_CANT_CUE;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | CreatePins | This method is used to
 *    retrieve the current state of the filter. We don't send any data during
 *    PAUSE, so to avoid hanging renderers, we need to return VFW_S_CANT_CUE
 *    when paused.
 *
 *  @parm DWORD | dwMilliSecsTimeout | Specifies the duration of the time-out,
 *    in milliseconds.
 *
 *  @parm FILTER_STATE* | State | Specifies the name of the filter being added.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::CreatePins()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVCap::CreatePins")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock cObjectLock(m_pLock);

        // Validate input parameters
        ASSERT(!m_pCapturePin);
        ASSERT(!m_pRtpPdPin);
        ASSERT(!m_pPreviewPin);
#ifdef USE_OVERLAY
        ASSERT(!m_pOverlayPin);
        if (m_pCapturePin || m_pRtpPdPin || m_pPreviewPin || m_pOverlayPin)
#else
        if (m_pCapturePin || m_pRtpPdPin || m_pPreviewPin)
#endif
{
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pins already exist!", _fx_));
                Hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
                goto MyExit;
        }

        // Create our output pins for the video data stream, RTP packetization descriptor data stream, and maybe overlay
        if (FAILED(Hr = CCapturePin::CreateCapturePin(this, &m_pCapturePin)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture pin couldn't be created!", _fx_));
                goto MyError;
        }

#ifdef TEST_H245_VID_CAPS
        m_pCapturePin->TestH245VidC();
#endif
#ifdef TEST_ISTREAMCONFIG
                m_pCapturePin->TestIStreamConfig();
#endif

        // If we can do h/w preview with overlay, great, otherwise we'll do a non-overlay preview
#ifdef USE_OVERLAY
        if (m_fAvoidOverlay || !m_cs.bHasOverlay || FAILED(Hr = COverlayPin::CreateOverlayPin(this, &m_pOverlayPin)))
        {
                // We'll use regular preview if we don't get overlay
                if (FAILED(Hr = CPreviewPin::CreatePreviewPin(this, &m_pPreviewPin)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Preview pin couldn't be created!", _fx_));
                        goto MyError;
                }
        }
#else
        if (FAILED(Hr = CPreviewPin::CreatePreviewPin(this, &m_pPreviewPin)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Preview pin couldn't be created!", _fx_));
                goto MyError;
        }
#endif

        if (FAILED(Hr = CRtpPdPin::CreateRtpPdPin(this, &m_pRtpPdPin)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Rtp Pd pin couldn't be created!", _fx_));
                goto MyError;
        }

        goto MyExit;

MyError:
        // Release the pins
        if (m_pCapturePin)
                delete m_pCapturePin, m_pCapturePin = NULL;
        if (m_pPreviewPin)
                delete m_pPreviewPin, m_pPreviewPin = NULL;
#ifdef USE_OVERLAY
        if (m_pOverlayPin)
                delete m_pOverlayPin, m_pOverlayPin = NULL;
#endif
        if (m_pRtpPdPin)
                delete m_pRtpPdPin, m_pRtpPdPin = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\thunk.c ===
/****************************************************************************
 *  @doc INTERNAL THUNK
 *
 *  @module Thunk.c | Source file for thunking to 16-bit code without using
 *    the thunk compiler.
 ***************************************************************************/

#pragma warning(disable:4054)           /* cannot cast to function ptr */
#pragma warning(disable:4055)           /* cannot cast from function ptr */

#pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
#pragma warning(disable:4201)           /* winnt.h: nameless union */
#pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
#pragma warning(disable:4514)           /* winnt.h: fiber goo */

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <pshpack1.h>                   /* Byte packing, please */

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#ifdef WIN32
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif
#endif

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define pvAdd(pv, cb) ((LPVOID)((LPSTR)(pv) + (DWORD)(cb)))
#define pvSub(pv1, pv2) (DWORD)((LPSTR)(pv1) - (LPSTR)(pv2))

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT_PTR ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAdd(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                                pvAdd(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAdd(pidh, pedt->AddressOfFunctions);
                fp = (FARPROC)pvAdd(pidh, peat[ord - pedt->Base]);
                if (pvSub(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  This structure starts out life as the things that we will GetProcAddress
 *  for.  And then it turns into pointers to functions.
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

static TCHAR c_tszKernel32[] = TEXT("KERNEL32");

static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "QT_Thunk",
    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
};

#pragma END_CONST_DATA

typedef struct MANUALIMPORTTABLE {  /* mit */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    void        (__cdecl *QT_Thunk)(void);
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);

} MIT;

static MIT s_mit;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *          l = a 32-bit integer
 *          s = a 16-bit integer
 *
 *          P = returns a pointer
 *          L = returns a 32-bit integer
 *          S = returns a 16-bit signed integer
 *          U = returns a 16-bit unsigned integer
 *
 *  @parm   FARPROC | fp |
 *
 *          16:16 function to call.
 *
 *  @parm   PCSTR | pszSig |
 *
 *          Function signature.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifndef NON_X86
__declspec(naked) DWORD
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.MapLS;            /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    s_mit.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    s_mit.MapSL;            /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    s_mit.UnMapLS;          /* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}
#else
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
        return  0;
}
#endif

#pragma warning(default:4035)

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          Initialize the various goo we need in KERNEL32.
 *
 *          Returns FALSE if we cannot initialize the thunks.
 *          (For example, if the platform doesn't support flat thunks.)
 *
 *          Note that you must never ever call this function more
 *          than once.
 *
 ***************************************************************************/

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#endif

#pragma BEGIN_CONST_DATA

static char c_szVidx16[] = "VIDX16.DLL";

static LPCSTR c_rgpszVidx16[] = {
    (LPCSTR)6,      /* vidxAllocHeaders             */
    (LPCSTR)7,      /* vidxFreeHeaders              */
    (LPCSTR)8,      /* vidxAllocBuffer              */
    (LPCSTR)9,      /* vidxAllocPreviewBuffer       */
    (LPCSTR)10,     /* vidxFreeBuffer               */
    (LPCSTR)11,     /* vidxSetRect                  */
    (LPCSTR)12,     /* vidxFrame                    */
    (LPCSTR)13,     /* vidxAddBuffer                */
    (LPCSTR)14,     /* vidxGetErrorText             */
    (LPCSTR)15,     /* vidxUpdate                   */
    (LPCSTR)16,     /* vidxDialog                   */
    (LPCSTR)17,     /* vidxStreamInit               */
    (LPCSTR)18,     /* vidxStreamFini               */
    (LPCSTR)19,     /* vidxConfigure                */
    (LPCSTR)20,     /* vidxOpen                     */
    (LPCSTR)21,     /* vidxClose                    */
    (LPCSTR)22,     /* vidxGetChannelCaps           */
    (LPCSTR)23,     /* vidxStreamReset              */
    (LPCSTR)24,     /* vidxStreamStart              */
    (LPCSTR)25,     /* vidxStreamStop               */
    (LPCSTR)26,     /* vidxStreamUnprepareHeader    */
    (LPCSTR)27,     /* vidxCapDriverDescAndVer      */
    (LPCSTR)28,     /* vidxMessage                  */
    (LPCSTR)29,     /* vidxFreePreviewBuffer        */
};

#pragma END_CONST_DATA

static HINSTANCE s_hinstVidx16;

static FARPROC s_rgfpVidx16[ARRAYSIZE(c_rgpszVidx16)];

#define s_fpvidxAllocHeaders            s_rgfpVidx16[0]
#define s_fpvidxFreeHeaders             s_rgfpVidx16[1]
#define s_fpvidxAllocBuffer             s_rgfpVidx16[2]
#define s_fpvidxAllocPreviewBuffer      s_rgfpVidx16[3]
#define s_fpvidxFreeBuffer              s_rgfpVidx16[4]
#define s_fpvidxFrame                   s_rgfpVidx16[6]
#define s_fpvidxAddBuffer               s_rgfpVidx16[7]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *           returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
#define s_fpvideoDialog                 s_rgfpVidx16[10]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD_PTR | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD_PTR | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
#define s_fpvideoStreamInit             s_rgfpVidx16[11]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
#define s_fpvideoStreamFini             s_rgfpVidx16[12]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
#define s_fpvideoConfigure              s_rgfpVidx16[13]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *           for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
#define s_fpvideoOpen                   s_rgfpVidx16[14]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
#define s_fpvideoClose                  s_rgfpVidx16[15]

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
#define s_fpvideoGetChannelCaps         s_rgfpVidx16[16]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoStreamReset | This function stops streaming
 *           on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
#define s_fpvideoStreamReset            s_rgfpVidx16[17]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
#define s_fpvideoStreamStart            s_rgfpVidx16[18]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
#define s_fpvideoStreamStop             s_rgfpVidx16[19]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoCapDriverDescAndVer | This function gets strings
 *   for the description and version of a video capture driver
 *
 * @parm DWORD | dwDeviceID | Specifies the index of which video driver to get
 *      information about.
 *
 * @parm LPTSTR | lpszDesc | Specifies a place to return the description
 *
 * @parm UINT | cbDesc | Specifies the length of the description string
 *
 * @parm LPTSTR | lpszVer | Specifies a place to return the version
 *
 * @parm UINT | cbVer | Specifies the length of the version string
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number.
 *
 * @comm Use this function to get strings describing the driver and its version
 *
/****************************************************************************/
#define s_fpvideoCapDriverDescAndVer    s_rgfpVidx16[21]

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
#define s_fpvideoMessage                s_rgfpVidx16[22]
#define s_fpvidxFreePreviewBuffer       s_rgfpVidx16[23]

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkTerm |
 *
 *          Free it.
 *
 ***************************************************************************/

void NTAPI
ThunkTerm(void)
{
    if (s_hinstVidx16) {
        s_mit.FreeLibrary16(s_hinstVidx16);
        s_hinstVidx16 = 0;
    }
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE NTAPI
ThunkGetProcAddresses(FARPROC rgfp[], LPCSTR rgpsz[], UINT cfp,
                      LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = s_mit.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = s_mit.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                s_mit.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ThunkInit |
 *
 *          GetProcAddress16 our brains out.
 *
 ***************************************************************************/

BOOL NTAPI
ThunkInit(void)
{
    HINSTANCE hinstK32 = GetModuleHandle(c_tszKernel32);
    BOOL fRc;

    if (hinstK32) {
        int i;
        FARPROC *rgfpMit = (LPVOID)&s_mit;

        for (i = 0; i < ARRAYSIZE(c_rgpszKernel32); i++) {
            if ((LONG_PTR)(c_rgpszKernel32[i]) & ~(LONG_PTR)65535) {
                rgfpMit[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
            } else {
                rgfpMit[i] = GetProcOrd(hinstK32, (UINT_PTR)c_rgpszKernel32[i]);
            }
            if (!rgfpMit[i]) return FALSE;  /* Aigh! */
        }

        s_hinstVidx16 =
            ThunkGetProcAddresses(s_rgfpVidx16, c_rgpszVidx16,
                                  ARRAYSIZE(s_rgfpVidx16),
                                  c_szVidx16);

        if (!s_hinstVidx16) {
            goto failed;
        }

        fRc = 1;

    } else {
    failed:;
        ThunkTerm();

        fRc = 0;
    }

    return fRc;
}


/***************************************************************************
 *
 *  Now come the actual thunklets.
 *
 ***************************************************************************/

// typedef DWORD   HDR32;
// typedef DWORD   HVIDEO;
// typedef DWORD  *LPHVIDEO;
typedef struct channel_caps_tag CHANNEL_CAPS, *LPCHANNEL_CAPS;


#include "ivideo32.h"

typedef PTR32 FAR * PPTR32;

extern int g_IsNT;

#define tHVIDEO                 "l"
#define tUINT                   "s"
#define tHWND                   "s"
#define tHDC                    "s"
#define tint                    "s"
#define tDWORD                  "l"
#define tLPARAM                 "l"
#define tDWORD_PTR              "l"     // exactly like DWORD, or we'll blow up
#define tHDR32                  "l"
#define tPTR32                  "l"
#define tLPVIDEOHDR             "p"     // was l
#define tLPVOID                 "p"
#define tLPDWORD                "p"
#define tPPTR32                 "p"
#define tLPSTR                  "p"
#define tLPTSTR                 "p"
#define tLPHVIDEO               "p"
#define tLPCHANNEL_CAPS         "p"
#define rDWORD                  "L"
#define rLRESULT                "L"

#pragma BEGIN_CONST_DATA


#define MAKETHUNK1(rT, fn, t1, a1)                                          \
rT NTAPI                                                                    \
fn(t1 a1)                                                                   \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1);                                                  \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1                                                       \
        r##rT,     a1);                                                     \
}                                                                           \

#define MAKETHUNK2(rT, fn, t1, a1, t2, a2)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2)                                                            \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2);                                               \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2                                                 \
        r##rT,   a1,     a2);                                               \
}                                                                           \

#define MAKETHUNK3(rT, fn, t1, a1, t2, a2, t3, a3)                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3)                                                     \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3);                                            \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3                                           \
        r##rT,   a1,     a2,   a3);                                         \
}                                                                           \

#define MAKETHUNK4(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4)                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4)                                              \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4);                                         \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4                                     \
        r##rT,     a1,   a2,   a3,   a4);                                   \
}                                                                           \

#define MAKETHUNK5(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5)          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5)                                       \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5);                                      \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5                               \
        r##rT,     a1,   a2,   a3,   a4,   a5);                             \
}                                                                           \

#define MAKETHUNK6(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6)  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6)                                \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6);                                   \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6                         \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6);                       \
}                                                                           \

#define MAKETHUNK7(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7)                                          \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7)                         \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7);                                \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7                   \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7);                 \
}                                                                           \

#define MAKETHUNK8(rT, fn, t1, a1, t2, a2, t3, a3, t4, a4, t5, a5, t6, a6,  \
                           t7, a7, t8, a8)                                  \
rT NTAPI                                                                    \
fn(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6, t7 a7, t8 a8)                  \
{                                                                           \
    if (g_IsNT)                                                             \
        return NT##fn(a1,a2,a3,a4,a5,a6,a7,a8);                             \
    else                                                                    \
        return (rT)TemplateThunk(s_fp##fn,                                  \
                t##t1 t##t2 t##t3 t##t4 t##t5 t##t6 t##t7 t##t8             \
        r##rT,     a1,   a2,   a3,   a4,   a5,   a6,   a7,   a8);           \
}                                                                           \

MAKETHUNK4(DWORD,   vidxAllocHeaders,
           HVIDEO,  hv,
           UINT,    nHeaders,
           UINT,    cbHeader,
           PPTR32,  lp32Hdrs)

MAKETHUNK1(DWORD,   vidxFreeHeaders,
           HVIDEO,  hv)

MAKETHUNK4(DWORD,   vidxAllocBuffer,
           HVIDEO,  hv,
           UINT,    iHdr,
           PPTR32,  pp32Hdr,
           DWORD,   dwSize)

MAKETHUNK4(DWORD,   vidxAllocPreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr,
           UINT,    cbHdr,
           DWORD,   cbData)

MAKETHUNK2(DWORD,   vidxFreePreviewBuffer,
           HVIDEO,  hv,
           PPTR32,  pp32Hdr)

MAKETHUNK2(DWORD,   vidxFreeBuffer,
           HVIDEO,  hv,
           DWORD,   p32Hdr)

MAKETHUNK3(DWORD,   videoDialog,
           HVIDEO,  hv,
           HWND,    hWndParent,
           DWORD,   dwFlags)

MAKETHUNK5(DWORD,   videoStreamInit,
           HVIDEO,  hvideo,
           DWORD,   dwMicroSecPerFrame,
           DWORD_PTR,   dwCallback,
           DWORD_PTR,   dwCallbackInst,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoStreamFini,
           HVIDEO,  hvideo)

MAKETHUNK2(DWORD,   vidxFrame,
           HVIDEO,  hvideo,
           LPVIDEOHDR, p32hdr)

MAKETHUNK8(DWORD,   videoConfigure,
           HVIDEO,  hvideo,
           UINT,    msg,
           DWORD,   dwFlags,
           LPDWORD, lpdwReturn,
           LPVOID,  lpData1,
           DWORD,   dwSize1,
           LPVOID,  lpData2,
           DWORD,   dwSize2)

MAKETHUNK3(DWORD,   videoOpen,
           LPHVIDEO,phv,
           DWORD,   dwDevice,
           DWORD,   dwFlags)

MAKETHUNK1(DWORD,   videoClose,
           HVIDEO,  hv)

MAKETHUNK3(DWORD,   videoGetChannelCaps,
           HVIDEO,  hv,
           LPCHANNEL_CAPS, lpcc,
           DWORD,  dwSize)

MAKETHUNK3(DWORD,   vidxAddBuffer,
           HVIDEO,  hvideo,
           PTR32,   p32Hdr,
           DWORD,   dwSize)

MAKETHUNK1(DWORD,   videoStreamReset,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStart,
           HVIDEO,  hvideo)

MAKETHUNK1(DWORD,   videoStreamStop,
           HVIDEO,  hvideo)

MAKETHUNK7(DWORD,   videoCapDriverDescAndVer,
           DWORD,  dwDeviceID,
           LPTSTR, lpszDesc,
           UINT,   cbDesc,
           LPTSTR, lpszVer,
           UINT,   cbVer,
           LPTSTR, lpszDllName,
           UINT,   cbDllName)

MAKETHUNK4(LRESULT,   videoMessage,
           HVIDEO,  hVideo,
           UINT,    uMsg,
           LPARAM,   dw1,
           LPARAM,   dw2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\tapivcap.h ===
/****************************************************************************
 *  @doc INTERNAL TAPIVCAP
 *
 *  @module TAPIVCap.h | Header file for the <c CTAPIVCap>
 *    class used to implement the TAPI Capture Source filter.
 ***************************************************************************/

/****************************************************************************
                                                                Table Of Contents
****************************************************************************/
/****************************************************************************
@doc INTERNAL

@contents1 Contents | To display a list of topics by category, click any
of the contents entries below. To display an alphabetical list of
topics, choose the Index button.

@head2 Introduction |
This DLL implements the TAPI MSP Video Capture filter. This filter reuses
some of the code that has been developed for the off-the-shelf VfW (QCAP) and
WDM (KSProxy) video capture filters, but adds a significant amount of
powerful processing functions to the capture process to meet all the
requirements discussed in section 4 of "Microsoft Video Capture Filter.doc".

This DLL adds support for  extended bitmap info headers for H.261 and H.263
video streams to communicate to the TAPI MSP Video Capture filter a list of
media types supported by the remote endpoint. Still, the decision to use
optional compression modes is left to the TAPI MSP Video Capture filter. The
current VfW off-the-shelf capture filter does not have a way to expose all
the capabilities of the capture device. We create our own media type
enumeration process to compensate for this limitation.

The TAPI MSP Video Capture filter also supports a number of DirectShow
interfaces (IAMVfwCaptureDialogs, IAMCrossbar, IAMVideoProcAmp,
ICameraControl, IAMVideoControl) to provide better control over the capture
process to TAPI applications.

It implements a new H.245 Video Capability interface (IH245VideoCapability)
to be used by the MSP in order to provide the TAPI MSP Capability module with
a table of estimated steady-state resource requirements as related to each
format that the capture device supports.

A new H.245 command interface (IH245EncoderCommand) is implemented to
communicate to the TAPI MSP Video Capture filter requests for I-frame, group
of blocks, or macro-block updates due to packet loss or multi-point switching.
We implement a network statistics interface (INetworkStats), to allow the
network to provide feedback on the channel conditions to the compressed video
output pin of the TAPI MSP Video Capture filter. The TAPI MSP Video Capture
filter is responsible for taking appropriate actions, if needed. The TAPI MSP
Video Capture filter also implements three control interfaces (ICPUControl,
IFrameRateControl, IBitrateControl) to be used by the TAPI MSP Quality
Controller to provide the best user experience.

The TAPI MSP Video Capture filter also exposes a preview output pin that can
be controlled independently of the capture output pin.

The TAPI MSP Video Capture filter exposes an interface (IProgressiveRefinement)
on its compressed video output pin to allow for transmission of
high-resolution stills that are continuously improved on the remote endpoint
as more data is received and decompressed. The TAPI MSP Video Capture filter
may also elect to implement this same interface on an optional separate and
dedicated still-image output pin.

Finally, the TAPI MSP Video Capture filter exposes an RTP packetization
descriptor output pin synchronized to the compressed capture output pin. The
downstream RTP Network Sink filter uses this second pin to understand how to
better fragment the compressed video data into network RTP packets.


@head2 Implementation |

@head3 VfW capture devices |
The TAPI MSP Video Capture filter talks directly to the VfW capture driver
using SendDriverMessage. This filter uses the existing DShow code
implemented in QCAP but adds the necessary functions to perform smart
teeing of the capture data to the preview pin. It replaces the
streaming-only code used by QCAP with frame grabbing code whenever
necessary. It controls the rate at which frames are being captured by
adjusting the rate at which DVM_FRAME message are being sent to the driver
in frame grabbing mode, or only returning a fraction of the frames being
captured in streaming mode. It performs format and Vfw to ITU-T size
conversions to bring the format of the captured video data to a format that
can easily be used for rendering, and directly encoded by the downstream
TAPI MSP Video Encoder filter if an installable codecs is registered with
the TAPI MSP. If there is no installable codec registered, the TAPI MSP
Video Capture filter also performs H.26x encoding, generating a compressed
video capture output stream in H.26x format, as well as an RTP packetization
descriptor output data stream. Finally, the TAPI MSP Video Capture filter
does all the necessary sequencing to pause the existing video streams
whenever it is being asked to generate still-image data, grab a
high-resolution snapshot, deliver it in progressively rendered form, and
restart the video streams.

@head3 WDM capture devices |
The TAPI MSP Video Capture filter talks directly to the WDM capture driver
using IOCTLs. This filter uses the existing code implemented in KSProxy
but adds the necessary functions to perform smart teeing of the capture
data to the preview pin, if necessary. It controls the rate at which frames
are being captured by adjusting the rate at which buffers are being
submitted to the driver in frame grabbing mode, or only returning a fraction
of the frames being captured in streaming mode using overlapped IOs. It
performs format and Vfw to ITU-T size conversions to bring the format of the
captured video data to a format that can easily be used for rendering, and
directly encoded by the downstream TAPI MSP Video Encoder filter if an
installable codecs is registered with the TAPI MSP. If there is no
installable codec registered, the TAPI MSP Video Capture filter also performs
H.26x encoding, generating a compressed video capture output stream in H.26x
format, as well as an RTP packetization descriptor output data stream.
Finally, the TAPI MSP Video Capture filter does all the necessary sequencing
to pause the existing video streams whenever it is being asked to generate
still-image data, grab a high-resolution snapshot, deliver it in
progressively rendered form, and restart the video streams.

@head2 Video capture filter application interfaces |

@head3 IAMVfwCaptureDialogs application interface|
@subindex IAMVfwCaptureDialogs methods
@subindex IAMVfwCaptureDialogs structures and enums

@head3 IAMCrossbar application interface|
@subindex IAMCrossbar methods
@subindex IAMCrossbar structures and enums

@head3 IAMVideoProcAmp application interface|
@subindex IAMVideoProcAmp methods
@subindex IAMVideoProcAmp structures and enums

@head3 ICameraControl application interface|
@subindex ICameraControl methods
@subindex ICameraControl structures and enums

@head3 IAMVideoControl application interface|
@subindex IAMVideoControl methods
@subindex IAMVideoControl structures and enums

@head3 IVideoDeviceControl application interface|
@subindex IVideoDeviceControl methods
@subindex IVideoDeviceControl structures and enums

@head2 Video capture filter MSP interfaces |

@head3 IH245VideoCapability application interface|
@subindex IH245VideoCapability methods
@subindex IH245VideoCapability structures and enums

@head2 Video capture filter output pin TAPI interfaces |

@head3 ICPUControl interface|
@subindex ICPUControl methods
@subindex ICPUControl structures and enums

@head3 IFrameRateControl interface|
@subindex IFrameRateControl methods
@subindex IFrameRateControl structures and enums

@head3 IBitrateControl interface|
@subindex IBitrateControl methods
@subindex IBitrateControl structures and enums

@head3 INetworkStats interface|
@subindex INetworkStats methods
@subindex INetworkStats structures and enums

@head3 IH245EncoderCommand interface|
@subindex IH245EncoderCommand methods
@subindex IH245EncoderCommand structures and enums

@head3 IProgressiveRefinement interface|
@subindex IProgressiveRefinement methods
@subindex IProgressiveRefinement structures and enums

@head3 IRTPPDControl interface|
@subindex IRTPPDControl methods
@subindex IRTPPDControl structures and enums

@head3 Common control structures and enums |
@subindex Common control structures
@subindex Common control enums

@head2 Classes |
@subindex Classes

@head2 Modules |
@subindex Modules
@subindex Constants

@head2 Code information |

The only libraries necessary in retail mode (w/o property pages) are ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib kernel32.lib ole32.lib uuid.lib msvcrt.lib

@head3 Exports |
DllCanUnloadNow
DllGetClassObject

@head3 Imports |
KERNEL32.DLL:
CloseHandle
CreateEventA
DeviceIoControl
DisableThreadLibraryCalls
FreeLibrary
GetLastError
GetOverlappedResult
GetVersionExA
InterlockedDecrement
InterlockedIncrement
RtlZeroMemory

MSVCRT.DLL:
??2@YAPAXI@Z
??3@YAXPAX@Z
_EH_prolog
__CxxFrameHandler
_purecall
memcmp

@head3 Code size |
Compile options: /nologo /MDd /W3 /GX /O1 /X /I "..\..\inc" /I "..\..\..\ddk\inc" /I "..\..\..\..\dev\tools\amovsdk.20\include" /I "..\..\..\..\dev\tools\amovsdk.20\classes\base" /I "..\..\..\..\dev\ntddk\inc" /I "..\..\..\..\dev\inc" /I "..\..\..\..\dev\tools\c32\inc" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "DLL" /D "STRICT" /FR"Release/" /Fp"Release/TAPIKsIf.pch" /YX /Fo"Release/" /Fd"Release/" /FD /c

Link options: ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib comctl32.lib msvcrt.lib winmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /base:"0x1e180000" /entry:"DllEntryPoint" /dll /incremental:no /pdb:"Release/TAPIKsIf.pdb" /map:"Release/TAPIKsIf.map" /machine:I386 /nodefaultlib /def:".\TAPIKsIf.def" /out:"Release/TAPIKsIf.ax" /i mplib:"Release/TAPIKsIf.lib"

Resulting size: 28KB


***********************************************************************
@contents2 IAMVfwCaptureDialogs methods |
@index mfunc | CVFWDLGSMETHOD

***********************************************************************
@contents2 IAMVfwCaptureDialogs structures and enums |
@index struct,enum | CVFWDLGSSTRUCTENUM

***********************************************************************
@contents2 IAMCrossbar methods |
@index mfunc | CXBARMETHOD

***********************************************************************
@contents2 IAMCrossbar structures and enums |
@index struct,enum | CXBARSTRUCTENUM

***********************************************************************
@contents2 IAMVideoProcAmp methods |
@index mfunc | CPROCAMPMETHOD

***********************************************************************
@contents2 IAMVideoProcAmp structures and enums |
@index struct,enum | CPROCAMPSTRUCTENUM

***********************************************************************
@contents2 ICameraControl methods |
@index mfunc | CCAMERACMETHOD

***********************************************************************
@contents2 ICameraControl structures and enums |
@index struct,enum | CCAMERACSTRUCTENUM

***********************************************************************
@contents2 IAMVideoControl methods |
@index mfunc | CVIDEOCMETHOD

***********************************************************************
@contents2 IAMVideoControl structures and enums |
@index struct,enum | CVIDEOCSTRUCTENUM

***********************************************************************
@contents2 IVideoDeviceControl methods |
@index mfunc | CDEVENUMMETHOD

***********************************************************************
@contents2 IVideoDeviceControl structures and enums |
@index struct,enum | CDEVENUMSTRUCTENUM

***********************************************************************
@contents2 IH245VideoCapability methods |
@index mfunc | CH245VIDCMETHOD

***********************************************************************
@contents2 IH245VideoCapability structures and enums |
@index struct,enum | H245VIDCSTRUCTENUM

***********************************************************************
@contents2 ICPUControl methods |
@index mfunc | CCPUCMETHOD

***********************************************************************
@contents2 ICPUControl structures and enums |
@index struct,enum | CCAPTURECPUCSTRUCTENUM

***********************************************************************
@contents2 IFrameRateControl methods |
@index mfunc | CFPSCMETHOD

***********************************************************************
@contents2 IFrameRateControl structures and enums |
@index struct,enum | CCAPTUREFPSCSTRUCTENUM

***********************************************************************
@contents2 IBitrateControl methods |
@index mfunc | CCAPTUREBITRATECMETHOD

***********************************************************************
@contents2 IBitrateControl structures and enums |
@index struct,enum | CCAPTUREBITRATECSTRUCTENUM

***********************************************************************
@contents2 INetworkStats methods |
@index mfunc | CCAPTURENETSTATMETHOD

***********************************************************************
@contents2 INetworkStats structures and enums |
@index struct,enum | CNETSTATSSTRUCTENUM

***********************************************************************
@contents2 IH245EncoderCommand methods |
@index mfunc | CCAPTUREH245VIDCMETHOD

***********************************************************************
@contents2 IH245EncoderCommand structures and enums |
@index struct,enum | CCAPTUREH245VIDCSTRUCTENUM

***********************************************************************
@contents2 IProgressiveRefinement methods |
@index mfunc | CCAPTUREPROGREFMETHOD

***********************************************************************
@contents2 IProgressiveRefinement structures and enums |
@index struct,enum | CCAPTUREPROGREFSTRUCTENUM

***********************************************************************
@contents2 IRTPPDControl methods |
@index mfunc | CRTPPDMETHOD

***********************************************************************
@contents2 IRTPPDControl structures and enums |
@index struct,enum | CRTPPDSTRUCTENUM

***********************************************************************
@contents2 Common control structures |
@index struct | STRUCT

***********************************************************************
@contents2 Common control enums |
@index enum | ENUM

***********************************************************************
@contents2 Modules |
@index module |

***********************************************************************
@contents2 Classes |
@index class |
@index mdata, mfunc | CCAPTUREPINCLASS,CCAPTUREPINMETHOD,CCAPTUREBITRATECMETHOD
@index mdata, mfunc | CBASEPINCLASS,CBASEPINMETHOD,CCPUCMETHOD,CFPSCMETHOD
@index mdata, mfunc | CTAPIVCAPCLASS,CCAMERACMETHOD,CDEVENUMMETHOD

***********************************************************************
@contents2 Constants |
@index const |
****************************************************************************/

#ifndef _TAPIVCAP_H_
#define _TAPIVCAP_H_

//these must be kept in synch with the ones in Capture.h @ 12
#ifndef MAX_VIDEO_BUFFERS
#define MAX_VIDEO_BUFFERS 6
#endif
#ifndef MIN_VIDEO_BUFFERS
#define MIN_VIDEO_BUFFERS 2
#endif

//#define M_EVENTS

#ifdef DBG
extern DWORD g_dwVideoCaptureTraceID;

#ifndef FX_ENTRY
#define FX_ENTRY(s) static TCHAR _this_fx_ [] = TEXT(s);
#define _fx_ ((LPTSTR) _this_fx_)
#endif
#else
#ifndef FX_ENTRY
#define FX_ENTRY(s)
#endif
#define _fx_
#endif

// Forward declarations
class CCapturePin;      // Filter's video stream output pin
#ifdef USE_OVERLAY
class COverlayPin;      // Filter's overlay preview pin
#endif
class CPreviewPin;      // Filter's non-overlay preview pin
class CRtpPdPin;        // Filter's RTP packetization descriptor pin
class CTAPIVCap;        // Filter class
class CFrameSample;     // Video media sample class
class CRtpPdSample;     // Rtp pd media sample class
class CCapDev;          // Capture device base class
class CVfWCapDev;       // VfW capture device class
class CWDMCapDev;       // WDM capture device class
class CConverter;       // Format converter base class
class CICMConverter;// ICM format converter class

// Globals
EXTERN_C VIDEOCAPTUREDEVICEINFO g_aDeviceInfo[];
EXTERN_C DWORD          g_dwNumDevices;

/*****************************************************************************
 *  @doc INTERNAL CTAPIVCAPCLASSSTRUCTENUM
 *
 *  @enum ThdState | The <t ThdState> enum is used to change and keep track of
 *    that capture worker thread state.
 *
 *  @emem TS_Not | Worker thread hasn't been created yet.
 *
 *  @emem TS_Create | Worker thread has been created.
 *
 *  @emem TS_Init | Worker thread hasn't been initialized.
 *
 *  @emem TS_Pause | Worker thread is in the Pause state.
 *
 *  @emem TS_Run | Worker thread is in the Run state.
 *
 *  @emem TS_Stop | Worker thread is in the Stop state.
 *
 *  @emem TS_Destroy | Worker thread hasn't been destroyed.
 *
 *  @emem TS_Exit | Worker thread hasn't been asked to exit.
 *
 ****************************************************************************/
enum ThdState {TS_Not, TS_Create, TS_Init, TS_Pause, TS_Run, TS_Stop, TS_Destroy, TS_Exit};

// this structure contains all settings of the capture
// filter that are user settable
//
typedef struct _vfwcaptureoptions {

   UINT  uVideoID;      // id of video driver to open
   DWORD dwTimeLimit;   // stop capturing at this time???

   DWORD dwTickScale;   // frame rate rational
   DWORD dwTickRate;    // frame rate = dwRate/dwScale in ticks/sec
   DWORD usPerFrame;    // frame rate expressed in microseconds per frame
   DWORD dwLatency;     // time added for latency, in 100ns units

   UINT  nMinBuffers;   // number of buffers to use for capture
   UINT  nMaxBuffers;   // number of buffers to use for capture

   UINT  cbFormat;      // sizeof VIDEOINFO stuff
   VIDEOINFOHEADER * pvi;     // pointer to VIDEOINFOHEADER (media type)

} VFWCAPTUREOPTIONS;

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPCLASS
 *
 *  @class CTAPIVCap | This class implements the TAPI Capture Source
 *    filter.
 *
 *  @mdata CCritSec | CTAPIVCap | m_lock | Critical section used for
 *    locking by the <c CBaseFilter> base class.
 *
 *  @mdata CCapturePin | CTAPIVCap | m_pCapturePin | Pointer to the capture pin
 *    object
 *
 *  @mdata COverlayPin | CTAPIVCap | m_pOverlayPin | Pointer to the overlay
 *    pin object
 *
 *  @mdata CPreviewPin | CTAPIVCap | m_pPreviewPin | Pointer to the preview
 *    pin object
 *
 *  @mdata CPreviewPin | CTAPIVCap | m_pRtpPdPin | Pointer to the Rtp Pd
 *    pin object
 *
 *  @mdata BOOL | CTAPIVCap | m_fDialogUp | Set to TRUE if a VfW driver
 *    dialog box is up
 *
 *  @todo Describe and clean up other members
 ***************************************************************************/
class CTAPIVCap : public CBaseFilter, public IAMVideoControl
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
,public IVideoDeviceControl
,public IRTPPayloadHeaderMode
{
        public:
        DECLARE_IUNKNOWN

        CTAPIVCap(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr);
        ~CTAPIVCap();
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);

#ifdef USE_PROPERTY_PAGES
        // ISpecifyPropertyPages methods
        STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

        // Implement IAMVideoControl
        STDMETHODIMP GetCaps(IN IPin *pPin, OUT long *pCapsFlags);
        STDMETHODIMP GetCurrentActualFrameRate(IN IPin *pPin, OUT LONGLONG *ActualFrameRate);
        STDMETHODIMP GetFrameRateList(IN IPin *pPin, IN long iIndex, IN SIZE Dimensions, OUT long *ListSize, OUT LONGLONG **FrameRates);
        STDMETHODIMP GetMaxAvailableFrameRate(IN IPin *pPin, IN long iIndex,IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate);
        STDMETHODIMP GetMode(IN IPin *pPin, OUT long *Mode);
        STDMETHODIMP SetMode(IN IPin *pPin, IN long Mode);

        // Implement IVideoDeviceControl
        STDMETHODIMP GetNumDevices(OUT PDWORD pdwNumDevices);
        STDMETHODIMP GetDeviceInfo(IN DWORD dwDeviceIndex, OUT VIDEOCAPTUREDEVICEINFO *pDeviceInfo);
        STDMETHODIMP GetCurrentDevice(OUT DWORD *pdwDeviceIndex);
        STDMETHODIMP SetCurrentDevice(IN DWORD dwDeviceIndex);

        // Implement CBaseFilter pure virtual member functions
        int GetPinCount();
        CBasePin *GetPin(IN int n);

        // Implement IMediaFilter
        STDMETHODIMP Run(IN REFERENCE_TIME tStart);
        STDMETHODIMP Pause();
        STDMETHODIMP Stop();
        STDMETHODIMP GetState(IN DWORD dwMilliSecsTimeout, OUT FILTER_STATE *State);
        STDMETHODIMP SetSyncSource(IN IReferenceClock *pClock);
        STDMETHODIMP JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName);

        // Implement IRTPPayloadHeaderMode
        STDMETHODIMP SetMode(IN RTPPayloadHeaderMode rtpphmMode);

        private:

        friend class CTAPIBasePin;
        friend class CCapturePin;
        friend class CPreviewPin;
#ifdef USE_OVERLAY
        friend class COverlayPin;
#endif
        friend class CRtpPdPin;
        friend class CCapDev;
        friend class CVfWCapDev;
        friend class CWDMCapDev;
        friend class CDShowCapDev;
        friend class CWDMDialog;
        friend class CConverter;
        friend class CICMConverter;
        friend class CH26XEncoder;

        HRESULT CreatePins();
        HRESULT GetWDMDevices();
        CCritSec        m_lock;
        CCapturePin     *m_pCapturePin;
#ifdef USE_OVERLAY
        COverlayPin     *m_pOverlayPin;
#endif
        CPreviewPin     *m_pPreviewPin;
        CRtpPdPin       *m_pRtpPdPin;
        CCapDev         *m_pCapDev;
        DWORD           m_dwDeviceIndex;
        BOOL            m_fAvoidOverlay;
        BOOL            m_fPreviewCompressedData;

    // Capture worker thread management
    HANDLE              m_hThread;
    DWORD               m_tid;
    ThdState    m_state;     // used to communicate state changes between worker thread and main
                          // Worker thread can make
                          //    Init->Pause, Stop->Destroy, Destroy->Exit transitions
                          // main thread(s) can make
                          //    Pause->Run, Pause->Stop, Run->Pause, Run->Stop transitions
                          // other transitions are invalid
        HANDLE          m_hEvtPause; // Signalled when the worker is in the pause state
    HANDLE              m_hEvtRun;   // Signalled when the worker is in the run state
        CAMEvent        m_EventAdvise;
    static DWORD WINAPI ThreadProcInit(void *pv);
    DWORD               ThreadProc();
        ThdState        ChangeThdState(ThdState state);
    BOOL                CreateThd();
    BOOL                PauseThd();
    BOOL                RunThd();
    BOOL                StopThd();
    BOOL                DestroyThd();
    BOOL                ThdExists() {return (m_hThread != NULL);};
    HRESULT             Prepare();
    HRESULT             Capture();
    HRESULT             Unprepare();

        // Video capture buffer queue management
    UINT        *m_pBufferQueue; // what order we sent the buffers to the driver in
    UINT        m_uiQueueHead;   // next buffer going to driver goes here
    UINT        m_uiQueueTail;   // next buffer coming from driver is here
        HRESULT ReleaseFrame(LPTHKVIDEOHDR ptvh);

    // return the time of a given tick
    //
    REFERENCE_TIME TickToRefTime (DWORD nTick) {
       const DWORD dw100ns = 10 * 1000 * 1000;
       REFERENCE_TIME time =
          UInt32x32To64(dw100ns, m_user.dwTickScale)
          * nTick
          / m_user.dwTickRate;
       return time;
       };

        struct _cap_parms
        {
#if 0
                // video driver stuff
                //
                HVIDEO         hVideoIn;     // video input
                HVIDEO         hVideoExtIn;  // external in (source control)
                HVIDEO         hVideoExtOut; // external out (overlay; not required)
                MMRESULT       mmr;          // open fail/success code
                BOOL           bHasOverlay;  // TRUE if ExtOut has overlay support
#endif
                // the preview buffer.  once created it persists until
                // the stream destructor because the renderer assumes
                // that it can keep a pointer to this and not crash
                // if it uses it after stopping the stream.
                // (no longer a problem)
                // !!! can we remove all this Preview still frame stuff?
                //
                UINT           cbVidHdr;       // size of a videohdr (or videohdrex)
#if 0
                THKVIDEOHDR    tvhPreview;     // preview video header
                CFrameSample * pSamplePreview; // CMediaSample for preview buffer
#endif
                CFrameSample **paPreviewSamples;
                CFrameSample **paCaptureSamples;
                CRtpPdSample **paRtpPdSamples;
                UINT           cCaptureSamples;// number of capture samples
                UINT           cPreviewSamples;// number of preview samples
                UINT           cRtpPdSamples;// number of rtp pd samples

                // video header & buffer stuff
                //
                UINT           cbBuffer;           // max size of video frame data
                UINT           nHeaders;           // number of video headers
                struct _cap_hdr {
                THKVIDEOHDR  tvh;
                long  lLock;
                //long  nUsedDownstream;
                } * paHdr;
                BOOL           fCaptureNeedConverter; // TRUE if capture pin generates compressed data
                BOOL           fPreviewNeedConverter; // TRUE if preview pin generates compressed data

#ifdef M_EVENTS
                HANDLE         h_aEvtBufferDone[MAX_VIDEO_BUFFERS];     //**cristiai: each event for a buffer
                HANDLE         h_aEvtCapWait[MAX_VIDEO_BUFFERS+1];      //**cristiai: WaitMultiple on this array
#endif
                HANDLE         hEvtBufferDone;     // this event signalled when a buffer is ready
                DWORD_PTR      h0EvtBufferDone;    // on Win95 this is a Ring0 alias of the above event

                LONGLONG       tTick;              // duration of a single tick
                LONGLONG       llLastTick;        // the last frame sent downstream
                DWORDLONG      dwlLastTimeCaptured;// the last driver time stamp
                DWORDLONG      dwlTimeCapturedOffset;// wraparound compensation
                UINT           uiLastAdded;       // the last buffer AddBuffer'd
                DWORD         dwFirstFrameOffset; // when 1st frame was captured
                LONGLONG       llFrameCountOffset; // add this to frame number
                BOOL          fReRun;             // went from Run->Pause->Run
                BOOL          fLastRtpPdSampleDiscarded; // due to IAMStreamControl
                CRefTime       rtThisFrameTime;  // clock time when frame was captured
                CRefTime              rtDriverStarted;  // when videoStreamStart was called
                CRefTime              rtDriverLatency;  // how long it takes captured frame to
                // get noticed by ring 3
        } m_cs;

        VFWCAPTUREOPTIONS m_user;

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        RTPPayloadHeaderMode m_RTPPayloadHeaderMode;
};

#endif // _TAPIVCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\thunk.h ===
/****************************************************************************
 *
 *   thunk.h
 * 
 *   macros, defines, prototypes for avicap 16:32 thunks
 *
 *   Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef _THUNK_H_
#define _THUNK_H_

typedef LPVOID P16VOID;
typedef DWORD  P32VOID;
//#define P16VOID LPVOID
//#define P32VOID DWORD

//#include "common.h"

// thunk helpers exported from the kernel
//
DWORD WINAPI GetCurrentProcessID(void);  // KERNEL
DWORD WINAPI SetWin32Event(DWORD hEvent); // KERNEL

P16VOID  WINAPI MapLS(P32VOID);
P16VOID  WINAPI UnMapLS(P16VOID);
P32VOID  WINAPI MapSL(P16VOID);

// thunk helpers in thunka.asm
//
DWORD FAR PASCAL capTileBuffer (
    DWORD dwLinear,
    DWORD dwSize);

#define PTR_FROM_TILE(dwTile) (LPVOID)(dwTile & 0xFFFF0000)

void  FAR PASCAL capUnTileBuffer (
    DWORD dwTileInfo);

BOOL  FAR PASCAL capPageFree (
    DWORD dwMemHandle);

typedef struct _cpa_data {
    DWORD dwMemHandle;
    DWORD dwPhysAddr;
    } CPA_DATA, FAR * LPCPA_DATA;

DWORD FAR PASCAL capPageAllocate (  // returns ptr to allocated memory
    DWORD   dwFlags,
    DWORD   dwPageCount,
    DWORD   dwMaxPhysPageMask,
    LPCPA_DATA pcpad);   // returned mem handle & phys address

// flags for capPageAllocate, same as flags from vmm.inc
//
#define PageUseAlign    0x00000002
#define PageContig      0x00000004
#define PageFixed       0x00000008

#ifdef WIN32
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */
void NTAPI ThunkTerm(void);
BOOL NTAPI ThunkInit(void);
#ifdef __cplusplus
}
#endif	/* __cplusplus */
#endif

#endif // _THUNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\vfwdlgs.cpp ===
/****************************************************************************
 *  @doc INTERNAL VFWDLGS
 *
 *  @module VfWDlgs.cpp | Source file for the <c CVfWCapDev> 
 *    class methods used to implement the <i IAMVfwCaptureDialogs> interface.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CVFWDLGSMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | HasDialog | This method is used to
 *    determine if the specified dialog box exists in the driver.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag S_OK | If the driver contains the dialog box 
 *  @flag S_FALSE | If the driver doesn't contain the dialog box 
 ***************************************************************************/
HRESULT CVfWCapDev::HasDialog(IN int iDialog)
{
	HRESULT	Hr = NOERROR;
	HVIDEO	hVideo;

	FX_ENTRY("CVfWCapDev::HasDialog")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));
	if (iDialog == VfwCaptureDialog_Source)
		hVideo = m_hVideoExtIn;
	else if (iDialog == VfwCaptureDialog_Format)
		hVideo = m_hVideoIn;
	else if (iDialog == VfwCaptureDialog_Display)
		hVideo = m_hVideoExtOut;
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	if (videoDialog(hVideo, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
	{
		Hr = S_OK;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Yes, %s dialog is supported", _fx_, iDialog == VfwCaptureDialog_Source ? "Source" : iDialog == VfwCaptureDialog_Format ? "Format" : "Display"));
	}
	else
	{
		Hr = S_FALSE;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Nope, %s dialog is not supported", _fx_, iDialog == VfwCaptureDialog_Source ? "Source" : iDialog == VfwCaptureDialog_Format ? "Format" : "Display"));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWDLGSMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | ShowDialog | This method is used to
 *    displaay the specified dialog box.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @parm HWND | hwnd | Specifies the handle of the dialog box's parent
 *    window.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag VFW_E_NOT_STOPPED | The operation could not be performed because the filter is not stopped 
 *  @flag VFW_E_CANNOT_CONNECT | No combination of intermediate filters could be found to make the connection 
 ***************************************************************************/
HRESULT CVfWCapDev::ShowDialog(IN int iDialog, IN HWND hwnd)
{
	HRESULT	Hr = NOERROR;
	HVIDEO	hVideo;
	DWORD	dw;

	FX_ENTRY("CVfWCapDev::ShowDialog")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Before we bring the format dialog up, make sure we're not streaming, or about to
	// Also make sure another dialog isn't already up (I'm paranoid)
	if ((iDialog == VfwCaptureDialog_Format && m_pCaptureFilter->m_State != State_Stopped) || m_fDialogUp)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't put format dialog up while streaming!", _fx_));
		Hr = VFW_E_NOT_STOPPED;
		goto MyExit;
	}

	m_fDialogUp = TRUE;

	ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));

	if (iDialog == VfwCaptureDialog_Source)
		hVideo = m_hVideoExtIn;
	else if (iDialog == VfwCaptureDialog_Format)
		hVideo = m_hVideoIn;
	else if (iDialog == VfwCaptureDialog_Display)
		hVideo = m_hVideoExtOut;
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		m_fDialogUp = FALSE;
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	if (hwnd == NULL)
		hwnd = GetDesktopWindow();

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Putting up %s dialog...", _fx_, iDialog == VfwCaptureDialog_Source ? "Source" : iDialog == VfwCaptureDialog_Format ? "Format" : "Display"));

	// This changed our output format!
	if ((dw = videoDialog(hVideo, hwnd, 0)) == 0)
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ...videoDialog succeeded", _fx_));

		if (iDialog == VfwCaptureDialog_Format)
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Output format may have changed", _fx_));

			// The dialog changed the driver's internal format.  Get it again.
			if (m_pCaptureFilter->m_user.pvi)
				delete m_pCaptureFilter->m_user.pvi;
			GetFormatFromDriver(&m_pCaptureFilter->m_user.pvi);

			// Reconnect the capture pin
			if ((Hr = m_pCaptureFilter->m_pCapturePin->Reconnect()) != S_OK)
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't reconnect capture pin", _fx_));
				Hr = VFW_E_CANNOT_CONNECT;
				goto MyExit;
			}

			// Reconnect the preview pin
			if ((Hr = m_pCaptureFilter->m_pPreviewPin->Reconnect()) != S_OK)
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't reconnect preview pin", _fx_));
				Hr = VFW_E_CANNOT_CONNECT;
				goto MyExit;
			}

/* The RTP pin doesn't need to be reconnected because it will not be affected by capture format change.
			// Reconnect the Rtp Pd pin
			if ((Hr = m_pCaptureFilter->m_pRtpPdPin->Reconnect()) != S_OK)
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't reconnect Rtp Pd pin", _fx_));
				Hr = VFW_E_CANNOT_CONNECT;
				goto MyExit;
			}
*/
		}
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ...videoDialog failed!", _fx_));
		Hr = E_FAIL;
	}

	m_fDialogUp = FALSE;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWDLGSMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | SendDriverMessage | This method is used to
 *    send a driver-specific message.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @parm int | uMsg | Specifies the message to send to the driver.
 *
 *  @parm long | dw1 | Specifies message data.
 *
 *  @parm long | dw2 | Specifies message data.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 ***************************************************************************/
HRESULT CVfWCapDev::SendDriverMessage(IN int iDialog, IN int uMsg, IN long dw1, IN long dw2)
{
	HRESULT	Hr = NOERROR;
	HVIDEO	hVideo;

	FX_ENTRY("CVfWCapDev::SendDriverMessage")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// This could do anything!  Bring up a dialog, who knows.
	// Don't take any crit sect or do any kind of protection.
	// They're on their own

	// Validate input parameters
	ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));

	if (iDialog == VfwCaptureDialog_Source)
		hVideo = m_hVideoExtIn;
	else if (iDialog == VfwCaptureDialog_Format)
		hVideo = m_hVideoIn;
	else if (iDialog == VfwCaptureDialog_Display)
		hVideo = m_hVideoExtOut;
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	Hr = videoMessage(hVideo, uMsg, dw1, dw2);

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\vidctrl.cpp ===
/****************************************************************************
 *  @doc INTERNAL VIDCTRL
 *
 *  @module VidCtrl.cpp | Source file for the <c CTAPIVCap>
 *    class methods used to implement the <i IAMVideoControl> interface.
 ***************************************************************************/

#include "Precomp.h"

/*****************************************************************************
 *  @doc INTERNAL CVIDEOCSTRUCTENUM
 *
 *  @enum VideoControlFlags | The <t VideoControlFlags> enum is used to describe
 *    video modes.
 *
 *  @emem VideoControlFlag_FlipHorizontal | Specifies that the camera control
 *    setting can be modified manually.
 *
 *  @emem VideoControlFlag_FlipVertical | Specifies that the camera control
 *    setting can be modified automatically.
 *
 *  @emem VideoControlFlag_ExternalTriggerEnable | Specifies that the camera
 *    control setting can be modified automatically.
 *
 *  @emem VideoControlFlag_Trigger | Specifies that the camera control setting
 *    can be modified automatically.
 ****************************************************************************/

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetCaps | This method is used to retrieve
 *    the capabilities of the TAPI MSP Video Capture filter regarding
 *    flipping pictures and external triggers.
 *
 *  @parm IPin* | pPin | Used to specify the video output pin to query
 *    capabilities from.
 *
 *  @parm long* | pCapsFlags | Used to retrieve a value representing a
 *    combination of the flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetCaps(IN IPin *pPin, OUT long *pCapsFlags)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetCaps")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(pCapsFlags);
	if (!pPin || !pCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetCaps(pCapsFlags);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | SetMode | This method is used to set the
 *    video control mode of operation.
 *
 *  @parm IPin* | pPin | Used to specify the pin to set the video control
 *    mode on.
 *
 *  @parm long | Mode | Used to specify a combination of the flags from the
 *    <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::SetMode(IN IPin *pPin, IN long Mode)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::SetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	if (!pPin)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->SetMode(Mode);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetMode | This method is used to retrieve
 *    the video control mode of operation.
 *
 *  @parm IPin* | pPin | Used to specify the pin to get the video control
 *    mode from.
 *
 *  @parm long | Mode | Pointer to a value representing a combination of the
 *    flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetMode(IN IPin *pPin, OUT long *Mode)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(Mode);
	if (!pPin || !Mode)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetMode(Mode);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetCurrentActualFrameRate | This method is
 *    used to retrieve the actual frame rate, expressed as a frame duration
 *    in 100 ns units.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rate
 *    from.
 *
 *  @parm LONGLONG* | ActualFrameRate | Pointer to the frame rate in frame
 *    duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetCurrentActualFrameRate(IN IPin *pPin, OUT LONGLONG *ActualFrameRate)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetCurrentActualFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(ActualFrameRate);
	if (!pPin || !ActualFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetCurrentActualFrameRate(ActualFrameRate);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetMaxAvailableFrameRate | This method is
 *    used to retrieve the maximum frame rate currently available, based on
 *    bus bandwidth usage for connections, such as USB (Universal Serial Bus)
 *    and IEEE 1394, where the maximum frame rate may be limited due to
 *    bandwidth availability.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rate
 *    from.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm LONGLONG* | MaxAvailableFrameRate | Pointer to the maximum
 *    available frame rate in frame duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetMaxAvailableFrameRate(IN IPin *pPin, IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetMaxAvailableFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(MaxAvailableFrameRate);
	if (!pPin || !MaxAvailableFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetMaxAvailableFrameRate(iIndex, Dimensions, MaxAvailableFrameRate);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetFrameRateList | This method is
 *    used to retrieve the list of available frame rates.
 *
 *  @parm IPin* | pPin | Used to specify the pin to retrieve the frame rates
 *    from.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm long* | ListSize | Pointer to the number of elements in the list
 *    of frame rates.
 *
 *  @parm LONGLONG** | MaxAvailableFrameRate | Pointer to an array of frame
 *    rates in 100 ns units. Can be NULL if only <p ListSize> is wanted.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVCap::GetFrameRateList(IN IPin *pPin, IN long iIndex, IN SIZE Dimensions, OUT long *ListSize, OUT LONGLONG **FrameRates)
{
	HRESULT Hr = NOERROR;
	IVideoControl *pIVideoControl;

	FX_ENTRY("CTAPIVCap::GetFrameRateList")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPin);
	ASSERT(ListSize);
	ASSERT(FrameRates);
	if (!pPin || !ListSize || !FrameRates)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Delegate call to the pin
	if (SUCCEEDED(Hr = pPin->QueryInterface(__uuidof(IVideoControl), (void **)&pIVideoControl)))
	{
		Hr = pIVideoControl->GetFrameRateList(iIndex, Dimensions, ListSize, FrameRates);
		pIVideoControl->Release();
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCaps | This method is used to retrieve
 *    the capabilities of the TAPI MSP Video Capture filter capture pin regarding
 *    flipping pictures and external triggers.
 *
 *  @parm long* | pCapsFlags | Used to retrieve a value representing a
 *    combination of the flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCaps(OUT long *pCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetCaps")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pCapsFlags);
	if (!pCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return capabilities
	*pCapsFlags = VideoControlFlag_FlipHorizontal | VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetMode | This method is used to set the
 *    video control mode of operation.
 *
 *  @parm long | Mode | Used to specify a combination of the flags from the
 *    <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetMode(IN long Mode)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::SetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Mode & VideoControlFlag_ExternalTriggerEnable) == 0);
	ASSERT((Mode & VideoControlFlag_Trigger) == 0);
	if ((Mode & VideoControlFlag_ExternalTriggerEnable) || (Mode & VideoControlFlag_Trigger))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Set flip modes
	m_fFlipHorizontal = Mode & VideoControlFlag_FlipHorizontal;
	m_fFlipVertical = Mode & VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMode | This method is used to retrieve
 *    the video control mode of operation.
 *
 *  @parm long | Mode | Pointer to a value representing a combination of the
 *    flags from the <t VideoControlFlags> enumeration.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMode(OUT long *Mode)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMode")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(Mode);
	if (!Mode)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current modes
	*Mode = 0;
	if (m_fFlipHorizontal)
		*Mode |= VideoControlFlag_FlipHorizontal;
	if (m_fFlipVertical)
		*Mode |= VideoControlFlag_FlipVertical;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCurrentActualFrameRate | This method is
 *    used to retrieve the actual frame rate, expressed as a frame duration
 *    in 100 ns units.
 *
 *  @parm LONGLONG* | ActualFrameRate | Pointer to the frame rate in frame
 *    duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCurrentActualFrameRate(OUT LONGLONG *ActualFrameRate)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetCurrentActualFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ActualFrameRate);
	if (!ActualFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current actual frame rate
	*ActualFrameRate = m_lCurrentAvgTimePerFrame;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxAvailableFrameRate | This method is
 *    used to retrieve the maximum frame rate currently available, based on
 *    bus bandwidth usage for connections, such as USB (Universal Serial Bus)
 *    and IEEE 1394, where the maximum frame rate may be limited due to
 *    bandwidth availability.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm LONGLONG* | MaxAvailableFrameRate | Pointer to the maximum
 *    available frame rate in frame duration in 100 nS units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxAvailableFrameRate(IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxAvailableFrameRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(MaxAvailableFrameRate);
	if (!MaxAvailableFrameRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return max available frame rate
	*MaxAvailableFrameRate = m_lAvgTimePerFrameRangeMax;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVIDEOCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetFrameRateList | This method is
 *    used to retrieve the list of available frame rates.
 *
 *  @parm long | iIndex | Used to specify the index of the format to query
 *    for frame rates. This index corresponds to the order in which formats
 *    are enumerated by IAMStreamConfig::GetStreamCaps. The value must range
 *    between 0 and the number of supported <t VIDEO_STREAM_CONFIG_CAPS>
 *    structures returned by IAMStreamConfig::GetNumberOfCapabilities.
 *
 *  @parm SIZE | Dimensions | Used to specify the frame's image size (width
 *    and height) in pixels.
 *
 *  @parm long* | ListSize | Pointer to the number of elements in the list
 *    of frame rates.
 *
 *  @parm LONGLONG** | MaxAvailableFrameRate | Pointer to an array of frame
 *    rates in 100 ns units. Can be NULL if only <p ListSize> is wanted.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetFrameRateList(IN long iIndex, IN SIZE Dimensions, OUT long *ListSize, OUT LONGLONG **FrameRates)
{
	HRESULT Hr = NOERROR;
	PLONGLONG pFrameRate;

	FX_ENTRY("CTAPIBasePin::GetFrameRateList")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ListSize);
	if (!ListSize)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the number of frame rates
	if (m_lAvgTimePerFrameRangeMax > m_lAvgTimePerFrameRangeMin && m_lAvgTimePerFrameRangeSteppingDelta)
	{
		*ListSize = (LONG)((m_lAvgTimePerFrameRangeMax - m_lAvgTimePerFrameRangeMin) / m_lAvgTimePerFrameRangeSteppingDelta);
	}
	else
	{
		*ListSize = 1;
	}

	// Get the actual frame rates
	if (FrameRates)
	{
		if (*FrameRates = (PLONGLONG)CoTaskMemAlloc(sizeof(LONGLONG) * *ListSize))
		{
			pFrameRate = *FrameRates;
			for (LONG j=0 ; j < *ListSize; j++)
			{
				// Spew the list of sizes
				*pFrameRate++ = (LONGLONG)(m_lAvgTimePerFrameRangeMin + m_lAvgTimePerFrameRangeSteppingDelta * j);
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\video.c ===
/****************************************************************************
 *  @doc INTERNAL THUNK
 *
 *  @module Thunk.c | Source file for the VfW video API.
 ***************************************************************************/

#ifndef DRIVERS_SECTION
#define DRIVERS_SECTION  TEXT("DRIVERS32")
#endif

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#ifdef WIN32
//#include <mmddk.h>
#include <stdlib.h>
#endif

#include <vfw.h>
//#include "win32.h"
#if defined (NT_BUILD)
#include "vc50\msviddrv.h"
#else
#include "msviddrv.h"
#endif
//#include "msvideo.h"
#include "ivideo32.h"
// #include "msvideoi.h"

#define DBGUTIL_ENABLE
#ifdef DBGUTIL_ENABLE
  #include <stdio.h>
  #include <stdarg.h>

  static int dprintf( char * format, ... )
  {
      char out[1024];
      int r;
      va_list marker;
      va_start(marker, format);
      r=_vsnprintf(out, 1022, format, marker);
      va_end(marker);
      OutputDebugString( out );
      return r;
  }


#else
  #define dprintf ; / ## /
#endif


#ifdef DBGUTIL_ENABLE // DEBUG

#ifndef FX_ENTRY
#define FX_ENTRY(s) static char _this_fx_ [] = TEXT(s);
#define _fx_ ((LPTSTR) _this_fx_)
#endif
#else
#ifndef FX_ENTRY
#define FX_ENTRY(s)
#endif
#define _fx_
#endif




#ifndef DVM_STREAM_FREEBUFFER
  #define DVM_STREAM_ALLOCBUFFER    (DVM_START + 312)
  #define DVM_STREAM_FREEBUFFER    (DVM_START + 313)
#endif

#define SZCODE const TCHAR
#define STATICDT static
#define STATICFN static

/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)              (TRUE)
#define HugePageUnlock(x, y)

#define MapSL(x)        x

#define GetCurrentTask() GetCurrentThread()
#define MAXVIDEODRIVERS 10

#define DebugErr(this, that)

#pragma warning(disable:4002)
#define AuxDebugEx()
#define assert()

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");

#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

SZCODE szDriversDescRegKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");

UINT    wTotalVideoDevs;                  // total video devices
extern HINSTANCE ghInstDll;               // our module handle

#include "CritSec.h"


// -----------------------------------------------------------
// If the following structure changes, update AVICAP and AVICAP.32 also!!!

typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
   DWORD dwMsVideoIndex;    // msvideo# slot number in system.ini
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

#ifndef DEVNODE
typedef DWORD      DEVNODE;     // Devnode.
#endif

#ifndef LPHKEY
typedef HKEY FAR * LPHKEY;
#endif

// Registry settings of interest to capture drivers
SZCODE  szRegKey[]          = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo");
SZCODE  szRegActive[]       = TEXT("Active");
SZCODE  szRegDisabled[]     = TEXT("Disabled");
SZCODE  szRegDescription[]  = TEXT("Description");
SZCODE  szRegDevNode[]      = TEXT("DevNode");
SZCODE  szRegDriver[]       = TEXT("Driver");
SZCODE  szRegSoftwareKey[]  = TEXT("SOFTWAREKEY");

LPCAPDRIVERINFO aCapDriverList[MAXVIDEODRIVERS]; // Array of all capture drivers


#ifdef DBGUTIL_ENABLE //DEBUG
  void dbg_Dump_aCapDriverList(char *msg)
  {
    int i;
    dprintf("%s: DeviceList contains %d Video Device(s).\n", msg, wTotalVideoDevs);

    for (i = 0; i < (int) wTotalVideoDevs; i++) {
        dprintf("%s: aCapDriverList[%d]:  DriverName %s, Desc %s\n", msg, i, aCapDriverList[i]->szDriverName, aCapDriverList[i]->szDriverDescription);
    }
  }

#else
  #define dbg_Dump_aCapDriverList(a)
#endif

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegOpenMSVideoKey | This function returns a key
 *      for the msvideo node in the registry.
 *      If the key does not exist it will be created,
 *      and the default entries made.
 *
 * @rdesc Returns Key on success, else NULL.
 ****************************************************************************/
HKEY videoRegOpenMSVideoKey (void)
{
    HKEY hKey = NULL;

    // Get the key if it already exists
    if (RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szRegKey,
                &hKey) != ERROR_SUCCESS) {

        // Otherwise make a new key
        if (RegCreateKey (
                        HKEY_LOCAL_MACHINE,
                        szRegKey,
                        &hKey) == ERROR_SUCCESS) {
            // Add the default entries to the msvideo node?

        }
    }
    return hKey;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegGetDriverByIndex | This function returns information
 *      about a capture driver by index from the registry.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm LPDEVNODE | lpDevnode | Specifies a far pointer to a buffer
 *   used to return an <t DEVNODE> handle.  For non Plug-and-Play devices,
 *   this return value will be NULL.
 *
 * @parm LPBOOL | lpEnabled | Specifies a far pointer to a buffer
 *   used to return a <t BOOL> flag.  If this value is TRUE, the driver is
 *   enabled, if FALSE, the corresponding device is disabled.
 *
 * @rdesc Returns TRUE if successful, or FALSE if a driver was not found
 *  with the <p dwDeviceID> index.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 ****************************************************************************/


BOOL videoRegGetKeyByIndex (
        HKEY            hKeyMSVideoRoot,
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo,
        LPHKEY          phKeyChild)
{
    BOOL fOK = FALSE;
    HKEY hKeyEnum;
    int i;

    *phKeyChild = (HKEY) 0;

    for (i=0; i < MAXVIDEODRIVERS; i++) {       //

        if (RegEnumKey (
                hKeyMSVideoRoot,
                i,
                lpCapDriverInfo-> szKeyEnumName,
                sizeof(lpCapDriverInfo->szKeyEnumName)/sizeof(TCHAR)) != ERROR_SUCCESS)
            break;

        // Found a subkey, does it match the requested index?
        if (i == (int) dwDeviceID) {

            if (RegOpenKey (
                        hKeyMSVideoRoot,
                        lpCapDriverInfo-> szKeyEnumName,
                        &hKeyEnum) == ERROR_SUCCESS) {

                *phKeyChild = hKeyEnum;  // Found it!!!
                fOK = TRUE;

            }
            break;
        }
    } // endof all driver indices
    return fOK;
}

// Fetches driver info listed in the registry.
// Returns: TRUE if the index was valid, FALSE if no driver at that index
// Note: Registry entry ordering is random.

BOOL videoRegGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    DWORD dwType;
    DWORD dwSize;
    BOOL fOK;
    HKEY hKeyChild;
    HKEY hKeyMSVideoRoot;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    if (!(hKeyMSVideoRoot = videoRegOpenMSVideoKey()))
        return FALSE;

    if (fOK = videoRegGetKeyByIndex (
                hKeyMSVideoRoot,
                dwDeviceID,
                lpCapDriverInfo,
                &hKeyChild)) {

        // Fetch the values:
        //      Active
        //      Disabled
        //      Description
        //      DEVNODE
        //      Driver
        //      SOFTWAREKEY

        dwSize = sizeof(BOOL);          // Active
        RegQueryValueEx(
                   hKeyChild,
                   szRegActive,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fActive,
                   &dwSize);

        dwSize = sizeof(BOOL);          // Enabled
        RegQueryValueEx(
                   hKeyChild,
                   szRegDisabled,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fDisabled,
                   &dwSize);
        // Convert this thing to a bool
        lpCapDriverInfo->fDisabled = (lpCapDriverInfo->fDisabled == '1');

        // DriverDescription
        dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDescription,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

        // DEVNODE
        dwSize = sizeof(DEVNODE);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDevNode,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->dnDevNode,
                   &dwSize);

        // DriverName
        dwSize = sizeof (lpCapDriverInfo->szDriverName) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDriver,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverName,
                   &dwSize);

        // SoftwareKey
        dwSize = sizeof (lpCapDriverInfo->szSoftwareKey) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegSoftwareKey,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szSoftwareKey,
                   &dwSize);

        RegCloseKey (hKeyChild);

    } // if the subkey could be opened

    RegCloseKey (hKeyMSVideoRoot);

    return fOK;
}

// Fetches driver info listed in system.ini
// Returns: TRUE if the index was valid, FALSE if no driver at that index

BOOL videoIniGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    int w = (int) dwDeviceID;
    BOOL fOK = FALSE;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    lstrcpy(szKey, szVideo);    //
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }

    // Only get its driver name
    if (GetPrivateProfileString(szDrivers, szKey, szNull,       //
                lpCapDriverInfo->szDriverName,
                sizeof(lpCapDriverInfo->szDriverName)/sizeof(TCHAR),
                szSystemIni)) {

        HKEY hKey = NULL;
        DWORD dwSize, dwType;

        // Get the key if it already exists

        // Get Drivers.Desc from its Drivers32 driver name
        if (ERROR_SUCCESS == RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szDriversDescRegKey,
                &hKey) != ERROR_SUCCESS) {
            // DriverDescription
            dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
            // [drivers.desc]
            //   DriverName = DriverDescription
            dwType = REG_SZ;
            RegQueryValueEx(
                   hKey,
                   lpCapDriverInfo->szDriverName,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

            RegCloseKey (hKey);
        }  else {
            dprintf("videoIniGetDriverByIndex: RegOpenKey of Drivers.Desc failed !!\n");
        }





        // Found an entry at the requested index
        // The description and version info will be inserted as
        // requested by the client app.

        lpCapDriverInfo-> fOnlySystemIni = TRUE;
        lpCapDriverInfo-> dwMsVideoIndex = w;

        fOK = TRUE;
    }

    return fOK;
}

DWORD WINAPI videoFreeDriverList (void)

{
    int i;

    EnterCriticalSection (&g_CritSec);

    dprintf("+ videoFreeDriverList\n");

    // Free the driver list
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    wTotalVideoDevs = 0;

    dprintf("- videoFreeDriverList\n");

    LeaveCriticalSection (&g_CritSec);

    return DV_ERR_OK;
}

// This function may be called a number of times to create the
// current driver array.  Since Capscrn assumes it can throw a
// driver into system.ini on the fly and have it immediately accessible,
// this routine is called on videoGetNumDevs() and when AVICapx.dll
// tries to get the driver description and version.
//
// Drivers in the registry will be the first entries in the list.
//
// If a driver is listed in the registry AND in system.ini AND
// the full path to the drivers match, the system.ini entry will NOT
// be in the resulting list.

// The variable wTotalVideoDevs is set as a byproduct of this function.

// Returns DV_ERR_OK on success, even if no drivers are installed.
//
DWORD videoCreateDriverList (void)

{
    int i, j, k;

    EnterCriticalSection (&g_CritSec);

    dprintf("+ videoCreateDriverList\n");
    // Delete the existing list
    videoFreeDriverList ();

    // Allocate an array of pointers to all possible capture drivers
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        aCapDriverList[i] = (LPCAPDRIVERINFO) GlobalAllocPtr (
                GMEM_MOVEABLE |
                GMEM_SHARE |
                GMEM_ZEROINIT,
                sizeof (CAPDRIVERINFO));
        if (aCapDriverList[i] == NULL) {
            videoFreeDriverList ();
            LeaveCriticalSection (&g_CritSec);
            return DV_ERR_NOMEM;
        }
    }

//actually the next #ifdef...#endif block is a comment; we should not count the vfwwdm which is the only one found in this reg section
#ifdef COMMENT_COUNT_VFW
    // Walk the list of Registry drivers and get each entry
    // Get VFW drivers from MediaResource\MsVideo
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (videoRegGetDriverByIndex (
                    (DWORD) i, aCapDriverList[wTotalVideoDevs])) {

            dprintf("MediaResource: idx %d, DriverName %x, Desc %x\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName, aCapDriverList[wTotalVideoDevs]->szDriverDescription);

            wTotalVideoDevs++;  //
        }
        else
            break;
    }

    if (wTotalVideoDevs == MAXVIDEODRIVERS)
        goto AllDone;
#endif
    // Now add the entries listed in system.ini, [Drivers#2] section, (msvideo[0-9] = driver.drv)
    // to the driver array, ONLY if the entry doesn't exactly match
    // an existing registry entry.

    for (j = 0; j < MAXVIDEODRIVERS; j++) {
        // Get driver name such as *.dll
        if (videoIniGetDriverByIndex ((DWORD) j,
                        aCapDriverList[wTotalVideoDevs])) {

            // Found an entry, now see if it is a duplicate of an existing
            // registry entry

            for (k = 0; k < (int) wTotalVideoDevs; k++) {

                if (lstrcmpi (aCapDriverList[k]->szDriverName,
                    aCapDriverList[wTotalVideoDevs]->szDriverName) == 0) {

                    // Found an exact match, so skip it!
                    goto SkipThisEntry;
                }
            }

            if (wTotalVideoDevs >= MAXVIDEODRIVERS - 1)
                break;

            dprintf("Drivers32: idx %d, DriverName %s ( %x )\n", wTotalVideoDevs, aCapDriverList[wTotalVideoDevs]->szDriverName, aCapDriverList[wTotalVideoDevs]->szDriverName);

            wTotalVideoDevs++;

SkipThisEntry:
            ;
        } // If sytem.ini entry was found
    } // For all system.ini possibilities

#ifdef COMMENT_COUNT_VFW        //see explanation above
AllDone:
#endif

    // Decrement wTotalVideoDevs for any entries which are marked as disabled
    // And remove disabled entries from the list
    for (i = 0; i < MAXVIDEODRIVERS; ) {

        if (aCapDriverList[i] && aCapDriverList[i]->fDisabled) {

            GlobalFreePtr (aCapDriverList[i]);

            // Shift down the remaining drivers
            for (j = i; j < MAXVIDEODRIVERS - 1; j++) {
                aCapDriverList[j] = aCapDriverList[j + 1];
            }
            aCapDriverList[MAXVIDEODRIVERS - 1] = NULL;

            wTotalVideoDevs--;
        }
        else
            i++;
    }

    // Free the unused pointers
    for (i = wTotalVideoDevs; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    // Put PnP drivers first in the list
    // These are the only entries that have a DevNode
    for (k = i = 0; i < (int) wTotalVideoDevs; i++) {
        if (aCapDriverList[i]-> dnDevNode) {
            LPCAPDRIVERINFO lpCDTemp;

            if (k != i) {
                // Swap the entries
                lpCDTemp = aCapDriverList[k];
                aCapDriverList[k] = aCapDriverList[i];
                aCapDriverList[i] = lpCDTemp;
            }
            k++;   // Index of first non-PnP driver
        }
    }

    dbg_Dump_aCapDriverList("videoCreateDriverList");
    dprintf("- videoCreateDriverList\n");

    LeaveCriticalSection (&g_CritSec);
    return DV_ERR_OK;
}





// ----------------------------------------------------------------------
//
// To clean up when a WOW app exits, we need to maintain a list of
// open devices. A list of HANDLEINFO structs is hung off g_pHandles.
// An item is added to the head of this list in videoOpen, and removed
// in videoClose. When a WOW app exits, winmm will call our WOWAppExit
// function: for each entry in the list that is owned by the exiting thread,
// we call videoClose to close the device and remove the handle entry.
//

// one of these per open handle
typedef struct _HANDLEINFO {
    HVIDEO hv;
    HANDLE hThread;
    struct _HANDLEINFO * pNext;
} HANDLEINFO, * PHANDLEINFO;

// head of global list of open handles
PHANDLEINFO g_pHandles;

// critical section that protects global list
CRITICAL_SECTION csHandles;

// init list and critsec
BOOL
NTvideoInitHandleList()
{
    g_pHandles = NULL;

    __try
    {
        InitializeCriticalSection(&csHandles);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
    return TRUE;
}

// finished with critsec list
void
NTvideoDeleteHandleList()
{
    // don't need critical section as no-one else can be using
    // it now (we are about to delete the critsec)

    // empty everything out of the list
    while (g_pHandles) {
        videoClose(g_pHandles->hv);
    }

    DeleteCriticalSection(&csHandles);
}



// add a handle to the list
void
NTvideoAddHandle(HVIDEO hv)
{
    PHANDLEINFO pinfo = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLEINFO));

    if (!pinfo) {
        // couldn't allocate the memory - best thing to do is
        // forget it - nothing bad will happen except that we
        // might possibly fail to clean up if this is a wow app and
        // it exits without closing the capture device.
        return;
    }

    pinfo->hv = hv;
    pinfo->hThread = GetCurrentTask();

    EnterCriticalSection(&csHandles);

    pinfo->pNext = g_pHandles;
    g_pHandles = pinfo;

    LeaveCriticalSection(&csHandles);
}

// delete an entry from the handle list given the HVIDEO.
// caller must close the HVIDEO
// should be called before closing (in case the HVIDEO is reassigned after
// closing and before removing from the list
void
NTvideoDelete(HVIDEO hv)
{
    PHANDLEINFO * ppNext;
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    ppNext = &g_pHandles;
    while (*ppNext) {
        if ((*ppNext)->hv == hv) {
            pinfo = *ppNext;
            *ppNext = pinfo->pNext;
            HeapFree(GetProcessHeap(), 0, pinfo);
            break;

        } else {
            ppNext = &(*ppNext)->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}

// close any handles open by this task
void
AppCleanup(HANDLE hTask)
{
    PHANDLEINFO pinfo;

    EnterCriticalSection(&csHandles);

    pinfo = g_pHandles;
    while (pinfo) {

        if (pinfo->hThread == hTask) {

            // get the next pointer before videoClose deletes the entry
            HVIDEO hv = pinfo->hv;
            pinfo = pinfo->pNext;

            videoClose(hv);
        } else {
            pinfo = pinfo->pNext;
        }
    }

    LeaveCriticalSection(&csHandles);
}


// ----------------------------------------------------------------------




/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
LONG WINAPI NTvideoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoGetNumDevs(BOOL bFreeList)
{
    DWORD dwNumDevs = 0;

    if(DV_ERR_OK == videoCreateDriverList ()) {

       dwNumDevs = wTotalVideoDevs;  // Save it before (possibly) reseting to 0 in videoFreeDriverList.
       if(bFreeList)
                videoFreeDriverList ();
    }

    return dwNumDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI NTvideoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                        DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return (DWORD)NTvideoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (LPARAM)lpChannelCaps,
                dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *           for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI NTvideoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    WCHAR szKey[MAX_PATH];
    WCHAR szbuf[MAX_PATH];
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;
    DWORD dwErr=DV_ERR_OK;
    DWORD dwNumDevs = 0;

    int i;


    dprintf("*************************************** NTvideoOpen ******************************************\n");
    dprintf("+ NTvideoOpen\n");

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    EnterCriticalSection (&g_CritSec);

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    //w = (UINT)dwDeviceID;
    *lphVideo = NULL;

    dwNumDevs = videoGetNumDevs(TRUE);  // TRUE = free the list after counting

    // No drivers installed
    if (dwNumDevs == 0)
    {
        dwErr = DV_ERR_BADINSTALL;
        goto MyExit;
    }

    if (dwDeviceID >= MAXVIDEODRIVERS)
    {
        dwErr = DV_ERR_BADDEVICEID;
        goto MyExit;
    }

    dwErr = videoCreateDriverList ();
    if(DV_ERR_OK != dwErr)
    {
        goto My_Err1;
    }

    for (i = 0; i < (int) wTotalVideoDevs; i++)
    {
        if (dwDeviceID == aCapDriverList[i]->dwMsVideoIndex)
        {
            w = i;
            break;
        }
    }

    //if(w < dwNumDevs)
    if(w < wTotalVideoDevs)
    {
        MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, aCapDriverList[w]->szDriverName, -1, szKey, MAX_PATH);
        MultiByteToWideChar(GetACP(), MB_PRECOMPOSED, aCapDriverList[w]->szDriverName, -1, szbuf, MAX_PATH);

        dprintf("* NTvideoOpen: OpenDriver(%s,%s,...)\n", aCapDriverList[w]->szDriverName, szDrivers);
        //*lphVideo = (HVIDEO)OpenDriver((LPCWSTR)szKey, (LPCWSTR)szDrivers, (LPARAM) (LPVOID) &vop);
        *lphVideo = (HVIDEO)OpenDriver((LPCWSTR)szKey, NULL, (LPARAM) (LPVOID) &vop);
        dprintf("* NTvideoOpen: OpenDriver returned %x\n", *lphVideo);
        if( ! *lphVideo ) {
            if (vop.dwError)    // if driver returned an error code...
            {
                dprintf("? NTvideoOpen: vop.dwError = 0x%08lx\n", vop.dwError);
                dwErr = vop.dwError;
            }
            else {
#ifdef WIN32
                if (GetFileAttributes(aCapDriverList[w]->szDriverName) == (DWORD) -1)
#else
                OFSTRUCT of;

                if (OpenFile (szbuf, &of, OF_EXIST) == HFILE_ERROR)
#endif
                {
                    dprintf("? NTvideoOpen: DV_ERR_BADINSTALL: %s\n", aCapDriverList[w]->szDriverName);
                    dwErr = DV_ERR_BADINSTALL;
                }
                else
                {
                    dprintf("? NTvideoOpen: DV_ERR_NOTDETECTED: %s\n", aCapDriverList[w]->szDriverName);
                    dwErr = DV_ERR_NOTDETECTED;
                }
            }
            goto My_Err1;
        }
        // here is the only SUCCESSFUL way to get out of this 'if' ...
    } else {
        dwErr = DV_ERR_BADINSTALL;
        goto My_Err1;
    }

    NTvideoAddHandle(*lphVideo);

My_Err1:
    videoFreeDriverList ();

MyExit:
    dprintf("- NTvideoOpen\n");

    LeaveCriticalSection (&g_CritSec);
    return dwErr;

}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI NTvideoClose (HVIDEO hVideo)
{
    DWORD dwErr=DV_ERR_OK;

    dprintf("+ NTvideoClose closing handle %x\n" , (DWORD)hVideo);

    if (!hVideo) {
        dwErr = DV_ERR_INVALHANDLE;
        goto MyExit;
    }

    NTvideoDelete(hVideo);

    dwErr = CloseDriver((HDRVR)hVideo, 0L, 0L ) ? DV_ERR_OK : DV_ERR_NONSPECIFIC;
MyExit:
    dprintf("- NTvideoClose returning %x\n" , dwErr);

    return (dwErr);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI NTvideoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
                LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (*lpdwReturn)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return (DWORD)NTvideoMessage(hVideo, msg, dwFlags,
            (LPARAM)(LPVIDEOCONFIGPARMS)&vcp );
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *           returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI NTvideoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_DIALOG, (LPARAM)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *      header and data
 *      by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI NTvideoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI NTvideoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD_PTR)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamPrepareHeader(HVIDEO hVideo,
                LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (LPARAM)lpvideoHdr, dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = NTvideoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (LPARAM)lpvideoHdr, dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = NTvideoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (LPARAM)lpvideoHdr, dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;
    dprintf("* NTvideoStreamStop\n");
    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *           on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI NTvideoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;
    dprintf("* NTvideoStreamReset\n");
    return (DWORD)NTvideoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD_PTR | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD_PTR | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;
    DWORD ret=0L;

    dprintf("+ NTvideoStreamInit (hVideo = %x)\n", hVideo);
    if (!hVideo) {
        ret = DV_ERR_INVALHANDLE;
        goto MyExit;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) ) {
            ret = DV_ERR_PARAM2;
            goto MyExit;
        }
        if (!dwCallbackInst) {
            ret = DV_ERR_PARAM2;
            goto MyExit;
        }
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND)(dwCallback)) ) {
            ret = DV_ERR_PARAM2;
            goto MyExit;
        }
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = hVideo;

    ret = (DWORD)NTvideoMessage(hVideo, DVM_STREAM_INIT,
                (LPARAM) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                sizeof (VIDEO_STREAM_INIT_PARMS));
MyExit:
    dprintf("- NTvideoStreamInit returning %d\n",ret);
    return ret;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI NTvideoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI NTvideoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return (DWORD)NTvideoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI NTvideoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return (DWORD)NTvideoMessage(hVideo, DVM_FRAME, (LPARAM) lpVHdr,
                        sizeof(VIDEOHDR));
}


// NEW STUFF //





typedef struct tagVS_VERSION
{
      WORD wTotLen;
      WORD wValLen;
      TCHAR szSig[16];
      VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoCapDriverDescAndVer | This function gets strings
 *   for the description and version of a video capture driver
 *
 * @parm DWORD | dwDeviceID | Specifies the index of which video driver to get
 *      information about.
 *
 * @parm LPTSTR | lpszDesc | Specifies a place to return the description
 *
 * @parm UINT | cbDesc | Specifies the length of the description string
 *
 * @parm LPTSTR | lpszVer | Specifies a place to return the version
 *
 * @parm UINT | cbVer | Specifies the length of the version string
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number.
 *
 * @comm Use this function to get strings describing the driver and its version
 *
/****************************************************************************/
DWORD WINAPI NTvideoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc, UINT cbDesc, LPTSTR lpszVer, UINT cbVer, LPTSTR lpszDllName, UINT cbDllName)
{
    LPTSTR  lpStr;
    UINT    wLen;
    BOOL    bRetCode;
    TCHAR   szGetName[MAX_PATH];
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetName;
    BOOL    fGetDllName;
    BOOL    fGetVersion;

    BOOL    bDescSet = FALSE;
    int i;

    // Structure used to store enumerated languages and code pages.

    VS_FIXEDFILEINFO * p_vsFixedFileInfo;

    struct LANGANDCODEPAGE {
      WORD wLanguage;
      WORD wCodePage;
    } *lpTranslate;

    UINT cbTranslate;
    WORD wLanguage, wCodePage;
    TCHAR SubBLock[_MAX_PATH];



    //const static TCHAR szNull[]        = TEXT("");
    //const static TCHAR szVideo[]       = TEXT("msvideo");
    //const static TCHAR szSystemIni[]   = TEXT("system.ini");
    //const static TCHAR szDrivers[]     = TEXT("Drivers32");
          static TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];

    fGetName = lpszDesc != NULL && cbDesc != 0;
    fGetDllName = lpszDllName != NULL && cbDllName != 0;
    fGetVersion = lpszVer != NULL && cbVer != 0;

    if (fGetName)
        lpszDesc[0] = TEXT('\0');
    if (fGetDllName)
        lpszDllName[0] = TEXT('\0');
    if (fGetVersion)
        lpszVer [0] = TEXT('\0');

    lstrcpy(szKey, szVideo);
    szKey[sizeof(szVideo)/sizeof(TCHAR) - 1] = TEXT('\0');
    if( dwDeviceID > 0 ) {
        szKey[sizeof(szVideo)/sizeof(TCHAR)] = TEXT('\0');
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR)(TEXT('1') + (dwDeviceID-1) );  // driver ordinal
    }

    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szBuf, sizeof(szBuf)/sizeof(TCHAR), szSystemIni) < 2)
        return DV_ERR_BADDEVICEID;
    //after the above, szBuf should be less than sizeof(szBuf)/sizeof(TCHAR) which is MAX_PATH... so later copy operation are safe
    if (fGetDllName) {
        lstrcpyn(lpszDllName, szBuf, cbDllName);
    }

    if (fGetName)
    {
        // Copy in the driver name initially, just in case the driver has omitted a description field.
        lstrcpyn(lpszDesc, szBuf, cbDesc);
        // now get the description from previously set aCapDriverList array (filled during the videoCreateDriverList call)
        for (i = 0; i < (int) wTotalVideoDevs; i++)
        {
            if (lstrcmpi (szBuf, aCapDriverList[i]->szDriverName) == 0)
            {
                lstrcpyn (lpszDesc, aCapDriverList[i]->szDriverDescription, cbDesc);
                bDescSet = TRUE;
                break;
            }
        }
    }

    // ************************* now for language based desc/vers.info ******************************

    // You must find the size first before getting any file info
    dwVerInfoSize = GetFileVersionInfoSize(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;             // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        if (!hMem)
            return DV_ERR_NOMEM;

        lpstrVffInfo  = GlobalLock(hMem);
        if (!lpstrVffInfo)
        {
            GlobalFree (hMem);
            GetLastError (); // for debugging
            return DV_ERR_NOMEM;
        }

        // Get the File Version first
        if (GetFileVersionInfo(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
            if(VerQueryValue((LPVOID)lpstrVffInfo,
                         TEXT("\\"),
                         (void FAR*)&p_vsFixedFileInfo,
                         (UINT FAR *) &wLen))
            {
                // fill in the file version
                wsprintf(szBuf,
                         TEXT("Version:  %d.%d.%d.%d"),
                         HIWORD(p_vsFixedFileInfo->dwFileVersionMS),
                         LOWORD(p_vsFixedFileInfo->dwFileVersionMS),
                         HIWORD(p_vsFixedFileInfo->dwFileVersionLS),
                         LOWORD(p_vsFixedFileInfo->dwFileVersionLS));
                if (fGetVersion)
                   lstrcpyn (lpszVer, szBuf, cbVer);
            }

            // now if still no desc. was set, attempt to read it from the file...
            if(!bDescSet) {
                // Read the list of languages and code pages.
                VerQueryValue(lpstrVffInfo,
                              TEXT("\\VarFileInfo\\Translation"),
                              (LPVOID*)&lpTranslate,
                              &cbTranslate);

                // Read the file description for the 1st language and code page.
                if(cbTranslate>=sizeof(struct LANGANDCODEPAGE)) // at least one language/codepage pair retrieved...
                {
                        wLanguage = lpTranslate[0].wLanguage ;
                        wCodePage = lpTranslate[0].wCodePage ;
                }
                else
                {
                        wLanguage = 0x0409 ; // 0x0409 (English (United States))
                        wCodePage = 0x04b0 ; // 0x04b0 Unicode
                }

                //get description
                wsprintf( szGetName,TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),wLanguage,wCodePage);

                wLen   = 0;
                lpStr  = NULL;

                // Look for the corresponding string.
                bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                                (LPTSTR)szGetName,
                                (void FAR* FAR*)&lpStr,
                                (UINT FAR *) &wLen);

                if (fGetName && bRetCode && wLen && lpStr)
                   lstrcpyn (lpszDesc, lpStr, cbDesc);
            }
        }

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    return DV_ERR_OK;
}



/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
}

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}




DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr) {
   LPVIDEOHDR lpVHdr) {
    return NTvideoFrame(hVideo, (LPVIDEOHDR) lpVHdr);
}

DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData) {

    NTvideoStreamPrepareHeader(hVideo, lpVHdr, cbData);
    return NTvideoStreamAddBuffer(hVideo, lpVHdr, cbData);
}

#define USE_HW_BUFFERS 1
// #define USE_CONTIG_ALLOC     // can we do this in 32-bit land?



typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
typedef struct _thk_hvideo {
    struct _thk_hvideo * pNext;
    DWORD          Stamp;
    UINT           nHeaders;
    UINT           cbAllocHdr;
    UINT           cbVidHdr;
    UINT           spare;
    LPVOID         paHdrs;
    PTR32          p32aHdrs;
    LPVOID         pVSyncMem;
    DWORD          p32VSyncMem;
    DWORD          pid;

    HVIDEO         hVideo;
    HVIDEO         hFill;

    DWORD_PTR          dwCallback;
    DWORD_PTR          dwUser;

    LPTHKVIDEOHDR  pPreviewHdr;

    } THKHVIDEO;

#define THKHDR(ii) ((LPTHKVIDEOHDR)((LPBYTE)ptv->paHdrs + (ii * ptv->cbAllocHdr)))

static struct _thk_local {
    THKHVIDEO *    pMruHandle;
    THKHVIDEO *    pFreeHandle;
    int            nPoolSize;
    int            nAllocCount;
    } tl;

#define THKHVIDEO_STAMP  MAKEFOURCC('t','V','H','x')
#define V_HVIDEO(ptv) if (!ptv || ptv->Stamp != THKHVIDEO_STAMP) { \
             AuxDebugEx (-1, DEBUGLINE "V_HVIDEO failed hVideo=%08lx\r\n", ptv); \
             return MMSYSERR_INVALHANDLE; \
        }
#define V_HEADER(ptv,p32Hdr,ptvh) if (!(ptvh = NTvidxLookupHeader(ptv,p32Hdr))) { \
            AuxDebugEx(-1, DEBUGLINE "V_HEADER(%08lX,%08lX) failed!", ptv, p32Hdr); \
            return MMSYSERR_INVALPARAM; \
        }

// !!! this means we only allow one of these at a time, which might
// be okay since there's usually only one capture card.
static THKHVIDEO g_tv = { NULL, THKHVIDEO_STAMP, };

#define DATAFROMHANDLE(h) &g_tv

DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        ii,
   PTR32 FAR * pp32Hdr,
   DWORD       cbData)
{

    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;
   #ifdef USE_CONTIG_ALLOC
    CPA_DATA cpad;
   #endif

    *pp32Hdr = 0;

    V_HVIDEO(ptv);
    if (ii >= ptv->nHeaders || ptv->paHdrs == NULL)
        return MMSYSERR_NOMEM;

    ptvh = THKHDR(ii);

  #ifdef USE_HW_BUFFERS
    // try to allocate a buffer on hardware
    //
    if (NTvideoMessage (ptv->hVideo, DVM_STREAM_ALLOCBUFFER,
                (LPARAM) (LPVOID)&ptvh->dwTile, cbData)
        == DV_ERR_OK)
    {
        // if we got hw buffers, dwMemHandle == 0 && dwTile != 0
        // we will depend on this to know who to free the memory to
        // (for phys mem both will be non zero, while for GlobalMem
        // both will be zero)
        //
        ptvh->dwMemHandle = 0;
        ptvh->p16Alloc = (PTR16)ptvh->dwTile;
        ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);
        return MMSYSERR_NOERROR;
    }

    // if we have more than 1 buffer, and
    // the first buffer was on hardware.  if we fail
    // to allocate a buffer on hardware, return failure
    //
    // !!! This might upset somebody who doesn't get a min # of buffers
    if ((ii > 0) &&
        (0 == THKHDR(0)->dwMemHandle) &&
        (0 != THKHDR(0)->dwTile))
        return MMSYSERR_NOMEM;
  #endif

  #ifdef USE_CONTIG_ALLOC
    cpad.dwMemHandle = 0;
    cpad.dwPhysAddr = 0;
    // first try to get contig memory
    //
    ptvh->p32Buff = capPageAllocate (PageContig | PageFixed | PageUseAlign,
                                     (cbData + 4095) >> 12,
                                     0xFFFFF,  // max phys addr mask (fffff is no max addr)
                                     &cpad);
    if (ptvh->p32Buff)
    {
        ptvh->dwMemHandle = cpad.dwMemHandle;
        ptvh->dwTile = capTileBuffer (ptvh->p32Buff, cbData);
        ptvh->p16Alloc = PTR_FROM_TILE(ptvh->dwTile);
        if ( ! ptvh->p16Alloc)
        {
            capPageFree (ptvh->dwMemHandle);
            ptvh->dwMemHandle = 0;
            ptvh->dwTile = ptvh->p32Buff = 0;
        }
        else
        {
            // put the physical address into the the header so that
            // it can be used on the 32 bit side
            //
            ptvh->vh.dwReserved[3] = cpad.dwPhysAddr;
        }
    }

    // if we failed to get contiguous memory,
    // return NOMEM if there is a sufficient number of buffers
    // otherwise use GlobalAlloc
    // !!! The ideal thing to do is only use contig memory buffers until
    // they're all full, then fall back on more non-contig buffers
    //
    if ( ! ptvh->p32Buff)
        if (ii >= MIN_VIDEO_BUFFERS)
            return MMSYSERR_NOMEM;
        else
   #endif
        {
            ptvh->dwTile = ptvh->dwMemHandle = 0;
            ptvh->p16Alloc = GlobalAllocPtr(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, cbData);
            if ( ! ptvh->p16Alloc)
               return MMSYSERR_NOMEM;

            ptvh->p32Buff = MapSL(ptvh->p16Alloc);
        }

    *pp32Hdr = (BYTE *) ptv->p32aHdrs + (ii * ptv->cbAllocHdr);

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxFreePreviewBuffer (
    HVIDEOX       hv,
    PTR32         p32)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);

    ptvh = ptv->pPreviewHdr;

    if (! ptvh )
        return MMSYSERR_NOMEM;

    if (ptvh->p16Alloc)
        GlobalFreePtr (ptvh->p16Alloc);

    GlobalFreePtr (ptvh);

    ptv->pPreviewHdr = NULL;

    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  p32,
   UINT         cbHdr,
   DWORD        cbData)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPTHKVIDEOHDR ptvh;

    cbHdr = max(cbHdr, sizeof(THKVIDEOHDR));

    *p32 = 0;

    V_HVIDEO(ptv);

    if (ptv->pPreviewHdr)
        NTvidxFreePreviewBuffer (hVideo, 0);

    ptvh = (LPVOID) GlobalAllocPtr(GPTR | GMEM_SHARE, cbHdr);
    if (!ptvh)
       return MMSYSERR_NOMEM;

    ptv->pPreviewHdr = ptvh;

    ptvh->dwTile = ptvh->dwMemHandle = 0;
    ptvh->p16Alloc = GlobalAllocPtr(GPTR | GMEM_SHARE, cbData);
    if ( ! ptvh->p16Alloc)
       {
       GlobalFreePtr (ptvh);
       return MMSYSERR_NOMEM;
       }

    ptvh->p32Buff = MapSL(ptvh->p16Alloc);

    *p32 = ptvh->p32Buff;
    return MMSYSERR_NOERROR;
}

DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbAllocHdr,
   PTR32 FAR * lpHdrs)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hVideo);
    LPVOID      lpv;

    V_HVIDEO(ptv);

    if ( ! nHeaders ||
        cbAllocHdr < sizeof(THKVIDEOHDR) ||
        cbAllocHdr & 3 ||
        (cbAllocHdr * nHeaders) > 0x10000l)
        return MMSYSERR_INVALPARAM;

    assert (ptv->paHdrs == NULL);

    lpv = GlobalAllocPtr (GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
                          cbAllocHdr * nHeaders);

    if (!lpv)
        return MMSYSERR_NOMEM;

    ptv->nHeaders   = nHeaders;
    ptv->cbAllocHdr = cbAllocHdr;
    //ptv->cbVidHdr   = sizeof(VIDEOHDREX);
    ptv->cbVidHdr   = sizeof(VIDEOHDR);
    ptv->p32aHdrs   = MapSL(lpv);
    ptv->paHdrs     = lpv;

    *lpHdrs = ptv->p32aHdrs;

    return MMSYSERR_NOERROR;
}

STATICFN VOID PASCAL FreeBuffer (
    LPTHKHVIDEO ptv,
    LPTHKVIDEOHDR ptvh)
{
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

  #ifdef USE_CONTIG_ALLOC
    //
    // if this buffer was pageAllocated (as indicated by dwMemHandle
    // is non-zero)
    //
    if (ptvh->dwMemHandle)
    {
        if (ptvh->dwTile)
            capUnTileBuffer (ptvh->dwTile), ptvh->dwTile = 0;

        capPageFree (ptvh->dwMemHandle), ptvh->dwMemHandle = 0;
    }
    else
  #endif
  #ifdef USE_HW_BUFFERS
    //
    // if this buffer was allocated from capture hardware
    // (as indicated by dwMemHandle == 0 && dwTile != 0)
    //
    if (ptvh->dwTile != 0)
    {
        assert (ptvh->dwMemHandle == 0);
        NTvideoMessage (ptv->hVideo, DVM_STREAM_FREEBUFFER,
                (LPARAM) (LPVOID) ptvh->dwTile, 0);
        ptvh->dwTile = 0;
    }
    else
  #endif
    //
    // if this buffer was allocated from global memory
    //
    {
        if (ptvh->p16Alloc)
            GlobalFreePtr (ptvh->p16Alloc);
    }

    ptvh->p16Alloc = NULL;
    ptvh->p32Buff  = 0;
}

DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    UINT          ii;
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);

    if ( ! ptv->paHdrs)
        return MMSYSERR_ERROR;

    for (ptvh = THKHDR(ii = 0); ii < ptv->nHeaders; ++ii, ptvh = THKHDR(ii))
    {
        if (ptvh->vh.dwFlags & VHDR_PREPARED)
        {
            NTvideoStreamUnprepareHeader (ptv->hVideo, (LPVOID)ptvh, ptv->cbVidHdr);
            ptvh->vh.dwFlags &= ~VHDR_PREPARED;
        }
        FreeBuffer (ptv, ptvh);
    }

    GlobalFreePtr (ptv->paHdrs);
    ptv->paHdrs = NULL;
    ptv->p32aHdrs = 0;
    ptv->nHeaders = 0;

    return MMSYSERR_NOERROR;

}

STATICFN LPTHKVIDEOHDR PASCAL NTvidxLookupHeader (
    LPTHKHVIDEO ptv,
    DWORD_PTR p32Hdr)
{
    WORD ii;

    if ( ! p32Hdr || ! ptv->paHdrs || ! ptv->cbAllocHdr)
        return NULL;

    if ((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) % ptv->cbAllocHdr)
        return NULL;

    ii = (WORD)((p32Hdr - (DWORD_PTR) ptv->p32aHdrs) / ptv->cbAllocHdr);
    if (ii > ptv->nHeaders)
        return NULL;

    return THKHDR(ii);
}

DWORD WINAPI NTvidxFreeBuffer (
    HVIDEOX       hv,
    DWORD_PTR         p32Hdr)
{
    LPTHKHVIDEO ptv = DATAFROMHANDLE(hv);
    LPTHKVIDEOHDR ptvh;

    V_HVIDEO(ptv);
    V_HEADER(ptv,p32Hdr,ptvh);

    // single frame buffers are never prepared!
    //
    assert (!(ptvh->vh.dwFlags & VHDR_PREPARED));

    FreeBuffer (ptv, ptvh);
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\vidx.h ===
/*+ vidx.h
 *
 * structures and prototypes for thunkable videoXXX api's
 *
 *-================ Copyright 1995 Microsoft Corp. ======================*/

#ifndef _VIDX_H_
#define _VIDX_H_

// Force C declarations for C++
//
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#ifdef WIN32
  typedef unsigned __int64 QUADWORD;
  #define HVIDEOX HVIDEO
  #define PTR32   LPVOID
  #define PTR16   LPVOID
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif
#else
  #define QUADWORD struct { DWORD lo; DWORD hi; }
  #undef  WINAPI
  #define WINAPI FAR PASCAL _export
  typedef struct _thk_hvideo FAR * LPTHKHVIDEO;
  #undef  HVIDEO
  #define HVIDEOX LPTHKHVIDEO
  #define PTR32   DWORD
  #define PTR16   LPVOID
#endif

// 'cooked' SMPTE timecode.  this is organized so that
// timecode values can be compared as a single QUAD operation
// so long as frame rates match.
//
// it is treated as a fixed point 48bit binary real number
// with the decimal point always at 32.16
//
// the only non-integral frame rate is 29.97 (NTSC) which is
// indicated by 0 in the frame rate field.
//
typedef union _vidxtimecode {
   struct {
      WORD  wFrameRate;  // 0 == 29.97 frame rate
      WORD  wFrameFract; // fractional frames. range 0-FFFF
      DWORD dwFrames;    // frame count.
      };
   QUADWORD qw;          // for copy/compare operations.
   } VIDXTIMECODE;

// timecode + userdata
//
typedef struct _vidxtimecodedata {
   VIDXTIMECODE time;
   DWORD    dwSMPTEFlags;
   DWORD    dwUser;
   } VIDXTIMECODEDATA;

// structure of memory shared between driver and quartz
// capture. used to allow Quartz to slave a clock to
// the vsync interrupt.
//
// This memory region will be locked down prior to being
// passed to the driver in Win95 so that it may be accessed at
// interrupt time. Because of the way the thunking layer works,
// it is not advisable for the driver to attempt to lock this
// memory. The memory will be visible in all process contexts.
//
// The driver is responsible for updating nVsyncCount on each VSYNC
// or as often as possible.  Whenever nVsyncCount is updated, qwSystemTime
// should be updated also, and if SMPTE timecode corresponding to this VSYNC
// is available, tcdata should be updated also.  If SMPTE timecode for this
// VSYNC is NOT available, dwFlags should be changed to indicate there is no
// timecode infomation (clear the VSYNCMEM_FLAGS_SMPTE bit of dwFlags)
//
// While updating, the driver should set the low bit of the dwInUse flag to 1.
//
// The driver should set the dwFlags field to indicated the presense
// of valid nVsyncCount/qwSystemTime and tcdata.
//
// The driver is allowed to choose between setting qwSystemTime to the return
// value of QueryPerformanceCounter or the value of the Pentium tick.  It is
// recommended to use QPC on NT as the pentium tick is not necessarily available
// to application code in that environment.
//
// When the Quartz capture wrapper reads from this shared memory, it will check
// the dwInUse flag and also read twice comparing results to insure that it reads
// valid, consistent data.
//
typedef struct _vsyncmem {
   DWORD        dwInUse;       // low bit is non-zero when the driver is
                               // updating this struture.  other bits reserved.

   DWORD        nVsyncCount;  // VSYNC count
   QUADWORD     qwSystemTime; // QueryPerformanceCounter value at this VSYNC

   DWORD        dwFlags;      // flags indicate which fields are in use
   #define VSYNCMEM_TIME_MASK    0x0000000F // mask to get type of qwSystemTime
   #define VSYNCMEM_TIME_QPC     0x00000001 // qwSystemTime is QueryPerformanceCounter
   #define VSYNCMEM_TIME_PENTIUM 0x00000002 // qwSystemTime is pentium CPU tick

   #define VSYNCMEM_FLAG_SMPTE   0x00000010  // set if tcdata is valid

   DWORD        dwSpare;      // spare to align the next field on Quad boundary
   VIDXTIMECODEDATA tcdata;   // SMPTE timecode associated with this VSYNC
   } VSYNCMEM;

// DVM_xxx messages are defined in VFW.H
//
#ifndef DVM_CONFIGURE_START
  #define DVM_CONFIGURE_START 0x1000
#endif
#define DVM_CLOCK_BUFFER     (UINT)(DVM_CONFIGURE_START+0x10)
   //
   // dw1 = ptr to VSYNCMEM. ptr is valid until next DVM_CLOCK_BUFFER message
   //       or until driver is closed.
   // dw2 = size of VSYNCMEM buffer
   //
   // driver should return MMSYSERR_NOERROR (0) to indicate that it is
   // capable of keeping the contents of the VSYNCMEM buffer up to date.
   //


// legacy VFW capture filter will NOT make any attempt at time code/line 21
//========================================================================
#if 0
// The extended video header has extra fields that can be used to
// return CC (Line21) and SMPTE timcode information along with captured
// video frames.
//
// the first time the driver gets a DVM_STREAM_PREPAREHEADER and/or DVM_STREAM_ADDBUFFER
// message, it will contain sizeof(VIDEOHDREX) as dwParam2, if the driver fails
// this message, all subsequent messages will use sizeof(VIDEOHDR) as the videoheader size.
// drivers that do not fail this message, may still not be checking the header size
// and responding properly to the new fields.
//
// Drivers that do support the extra fields in VIDEOHDREX are responsible for setting
// bits in dwExtraMask to indicate which extra fields have valid data, this should be
// done BEFORE setting the 'done' bit in the VIDEOHDR
//
typedef struct _videohdrex {
  LPBYTE lpData;
  DWORD  dwBufferLength;
  DWORD  dwBytesUsed;
  DWORD  dwTimeCaptured;
  DWORD  dwUser;
  DWORD  dwFlags;
  DWORD  dwReserved[4];
  //
  // fields above this match the VIDEOHDR
  //

  // bits in this mask indicate which extra header fields
  // have data in them
  DWORD  dwExtraMask;

  // accumulated line21 info since last header. older data
  // is in smaller index'd elements.  the mask indicates
  // how many words of line21 are filled in the array.
  // if both CC and OTHER information are being captured
  // then CC data is in even elements and OTHER data is in
  // odd elements.
  //
  #define VHDR_EXTRA_LINE21     0x0000F  // count of wLine21 members that have data
  #define VHDR_EXTRA_CC         0x00010  // set when data is from CC field
  #define VHDR_EXTRA_OTHER      0x00020  // set when data is program info field
  WORD   wLine21[10]; // this needs to be a multiple of 4+2 so
                      // that the timecode field below gets aligned
                      // properly

  // primary and secondary timecode + userdata
  // timecodeA is in element [0] of the array
  //
  #define VHDR_EXTRA_TIMECODEA  0x10000
  #define VHDR_EXTRA_TIMECODEB  0x20000
  VIDXTIMECODEDATA timecode[2];

} VIDEOHDREX, FAR * LPVIDEOHDREX;
#endif
//========================================================================

// VIDEOHDR + extra fields used by the thunking layer
//
typedef struct _thk_videohdr {
    //VIDEOHDREX vh;
    VIDEOHDR vh;
    PTR32      p32Buff;
    PTR16      p16Alloc;
    DWORD      dwMemHandle;
    DWORD      dwTile;
    DWORD_PTR  dwUser;          // use this instead of dwUser in VIDEOHDR
                                // because some drivers trash it! (Miro DC30)
    DWORD      dwIndex;         // which header is this in our array?
    PTR32      pStart;
} THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

DWORD WINAPI vidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);
DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);

DWORD WINAPI vidxFreeHeaders(
   HVIDEOX hv);
DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv);

DWORD WINAPI vidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);
DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);

DWORD WINAPI vidxFreeBuffer (
   HVIDEOX hv,
   DWORD   p32Hdr);
DWORD WINAPI NTvidxFreeBuffer (
   HVIDEOX hv,
   DWORD_PTR p32Hdr);

DWORD WINAPI vidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI vidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);
DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);

DWORD WINAPI vidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);
DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);

DWORD WINAPI vidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);
DWORD WINAPI NTvidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);

DWORD WINAPI vidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem
DWORD WINAPI NTvidxSetupVSyncMem (
    HVIDEOX     hVideo,
    PTR32 FAR * ppVsyncMem); // NULL to release VSYNC mem


// needed for Win95 thunking
//
VOID WINAPI OpenMMDEVLDR(void);
VOID WINAPI CloseMMDEVLDR(void);

#ifdef __cplusplus
}
#endif

#endif // _VIDX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\wdmdlgs.h ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.h | Include file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#ifndef _DIALOGS_H_
#define _DIALOGS_H_

// Constants used to check if the property has an automatic mode or/and a manual mode
#define KSPROPERTY_FLAGS_MANUAL KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL
#define KSPROPERTY_FLAGS_AUTO KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

#if (KSPROPERTY_FLAGS_AUTO != KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) || (KSPROPERTY_FLAGS_MANUAL != KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL)
#error Why did you mess with the kernel streaming include files? - PhilF-
#endif

typedef struct _tagPROPSLIDECONTROL
{
    LONG lLastValue;
    LONG lCurrentValue;
    LONG lMin;
    LONG lMax;
    ULONG ulCapabilities;

    // Dialog item IDs
    UINT uiProperty;
    UINT uiSlider;
    UINT uiString;
    UINT uiStatic;
    UINT uiCurrent;
    UINT uiAuto;
} PROPSLIDECONTROL, * PPROPSLIDECONTROL;

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGCLASS
 *
 *  @class CWDMDialog | This class provides support for property
 *    pages to be displayed within a property sheet.
 *
 *  @mdata BOOL | CWDMDialog | m_bInit | This member is set to TRUE after the
 *    page has been initialized.
 *
 *  @mdata BOOL | CWDMDialog | m_bChanged | This member is set to TRUE after the
 *    page has been changed.
 *
 *  @mdata int | CWDMDialog | m_DlgID | Resource ID of the property page dialog.
 *
 *  @mdata HWND | CWDMDialog | m_hDlg | Window handle of the property page.
 *
 *  @mdata PDWORD | CWDMDialog | m_pdwHelp | Pointer to the list of help IDs
 *    to be displayed in the property page.
 *
 *  @mdata CWDMPin * | CWDMDialog | m_pCWDMPin | Pointer to the kernel
 *    streaming object we will query the property on.
 *
 *  @mdata PPROPSLIDECONTROL | CWDMDialog | m_pPC | Pointer to the list of
 *    slider controls to be displayed in the property page.
 *
 *  @mdata DWORD | CWDMDialog | m_dwNumControls | Number of controls to\
 *    display in the page.
 *
 *  @mdata GUID | CWDMDialog | m_guidPropertySet | GUID of the KS property
 *    we are showing in the property page.
 ***************************************************************************/
class CWDMDialog
{
public:
    CWDMDialog(int DlgID, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, CTAPIVCap *pCaptureFilter);
    ~CWDMDialog() {};

	HPROPSHEETPAGE	Create();

private:
	BOOL				m_bInit;
	BOOL				m_bChanged;
	int					m_DlgID;
	HWND				m_hDlg;
	PPROPSLIDECONTROL	m_pPC;
	DWORD				m_dwNumControls;
	GUID				m_guidPropertySet;
	CTAPIVCap			*m_pCaptureFilter;

	// Dialog proc helper functions
	int		SetActive();
	int		QueryCancel();
	int		DoCommand(WORD wCmdID,WORD hHow);

	// Dialog proc
	static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif // _DIALOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\wrkrthd.cpp ===
/****************************************************************************
 *  @doc INTERNAL WRKRTHD
 *
 *  @module WrkrThd.cpp | Source file for the <c CTAPIVCap> class methods
 *    used to implement the video capture worker thread.
 ***************************************************************************/

#include "Precomp.h"

EXTERN_C int g_IsNT;

#define __WRKRTHD__
#include "dbgxtra.h"

#ifdef XTRA_TRACE
#include "dbgxtra.c"
#endif

//#define DEBUG_STREAMING
#define DEBUG_STREAMING_BRK 1

#ifdef DEBUG_STREAMING
DWORD debug_streaming_flag=0;
#define ODS(str)    OutputDebugString(str);      DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: DBG_STRM %s", _fx_,str))

DWORD crca[6]={0};

#endif

#ifndef SLSH     // actually it is previously defined in dbgxtra.h, but just in case ...
#define SLSH(a)    a##/
#endif


//#define LOOPBUGFIX
#ifndef LOOPBUGFIX    // cristiai: isolate statements for the loopbug fix ...
    #define TEST_LBUG SLSH(/)
#else
    #define TEST_LBUG
#endif

#if defined(DEBUG) && defined(DEBUG_STREAMING)
    #define DBGONLY
#else
    #define DBGONLY SLSH(/)
#endif

#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif

#define WRKRTHD_DEBUG
//--//#include "dbgutil.h" // this defines the __DBGUTIL_H__ below
#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef WRKRTHD_DEBUG
    DEFINE_DBG_VARS(WrkrThd, (NTSD_OUT | LOG_OUT), 0x8000);
  #else
    DEFINE_DBG_VARS(WrkrThd, 0, 0);
  #endif
  #define D(f) if(g_dbg_WrkrThd & (f))
  #define DEQ(f) if((g_dbg_WrkrThd & (f)) == (f))

#else
  #undef WRKRTHD_DEBUG

  #define D(f) ; / ## /
  #define DEQ(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ThreadProc | Capture worker thread.
 *
 *  @rdesc This method returns 0.
 *
 *  @comm General strategy for thread synchronization:
 *    as much as possible we try to handle thread state transitions without
 *    trying to grab any critical sections. we use InterlockedExchange of a
 *    thread state variable and count on the fact that only Active and Inactive
 *    and the ThreadProc can change the thread state
 *
 *    this works because: the caller of Active/Inactive is serialized so we
 *    will never try to make two state changes simultaneously.
 *    so state transitions boil down to a few simple possibilities:
 *
 *    Not->Create   - Create() does this. effectively serializes Create
 *                    so that the first thread does the work and subsequent
 *                    threads fail.
 *
 *    Create->Init  - worker does this when it starts up. worker will always
 *                    proceed to Pause, this state exists only to make debugging
 *                    easier.
 *    Init->Pause   - worker does this when done with initialization.
 *
 *    Pause->Run    - user does  this via Run()
 *    Run->Pause    - user does this via Pause()
 *
 *    Run->Stop     - user does this via Stop()
 *    Pause->Stop   - user does this via Stop()
 *
 *    Stop->Destroy - another debugging state. worker sets destroy to indicate
 *                    that it has noticed Stop request and is not shutting down
 *                    thread always proceeds to Exit from
 *    Destroy->Exit - worker does this prior to dying.  this is a debug transition
 *    Exit->Not     - Destroy() does this after waiting for the worker to die.
 *
 *    When Active returns, worker should always be in Pause or Run state
 *    When Inactive returns, worker should always be in Not state (worker does
 *       not exist)
 *
 ***************************************************************************/
DWORD CTAPIVCap::ThreadProc()
{
    ThdState state;

    FX_ENTRY("CTAPIVCap::ThreadProc")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    state = ChangeThdState (TS_Init);
    ASSERT (state == TS_Create);
    if (state != TS_Create)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state!", _fx_));
        goto MyExit;
    }

    // Do the work necessary to go into the paused state
    if (FAILED(Prepare()))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Error preparing the allocator. Can't capture!", _fx_));
        // Main thread is blocked right now!
        SetEvent(m_hEvtPause);
        goto MyExit;
    }

    // Go into paused state
    state = ChangeThdState (TS_Pause);
    ASSERT (state == TS_Init);
    if (state != TS_Init)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state!", _fx_));
        goto MyExit;
    }

    SetEvent(m_hEvtPause);

    while (m_state != TS_Stop)
    {
        // Don't start capturing until we run (or stop)
        WaitForSingleObject(m_hEvtRun, INFINITE);
        ResetEvent(m_hEvtRun);

        // Stream until not running, or we get an error
        // There is no reason to call Capture if WaitForSingleObject
        // woke up on a stop event...
        if (m_state != TS_Stop)
            Capture();
    }

    // We expect to be in the Stop state when we get to here.
    // Flush any downstream buffers.
    ASSERT (m_state == TS_Stop);

    // For next time we pause
    ResetEvent(m_hEvtPause);
    if (m_pCapturePin && m_pCapturePin->IsConnected())
        m_pCapturePin->Flush();
    if (m_pPreviewPin && m_pPreviewPin->IsConnected())
        m_pPreviewPin->Flush();
    if (m_pRtpPdPin && m_pRtpPdPin->IsConnected())
        m_pRtpPdPin->Flush();

MyExit:

    // Change the state to destroy to indicate that we are exiting
    state = ChangeThdState (TS_Destroy);

    // Free stuff
    Unprepare();

    // Change state to Exit and then get out of here
    ChangeThdState (TS_Exit);

    return 0;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ThreadProcInit | Thread init stub.
 *
 *  @rdesc This method returns 0
 ***************************************************************************/
DWORD WINAPI CTAPIVCap::ThreadProcInit (void * pv)
{
   CTAPIVCap * pThis = (CTAPIVCap *) pv;
   return pThis->ThreadProc();
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | CreateThd | This method creates the
 *    capture worker thread.
 *
 *  @rdesc This method returns TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CTAPIVCap::CreateThd()
{
    BOOL fRes = TRUE;

    FX_ENTRY("CTAPIVCap::CreateThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Return fail if someone else is already creating / has created
    // the worker thread
    if (ChangeThdState(TS_Create) > TS_Not)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Thread already created!", _fx_));
        goto MyError0;
    }

    // Create Pause event
    ASSERT (!m_hEvtPause);
    if (!(m_hEvtPause = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create Pause event!", _fx_));
        goto MyError0;
    }

    // Create Run event
    ASSERT (!m_hEvtRun);
    if (!(m_hEvtRun = CreateEvent(NULL, TRUE, FALSE, NULL)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create Run event!", _fx_));
        goto MyError1;
    }

    m_EventAdvise.Reset();

    // Create the worker thread
    if (!(m_hThread = CreateThread (NULL, 0, CTAPIVCap::ThreadProcInit, this, 0, &m_tid)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create capture worker thread!", _fx_));
        goto MyError2;
    }

    goto MyExit;

MyError2:
    if (m_hEvtRun)
        CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
MyError1:
    if (m_hEvtPause)
        CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
MyError0:
    m_state = TS_Not;
    fRes = FALSE;
MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | DestroyThd | This method waita for the
 *    worker thread to die before performing some cleanup.
 *
 *  @rdesc This method returns TRUE
 ***************************************************************************/
BOOL CTAPIVCap::DestroyThd()
{
    FX_ENTRY("CTAPIVCap::DestroyThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Anything to destroy?
    if (m_state == TS_Not)
     goto MyExit;

    // Wait for the thread to die. (Destroy must be preceeded by
    // a Stop or we could deadlock here)
    ASSERT (m_state >= TS_Stop);
    WaitForSingleObject (m_hThread, INFINITE);
    ASSERT (m_state == TS_Exit);

    // Cleanup
    if (m_hThread)
        CloseHandle(m_hThread), m_hThread = NULL;
    m_tid = 0;
    if (m_hEvtPause)
        CloseHandle(m_hEvtPause), m_hEvtPause = NULL;
    if (m_hEvtRun)
        CloseHandle(m_hEvtRun), m_hEvtRun = NULL;
    m_state = TS_Not;

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | RunThd | This method puts the worker
 *    thread into the run state. This call does not wait for the state
 *    transition to be complete before returning.
 *
 *  @rdesc This method returns TRUE on success, FALSE otherwise
 ***************************************************************************/
BOOL CTAPIVCap::RunThd()
{
    BOOL fRes = TRUE;
    ThdState state;

    FX_ENTRY("CTAPIVCap::RunThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Bail if we are already running
    if (m_state == TS_Run)
    {
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're already running!", _fx_));
        goto MyExit;
    }

    // A transition to run state is only valid if the current
    // state is Pause (or already Running)
    state = m_state;
    if (state != TS_Run && state != TS_Pause)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid state transition!", _fx_));
        fRes = FALSE;
        goto MyExit;
    }

    // Change the state and turn on the 'run' event
    // in case the thread is blocked on it.  If state that we are
    // changing from is not Run or Pause, then something is seriously wrong!!
    state = ChangeThdState(TS_Run);
    ASSERT(state == TS_Run || state == TS_Pause);
    SetEvent(m_hEvtRun);

    // Go capture, go! Note when we started it
    if (m_pClock)
        m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtDriverStarted);
    else
        m_cs.rtDriverStarted = m_tStart;

    // Start streaming on streaming capture devices
    m_pCapDev->StartStreaming();

    // These need to be zeroed every time the driver is told to stream, because
    // the driver will start counting from 0 again
    m_cs.dwlLastTimeCaptured = 0;
    m_cs.dwlTimeCapturedOffset = 0;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're running!", _fx_));

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | PauseThd | This method puts the capture
 *    worker thread in a paused state and wait for it to get there.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
BOOL CTAPIVCap::PauseThd()
{
    BOOL fRes = TRUE;
    ThdState state = m_state;

    FX_ENTRY("CTAPIVCap::PauseThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // We're already paused
    if (state == TS_Pause)
        goto MyExit;

    // It is valid to go into the pause state only if currently in the Create/Init
    // (depending on if our thread has run yet) or Run state
    ASSERT (state == TS_Create || state == TS_Init || state == TS_Run);

    // If we are in the init state, we will fall into the pause state
    // naturally, we just have to wait for it to happen
    if (state == TS_Create || state == TS_Init)
    {
        WaitForSingleObject (m_hEvtPause, INFINITE);
        state = m_state;
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Transition Create->Init->Pause complete", _fx_));
    }
    else if (state == TS_Run)
    {
        state = ChangeThdState (TS_Pause);

        ASSERT(state == TS_Run);

        // Since we aren't running, stop streaming on streaming capture devices
        m_pCapDev->StopStreaming();

        state = m_state;
        m_cs.fReRun = TRUE;  // if we are RUN now, it will have been RUN-PAUSE-RUN
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: Transition Run->Pause complete", _fx_));
    }

    fRes = (BOOL)(state == TS_Pause);

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | StopThd | This method puts the capture
 *    worker thread in a stopped state.
 *
 *  @rdesc Returns TRUE
 ***************************************************************************/
BOOL CTAPIVCap::StopThd()
{
    ThdState state = m_state;

    FX_ENTRY("CTAPIVCap::StopThd")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Are we already stopped or some other pin terminated the worker thread?
    if (state >= TS_Stop || state == TS_Not)
     goto MyExit;

    // Don't go from Run->Stop without Pause
    if (state == TS_Run)
        PauseThd();

    state = ChangeThdState (TS_Stop);

    // We won't be running, unblock our thread
    SetEvent(m_hEvtRun);

    // Next RUN is not a RUN-PAUSE-RUN
    m_cs.fReRun = FALSE;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: Transition Pause->Stop complete", _fx_));

    // Do we expect that Stop can only be called when the thread is in a Pause state ?
    // No, it can be called also when a call to PauseThd failed, like in BasePin.cpp@414...
    //thus the assert below is commented out (see bug 209192)
    //ASSERT (state == TS_Pause);

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc BOOL | CTAPIVCap | ChangeThdState | This method changes the state of the
 *    capture worker thread.
 *
 *  @rdesc Returns new thread state
 ***************************************************************************/
ThdState CTAPIVCap::ChangeThdState(ThdState state)
{
#ifdef DEBUG
    static char szState[] = "Not    \0Create \0Init   \0Pause  \0"
                            "Run    \0Stop   \0Destroy\0Exit   \0";
#endif

    FX_ENTRY("CTAPIVCap::ChangeThdState")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SUCCESS: ChangeThdState(%d:%s) current=%d:%s", _fx_, (int)state, (state <= TS_Exit && state >= TS_Not) ? szState + (int)state * 8 : "<Invalid>", (int)m_state, (m_state <= TS_Exit && m_state >= TS_Not) ? szState + (int)m_state * 8 : "<Invalid>"));

    return (ThdState) InterlockedExchange ((LONG *)&m_state, (LONG)state);
} ;

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINFUNCTION
 *
 *  @func DWORD | OpenVxDHandle | On Win9x we have to convert the event
 *    handle we will be using as a callback into a VxD handle. Ssince the
 *    Win9x kernel does not publish this entry point we dynamically link to
 *    it.
 *
 *  @parm HANDLE | hEvent | Specifies a event handle.
 *
 *  @rdesc Returns mapped event handle
 ***************************************************************************/
static DWORD WINAPI OpenVxDHandle(HANDLE hEvent)
{
    HMODULE hModule;
    typedef DWORD (WINAPI *PFNOPENVXDHANDLE)(HANDLE);
    static DWORD (WINAPI *pfnOpenVxDHandle)(HANDLE);

    if (!pfnOpenVxDHandle)
    {
        if (!(hModule = GetModuleHandle(TEXT("Kernel32"))))
        {
            ASSERT(0);
            return 0;
        }
        if (!(pfnOpenVxDHandle = (PFNOPENVXDHANDLE)GetProcAddress (hModule, "OpenVxDHandle")))
        {
            ASSERT(0);
            return 0;
        }
    }
    return pfnOpenVxDHandle (hEvent);
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | Capture | This method is used to
 *    run the capture loop. Executes while in the run state.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::Capture()
{
    HRESULT Hr = E_FAIL;
    DWORD dwOldPrio;
    BOOL bDiscon;
    LPTHKVIDEOHDR ptvh;
    DWORD dwBytesUsed, dwBytesExtent;
    DWORD dwCaptureTime, dwLastCaptureTime, dwCaptureWaitTime;
    DWORD dwPreviewTime, dwLastPreviewTime, dwPreviewWaitTime;
    DWORD dwLastRefCaptureTime, dwLastRefPreviewTime, dwLastRefDeviceTime, dwTime, dwWaitTime;
    BOOL fCapture, fPreview;
    HEVENT hEvent;
    UINT uiLatestIndex;
    CFrameSample *pCSample;
    CFrameSample *pPSample;
    CRtpPdSample *pRSample;
    DWORD dwNumBufferDone;
    DWORD dwDoneCount;
    REFERENCE_TIME DeviceAvgTimePerFrame;
    DWORD dwNumPreviewFramesDelivered, dwNumCaptureFramesDelivered;
    DWORD dwNumPreviewBytesDelivered, dwNumCaptureBytesDelivered;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    char szDebug[512];
#endif

    FX_ENTRY("CTAPIVCap::Capture")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    if ((dwOldPrio = GetThreadPriority(GetCurrentThread())) != THREAD_PRIORITY_HIGHEST)
        SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    // Start streams
    bDiscon = TRUE;

    dwNumPreviewFramesDelivered = dwNumCaptureFramesDelivered = 0;
    dwNumPreviewBytesDelivered = dwNumCaptureBytesDelivered = 0;
    dwNumBufferDone = 0;
    hEvent = (HEVENT)(HANDLE)m_EventAdvise;
    dwLastRefCaptureTime = dwLastRefPreviewTime = dwLastRefDeviceTime = dwLastCaptureTime = dwLastPreviewTime = timeGetTime();
    DeviceAvgTimePerFrame = m_user.pvi->AvgTimePerFrame;

#if defined(DEBUG)
        OutputDebugString("Capture...\n");
        {       UINT i; char buf[64+36];
                for(i=0; i<m_cs.nHeaders;i++)
                        if(m_pBufferQueue[i]!=i) {
                                _itoa(i,buf,16);
                                strcat(buf," : order changed\n");
                                OutputDebugString(buf);
                        }
        }
#endif


    // Stream as long as we're running - or paused
    // The test on Pause did not exist in the original code. There is a time
    // window where m_state may be set to Paused (Pausing the graph), before any of the deliver
    // function gets to block due to the base filter m_State set to paused.
    // If you hit this window you will exit Capture!
    while ((m_state == TS_Run || m_state == TS_Pause) && m_cs.nHeaders > 0)
    {

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Loop ******** m_pBufferQueue[m_uiQueueTail] = m_pBufferQueue[%d] = %d", _fx_, m_uiQueueTail,m_pBufferQueue[m_uiQueueTail]));

        ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
        pCSample = pPSample = NULL;
        pRSample = NULL;

        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Waiting for done buffer **** m_pBufferQueue[m_uiQueueTail] = m_pBufferQueue[%d] = %d", _fx_, m_uiQueueTail,m_pBufferQueue[m_uiQueueTail]));

            // STOP will hang until this event times out. So make sure this never
            // waits across a state transition
            // !!! PAUSE will still keep waiting until the timeout for slow rates
            HANDLE hStuff[2] = {m_cs.hEvtBufferDone, m_hEvtRun};
            int waitcode = WaitForMultipleObjects(2, hStuff, FALSE, 1000);
            //int waitcode = WaitForMultipleObjects(2, hStuff, FALSE, m_user.usPerFrame / 500);

            // timeout?
            if (waitcode == WAIT_TIMEOUT)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: Waiting for buffer %d TIMED OUT!", _fx_, m_pBufferQueue[m_uiQueueTail]));
                DBGONLY if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                continue;
            }
            else if (waitcode != WAIT_OBJECT_0)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: hEvtRun was set", _fx_));
                ResetEvent(m_hEvtRun);  // don't infinite loop
                continue;
            }

#if DBG
            if (m_pCapDev->IsBufferDone(&ptvh->vh))
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GOT %d EVENT AND DONE BIT!", _fx_, m_pBufferQueue[m_uiQueueTail]));
#endif

#if defined(DEBUG) && defined(DEBUG_STREAMING_ZZZ)
            { char *pd=szDebug; DWORD nh; BOOL b;
            pd+=wsprintf(pd, "Buffer DONE status: ");
            for(nh=dwDoneCount=0; nh<m_cs.nHeaders; nh++) {
                    // (@fixed for variable number of buffers -- Cristi) // Hmmm, you're assuming always 6 buffers here... KABOOM!
                    b=m_pCapDev->IsBufferDone(&m_cs.paHdr[m_pBufferQueue[nh]].tvh.vh);
                    pd+=wsprintf(pd, "%d[%s] ", m_pBufferQueue[nh], b ? "X" : "_");
                    if(b)
                        dwDoneCount++;
                    }
            wsprintf(pd, "(total %d) C:%d", dwDoneCount, m_uiQueueTail);
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   %s",_fx_, szDebug));
            OutputDebugString(szDebug);
            if(dwDoneCount==0) {
                if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                OutputDebugString("dwDoneCount==0");

                }
            }
#endif
            // Make sure we always use the latest DONE buffer
            dwDoneCount=0;
            while (1)
            {
                dwNumBufferDone++; dwDoneCount++;
                uiLatestIndex = m_uiQueueTail + 1;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   1. Using uiLatestIndex %d",_fx_, uiLatestIndex));
                if (uiLatestIndex == m_cs.nHeaders)
                    uiLatestIndex = 0;
                if (uiLatestIndex == m_uiQueueHead)
                    break;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   2. Using uiLatestIndex %d (lLock=%ld)",_fx_, uiLatestIndex,m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].lLock));
                TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   2. Using uiLatestIndex %d (nUsed=%ld)",_fx_, uiLatestIndex,m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].nUsedDownstream));
                if (    !(m_pCapDev->IsBufferDone(&m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].tvh.vh))
                     TEST_LBUG || m_cs.paHdr[m_pBufferQueue[uiLatestIndex]].nUsedDownstream>0
                   )
                    break;
                DBGONLY if(dwDoneCount>6) {
                DBGONLY         //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   dwDoneCount == %d > 6: WRAP!",_fx_, dwDoneCount));
                DBGONLY         //OutputDebugString("dwDoneCount>6: WRAP!");
                DBGONLY         if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                DBGONLY         }

                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   3. Using uiLatestIndex %d, m_uiQueueTail = %d,m_uiQueueHead = %d",_fx_, uiLatestIndex, m_uiQueueTail,m_uiQueueHead));
                // This is an old buffer and there is a newer one available - release old buffer
                // @todo Isn't there a better way to return the buffer to the device?
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   4. Before AddRefs lLock=%ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                if (m_cs.paCaptureSamples && (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                if (m_cs.paPreviewSamples && (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                if (m_pRtpPdPin->IsConnected() && m_cs.paRtpPdSamples && (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]]))
                    pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   5. After ...      lLock=%ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                m_uiQueueTail = uiLatestIndex;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   6. set m_uiQueueTail = %d", _fx_, m_uiQueueTail));
                if (pPSample)
                    pPSample->Release(), pPSample = NULL;
                if (pCSample)
                    pCSample->Release(), pCSample = NULL;
                if (pRSample)
                    pRSample->Release(), pRSample = NULL;
                //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   7. After release lLock = %ld", _fx_, m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock));
                ptvh = &m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].tvh;
            }

            //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   m_pBufferQueue[%d] .. m_pBufferQueue[%d] = %d .. %d",_fx_, m_uiQueueTail, m_uiQueueHead, m_pBufferQueue[m_uiQueueTail], m_pBufferQueue[m_uiQueueHead]));
            if(dwDoneCount==0)      // no done buffers available
                    continue;
        }

#ifdef WRKRTHD_DEBUG
        { int i; DWORD crc;
        crc=Buf_CRC32((unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength); // this is for m_pBufferQueue[m_uiQueueTail]
        D(4) dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   8. crc(buffer[%d] : %p) = %08lx", _fx_, m_pBufferQueue[m_uiQueueTail],ptvh,crc);
        for(i=0;i<6;i++)
                if(crca[i]==crc)
                        D(4) dprintf("%s:   crca[%d ==  %d] = %08lx * * * * * * * * * * * * * * * *\n", _fx_, i, m_pBufferQueue[m_uiQueueTail],crc);
        crca[m_pBufferQueue[m_uiQueueTail]]=crc;
        }
#endif
        TEST_LBUG //we are going to use the buffer, so mark it in use down stream below
        TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  -9. m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream = %ld", _fx_,m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream));
        TEST_LBUG InterlockedCompareExchange(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream,1,0);
        TEST_LBUG DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  =9. m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream = %ld", _fx_,m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream));
        TEST_LBUG OutputDebugString("m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].nUsedDownstream <- 1\n");

#ifdef WRKRTHD_DEBUG
        D(0x8000)
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        { int i;
          D(1) dprintf("Image buffer at %p (len = %d)\n",(unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength);
          D(1) dprintf("W 4CC used = %lX : '%.4s' (bitcount = %d )\n", g_dbg_4cc, &g_dbg_4cc, g_dbg_bc);

          //D(1) dprintf("YUY2 160 x 120 means %d\n", 160*120*2);
          //D(1) dprintf("I420 176 x 144 means %d\n", 176*144+(176*144)/2);

          D(1) hex_dump((unsigned char*)ptvh->vh.lpData,16);
          D(1) fill4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\x0e\x64\x40");
          for(i=0; i<20; i++)
                set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",i,i);
          for(i=0; i<20; i++)
                set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",20-i,i);
          //for(i=0; i<80; i++)
          //      set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",10+i,20+i/2);
          D(2) DebugBreak();
        }
#endif

        dwCaptureTime = dwPreviewTime = dwTime = timeGetTime();

        // Note the clock time as close as possible to the capturing of this
        // frame.
        if (m_pClock)
            m_pClock->GetTime((REFERENCE_TIME *)&m_cs.rtThisFrameTime);
        else
            m_cs.rtThisFrameTime = (REFERENCE_TIME)dwTime * 10000;

        // Evaluate the  rate at which video frames are coming from the capture device
        if (dwNumBufferDone && ((dwTime - dwLastRefDeviceTime) > 1000))
        {
            if (dwNumBufferDone)
                DeviceAvgTimePerFrame = (REFERENCE_TIME)(dwTime - dwLastRefDeviceTime) * 10000 / dwNumBufferDone;
            dwNumBufferDone = 0;
            dwLastRefDeviceTime = dwTime;
        }

        // Do we have a use for this frame on the capture pin?
        if (    !m_pCapturePin->IsConnected()
                || (    m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming
                        && (dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000)
                                               < (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000))
                    )
           )
            fCapture = FALSE;
        else
            fCapture = TRUE;

        // Do we have a use for this frame on the preview pin?
        if (    m_fPreviewCompressedData
                || !m_pPreviewPin->IsConnected()
                || (    m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming
                        && (dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000)
                                               < (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000))
                   )
           )
            fPreview = FALSE;
        else
            fPreview = TRUE;

        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   fPreview = %d fCapture = %d",_fx_, fPreview, fCapture));
        if (!fPreview && !fCapture)
        {
            // We're sending buffers downstream at a much lower rate
            // than we are capturing - return this buffer to the
            // capture device and wait for the next one. This next buffer
            // will still allow us to deliver a frame on time. This
            // way, we avoid waiting in the worker thread too long
            // which would ultimately starve the capture device.
            // @todo Isn't there a better way to return the buffer to the device?
            if (m_cs.paCaptureSamples && (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]]))
                pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (m_cs.paPreviewSamples && (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]]))
                pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (m_pRtpPdPin->IsConnected() && m_cs.paRtpPdSamples && (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]]))
                pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
            if (++m_uiQueueTail >= m_cs.nHeaders)
                m_uiQueueTail = 0;
            if (pPSample)
                pPSample->Release(), pPSample = NULL;
            if (pCSample)
                pCSample->Release(), pCSample = NULL;
            if (pRSample)
                pRSample->Release(), pRSample = NULL;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            wsprintf(szDebug, "Too soon: DeviceAvgTimePerFrame = %ld\n", DeviceAvgTimePerFrame);
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000) = (%ld - %ld + (DWORD)(%ld / 10000) = %ld\n", dwCaptureTime, dwLastCaptureTime, DeviceAvgTimePerFrame, dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000) = (DWORD)(%ld / 10000) = %ld\n", m_pCapturePin->m_lMaxAvgTimePerFrame, (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000) = (%ld - %ld + (DWORD)(%ld / 10000) = %ld\n", dwPreviewTime, dwLastPreviewTime, DeviceAvgTimePerFrame, dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
            wsprintf(szDebug, "Too soon: (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000) = (DWORD)(%ld / 10000) = %ld\n", m_pPreviewPin->m_lMaxAvgTimePerFrame, (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000));
            OutputDebugString(szDebug);
#endif
            continue;
        }
        else
        {
            // What pin needs it first?
            if (fPreview)
            {
                if (    (dwPreviewTime < (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000UL))
                     && (       (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
                             || (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000-dwPreviewTime < DeviceAvgTimePerFrame/10000)
                        )
                   )
                    dwPreviewWaitTime = dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime;
                else
                    dwPreviewWaitTime = 0;
            }
            else
            {
                dwPreviewWaitTime = 0xFFFFFFFF;
            }
            if (fCapture)
            {
                if (    (dwCaptureTime < (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000UL))
                     && (       (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
                             || (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000-dwCaptureTime < DeviceAvgTimePerFrame/10000)
                        )
                   )
                    dwCaptureWaitTime = dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime;
                else
                    dwCaptureWaitTime = 0;
            }
            else
            {
                dwCaptureWaitTime = 0xFFFFFFFF;
            }

            // Sleep until it is time to deliver a frame on either pin
            //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   dwPreviewWaitTime 0x%08lx, dwCaptureWaitTime 0x%08lx dwTimex%08lx", _fx_,dwPreviewWaitTime, dwCaptureWaitTime, dwTime));
            dwWaitTime = min(dwPreviewWaitTime, dwCaptureWaitTime);
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) {
            wsprintf(szDebug, "Waiting %d ms...", dwWaitTime);
            OutputDebugString(szDebug);
            }
#endif
            if ((dwWaitTime > 1) && (timeSetEvent(dwWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Waiting %d ms...",_fx_, dwWaitTime));
                m_EventAdvise.Wait();
                dwTime = timeGetTime();
            }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) OutputDebugString(" done!\n");

            if (m_pBufferQueue[m_uiQueueTail] == m_cs.uiLastAdded)
            {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Capture device is STARVING!", _fx_));
            }
#endif

            if ((m_pCapDev->m_vcdi.nCaptureMode != CaptureMode_Streaming) && (m_state == TS_Run)) {
                HRESULT Hrg;
                if (FAILED(Hrg=m_pCapDev->GrabFrame(&ptvh->vh))) {
                    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: GrabFrame returned error 0x%08lx", _fx_,Hrg));
                    break;
                }

#ifdef WRKRTHD_DEBUG
                D(0x8000)
                { int i;
                  D(1) dprintf("Image buffer at %p (len = %d) !!! frame grab !!!\n",(unsigned char*)ptvh->vh.lpData,ptvh->vh.dwBufferLength);
                  D(1) dprintf("W 4CC used = %lX : '%.4s' (bitcount = %d )\n", g_dbg_4cc, &g_dbg_4cc, g_dbg_bc);

                  //D(1) dprintf("YUY2 160 x 120 means %d\n", 160*120*2);
                  //D(1) dprintf("I420 176 x 144 means %d\n", 176*144+(176*144)/2);
                  D(1) hex_dump((unsigned char*)ptvh->vh.lpData,16);
                  D(1) fill4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\x0e\x64\x40");
                  for(i=0; i<20; i++)
                        set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",i,i);
                  for(i=0; i<20; i++)
                        set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",20-i,i);
                  //for(i=0; i<80; i++)
                  //      set4cc(g_dbg_4cc,g_dbg_bc, (unsigned char*)ptvh->vh.lpData, g_dbg_w, g_dbg_h, "\xa0\x10\xd0",10+i,20+i/2);
                  D(2) DebugBreak();
                }
#endif

                DBGONLY if(IsBadReadPtr(ptvh->p32Buff, ptvh->vh.dwBytesUsed)) {
                DBGONLY    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: GrabFrame returned garbled buffer: %p (size: %ld)", _fx_,ptvh->p32Buff, ptvh->vh.dwBytesUsed));
                DBGONLY    if(debug_streaming_flag & DEBUG_STREAMING_BRK) DebugBreak();
                DBGONLY    break;
                DBGONLY }
            }

            if (fPreview && dwPreviewWaitTime == dwWaitTime)
            {
                // This is a preview frame
                dwPreviewTime = dwTime;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) wsprintf(szDebug, "Delta P: %ld ms\n", dwPreviewTime - dwLastPreviewTime);
#endif
                dwLastPreviewTime = dwPreviewTime;

                // Deliver the sample downstream
                if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                {
                    pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pPreviewPin->SendFrame(pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        pPSample->Release(), pPSample = NULL;
                        break;
                    }
                }
                bDiscon = FALSE;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) OutputDebugString(szDebug);
#endif
                // Compute statistics
                dwNumPreviewFramesDelivered++;
                dwNumPreviewBytesDelivered += dwBytesUsed;
                // dwCaptureTime = timeGetTime();
                if (dwNumPreviewFramesDelivered && ((dwPreviewTime - dwLastRefPreviewTime) > 1000))
                {
                    m_pPreviewPin->m_lCurrentAvgTimePerFrame = (dwPreviewTime - dwLastRefPreviewTime) * 10000 / dwNumPreviewFramesDelivered;
                    m_pPreviewPin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumPreviewBytesDelivered * 8000 / ((REFERENCE_TIME)(dwPreviewTime - dwLastRefPreviewTime)));
                    dwNumPreviewFramesDelivered = 0;
                    dwNumPreviewBytesDelivered = 0;
                    dwLastRefPreviewTime = dwPreviewTime;
                }

                // Do I need to send a capture frame too?
                dwCaptureTime = timeGetTime();

                // Do we have a use for this frame on the capture pin?
                if (!m_pCapturePin->IsConnected() || (dwCaptureTime - dwLastCaptureTime + (DWORD)(DeviceAvgTimePerFrame / 10000) < (DWORD)(m_pCapturePin->m_lMaxAvgTimePerFrame / 10000)))
                    fCapture = FALSE;
                else
                    fCapture = TRUE;

                if (fCapture)
                {
                    if ((dwCaptureTime < (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000UL)) && (dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime < DeviceAvgTimePerFrame / 10000))
                        dwCaptureWaitTime = dwLastCaptureTime + (DWORD)m_pCapturePin->m_lMaxAvgTimePerFrame / 10000 - dwCaptureTime;
                    else
                        dwCaptureWaitTime = 0;

                    // Sleep until it is time to deliver a frame on capture pin
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) {
                    wsprintf(szDebug, "Waiting %d ms...", dwCaptureWaitTime);
                    OutputDebugString(szDebug);
                    }
#endif
                    if ((dwCaptureWaitTime > 1) && (timeSetEvent(dwCaptureWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                    {
                        m_EventAdvise.Wait();
                        dwCaptureTime = timeGetTime();
                    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(" done!\n");

                    D(8) wsprintf(szDebug, "Delta C: %ld ms\n", dwCaptureTime - dwLastCaptureTime);
#endif
                    dwLastCaptureTime = dwCaptureTime;

                    // Deliver the video sample downstream
                    if (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]])
                        pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrame(pCSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        break;
                    }

                    // Deliver the Rtp Pd sample downstream
                    if (Hr == S_OK && m_pRtpPdPin->IsConnected())
                    {
                        if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]])
                            pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                        // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                        if (FAILED(Hr = m_pRtpPdPin->SendFrame(pCSample, pRSample, dwBytesExtent, bDiscon)))
                        {
                            // So the next time we enter this function we're ready to continue
                            if (++m_uiQueueTail >= m_cs.nHeaders)
                                m_uiQueueTail = 0;
                            if (pCSample)
                                pCSample->Release(), pCSample = NULL;
                            if (pRSample)
                                pRSample->Release(), pRSample = NULL;
                            break;
                        }
                    }

                    bDiscon = FALSE;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(szDebug);
#endif
                    // Compute statistics
                    dwNumCaptureFramesDelivered++;
                    dwNumCaptureBytesDelivered += dwBytesUsed;
                    // dwCaptureTime = timeGetTime();
                    if (dwNumCaptureFramesDelivered && ((dwCaptureTime - dwLastRefCaptureTime) > 1000))
                    {
                        m_pCapturePin->m_lCurrentAvgTimePerFrame = (dwCaptureTime - dwLastRefCaptureTime) * 10000 / dwNumCaptureFramesDelivered;
                        m_pCapturePin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumCaptureBytesDelivered * 8000 / ((REFERENCE_TIME)(dwCaptureTime - dwLastRefCaptureTime)));
                        dwNumCaptureFramesDelivered = 0;
                        dwNumCaptureBytesDelivered = 0;
                        dwLastRefCaptureTime = dwCaptureTime;
                    }

                    // Now we're all done with this sample
                    if (pCSample)
                        pCSample->Release(), pCSample = NULL;
                    if (pRSample)
                        pRSample->Release(), pRSample = NULL;
                }

                // Please don't increment m_uiQueueTail until after the SendFrame
                // and FakePreview
                if (++m_uiQueueTail >= m_cs.nHeaders)
                    m_uiQueueTail = 0;
                //** ASSERT( m_uiQueueTail != m_uiQueueHead );

                // Now we're all done with this sample
                if (pPSample)
                    pPSample->Release(), pPSample = NULL;
            }
            else
            {
                // This is a capture frame
                dwCaptureTime = dwTime;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) wsprintf(szDebug, "Delta C: %ld ms\n", dwCaptureTime - dwLastCaptureTime);
#endif
                dwLastCaptureTime = dwCaptureTime;

                // Deliver the video sample downstream
                if (pCSample = (CFrameSample *)m_cs.paCaptureSamples[m_pBufferQueue[m_uiQueueTail]])
                    pCSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                if (m_fPreviewCompressedData && m_pPreviewPin->IsConnected())
                {
                    // We'll also deliver a sample on the preview pin
                    if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                        pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                    D(8) if(!(ptvh->vh.dwBytesUsed>0)) dprintf("Before SendFrames: ptvh->vh.dwBytesUsed=%lu\n",ptvh->vh.dwBytesUsed);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrames(pCSample, pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        break;
                    }
                }
                else
                {
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pCapturePin->SendFrame(pCSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        break;
                    }
                }

                // Deliver the Rtp Pd sample downstream, only if the video packet was also sent downstream
                if (Hr == S_OK && m_pRtpPdPin->IsConnected())
                {
                    if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[m_pBufferQueue[m_uiQueueTail]])
                        pRSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);

                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pRtpPdPin->SendFrame(pCSample, pRSample, dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pCSample)
                            pCSample->Release(), pCSample = NULL;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        if (pRSample)
                            pRSample->Release(), pRSample = NULL;
                        break;
                    }
                }

                bDiscon = FALSE;

#if defined(DEBUG) && defined(DEBUG_STREAMING)
                D(8) OutputDebugString(szDebug);
#endif
                // Compute statistics
                dwNumCaptureFramesDelivered++;
                dwNumCaptureBytesDelivered += dwBytesUsed;
                // dwCaptureTime = timeGetTime();
                if (dwNumCaptureFramesDelivered && ((dwCaptureTime - dwLastRefCaptureTime) > 1000))
                {
                    m_pCapturePin->m_lCurrentAvgTimePerFrame = (dwCaptureTime - dwLastRefCaptureTime) * 10000 / dwNumCaptureFramesDelivered;
                    if (m_fPreviewCompressedData)
                        m_pPreviewPin->m_lCurrentAvgTimePerFrame = m_pCapturePin->m_lCurrentAvgTimePerFrame;
                    m_pCapturePin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumCaptureBytesDelivered * 8000 / ((REFERENCE_TIME)(dwCaptureTime - dwLastRefCaptureTime)));
                    dwNumCaptureFramesDelivered = 0;
                    dwNumCaptureBytesDelivered = 0;
                    dwLastRefCaptureTime = dwCaptureTime;
                }

                // Do I need to send a preview frame too?
                dwPreviewTime = timeGetTime();

                // Do we have a use for this frame on the capture pin?
                if (m_fPreviewCompressedData || !m_pPreviewPin->IsConnected() || (dwPreviewTime - dwLastPreviewTime + (DWORD)(DeviceAvgTimePerFrame / 10000) < (DWORD)(m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000)))
                    fPreview = FALSE;
                else
                    fPreview = TRUE;

                if (fPreview)
                {
                    if ((dwPreviewTime < (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000UL)) && (dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime < DeviceAvgTimePerFrame / 10000))
                        dwPreviewWaitTime = dwLastPreviewTime + (DWORD)m_pPreviewPin->m_lMaxAvgTimePerFrame / 10000 - dwPreviewTime;
                    else
                        dwPreviewWaitTime = 0;

                    // Sleep until it is time to deliver a frame on preview pin
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) {
                    wsprintf(szDebug, "Waiting %d ms...", dwPreviewWaitTime);
                    OutputDebugString(szDebug);
                    }
#endif
                    if ((dwPreviewWaitTime > 1) && (timeSetEvent(dwPreviewWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                    {
                        m_EventAdvise.Wait();
                        dwPreviewTime = timeGetTime();
                    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(" done!\n");

                    D(8) wsprintf(szDebug, "Delta P: %ld ms\n", dwPreviewTime - dwLastPreviewTime);
#endif
                    dwLastPreviewTime = dwPreviewTime;

                    // Deliver the sample downstream
                    if (pPSample = (CFrameSample *)m_cs.paPreviewSamples[m_pBufferQueue[m_uiQueueTail]])
                        pPSample->AddRef(), InterlockedIncrement(&m_cs.paHdr[m_pBufferQueue[m_uiQueueTail]].lLock);
                    // Deliver inside SendFrame failed or returned S_FALSE.  Stop capture.
                    if (FAILED(Hr = m_pPreviewPin->SendFrame(pPSample, (PBYTE)ptvh->p32Buff, ptvh->vh.dwBytesUsed, &dwBytesUsed, &dwBytesExtent, bDiscon)))
                    {
                        // So the next time we enter this function we're ready to continue
                        if (++m_uiQueueTail >= m_cs.nHeaders)
                            m_uiQueueTail = 0;
                        if (pPSample)
                            pPSample->Release(), pPSample = NULL;
                        break;
                    }

                    bDiscon = FALSE;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                    D(8) OutputDebugString(szDebug);
#endif
                    // Compute statistics
                    dwNumPreviewFramesDelivered++;
                    dwNumPreviewBytesDelivered += dwBytesUsed;
                    // dwCaptureTime = timeGetTime();
                    if (dwNumPreviewFramesDelivered && ((dwPreviewTime - dwLastRefPreviewTime) > 1000))
                    {
                        m_pPreviewPin->m_lCurrentAvgTimePerFrame = (dwPreviewTime - dwLastRefPreviewTime) * 10000 / dwNumPreviewFramesDelivered;
                        m_pPreviewPin->m_lCurrentBitrate = (DWORD)((LONGLONG)dwNumPreviewBytesDelivered * 8000 / ((REFERENCE_TIME)(dwPreviewTime - dwLastRefPreviewTime)));
                        dwNumPreviewFramesDelivered = 0;
                        dwNumPreviewBytesDelivered = 0;
                        dwLastRefPreviewTime = dwPreviewTime;
                    }

                    // Now we're all done with this sample
                    if (pPSample)
                        pPSample->Release(), pPSample = NULL;
                }

                // Please don't increment m_uiQueueTail until after the SendFrame
                // and FakePreview
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                //ASSERT( m_uiQueueTail != m_uiQueueHead );
                if(m_uiQueueTail != m_uiQueueHead) {
                    wsprintf(szDebug, "m_uiQueueTail -> %d : %d <- m_uiQueueHead", m_uiQueueTail , m_uiQueueHead);
                    OutputDebugString(szDebug);
                }
#endif
                if (++m_uiQueueTail >= m_cs.nHeaders)
                    m_uiQueueTail = 0;

                // Now we're all done with this sample
                if (pCSample)
                    pCSample->Release(), pCSample = NULL;
                if (m_fPreviewCompressedData && pPSample)
                    pPSample->Release(), pPSample = NULL;
                if (pRSample)
                    pRSample->Release(), pRSample = NULL;
            }
        }
    }

    // The main thread will stop the capture because this thread probably hung
    // in Deliver going from run->pause and will never get to this line!
    // (The video renderer will hold samples in Receive in pause mode)
    // videoStreamStop (m_cs.hVideoIn);
    SetThreadPriority (GetCurrentThread(), dwOldPrio);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc DWORD | CTAPIVCap | Prepare | This method is used to allocate
 *    resources in preparation for capture loop.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::Prepare()
{
    HRESULT Hr = NOERROR;
    LPBYTE pbyCompressedBuffer, pbyRtpPdBuffer;
    DWORD i, j;
    DWORD cbCaptureBuffer, cbPreviewBuffer;
    DWORD cbPrefix, cbAlign;

    FX_ENTRY("CTAPIVCap::Prepare");


#ifdef XTRA_TRACE
    char strMutexName[80];
    wsprintf(strMutexName, TEXT("%dCTAPIVCap"), _getpid());

    h_mut1 = CreateMutex(NULL,FALSE,strMutexName);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Enabling Xtra Tracing", _fx_));
    QueryPerformanceFrequency(&g_liFreq);
        MyTraceId=TraceRegisterEx("TRAX",TRACE_USE_FILE);
        if(MyTraceId==0) {
                OutputDebugString("Failed to enable Xtra Tracing ... \n");
                }

#endif


    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    m_cs.paHdr = NULL;
    m_cs.hEvtBufferDone = NULL;
    m_cs.h0EvtBufferDone = 0;
    m_cs.llLastTick = (LONGLONG)-1;
    m_cs.uiLastAdded = (UINT)-1;
    // m_cs.dwFirstFrameOffset = 0;
    m_cs.llFrameCountOffset = 0;
    m_cs.fReRun = FALSE;
    m_cs.rtDriverLatency = -1;
    m_cs.cbVidHdr = sizeof(VIDEOHDR);

    // Can't do anything if no videoformat has been chosen
    if (!m_user.pvi)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: No video format chosen yet!", _fx_));
        Hr = E_FAIL;
        goto MyError;
    }

    // Set default number of capture buffers. We may adjust this below
    // if a pin wants to ship the video capture buffers downstream
    m_cs.nHeaders = m_user.nMaxBuffers;

    // Set default size. Again, if some pin wants to deliver a video
    // capture buffer downstream, this may be adjusted to match the
    // pin's allocator requirements regarding buffer alignment for instance
    m_cs.cbBuffer = m_user.pvi->bmiHeader.biSizeImage;


    if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        // Create the VfW streaming capture event (**cristi: WDM capture event ?)
        if (!(m_cs.hEvtBufferDone = CreateEvent (NULL, FALSE, FALSE, NULL)))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to create buffer done event!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }

        if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW)
        {
            if (!g_IsNT)
            {
                // Map this event
                if (!(m_cs.h0EvtBufferDone = OpenVxDHandle(m_cs.hEvtBufferDone)))
                {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to create event's Ring 0 handle!", _fx_));
                    Hr = E_FAIL;
                    goto MyError;
                }
            }
            else
            {
                m_cs.h0EvtBufferDone = (DWORD_PTR)m_cs.hEvtBufferDone;
            }
        }
    }

    cbPrefix = cbAlign = 0;
    m_cs.cCaptureSamples = m_cs.cPreviewSamples = 0;

    if (m_pCapturePin->IsConnected())
    {
        //dprintf("m_user.pvi->bmiHeader.biSizeImage = %x <= %x (DWORD)m_pCapturePin->m_parms.cbBuffer\n",m_user.pvi->bmiHeader.biSizeImage,m_pCapturePin->m_parms.cbBuffer);
        if (m_cs.fCaptureNeedConverter =   HEADER(m_user.pvi)->biCompression != HEADER(m_pCapturePin->m_mt.pbFormat)->biCompression
                                        || HEADER(m_user.pvi)->biWidth       != HEADER(m_pCapturePin->m_mt.pbFormat)->biWidth
                                        || HEADER(m_user.pvi)->biHeight      != HEADER(m_pCapturePin->m_mt.pbFormat)->biHeight)
        {
            // For each compressed buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbCaptureBuffer = m_pCapturePin->m_parms.cbPrefix + m_pCapturePin->m_parms.cbAlign + m_pCapturePin->m_parms.cbBuffer;
            ASSERT(HEADER(m_pCapturePin->m_mt.pbFormat)->biSizeImage <= (DWORD)m_pCapturePin->m_parms.cbBuffer);
            m_cs.cCaptureSamples = m_pCapturePin->m_parms.cBuffers;
        }
        else
        {
            // This pin will ship the video capture buffers downstream.
            // For each buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPrefix = m_pCapturePin->m_parms.cbPrefix;
            cbAlign = m_pCapturePin->m_parms.cbAlign;
            m_cs.cbBuffer = cbCaptureBuffer = max(m_cs.cbBuffer, cbPrefix + cbAlign + m_pCapturePin->m_parms.cbBuffer);
            ASSERT(m_user.pvi->bmiHeader.biSizeImage <= (DWORD)m_pCapturePin->m_parms.cbBuffer);

            // Try to get the requested number of buffers, but make sure
            // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
            m_cs.nHeaders = max((DWORD)m_pCapturePin->m_parms.cBuffers, m_user.nMinBuffers);
            m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);
            m_cs.cCaptureSamples = m_cs.nHeaders;
        }
    }

    if (m_pPreviewPin->IsConnected())
    {
        //dprintf("m_user.pvi->bmiHeader.biSizeImage = %x <= %x (DWORD)m_pPreviewPin->m_parms.cbBuffer\n",m_user.pvi->bmiHeader.biSizeImage,m_pPreviewPin->m_parms.cbBuffer);
        m_cs.fPreviewNeedConverter = FALSE;

        if (m_fPreviewCompressedData ||
                (m_cs.fPreviewNeedConverter =   (HEADER(m_user.pvi)->biCompression != HEADER(m_pPreviewPin->m_mt.pbFormat)->biCompression
                                              || HEADER(m_user.pvi)->biBitCount    != HEADER(m_pPreviewPin->m_mt.pbFormat)->biBitCount
                                              || HEADER(m_user.pvi)->biWidth       != HEADER(m_pPreviewPin->m_mt.pbFormat)->biWidth
                                              || HEADER(m_user.pvi)->biHeight      != HEADER(m_pPreviewPin->m_mt.pbFormat)->biHeight)
                ))
        {
            // Hey! You can only preview compressed data if you have connected the capture pin...
            ASSERT(!m_fPreviewCompressedData || (m_fPreviewCompressedData && m_pCapturePin->IsConnected()));

            // For each compressed buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPreviewBuffer = m_pPreviewPin->m_parms.cbPrefix + m_pPreviewPin->m_parms.cbAlign + m_pPreviewPin->m_parms.cbBuffer;
            ASSERT(HEADER(m_pPreviewPin->m_mt.pbFormat)->biSizeImage <= (DWORD)m_pPreviewPin->m_parms.cbBuffer);
            m_cs.cPreviewSamples = m_pPreviewPin->m_parms.cBuffers;
        }
        else
        {
            // This pin will ship the video capture buffers downstream.
            // For each buffer, allocate the user requested size
            // Also, align allocation size up to nearest align boundary
            cbPrefix = max(cbPrefix, (DWORD)m_pPreviewPin->m_parms.cbPrefix);
            cbAlign = max(cbAlign, (DWORD)m_pPreviewPin->m_parms.cbAlign);
            m_cs.cbBuffer = max(m_cs.cbBuffer, (DWORD)(cbPrefix + cbAlign + m_pPreviewPin->m_parms.cbBuffer));
            ASSERT(m_user.pvi->bmiHeader.biSizeImage <= (DWORD)m_pPreviewPin->m_parms.cbBuffer);

            // Try to get the requested number of buffers, but make sure
            // to get at least MIN_VIDEO_BUFFERS and no more than MAX_VIDEO_BUFFERS
            m_cs.nHeaders = max((DWORD)m_pPreviewPin->m_parms.cBuffers, m_user.nMinBuffers);
            m_cs.nHeaders = min(m_cs.nHeaders, m_user.nMaxBuffers);
            m_cs.cPreviewSamples = m_cs.nHeaders;
        }
    }

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   We are trying to get %d compressed/capture buffers", _fx_, m_cs.nHeaders));

    // Allocate headers for all of the buffers that we will be using


    //if (FAILED(m_pCapDev->AllocateHeaders(m_cs.nHeaders, sizeof(THKVIDEOHDR) + sizeof(DWORD), (LPVOID *)&m_cs.paHdr)))
    if (FAILED(m_pCapDev->AllocateHeaders(m_cs.nHeaders, sizeof(struct CTAPIVCap::_cap_parms::_cap_hdr), (LPVOID *)&m_cs.paHdr)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAllocHeaders failed!", _fx_));
        Hr = E_OUTOFMEMORY;
        goto MyError;
    }

    // Allocate each buffer, if buffer allocation ever fails
    // just set the number of buffers to the number of successes
    // and continue on.
    for (i = 0; i < m_cs.nHeaders; ++i)
    {
        LPTHKVIDEOHDR ptvh;

        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_FrameGrabbing)
        {
            ptvh = &m_cs.paHdr[i].tvh;
        }

        if (FAILED(m_pCapDev->AllocateBuffer((LPTHKVIDEOHDR *)&ptvh, i, m_cs.cbBuffer)))
            break; //it was goto MyExit; (cristiai; see bug 186119)

        ASSERT (ptvh == &m_cs.paHdr[i].tvh);

        dprintf("Align buffer %d; before %p\n",i,ptvh->vh.lpData);
        // Fix the memory we got to obey alignment
        ptvh->vh.lpData = cbAlign ? (LPBYTE)ALIGNUP(ptvh->p32Buff, cbAlign) + cbPrefix : (LPBYTE)ptvh->p32Buff + cbPrefix;
        dprintf("                after  %p\n",ptvh->vh.lpData);
        dprintf("                length: ptvh->vh.dwBufferLength %d ( m_cs.cbBuffer = %d ) \n",ptvh->vh.dwBufferLength,m_cs.cbBuffer);
        // We added cbAlign up top, so take it back now
        ptvh->vh.dwBufferLength = m_cs.cbBuffer - cbAlign - cbPrefix;
        dprintf("                length: [adjusted]              %d\n",ptvh->vh.dwBufferLength);
        ptvh->vh.dwBytesUsed = ptvh->vh.dwTimeCaptured = 0;
        // Which buffer is this?
        ptvh->dwIndex = i;

        ASSERT (!IsBadWritePtr(ptvh->vh.lpData, ptvh->vh.dwBufferLength));

        dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   Alloc'd: ptvh %08lX, buffer %08lX, size %d, p32 %08lX, p16 %08lX", _fx_, ptvh, ptvh->vh.lpData, ptvh->vh.dwBufferLength, ptvh->p32Buff, ptvh->p16Alloc);
    }


    // Now allocate the capture pin media samples
    if (m_cs.cCaptureSamples)
    {
        if (!(m_cs.paCaptureSamples = (CFrameSample **) new BYTE[sizeof(CFrameSample *) * m_cs.cCaptureSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paCaptureSamples, sizeof(CFrameSample *) * m_cs.cCaptureSamples);
        //dprintf("m_cs.cCaptureSamples = %d in m_cs.paCaptureSamples @ %p\n",m_cs.cCaptureSamples, m_cs.paCaptureSamples);
        //dprintf("m_cs.fCaptureNeedConverter = %d\n",m_cs.fCaptureNeedConverter);
        for (j = 0; j < m_cs.cCaptureSamples; j++)
        {
            if (m_pCapturePin->IsConnected())
            {
                if (m_cs.fCaptureNeedConverter)
                {
                    // Allocate compressed header
                    // @todo Do some real error handling here
                    if (!(pbyCompressedBuffer = new BYTE[cbCaptureBuffer]))
                        break;
                    dprintf("Capture sample %-4d :                             @ %p\n",j,pbyCompressedBuffer);

                    // Fix the memory we got to obey alignment
                    if (m_pCapturePin->m_parms.cbAlign) {
                        pbyCompressedBuffer = (LPBYTE) ALIGNUP(pbyCompressedBuffer, m_pCapturePin->m_parms.cbAlign) + m_pCapturePin->m_parms.cbPrefix;
                        dprintf("ALIGNUP: m_pCapturePin->m_parms.cbAlign = %4x .... %p\n",m_pCapturePin->m_parms.cbAlign,pbyCompressedBuffer);
                    }

                    // We added cbAlign up top, so take it back now
                    // @todo Before you can do the following you need to decouple the samples
                    // from the capture buffers. This means using two different queues: one for
                    // the capture samples, and one for the capture buffers. This will also allow
                    // for a much smaller number of samples than capture buffers.
                    m_cs.paCaptureSamples[j] = (CFrameSample *)new CFrameSample(static_cast<IMemAllocator*>(m_pCapturePin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyCompressedBuffer,cbCaptureBuffer - m_pCapturePin->m_parms.cbAlign - m_pCapturePin->m_parms.cbPrefix);
                    //dprintf("m_cs.paCaptureSamples[%d] @ %p (len = %d , m_pCapturePin->m_parms. : cbAlign = %x, cbPrefix = %x)\n",j,m_cs.paCaptureSamples[j],cbCaptureBuffer - m_pCapturePin->m_parms.cbAlign - m_pCapturePin->m_parms.cbPrefix,m_pCapturePin->m_parms.cbAlign , m_pCapturePin->m_parms.cbPrefix);
                }
                else
                {
                    m_cs.paCaptureSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pCapturePin),
                        &Hr, &m_cs.paHdr[j].tvh, m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength);
                }
            }
        }
    }

    // Now allocate the Rtp Pd pin media samples
    if (m_pCapturePin->IsConnected() && m_pRtpPdPin->IsConnected() && m_cs.cCaptureSamples && m_pRtpPdPin->m_parms.cBuffers)
    {
        m_cs.cRtpPdSamples = m_pRtpPdPin->m_parms.cBuffers;
        if (!(m_cs.paRtpPdSamples = (CRtpPdSample **) new BYTE[sizeof(CRtpPdSample *) * m_cs.cRtpPdSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paRtpPdSamples, sizeof(CRtpPdSample *) * m_cs.cRtpPdSamples);
        //dprintf("m_cs.cRtpPdSamples = %d in m_cs.paRtpPdSamples @ %p\n",m_cs.cRtpPdSamples, m_cs.paRtpPdSamples);
        for (j = 0; j < m_cs.cRtpPdSamples; j++)
        {
            if (m_pRtpPdPin->IsConnected())
            {
                // Allocate Rtp Pd buffer
                // @todo Do some real error handling here
                if (!(pbyRtpPdBuffer = new BYTE[m_pRtpPdPin->m_parms.cbPrefix + m_pRtpPdPin->m_parms.cbAlign + m_pRtpPdPin->m_parms.cbBuffer]))
                    break;

                // Fix the memory we got to obey alignment
                if (m_pRtpPdPin->m_parms.cbAlign)
                    pbyRtpPdBuffer = (LPBYTE) ALIGNUP(pbyRtpPdBuffer, m_pRtpPdPin->m_parms.cbAlign) + m_pRtpPdPin->m_parms.cbPrefix;

                // We added cbAlign up top, so take it back now
                // @todo Before you can do the following you need to decouple the samples
                // from the capture buffers. This means using two different queues: one for
                // the capture samples, and one for the capture buffers. This will also allow
                // for a much smaller number of samples than capture buffers.
                m_cs.paRtpPdSamples[j] = (CRtpPdSample *)new CRtpPdSample(static_cast<IMemAllocator*>(m_pRtpPdPin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyRtpPdBuffer, m_pRtpPdPin->m_parms.cbBuffer);
            }
        }
    }

    // Now allocate the preview pin media samples
    if (m_cs.cPreviewSamples)
    {
        if (!(m_cs.paPreviewSamples = (CFrameSample **) new BYTE[sizeof(CFrameSample *) * m_cs.cPreviewSamples]))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Allocation failed!", _fx_));
            Hr = E_OUTOFMEMORY;
            goto MyError;
        }
        ZeroMemory(m_cs.paPreviewSamples, sizeof(CFrameSample *) * m_cs.cPreviewSamples);
        //dprintf("m_cs.cPreviewSamples = %d in m_cs.paPreviewSamples @ %p\n",m_cs.cPreviewSamples, m_cs.paPreviewSamples);
        //dprintf("m_fPreviewCompressedData || m_cs.fPreviewNeedConverter = %d\n",m_fPreviewCompressedData || m_cs.fPreviewNeedConverter);
        for (j = 0; j < m_cs.cPreviewSamples; j++)
        {
            if (m_pPreviewPin->IsConnected())
            {
                if (m_fPreviewCompressedData || m_cs.fPreviewNeedConverter)
                {
                    // Allocate compressed header
                    // @todo Do some real error handling here
                    if (!(pbyCompressedBuffer = new BYTE[cbPreviewBuffer]))
                        break;
                    dprintf("Preview sample %-4d :                             @ %p\n",j,pbyCompressedBuffer);

                    // Fix the memory we got to obey alignment
                    if (m_pPreviewPin->m_parms.cbAlign) {
                        pbyCompressedBuffer = (LPBYTE) ALIGNUP(pbyCompressedBuffer, m_pPreviewPin->m_parms.cbAlign) + m_pPreviewPin->m_parms.cbPrefix;
                        dprintf("ALIGNUP: m_pPreviewPin->m_parms.cbAlign = %4x .... %p\n",m_pPreviewPin->m_parms.cbAlign,pbyCompressedBuffer);
                    }

                    // We added cbAlign up top, so take it back now
                    // @todo Before you can do the following you need to decouple the samples
                    // from the capture buffers. This means using two different queues: one for
                    // the preview samples, and one for the capture buffers. This will also allow
                    // for a much smaller number of samples than capture buffers.
                    m_cs.paPreviewSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pPreviewPin),
                        &Hr, &m_cs.paHdr[j].tvh, pbyCompressedBuffer, cbPreviewBuffer - m_pPreviewPin->m_parms.cbAlign - m_pPreviewPin->m_parms.cbPrefix);
                    //dprintf("m_cs.paPreviewSamples[%d] @ %p (len = %d , m_pPreviewPin->m_parms. : cbAlign = %x, cbPrefix = %x)\n",j,m_cs.paPreviewSamples[j],cbPreviewBuffer - m_pPreviewPin->m_parms.cbAlign - m_pPreviewPin->m_parms.cbPrefix,m_pPreviewPin->m_parms.cbAlign , m_pPreviewPin->m_parms.cbPrefix);
                }
                else
                {
                    m_cs.paPreviewSamples[j] = new CFrameSample(static_cast<IMemAllocator*>(m_pPreviewPin),
                        &Hr, &m_cs.paHdr[j].tvh, m_cs.paHdr[j].tvh.vh.lpData, m_cs.paHdr[j].tvh.vh.dwBufferLength);
                }
            }
        }
    }

    D(0x10) DebugBreak();

    // Update total number of buffers succesfully allocated
    m_cs.nHeaders = i;

    // This is where we will remember in what order we gave the buffers to the driver
    m_pBufferQueue = (UINT *)QzTaskMemAlloc(i * sizeof(UINT));

    if (m_cs.nHeaders < m_user.nMinBuffers)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: We only allocated %d buffer(s) which is less than MIN_VIDEO_BUFFERS", _fx_, m_cs.nHeaders));
        Hr = E_FAIL;
        goto MyError;
    }

    // Calculate the requested microsec per frame
    // RefTime is in 100ns units, so we divide by
    // 10 to get microsec/frame. (the +5 is to handle rounding)
    {
        m_user.usPerFrame = (DWORD) ((TickToRefTime(1) + 5) / 10);
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Using m_dwDeviceIndex %d", _fx_, m_dwDeviceIndex));
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            // Open the driver for streaming access
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Initializing driver at %d usPerFrame", _fx_, m_user.usPerFrame));

            HRESULT hres;
            hres=m_pCapDev->InitializeStreaming(m_user.usPerFrame,
                        m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW ? m_cs.h0EvtBufferDone : (DWORD_PTR)m_cs.hEvtBufferDone);
            if (FAILED(hres))
            {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: videoStreamInit failed", _fx_));
                Hr = E_FAIL;
                goto MyError;
            }
        }
    }

    if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_VfW && m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        // Send the buffers to the driver
        for (i = 0; i < m_cs.nHeaders; ++i)
        {
            ASSERT (m_cs.cbVidHdr >= sizeof(VIDEOHDR));

            // vidxAddBuffer can fail if there is not enough memory to
            // prepare (lock down) the buffer. This is ok, we will just
            // make due with the buffers that we have
            if (FAILED(m_pCapDev->AddBuffer(&m_cs.paHdr[i].tvh.vh, m_cs.cbVidHdr)))
            {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAddBuffer failed", _fx_));
                Hr = E_FAIL;
                goto MyError;
            }
        }
    }

    // To start with, we gave the buffers to the driver in numerical order.
    // From now on, we will use this list to know what buffer to wait for
    // next, and when we send another buffer to the driver.  We can't assume
    // they'll always be in the same order.  What if a downstream filter
    // decides to hold on to a sample longer than the next one we send it?
    UINT kk;
    for (kk = 0; kk < m_cs.nHeaders; kk++)
        m_pBufferQueue[kk] = kk;
    m_uiQueueHead = 0;
    m_uiQueueTail = 0;

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   We are capturing with %d buffers", _fx_, m_cs.nHeaders));

    if (m_pCapturePin->IsConnected() && m_cs.fCaptureNeedConverter && FAILED(Hr = m_pCapturePin->OpenConverter(HEADER(m_user.pvi), HEADER(m_pCapturePin->m_mt.pbFormat))))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't open convertor!", _fx_));
    }
    else if (m_pPreviewPin->IsConnected() && m_cs.fPreviewNeedConverter && FAILED(Hr = m_pPreviewPin->OpenConverter(HEADER(m_user.pvi), HEADER(m_pPreviewPin->m_mt.pbFormat))))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't open convertor!", _fx_));
    }

    // if we have 0 buffers to capture into DO NOT BAIL... bad things seem to
    // happen if you fail a Pause transition, and we start hanging later
    goto MyExit;

MyError:
    Unprepare();
MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc DWORD | CTAPIVCap | Unprepare | This method is used to
 *    free resources used by the capture loop.
 *
 *  @rdesc This method returns NOERROR
 ***************************************************************************/
HRESULT CTAPIVCap::Unprepare()
{
    CFrameSample *pSample;
    CRtpPdSample *pRSample;
    LPBYTE lp;
    DWORD i,j;

        INIT_TICKS;

    FX_ENTRY("CTAPIVCap::Unprepare")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    ASSERT(m_pCapturePin);
    ASSERT(m_pPreviewPin);
    ASSERT(m_pRtpPdPin);
    ASSERT(m_pCapDev);

    // Free all of the capture samples
    if (m_cs.cCaptureSamples && m_cs.paCaptureSamples)
    {
        for (j = 0; j < m_cs.cCaptureSamples; j++)
        {
            if (pSample = (CFrameSample *)m_cs.paCaptureSamples[j])
            {
                // Free the conversion buffers if necessary
                if (m_cs.fCaptureNeedConverter)
                {
                    lp = NULL;
                    if (SUCCEEDED(pSample->GetPointer(&lp)))
                    {
                        dprintf("%s : GetPointer on m_cs.paCaptureSamples[%d] : %p\n",_fx_,j,lp);
                        if (lp)
                            delete[] lp;
                    }
                }
                LOG_MSG_VAL("delCsamples:cRef,pSample,this",pSample->m_cRef,(DWORD)pSample,(DWORD)this);
                ASSERT(pSample->m_cRef==0 || pSample->m_cRef==1);
                delete pSample, m_cs.paCaptureSamples[j] = NULL;
            }
        }

        delete[] m_cs.paCaptureSamples, m_cs.paCaptureSamples = NULL;
    }

    // Free all of the Rtp Pd samples
    if (m_cs.cRtpPdSamples && m_cs.paRtpPdSamples)
    {
        for (j = 0; j < m_cs.cRtpPdSamples; j++)
        {
            if (pRSample = (CRtpPdSample *)m_cs.paRtpPdSamples[j])
            {
                lp = NULL;
                if (SUCCEEDED(pRSample->GetPointer(&lp)))
                {
                    if (lp)
                        delete[] lp;
                }
                LOG_MSG_VAL("delRsamples:cRef,pRSample,this",pRSample->m_cRef,(DWORD)pRSample,(DWORD)this);
                ASSERT(pRSample->m_cRef==0 || pRSample->m_cRef==1);
                delete pRSample, m_cs.paRtpPdSamples[j] = NULL;
            }
        }

        delete[] m_cs.paRtpPdSamples, m_cs.paRtpPdSamples = NULL;
    }

    // Free all of the preview samples
    if (m_cs.cPreviewSamples && m_cs.paPreviewSamples)
    {
        for (j = 0; j < m_cs.cPreviewSamples; j++)
        {
            if (pSample = (CFrameSample *)m_cs.paPreviewSamples[j])
            {
                // Free the conversion buffers if necessary
                if (m_fPreviewCompressedData || m_cs.fPreviewNeedConverter)
                {
                    lp = NULL;
                    if (SUCCEEDED(pSample->GetPointer(&lp)))
                    {
                        dprintf("%s : GetPointer on m_cs.paPreviewSamples[%d] : %p\n",_fx_,j,lp);
                        if (lp)
                            delete[] lp;
                    }
                }
                LOG_MSG_VAL("delPsamples:cRef,pSample,this",pSample->m_cRef,(DWORD)pSample,(DWORD)this);
                ASSERT(pSample->m_cRef==0 || pSample->m_cRef==1);
                delete pSample, m_cs.paPreviewSamples[j] = NULL;
            }
        }

        delete[] m_cs.paPreviewSamples, m_cs.paPreviewSamples = NULL;
    }

        HEAPCHK("before Term.Str.");
        BEGIN_TICK;

    if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
    {
        if(FAILED(m_pCapDev->TerminateStreaming()))
                {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: TerminateStreaming failed", _fx_));
                }
    }
        HEAPCHK("after Term.Str.");
        MARK_LOG_TICK("after TerminateStr");


    if(m_cs.paHdr!=NULL) {
        // Free all of the capture buffers
        for (j = 0; j < m_cs.nHeaders; j++)
        {
            #ifdef XTRA_TRACE
            if(m_pCapDev->m_vcdi.nDeviceType == DeviceType_WDM)
                    FillPattern((char*)m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength,0,"Free%3d:%08x (%x)",j,m_cs.paHdr[j].tvh.vh.lpData,m_cs.paHdr[j].tvh.vh.dwBufferLength);
            #endif //XTRA_TRACE
            m_pCapDev->FreeBuffer(&m_cs.paHdr[j].tvh); // previously was .tvh.vh
        }

            HEAPCHK("after freeBufs");
            MARK_LOG_TICK("after freeBufs");
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming)
        {
            //m_pCapDev->TerminateStreaming();
            if (m_pCapDev->m_vcdi.nDeviceType == DeviceType_WDM)
                delete[] m_cs.paHdr;
        }
        else
        {
            delete[] m_cs.paHdr;
        }
        m_cs.paHdr = NULL;
    }

        HEAPCHK("after delete paHdr");
        MARK_LOG_TICK("after delete paHdr");
    if (m_pBufferQueue)
        QzTaskMemFree(m_pBufferQueue), m_pBufferQueue = NULL;

    if (m_cs.hEvtBufferDone)
        CloseHandle (m_cs.hEvtBufferDone), m_cs.hEvtBufferDone = NULL;

    if (m_pCapturePin->IsConnected())
    {
        if (m_cs.fCaptureNeedConverter)
            m_pCapturePin->CloseConverter();
#ifdef USE_SOFTWARE_CAMERA_CONTROL
        if (m_pCapturePin->IsSoftCamCtrlOpen())
            m_pCapturePin->CloseSoftCamCtrl();
#endif
    }

    if (m_pPreviewPin->IsConnected())
    {
        if (m_cs.fPreviewNeedConverter)
            m_pPreviewPin->CloseConverter();
#ifdef USE_SOFTWARE_CAMERA_CONTROL
        if (m_pPreviewPin->IsSoftCamCtrlOpen())
            m_pPreviewPin->CloseSoftCamCtrl();
#endif
    }

        END_LOG_TICK("end of Unprepare");
#ifdef XTRA_TRACE
        TraceDeregister(MyTraceId);
        if(h_mut1 != INVALID_HANDLE_VALUE) {
                if(!CloseHandle(h_mut1)) {
                        OutputDebugString("Failed to close mutex handle ... \n");
                        }
                h_mut1 = INVALID_HANDLE_VALUE;
        }
#endif
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | ReleaseFrame | This method is used to
 *    return a buffer to the capture driver.
 *
 *  @parm LPTHKVIDEOHDR | ptvh | ???.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag S_FALSE | If the pin is off (IAMStreamControl)
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::ReleaseFrame(LPTHKVIDEOHDR ptvh)
{
    HRESULT Hr = S_OK;
    LONG l;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    char szDebug[512];
#endif

    FX_ENTRY("CTAPIVCap::ReleaseFrame")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Giving buffer (%d) back to the driver (lLock=%ld)", _fx_, ptvh->dwIndex,m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].lLock));

    if (!(l=InterlockedDecrement(&m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].lLock)))
    {
        #if defined(DEBUG) && defined(DEBUG_STREAMING)
        D(8) dprintf("Giving buffer (%d) back to the driver... [After ILockDecr. lLock = %ld]...", ptvh->dwIndex,l);
        #endif

        ptvh->vh.dwFlags &= ~VHDR_DONE;
        //ASSERT(ptvh->vh.dwBufferLength>0);
        //memset((unsigned char*)ptvh->vh.lpData,0,ptvh->vh.dwBufferLength);
        if (m_pCapDev->m_vcdi.nCaptureMode == CaptureMode_Streaming && m_pCapDev->AddBuffer(&ptvh->vh, m_cs.cbVidHdr))
        {
            #if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) dout(3, g_dwVideoCaptureTraceID, TRCE, "failed!\n");
            #endif
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: vidxAddBuffer failed!", _fx_));
            Hr = E_FAIL;
            goto MyExit;
        }
        else
        {
            #if defined(DEBUG) && defined(DEBUG_STREAMING)
            D(8) dout(3, g_dwVideoCaptureTraceID, TRCE, "succeeded!\n");
            #endif
            TEST_LBUG long l=InterlockedCompareExchange(&m_cs.paHdr[m_pBufferQueue[ptvh->dwIndex]].nUsedDownstream,0,1);
            TEST_LBUG #if defined(DEBUG) && defined(DEBUG_STREAMING)
            TEST_LBUG D(8) dprintf("Initial nUsedDownstream was %ld\n", l);
            TEST_LBUG #endif
            m_pBufferQueue[m_uiQueueHead] = ptvh->dwIndex;
            if (++m_uiQueueHead >= m_cs.nHeaders)
                m_uiQueueHead = 0;
        }

        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   X. m_pBufferQueue[%d] .. m_pBufferQueue[%d] = %d .. %d",_fx_, m_uiQueueTail, m_uiQueueHead, m_pBufferQueue[m_uiQueueTail], m_pBufferQueue[m_uiQueueHead]));

        if (++m_cs.uiLastAdded >= m_cs.nHeaders)
            m_cs.uiLastAdded = 0;

        if (m_cs.uiLastAdded != ptvh->dwIndex)
        {
            DWORD dw = m_cs.uiLastAdded;
            m_cs.uiLastAdded = ptvh->dwIndex;
            // Use dw to keep the above code fairly atomic... debug printf will get prempted
            DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Out of order AddBuffer - %d not %d", _fx_, ptvh->dwIndex, dw));
        }
    }
#if defined(DEBUG) && defined(DEBUG_STREAMING)
    else
    {
        D(8) dprintf("Not Giving buffer (%d) back to the driver yet... [lLock = %ld]\n", ptvh->dwIndex,l);
    }
#endif

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}


#undef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\wdmdlgs.cpp ===
/****************************************************************************
 *  @doc INTERNAL DIALOGS
 *
 *  @module WDMDialg.cpp | Source file for <c CWDMDialog> class used to display
 *    video settings and camera controls dialog for WDM devices.
 *
 *  @comm This code is based on the VfW to WDM mapper code written by
 *    FelixA and E-zu Wu. The original code can be found on
 *    \\redrum\slmro\proj\wdm10\\src\image\vfw\win9x\raytube.
 *
 *    Documentation by George Shaw on kernel streaming can be found in
 *    \\popcorn\razzle1\src\spec\ks\ks.doc.
 *
 *    WDM streaming capture is discussed by Jay Borseth in
 *    \\blues\public\jaybo\WDMVCap.doc.
 ***************************************************************************/

#include "Precomp.h"

// Globals
extern HINSTANCE g_hInst;

// For now, we only expose a video settings and camera control page
#define MAX_PAGES 2

// Video settings (brightness tint hue etc.)
#define NumVideoSettings 8
static PROPSLIDECONTROL g_VideoSettingControls[NumVideoSettings] =
{
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,   IDC_SLIDER_BRIGHTNESS, IDS_BRIGHTNESS, IDC_BRIGHTNESS_STATIC, IDC_TXT_BRIGHTNESS_CURRENT, IDC_CB_AUTO_BRIGHTNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_CONTRAST,     IDC_SLIDER_CONTRAST,   IDS_CONTRAST,   IDC_CONTRAST_STATIC,   IDC_TXT_CONTRAST_CURRENT,   IDC_CB_AUTO_CONTRAST},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_HUE,          IDC_SLIDER_HUE,        IDS_HUE,        IDC_HUE_STATIC,        IDC_TXT_HUE_CURRENT,        IDC_CB_AUTO_HUE},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SATURATION,   IDC_SLIDER_SATURATION, IDS_SATURATION, IDC_SATURATION_STATIC, IDC_TXT_SATURATION_CURRENT, IDC_CB_AUTO_SATURATION},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_SHARPNESS,    IDC_SLIDER_SHARPNESS,  IDS_SHARPNESS,  IDC_SHARPNESS_STATIC,  IDC_TXT_SHARPNESS_CURRENT,  IDC_CB_AUTO_SHARPNESS},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE, IDC_SLIDER_WHITEBAL,   IDS_WHITEBAL,   IDC_WHITE_STATIC,      IDC_TXT_WHITE_CURRENT,      IDC_CB_AUTO_WHITEBAL},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_GAMMA,        IDC_SLIDER_GAMMA,      IDS_GAMMA,      IDC_GAMMA_STATIC,      IDC_TXT_GAMMA_CURRENT,      IDC_CB_AUTO_GAMMA},
    { 0, 0, 0, 0, 0, KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,    IDC_SLIDER_BACKLIGHT,  IDS_BACKLIGHT,  IDC_BACKLIGHT_STATIC,      IDC_TXT_BACKLIGHT_CURRENT,  IDC_CB_AUTO_BACKLIGHT}
};

// Camera control (focus, zoom etc.)
#define NumCameraControls 7
static PROPSLIDECONTROL g_CameraControls[NumCameraControls] =
{
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_FOCUS,   IDC_SLIDER_FOCUS,   IDS_FOCUS,    IDC_FOCUS_STATIC,   IDC_TXT_FOCUS_CURRENT,    IDC_CB_AUTO_FOCUS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ZOOM,    IDC_SLIDER_ZOOM,    IDS_ZOOM,     IDC_ZOOM_STATIC,    IDC_TXT_ZOOM_CURRENT,     IDC_CB_AUTO_ZOOM},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_EXPOSURE,IDC_SLIDER_EXPOSURE,IDS_EXPOSURE, IDC_EXPOSURE_STATIC,IDC_TXT_EXPOSURE_CURRENT, IDC_CB_AUTO_EXPOSURE},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_IRIS,    IDC_SLIDER_IRIS,    IDS_IRIS,     IDC_IRIS_STATIC,    IDC_TXT_IRIS_CURRENT,     IDC_CB_AUTO_IRIS},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_TILT,    IDC_SLIDER_TILT,    IDS_TILT,     IDC_TILT_STATIC,    IDC_TXT_TILT_CURRENT,     IDC_CB_AUTO_TILT},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_PAN,     IDC_SLIDER_PAN,     IDS_PAN,      IDC_PAN_STATIC,     IDC_TXT_PAN_CURRENT,      IDC_CB_AUTO_PAN},
    { 0, 0, 0, 0, 0, KSPROPERTY_CAMERACONTROL_ROLL,    IDC_SLIDER_ROLL,    IDS_ROLL,     IDC_ROLL_STATIC,    IDC_TXT_ROLL_CURRENT,     IDC_CB_AUTO_ROLL},
};

/****************************************************************************
 *  @doc INTERNAL CWDMDLGSMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | HasDialog | This method is used to
 *    determine if the specified dialog box exists in the driver.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag S_OK | If the driver contains the dialog box
 *  @flag S_FALSE | If the driver doesn't contain the dialog box
 ***************************************************************************/
HRESULT CWDMCapDev::HasDialog(IN int iDialog)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::HasDialog")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

        // Validate input parameters
        ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));
        if (iDialog == VfwCaptureDialog_Source)
                Hr = S_OK;
        else if (iDialog == VfwCaptureDialog_Format)
                Hr = S_FALSE;
        else if (iDialog == VfwCaptureDialog_Display)
                Hr = S_FALSE;
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Invalid argument"), _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: end"), _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMDLGSMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | ShowDialog | This method is used to
 *    displaay the specified dialog box.
 *
 *  @parm int | iDialog | Specifies the desired dialog box. This is a member
 *    of the <t VfwCaptureDialogs> enumerated data type.
 *
 *  @parm HWND | hwnd | Specifies the handle of the dialog box's parent
 *    window.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag VFW_E_NOT_STOPPED | The operation could not be performed because the filter is not stopped
 *  @flag VFW_E_CANNOT_CONNECT | No combination of intermediate filters could be found to make the connection
 ***************************************************************************/
HRESULT CWDMCapDev::ShowDialog(IN int iDialog, IN HWND hwnd)
{
        HRESULT                 Hr = NOERROR;
        PROPSHEETHEADER Psh;
        HPROPSHEETPAGE  Pages[MAX_PAGES];
    CWDMDialog          VideoSettings(IDD_VIDEO_SETTINGS, NumVideoSettings, PROPSETID_VIDCAP_VIDEOPROCAMP, g_VideoSettingControls, m_pCaptureFilter);
    CWDMDialog          CamControl(IDD_CAMERA_CONTROL, NumCameraControls, PROPSETID_VIDCAP_CAMERACONTROL, g_CameraControls, m_pCaptureFilter);

        FX_ENTRY("CWDMCapDev::ShowDialog")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

        ASSERT((iDialog == VfwCaptureDialog_Source) || (iDialog == VfwCaptureDialog_Format) || (iDialog == VfwCaptureDialog_Display));

        // Before we bring the format dialog up, make sure we're not streaming, or about to
        // Also make sure another dialog isn't already up (I'm paranoid)
        if (iDialog == VfwCaptureDialog_Format || iDialog == VfwCaptureDialog_Display)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Unsupported dialog!"), _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        if (hwnd == NULL)
                hwnd = GetDesktopWindow();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   SUCCESS: Putting up Source dialog..."), _fx_));

        // Initialize property sheet header     and common controls
        Psh.dwSize              = sizeof(Psh);
        Psh.dwFlags             = PSH_DEFAULT;
        Psh.hInstance   = g_hInst;
        Psh.hwndParent  = hwnd;
        if(m_bCached_vcdi)
                Psh.pszCaption  = m_vcdi.szDeviceDescription;
        else
                Psh.pszCaption  = g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription;
        Psh.nPages              = 0;
        Psh.nStartPage  = 0;
        Psh.pfnCallback = NULL;
        Psh.phpage              = Pages;

    // Create the video settings property page and add it to the video settings sheet
        if (Pages[Psh.nPages] = VideoSettings.Create())
                Psh.nPages++;

    // Create the camera control property page and add it to the video settings sheet
        if (Pages[Psh.nPages] = CamControl.Create())
                Psh.nPages++;

        // Put up the property sheet
        if (Psh.nPages && PropertySheet(&Psh) >= 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   SUCCESS: ...videoDialog succeeded"), _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: ...videoDialog failed!"), _fx_));
                Hr = E_FAIL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: end"), _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CWDMDialog | Create | This function creates a new
 *    page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CWDMDialog::Create()
{
    PROPSHEETPAGE psp;

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = g_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(m_DlgID);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc BOOL | CWDMDialog | BaseDlgProc | This function implements
 *    the dialog box procedure for the page of a property sheet.
 *
 *  @parm HWND | hDlg | Handle to dialog box.
 *
 *  @parm UINT | uMessage | Message sent to the dialog box.
 *
 *  @parm WPARAM | wParam | First message parameter.
 *
 *  @parm LPARAM | lParam | Second message parameter.
 *
 *  @rdesc Except in response to the WM_INITDIALOG message, the dialog box
 *    procedure returns nonzero if it processes the message, and zero if it
 *    does not.
 ***************************************************************************/
INT_PTR CALLBACK CWDMDialog::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CWDMDialog *pSV = (CWDMDialog*)GetWindowLong(hDlg, DWL_USER);

        FX_ENTRY("CWDMDialog::BaseDlgProc");

    switch (uMessage)
    {
        case WM_INITDIALOG:
                        {
                                LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)lParam;
                                pSV=(CWDMDialog*)psp->lParam;
                                pSV->m_hDlg = hDlg;
                                SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
                                pSV->m_bInit = FALSE;
                                pSV->m_bChanged = FALSE;
                                return TRUE;
                        }
                        break;

        case WM_COMMAND:
            if (pSV)
            {
                int iRet = pSV->DoCommand(LOWORD(wParam), HIWORD(wParam));
                if (!iRet && pSV->m_bInit)
                                {
                                        PropSheet_Changed(GetParent(pSV->m_hDlg), pSV->m_hDlg);
                                        pSV->m_bChanged = TRUE;
                                }
                return iRet;
            }
                        break;

        case WM_HSCROLL:
                        if (pSV && pSV->m_pCaptureFilter && pSV->m_pCaptureFilter->m_pCapDev && pSV->m_pPC)
                        {
                                HWND hwndControl = (HWND) lParam;
                                HWND hwndSlider;
                                ULONG i;
                                TCHAR szTemp[32];

                                for (i = 0 ; i < pSV->m_dwNumControls ; i++)
                                {
                                        hwndSlider = GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider);

                                        // find matching slider
                                        if (hwndSlider == hwndControl)
                                        {
                                                LONG lValue = (LONG)SendMessage(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiSlider), TBM_GETPOS, 0, 0);
                                                ((CWDMCapDev *)(pSV->m_pCaptureFilter->m_pCapDev))->SetPropertyValue(pSV->m_guidPropertySet, pSV->m_pPC[i].uiProperty, lValue, KSPROPERTY_FLAGS_MANUAL, pSV->m_pPC[i].ulCapabilities);
                                                pSV->m_pPC[i].lCurrentValue = lValue;
                                                wsprintf(szTemp,"%d", lValue);
                                                SetWindowText(GetDlgItem(pSV->m_hDlg, pSV->m_pPC[i].uiCurrent), szTemp);
                                                break;
                                        }
                                }
                        }

                        break;

        case WM_NOTIFY:
                        if (pSV)
                        {
                                switch (((NMHDR FAR *)lParam)->code)
                                {
                                        case PSN_SETACTIVE:
                                                {
                                                        // We call out here specially so we can mark this page as having been init'd.
                                                        int iRet = pSV->SetActive();
                                                        pSV->m_bInit = TRUE;
                                                        return iRet;
                                                }
                                                break;

                                        case PSN_APPLY:
                                                // Since we apply the changes on the fly when the user moves the slide bars,
                                                // there isn't much left to do on PSN_APPLY...
                                                if (pSV->m_bChanged)
                                                        pSV->m_bChanged = FALSE;
                                                return FALSE;
                                                break;

                                        case PSN_QUERYCANCEL:
                                                return pSV->QueryCancel();
                                                break;

                                        default:
                                                break;
                                }
                        }
                        break;

                default:
                        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc void | CWDMDialog | CWDMDialog | Property page class constructor.
 *
 *  @parm int | DlgId | Resource ID of the property page dialog.
 *
 *  @parm DWORD | dwNumControls | Number of controls to display in the page.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are showing in
 *    the property page.
 *
 *  @parm PPROPSLIDECONTROL | pPC | Pointer to the list of slider controls
 *    to be displayed in the property page.
 *
 *  @parm PDWORD | pdwHelp | Pointer to the list of help IDs to be displayed
 *    in the property page.
 *
 *  @parm CWDMPin * | pCWDMPin | Pointer to the kernel streaming object
 *    we will query the property on.
 ***************************************************************************/
CWDMDialog::CWDMDialog(int DlgId, DWORD dwNumControls, GUID guidPropertySet, PPROPSLIDECONTROL pPC, CTAPIVCap *pCaptureFilter)
{
        FX_ENTRY("CWDMDialog::CWDMDialog");

        ASSERT(dwNumControls);
        ASSERT(pPC);
        ASSERT(pCaptureFilter);

        m_DlgID                         = DlgId;
        m_pCaptureFilter        = pCaptureFilter;
        m_dwNumControls         = dwNumControls;
        m_guidPropertySet       = guidPropertySet;
        m_pPC                           = pPC;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | SetActive | This function handles
 *    PSN_SETACTIVE by intializing all the property page controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::SetActive()
{
        FX_ENTRY("CWDMDialog::SetActive");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: begin"), _fx_));

    if (!m_pCaptureFilter || !m_pPC || !m_pCaptureFilter->m_pCapDev)
        return 0;

    // Returns zero to accept the activation or
    // -1 to activate the next or previous page
    // (depending on whether the user chose the Next or Back button)
    LONG i;
    EnableWindow(m_hDlg, TRUE);

    if (m_bInit)
        return 0;

    LONG  j, lValue, lMin, lMax, lStep;
    ULONG ulCapabilities, ulFlags;
    TCHAR szDisplay[256];

    for (i = j = 0 ; i < (LONG)m_dwNumControls; i++)
        {
        // Get the current value
        if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetPropertyValue(m_guidPropertySet, m_pPC[i].uiProperty, &lValue, &ulFlags, &ulCapabilities)))
                {
            LoadString(g_hInst, m_pPC[i].uiString, szDisplay, sizeof(szDisplay));
            SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), szDisplay);

            // Get the Range of Values possible.
            if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetRangeValues(m_guidPropertySet, m_pPC[i].uiProperty, &lMin, &lMax, &lStep)))
                        {
                                HWND hTB = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                                SendMessage(hTB, TBM_SETTICFREQ, (lMax-lMin)/lStep, 0);
                                SendMessage(hTB, TBM_SETRANGE, 0, MAKELONG(lMin, lMax));
                        }
            else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, TEXT("%s:   ERROR: Cannot get range values for this property ID = %d"), _fx_, m_pPC[j].uiProperty));
            }

            // Save these value for Cancel
            m_pPC[i].lLastValue = m_pPC[i].lCurrentValue = lValue;
            m_pPC[i].lMin                              = lMin;
            m_pPC[i].lMax                              = lMax;
            m_pPC[i].ulCapabilities                    = ulCapabilities;

            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), TRUE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), TRUE);

                        SendMessage(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TBM_SETPOS, TRUE, lValue);
                        wsprintf(szDisplay,"%d", lValue);
                        SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szDisplay);

                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   Capability = 0x%08lX; Flags=0x%08lX; lValue=%d"), _fx_, ulCapabilities, ulFlags, lValue));
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s:   switch(%d):"), _fx_, ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO)));

            switch (ulCapabilities & (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO))
                        {
                                case KSPROPERTY_FLAGS_MANUAL:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto
                                        break;

                                case KSPROPERTY_FLAGS_AUTO:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider;
                                        // always auto!
                                        SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                                        break;

                                case (KSPROPERTY_FLAGS_MANUAL | KSPROPERTY_FLAGS_AUTO):
                                        // Set flags
                                        if (ulFlags & KSPROPERTY_FLAGS_AUTO)
                                        {
                                                // Set auto check box; greyed out slider
                                                SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 1, 0);
                                                EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                                        }
                                        else
                                        {
                                                // Unchecked auto; enable slider
                                                SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_SETCHECK, 0, 0);
                                                EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                                        }
                                        break;

                                case 0:
                                default:
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);    // Disable slider; always auto!
                                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);    // Disable auto (greyed out)
                                        break;
            }

            j++;

        }
                else
                {
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiStatic), FALSE);
            EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiAuto), FALSE);
        }
    }

    // Disable the "default" push button;
    // or inform user that no control is enabled.
    if (j == 0)
        EnableWindow(GetDlgItem(m_hDlg, IDC_DEFAULT), FALSE);

    return 0;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | DoCommand | This function handles WM_COMMAND. This
 *    is where a click on the Default button or one of the Auto checkboxes
 *    is handled
 *
 *  @parm WORD | wCmdID | Command ID.
 *
 *  @parm WORD | hHow | Notification code.
 *
 *  @rdesc Always returns 1.
 ***************************************************************************/
int CWDMDialog::DoCommand(WORD wCmdID, WORD hHow)
{
    // If a user select default settings of the video format
    if (wCmdID == IDC_DEFAULT)
        {
        if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
                {
            HWND hwndSlider;
            LONG  lDefValue;
                        TCHAR szTemp[32];

            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                        {
                hwndSlider = GetDlgItem(m_hDlg, m_pPC[i].uiSlider);

                if (IsWindowEnabled(hwndSlider))
                                {
                    if (SUCCEEDED(((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->GetDefaultValue(m_guidPropertySet, m_pPC[i].uiProperty, &lDefValue)))
                                        {
                        if (lDefValue != m_pPC[i].lCurrentValue)
                                                {
                            ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, lDefValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                                                        SendMessage(hwndSlider, TBM_SETPOS, TRUE, lDefValue);
                                                        wsprintf(szTemp,"%d", lDefValue);
                                                        SetWindowText(GetDlgItem(m_hDlg, m_pPC[i].uiCurrent), szTemp);
                                                        m_pPC[i].lCurrentValue = lDefValue;
                        }
                    }
                }
            }
        }
        return 1;
    }
        else if (hHow == BN_CLICKED)
        {
        if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
                {
            for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                        {
                // find matching slider
                if (m_pPC[i].uiAuto == wCmdID)
                                {
                    if (BST_CHECKED == SendMessage (GetDlgItem(m_hDlg, m_pPC[i].uiAuto),BM_GETCHECK, 1, 0))
                                        {
                        ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_AUTO, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), FALSE);
                    }
                                        else
                                        {
                        ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lCurrentValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
                        EnableWindow(GetDlgItem(m_hDlg, m_pPC[i].uiSlider), TRUE);
                    }
                    break;
                }
            }
        }
    }

    return 1;
}


/****************************************************************************
 *  @doc INTERNAL CWDMDIALOGMETHOD
 *
 *  @mfunc int | CWDMDialog | QueryCancel | This function handles
 *    PSN_QUERYCANCEL by resetting the values of the controls.
 *
 *  @rdesc Always returns 0.
 ***************************************************************************/
int CWDMDialog::QueryCancel()
{
    if (m_pCaptureFilter && m_pCaptureFilter->m_pCapDev && m_pPC)
        {
        for (ULONG i = 0 ; i < m_dwNumControls ; i++)
                {
            if (IsWindowEnabled(GetDlgItem(m_hDlg, m_pPC[i].uiSlider)))
                        {
                if (m_pPC[i].lLastValue != m_pPC[i].lCurrentValue)
                    ((CWDMCapDev *)(m_pCaptureFilter->m_pCapDev))->SetPropertyValue(m_guidPropertySet,m_pPC[i].uiProperty, m_pPC[i].lLastValue, KSPROPERTY_FLAGS_MANUAL, m_pPC[i].ulCapabilities);
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#include <windows.h>

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\vc50\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video drivers           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef WIN32
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		3

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR  dwCallback;
       DWORD_PTR  dwCallbackInst;
       DWORD  dwFlags;
       HVIDEO  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\camerac.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERAC
 *
 *  @module CameraC.cpp | Source file for the <c CTAPIVDec>
 *    class methods used to implement the TAPI <i ICameraControl> interface.
 *
 *  @comm The <c CTAPIVDec> class does everything in software.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_CAMERA_CONTROL

#define PAN_TILT_MIN -180
#define PAN_TILT_MAX 180
#define PAN_TILT_DELTA 1
#define PAN_TILT_DEFAULT 0
#define ZOOM_MIN 10
#define ZOOM_MAX 600
#define ZOOM_DELTA 10
#define ZOOM_DEFAULT ZOOM_MIN
#define FLIP_MIN 0
#define FLIP_MAX 1
#define FLIP_DELTA 1
#define FLIP_DEFAULT FLIP_MIN

// From TAPIH263\cdrvdefs.h
#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_SET_ZOOM			(PLAYBACK_CUSTOM_START + 12)
#define PLAYBACK_CUSTOM_SET_PAN				(PLAYBACK_CUSTOM_START + 13)
#define PLAYBACK_CUSTOM_SET_TILT			(PLAYBACK_CUSTOM_START + 14)
#define PLAYBACK_CUSTOM_SET_FLIPVERTICAL	(PLAYBACK_CUSTOM_START + 15)
#define PLAYBACK_CUSTOM_SET_FLIPHORIZONTAL	(PLAYBACK_CUSTOM_START + 16)

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Set | This method is used to set the value
 *    of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the camera control
 *    setting.
 *
 *  @parm TAPIControlFlags | Flags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Set (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	switch (Property)
	{
		case TAPICameraControl_Pan:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
			{
				m_lCCPan = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_PAN, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_Tilt:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
			{
				m_lCCTilt = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_TILT, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_Zoom:
			ASSERT(lValue >= ZOOM_MIN && lValue <= ZOOM_MAX);
			if (lValue >= ZOOM_MIN && lValue <= ZOOM_MAX)
			{
				m_lCCZoom = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_ZOOM, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case TAPICameraControl_FlipVertical:
			m_fFlipVertical = lValue;
			(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_FLIPVERTICAL, (LPARAM)lValue, NULL);
			break;
		case TAPICameraControl_FlipHorizontal:
			m_fFlipHorizontal = lValue;
			(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_SET_FLIPHORIZONTAL, (LPARAM)lValue, NULL);
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Get | This method is used to retrieve the
 *    value of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to get the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    camera control setting.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Get (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
			*plValue = m_lCCPan;
			break;
		case TAPICameraControl_Tilt:
			*plValue = m_lCCTilt;
			break;
		case TAPICameraControl_Zoom:
			*plValue = m_lCCZoom;
			break;
		case TAPICameraControl_FlipVertical:
			*plValue = m_fFlipVertical;
			break;
		case TAPICameraControl_FlipHorizontal:
			*plValue = m_fFlipHorizontal;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific camera control
 *    settings.
 *
 *  @parm CameraControlProperty | Property | Used to specify the camera
 *    control setting to determine the range of. Use a member of the
 *    <t CameraControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the camera
 *    control setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the camera
 *    control setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the camera control setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    camera control setting range.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to retrieve the capabilities
 *     of the camera control setting. Pointer to a member of the <t TAPIControlFlags>
 *     enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::GetRange (CameraControl)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plCapsFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
		case TAPICameraControl_Tilt:
			*plMin = PAN_TILT_MIN;
			*plMax = PAN_TILT_MAX;
			*plSteppingDelta = PAN_TILT_DELTA;
			*plDefault = PAN_TILT_DEFAULT;
			break;
		case TAPICameraControl_Zoom:
			*plMin = ZOOM_MIN;
			*plMax = ZOOM_MAX;
			*plSteppingDelta = ZOOM_DELTA;
			*plDefault = ZOOM_DEFAULT;
			break;
		case TAPICameraControl_FlipVertical:
		case TAPICameraControl_FlipHorizontal:
			*plMin = FLIP_MIN;
			*plMax = FLIP_MAX;
			*plSteppingDelta = FLIP_DELTA;
			*plDefault = FLIP_DEFAULT;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\cameracp.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.cpp | Source file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI H.26X Video Decoder filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CAMERA_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | CCameraControlProperty | This
 *    method is the constructor for camera control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i ICameraControl> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ICameraControl* | pInterface | Specifies a pointer to the
 *    <i ICameraControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCameraControlProperty::CCameraControlProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | ~CCameraControlProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::~CCameraControlProperty()
{
	FX_ENTRY("CCameraControlProperty::~CCameraControlProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get((TAPICameraControlProperty)m_IDProperty, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set((TAPICameraControlProperty)m_IDProperty, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange((TAPICameraControlProperty)m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pICameraControl->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc CUnknown* | CCameraControlProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CCameraControlPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CCameraControlProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CCameraControlProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CCameraControlProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | CCameraControlProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Camera Control Property Page"), pUnk, IDD_CameraControlProperties, IDS_CAMERACONTROLPROPNAME)
{
	FX_ENTRY("CCameraControlProperties::CCameraControlProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_pICameraControl = NULL;
	m_NumProperties = NUM_CAMERA_CONTROLS;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | ~CCameraControlProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::~CCameraControlProperties()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::~CCameraControlProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the camera control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICameraControl),(void **)&m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_pICameraControl=0x%08lX", _fx_, m_pICameraControl));
	}
	else
	{
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDisconnect()
{
	FX_ENTRY("CCameraControlProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pICameraControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pICameraControl->Release();
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: releasing m_pICameraControl", _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CCameraControlProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CCameraControlProperty(m_hwnd, IDC_Pan_Label, IDC_Pan_Minimum, IDC_Pan_Maximum, IDC_Pan_Default, IDC_Pan_Stepping, IDC_Pan_Edit, IDC_Pan_Slider, 0, TAPICameraControl_Pan, IDC_Pan_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Pan] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Pan]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CCameraControlProperty(m_hwnd, IDC_Tilt_Label, IDC_Tilt_Minimum, IDC_Tilt_Maximum, IDC_Tilt_Default, IDC_Tilt_Stepping, IDC_Tilt_Edit, IDC_Tilt_Slider, 0, TAPICameraControl_Tilt, IDC_Tilt_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Tilt] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Tilt]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CCameraControlProperty(m_hwnd, IDC_Roll_Label, IDC_Roll_Minimum, IDC_Roll_Maximum, IDC_Roll_Default, IDC_Roll_Stepping, IDC_Roll_Edit, IDC_Roll_Slider, 0, TAPICameraControl_Roll, IDC_Roll_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Roll] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Roll]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CCameraControlProperty(m_hwnd, IDC_Zoom_Label, IDC_Zoom_Minimum, IDC_Zoom_Maximum, IDC_Zoom_Default, IDC_Zoom_Stepping, IDC_Zoom_Edit, IDC_Zoom_Slider, 0, TAPICameraControl_Zoom, IDC_Zoom_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Zoom] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Zoom]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CCameraControlProperty(m_hwnd, IDC_Exposure_Label, IDC_Exposure_Minimum, IDC_Exposure_Maximum, IDC_Exposure_Default, IDC_Exposure_Stepping, IDC_Exposure_Edit, IDC_Exposure_Slider, 0, TAPICameraControl_Exposure, IDC_Exposure_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Exposure] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Exposure]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CCameraControlProperty(m_hwnd, IDC_Iris_Label, IDC_Iris_Minimum, IDC_Iris_Maximum, IDC_Iris_Default, IDC_Iris_Stepping, IDC_Iris_Edit, IDC_Iris_Slider, 0, TAPICameraControl_Iris, IDC_Iris_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Iris] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Iris]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CCameraControlProperty(m_hwnd, IDC_Focus_Label, IDC_Focus_Minimum, IDC_Focus_Maximum, IDC_Focus_Default, IDC_Focus_Stepping, IDC_Focus_Edit, IDC_Focus_Slider, 0, TAPICameraControl_Focus, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Focus] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Focus]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipVertical_Edit, 0, 0, TAPICameraControl_FlipVertical, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipVertical] failed - Out of memory", _fx_));
		goto MyError6;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipVertical]=0x%08lX", _fx_, m_Controls[7]));
	}

	if (!(m_Controls[8] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipHorizontal_Edit, 0, 0, TAPICameraControl_FlipHorizontal, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipHorizontal] failed - Out of memory", _fx_));
		goto MyError7;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipHorizontal]=0x%08lX", _fx_, m_Controls[8]));
	}


	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError7:
	if (m_Controls[7])
		delete m_Controls[7], m_Controls[7] = NULL;
MyError6:
	if (m_Controls[6])
		delete m_Controls[6], m_Controls[6] = NULL;
MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CCameraControlProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCameraControlProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\h245comm.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245COMM
 *
 *  @module H245Comm.cpp | Source file for the <c CTAPIInputPin>  and
 *    <c CTAPIVDec> class methods used to implement the video decoder input
 *    pin remote H.245 encoder command methods, and <c CTAPIOutputPin> H.245
 *    decoder command method.
 *
 *  @comm Our decoder only issues video fast-update picture commands.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | videoFastUpdatePicture | This
 *    method is used to specify to the remote encoder to enter
 *    the fast-update picture mode at its earliest opportunity.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::videoFastUpdatePicture()
{
	FX_ENTRY("CTAPIVDec::videoFastUpdatePicture")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Ask the channel controller to issue an I-frame request 
	if (m_pIH245EncoderCommand)
		m_pIH245EncoderCommand->videoFastUpdatePicture();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Set | This method is used by the incoming
 *    video stream to provide a pointer to the <i IH245EncoderCommand>
 *    interface supported by the associated channel controller.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Set(IN IH245EncoderCommand *pIH245EncoderCommand)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::videoFastUpdateGOB")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pIH245EncoderCommand);
	if (!pIH245EncoderCommand)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Remember the interface pointer 
	m_pDecoderFilter->m_pIH245EncoderCommand = pIH245EncoderCommand;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245COMMMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | videoFreezePicture | This
 *    method is used to specify to the decoder to complete updating the
 *    current video frame and subsequently display the frozen picture until
 *    receipt of the appropriate freeze-picture release control signal.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::videoFreezePicture()
{
	FX_ENTRY("CTAPIOutputPin::videoFreezePicture")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Freeze the video decoding 
	m_pDecoderFilter->m_fFreezePicture = TRUE;
	m_pDecoderFilter->m_dwFreezePictureStartTime = timeGetTime();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\formats.h ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.h | Header file for the supported compressed input formats.
 ***************************************************************************/

#ifndef _FORMATS_H_
#define _FORMATS_H_

// List of capture formats supported
#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L
#define STILL_FRAME_INTERVAL 10000000

#define NUM_H245VIDEOCAPABILITYMAPS 5
#define NUM_RATES_PER_RESOURCE 5
#define NUM_ITU_SIZES 3
#define QCIF_SIZE 0
#define CIF_SIZE 1
#define SQCIF_SIZE 2

#define R263_QCIF_H245_CAPID 0UL
#define R263_CIF_H245_CAPID 1UL
#define R263_SQCIF_H245_CAPID 2UL
#define R261_QCIF_H245_CAPID 3UL
#define R261_CIF_H245_CAPID 4UL

extern const AM_MEDIA_TYPE AMMT_R263_QCIF;
extern const AM_MEDIA_TYPE AMMT_R263_CIF;
extern const AM_MEDIA_TYPE AMMT_R263_SQCIF;
extern const AM_MEDIA_TYPE AMMT_R261_QCIF;
extern const AM_MEDIA_TYPE AMMT_R261_CIF;

#define NUM_R26X_FORMATS 5

extern const AM_MEDIA_TYPE* const R26XFormats[NUM_R26X_FORMATS];
extern const TAPI_STREAM_CONFIG_CAPS* const R26XCaps[NUM_R26X_FORMATS];
extern DWORD const R26XPayloadTypes[NUM_R26X_FORMATS];

#define H263_PAYLOAD_TYPE 34UL
#define H261_PAYLOAD_TYPE 31UL

#endif // _FORMATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\formats.cpp ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.cpp | Source file for the video formats we support.
 ***************************************************************************/

#include "Precomp.h"

// RTP packetized H.263 Version 1 QCIF size
#define CIF_BUFFER_SIZE 32768
#define D_X_CIF 352
#define D_Y_CIF 288

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_CIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 CIF",						// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_CIF, D_Y_CIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_CIF, D_Y_CIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_CIF, D_Y_CIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_CIF, D_Y_CIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_CIF, D_Y_CIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    CIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_CIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_CIF,							// LONG  biWidth;
		D_Y_CIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		CIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
		CIF_BUFFER_SIZE * 8 / 1024,			// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_CIF),			// cbFormat
	(LPBYTE)&VIH_R263_CIF,			// pbFormat
};

// H.263 Version 1 QCIF size
#define QCIF_BUFFER_SIZE 8192
#define D_X_QCIF 176
#define D_Y_QCIF 144

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_QCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 QCIF",						// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_QCIF, D_Y_QCIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_QCIF, D_Y_QCIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_QCIF, D_Y_QCIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_QCIF, D_Y_QCIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_QCIF, D_Y_QCIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    QCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_QCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_QCIF,							// LONG  biWidth;
		D_Y_QCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		QCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		QCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		QCIF_BUFFER_SIZE * 8 / 1024,		// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_QCIF),			// cbFormat
	(LPBYTE)&VIH_R263_QCIF,			// pbFormat
};

// H.263 Versions 1 SQCIF size
#define SQCIF_BUFFER_SIZE 8192
#define D_X_SQCIF 128
#define D_Y_SQCIF 96

const TAPI_STREAM_CONFIG_CAPS TSCC_R263_SQCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.263 v.1 SQCIF",						// Description
	    D_X_SQCIF, D_Y_SQCIF,					// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_SQCIF, D_Y_SQCIF,					// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_SQCIF, D_Y_SQCIF,					// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_SQCIF, D_Y_SQCIF,					// MinOutputSize, smallest bitmap stream can produce
	    D_X_SQCIF, D_Y_SQCIF,					// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    SQCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H263 VIH_R263_SQCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    SQCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H263),		// DWORD biSize;
		D_X_SQCIF,							// LONG  biWidth;
		D_Y_SQCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R263,						// DWORD biCompression;
		SQCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.263 specific fields
		SQCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		SQCIF_BUFFER_SIZE * 8 / 1024,		// dwBppMaxKb
		0,									// dwHRD_B

		//Options
		0,									// fUnrestrictedVector
		0,									// fArithmeticCoding
		0,									// fAdvancedPrediction
		0,									// fPBFrames
		0,									// fErrorCompensation
		0,									// fAdvancedIntraCodingMode
		0,									// fDeblockingFilterMode
		0,									// fImprovedPBFrameMode
		0,									// fUnlimitedMotionVectors
		0,									// fFullPictureFreeze
		0,									// fPartialPictureFreezeAndRelease
		0,									// fResizingPartPicFreezeAndRelease
		0,									// fFullPictureSnapshot
		0,									// fPartialPictureSnapshot
		0,									// fVideoSegmentTagging
		0,									// fProgressiveRefinement
		0,									// fDynamicPictureResizingByFour
		0,									// fDynamicPictureResizingSixteenthPel
		0,									// fDynamicWarpingHalfPel
		0,									// fDynamicWarpingSixteenthPel
		0,									// fIndependentSegmentDecoding
		0,									// fSlicesInOrder-NonRect
		0,									// fSlicesInOrder-Rect
		0,									// fSlicesNoOrder-NonRect
		0,									// fSlicesNoOrder-NonRect
		0,									// fAlternateInterVLCMode
		0,									// fModifiedQuantizationMode
		0,									// fReducedResolutionUpdate
		0,									// fReserved

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R263_SQCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R263_V1,			// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R263_SQCIF),		// cbFormat
	(LPBYTE)&VIH_R263_SQCIF,		// pbFormat
};

// RTP packetized H.261 CIF size
const TAPI_STREAM_CONFIG_CAPS TSCC_R261_CIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.261 CIF",							// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_CIF, D_Y_CIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_CIF, D_Y_CIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_CIF, D_Y_CIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_CIF, D_Y_CIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_CIF, D_Y_CIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    CIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H261 VIH_R261_CIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H261),		// DWORD biSize;
		D_X_CIF,							// LONG  biWidth;
		D_Y_CIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R261,						// DWORD biCompression;
		CIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.261 specific fields
		CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
		0,									// fStillImageTransmission

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R261_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R261,				// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R261_CIF),			// cbFormat
	(LPBYTE)&VIH_R261_CIF,			// pbFormat
};

// RTP packetized H.261 QCIF size
const TAPI_STREAM_CONFIG_CAPS TSCC_R261_QCIF = 
{
	VideoStreamConfigCaps,						// CapsType
	{
	    L"H.261 QCIF",							// Description
	    AnalogVideo_None,						// VideoStandard
	    D_X_QCIF, D_Y_QCIF,						// InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
	    D_X_QCIF, D_Y_QCIF,						// MinCroppingSize, smallest rcSrc cropping rect allowed
	    D_X_QCIF, D_Y_QCIF,						// MaxCroppingSize, largest  rcSrc cropping rect allowed
	    1,										// CropGranularityX, granularity of cropping size
	    1,										// CropGranularityY
	    1,										// CropAlignX, alignment of cropping rect 
	    1,										// CropAlignY;
	    D_X_QCIF, D_Y_QCIF,						// MinOutputSize, smallest bitmap stream can produce
	    D_X_QCIF, D_Y_QCIF,						// MaxOutputSize, largest  bitmap stream can produce
	    1,										// OutputGranularityX, granularity of output bitmap size
	    1,										// OutputGranularityY;
	    0,										// StretchTapsX
	    0,										// StretchTapsY
	    0,										// ShrinkTapsX
	    0,										// ShrinkTapsY
	    MIN_FRAME_INTERVAL,						// MinFrameInterval, 100 nS units
	    MAX_FRAME_INTERVAL,						// MaxFrameInterval, 100 nS units
	    0,										// MinBitsPerSecond
	    QCIF_BUFFER_SIZE * 30 * 8				// MaxBitsPerSecond;
	}
}; 

const VIDEOINFOHEADER_H261 VIH_R261_QCIF = 
{
    0,0,0,0,								// RECT  rcSource; 
    0,0,0,0,								// RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,				// DWORD dwBitRate;
    0L,										// DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,						// REFERENCE_TIME  AvgTimePerFrame;   

	{
		sizeof (BITMAPINFOHEADER_H261),		// DWORD biSize;
		D_X_QCIF,							// LONG  biWidth;
		D_Y_QCIF,							// LONG  biHeight;
		1,									// WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
		24,									// WORD  biBitCount;
#else
		0,									// WORD  biBitCount;
#endif
		FOURCC_R261,						// DWORD biCompression;
		QCIF_BUFFER_SIZE,					// DWORD biSizeImage;
		0,									// LONG  biXPelsPerMeter;
		0,									// LONG  biYPelsPerMeter;
		0,									// DWORD biClrUsed;
		0,									// DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
		// H.261 specific fields
		QCIF_BUFFER_SIZE * 30 * 8 / 100,	// dwMaxBitrate
		0,									// fStillImageTransmission

		// Reserved
		0, 0, 0, 0							// dwReserved[4]
#endif
	}
};

const AM_MEDIA_TYPE AMMT_R261_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,			// majortype
    STATIC_MEDIASUBTYPE_R261,				// subtype
    FALSE,									// bFixedSizeSamples (all samples same size?)
    TRUE,									// bTemporalCompression (uses prediction?)
    0,										// lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
	NULL,									// pUnk
	sizeof (VIH_R261_QCIF),			// cbFormat
	(LPBYTE)&VIH_R261_QCIF,			// pbFormat
};

// Array of all formats
const AM_MEDIA_TYPE* const R26XFormats[] = 
{
    (AM_MEDIA_TYPE*) &AMMT_R263_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_CIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_SQCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_CIF
};
const TAPI_STREAM_CONFIG_CAPS* const R26XCaps[] = 
{
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_QCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_CIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R263_SQCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R261_QCIF,
	(TAPI_STREAM_CONFIG_CAPS*) &TSCC_R261_CIF
};
DWORD const R26XPayloadTypes [] =
{
	H263_PAYLOAD_TYPE,
	H263_PAYLOAD_TYPE,
	H263_PAYLOAD_TYPE,
	H261_PAYLOAD_TYPE,
	H261_PAYLOAD_TYPE,
};

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | SetFormat | This method is used to
 *    set a specific media type on a pin. It is only implemented by the
 *    output pin of video encoders.
 *
 *  @parm DWORD | dwRTPPayLoadType | Specifies the payload type associated
 *    to the pointer to the <t AM_MEDIA_TYPE> structure passed in.
 *
 *  @parm AM_MEDIA_TYPE* | pMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType)
{
	FX_ENTRY("CTAPIInputPin::SetFormat")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

    // we can handle dynamic format changing.
	return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetFormat | This method is used to
 *    retrieve the current media type on a pin.
 *
 *  @parm DWORD* | pdwRTPPayLoadType | Specifies the address of a DWORD
 *    to receive the payload type associated to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm Note that we return the output type, not the format at which
 *    we are capturing. Only the filter really cares about how the data is
 *    being captured.
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetFormat")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwRTPPayLoadType);
	ASSERT(ppMediaType);
	if (!pdwRTPPayLoadType || !ppMediaType)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return a copy of our current format
	*ppMediaType = CreateMediaType(&m_mt);

	// Return the payload type associated to the current format
	*pdwRTPPayLoadType = m_dwRTPPayloadType;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetNumberOfCapabilities | This method is
 *    used to retrieve the number of stream capabilities structures.
 *
 *  @parm DWORD* | pdwCount | Specifies a pointer to a DWORD to receive the
 *    number of <t TAPI_STREAM_CONFIG_CAPS> structures supported.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetNumberOfCapabilities(OUT DWORD *pdwCount)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetNumberOfCapabilities")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwCount);
	if (!pdwCount)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return relevant info
	*pdwCount = NUM_R26X_FORMATS;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Returning %ld formats", _fx_, *pdwCount));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetStreamCaps | This method is
 *    used to retrieve a video stream capability pair.
 *
 *  @parm DWORD | dwIndex | Specifies the index to the desired media type
 *    and capability pair.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm TAPI_STREAM_CONFIG_CAPS* | pTSCC | Specifies a pointer to a
 *    <t TAPI_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD * pdwRTPPayLoadType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIInputPin::GetStreamCaps")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwIndex < NUM_R26X_FORMATS);
	if (!(dwIndex < NUM_R26X_FORMATS))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid dwIndex argument!", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return a copy of the requested AM_MEDIA_TYPE structure 
	if (ppMediaType)
    {
	    if (!(*ppMediaType = CreateMediaType(R26XFormats[dwIndex])))
	    {
		    DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
		    Hr = E_OUTOFMEMORY;
		    goto MyExit;
	    }
    }

	// Return a copy of the requested VIDEO_STREAM_CONFIG_CAPS structure
	if (pTSCC)
    {
        CopyMemory(pTSCC, R26XCaps[dwIndex], sizeof(TAPI_STREAM_CONFIG_CAPS));
    }

    if (pdwRTPPayLoadType)
    {
        *pdwRTPPayLoadType = R26XPayloadTypes[dwIndex];
    }

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Returning format index %ld: %s %ld bpp %ldx%ld", _fx_, dwIndex, HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression == BI_RGB ? "RGB" : "????", HEADER(R26XFormats[dwIndex]->pbFormat)->biBitCount, HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth, HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\cameracp.h ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.h | Header file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _CAMERACP_H_
#define _CAMERACP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CAMERA_CONTROL

#define NUM_CAMERA_CONTROLS 9

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperty | This class implements handling of a
 *    single camera control property in a property page.
 *
 *  @mdata int | CCameraControlProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperty | m_pInterface | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperty : public CPropertyEditor 
{
	public:
	CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface);
	~CCameraControlProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	ICameraControl *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i ICameraControl> implementation.
 *
 *  @mdata int | CCameraControlProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperties | m_pICameraControl | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @mdata CCameraControlProperty * | CCameraControlProperties | m_Controls[NUM_CAMERA_CONTROLS] | Array
 *    of camera control properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperties : public CBasePropertyPage
{
	public:
	CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CCameraControlProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	ICameraControl *m_pICameraControl;
	BOOL m_fActivated;
	CCameraControlProperty *m_Controls[NUM_CAMERA_CONTROLS];
};

#endif // USE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES

#endif // _CAMERACP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\h245vidc.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245VIDC
 *
 *  @module H245VidC.cpp | Source file for the <c CTAPIInputPin> class methods
 *    used to implement the <i IH245Capability> TAPI inteface.
 *
 *  @comm For now, use the NM heuristics.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetH245VersionID | This method is used to
 *    retrieve a DWORD value that identifies the platform version that the
 *    TAPI MSP Video Capture filter was designed for. The platform version is
 *    defined as TAPI_H245_VERSION_ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetH245VersionID(OUT DWORD *pdwVersionID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetH245VersionID")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameter
        ASSERT(pdwVersionID);
        if (!pdwVersionID)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
        }
        else
        {
                *pdwVersionID = TAPI_H245_VERSION_ID;
                Hr = NOERROR;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetFormatTable | This method is used to
 *    obtain <t H245MediaCapabilityMap> structures for all formats and format
 *    options that the TAPI MSP Video Decoder filter supports. The content of
 *    the capability information that the TAPI MSP Capability module obtains
 *    via this method is a two dimensional table that relates every supported
 *    receive format to steady-state resource requirements of that format.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm The memory allocated by <mf CTAPIInputPin.GetFormatTable> is released
 *    by calling <mf CTAPIInputPin.ReleaseFormatTable>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetFormatTable(OUT H245MediaCapabilityTable *pTable)
{
        HRESULT                                 Hr = NOERROR;
        int                                             nNormalizedSpeed;
        LONG                                    lRate, lRateCIF, lRateQCIF, lRateSQCIF;
        DWORD                                   dwNumQCIFBounds, dwNumCIFBounds, dwNumSQCIFBounds;
        DWORD                                   dwCPUUsage;
        DWORD                                   dwBitsPerSec;

        FX_ENTRY("CTAPIInputPin::GetFormatTable")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pTable);
        if (!pTable)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // We support H.261 QCIF and CIF, as well as H.263 SQCIF, QCIF, and CIF

        // Allocate memory to describe the capabilities of these formats
        if (!(m_pH245MediaCapabilityMap = new H245MediaCapabilityMap[NUM_H245VIDEOCAPABILITYMAPS]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Initialize the array of capabilities
        ZeroMemory(m_pH245MediaCapabilityMap, NUM_H245VIDEOCAPABILITYMAPS * sizeof(H245MediaCapabilityMap));

        // Allocate memory to describe the resource bounds of our capabilities
        if (!(m_pVideoResourceBounds = new VideoResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError1;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pVideoResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Allocate memory to describe the format bounds of our capabilities
        if (!(m_pFormatResourceBounds = new FormatResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError2;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pFormatResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Get the CPU properties
        GetNormalizedCPUSpeed(&nNormalizedSpeed);

        // Initialize frame rate limits
        if (nNormalizedSpeed > SLOW_CPU_MHZ && nNormalizedSpeed < FAST_CPU_MHZ)
        {
                // 110MHz < CPUs < 200MhZ
                lRateCIF   = CIF_RATE_SLOW;
                lRateQCIF  = QCIF_RATE_SLOW;
                lRateSQCIF = SQCIF_RATE_SLOW;
        }
        else if (nNormalizedSpeed >= FAST_CPU_MHZ && nNormalizedSpeed < VERYFAST_CPU_MHZ)
        {
                // 200MHz < CPUs < 400MhZ
                lRateCIF   = CIF_RATE_FAST;
                lRateQCIF  = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else if (nNormalizedSpeed >= VERYFAST_CPU_MHZ)
        {
                // CPUs > 400MhZ
                // It would be better if we could scale between 15 and 30 frames/sec
                // depending on the CPU speed. But H.245 doesn't have any values
                // between 15 and 30. (See definition of Minimum Picture Interval)
                // So for now, 30 frames per sec CIF for all 400mhz and faster machines
                lRateCIF = CIF_RATE_VERYFAST;
                lRateQCIF = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else
        {
                // CPUs < 110MHZ
                lRateCIF   = CIF_RATE_VERYSLOW;
                lRateQCIF  = QCIF_RATE_VERYSLOW;
                lRateSQCIF = SQCIF_RATE_VERYSLOW;
        }

        //it was #define HUNDREDSBITSPERPIC 640
        //#define BITSPERPIC (64*1024)
        #define BITSPERPIC (8*1024)
        // Compute resources bounds
        for (lRate = lRateQCIF, dwNumQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   QCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   QCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumQCIFBounds));
                dwNumQCIFBounds++;
        }
        for (lRate = lRateCIF, dwNumCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:    CIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:    CIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumCIFBounds));
                dwNumCIFBounds++;
        }
        for (lRate = lRateSQCIF, dwNumSQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:  SQCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:  SQCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumSQCIFBounds));
                dwNumSQCIFBounds++;
        }

        // Initialise H.263 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].dwUniqueID = R263_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 8192 bytes
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.263 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].dwUniqueID = R263_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes

        // Initialise H.263 SQCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].dwUniqueID = R263_SQCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries = dwNumSQCIFBounds;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_sqcifMPI_present;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / lRateSQCIF);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateSQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.261 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].dwUniqueID = R261_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 8192 bytes

        // Initialise H.261 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].dwUniqueID = R261_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoDecoder);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 32768 bytes

        // Return our H245MediaCapabilityTable
        pTable->uMappedCapabilities = NUM_H245VIDEOCAPABILITYMAPS;
        pTable->pCapabilityArray = m_pH245MediaCapabilityMap;

        goto MyExit;

MyError2:
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
MyError1:
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | ReleaseFormatTable | This method is used to
 *    to release memory allocated by the <mf CTAPIInputPin.GetFormatTable> method.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetFormatTable>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::ReleaseFormatTable(IN H245MediaCapabilityTable *pTable)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::ReleaseFormatTable")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters - if it is our table, it should have NUM_H245VIDEOCAPABILITYMAPS entries
        ASSERT(pTable);
        if (!pTable || !pTable->pCapabilityArray)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pTable->uMappedCapabilities == NUM_H245VIDEOCAPABILITYMAPS && pTable->pCapabilityArray == m_pH245MediaCapabilityMap);
        if (pTable->uMappedCapabilities != NUM_H245VIDEOCAPABILITYMAPS || pTable->pCapabilityArray != m_pH245MediaCapabilityMap)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Release the table of H245MediaCapabilityMap structures
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
        if (m_pFormatResourceBounds)
                delete[] m_pFormatResourceBounds, m_pFormatResourceBounds = NULL;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Refine | This method is used to
 *    refine the content of an <t H245MediaCapability> structure based on the
 *    CPU and bandwidth limitations passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique ID of the local capability
 *    structure passed in.
 *
 *  @parm DWORD | dwResourceBoundIndex | Specifies the resource limitations to
 *    be applied on the local capability structure passed in.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Refine")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
        if (!pLocalCapability)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pLocalCapability->media_type == H245MediaType_Video);
        if (pLocalCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Update the relevant fields
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_SQCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                default:
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | IntersectFormats | This method is used to
 *    compare and intersect one local capability and one remote capability
 *    and to obtain configuration parameters.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the local H.245
 *    video capability passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm H245MediaCapability* | pRemoteCapability | Specifies the H.245
 *    video format, including all parameters and options defined by H.245, of
 *    a remote video capability.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm DWORD* | pdwPayloadType | Specifies RTP payload type to be used.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::IntersectFormats(
    IN DWORD dwUniqueID,
    IN const H245MediaCapability *pLocalCapability,
    IN const H245MediaCapability *pRemoteCapability,
    OUT H245MediaCapability **ppIntersectedCapability,
    OUT  DWORD *pdwPayloadType
    )
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::IntersectFormats")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
    ASSERT(pdwPayloadType);

        if (!pLocalCapability || !pdwPayloadType)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                return E_POINTER;
        }

    *pdwPayloadType = R26XPayloadTypes[dwUniqueID];

    // initialize intersected cap
    if (ppIntersectedCapability) *ppIntersectedCapability = NULL;

    if (pRemoteCapability == NULL)
    {
        // if this is NULL, the caller just want a copy of the local caps.

        // Allocate memory to describe the capabilities of these formats
            if (!(*ppIntersectedCapability = new H245MediaCapability))
            {
                    DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                    Hr = E_OUTOFMEMORY;
                    goto MyExit;
            }

        *(*ppIntersectedCapability) = *pLocalCapability;

                Hr = S_OK;
                goto MyExit;
    }

    // First: test for basic similarity between local and remote format.
        if(pLocalCapability->capability.audio_cap.choice != pRemoteCapability->
                capability.audio_cap.choice)
        {
                Hr = E_INVALIDARG; // E_NO_INTERSECTION ?
                goto MyExit;
        }

    if (ppIntersectedCapability == NULL)
    {
        // just test to see if we like it.
            if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

#ifdef STRICT_H245
            // do more testing withe the capability. They might break the interop
            // with bad H323 endpoints.

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI)
            {
                return E_FAIL;
            }
#endif
        }
            else if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

#ifdef STRICT_H245
            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI)
            {
                return E_FAIL;
            }
#endif
        }
        else
        {
            return E_UNEXPECTED;
        }

        return S_OK;
    }

        // Allocate memory to describe the capabilities of these formats
        if (!(*ppIntersectedCapability = new H245MediaCapability))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Initialize the intersected capability
        ZeroMemory(*ppIntersectedCapability, sizeof(H245MediaCapability));

        // Resolve the capabilities
        if (pRemoteCapability->media_type == H245MediaType_Video && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;
                (*ppIntersectedCapability)->capability.video_cap.choice = h263VideoCapability_chosen;
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask = pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask;
                if (!(*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bppMaxKb = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb, pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.qcifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.cifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.sqcifMPI = max(pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI, pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI);
        }
        else if (pRemoteCapability->media_type == H245MediaType_Video && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;
                (*ppIntersectedCapability)->capability.video_cap.choice = h261VideoCapability_chosen;
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask = pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask;
                if (!(*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate);
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.qcifMPI = max(pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI, pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI);
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.cifMPI = max(pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI, pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI);
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

MyExit:
    if (FAILED (Hr))
    {
        if (ppIntersectedCapability && *ppIntersectedCapability)
        {
            // clear allocated memory if we failed
            delete (*ppIntersectedCapability);
            *ppIntersectedCapability = NULL;
        }
    }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetLocalFormat | This method is used to
 *    obtain the local TAPI MSP Video Decoder filter configuration
 *    parameters that are compatible with a remote capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the intersected
 *    H.245 video capability passed in.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm AM_MEDIA_TYPE** | ppAMMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure to be been initialized with regards
 *    to negotiated options.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetLocalFormat")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        ASSERT(ppAMMediaType);
        if (!pIntersectedCapability || !ppAMMediaType)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Find the DShow format the passed in capability structure matches
        ASSERT(pIntersectedCapability->media_type == H245MediaType_Video);
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        if (!(dwUniqueID <= R261_CIF_H245_CAPID) || pIntersectedCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return a copy of the format that matches the capability negociated
        if (!(*ppAMMediaType = CreateMediaType(R26XFormats[dwUniqueID])))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Doctor the AM_MEDIA_TYPE fields to show the changes in frame
        // rate, bitrate, and max frame size in the negotiated capability
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R263_CIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R263_SQCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
                        break;
                case R261_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
                case R261_CIF_H245_CAPID:
                default:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | ReleaseNegotiatedCapability | This method
 *    is used to release the TAPI MSP Video Capture filter internal memory
 *    allocated by either the <mf CTAPIInputPin.IntersectFormats> or
 *    <mf CTAPIInputPin.GetLocalFormat> method.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CTAPIInputPin.IntersectFormats>, <mf CTAPIInputPin.GetLocalFormat>
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::ReleaseNegotiatedCapability")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        if (!pIntersectedCapability)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Release the memory
        delete pIntersectedCapability;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | FindIDByRange | This method is used to
 *    obtain the unique format ID of a capability that corresponds to an
 *    <t AM_MEDIA_TYPE>.
 *
 *  @parm AM_MEDIA_TYPE* | pAMMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure that has been initialized with a
 *    specific format.
 *
 *  @parm DWORD* | pdwID | Specifies a pointer to a DWORD output parameter
 *    that will contain the unique format ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::FindIDByRange")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pAMMediaType);
        ASSERT(pdwID);
        if (!pAMMediaType || !pdwID)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pAMMediaType->majortype == MEDIATYPE_Video && pAMMediaType->formattype == FORMAT_VideoInfo && pAMMediaType->pbFormat);
        if (!pAMMediaType || !pdwID || pAMMediaType->majortype != MEDIATYPE_Video || pAMMediaType->formattype != FORMAT_VideoInfo || !pAMMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Which media type is this?
        if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_R263)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwID = R263_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwID = R263_CIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 128 && HEADER(pAMMediaType->pbFormat)->biHeight == 96)
                {
                        *pdwID = R263_SQCIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_R261)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwID = R261_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwID = R261_CIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if 0
STDMETHODIMP CTAPIInputPin::TestH245VidC()
{
        HRESULT Hr = NOERROR;
        DWORD   dw;
        H245MediaCapabilityTable Table;
        H245MediaCapability *pIntersectedCapability;
        AM_MEDIA_TYPE *pAMMediaType;

        FX_ENTRY("CTAPIInputPin::TestH245VidC")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Test GetH245VersionID
        GetH245VersionID(&dw);

        // Test GetFormatTable
        GetFormatTable(&Table);

        for (DWORD i=0; i < Table.uMappedCapabilities; i++)
        {
                // Test Refine
                for (DWORD j=0; j < Table.pCapabilityArray[i].uNumEntries; j++)
                        Refine(&Table.pCapabilityArray[i].h245MediaCapability, Table.pCapabilityArray[i].dwUniqueID, j);

                // Test IntersectFormats
                IntersectFormats(Table.pCapabilityArray[i].dwUniqueID, &Table.pCapabilityArray[i].h245MediaCapability, &Table.pCapabilityArray[i].h245MediaCapability, &pIntersectedCapability);

                // Test GetLocalFormat
                GetLocalFormat(Table.pCapabilityArray[i].dwUniqueID, pIntersectedCapability, &pAMMediaType);

                // Test FindIDByRange
                FindIDByRange(pAMMediaType, &dw);

                // Test ReleaseNegotiatedCapability
                ReleaseNegotiatedCapability(pIntersectedCapability);
        }

        // Test ReleaseFormatTable
        ReleaseFormatTable(&Table);

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\inpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL INPIN
 *
 *  @module InPin.cpp | Source file for the <c CTAPIInputPin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | CTAPIInputPin | This method is the
 *  constructor for the <c CTAPIInputPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIInputPin::CTAPIInputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseInputPin(pObjectName, pDecoderFilter, pLock, pHr, pName)
{
        FX_ENTRY("CTAPIInputPin::CTAPIInputPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Initialize stuff
        m_pDecoderFilter = pDecoderFilter;

        // Initialize to default format: H.263 176x144 at 30 fps
        m_mt = *R26XFormats[0];
        m_dwRTPPayloadType = R26XPayloadTypes[0];
        m_iCurrFormat   = 0L;

        // Frame rate control
        // This should not be based on the capabilities of the machine.
        // These members are only used for read-only operations, and we
        // could receive CIF or SQCIF. In the former case, we could be
        // maxed out at 7 fps but still can receive 30fps. So, we should
        // initialize those values to their potential max.
        m_lMaxAvgTimePerFrame = 333333L;
        m_lCurrentAvgTimePerFrame       = LONG_MAX;
        m_lAvgTimePerFrameRangeMin = 333333L;
        m_lAvgTimePerFrameRangeMax = LONG_MAX;
        m_lAvgTimePerFrameRangeSteppingDelta = 333333L;
        m_lAvgTimePerFrameRangeDefault = 333333L;

        // Bitrate control
        m_lTargetBitrate = 0L;
        m_lCurrentBitrate = 0L;
        m_lBitrateRangeMin = 0L;
        m_lBitrateRangeMax = 1000000;
        m_lBitrateRangeSteppingDelta = 1L;
        m_lBitrateRangeDefault = 0L;

        // H.245 video capabilities
        m_pH245MediaCapabilityMap = NULL;
        m_pVideoResourceBounds = NULL;
        m_pFormatResourceBounds = NULL;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc void | CTAPIInputPin | ~CTAPIInputPin | This method is the
 *    destructor of our input pin. We simply release the pointer to the
 *    <i IH245EncoderCommand> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIInputPin::~CTAPIInputPin()
{
        FX_ENTRY("CTAPIInputPin::~CTAPIInputPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a
 *    pointer to the specified interface if supported. The only interfaces
 *    explicitly supported being <i IOutgoingInterface>,
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IStreamConfig))
        {
                if (FAILED(Hr = GetInterface(static_cast<IStreamConfig*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IStreamConfig failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IStreamConfig*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IOutgoingInterface))
        {
                if (FAILED(Hr = GetInterface(static_cast<IOutgoingInterface*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IOutgoingInterface failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IOutgoingInterface*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
        else if (riid == __uuidof(IH245Capability))
        {
                if (FAILED(Hr = GetInterface(static_cast<IH245Capability*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IH245Capability failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IH245Capability*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IFrameRateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IFrameRateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IFrameRateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IFrameRateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IBitrateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IBitrateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IBitrateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IBitrateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }

        if (FAILED(Hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetPages | This method fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetPages")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        pPages->cElems = 1;
        if (pPages->cElems)
        {
                if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
                else
                {
                        pPages->pElems[0] = __uuidof(TAPIVDecInputPinPropertyPage);
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CFPSINCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Get | This method is used to retrieve
 *    the value of the current or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in
 *    100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Get (FrameRateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plValue);
        ASSERT(plFlags);
        if (!plValue || !plFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

        // Return relevant values
        *plFlags = TAPIControl_Flags_None;
        if (Property == FrameRateControl_Maximum)
                *plValue = m_lMaxAvgTimePerFrame;
        else if (Property == FrameRateControl_Current)
                *plValue = m_lCurrentAvgTimePerFrame;
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSINCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of the current
 *    or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the range values of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in 100-nanosecond units.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetRange (FrameRateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plMin);
        ASSERT(plMax);
        ASSERT(plSteppingDelta);
        ASSERT(plDefault);
        ASSERT(plCapsFlags);
        if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);
        if (Property != FrameRateControl_Maximum && Property != FrameRateControl_Current)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
                goto MyExit;
        }

        // Return relevant values
        *plCapsFlags = TAPIControl_Flags_None;
        *plMin = m_lAvgTimePerFrameRangeMin;
        *plMax = m_lAvgTimePerFrameRangeMax;
        *plSteppingDelta = m_lAvgTimePerFrameRangeSteppingDelta;
        *plDefault = m_lAvgTimePerFrameRangeDefault;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Get | This method is used to retrieve
 *    the current or maximum limit in bandwidth transmission advertized.
 *
 *  @parm BitrateControlProperty | Property | Used to specifiy the property
 *    to retrieve the value of.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in bps.
 *
 *  @parm TAPIControlFlags* | plFlags | Used to receive the value of the flag
 *    associated to the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Get (BitrateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plValue);
        ASSERT(plFlags);
        if (!plValue || !plFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't support multi-layered decoding in this filter
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);

        // Return relevant values
        *plFlags = TAPIControl_Flags_None;
        if (Property == BitrateControl_Maximum)
                *plValue = m_lTargetBitrate;
        else if (Property == BitrateControl_Current)
                *plValue = m_lCurrentBitrate;
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | GetRange | This
 *    method is used to retrieve support, minimum, maximum, and default
 *    values for the upper limit in bandwidth transmission the an output pin
 *    may be setup for.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in bps.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in bps.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in bps.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in bps.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::GetRange (BitrateControlProperty)")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plMin);
        ASSERT(plMax);
        ASSERT(plSteppingDelta);
        ASSERT(plDefault);
        ASSERT(plCapsFlags);
        if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);
        if (Property != BitrateControl_Maximum && Property != BitrateControl_Current)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
                goto MyExit;
        }

        // Return relevant values
        *plCapsFlags = TAPIControl_Flags_None;
        *plMin = m_lBitrateRangeMin;
        *plMax = m_lBitrateRangeMax;
        *plSteppingDelta = m_lBitrateRangeSteppingDelta;
        *plDefault = m_lBitrateRangeDefault;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | Receive | This method is used to retrieve
 *    the next block of data from the stream and call the transform operations
 *    supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIInputPin::Receive(IMediaSample *pIn)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::Receive")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    CAutoLock Lock(&m_pDecoderFilter->m_csReceive);

        // Validate input parameters
        ASSERT(pIn);
        if (!pIn)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Check all is well with the base class
        if ((Hr = CBaseInputPin::Receive(pIn)) == S_OK)
        {
                Hr = m_pDecoderFilter->Transform(pIn, m_lPrefixSize);
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

STDMETHODIMP CTAPIInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);

    if (SUCCEEDED(hr))
    {
        ALLOCATOR_PROPERTIES Property;
        hr = m_pAllocator->GetProperties(&Property);
        
        if (SUCCEEDED(hr))
        {
            m_lPrefixSize = Property.cbPrefix;
        }
    }

    return hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | CheckMediaType | This method is used to
 *    verify that the input pin supports the media type.
 *
 *  @parm const CMediaType* | pmtIn | Specifies a pointer to an input
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIInputPin::CheckMediaType(IN const CMediaType *pmtIn)
{
        HRESULT                 Hr = NOERROR;
        VIDEOINFOHEADER *pVidInfHdr;
        ICOPEN                  icOpen;
        LPINST                  pInstInfo;
        BOOL                    fOpenedDecoder = FALSE;
        ICDECOMPRESSEX  icDecompress = {0};

        FX_ENTRY("CTAPIInputPin::CheckMediaType")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pmtIn);
        if (!pmtIn)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        // We only support MEDIATYPE_Video type and VIDEOINFOHEADER format type
        if (*pmtIn->Type() != MEDIATYPE_Video || !pmtIn->Format() || *pmtIn->FormatType() != FORMAT_VideoInfo)
        {
                Hr = E_INVALIDARG;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: input not a valid video format", _fx_));
                goto MyExit;
        }

        // We only support H.263, H.261, RTP packetized H.263 and RTP packetized H.261.
        if (HEADER(pmtIn->Format())->biCompression != FOURCC_M263 && HEADER(pmtIn->Format())->biCompression != FOURCC_M261 && HEADER(pmtIn->Format())->biCompression != FOURCC_R263 && HEADER(pmtIn->Format())->biCompression != FOURCC_R261)
        {
                Hr = E_INVALIDARG;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: we only support H.263 and H.261", _fx_));
                goto MyExit;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtIn->Format())->biCompression, HEADER(pmtIn->Format())->biBitCount, HEADER(pmtIn->Format())->biWidth, HEADER(pmtIn->Format())->biHeight, HEADER(pmtIn->Format())->biSize));

        pVidInfHdr = (VIDEOINFOHEADER *)pmtIn->Format();

        // Look for a decoder for this format
        if (m_pDecoderFilter->m_FourCCIn != HEADER(pVidInfHdr)->biCompression)
        {
#if DXMRTP <= 0
                // Load TAPIH263.DLL or TAPIH263.DLL and get a proc address
                if (!m_pDecoderFilter->m_hTAPIH26XDLL)
                {
                        if (!(m_pDecoderFilter->m_hTAPIH26XDLL = LoadLibrary(TEXT("TAPIH26X"))))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: TAPIH26X.dll load failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyError;
                        }
                }
                if (!m_pDecoderFilter->m_pDriverProc)
                {
                        if (!(m_pDecoderFilter->m_pDriverProc = (LPFNDRIVERPROC)GetProcAddress(m_pDecoderFilter->m_hTAPIH26XDLL, "DriverProc")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: Couldn't find DriverProc on TAPIH26X.dll!", _fx_));
                                Hr = E_FAIL;
                                goto MyError;
                        }
                }
#else
                if (!m_pDecoderFilter->m_pDriverProc)
        {
            m_pDecoderFilter->m_pDriverProc = H26XDriverProc;
        }
#endif
        
                // Load decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_LOAD\r\n");
#endif
                if (!(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_LOAD, 0L, 0L))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to load decoder", _fx_));
                        Hr = E_FAIL;
                        goto MyError;
                }

                // Open decoder
                icOpen.fccHandler = HEADER(pVidInfHdr)->biCompression;
                icOpen.dwFlags = ICMODE_DECOMPRESS;
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_OPEN\r\n");
#endif
                if (!(pInstInfo = (LPINST)(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_OPEN, 0L, (LPARAM)&icOpen)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to open decoder", _fx_));
                        Hr = E_FAIL;
                        goto MyError1;
                }

                if (pInstInfo)
                        fOpenedDecoder = TRUE;
        }
        else
        {
                pInstInfo = m_pDecoderFilter->m_pInstInfo;
        }

        if (!pInstInfo)
        {
                Hr = VFW_E_NO_DECOMPRESSOR;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't open a decoder", _fx_));
                goto MyError;
        }

        icDecompress.lpbiSrc = HEADER(pVidInfHdr);
        icDecompress.lpbiDst = NULL;
#if defined(ICM_LOGGING) && defined(DEBUG)
        OutputDebugString("CTAPIInputPin::CheckMediaType - ICM_DECOMPRESSEX_QUERY\r\n");
#endif
        if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, ICM_DECOMPRESSEX_QUERY, (long)&icDecompress, NULL))
        {
                Hr = VFW_E_TYPE_NOT_ACCEPTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected input format", _fx_));
                if (fOpenedDecoder)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
                goto MyExit;
        }

        // Remember this decoder to save time if asked again, if it won't interfere with an existing connection.
        // If a connection is broken, we will remember the next decoder.
        if (!IsConnected())
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: caching this decoder", _fx_));
                if (fOpenedDecoder && m_pDecoderFilter->m_pInstInfo)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
                m_pDecoderFilter->m_pInstInfo = pInstInfo;
                m_pDecoderFilter->m_FourCCIn = HEADER(pVidInfHdr)->biCompression;
        }
        else if (fOpenedDecoder)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: not caching decoder - we're connected", _fx_));
                if (fOpenedDecoder && pInstInfo)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_CLOSE\r\n");
                        OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                        (*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
                }
        }

        goto MyExit;

MyError1:
        if (m_pDecoderFilter->m_pDriverProc)
        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIInputPin::CheckMediaType - DRV_FREE\r\n");
#endif
                (*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_FREE, 0L, 0L);
        }
MyError:
        m_pDecoderFilter->m_pDriverProc = NULL;
#if DXMRTP <= 0
        if (m_pDecoderFilter->m_hTAPIH26XDLL)
                FreeLibrary(m_pDecoderFilter->m_hTAPIH26XDLL), m_pDecoderFilter->m_hTAPIH26XDLL = NULL;
#endif
MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIInputPin | SetMediaType | This method is called when
 *    the media type is established for the connection.
 *
 *  @parm const CMediaType* | pmt | Specifies a pointer to a media type
 *    object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Is this the method that I should call when I detect that the
 *    input format data has changed in-band? But I would be streaming at
 *    this point...
 ***************************************************************************/
HRESULT CTAPIInputPin::SetMediaType(IN const CMediaType *pmt)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIInputPin::SetMediaType")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameter
        ASSERT(pmt);
        if (!pmt)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: null pointer argument", _fx_));
                goto MyExit;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_mt.pbFormat)->biCompression, HEADER(m_mt.pbFormat)->biBitCount, HEADER(m_mt.pbFormat)->biWidth, HEADER(m_mt.pbFormat)->biHeight, HEADER(m_mt.pbFormat)->biSize));

        // We better have one of these opened by now
        ASSERT(m_pDecoderFilter->m_pInstInfo);

    Hr = CBaseInputPin::SetMediaType(pmt);

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\inpin.h ===
/****************************************************************************
 *  @doc INTERNAL INPIN
 *
 *  @module InPin.h | Header file for the <c CTAPIInputPin> class methods
 *    used to implement the TAPI base input pin.
 ***************************************************************************/

#ifndef _INPIN_H_
#define _INPIN_H_

#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L

/****************************************************************************
 *  @doc INTERNAL CINPINCLASS
 *
 *  @class CTAPIInputPin | This class implements the TAPI H.26X Video
 *    Decoder input pin.
 *
 *  @mdata CTAPIVCap* | CTAPIInputPin | m_pDecoderFilter | Pointer to the
 *    filter that owns us.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeMin | Minimum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeMax | Maximum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeSteppingDelta | Target
 *    frame rate stepping delta.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_AvgTimePerFrameRangeDefault | Target
 *    frame rate default.
 *
 *  @mdata REFERENCE_TIME | CTAPIInputPin | m_CurrentAvgTimePerFrame | Current
 *    frame rate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeMin | Minimum target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeMax | Maximum target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeSteppingDelta | Target
 *    bitrate stepping delta.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwBitrateRangeDefault | Default target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwMaxBitrate | Target bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwCurrentBitrate | Current bitrate.
 *
 *  @mdata DWORD | CTAPIInputPin | m_dwNumBytesDelivered | Counts number of
 *    bytes delivered, reset every second or so.
 ***************************************************************************/
class CTAPIInputPin : public CBaseInputPin, public IStreamConfig, public IH245Capability, public IOutgoingInterface, public IFrameRateControl, public IBitrateControl
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
{
        public:
        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CTAPIInputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName);
        ~CTAPIInputPin();

        // override CBaseInputPin methods.
        STDMETHODIMP ReceiveCanBlock() {return S_FALSE;};
        STDMETHODIMP Receive(IMediaSample *pSample);
    STDMETHODIMP NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly);

        // CBasePin stuff
        HRESULT GetMediaType(IN int iPosition, IN CMediaType *pmtIn) {return VFW_S_NO_MORE_ITEMS;};
        HRESULT CheckMediaType(IN const CMediaType *pmtIn);
        HRESULT SetMediaType(IN const CMediaType *pmt);

        // Implement IStreamConfig
        STDMETHODIMP SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType);
        STDMETHODIMP GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType);
        STDMETHODIMP GetNumberOfCapabilities(OUT DWORD *pdwCount);
        STDMETHODIMP GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD * pdwRTPPayLoadType);

#ifdef USE_PROPERTY_PAGES
        // ISpecifyPropertyPages methods
        STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

        // Implement IH245Capability
        STDMETHODIMP GetH245VersionID(OUT DWORD *pdwVersionID);
        STDMETHODIMP GetFormatTable(OUT H245MediaCapabilityTable *pTable);
        STDMETHODIMP ReleaseFormatTable(IN H245MediaCapabilityTable *pTable);
        STDMETHODIMP IntersectFormats(
        IN DWORD dwUniqueID, 
        IN const H245MediaCapability *pLocalCapability, 
        IN const H245MediaCapability *pRemoteCapability, 
        OUT H245MediaCapability **ppIntersectedCapability,
        OUT DWORD *pdwPayloadType
        );
        STDMETHODIMP Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex);
        STDMETHODIMP GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType);
        STDMETHODIMP ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability);
        STDMETHODIMP FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwID);
#if 0
        STDMETHODIMP TestH245VidC();
#endif

        // Implement IFrameRateControl
        STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
        STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) { return E_NOTIMPL;};
        STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);

        // Implement IBitrateControl
        STDMETHODIMP GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId);
        STDMETHODIMP Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId) { return E_NOTIMPL;};
        STDMETHODIMP Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId);

        // Implement IOutgoingInterface
        STDMETHODIMP Set(IN IH245EncoderCommand *pIH245EncoderCommand);

        protected:

        friend class CTAPIVDec;
        friend class CTAPIOutputPin;

        CTAPIVDec *m_pDecoderFilter;

        // Formats
        int             m_iCurrFormat;
        DWORD   m_dwRTPPayloadType;
    LONG    m_lPrefixSize;

        // Frame rate control
        LONG m_lAvgTimePerFrameRangeMin;
        LONG m_lAvgTimePerFrameRangeMax;
        LONG m_lAvgTimePerFrameRangeSteppingDelta;
        LONG m_lAvgTimePerFrameRangeDefault;
        LONG m_lMaxAvgTimePerFrame;
        LONG m_lCurrentAvgTimePerFrame;

        // Bitrate control
        LONG m_lBitrateRangeMin;
        LONG m_lBitrateRangeMax;
        LONG m_lBitrateRangeSteppingDelta;
        LONG m_lBitrateRangeDefault;
        LONG m_lTargetBitrate;
        LONG m_lCurrentBitrate;

        // H.245 Video Capabilities
        H245MediaCapabilityMap  *m_pH245MediaCapabilityMap;
        VideoResourceBounds             *m_pVideoResourceBounds;
        FormatResourceBounds    *m_pFormatResourceBounds;
};

#endif // _INPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\outpinp.cpp ===
/****************************************************************************
 *  @doc INTERNAL OUTPINP
 *
 *  @module OutPinP.cpp | Source file for the <c COutputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i ICPUControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperty | COutputPinProperty | This
 *    method is the constructor for control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the control interface(s).
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @parm ICPUControl* | pICPUControl | Specifies a pointer to the
 *    <i ICPUControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
#ifdef USE_CPU_CONTROL
COutputPinProperty::COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, ICPUControl *pICPUControl)
#else
COutputPinProperty::COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl)
#endif
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("COutputPinProperty::COutputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pIFrameRateControl = pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	m_pICPUControl   = pICPUControl;
#endif

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperty | ~COutputPinProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperty::~COutputPinProperty()
{
	FX_ENTRY("COutputPinProperty::~COutputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::GetValue()
{
	HRESULT Hr = NOERROR;
	LONG CurrentValue;

	FX_ENTRY("COutputPinProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case CurrentDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_CurrentProcessingTime, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				// Displayed in ms instead of 100ns
				m_CurrentValue = CurrentValue / 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentProcessingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_CurrentCPULoad, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		case TargetFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Maximum, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_MaxProcessingTime, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				// Displayed in ms instead of 100ns
				m_CurrentValue = CurrentValue / 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwProcessingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Get(CPUControl_MaxCPULoad, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("COutputPinProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case TargetFrameRate:
			if (m_CurrentValue)
				CurrentValue = 10000000L / m_CurrentValue;
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Set(FrameRateControl_Maximum, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: AvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			// Displayed in ms instead of 100ns
			CurrentValue = m_CurrentValue * 10000;
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Set(CPUControl_MaxProcessingTime, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: dwMaxDecodingTime=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->Set(CPUControl_MaxCPULoad, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: dwMaxCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("COutputPinProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case TargetFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Maximum, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case TargetDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_MaxProcessingTime, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				// Displayed in ms instead of 100ns
				m_Min /= 10000;
				m_Max /= 10000;
				m_SteppingDelta /= 10000;
				m_DefaultValue /= 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case TargetCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_MaxCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#ifdef USE_CPU_CONTROL
		case CurrentDecodingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_CurrentProcessingTime, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				// Displayed in ms instead of 100ns
				m_Min /= 10000;
				m_Max /= 10000;
				m_SteppingDelta /= 10000;
				m_DefaultValue /= 10000;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetRange(CPUControl_CurrentCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
#endif
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc CUnknown* | COutputPinProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK COutputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("COutputPinPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new COutputPinProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: new COutputPinProperties failed"), _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: new COutputPinProperties created"), _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperties | COutputPinProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperties::COutputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Output Pin Property Page"), pUnk, IDD_OutputPinProperties, IDS_OUTPUTPINPROPNAME)
{
	FX_ENTRY("COutputPinProperties::COutputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	m_pIFrameRateControl = NULL;
#ifdef USE_CPU_CONTROL
	m_pICPUControl = NULL;
#endif
	m_pIH245DecoderCommand = NULL;
	m_NumProperties = NUM_OUTPUT_PIN_PROPERTIES;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc void | COutputPinProperties | ~COutputPinProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COutputPinProperties::~COutputPinProperties()
{
	int		j;

	FX_ENTRY("COutputPinProperties::~COutputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COutputPinProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl),(void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIFrameRateControl=0x%08lX"), _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

#ifdef USE_CPU_CONTROL
	// Get the bitrate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICPUControl),(void **)&m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pICPUControl=0x%08lX"), _fx_, m_pICPUControl));
	}
	else
	{
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}
#endif

	// Get the H.245 decoder command interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IH245DecoderCommand),(void **)&m_pIH245DecoderCommand)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIH245DecoderCommand=0x%08lX"), _fx_, m_pIH245DecoderCommand));
	}
	else
	{
		m_pIH245DecoderCommand = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnDisconnect()
{
	FX_ENTRY("COutputPinProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIFrameRateControl"), _fx_));
	}

#ifdef USE_CPU_CONTROL
	if (!m_pICPUControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pICPUControl->Release();
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pICPUControl"), _fx_));
	}
#endif

	if (!m_pIH245DecoderCommand)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIH245DecoderCommand->Release();
		m_pIH245DecoderCommand = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIH245DecoderCommand"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("COutputPinProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
#ifdef USE_CPU_CONTROL
	if (!(m_Controls[0] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new COutputPinProperty(m_hwnd, IDC_MaxProcessingTime_Label, 0, 0, 0, 0, IDC_MaxProcessingTime_Actual, 0, IDC_MaxProcessingTime_Meter, CurrentDecodingTime, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentDecodingTime] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentDecodingTime]=0x%08lX"), _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new COutputPinProperty(m_hwnd, IDC_CPULoad_Label, 0, 0, 0, 0, IDC_CPULoad_Actual, 0, IDC_CPULoad_Meter, CurrentCPULoad, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentCPULoad] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentCPULoad]=0x%08lX"), _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, TargetFrameRate, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetFrameRate] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetFrameRate]=0x%08lX"), _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new COutputPinProperty(m_hwnd, IDC_MaxProcessingTime_Label, IDC_MaxProcessingTime_Minimum, IDC_MaxProcessingTime_Maximum, IDC_MaxProcessingTime_Default, IDC_MaxProcessingTime_Stepping, IDC_MaxProcessingTime_Edit, IDC_MaxProcessingTime_Slider, 0, TargetDecodingTime, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetDecodingTime] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetDecodingTime]=0x%08lX"), _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new COutputPinProperty(m_hwnd, IDC_CPULoad_Label, IDC_CPULoad_Minimum, IDC_CPULoad_Maximum, IDC_CPULoad_Default, IDC_CPULoad_Stepping, IDC_CPULoad_Edit, IDC_CPULoad_Slider, 0, TargetCPULoad, 0, m_pIFrameRateControl, m_pICPUControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetCPULoad] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetCPULoad]=0x%08lX"), _fx_, m_Controls[5]));
	}
#else
	if (!(m_Controls[0] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new COutputPinProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, TargetFrameRate, 0, m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[TargetFrameRate] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[TargetFrameRate]=0x%08lX"), _fx_, m_Controls[1]));
	}
#endif

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the filter. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

#ifdef USE_CPU_CONTROL
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
#endif
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("COutputPinProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc HRESULT | COutputPinProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COutputPinProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("COutputPinProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc BOOL | COutputPinProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL COutputPinProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				// OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;
					case IDC_Freeze_Picture_Request:
						if (m_pIH245DecoderCommand)
							m_pIH245DecoderCommand->videoFreezePicture();
						break;
					default:
						break;
				}

			// OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINPMETHOD
 *
 *  @mfunc BOOL | COutputPinProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void COutputPinProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\inpinp.cpp ===
/****************************************************************************
 *  @doc INTERNAL INPINP
 *
 *  @module InPinP.cpp | Source file for the <c CInputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperty | CInputPinProperty | This
 *    method is the constructor for control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the control interface(s).
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @parm IBitrateControl* | pIBitrateControl | Specifies a pointer to the
 *    <i IBitrateControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperty::CInputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, IBitrateControl *pIBitrateControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CInputPinProperty::CInputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pIFrameRateControl = pIFrameRateControl;
	m_pIBitrateControl   = pIBitrateControl;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperty | ~CInputPinProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperty::~CInputPinProperty()
{
	FX_ENTRY("CInputPinProperty::~CInputPinProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::GetValue()
{
	HRESULT Hr = NOERROR;
	LONG CurrentValue;

	FX_ENTRY("CInputPinProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->Get(BitrateControl_Current, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags, 0UL)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwCurrentBitrate=%ld, dwLayerId=0"), _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CInputPinProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// This is a read-only property. Don't do anything.

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("CInputPinProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->GetRange(BitrateControl_Current, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags, 0UL)))
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld, dwLayerId=0"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc CUnknown* | CInputPinProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CInputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CInputPinPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CInputPinProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: new CInputPinProperties failed"), _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: new CInputPinProperties created"), _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperties | CInputPinProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperties::CInputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Input Pin Property Page"), pUnk, IDD_InputPinProperties, IDS_INPUTPINPROPNAME)
{
	FX_ENTRY("CInputPinProperties::CInputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	m_pIFrameRateControl = NULL;
	m_pIBitrateControl = NULL;
	m_NumProperties = NUM_INPUT_PIN_PROPERTIES;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc void | CInputPinProperties | ~CInputPinProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CInputPinProperties::~CInputPinProperties()
{
	int		j;

	FX_ENTRY("CInputPinProperties::~CInputPinProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CInputPinProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl),(void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIFrameRateControl=0x%08lX"), _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// Get the bitrate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IBitrateControl),(void **)&m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_pIBitrateControl=0x%08lX"), _fx_, m_pIBitrateControl));
	}
	else
	{
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnDisconnect()
{
	FX_ENTRY("CInputPinProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIFrameRateControl"), _fx_));
	}

	if (!m_pIBitrateControl)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pIBitrateControl->Release();
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: releasing m_pIBitrateControl"), _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CInputPinProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CInputPinProperty(m_hwnd, IDC_FrameRateControl_Label, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, CurrentFrameRate, 0, m_pIFrameRateControl, m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentFrameRate] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentFrameRate]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CInputPinProperty(m_hwnd, IDC_BitrateControl_Label, 0, 0, 0, 0, IDC_BitrateControl_Actual, 0, IDC_BitrateControl_Meter, CurrentBitrate, 0, m_pIFrameRateControl, m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: mew m_Controls[CurrentBitrate] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[CurrentBitrate]=0x%08lX"), _fx_, m_Controls[1]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the filter. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CInputPinProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc HRESULT | CInputPinProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CInputPinProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CInputPinProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc BOOL | CInputPinProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CInputPinProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
						SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CINPINPMETHOD
 *
 *  @mfunc BOOL | CInputPinProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CInputPinProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\outpin.cpp ===
/****************************************************************************
 *  @doc INTERNAL OUTPIN
 *
 *  @module OutPin.cpp | Source file for the <c CTAPIOutputPin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#include "Precomp.h"

// Default CPU load for decoding a frame (in %)
#define DEFAULT_CPU_LOAD 85

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | CTAPIOutputPin | This method is the
 *  constructor for the <c CTAPIOutputPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
#if 0
CTAPIOutputPin::CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPinEx(pObjectName, pDecoderFilter, pLock, pHr, pName)
#else
CTAPIOutputPin::CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPin(pObjectName, pDecoderFilter, pLock, pHr, pName)
#endif
{
	FX_ENTRY("CTAPIOutputPin::CTAPIOutputPin")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Initialize stuff
	m_pDecoderFilter = pDecoderFilter;

#ifdef USE_CPU_CONTROL
	// CPU control
	m_lMaxProcessingTime = 333333L;
	m_lCurrentProcessingTime = 0;
	m_lMaxCPULoad = DEFAULT_CPU_LOAD;
	m_lCurrentCPULoad = 0UL;
#endif

	// Frame rate control
	// This should not be based on the capabilities of the machine.
	// We could receive CIF or SQCIF. In the former case, we could be
	// maxed out at 7 fps but still can render 30fps. So, we should
	// initialize those values to their potential max.
	m_lMaxAvgTimePerFrame = 333333L;
	m_lCurrentAvgTimePerFrame = 333333L;
	m_lAvgTimePerFrameRangeMin = 333333L;
	m_lAvgTimePerFrameRangeMax = 10000000L;
	m_lAvgTimePerFrameRangeSteppingDelta = 333333L;
	m_lAvgTimePerFrameRangeDefault = 333333L;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc void | CTAPIOutputPin | ~CTAPIOutputPin | This method is the
 *    destructor of our output pin.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIOutputPin::~CTAPIOutputPin()
{
	FX_ENTRY("CTAPIOutputPin::~CTAPIOutputPin")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a
 *    pointer to the specified interface if supported. The only interfaces
 *    explicitly supported being <i ICPUControl>, <i IFrameRateControl>
 *    and <i IH245DecoderCommand>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::NonDelegatingQueryInterface")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ppv);
	if (!ppv)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Retrieve interface pointer
	if (riid == __uuidof(IH245DecoderCommand))
	{
		if (FAILED(Hr = GetInterface(static_cast<IH245DecoderCommand*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IH245DecoderCommand failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IH245DecoderCommand*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#ifdef USE_PROPERTY_PAGES
	else if (riid == IID_ISpecifyPropertyPages)
	{
		if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#endif
	else if (riid == __uuidof(IFrameRateControl))
	{
		if (FAILED(Hr = GetInterface(static_cast<IFrameRateControl*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IFrameRateControl failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IFrameRateControl*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#ifdef USE_CPU_CONTROL
	else if (riid == __uuidof(ICPUControl))
	{
		if (FAILED(Hr = GetInterface(static_cast<ICPUControl*>(this), ppv)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ICPUControl failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ICPUControl*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
#endif

	if (FAILED(Hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetPages | This method fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetPages(OUT CAUUID *pPages)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetPages")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pPages);
	if (!pPages)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	pPages->cElems = 1;
	if (pPages->cElems)
	{
		if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
			Hr = E_OUTOFMEMORY;
		}
		else
		{
			pPages->pElems[0] = __uuidof(TAPIVDecOutputPinPropertyPage);
		}
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Set | This method is used to set the
 *    value of a frame rate control property.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to set the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the frame rate control
 *    setting.
 *
 *  @parm TAPIControlFlags | lFlags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Set (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(lValue >= m_lAvgTimePerFrameRangeMin);
	ASSERT(lValue <= m_lAvgTimePerFrameRangeMax);
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Set relevant values
	if (Property == FrameRateControl_Maximum)
	{
		if (!lValue || lValue < m_lAvgTimePerFrameRangeMin || lValue > m_lAvgTimePerFrameRangeMax)
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
			Hr = E_INVALIDARG;
			goto MyExit;
		}
		m_lMaxAvgTimePerFrame = lValue;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   New target frame rate: %ld.%ld fps", _fx_, 10000000/m_lMaxAvgTimePerFrame, 1000000000/m_lMaxAvgTimePerFrame - (10000000/m_lMaxAvgTimePerFrame) * 100));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Get | This method is used to retrieve
 *    the value of the current or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the value of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in
 *    100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Get (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Return relevant values
	*plFlags = TAPIControl_Flags_None;
	if (Property == FrameRateControl_Maximum)
		*plValue = m_lMaxAvgTimePerFrame;
	else if (Property == FrameRateControl_Current)
		*plValue = m_lCurrentAvgTimePerFrame;
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSOUTCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of the current
 *    or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specify the frame rate
 *    control setting to get the range values of. Use a member of the
 *    <t FrameRateControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in 100-nanosecond units.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Pointer to a member of the
 *     <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetRange (FrameRateControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);
	if (Property != FrameRateControl_Maximum && Property != FrameRateControl_Current)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	// Return relevant values
	*plCapsFlags = TAPIControl_Flags_None;
	*plMin = m_lAvgTimePerFrameRangeMin;
	*plMax = m_lAvgTimePerFrameRangeMax;
	*plSteppingDelta = m_lAvgTimePerFrameRangeSteppingDelta;
	*plDefault = m_lAvgTimePerFrameRangeDefault;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#ifdef USE_CPU_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Set | This method is used to set the
 *    value of a CPU control property.
 *
 *  @parm CPUControlProperty | Property | Used to specify the CPU
 *    control setting to set the value of. Use a member of the
 *    <t CPUControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the CPU control
 *    setting.
 *
 *  @parm TAPIControlFlags | lFlags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Set (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Set relevant values
	switch(Property)
	{
#if 0
		case CPUControl_MaxCPULoad:

			// Validate input parameters
			ASSERT(lValue >= 0 && lValue <= 100);
			if (!(lValue >= 0 && lValue <= 100))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument - 0<Max CPU Load<100", _fx_));
				Hr = E_INVALIDARG;
				goto MyExit;
			}

			// Remember value passed in
			m_lMaxCPULoad = lValue;
			break;

		case CPUControl_MaxProcessingTime:

			// Validate input parameters - we can't take more than the picture interval
			// if we still want to be working in real time
			ASSERT(lValue < m_lMaxAvgTimePerFrame);
			if (!(lValue < m_lMaxAvgTimePerFrame))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument - would break real-time!", _fx_));
				Hr = E_INVALIDARG;
				goto MyExit;
			}

			// Remember value passed in 
			m_lMaxProcessingTime = lValue;
			break;
#endif
		case CPUControl_CurrentCPULoad:
		case CPUControl_CurrentProcessingTime:

			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is read-only", _fx_));
			Hr = E_INVALIDARG;
			goto MyExit;

		default:
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is not supported", _fx_));
			Hr = E_PROP_ID_UNSUPPORTED;
			goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Value=%ld", _fx_, lValue));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | Get | This method is used to retrieve
 *    the value of a CPU control property.
 *
 *  @parm CPUControlProperty | Property | Used to specify the CPU
 *    control setting to get the value of. Use a member of the
 *    <t CPUControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to receive the value of the property.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Get (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Return relevant values
	*plFlags = TAPIControl_Flags_None;
	switch(Property)
	{
#if 0
		case CPUControl_MaxCPULoad:
			*plValue = m_lMaxCPULoad;
			break;

		case CPUControl_MaxProcessingTime:
			*plValue = m_lMaxProcessingTime;
			break;
#endif
		case CPUControl_CurrentCPULoad:
			*plValue = m_lCurrentCPULoad;
			break;

		case CPUControl_CurrentProcessingTime:
			*plValue = m_lCurrentProcessingTime;
			break;

		default:
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument - Property is not supported", _fx_));
			Hr = E_PROP_ID_UNSUPPORTED;
			goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Value=%ld", _fx_, *plValue));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of a CPU control
 *    property.
 *
 *  @parm CPUControlProperty | Property | Used to specifiy the CPU control
 *    property to retrieve the range values of.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 *
 *  @comm We don't support CPUControl_MaxCPULoad and CPUControl_MaxProcessingTime.
 ***************************************************************************/
STDMETHODIMP CTAPIOutputPin::GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetRange (CPUControlProperty)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= CPUControl_MaxCPULoad && Property <= CPUControl_CurrentProcessingTime);

	// Return relevant values
	*plCapsFlags = TAPIControl_Flags_None;
#if 0
	if (Property == CPUControl_MaxCPULoad || Property == CPUControl_CurrentCPULoad)
#else
	if (Property == CPUControl_CurrentCPULoad)
#endif
	{
		*plMin = 0;
		*plMax = 100;
		*plSteppingDelta = 1;
		*plDefault = DEFAULT_CPU_LOAD;
	}
#if 0
	else if (Property == CPUControl_MaxProcessingTime || Property == CPUControl_CurrentProcessingTime)
#else
	else if (Property == CPUControl_CurrentProcessingTime)
#endif
	{
		*plMin = 0;
		*plMax = m_lMaxAvgTimePerFrame;
		*plSteppingDelta = 1;
		*plDefault = m_lMaxAvgTimePerFrame;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | GetMediaType | This method is called when
 *    enumerating the media type the output pin supports. It checks the
 *    current display mode to device which of the RGB types to return.
 *
 *  @parm int | iPosition | Specifies the position of the media type in the
 *    media type list.
 *
 *  @parm CMediaType* | pmt | Specifies a pointer pointer to the returned
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
	HRESULT				Hr = NOERROR;
	HDC					hDC;
	int					nBPP;
	LPBITMAPINFOHEADER	lpbi;
	LARGE_INTEGER		li;
	FOURCCMap			fccHandler;
	VIDEOINFOHEADER		*pf;

	FX_ENTRY("CTAPIOutputPin::GetMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    // we can't lock the filter here because of a deadlock.
    // On the receive path, if there is a format change, the video allocator
    // calls back into this function holding the receive lock. If the graph is
    // being stopped at the same time, the other thead will lock the filter and
    // try to lock the receive lock. A simple fix is to remove this lock and
    // assume that no one is going to call this method and disconnect the input
    // pin at the same time.
    //CAutoLock Lock(&m_pDecoderFilter->m_csFilter);

	// Validate input parameters
	ASSERT(iPosition >= 0);
	ASSERT(pMediaType);
	if (iPosition < 0)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid iPosition argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}
	if (!pMediaType)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
    if (!m_pDecoderFilter->m_pInput->m_mt.IsValid())
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid input pin format", _fx_));
		Hr = E_FAIL;
		goto MyExit;
    }

	// Get the current bitdepth
	hDC = GetDC(NULL);
	nBPP = GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES);
	ReleaseDC(NULL, hDC);

	// Get most of the format attributes from the input format and override the appropriate fields
	*pMediaType = m_pDecoderFilter->m_pInput->m_mt;

#ifndef NO_YUV_MODES
	if (iPosition == 0)
	{
		// YUY2
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_YUY2;
		lpbi->biBitCount = 16;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_YUY2);
	}
	else if (iPosition == 1)
	{
		// UYVY
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_UYVY;
		lpbi->biBitCount = 16;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_UYVY);
	}
	else if (iPosition == 2)
	{
		// I420
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_I420;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_I420);
	}
	else if (iPosition == 3)
	{
		// IYUV
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_IYUV;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_IYUV);
	}
	else if (iPosition == 4)
	{
		// YV12
		pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
		lpbi = HEADER(pMediaType->Format());
		lpbi->biSize = sizeof(BITMAPINFOHEADER);
		lpbi->biCompression = FOURCC_YV12;
		lpbi->biBitCount = 12;
		lpbi->biClrUsed = 0;
		lpbi->biClrImportant = 0;
		lpbi->biSizeImage = DIBSIZE(*lpbi);
		pMediaType->SetSubtype(&MEDIASUBTYPE_YV12);
	}
	else
	{
#endif
		// Configure the bitmap info header based on the bit depth of the screen
	    switch (nBPP)
		{
		    case 32:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 32;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
			        pMediaType->SetSubtype(&MEDIASUBTYPE_RGB32);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    case 16:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					if (FAILED(pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS)))
					{
						DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
						Hr = E_OUTOFMEMORY;
						goto MyExit;
					}
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_BITFIELDS;
					lpbi->biBitCount = 16;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);

					DWORD *pdw = (DWORD *)(lpbi+1);
					pdw[iRED]	= 0x00F800;
					pdw[iGREEN]	= 0x0007E0;
					pdw[iBLUE]	= 0x00001F;

					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB565);
				}
#ifndef NO_YUV_MODES
				else if (iPosition == 6)
#else
				else if (iPosition == 1)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 16;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB555);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    case 8:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					if (FAILED(pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_PALETTE)))
					{
						DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
						Hr = E_OUTOFMEMORY;
						goto MyExit;
					}
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 8;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);

					ASSERT(m_pDecoderFilter->m_pInstInfo);

					// Get the Indeo palette from the decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
					OutputDebugString("CTAPIOutputPin::GetMediaType - ICM_DECOMPRESS_GET_PALETTE\r\n");
#endif
					(*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESS_GET_PALETTE, (long)HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat), (long)lpbi);

					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB8);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }

		    default:
		    {
#ifndef NO_YUV_MODES
				if (iPosition == 5)
#else
				if (iPosition == 0)
#endif
				{
					pMediaType->ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
					lpbi = HEADER(pMediaType->Format());
					lpbi->biSize = sizeof(BITMAPINFOHEADER);
					lpbi->biCompression = BI_RGB;
					lpbi->biBitCount = 24;
					lpbi->biClrUsed = 0;
					lpbi->biClrImportant = 0;
					lpbi->biSizeImage = DIBSIZE(*lpbi);
					pMediaType->SetSubtype(&MEDIASUBTYPE_RGB24);
				}
				else
				{
					Hr = VFW_S_NO_MORE_ITEMS;
					goto MyExit;
				}
		        break;
		    }
		}
#ifndef NO_YUV_MODES
	}
#endif

    // Now set the common things about the media type
    pf = (VIDEOINFOHEADER *)pMediaType->Format();
#if 1
    pf->AvgTimePerFrame = ((VIDEOINFOHEADER *)m_pDecoderFilter->m_pInput->m_mt.pbFormat)->AvgTimePerFrame;
    li.QuadPart = pf->AvgTimePerFrame;
    if (li.LowPart)
        pf->dwBitRate = MulDiv(pf->bmiHeader.biSizeImage, 80000000, li.LowPart);
#else
    pf->AvgTimePerFrame = 0;
    pf->dwBitRate = 0;
#endif
    pf->dwBitErrorRate = 0L;
	pf->rcSource.top = 0;
	pf->rcSource.left = 0;
	pf->rcSource.right = lpbi->biWidth;
	pf->rcSource.bottom = lpbi->biHeight;
	pf->rcTarget = pf->rcSource;
	pMediaType->SetType(&MEDIATYPE_Video);
    pMediaType->SetSampleSize(pf->bmiHeader.biSizeImage);
    pMediaType->SetFormatType(&FORMAT_VideoInfo);
    pMediaType->SetTemporalCompression(FALSE);

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pMediaType->Format())->biCompression, HEADER(pMediaType->Format())->biBitCount, HEADER(pMediaType->Format())->biWidth, HEADER(pMediaType->Format())->biHeight, HEADER(pMediaType->Format())->biSize));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | SetMediaType | This method is called when
 *    the media type is established for the connection.
 *
 *  @parm const CMediaType* | pmt | Specifies a pointer to a media type
 *    object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::SetMediaType(IN const CMediaType *pmt)
{
	HRESULT			Hr = NOERROR;
	ICDECOMPRESSEX	icDecompress;

	FX_ENTRY("CTAPIOutputPin::SetMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameter
	ASSERT(pmt);
	if (!pmt)
	{
		Hr = E_POINTER;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: null pointer argument", _fx_));
		goto MyExit;
	}

	// Save the output format
	if (FAILED(Hr = CBaseOutputPin::SetMediaType(pmt)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: couldn't set format", _fx_));
		goto MyExit;
	}

	if (m_pDecoderFilter->m_pMediaType)
		DeleteMediaType(m_pDecoderFilter->m_pMediaType);

	m_pDecoderFilter->m_pMediaType = CreateMediaType(&m_mt);

	icDecompress.lpbiSrc = HEADER(m_pDecoderFilter->m_pInput->m_mt.Format());
	icDecompress.lpbiDst = HEADER(m_pDecoderFilter->m_pMediaType->pbFormat);
	icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left;
	icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top;
	icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left;
	icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top;
	icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left;
	icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top;
	icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left;
	icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcSource.bottom));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pMediaType->pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pDecoderFilter->m_pMediaType->pbFormat))->rcTarget.bottom));

	// Terminate current H.26X decompression configuration
	if (m_pDecoderFilter->m_fICMStarted)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::SetMediaType - ICM_DECOMPRESSEX_END\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
		m_pDecoderFilter->m_fICMStarted = FALSE;
	}

	// Create a new H.26X decompression configuration
#if defined(ICM_LOGGING) && defined(DEBUG)
	OutputDebugString("CTAPIOutputPin::SetMediaType - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
	if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)m_pDecoderFilter->m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
		Hr = E_FAIL;
	}
	m_pDecoderFilter->m_fICMStarted = TRUE;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | CheckMediaType | This method is used to
 *    verify that the output pin supports the media types.
 *
 *  @parm const CMediaType* | pmtOut | Specifies a pointer to an output
 *    media type object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::CheckMediaType(IN const CMediaType* pmtOut)
{
	HRESULT			Hr = NOERROR;
	ICOPEN			icOpen;
	LPINST			pInstInfo;
	BOOL			fOpenedDecoder = FALSE;
    VIDEOINFO		*pDstInfo;
    VIDEOINFO		*pSrcInfo;
	ICDECOMPRESSEX	icDecompress = {0};

	FX_ENTRY("CTAPIOutputPin::CheckMediaType")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pmtOut);
	if (!m_pDecoderFilter->m_pInput->m_mt.pbFormat || !pmtOut || !pmtOut->Format())
	{
		Hr = E_POINTER;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	// We only support the MEDIATYPE_Video type and VIDEOINFOHEADER format type
	ASSERT(!(m_pDecoderFilter->m_pInput->m_mt.majortype != MEDIATYPE_Video || m_pDecoderFilter->m_pInput->m_mt.formattype != FORMAT_VideoInfo || *pmtOut->Type() != MEDIATYPE_Video || *pmtOut->FormatType() != FORMAT_VideoInfo));
	if (m_pDecoderFilter->m_pInput->m_mt.majortype != MEDIATYPE_Video || m_pDecoderFilter->m_pInput->m_mt.formattype != FORMAT_VideoInfo || *pmtOut->Type() != MEDIATYPE_Video || *pmtOut->FormatType() != FORMAT_VideoInfo)
	{
		Hr = E_INVALIDARG;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: input not a valid video format", _fx_));
		goto MyExit;
	}

	// We only support H.263, H.261, RTP packetized H.263 and RTP packetized H.261.
	ASSERT(HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_M263 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_M261 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261);
	if (HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_M263 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_M261 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R263 && HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R261)
	{
		Hr = E_INVALIDARG;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: we only support H.263, H.261, RTP H.261, and RTP H.263", _fx_));
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.right, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.bottom));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtOut->Format())->biCompression, HEADER(pmtOut->Format())->biBitCount, HEADER(pmtOut->Format())->biWidth, HEADER(pmtOut->Format())->biHeight, HEADER(pmtOut->Format())->biSize));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.right, ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.bottom));

	// Look for a decoder for this format
	if (m_pDecoderFilter->m_FourCCIn != HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression)
	{
#if DXMRTP <= 0
		// Load TAPIH26X.DLL and get a proc address
		if (!m_pDecoderFilter->m_hTAPIH26XDLL)
		{
			if (!(m_pDecoderFilter->m_hTAPIH26XDLL = LoadLibrary(TEXT("TAPIH26X"))))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: TAPIH26X.dll load failed!", _fx_));
				Hr = E_FAIL;
				goto MyError;
			}
		}
		if (!m_pDecoderFilter->m_pDriverProc)
		{
			if (!(m_pDecoderFilter->m_pDriverProc = (LPFNDRIVERPROC)GetProcAddress(m_pDecoderFilter->m_hTAPIH26XDLL, "DriverProc")))
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: Couldn't find DriverProc on TAPIH26X.dll!", _fx_));
				Hr = E_FAIL;
				goto MyError;
			}
		}
#else
		if (!m_pDecoderFilter->m_pDriverProc)
		{
            m_pDecoderFilter->m_pDriverProc = H26XDriverProc; 
        }        
#endif
		// Load decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_LOAD\r\n");
#endif
		if (!(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_LOAD, 0L, 0L))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to load decoder", _fx_));
			Hr = E_FAIL;
			goto MyError;
		}

		// Open decoder
		icOpen.fccHandler = HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biCompression;
		icOpen.dwFlags = ICMODE_DECOMPRESS;
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_OPEN\r\n");
#endif
		if (!(pInstInfo = (LPINST)(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_OPEN, 0L, (LPARAM)&icOpen)))
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Failed to open decoder", _fx_));
			Hr = E_FAIL;
			goto MyError1;
		}

		if (pInstInfo)
			fOpenedDecoder = TRUE;
	}
	else
	{
		pInstInfo = m_pDecoderFilter->m_pInstInfo;
	}

	if (!pInstInfo)
	{
		Hr = VFW_E_NO_DECOMPRESSOR;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't open a decoder", _fx_));
		goto MyExit;
	}

	icDecompress.lpbiSrc = HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat);
	icDecompress.lpbiDst = HEADER(pmtOut->Format());
	icDecompress.xSrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left;
	icDecompress.ySrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top;
	icDecompress.dxSrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.right - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.left;
	icDecompress.dySrc = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.bottom - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcSource.top;
	icDecompress.xDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left;
	icDecompress.yDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top;
	icDecompress.dxDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.right - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.left;
	icDecompress.dyDst = ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.bottom - ((VIDEOINFOHEADER *)(pmtOut->Format()))->rcTarget.top;
#if 0
	if (icDecompress.lpbiDst->biCompression != FOURCC_YUY2)
	{
		Hr = VFW_E_TYPE_NOT_ACCEPTED;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected formats", _fx_));
		goto MyExit;
	}
#endif

#if defined(ICM_LOGGING) && defined(DEBUG)
	OutputDebugString("CTAPIOutputPin::CheckMediaType - ICM_DECOMPRESSEX_QUERY\r\n");
#endif
	if ((*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, ICM_DECOMPRESSEX_QUERY, (long)&icDecompress, NULL))
	{
		Hr = VFW_E_TYPE_NOT_ACCEPTED;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: decoder rejected formats", _fx_));
	}

    // See if we can use direct draw.
    pDstInfo = (VIDEOINFO *)pmtOut->Format();
    pSrcInfo = (VIDEOINFO *)m_pDecoderFilter->m_pInput->m_mt.pbFormat;

    // First check that there is a non empty target and source rectangles.
    if (IsRectEmpty(&pDstInfo->rcSource) == TRUE)
	{
        ASSERT(IsRectEmpty(&pDstInfo->rcTarget) == TRUE);
        if (pSrcInfo->bmiHeader.biWidth != HEADER(pmtOut->Format())->biWidth || pSrcInfo->bmiHeader.biHeight != abs(HEADER(pmtOut->Format())->biHeight))
		{
			Hr = VFW_E_TYPE_NOT_ACCEPTED;
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't stretch formats", _fx_));
        }
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Not using DDraw", _fx_));
        }
    }
	else if (!IsRectEmpty(&pDstInfo->rcTarget))
	{
		// Next, check that the source rectangle is the entire image.
		if (pDstInfo->rcSource.left == 0 && pDstInfo->rcSource.top == 0 && pDstInfo->rcSource.right == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth && pDstInfo->rcSource.bottom == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight)
		{
			// Now check that the target rectangles size is the same as the image size
			long lWidth = pDstInfo->rcTarget.right - pDstInfo->rcTarget.left;
			long lDepth = pDstInfo->rcTarget.bottom - pDstInfo->rcTarget.top;

			if (lWidth == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biWidth && lDepth == HEADER(m_pDecoderFilter->m_pInput->m_mt.pbFormat)->biHeight)
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Using DDraw", _fx_));
			}
			else
			{
				Hr = VFW_E_TYPE_NOT_ACCEPTED;
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid destination rectangle", _fx_));
			}
		}
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   SUCCESS: Not using DDraw", _fx_));
    }

	// If we just opened it, close it
	if (fOpenedDecoder)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_CLOSE\r\n");
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_FREE\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
		(*m_pDecoderFilter->m_pDriverProc)((DWORD)pInstInfo, NULL, DRV_FREE, 0L, 0L);
	}

	goto MyExit;

MyError1:
	if (m_pDecoderFilter->m_pDriverProc)
	{
#if defined(ICM_LOGGING) && defined(DEBUG)
		OutputDebugString("CTAPIOutputPin::CheckMediaType - DRV_FREE\r\n");
#endif
		(*m_pDecoderFilter->m_pDriverProc)(NULL, NULL, DRV_FREE, 0L, 0L);
	}
MyError:
	m_pDecoderFilter->m_pDriverProc = NULL;
#if DXMRTP <= 0
	if (m_pDecoderFilter->m_hTAPIH26XDLL)
		FreeLibrary(m_pDecoderFilter->m_hTAPIH26XDLL), m_pDecoderFilter->m_hTAPIH26XDLL = NULL;
#endif
MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end  hr=%x", _fx_, Hr));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIOutputPin | DecideBufferSize | This method is
 *    used to set the number and size of buffers required for transfer.
 *
 *  @parm IMemAllocator* | pAlloc | Specifies a pointer to the allocator
 *    assigned to the transfer.
 *
 *  @parm ALLOCATOR_PROPERTIES* | ppropInputRequest | Specifies a pointer to an
 *    <t ALLOCATOR_PROPERTIES> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIOutputPin::DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest)
{
	HRESULT					Hr = NOERROR;
	ALLOCATOR_PROPERTIES	Actual;

	FX_ENTRY("CTAPIOutputPin::DecideBufferSize")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pAlloc);
	ASSERT(ppropInputRequest);
	if (!pAlloc || !ppropInputRequest)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(m_pDecoderFilter->m_pInstInfo);
	ASSERT(m_mt.pbFormat);
	if (!m_mt.pbFormat || !m_pDecoderFilter->m_pInstInfo)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid state", _fx_));
		Hr = E_UNEXPECTED;
		goto MyExit;
	}

	// Fix parameters
	if (ppropInputRequest->cBuffers == 0)
		ppropInputRequest->cBuffers = 1;

	// Set the size of buffers based on the expected output frame size
	ppropInputRequest->cbBuffer = m_mt.GetSampleSize();

	ASSERT(ppropInputRequest->cbBuffer);

	if (FAILED(Hr = pAlloc->SetProperties(ppropInputRequest, &Actual)) || Actual.cbBuffer < ppropInputRequest->cbBuffer)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Can't use allocator", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Using %d buffers of size %d", _fx_, Actual.cBuffers, Actual.cbBuffer));

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}


HRESULT CTAPIOutputPin::ChangeMediaTypeHelper(const CMediaType *pmt)
{
    HRESULT hr = m_Connected->ReceiveConnection(this, pmt);
    if(FAILED(hr)) {
        return hr;
    }

    hr = SetMediaType(pmt);
    if(FAILED(hr)) {
        return hr;
    }

    // Does this pin use the local memory transport?
    if(NULL != m_pInputPin) {
        // This function assumes that m_pInputPin and m_Connected are
        // two different interfaces to the same object.
        ASSERT(::IsEqualObject(m_Connected, m_pInputPin));

        ALLOCATOR_PROPERTIES apInputPinRequirements;
        apInputPinRequirements.cbAlign = 0;
        apInputPinRequirements.cbBuffer = 0;
        apInputPinRequirements.cbPrefix = 0;
        apInputPinRequirements.cBuffers = 0;

        m_pInputPin->GetAllocatorRequirements(&apInputPinRequirements);

        // A zero allignment does not make any sense.
        if(0 == apInputPinRequirements.cbAlign) {
            apInputPinRequirements.cbAlign = 1;
        }

        hr = m_pAllocator->Decommit();
        if(FAILED(hr)) {
            return hr;
        }

        hr = DecideBufferSize(m_pAllocator,  &apInputPinRequirements);
        if(FAILED(hr)) {
            return hr;
        }

        hr = m_pAllocator->Commit();
        if(FAILED(hr)) {
            return hr;
        }

        hr = m_pInputPin->NotifyAllocator(m_pAllocator, 0);
        if(FAILED(hr)) {
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\outpin.h ===
/****************************************************************************
 *  @doc INTERNAL OUTPIN
 *
 *  @module OutPin.h | Header file for the <c CTAPIOutputPin> class methods
 *    used to implement the TAPI H.26X Video Decoder output pin.
 ***************************************************************************/

#ifndef _OUTPIN_H_
#define _OUTPIN_H_

/****************************************************************************
 *  @doc INTERNAL COUTPINCLASS
 *
 *  @class CTAPIOutputPin | This class implements the TAPI H.26X Video
 *    Decoder output pin.
 *
 *  @mdata CTAPIVDec* | CTAPIOutputPin | m_pDecoderFilter | Pointer to the
 *    filter that owns us.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_MaxProcessingTime | Maximum
 *    processing time.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_CurrentProcessingTime | Current
 *    processing time.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwMaxCPULoad | Maximum CPU load.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwCurrentCPULoad | Current CPU load.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeMin | Minimum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeMax | Maximum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeSteppingDelta | Target
 *    frame rate stepping delta.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_AvgTimePerFrameRangeDefault | Target
 *    frame rate default.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_MaxAvgTimePerFrame | Target
 *    frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIOutputPin | m_CurrentAvgTimePerFrame | Current
 *    frame rate.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwNumFramesDelivered | Counts number of
 *    frames delivered, reset every second or so.
 *
 *  @mdata DWORD | CTAPIOutputPin | m_dwNumFramesDecompressed | Counts number of
 *    frames decompressed, reset every second or so.
 ***************************************************************************/
#if 0
class CTAPIOutputPin : public CBaseOutputPinEx
#else
class CTAPIOutputPin : public CBaseOutputPin
#endif
#ifdef USE_CPU_CONTROL
, public ICPUControl
#endif
, public IH245DecoderCommand
, public IFrameRateControl
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
{
	public:
	DECLARE_IUNKNOWN
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	CTAPIOutputPin(IN TCHAR *pObjectName, IN CTAPIVDec *pDecoderFilter, IN CCritSec *pLock, IN HRESULT *pHr, IN LPCWSTR pName);
	virtual ~CTAPIOutputPin();

	// CBasePin stuff
	HRESULT SetMediaType(IN const CMediaType *pmt);
	HRESULT GetMediaType(IN int iPosition, OUT CMediaType *pMediaType);
	HRESULT CheckMediaType(IN const CMediaType *pMediatype);

	// CBaseOutputPin stuff
	HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest);

    // helper method for changing media type.
    HRESULT ChangeMediaTypeHelper(const CMediaType *pmt);

	// Inherited from IQualityControl via CBasePin
	STDMETHODIMP Notify(IBaseFilter *pSender, Quality q) {return S_OK;};

#ifdef USE_PROPERTY_PAGES
	// ISpecifyPropertyPages methods
	STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

#ifdef USE_CPU_CONTROL
	// Implement ICPUControl
	STDMETHODIMP GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
	STDMETHODIMP Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags);
	STDMETHODIMP Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);
#endif

	// Implement IFrameRateControl
	STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
	STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags);
	STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);

	// Implement IH245DecoderCommand
	STDMETHODIMP videoFreezePicture();

	protected:

	friend class CTAPIVDec;

	CTAPIVDec *m_pDecoderFilter;

#ifdef USE_CPU_CONTROL
	// CPU control
	LONG  m_lMaxProcessingTime;
	LONG  m_lCurrentProcessingTime;
	LONG  m_lMaxCPULoad;
	LONG  m_lCurrentCPULoad;
#endif

	// Frame rate control
	LONG m_lAvgTimePerFrameRangeMin;
	LONG m_lAvgTimePerFrameRangeMax;
	LONG m_lAvgTimePerFrameRangeSteppingDelta;
	LONG m_lAvgTimePerFrameRangeDefault;
	LONG m_lMaxAvgTimePerFrame;
	LONG m_lCurrentAvgTimePerFrame;
};

#endif // _OUTPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\inpinp.h ===
/****************************************************************************
 *  @doc INTERNAL INPINP
 *
 *  @module InPinP.h | Header file for the <c CInputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _INPINP_H_
#define _INPINP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_INPUT_PIN_PROPERTIES 2
#define CurrentFrameRate     0
#define CurrentBitrate       1

/****************************************************************************
 *  @doc INTERNAL CINPINPCLASS
 *
 *  @class CInputPinProperty | This class implements handling of a
 *    single property in a property page.
 *
 *  @mdata int | CInputPinProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | CInputPinProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata IBitrateControl * | CInputPinProperty | m_pIBitrateControl | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i IBitrateControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CInputPinProperty : public CPropertyEditor 
{
	public:
	CInputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, IBitrateControl *pIBitrateControl);
	~CInputPinProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IFrameRateControl *m_pIFrameRateControl;
	IBitrateControl *m_pIBitrateControl;
};

/****************************************************************************
 *  @doc INTERNAL CINPINPCLASS
 *
 *  @class CInputPinProperties | This class runs a property page to test
 *    the TAPI Video Decoder Filter <i IFrameRateControl> and <i IBitrateControl>
 *    implementation.
 *
 *  @mdata int | CInputPinProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | CInputPinProperties | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata IBitrateControl * | CInputPinProperties | m_pIBitrateControl | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @mdata CInputPinProperty * | CInputPinProperties | m_Controls[NUM_INPUT_PIN_PROPERTIES] | Array
 *    of properties.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i IBitrateControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CInputPinProperties : public CBasePropertyPage
{
	public:
	CInputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CInputPinProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IFrameRateControl *m_pIFrameRateControl;
	IBitrateControl *m_pIBitrateControl;
	BOOL m_fActivated;
	CInputPinProperty *m_Controls[NUM_INPUT_PIN_PROPERTIES];
};

#endif // USE_PROPERTY_PAGES

#endif // _INPINP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\procutil.h ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.h | Header file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#ifndef _PROCUTIL_H_
#define _PROCUTIL_H_

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed);

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

// CallWithSEH is a utility function to call a function with structured exception handling
extern "C" DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void* pv, INEXCEPTION InException);
extern "C" WORD _cdecl is_cyrix(void);
extern "C" DWORD _cdecl get_nxcpu_type(void);

#endif // _PROCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\precomp.h ===
/****************************************************************************
 *  @doc INTERNAL PRECOMP
 *
 *  @module Precomp.h | Master header file.
 ***************************************************************************/
#ifndef _precomp_vdec_h_
#define _precomp_vdec_h

#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <winbase.h>
#include <mmsystem.h>
#include <streams.h>
#include <vfw.h>
#include <stdlib.h>
#include <limits.h>
#include <commctrl.h>
#include <TAPIVid.h>
#include <tptrace.h>
#include <filterid.h>
#include <H26XInc.h>
#include <TAPIH26X.h>
#include <msrtp.h>
#include <ks.h>
#include <ksmedia.h>
#include <RtpHdr.h>
#include "PropEdit.h"
#include "Resource.h"
#include "ProcAmpP.h"
#include "CameraCP.h"
#include "h245vid.h"
#include "TAPIVDec.h"
#include "InPin.h"
#include "OutPin.h"
#include "Formats.h"
#include "InPinP.h"
#include "OutPinP.h"
#include "ProcUtil.h"
#include "viddtemp.h"

#endif /* _precomp_vdec_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\outpinp.h ===
/****************************************************************************
 *  @doc INTERNAL OUTPINP
 *
 *  @module OutPinP.h | Header file for the <c COutputPinProperty>
 *    class used to implement a property page to test the TAPI interfaces
 *    <i IFrameRateControl> and <i ICPUControl>.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _OUTPINP_H_
#define _OUTPINP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CPU_CONTROL
#define NUM_OUTPUT_PIN_PROPERTIES 6
#define CurrentFrameRate     0
#define CurrentDecodingTime  1
#define CurrentCPULoad       2
#define TargetFrameRate      3
#define TargetDecodingTime   4
#define TargetCPULoad        5
#else
#define NUM_OUTPUT_PIN_PROPERTIES 2
#define CurrentFrameRate     0
#define TargetFrameRate      1
#endif

/****************************************************************************
 *  @doc INTERNAL COUTPINPCLASS
 *
 *  @class COutputPinProperty | This class implements handling of a
 *    single property in a property page.
 *
 *  @mdata int | COutputPinProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | COutputPinProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata ICPUControl * | COutputPinProperty | m_pICPUControl | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i ICPUControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class COutputPinProperty : public CPropertyEditor 
{
	public:
#ifdef USE_CPU_CONTROL
	COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl, ICPUControl *pICPUControl);
#else
	COutputPinProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IFrameRateControl *pIFrameRateControl);
#endif
	~COutputPinProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IFrameRateControl *m_pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	ICPUControl *m_pICPUControl;
#endif
};

/****************************************************************************
 *  @doc INTERNAL COUTPINPCLASS
 *
 *  @class COutputPinProperties | This class runs a property page to test
 *    the TAPI Video Decoder Filter <i IFrameRateControl> and <i ICPUControl>
 *    implementation.
 *
 *  @mdata int | COutputPinProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl * | COutputPinProperties | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata ICPUControl * | COutputPinProperties | m_pICPUControl | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @mdata COutputPinProperty * | COutputPinProperties | m_Controls[NUM_OUTPUT_PIN_PROPERTIES] | Array
 *    of properties.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IFrameRateControl>
 *     and <i ICPUControl> implementation. This code is only compiled if
 *     USE_PROPERTY_PAGES is defined.
***************************************************************************/
class COutputPinProperties : public CBasePropertyPage
{
	public:
	COutputPinProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~COutputPinProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IFrameRateControl *m_pIFrameRateControl;
#ifdef USE_CPU_CONTROL
	ICPUControl *m_pICPUControl;
#endif
	IH245DecoderCommand *m_pIH245DecoderCommand;
	BOOL m_fActivated;
	COutputPinProperty *m_Controls[NUM_OUTPUT_PIN_PROPERTIES];
};

#endif // USE_PROPERTY_PAGES

#endif // _OUTPINP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\procamp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMP
 *
 *  @module ProcAmp.cpp | Source file for the <c CTAPIVDec>
 *    class methods used to implement the <i IAMVideoProcAmp> interface.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_VIDEO_PROCAMP

#define PROCAMP_MIN		0
#define PROCAMP_MAX		255
#define PROCAMP_DELTA	1
#define PROCAMP_DEFAULT	128

// From TAPIH263\cdrvdefs.h
#define PLAYBACK_CUSTOM_START				(ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS	(PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST		(PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION	(PLAYBACK_CUSTOM_START + 2)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Set | This method is used to set the value
 *    of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to set the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the video quality
 *    setting.
 *
 *  @parm TAPIControlFlags | Flags | A member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Set (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);

	// Update the property and flags
	switch (Property)
	{
		case VideoProcAmp_Brightness:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPABrightness = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case VideoProcAmp_Contrast:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPAContrast = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_CONTRAST, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		case VideoProcAmp_Saturation:
			ASSERT(lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX);
			if (lValue >= PROCAMP_MIN && lValue <= PROCAMP_MAX)
			{
				m_lVPASaturation = lValue;
				(*m_pDriverProc)((DWORD)m_pInstInfo, NULL, PLAYBACK_CUSTOM_CHANGE_SATURATION, (LPARAM)lValue, NULL);
			}
			else
			{
				DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
				Hr = E_INVALIDARG;
			}
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Get | This method is used to retrieve the
 *    value of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to get the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    video quality setting.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::Get(IN VideoProcAmpProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::Get (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);

	// Update the property and flags
	*plFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case VideoProcAmp_Brightness:
			*plValue = m_lVPABrightness;
			break;
		case VideoProcAmp_Contrast:
			*plValue = m_lVPAContrast;
			break;
		case VideoProcAmp_Saturation:
			*plValue = m_lVPASaturation;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific video quality
 *    settings.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to determine the range of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the video
 *    quality setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the video
 *    quality setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the video quality setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    video quality setting range.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to retrieve the capabilities of the
 *    video quality setting. Pointer to a member of the
 *    <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetRange(IN VideoProcAmpProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIVDec::GetRange (VideoProcAmp)")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);
	if (Property != VideoProcAmp_Brightness && Property != VideoProcAmp_Contrast && Property != VideoProcAmp_Saturation)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	// Update the property and flags
	*plCapsFlags = TAPIControl_Flags_Manual;
	*plMin = PROCAMP_MIN;
	*plMax = PROCAMP_MAX;
	*plSteppingDelta = PROCAMP_DELTA;
	*plDefault = PROCAMP_DEFAULT;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\procampp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.cpp | Source file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_VIDEO_PROCAMP

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | CProcAmpProperty | This
 *    method is the constructor for video proc amp control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i IAMVideoProcAmp> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IAMVideoProcAmp* | pInterface | Specifies a pointer to the
 *    <i IAMVideoProcAmp> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CProcAmpProperty::CProcAmpProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | ~CProcAmpProperty | This
 *    method is the destructor for video proc amp control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::~CProcAmpProperty()
{
	FX_ENTRY("CProcAmpProperty::~CProcAmpProperty")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get(m_IDProperty, &m_CurrentValue, &m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::SetValue")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set(m_IDProperty, m_CurrentValue, m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetRange")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange(m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: m_pIAMVideoProcAmp->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc CUnknown* | CProcAmpProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CProcAmpPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr)
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CProcAmpPropertiesCreateInstance")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CProcAmpProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CProcAmpProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CProcAmpProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | CProcAmpProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Video Proc Amp Property Page"), pUnk, IDD_VideoProcAmpProperties, IDS_PROCAMPPROPNAME)
{
	FX_ENTRY("CProcAmpProperties::CProcAmpProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_pIAMVideoProcAmp = NULL;
	m_NumProperties = NUM_PROCAMP_CONTROLS;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | ~CProcAmpProperties | This
 *    method is the destructor for the video proc amp control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::~CProcAmpProperties()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::~CProcAmpProperties")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnConnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the video proc amp interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(IID_IAMVideoProcAmp,(void **)&m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_pIAMVideoProcAmp=0x%08lX", _fx_, m_pIAMVideoProcAmp));
	}
	else
	{
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDisconnect()
{
	FX_ENTRY("CProcAmpProperties::OnDisconnect")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIAMVideoProcAmp)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMVideoProcAmp->Release();
		m_pIAMVideoProcAmp = NULL;
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMVideoProcAmp", _fx_));
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CProcAmpProperties::OnActivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CProcAmpProperty(m_hwnd, IDC_Brightness_Label, IDC_Brightness_Minimum, IDC_Brightness_Maximum, IDC_Brightness_Default, IDC_Brightness_Stepping, IDC_Brightness_Edit, IDC_Brightness_Slider, 0, VideoProcAmp_Brightness, IDC_Brightness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Brightness] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Brightness]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CProcAmpProperty(m_hwnd, IDC_Contrast_Label, IDC_Contrast_Minimum, IDC_Contrast_Maximum, IDC_Contrast_Default, IDC_Contrast_Stepping, IDC_Contrast_Edit, IDC_Contrast_Slider, 0, VideoProcAmp_Contrast, IDC_Contrast_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Contrast] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Contrast]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CProcAmpProperty(m_hwnd, IDC_Hue_Label, IDC_Hue_Minimum, IDC_Hue_Maximum, IDC_Hue_Default, IDC_Hue_Stepping, IDC_Hue_Edit, IDC_Hue_Slider, 0, VideoProcAmp_Hue, IDC_Hue_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Hue] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Hue]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CProcAmpProperty(m_hwnd, IDC_Saturation_Label, IDC_Saturation_Minimum, IDC_Saturation_Maximum, IDC_Saturation_Default, IDC_Saturation_Stepping, IDC_Saturation_Edit, IDC_Saturation_Slider, 0, VideoProcAmp_Saturation, IDC_Saturation_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Saturation] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Saturation]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CProcAmpProperty(m_hwnd, IDC_Sharpness_Label, IDC_Sharpness_Minimum, IDC_Sharpness_Maximum, IDC_Sharpness_Default, IDC_Sharpness_Stepping, IDC_Sharpness_Edit, IDC_Sharpness_Slider, 0, VideoProcAmp_Sharpness, IDC_Sharpness_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Sharpness] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Sharpness]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CProcAmpProperty(m_hwnd, IDC_Gamma_Label, IDC_Gamma_Minimum, IDC_Gamma_Maximum, IDC_Gamma_Default, IDC_Gamma_Stepping, IDC_Gamma_Edit, IDC_Gamma_Slider, 0, VideoProcAmp_Gamma, IDC_Gamma_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_Gamma] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_Gamma]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CProcAmpProperty(m_hwnd, IDC_ColorEnable_Label, IDC_ColorEnable_Minimum, IDC_ColorEnable_Maximum, IDC_ColorEnable_Default, IDC_ColorEnable_Stepping, IDC_ColorEnable_Edit, IDC_ColorEnable_Slider, 0, VideoProcAmp_ColorEnable, IDC_ColorEnable_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_ColorEnable] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_ColorEnable]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CProcAmpProperty(m_hwnd, IDC_WhiteBalance_Label, IDC_WhiteBalance_Minimum, IDC_WhiteBalance_Maximum, IDC_WhiteBalance_Default, IDC_WhiteBalance_Stepping, IDC_WhiteBalance_Edit, IDC_WhiteBalance_Slider, 0, VideoProcAmp_WhiteBalance, IDC_WhiteBalance_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_WhiteBalance] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_WhiteBalance]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[8] = new CProcAmpProperty(m_hwnd, IDC_BacklightComp_Label, IDC_BacklightComp_Minimum, IDC_BacklightComp_Maximum, IDC_BacklightComp_Default, IDC_BacklightComp_Stepping, IDC_BacklightComp_Edit, IDC_BacklightComp_Slider, 0, VideoProcAmp_BacklightCompensation, IDC_BacklightComp_Auto, m_pIAMVideoProcAmp)))
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: mew m_Controls[VideoProcAmp_BacklightComp] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[VideoProcAmp_BacklightComp]=0x%08lX", _fx_, m_Controls[6]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::OnDeactivate")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnApplyChanges")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CProcAmpProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CProcAmpProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_VIDEO_PROCAMP

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\propedit.h ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.h | Header file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code tests the Ks interface handlers. This code is only
 *    compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _PROPEDIT_H_
#define _PROPEDIT_H_

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITCLASS
 *
 *  @class CPropertyEditor | This class implements behavior of a single
 *    property to be displayed in a property page.
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProperty | Property ID
 *
 *  @mdata LONG | CPropertyEditor | m_CurrentValue | Property current value
 *
 *  @mdata LONG | CPropertyEditor | m_Min | Property minimum value
 *
 *  @mdata LONG | CPropertyEditor | m_Max | Property maximum value
 *
 *  @mdata LONG | CPropertyEditor | m_SteppingDelta | Property stepping delta
 *
 *  @mdata LONG | CPropertyEditor | m_DefaultValue | Property default value
 *
 *  @mdata BOOL | CPropertyEditor | m_Active | Set to TRUE after all property values have been initialized
 *
 *  @mdata LONG | CPropertyEditor | m_OriginalValue | Backup of the original value
 *
 *  @mdata HWND | CPropertyEditor | m_hDlg | Window handle to the Parent dialog
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMin | Window handle to the Minimum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMax | Window handle to the Maximum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndDefault | Window handle to the Default dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndStep | Window handle to the Stepping Delta dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndEdit | Window handle to the Target dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndTrackbar | Window handle to the slide bar
 *
 *  @mdata HWND | CPropertyEditor | m_hWndProgress | Window handle to the progress bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDLabel | Resource ID of the property label
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMinControl | Resource ID of the Minimum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMaxControl | Resource ID of the Maximum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDStepControl | Resource ID of the Stepping Delta dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDDefaultControl | Resource ID of the Default dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDEditControl | Resource ID of the Target dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDTrackbarControl | Resource ID of the slide bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProgressControl | Resource ID of the progress bar
 ***************************************************************************/
class CPropertyEditor
{
	public:
	CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl);
	virtual ~CPropertyEditor();

	BOOL Init();

	HWND GetTrackbarHWnd();
	HWND GetProgressHWnd();
	HWND GetEditHWnd();
	HWND GetAutoHWnd();

	BOOL UpdateEditBox();
	BOOL UpdateTrackbar();
	BOOL UpdateProgress();
	BOOL UpdateAuto();

	BOOL OnApply();
	BOOL OnDefault();
	BOOL OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL HasChanged();

	protected:

	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	// Pure virtual functions to set/get actual property values, and the ranges
	virtual HRESULT GetValue(void) PURE;
	virtual HRESULT SetValue(void) PURE;
	virtual HRESULT GetRange(void) PURE; 

	ULONG	m_IDProperty;	// Property ID

	// The following are used by GetValue and SetValue
	LONG	m_CurrentValue;
	LONG	m_CurrentFlags;

	// The following must be set by GetRange
	LONG	m_Min;
	LONG	m_Max;
	LONG	m_SteppingDelta;
	LONG	m_DefaultValue;
	LONG	m_DefaultFlags;
	LONG	m_CapsFlags;

	private:
	BOOL	m_Active;
	BOOL	m_fCheckBox;
	LONG	m_OriginalValue;
	LONG	m_OriginalFlags;
	HWND	m_hDlg;				// Parent
	HWND	m_hWndMin;			// Min window
	HWND	m_hWndMax;			// Max window
	HWND	m_hWndDefault;		// Default window
	HWND	m_hWndStep;			// Step window
	HWND	m_hWndEdit;			// Edit window
	HWND	m_hWndTrackbar;		// Slider
	HWND	m_hWndProgress;		// Progress
	HWND	m_hWndAuto;			// Auto checkbox
	ULONG	m_IDLabel;			// ID of label
	ULONG	m_IDMinControl;		// ID of min control
	ULONG	m_IDMaxControl;		// ID of max control
	ULONG	m_IDStepControl;	// ID of step control
	ULONG	m_IDDefaultControl;	// ID of default control
	ULONG	m_IDEditControl;	// ID of edit control
	ULONG	m_IDTrackbarControl;// ID of trackbar
	ULONG	m_IDProgressControl;// ID of trackbar
	ULONG	m_IDAutoControl;	// ID of auto checkbox
	LONG	m_TrackbarOffset;	// Handles negative trackbar offsets
	LONG	m_ProgressOffset;	// Handles negative trackbar offsets
	BOOL	m_CanAutoControl;

};

#endif // USE_PROPERTY_PAGES

#endif // _PROPEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\procampp.h ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.h | Header file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the DShow interface
 *    <i IAMVideoProcAmp>.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _PROCAMPP_H_
#define _PROCAMPP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_VIDEO_PROCAMP

#define NUM_PROCAMP_CONTROLS (VideoProcAmp_BacklightCompensation + 1)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperty | This class implements handling of a
 *    single video proc amp control property in a property page.
 *
 *  @mdata int | CProcAmpProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperty | m_pInterface | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperty : public CPropertyEditor 
{
	public:
	CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, IAMVideoProcAmp *pInterface);
	~CProcAmpProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IAMVideoProcAmp *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i IAMVideoProcAmp> implementation.
 *
 *  @mdata int | CProcAmpProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IAMVideoProcAmp * | CProcAmpProperties | m_pIAMVideoProcAmp | Pointer
 *    to the <i IAMVideoProcAmp> interface.
 *
 *  @mdata CProcAmpProperty * | CProcAmpProperties | m_Controls[NUM_PROCAMP_CONTROLS] | Array
 *    of video proc amp properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i IAMVideoProcAmp>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CProcAmpProperties : public CBasePropertyPage
{
	public:
	CProcAmpProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CProcAmpProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	IAMVideoProcAmp *m_pIAMVideoProcAmp;
	BOOL m_fActivated;
	CProcAmpProperty *m_Controls[NUM_PROCAMP_CONTROLS];
};

#endif // USE_VIDEO_PROCAMP

#endif // USE_PROPERTY_PAGES

#endif // _PROCAMPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#include <windows.h>

typedef DWORD (CALLBACK *INEXCEPTION)(LPEXCEPTION_RECORD per, PCONTEXT pctx);
typedef DWORD (CALLBACK *EXCEPTPROC)(void* pv);

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\propedit.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.cpp | Source file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | CPropertyEditor | This
 *    method is the constructor for property objects.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the property.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl)
: m_hDlg (hDlg), m_hWndMin (NULL), m_hWndMax (NULL), m_hWndDefault (NULL), m_hWndStep (NULL), m_hWndEdit (NULL), m_hWndTrackbar (NULL), m_hWndProgress (NULL), m_IDLabel (IDLabel), m_hWndAuto (NULL), m_IDAutoControl (IDAutoControl)
, m_IDMinControl (IDMinControl), m_IDMaxControl (IDMaxControl), m_IDDefaultControl (IDDefaultControl), m_IDStepControl (IDStepControl), m_IDTrackbarControl (IDTrackbarControl), m_IDProgressControl (IDProgressControl)
, m_IDEditControl (IDEditControl), m_IDProperty (IDProperty), m_Active (FALSE), m_Min (0), m_Max (0), m_DefaultValue (0), m_DefaultFlags (0), m_SteppingDelta (0), m_CurrentValue (0), m_TrackbarOffset (0), m_ProgressOffset (0), m_fCheckBox (0)
, m_CurrentFlags (0), m_CanAutoControl (FALSE)

{
	FX_ENTRY("CPropertyEditor::CPropertyEditor")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | Init | This initializes the controls.
 *
 *  @rdesc TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::Init()
{
	HRESULT Hr = NOERROR;
	BOOL	fRes = TRUE;

	FX_ENTRY("CPropertyEditor::Init")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// For now disable all controls, and re-enable only the ones that make sense
	// at the end of this initialization function

	// Those GetDlgItem calls 'd better not fail ;)
	if (m_IDLabel)
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), FALSE);
	if (m_IDMinControl)
		EnableWindow(m_hWndMin = GetDlgItem(m_hDlg, m_IDMinControl), FALSE);
	if (m_IDMaxControl)
		EnableWindow(m_hWndMax = GetDlgItem(m_hDlg, m_IDMaxControl), FALSE);
	if (m_IDDefaultControl)
		EnableWindow(m_hWndDefault = GetDlgItem(m_hDlg, m_IDDefaultControl), FALSE);
	if (m_IDStepControl)
		EnableWindow(m_hWndStep = GetDlgItem(m_hDlg, m_IDStepControl), FALSE);
	if (m_IDEditControl)
		EnableWindow(m_hWndEdit = GetDlgItem(m_hDlg, m_IDEditControl), FALSE);
	if (m_IDTrackbarControl)
		EnableWindow(m_hWndTrackbar = GetDlgItem(m_hDlg, m_IDTrackbarControl), FALSE);
	if (m_IDProgressControl)
		EnableWindow(m_hWndProgress = GetDlgItem(m_hDlg, m_IDProgressControl), FALSE);
	if (m_IDAutoControl)
		EnableWindow(m_hWndAuto = GetDlgItem(m_hDlg, m_IDAutoControl), FALSE);

	// Only enable the control if we can read the current value
	if (FAILED(Hr = GetValue()))
	{
		fRes = FALSE;
		goto MyExit;
	}

	// Save original value in case user clicks Cancel
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Get the range, stepping, default, and capabilities
	if (FAILED(Hr = GetRange()))
	{
		// Special case, if no trackbar and no edit box, treat the
		// autocheck box as a boolean to control the property
		if (m_hWndTrackbar || m_hWndEdit || m_hWndProgress)
		{
			fRes = FALSE;
			goto MyExit;
		}
	}
	else
	{
		ASSERT(!(m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min));
		if (m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min)
		{
			DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: ERROR: Invalid range or current value", _fx_));
			fRes = FALSE;
			goto MyExit;
		}

		if (m_Min == 0 && m_Max == 1 && m_SteppingDelta == 1)
			m_fCheckBox = TRUE;
	}

	// We're ready to rock & roll
	m_Active = TRUE;

	// Re-enable appropriate controls
	if (m_IDLabel)
	{
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), TRUE);
	}
	if (m_hWndMin)
	{
		SetDlgItemInt(m_hDlg, m_IDMinControl, m_Min, TRUE);
		EnableWindow(m_hWndMin, TRUE);
	}
	if (m_hWndMax)
	{
		SetDlgItemInt(m_hDlg, m_IDMaxControl, m_Max, TRUE);
		EnableWindow(m_hWndMax, TRUE);
	}
	if (m_hWndDefault)
	{
		SetDlgItemInt(m_hDlg, m_IDDefaultControl, m_DefaultValue, TRUE);
		EnableWindow(m_hWndDefault, TRUE);
	}
	if (m_hWndStep)
	{
		SetDlgItemInt(m_hDlg, m_IDStepControl, m_SteppingDelta, TRUE);
		EnableWindow(m_hWndStep, TRUE);
	}
	if (m_hWndEdit)
	{
		UpdateEditBox();
		EnableWindow(m_hWndEdit, TRUE);
	}
	if (m_hWndTrackbar)
	{
		EnableWindow(m_hWndTrackbar, TRUE);

		// Trackbars don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_TrackbarOffset = -m_Min;

		SendMessage(m_hWndTrackbar, TBM_SETRANGEMAX, FALSE, m_Max + m_TrackbarOffset);
		SendMessage(m_hWndTrackbar, TBM_SETRANGEMIN, FALSE, m_Min + m_TrackbarOffset);

		// Have fun with the keyboards Page Up, Page Down, and arrows
		SendMessage(m_hWndTrackbar, TBM_SETLINESIZE, FALSE, (LPARAM) m_SteppingDelta);
		SendMessage(m_hWndTrackbar, TBM_SETPAGESIZE, FALSE, (LPARAM) m_SteppingDelta);

		UpdateTrackbar();
	}
	if (m_hWndProgress)
	{
		EnableWindow(m_hWndProgress, TRUE);

		// Progress controls don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_ProgressOffset = -m_Min;

		SendMessage(m_hWndProgress, PBM_SETRANGE32, m_Min + m_ProgressOffset, m_Max + m_ProgressOffset);

		UpdateProgress();

		// Set a timer to update the progress regularly
		SetTimer(m_hDlg, 123456, 250, NULL);
	}
	if (m_hWndAuto)
	{
		// If the control has an auto setting, enable the auto checkbox
		m_CanAutoControl = CanAutoControl();
		EnableWindow (m_hWndAuto, m_CanAutoControl);
		if (m_CanAutoControl)
		{
			Button_SetCheck (m_hWndAuto, GetAuto ());
		}
	}

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | ~CPropertyEditor | Destructor for this class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::~CPropertyEditor()
{
	FX_ENTRY("CPropertyEditor::~CPropertyEditor")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Kill timer if we have a progress bar
	if (m_hWndProgress)
		KillTimer(m_hDlg, 123456);

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | OnApply | This member function is
 *    called by the framework when the user chooses the OK or the Apply Now
 *    button. When the framework calls this member function, changes made on
 *    all property pages in the property sheet are accepted, the property
 *    sheet retains focus.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnApply()
{
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnApply")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
	{
		nCurrentValue = m_CurrentValue;
		m_CurrentValue = m_CurrentValue / m_SteppingDelta * m_SteppingDelta;
		if (m_CurrentValue != nCurrentValue)
		{
			UpdateEditBox();
			UpdateTrackbar();
		}
	}

	// Backup current value in order to only apply changes if something has really changed
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Set the value on the device
	SetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | HasChanged | This member tests for a
 *    change in value.
 *
 *  @rdesc Returns TRUE if value has changed.
 ***************************************************************************/
BOOL CPropertyEditor::HasChanged()
{
	FX_ENTRY("CPropertyEditor::HasChanged")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return (m_CurrentValue != m_OriginalValue);
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnDefault | Resets the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    pressed the Default button.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnDefault()
{
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnDefault")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	if (!m_Active)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Backup value in case user goes for the Cancel button
	m_CurrentValue = m_DefaultValue;
    m_CurrentFlags = m_DefaultFlags;

	// Update appropriate controls
	UpdateEditBox();
	UpdateTrackbar();
	UpdateAuto();

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnScroll | Reads the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    has messed with the slide bar.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	int pos;
	int command = LOWORD(wParam);
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnScroll")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// Validate input params
	if (command != TB_ENDTRACK && command != TB_THUMBTRACK && command != TB_LINEDOWN && command != TB_LINEUP && command != TB_PAGEUP && command != TB_PAGEDOWN)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: ERROR: Invalid input parameter!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}
	ASSERT (IsWindow((HWND) lParam));
	if (!m_Active)
	{
		DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s: WARNING: Control not active yet!", _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Retrieve position in slide bar
	pos = (int)SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
		m_CurrentValue = (pos - m_TrackbarOffset) / m_SteppingDelta * m_SteppingDelta;
	else
		m_CurrentValue = pos - m_TrackbarOffset;

	// Sync edit box to the slide bar
	UpdateEditBox();

MyExit:
	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnEdit | Reads the content of the
 *    Target window and updates the postion of the slider after the user
 *    has messed with the Target edit control.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	BOOL fTranslated;
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnEdit")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	// We get called even before init has been done -> test for m_Active
	if (m_Active)
	{
		if (!m_fCheckBox)
		{
			// Read the value from the control
			if (m_hWndEdit)
				nCurrentValue = GetDlgItemInt(m_hDlg, m_IDEditControl, &fTranslated, TRUE);

			// Is the value garbage?
			if (fTranslated)
			{
				if (nCurrentValue > m_Max)
				{
					// The value is already large than its max -> clamp it and update the control
					m_CurrentValue = m_Max;
					UpdateEditBox();
				}
				else if (nCurrentValue < m_Min)
				{
					// The value is already smaller than its min -> clamp it and update the control
					m_CurrentValue = m_Min;
					UpdateEditBox();
				}
				else
					m_CurrentValue = nCurrentValue;
			}
			else
			{
				// It's garbage -> Reset the control to its minimum value
				m_CurrentValue = m_Min;
				UpdateEditBox();
			}

			// Sync slide bar to edit box
			UpdateTrackbar();
		}
		else
		{
			// Read the value from the control
			if (m_hWndEdit)
				m_CurrentValue = Button_GetCheck(m_hWndEdit);
		}
	}

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnAuto | Gets the status of the
 *    checkbox.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	SetAuto(Button_GetCheck(m_hWndAuto));

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetTrackbarHWnd | Helper method to allow
 *    the property page code to access the slide bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the slide bar window.
 ***************************************************************************/
HWND CPropertyEditor::GetTrackbarHWnd()
{
	return m_hWndTrackbar;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetProgressHWnd | Helper method to allow
 *    the property page code to access the progress bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the progress window.
 ***************************************************************************/
HWND CPropertyEditor::GetProgressHWnd()
{
	return m_hWndProgress;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetEditHWnd | Helper method to allow
 *    the property page code to access the Target window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the Target window.
 ***************************************************************************/
HWND CPropertyEditor::GetEditHWnd()
{
	return m_hWndEdit;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetAutoHWnd | Helper method to allow
 *    the property page code to access the auto window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the auto window.
 ***************************************************************************/
HWND CPropertyEditor::GetAutoHWnd()
{
	return m_hWndAuto;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateEditBox | Updates the content of
 *    the Target window after user has moved the slide bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateEditBox()
{
	if (m_hWndEdit)
	{
		if (!m_fCheckBox)
			SetDlgItemInt(m_hDlg, m_IDEditControl, m_CurrentValue, TRUE);
		else
			Button_SetCheck(m_hWndEdit, m_CurrentValue);
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateTrackbar | Updates the position of
 *    the slide bar after user has messed with the Target window.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateTrackbar()
{
	if (m_hWndTrackbar)
		SendMessage(m_hWndTrackbar, TBM_SETPOS, TRUE, (LPARAM) m_CurrentValue + m_TrackbarOffset);

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateProgress | Updates the position of
 *    the progress bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateProgress()
{
	// Get current value from the device
	GetValue();

	if (m_hWndProgress)
		SendMessage(m_hWndProgress, PBM_SETPOS, (WPARAM) m_CurrentValue + m_ProgressOffset, 0);

	UpdateEditBox();

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateAuto | Updates the auto checkbox
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateAuto()
{
	if (m_hWndAuto && CanAutoControl())
	{
		m_CanAutoControl = GetAuto();
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::CanAutoControl(void)
{
	FX_ENTRY("CPropertyEditor::CanAutoControl")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return m_CapsFlags & TAPIControl_Flags_Auto;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::GetAuto(void)
{
	FX_ENTRY("CPropertyEditor::GetAuto")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	GetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return m_CurrentFlags & TAPIControl_Flags_Auto; 
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CPropertyEditor::SetAuto")

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

	m_CurrentFlags = (fAuto ? TAPIControl_Flags_Auto : (m_CapsFlags & TAPIControl_Flags_Manual) ? TAPIControl_Flags_Manual : TAPIControl_Flags_None);

	SetValue();

	DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\procutil.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCUTIL
 *
 *  @module ProcUtil.cpp | Source file for the Processor ID and Speed routines.
 *
 *  @comm Comes from the NM code base.
 ***************************************************************************/

#include "Precomp.h"

#define LEGACY_DIVISOR	8

DWORD __stdcall FindTSC (LPVOID pvRefData)
{
	   _asm
	   {
		   mov     eax,1
		   _emit   00Fh     ;; CPUID
		   _emit   0A2h

    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family
		   mov     ecx,pvRefData
		   mov     [ecx],edx
		   mov	   [ecx][4],eax
	   }

	   return 1;
}

DWORD __stdcall NoCPUID (LPEXCEPTION_RECORD per,PCONTEXT pctx)
{
    return 0;
}
//
//  GetProcessorSpeed(dwFamily)
//
//  get the processor speed in MHz, only works on Pentium or better
//  machines.
//
//  Will put 3, or 4 in dwFamily for 386/486, but no speed.
//  returns speed and family for 586+
//
//  - thanks to toddla, modified by mikeg
//

int __stdcall GetProcessorSpeed(int *pdwFamily)
{
    SYSTEM_INFO si;
    __int64	start, end, freq;
    int 	flags,family;
    int 	time;
    int 	clocks;
    DWORD	oldclass;
    HANDLE      hprocess;
    int     pRef[2];

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {
	*pdwFamily=si.wProcessorLevel;
    }else {
    	//Ok, we're on Win95
    	switch (si.dwProcessorType) {
    	       case PROCESSOR_INTEL_386:
    		   *pdwFamily=3;
    		   break;

    	       case PROCESSOR_INTEL_486:
    		   *pdwFamily=4;
    		   break;
    	       default:
    		   *pdwFamily=0;
    		   break;
    	}
    }

    // make sure this is a INTEL Pentium (or clone) or higher.
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    // see if this chip supports rdtsc before using it.
    if (!CallWithSEH (FindTSC,&pRef,NoCPUID))     {
        flags=0;
    } else {
    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family. Pull them out and use them
        flags=pRef[0];
        family=pRef[1];
    }

    if (!(flags & 0x10))
        return 0;

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*pdwFamily)) {
       *pdwFamily=(family& 0x0F00) >> 8;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    return (clocks + time/2) / time;
}

HRESULT __stdcall GetNormalizedCPUSpeed (int *pdwNormalizedSpeed)
{
	int dwProcessorSpeed;
	int dwFamily;

	dwProcessorSpeed=GetProcessorSpeed(&dwFamily);

	*pdwNormalizedSpeed=dwProcessorSpeed;

	if (dwFamily > 5) {
	   //Ok, TWO things.
	   // ONE DO NOT DO FP!
	   // Two for the same Mhz assume a 686 is 1.3 times as fast as a 586 and a 786 is 1.6 times, etc.
	   *pdwNormalizedSpeed=(ULONG) (((10+3*(dwFamily-5))*dwProcessorSpeed)/10);
	}

	if (dwFamily < 5) {
	  //bugbug until we have 386/486 timing code, assume
	  //486=50,386=37
	  if (dwFamily > 3) {
           //Cyrix, (5x86)? check before making default assignment
           if (is_cyrix()) {
               if (*pdwNormalizedSpeed==0) {
                   dwFamily=5;
                   *pdwNormalizedSpeed=100;
                   return NOERROR;
               }
           }
      }

	  *pdwNormalizedSpeed= (dwFamily*100)/LEGACY_DIVISOR;

      if (get_nxcpu_type ()) {
        //Double the perceived value on a NexGen
        *pdwNormalizedSpeed *=2;
      }
   }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TAPIVDec.rc
//

#define IDC_STATIC                      -1

#ifdef USE_PROPERTY_PAGES // { USE_PROPERTY_PAGES

#define IDS_CAMERACONTROLPROPNAME       0
#define IDS_PROCAMPPROPNAME				1
#define IDS_INPUTPINPROPNAME            2
#define IDS_OUTPUTPINPROPNAME           3

#define IDD_CameraControlProperties     100
#define IDD_VideoProcAmpProperties      101
#define IDD_InputPinProperties          102
#define IDD_OutputPinProperties         103

#define IDC_BitrateControl_Label        200
#define IDC_BitrateControl_Minimum      0
#define IDC_BitrateControl_Maximum      0
#define IDC_BitrateControl_Default      0
#define IDC_BitrateControl_Stepping     0
#define IDC_BitrateControl_Edit         0
#define IDC_BitrateControl_Slider       0
#define IDC_BitrateControl_Meter        207
#define IDC_BitrateControl_Actual       208

#define IDC_FrameRateControl_Label      210
#define IDC_FrameRateControl_Minimum    211
#define IDC_FrameRateControl_Maximum    212
#define IDC_FrameRateControl_Default    213
#define IDC_FrameRateControl_Stepping   214
#define IDC_FrameRateControl_Edit       215
#define IDC_FrameRateControl_Slider     216
#define IDC_FrameRateControl_Meter      217
#define IDC_FrameRateControl_Actual     218

#define IDC_VideoStandard_Edit          220

#define IDC_CONTROL_DEFAULT             230

#define IDC_Pan_Label                   400
#define IDC_Pan_Minimum                 0
#define IDC_Pan_Maximum                 0
#define IDC_Pan_Default                 0
#define IDC_Pan_Stepping                0
#define IDC_Pan_Edit                    405
#define IDC_Pan_Slider                  406
#define IDC_Pan_Auto                    407

#define IDC_Tilt_Label                  410
#define IDC_Tilt_Minimum                0
#define IDC_Tilt_Maximum                0
#define IDC_Tilt_Default                0
#define IDC_Tilt_Stepping               0
#define IDC_Tilt_Edit                   415
#define IDC_Tilt_Slider                 416
#define IDC_Tilt_Auto                   417

#define IDC_Roll_Label                  420
#define IDC_Roll_Minimum                0
#define IDC_Roll_Maximum                0
#define IDC_Roll_Default                0
#define IDC_Roll_Stepping               0
#define IDC_Roll_Edit                   425
#define IDC_Roll_Slider                 426
#define IDC_Roll_Auto                   427

#define IDC_Zoom_Label                  430
#define IDC_Zoom_Minimum                0
#define IDC_Zoom_Maximum                0
#define IDC_Zoom_Default                0
#define IDC_Zoom_Stepping               0
#define IDC_Zoom_Edit                   435
#define IDC_Zoom_Slider                 436
#define IDC_Zoom_Auto                   437

#define IDC_Exposure_Label              440
#define IDC_Exposure_Minimum            0
#define IDC_Exposure_Maximum            0
#define IDC_Exposure_Default            0
#define IDC_Exposure_Stepping           0
#define IDC_Exposure_Edit               445
#define IDC_Exposure_Slider             446
#define IDC_Exposure_Auto               447

#define IDC_Iris_Label                  450
#define IDC_Iris_Minimum                0
#define IDC_Iris_Maximum                0
#define IDC_Iris_Default                0
#define IDC_Iris_Stepping               0
#define IDC_Iris_Edit                   455
#define IDC_Iris_Slider                 456
#define IDC_Iris_Auto                   457

#define IDC_Focus_Label                 460
#define IDC_Focus_Minimum               0
#define IDC_Focus_Maximum               0
#define IDC_Focus_Default               0
#define IDC_Focus_Stepping              0
#define IDC_Focus_Edit                  465
#define IDC_Focus_Slider                466
#define IDC_Focus_Auto                  467

#define IDC_FlipVertical_Edit           470

#define IDC_FlipHorizontal_Edit         480

#define IDC_Brightness_Label            500
#define IDC_Brightness_Minimum          0
#define IDC_Brightness_Maximum          0
#define IDC_Brightness_Default          0
#define IDC_Brightness_Stepping         0
#define IDC_Brightness_Edit             505
#define IDC_Brightness_Slider           506
#define IDC_Brightness_Auto             507

#define IDC_Contrast_Label              510
#define IDC_Contrast_Minimum            0
#define IDC_Contrast_Maximum            0
#define IDC_Contrast_Default            0
#define IDC_Contrast_Stepping           0
#define IDC_Contrast_Edit               515
#define IDC_Contrast_Slider             516
#define IDC_Contrast_Auto               517

#define IDC_Hue_Label                   520
#define IDC_Hue_Minimum                 0
#define IDC_Hue_Maximum                 0
#define IDC_Hue_Default                 0
#define IDC_Hue_Stepping                0
#define IDC_Hue_Edit                    525
#define IDC_Hue_Slider                  526
#define IDC_Hue_Auto                    527

#define IDC_Saturation_Label            530
#define IDC_Saturation_Minimum          0
#define IDC_Saturation_Maximum          0
#define IDC_Saturation_Default          0
#define IDC_Saturation_Stepping         0
#define IDC_Saturation_Edit             535
#define IDC_Saturation_Slider           536
#define IDC_Saturation_Auto             537

#define IDC_Sharpness_Label             540
#define IDC_Sharpness_Minimum           0
#define IDC_Sharpness_Maximum           0
#define IDC_Sharpness_Default           0
#define IDC_Sharpness_Stepping          0
#define IDC_Sharpness_Edit              545
#define IDC_Sharpness_Slider            546
#define IDC_Sharpness_Auto              547

#define IDC_Gamma_Label                 550
#define IDC_Gamma_Minimum               0
#define IDC_Gamma_Maximum               0
#define IDC_Gamma_Default               0
#define IDC_Gamma_Stepping              0
#define IDC_Gamma_Edit                  555
#define IDC_Gamma_Slider                556
#define IDC_Gamma_Auto                  557

#define IDC_ColorEnable_Label           560
#define IDC_ColorEnable_Minimum         0
#define IDC_ColorEnable_Maximum         0
#define IDC_ColorEnable_Default         0
#define IDC_ColorEnable_Stepping        0
#define IDC_ColorEnable_Edit            565
#define IDC_ColorEnable_Slider          566
#define IDC_ColorEnable_Auto            567

#define IDC_WhiteBalance_Label          570
#define IDC_WhiteBalance_Minimum        0
#define IDC_WhiteBalance_Maximum        0
#define IDC_WhiteBalance_Default        0
#define IDC_WhiteBalance_Stepping       0
#define IDC_WhiteBalance_Edit           575
#define IDC_WhiteBalance_Slider         576
#define IDC_WhiteBalance_Auto           577

#define IDC_BacklightComp_Label         580
#define IDC_BacklightComp_Minimum       0
#define IDC_BacklightComp_Maximum       0
#define IDC_BacklightComp_Default       0
#define IDC_BacklightComp_Stepping      0
#define IDC_BacklightComp_Edit          585
#define IDC_BacklightComp_Slider        586
#define IDC_BacklightComp_Auto          587

#define IDC_CPULoad_Label               700
#define IDC_CPULoad_Minimum             701
#define IDC_CPULoad_Maximum             702
#define IDC_CPULoad_Default             703
#define IDC_CPULoad_Stepping            704
#define IDC_CPULoad_Edit                705
#define IDC_CPULoad_Slider              706
#define IDC_CPULoad_Meter               707
#define IDC_CPULoad_Actual              708

#define IDC_MaxProcessingTime_Label     710
#define IDC_MaxProcessingTime_Minimum   711
#define IDC_MaxProcessingTime_Maximum   712
#define IDC_MaxProcessingTime_Default   713
#define IDC_MaxProcessingTime_Stepping  714
#define IDC_MaxProcessingTime_Edit      715
#define IDC_MaxProcessingTime_Slider    716
#define IDC_MaxProcessingTime_Meter     717
#define IDC_MaxProcessingTime_Actual    718

#define IDC_Freeze_Picture_Request      720

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         341
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif

#endif // } USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\tapivdec.h ===
/****************************************************************************
 *  @doc INTERNAL TAPIVDEC
 *
 *  @module TAPIVDec.h | Header file for the <c CTAPIVDec>
 *    class used to implement the TAPI H.26X Video Decoder filter.
 ***************************************************************************/

/****************************************************************************
                                                                Table Of Contents
****************************************************************************/
/****************************************************************************
@doc INTERNAL

@contents1 Contents | To display a list of topics by category, click any
of the contents entries below. To display an alphabetical list of
topics, choose the Index button.

@head2 Introduction |
This DLL implements the TAPI MSP H.26X Video Decoder filter. This filter
differs from traditional Microsoft Windows desktop video codecs:

It operates over unreliable communication channels using RTP/UDP/IP (H.323)
It has many modes of operation (H.263 options)
It needs to handle or generate call control specific (H.245) commands
It implements different decoding algorithms in order to adapt its CPU usage

Like other desktop video decoders, it needs to operate in real-time.

The TAPI incoming video stack relies on this video decoder to expose a
RTP-packetized compressed video pin, and uncompressed video output pin using
the DirectShow model. This video decoder presents its input pins to the network
source filter and is able to reassemble and decompress raw RTP packets, to
deliver uncompressed video frames to the downstream render filter.

Its uncompressed video output pin implements a new H.245 command interface to
receive H.245 picture freeze requests. We also define an H.245 command outgoing
interface to allow the video input pin of this video decoder to issue H.245
commands such as requests for I-frame, group of blocks, or macro-block updates
due to packet loss.

It used extended bitmap info headers for H.261 and H.263 video streams to
retrieve from the compressed video input pin a list of optional mode of
decompression supported by the decoder.

It also exposes interfaces to allow users to control video quality settings
such as brightness, contrast, hue, saturation, gamma and sharpness, by applying
the necessary post-processing operators. It also exposes an interface to
simulate local camera control functionality such as pan, tilt and zoom.

Finally, it implements a new H.245 capability interface. This interface provides
the TAPI TSP/MSP call control components with information needed to resolve
capabilities.

@head2 Implementation |

The TAPI H.26X Video Decoder filter currently loads TAPIH263.DLL or TAPIH261.DLL
dynamically and calls a unique entry point (DriverProc) exposed by those
DLLs to decompress the incoming video data. The video decoder filter is
responsible for re-assembling the incoming RTP packets and watch dynamic format
changes in the content of those packets. If the incoming RTP packets use a
different encoding format (different encoding - H.261 vs H.263, different image
size - SQCIF vs QCIF vs CIF) it dynamically recongures the TAPIH26X DLL and
changes the format of the output media sample to let the downstream filter
know about the format change.

@head2 Video decoder filter application interfaces |
Although the following interfaces are not exposed directly to applications, interfaces
exposed to applications simply delegate to those interfaces.

@head3 IAMVideoProcAmp application interface|
@subindex IAMVideoProcAmp methods
@subindex IAMVideoProcAmp structures and enums

@head3 ICameraControl application interface|
@subindex ICameraControl methods
@subindex ICameraControl structures and enums

@head2 Video decoder filter MSP interfaces |

@head3 IH245Capability application interface|
@subindex IH245Capability methods
@subindex IH245Capability structures and enums

@head2 Video decoder filter output pin TAPI interfaces |

@head3 ICPUControl interface|
@subindex ICPUControl methods

@head3 IFrameRateControl interface (output pin)|
@subindex IFrameRateControl methods (output pin)
@subindex IFrameRateControl structures and enums (output pin)

@head3 IH245DecoderCommand interface|
@subindex IH245DecoderCommand methods

@head2 Video decoder filter input pin TAPI interfaces |

@head3 IFrameRateControl interface (input pin)|
@subindex IFrameRateControl methods (input pin)
@subindex IFrameRateControl structures and enums (input pin)

@head3 IBitrateControl interface|
@subindex IBitrateControl methods
@subindex IBitrateControl structures and enums

@head2 Classes |
@subindex Classes

@head2 Modules |
@subindex Modules
@subindex Constants

@head2 Code information |

The only libraries necessary in retail mode (w/o property pages) are ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib kernel32.lib ole32.lib uuid.lib msvcrt.lib

@head3 Exports |
DllCanUnloadNow
DllGetClassObject
DllRegisterServer
DllUnregisterServer

@head3 Imports |
MSVCRT.DLL:
??2@YAPAXI@Z
??3@YAXPAX@Z
_EH_prolog
__CxxFrameHandler
_purecall
memcmp

WINMM.DLL:
timeGetTime

KERNEL32.DLL:
DeleteCriticalSection
DisableThreadLibraryCalls
EnterCriticalSection
FreeLibrary
GetLastError
GetModuleFileNameA
GetVersionExA
InitializeCriticalSection
InterlockedDecrement
InterlockedIncrement
LeaveCriticalSection
MulDiv
MultiByteToWideChar
lstrlenA

MSVFW32.DLL:
ICClose
ICDecompress
ICLocate
ICSendMessage

USER32.DLL:
GetDC
ReleaseDC
wsprintfA

GDI32.DLL:
GetDeviceCaps

ADVAPI32.DLL:
RegCloseKey
RegCreateKeyA
RegDeleteKeyA
RegEnumKeyExA
RegOpenKeyExA
RegSetValueA
RegSetValueExA

OLE32.DLL:
CoCreateInstance
CoFreeUnusedLibraries
CoInitialize
CoTaskMemAlloc
CoTaskMemFree
CoUninitialize
StringFromGUID2

@head3 Code size |
Compile options: /nologo /MDd /W3 /GX /O1 /X /I "..\..\inc" /I "..\..\..\ddk\inc" /I "..\..\..\..\dev\tools\amovsdk.20\include" /I "..\..\..\..\dev\tools\amovsdk.20\classes\base" /I "..\..\..\..\dev\ntddk\inc" /I "..\..\..\..\dev\inc" /I "..\..\..\..\dev\tools\c32\inc" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "DLL" /D "STRICT" /FR"Release/" /Fp"Release/TAPIKsIf.pch" /YX /Fo"Release/" /Fd"Release/" /FD /c

Link options: ..\..\..\..\dev\tools\amovsdk.20\lib\strmbase.lib ..\..\..\ddk\lib\i386\ksuser.lib ..\..\..\ddk\lib\i386\ksguid.lib comctl32.lib msvcrt.lib winmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /base:"0x1e180000" /entry:"DllEntryPoint" /dll /incremental:no /pdb:"Release/TAPIKsIf.pdb" /map:"Release/TAPIKsIf.map" /machine:I386 /nodefaultlib /def:".\TAPIKsIf.def" /out:"Release/TAPIKsIf.ax" /implib:"Release/TAPIKsIf.lib"

Resulting size: 52KB


***********************************************************************
@contents2 IAMVideoProcAmp methods |
@index mfunc | CPROCAMPMETHOD

***********************************************************************
@contents2 IAMVideoProcAmp structures and enums |
@index struct,enum | CPROCAMPSTRUCTENUM

***********************************************************************
@contents2 ICameraControl methods |
@index mfunc | CCAMERACMETHOD

***********************************************************************
@contents2 ICameraControl structures and enums |
@index struct,enum | CCAMERACSTRUCTENUM

***********************************************************************
@contents2 IH245Capability methods |
@index mfunc | CH245VIDCMETHOD

***********************************************************************
@contents2 IH245Capability structures and enums |
@index struct,enum | H245VIDCSTRUCTENUM

***********************************************************************
@contents2 ICPUControl methods |
@index mfunc | CCPUCMETHOD

***********************************************************************
@contents2 IFrameRateControl methods (output pin) |
@index mfunc | CFPSOUTCMETHOD

***********************************************************************
@contents2 IFrameRateControl structures and enums (output pin) |
@index struct,enum | CFPSCSTRUCTENUM

***********************************************************************
@contents2 IH245DecoderCommand methods |
@index mfunc | CH245COMMMETHOD

***********************************************************************
@contents2 IFrameRateControl methods (input pin) |
@index mfunc | CFPSINCMETHOD

***********************************************************************
@contents2 IFrameRateControl structures and enums (input pin) |
@index struct,enum | CFPSCSTRUCTENUM

***********************************************************************
@contents2 IBitrateControl methods |
@index mfunc | CBPSCMETHOD

***********************************************************************
@contents2 IBitrateControl structures and enums |
@index struct,enum | CBPSCSTRUCTENUM

***********************************************************************
@contents2 Modules |
@index module |

***********************************************************************
@contents2 Classes |
@index class |
@index mdata, mfunc | CTAPIVDECCLASS,CTAPIVDECMETHOD
@index mdata, mfunc | COUTPINCLASS,COUTPINMETHOD,CCPUCMETHOD,CFPSOUTCMETHOD
@index mdata, mfunc | CINPINCLASS,CINPINMETHOD,CFPSINCMETHOD,CBITRATECMETHOD
@index mdata, mfunc | CH245COMMMETHOD,CH245VIDCMETHOD
@index mdata, mfunc | CCAMERACPCLASS,CCAMERACMETHOD,CCAMERACPMETHOD
@index mdata, mfunc | CPROCAMPPCLASS,CPROCAMPMETHOD,CPROCAMPPMETHOD
@index mdata, mfunc | CPROPEDITCLASS,CPROPEDITMETHO

***********************************************************************
@contents2 Constants |
@index const |
****************************************************************************/

#ifndef _TAPIVDEC_H_
#define _TAPIVDEC_H_

#ifdef DBG
extern DWORD g_dwVideoDecoderTraceID;

#ifndef FX_ENTRY
#define FX_ENTRY(s) static char _this_fx_ [] = s;
#define _fx_ ((LPSTR) _this_fx_)
#endif
#else
#ifndef FX_ENTRY
#define FX_ENTRY(s)
#endif
#define _fx_
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECCLASS
 *
 *  @class CTAPIVDec | This class implements the TAPI H.26X Video Decoder
 *    filter.
 *
 *  @mdata HIC | CTAPIVDec | m_hic | ICM handle to the decoder
 *
 *  @mdata FOURCC | CTAPIVDec | m_FourCCIn | FourCC used to get a handle
 *    to the decoder.
 *
 *  @mdata BOOL | CTAPIVDec | m_fStreaming | Streaming state.
 *
 *  @mdata DWORD | CTAPIVDec | m_pIH245EncoderCommand | Pointer to the
 *    outgoing <i IH245EncoderCommand> interface exposed by the channel
 *    controller to send H.245 commands to the remote encoder.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesReceived | Counts number of
 *    frames received, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumBytesReceived | Counts number of
 *    bytes received, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesDelivered | Counts number of
 *    frames delivered, reset every second or so.
 *
 *  @mdata DWORD | CTAPIVDec | m_dwNumFramesDecompressed | Counts number of
 *    frames decompressed, reset every second or so.
 ***************************************************************************/
class CTAPIVDec : public CBaseFilter
,public IRTPPayloadHeaderMode
#ifdef USE_PROPERTY_PAGES
,public ISpecifyPropertyPages
#endif
#ifdef USE_CAMERA_CONTROL
,public ICameraControl
#endif
#ifdef USE_VIDEO_PROCAMP
,public IVideoProcAmp
#endif
{
        public:
        DECLARE_IUNKNOWN

        CTAPIVDec(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr);
        ~CTAPIVDec();
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);

        // Pin enumeration functions.
        CBasePin* GetPin(IN int n);
        int GetPinCount();

        // Overrides CBaseFilter methods.
        STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
#if 0
        STDMETHODIMP JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName);
#endif

    // Override state changes to allow derived transform filter to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

        // Implement IRTPPayloadHeaderMode
        STDMETHODIMP SetMode(IN RTPPayloadHeaderMode rtpphmMode);

#ifdef USE_PROPERTY_PAGES
        // ISpecifyPropertyPages methods
        STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

#ifdef USE_VIDEO_PROCAMP
        // Implement IAMVideoProcAmp
        STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);
#endif

#ifdef USE_CAMERA_CONTROL
        // Implement ICameraControl
        STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);
#endif

        private:

        friend class CTAPIInputPin;
        friend class CTAPIOutputPin;

    // These hold our input and output pins
    CTAPIInputPin *m_pInput;
    CTAPIOutputPin *m_pOutput;

        // This method does all the work
        HRESULT Transform(IN IMediaSample *pIn, IN LONG lPrefixSize);

        // Standard setup for output sample
        HRESULT InitializeOutputSample(IMediaSample *pSample, IMediaSample **ppOutSample);

    // Critical section protecting filter state.
    CCritSec m_csFilter;

    // Critical section stopping state changes (ie Stop) while we're
    // processing a sample.
    //
    // This critical section is held when processing
    // events that occur on the receive thread - Receive() and EndOfStream().
    //
    // If you want to hold both m_csReceive and m_csFilter then grab
    // m_csFilter FIRST - like CTransformFilter::Stop() does.
    CCritSec m_csReceive;

#ifdef USE_DFC
        CAMEvent m_evStop;
#endif

        // Did we just skip a frame?
        BOOL m_bSampleSkipped;

        // @todo Use different exports for all the driver proc calls you make!
        LPFNDRIVERPROC  m_pDriverProc;  // DriverProc() function pointer
#if DXMRTP <= 0
        HINSTANCE               m_hTAPIH26XDLL; // DLL Handle to TAPIH263.dll or TAPIH261.dll
#endif
        LPINST                  m_pInstInfo;
        FOURCC                  m_FourCCIn;
        BOOL                    m_fICMStarted;

        // Current output format - content may change when going back and forth
        // between GDI and DDraw
        AM_MEDIA_TYPE   *m_pMediaType;

        // RTP packet reassembly helpers
        BOOL  m_fReceivedKeyframe;
        DWORD m_dwMaxFrameSize;
        DWORD m_dwCurrFrameSize;
        PBYTE m_pbyReconstruct;
        BOOL  m_fDiscontinuity;
        DWORD m_dwLastIFrameRequest;
        DWORD m_dwLastSeq;

#ifdef USE_CAMERA_CONTROL
        LONG m_lCCPan;
        LONG m_lCCTilt;
        LONG m_lCCZoom;
        BOOL m_fFlipVertical;
        BOOL m_fFlipHorizontal;
#endif

#ifdef USE_VIDEO_PROCAMP
        LONG m_lVPABrightness;
        LONG m_lVPAContrast;
        LONG m_lVPASaturation;
#endif

        // H.245 Video Decoder command
        BOOL  m_fFreezePicture;
        DWORD m_dwFreezePictureStartTime;

        // Video channel control interface
        IH245EncoderCommand *m_pIH245EncoderCommand;

        // Called to send an I-frame request
        STDMETHODIMP videoFastUpdatePicture();

        // Frame rate, bitrate, and CPU control helpers
        DWORD           m_dwNumFramesReceived;
        DWORD           m_dwNumBytesReceived;
        DWORD           m_dwNumFramesDelivered;
        DWORD           m_dwNumFramesDecompressed;
        DWORD           m_dwNumMsToDecode;
        DWORD           m_dwLastRefDeliveredTime;
        DWORD           m_dwLastRefReceivedTime;
        CAMEvent        m_EventAdvise;
        DWORD           m_dwLastRenderTime;

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        RTPPayloadHeaderMode m_RTPPayloadHeaderMode;
};

#endif // _TAPIVDEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivdec\tapivdec.cpp ===
/****************************************************************************
 *  @doc INTERNAL TAPIVDEC
 *
 *  @module TAPIVDec.cpp | Source file for the <c CTAPIVDec>
 *    class used to implement the TAPI H.26X Video Decoder filter.
 ***************************************************************************/

#include "Precomp.h"

//#define NO_YUV_MODES 1


typedef struct
{
    WORD biWidth;
    WORD biHeight;
} MYFRAMESIZE;

// Array of known ITU sizes
MYFRAMESIZE g_ITUSizes[8] =
{
        {    0,   0 }, {  128,  96 }, {  176, 144 }, {  352, 288 },
        {  704, 576 }, { 1408,1152 }, {    0,   0 }, {    0,   0 }
};

#define MIN_IFRAME_REQUEST_INTERVAL 15000UL

#ifdef DEBUG
// Setup data
const AMOVIESETUP_MEDIATYPE sudInputTypes[] =
{
        {
                &MEDIATYPE_Video,       // Major type
                &MEDIASUBTYPE_NULL      // Minor type
        },
        {
                &MEDIATYPE_RTP_Single_Stream,   // Major type
                &MEDIASUBTYPE_NULL                              // Minor type
        }
};

const AMOVIESETUP_MEDIATYPE sudOutputType[] =
{
        {
                &MEDIATYPE_Video,       // Major type
                &MEDIASUBTYPE_NULL      // Minor type
        }
};

const AMOVIESETUP_PIN sudDecoderPins[] =
{
        {
                L"H26X In",                     // Pin string name
                FALSE,                          // Is it rendered
                FALSE,                          // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                2,                                      // Number of types
                sudInputTypes           // Pin details
        },
        {
                L"Video Out",           // Pin string name
                FALSE,                          // Is it rendered
                TRUE,                           // Is it an output
                FALSE,                          // Can we have none
                FALSE,                          // Can we have many
                &CLSID_NULL,            // Connects to filter
                NULL,                           // Connects to pin
                1,                                      // Number of types
                sudOutputType           // Pin details
        }
};

const AMOVIESETUP_FILTER sudVideoDecoder =
{
        &__uuidof(TAPIVideoDecoder),// Filter CLSID
        L"TAPI H.26X Video Decoder",// String name
        MERIT_DO_NOT_USE,                       // Filter merit
        2,                                                      // Number pins
        sudDecoderPins                          // Pin details
};
#endif

#if DXMRTP <= 0

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] =
{
    VIDEO_DECODER_TEMPLATE

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

    ,INPUT_PIN_PROP_TEMPLATE

    ,OUTPUT_PIN_PROP_TEMPLATE

#ifdef USE_CAMERA_CONTROL
    ,DECCAMERA_CONTROL_TEMPLATE
#endif

#ifdef USE_VIDEO_PROCAMP
    ,VIDEO_SETTING_PROP_TEMPLATE
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */
};
int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
        return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
        return AMovieDllRegisterServer2(FALSE);
}

EXTERN_C BOOL WINAPI DllEntryPoint( HANDLE hInst, ULONG lReason, LPVOID lpReserved );

BOOL WINAPI DllMain( HANDLE hInst, DWORD dwReason, LPVOID lpReserved )
{
        switch (dwReason)
        {
                case DLL_PROCESS_ATTACH:
                {
                        break;
                }

                case DLL_PROCESS_DETACH:
                {
                        break;
                }
        }

        // Pass the call onto the DShow SDK initialization
        return DllEntryPoint(hInst, dwReason, lpReserved);
}
#endif /* DXMRTP <= 0 */

#if DBG
DWORD g_dwVideoDecoderTraceID = INVALID_TRACEID;
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc void | CTAPIVDec | CTAPIVDec | This method is the constructor
 *    for the <c CTAPIVDec> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVDec::CTAPIVDec(IN LPUNKNOWN pUnkOuter, IN TCHAR *pName, OUT HRESULT *pHr)
    : CBaseFilter(pName, pUnkOuter, &m_csFilter, __uuidof(TAPIVideoDecoder))
{
        FX_ENTRY("CTAPIVDec::CTAPIVDec")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        m_pInput = NULL;
        m_pOutput = NULL;

        m_pDriverProc = NULL;
#if DXMRTP <= 0
        m_hTAPIH26XDLL = NULL;
#endif
        m_pInstInfo = NULL;
        m_FourCCIn = 0xFFFFFFFF;
        m_pbyReconstruct = NULL;
        m_fICMStarted = FALSE;

#ifdef USE_CAMERA_CONTROL
        m_lCCPan  = 0L;
        m_lCCTilt = 0L;
        m_lCCZoom = 10L;
        m_fFlipVertical = FALSE;
        m_fFlipHorizontal = FALSE;
#endif

#ifdef USE_VIDEO_PROCAMP
        m_lVPABrightness = 128L;
        m_lVPAContrast   = 128L;
        m_lVPASaturation = 128L;
#endif

        // H.245 Video Decoder & Encoder commands
        m_fFreezePicture = FALSE;
        m_pIH245EncoderCommand = NULL;

        // Current output format
        m_pMediaType = NULL;

        m_bSampleSkipped = FALSE;

        //for the RTP Payload Header Mode (0=draft, 1=RFC2190)
        m_RTPPayloadHeaderMode = RTPPayloadHeaderMode_Draft;


        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc void | CTAPIVDec | ~CTAPIVDec | This method is the destructor
 *    for the <c CTAPIVDec> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIVDec::~CTAPIVDec()
{
        FX_ENTRY("CTAPIVDec::~CTAPIVDec")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        if (m_pInstInfo)
        {
                // Terminate H.26X decompression
                if (m_fICMStarted)
                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::~CTAPIVDec - ICM_DECOMPRESSEX_END\r\n");
#endif
                        (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                        m_fICMStarted = FALSE;
                }

                // Terminate H.26X decoder
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::~CTAPIVDec - DRV_CLOSE\r\n");
                OutputDebugString("CTAPIVDec::~CTAPIVDec - DRV_FREE\r\n");
#endif
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                m_pInstInfo = NULL;
                m_pDriverProc = NULL;
        }

#if DXMRTP <= 0
        // Release TAPIH26X.DLL
        if (m_hTAPIH26XDLL)
                FreeLibrary(m_hTAPIH26XDLL), m_hTAPIH26XDLL = NULL;
#endif

        // Release H.245 Encoder command outgoing interface
        if (m_pIH245EncoderCommand)
                m_pIH245EncoderCommand->Release();

        // Current output format
        if (m_pMediaType)
                DeleteMediaType(m_pMediaType); m_pMediaType = NULL;

        // Release the pins
        if (m_pOutput)
                delete m_pOutput;
        if (m_pInput)
                delete m_pInput;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc CUnknown* | CTAPIVDec | CreateInstance | This
 *    method is called by DShow to create an instance of the TAPI H.26X Video
 *    Decoder Transform filter referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown *CALLBACK CTAPIVDecCreateInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr)
{
#if DBG
    if (g_dwVideoDecoderTraceID == INVALID_TRACEID)
    {
        // if two threads happen to call this method at the same time, it is
        // serialized inside TraceRegister.
        g_dwVideoDecoderTraceID = TraceRegister(TEXT("dxmrtp_VideoDecoder"));
    }
#endif

    CUnknown *pUnknown = NULL;

        FX_ENTRY("CTAPIVDec::CreateInstance")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        if (!pHr)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        if (!(pUnknown = new CTAPIVDec(pUnkOuter, NAME("TAPI H.26X Video Decoder"), pHr)))
        {
                *pHr = E_OUTOFMEMORY;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: new CTAPIVDec failed", _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: new CTAPIVDec created", _fx_));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVideoProcAmp>, <i IAMCameraControl>, and
 *    <i IH245Capability>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IRTPPayloadHeaderMode))
        {
                if (FAILED(Hr = GetInterface(static_cast<IRTPPayloadHeaderMode*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IRTPPayloadHeaderMode failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IRTPPayloadHeaderMode*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_VIDEO_PROCAMP
        else if (riid == __uuidof(IVideoProcAmp))
        {
                if (FAILED(Hr = GetInterface(static_cast<IVideoProcAmp*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for IVideoProcAmp failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: IVideoProcAmp*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
#ifdef USE_CAMERA_CONTROL
        else if (riid == __uuidof(ICameraControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<ICameraControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ICameraControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ICameraControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif

        if (FAILED(Hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv)))
        {
                if (FAILED(Hr = CUnknown::NonDelegatingQueryInterface(riid, ppv)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
                }
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::GetPages")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

#ifdef USE_CAMERA_CONTROL
#ifdef USE_VIDEO_PROCAMP
        pPages->cElems = 2;
#else
        pPages->cElems = 1;
#endif
#else
#ifdef USE_VIDEO_PROCAMP
        pPages->cElems = 1;
#else
        pPages->cElems = 0;
#endif
#endif
        if (pPages->cElems)
        {
                if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
                else
                {
#ifdef USE_CAMERA_CONTROL
#ifdef USE_VIDEO_PROCAMP
                        pPages->pElems[0] = __uuidof(TAPICameraControlPropertyPage);
                        pPages->pElems[1] = __uuidof(TAPIProcAmpPropertyPage);
#else
                        pPages->pElems[0] = __uuidof(TAPICameraControlPropertyPage);
#endif
#else
#ifdef USE_VIDEO_PROCAMP
                        pPages->pElems[0] = __uuidof(TAPIProcAmpPropertyPage);
#endif
#endif
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Transform | This method is used
 *    to perform the transform operations supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @parm IMediaSample** | ppOut | Specifies the address of a pointer to the
 *    output IMediaSample interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::InitializeOutputSample(IMediaSample *pIn, IMediaSample **ppOut)
{
        HRESULT                                 Hr;
        IMediaSample                    *pOutSample;
        AM_SAMPLE2_PROPERTIES   *pProps;
        DWORD                                   dwFlags;
        LONGLONG                                MediaStart, MediaEnd;

        FX_ENTRY("CTAPIVDec::InitializeOutputSample")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIn);
        ASSERT(ppOut);
        if (!pIn || !ppOut)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        // default - times are the same
        pProps = m_pInput->SampleProps();
        dwFlags = m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0;

        // This will prevent the image renderer from switching us to DirectDraw
        // when we can't do it without skipping frames because we're not on a
        // keyframe. If it really has to switch us, it still will, but then we
        // will have to wait for the next keyframe
        if (!(pProps->dwSampleFlags & AM_SAMPLE_SPLICEPOINT))
        {
                dwFlags |= AM_GBF_NOTASYNCPOINT;
        }

        // Make sure the allocator is alive
        ASSERT(m_pOutput->m_pAllocator != NULL);
        if (!m_pOutput->m_pAllocator)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid allocator", _fx_));
                goto MyExit;
        }

        // Get an output sample from the allocator
        if (FAILED(Hr = m_pOutput->m_pAllocator->GetBuffer(&pOutSample, pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID ? &pProps->tStart : NULL, pProps->dwSampleFlags & AM_SAMPLE_STOPVALID ? &pProps->tStop : NULL, dwFlags)) || !pOutSample)
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: couldn't get output buffer", _fx_));
                goto MyExit;
        }

        *ppOut = pOutSample;

        // Initialize output sample state
        if (pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID)
        {
                pOutSample->SetTime(&pProps->tStart, &pProps->tStop);
        }
        if (pProps->dwSampleFlags & AM_SAMPLE_SPLICEPOINT)
        {
                pOutSample->SetSyncPoint(TRUE);
        }
        if (pProps->dwSampleFlags & AM_SAMPLE_DATADISCONTINUITY)
        {
                pOutSample->SetDiscontinuity(TRUE);
                m_bSampleSkipped = FALSE;
        }

        // Copy the media times
        if (SUCCEEDED(pIn->GetMediaTime(&MediaStart, &MediaEnd)))
        {
                pOutSample->SetMediaTime(&MediaStart, &MediaEnd);
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


#ifdef DEBUG
// #define LOGPAYLOAD_TOFILE 1
// #define LOGRTP_ON 1
///#define LOGPAYLOAD_ON 1
// #define LOGIFRAME_ON 1
// #define LOGSTREAMING_ON 1
#endif
#ifdef LOGPAYLOPAD_ON
int g_dbg_LOGPAYLOAD_TAPIVDec=-1;
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::SetMode(IN RTPPayloadHeaderMode rtpphmMode)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::SetMode")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190);
        if (!(rtpphmMode == RTPPayloadHeaderMode_Draft || rtpphmMode == RTPPayloadHeaderMode_RFC2190))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Save new target packet size
        m_RTPPayloadHeaderMode = rtpphmMode;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   New RTP Payload Header mode: %s", _fx_, (rtpphmMode == RTPPayloadHeaderMode_RFC2190)?"RFC2190":"Draft"));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}



/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Transform | This method is used
 *    to perform the transform operations supported by this filter.
 *
 *  @parm IMediaSample* | pIn | Specifies a pointer to the input
 *    IMediaSample interface.
 *
 *  @parm LONG | lPrefixSize | Specifies The size of RTP prefix in the sample.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::Transform(IN IMediaSample *pIn, IN LONG lPrefixSize)
{
        HRESULT                         Hr = NOERROR;
        PBYTE                           pbySrc = NULL;
        PBYTE                           pbyDst = NULL;
        LPBITMAPINFOHEADER      lpbiSrc;
        LPBITMAPINFOHEADER      lpbiDst;
        DWORD                           dwFlags = 0UL;
        DWORD                           dwImageSize = 0UL;
        ICDECOMPRESSEX          icDecompress;
        LRESULT                         lRes;
        FOURCCMap                       fccOut;
        AM_MEDIA_TYPE           *pmtIn = NULL;
        AM_MEDIA_TYPE           *pmtOut = NULL;
        IMediaSample            *pOut = NULL;
        BOOL                            fFormatChanged = FALSE;
        BOOL                            bSkipPacket = FALSE;

        FX_ENTRY("CTAPIVDec::Transform")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIn);
        if (!pIn)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }
        ASSERT(m_pInstInfo);
        ASSERT(m_pInput);
        ASSERT(m_pOutput);
        ASSERT(m_pInput->m_mt.pbFormat);
        ASSERT(m_pOutput->m_mt.pbFormat);
        if (!m_pInstInfo || !m_pInput || !m_pOutput || !m_pInput->m_mt.pbFormat || !m_pOutput->m_mt.pbFormat)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Decoder not initialized or not streaming", _fx_));
                goto MyExit;
        }

        // Get an output sample
        if (FAILED(Hr = InitializeOutputSample(pIn, &pOut)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Couldn't get output buffer", _fx_));
                goto MyExit;
        }

        // Get pointers to the input and output buffers
        if (FAILED(Hr = pIn->GetPointer(&pbySrc)) || !pbySrc)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid input buffer", _fx_));
                goto MyExit;
        }
        if (FAILED(Hr = pOut->GetPointer(&pbyDst)) || !pbyDst)
        {
                Hr = E_UNEXPECTED;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid output buffer", _fx_));
                goto MyExit;
        }

        // Get pointers to the input and output formats
        lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
        lpbiDst = HEADER(m_pOutput->m_mt.pbFormat);

        // We're getting variable size packets or frames - update the size
        dwImageSize = lpbiSrc->biSizeImage;
        lpbiSrc->biSizeImage = pIn->GetActualDataLength();

#ifdef DEBUG
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Pin:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(m_pInput->m_mt.pbFormat)->biCompression, HEADER(m_pInput->m_mt.pbFormat)->biBitCount, HEADER(m_pInput->m_mt.pbFormat)->biWidth, HEADER(m_pInput->m_mt.pbFormat)->biHeight, HEADER(m_pInput->m_mt.pbFormat)->biSize));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcSource.bottom));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Pin: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, HEADER(m_pOutput->m_mt.pbFormat)->biCompression, HEADER(m_pOutput->m_mt.pbFormat)->biBitCount, HEADER(m_pOutput->m_mt.pbFormat)->biWidth, HEADER(m_pOutput->m_mt.pbFormat)->biHeight, HEADER(m_pOutput->m_mt.pbFormat)->biSize, HEADER(m_pOutput->m_mt.pbFormat)->biSizeImage));
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pOutput->m_mt.pbFormat))->rcTarget.bottom));
        pIn->GetMediaType((AM_MEDIA_TYPE **)&pmtIn);
        if (pmtIn != NULL && pmtIn->pbFormat != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Spl:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, HEADER(pmtIn->pbFormat)->biCompression, HEADER(pmtIn->pbFormat)->biBitCount, HEADER(pmtIn->pbFormat)->biWidth, HEADER(pmtIn->pbFormat)->biHeight, HEADER(pmtIn->pbFormat)->biSize));
                DeleteMediaType(pmtIn);
        }
        else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Spl:  No format", _fx_));
        }
#endif

        // Do we need to switch from GDI to DDraw?
        pOut->GetMediaType((AM_MEDIA_TYPE **)&pmtOut);
        if (pmtOut != NULL && pmtOut->pbFormat != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld - Spl size = %ld", _fx_, HEADER(pmtOut->pbFormat)->biCompression, HEADER(pmtOut->pbFormat)->biBitCount, HEADER(pmtOut->pbFormat)->biWidth, HEADER(pmtOut->pbFormat)->biHeight, HEADER(pmtOut->pbFormat)->biSize, HEADER(pmtOut->pbFormat)->biSizeImage, pOut->GetActualDataLength()));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Src Spl Rec:left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcSource.bottom));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Dst Spl Rec:left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(pmtOut->pbFormat))->rcTarget.bottom));
        }
        else
        {
                pmtOut = NULL;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  No format - Spl size = %ld", _fx_, pOut->GetActualDataLength()));
        }

#ifdef DEBUG
        // Are we in direct draw mode?
    IDirectDraw *pidd;
    if (SUCCEEDED(pOut->QueryInterface(IID_IDirectDraw, (LPVOID *)&pidd)) && pidd != NULL)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  DDraw ON", _fx_));
        pidd->Release();
    }
    else
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Spl:  DDraw OFF", _fx_));
    }
#endif

        // Are we decompressing video frames or reassembling RTP packets?
        if (HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261)
        {
                // RTP packetized mode - reassemble the frame
                RtpHdr_t        *pRtpHdr;
                DWORD           dwPSCBytes = 0UL;
                DWORD           dwTRandPTYPEbytes = 0UL;
                DWORD           dwPayloadHeaderSize;
                DWORD           dwPreambleSize = 0;
                DWORD           dwITUSize;
                BOOL            fReceivedKeyframe;
                BOOL            fPacketLoss;
                DWORD           dwStartBit;
#if defined(LOGPAYLOAD_ON) || defined(LOGPAYLOAD_TOFILE) || defined(LOGIFRAME_ON) || defined(LOGSTREAMING_ON) || defined(LOGRTP_ON)
                HANDLE          g_TDebugFile;
                char            szTDebug[256];
                DWORD           d, GOBn;
                long            j;
#endif

                // Some inits
                dwITUSize = 0UL;

                // Look for the RTP header in this packet - the prefix contains the size
                // of the RTP header - move src pointer to the data right after it.
        if (lPrefixSize > 0)
        {
            RtpPrefixHdr_t *pPrefixHeader =
                (RtpPrefixHdr_t *)(((BYTE*)pbySrc) - lPrefixSize);

            if (pPrefixHeader->wPrefixID == RTPPREFIXID_HDRSIZE
                && pPrefixHeader->wPrefixLen == sizeof(RtpPrefixHdr_t))
            {
                // this is the prefix header provided by RTP source filter.

                dwPreambleSize = (DWORD)pPrefixHeader->lHdrSize;
            }
        }

        if (dwPreambleSize == 0)
        {
            return E_UNEXPECTED;
        }

                pRtpHdr = (RtpHdr_t *)(pbySrc);
                pbySrc += (DWORD)(dwPreambleSize);
#if defined(LOGPAYLOAD_ON) || defined(LOGRTP_ON)
                wsprintf(szTDebug, "RTP Header: PT=%ld, M=%ld, SEQ=%ld, TS=%lu\r\n", (DWORD)pRtpHdr->pt, (DWORD)pRtpHdr->m, (DWORD)(ntohs(pRtpHdr->seq)), (DWORD)(ntohl(pRtpHdr->ts)));
                OutputDebugString(szTDebug);
#endif

                // Check out the sequence number
                // If there is a gap between the new sequence number and the last
                // one, a frame got lost. Generate an I-Frame request then, but no more
                // often than one every 15 seconds.
                //
                // Is there a discontinuity in sequence numbers that was detected
                // in the past but not handled because an I-Frame request had already
                // been sent less than 15s ago? Is there a new discontinuity?
                fPacketLoss = ((DWORD)(ntohs(pRtpHdr->seq)) > 0UL) && (m_dwLastSeq != 0xFFFFFFFFUL) && (((DWORD)(ntohs(pRtpHdr->seq)) - 1) > m_dwLastSeq);
                if (m_fDiscontinuity || fPacketLoss)
                {
                        // Flush the reassembly buffer after a packet loss
                        if (fPacketLoss)
                        {
#ifdef LOGIFRAME_ON
                                OutputDebugString("Loss detected - Flushing reassembly buffer\r\n");
#endif
                                m_dwCurrFrameSize = 0UL;
                        }

                        // Issue an I-frame request only if we can and it is necessary
                        if (m_pIH245EncoderCommand)
                        {
                                DWORD dwNow = timeGetTime();

                                // Was the last time we issued an I-Frame request more than 15s ago?
                                if ((dwNow > m_dwLastIFrameRequest) && ((dwNow - m_dwLastIFrameRequest) > MIN_IFRAME_REQUEST_INTERVAL))
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Loss detected - Sending I-Frame request...", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("Loss detected - Sending I-Frame request...\r\n");
#endif

                                        m_dwLastIFrameRequest = dwNow;
                                        m_fDiscontinuity = FALSE;
                                        m_fReceivedKeyframe = FALSE;

                                        // Ask the remote endpoint for a refresh
                                        videoFastUpdatePicture();
                                }
                                else
                                {
                                        if (!m_fReceivedKeyframe)
                                        {
                                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Loss detected but too soon to send I-Frame request. Wait %ld ms", _fx_, MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest)));
#ifdef LOGIFRAME_ON
                                                wsprintf(szTDebug, "Loss detected but too soon to send I-Frame request. Wait %ld ms\r\n", MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest));
                                                OutputDebugString(szTDebug);
#endif
                                                m_fDiscontinuity = TRUE;
                                        }
                                        else
                                        {
                                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: Received a keyframe - resetting packet loss detector", _fx_));
#ifdef LOGIFRAME_ON
                                                OutputDebugString("Received a keyframe - resetting packet loss detector\r\n");
#endif
                                                m_fDiscontinuity = FALSE;
                                        }
                                }
                        }
                }
                m_dwLastSeq = (DWORD)(ntohs(pRtpHdr->seq));

                // Does the payload type of this packet matches the type of the video decoder
                // we are currently using - if not, pick up a new one
                if (pRtpHdr->pt == H263_PAYLOAD_TYPE)
                {
#define PF_F_BIT  0x80
#define PF_P_BIT  0x40
#define DRAFT_I_BIT (pbySrc[2] & 0x80)
#define RFC_4_I_BIT (pbySrc[1] & 0x10)
#define RFC_8_I_BIT (pbySrc[4] & 0x80)

                        // Let's reassemble those H.263 packets - strip the header of the packet
                        // and copy the payload in the video buffer

                        // Look for the first two bits to figure out what's the mode used.
                        // This will dictate the size of the header to be removed.
                        // Mode A is 4 bytes: first bit is set to 1,
                        // Mode B is 8 bytes: first bit is set to 0, second bit is set to 0,
                        // Mode C is 12 bytes: first bit is set to 0, second bit is set to 1.
                        dwPayloadHeaderSize = ((*pbySrc & PF_F_BIT) ? ((*pbySrc & PF_P_BIT) ? 12 : 8) : 4);

                        // Look at the payload header to figure out if the frame is a keyframe
                        // Update our flag to always remember this.
                        if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {  // 0 is the default mode
                            fReceivedKeyframe = (BOOL)DRAFT_I_BIT;
                        } else {
                            if (dwPayloadHeaderSize == 4) {
                                fReceivedKeyframe = (BOOL)RFC_4_I_BIT;
                            } else {    // both dwPayloadHeaderSize 8 and 12
                                fReceivedKeyframe = (BOOL)RFC_8_I_BIT;
                            }
                        }

#ifdef LOGPAYLOAD_ON
                        if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                            OutputDebugString("CTAPIVDec::Transform -- Draft Style Payload Header\r\n");
                        } else {
                            OutputDebugString("CTAPIVDec::Transform -- RFC 2190 Style Payload Header\r\n");
                        }
                        // Output some debug stuff
                        if (dwPayloadHeaderSize == 4)
                        {
                                // Header in mode A (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                // But that's the network byte order...

                                // Header in mode A (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC |I|U|S|A|R      |DBQ| TRB |    TR         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                                GOBn = (DWORD)((BYTE)pbySrc[4]) << 24 | (DWORD)((BYTE)pbySrc[5]) << 16 | (DWORD)((BYTE)pbySrc[6]) << 8 | (DWORD)((BYTE)pbySrc[7]);
                                GOBn >>= (DWORD)(10 - (DWORD)((pbySrc[0] & 0x38) >> 3));
                                GOBn &= 0x0000001F;
                                wsprintf(szTDebug, "Header content: Frame %3ld, GOB %0ld\r\n", (DWORD)(pbySrc[3]), GOBn);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x38) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(pbySrc[0] & 0x07));
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(pbySrc[1] >> 5))
                                {
                                        case 0:
                                                wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(pbySrc[1] >> 5));
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                                    OutputDebugString("Draft Style Payload Header flags:\r\n");
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbySrc[1] & 0x1F)); // no need for ">> 5"
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                } else {
                                    OutputDebugString("RFC 2190 Style Payload Header flags:\r\n");
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((pbySrc[1] & 0x01) << 3) | (DWORD)((pbySrc[2] & 0xE0) >> 5));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x10) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x08) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '0' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x04) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[1] & 0x02) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                }
                                wsprintf(szTDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((pbySrc[2] & 0x18) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(pbySrc[2] & 0x07));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "    TR:  %03ld\r\n", (DWORD)(pbySrc[3]));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[0], (BYTE)pbySrc[1], (BYTE)pbySrc[2], (BYTE)pbySrc[3]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[4], (BYTE)pbySrc[5], (BYTE)pbySrc[6], (BYTE)pbySrc[7]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[8], (BYTE)pbySrc[9], (BYTE)pbySrc[10], (BYTE)pbySrc[11]);
                                OutputDebugString(szTDebug);
                        }
                        else if (dwPayloadHeaderSize == 8)
                        {
                                // Header in mode B (!!! DRAFT VERSION !!!)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |I|A|S|  GOBN   |   MBA         |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //| HMV1          |  VMV1         |  HMV2         |   VMV2        |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                // But that's the network byte order...

                                // Header in mode B (*** RFC 2190 VERSION ***)
                                // 0                   1                   2                   3
                                // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|F|P|SBIT |EBIT | SRC | QUANT   |  GOBN   |   MBA           | R |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                //|I|U|S|A| HMV1        |  VMV1       |  HMV2       |   VMV2      |
                                //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


                                wsprintf(szTDebug, "Header content:\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (pbySrc[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x38) >> 3));
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(pbySrc[0] & 0x07));
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(pbySrc[1] >> 5))
                                {
                                        case 0:
                                                wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(pbySrc[1] >> 5));
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " QUANT:   %02ld\r\n", (DWORD)((pbySrc[1] & 0x1F) >> 5));
                                OutputDebugString(szTDebug);
                                if(m_RTPPayloadHeaderMode==RTPPayloadHeaderMode_Draft) {
                                    wsprintf(szTDebug, (pbySrc[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbySrc[2] & 0x1F));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)(pbySrc[3]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)(pbySrc[7]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)(pbySrc[6]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)(pbySrc[5]));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbySrc[4]));
                                    OutputDebugString(szTDebug);
                                } else {
                                    wsprintf(szTDebug, (pbySrc[4] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x40) ? "     U:   '1' => Unrestricted Motion Vector (bit10) was set in crt.pic.hdr.\r\n" : "     U:   '1' => Unrestricted Motion Vector (bit10) was 0 in crt.pic.hdr.\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, (pbySrc[4] & 0x10) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(pbySrc[2] & 0xF8) >>3);
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)((pbySrc[2] & 0x07) << 6) | (DWORD)((pbySrc[3] & 0xFC) >> 2));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)(pbySrc[3] & 0x03));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)((pbySrc[4] & 0x0F) << 3) | (DWORD)((pbySrc[5] & 0xE0) >> 5));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)((pbySrc[5] & 0x1F) << 2) | (DWORD)((pbySrc[6] & 0xC0) >> 6));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)((pbySrc[6] & 0x3F) << 1) | (DWORD)((pbySrc[7] & 0x80) >> 7));
                                    OutputDebugString(szTDebug);
                                    wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(pbySrc[7] & 0x7F));
                                    OutputDebugString(szTDebug);
                                }
                                wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[0], (BYTE)pbySrc[1], (BYTE)pbySrc[2], (BYTE)pbySrc[3]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[4], (BYTE)pbySrc[5], (BYTE)pbySrc[6], (BYTE)pbySrc[7]);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)pbySrc[8], (BYTE)pbySrc[9], (BYTE)pbySrc[10], (BYTE)pbySrc[11]);
                                OutputDebugString(szTDebug);
                        }
                        if(g_dbg_LOGPAYLOAD_TAPIVDec > 0)
                                g_dbg_LOGPAYLOAD_TAPIVDec--;
                        else if(g_dbg_LOGPAYLOAD_TAPIVDec == 0)
                                DebugBreak();
#endif
                        // The purpose of this code is to look for the presence of the
                        // Picture Start Code at the beginning of the frame. If it is
                        // not present, we should break in debug mode.

                        // Only look for PSC at the beginning of the frame
                        if (!m_dwCurrFrameSize)
                        {
                                // The start of the frame may not be at a byte boundary. The SBIT field
                                // of the header ((BYTE)pbySrc[0] & 0xE0) will tell us exactly where
                                // our frame starts. We then look for the PSC (0000 0000 0000 0000 1000 00 bits)
                                *((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize]);
                                *((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 1]);
                                *((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                dwPSCBytes = dwPSCBytes << ((DWORD)((BYTE)pbySrc[0] & 0x38) >> 3);
                                if ((dwPSCBytes & 0xFFFFFC00) != 0x00008000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: The first packet to reassemble is missing a PSC! - Frame not passed to video render filter", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("The first packet to reassemble is missing a PSC! - bailing\r\n");
#endif
                                        m_fDiscontinuity = TRUE;
                                        Hr = S_FALSE;
                                        // DebugBreak();
                                        goto MyExit;
                                }

                                // Look for the format and freeze picture release bits
                                *((BYTE *)&dwTRandPTYPEbytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwTRandPTYPEbytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                *((BYTE *)&dwTRandPTYPEbytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 4]);
                                *((BYTE *)&dwTRandPTYPEbytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 5]);
                                dwTRandPTYPEbytes = dwTRandPTYPEbytes << (((DWORD)((BYTE)pbySrc[0] & 0x38) >> 3) + 6);
                                if (dwTRandPTYPEbytes & 0x00080000)
                                        m_fFreezePicture = FALSE;

#ifdef LOGPAYLOAD_ON
                                wsprintf(szTDebug, "    TR:    %02ld\r\n", (DWORD)(dwTRandPTYPEbytes & 0xFF000000) >> 24);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " PTYPE:  0X%04lX\r\n", (DWORD)(dwTRandPTYPEbytes & 0x00FFF800) >> 11);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? "    Bit1:   '1' => Always '1', in order to avoid start code emulation\r\n" : "    Bit1:   '0' => WRONG: Should always be '1', in order to avoid start code emulation\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00400000) ? "    Bit2:   '1' => WRONG: Should always be '0', for distinction with H.261\r\n" : "    Bit2:   '0' => Always '0', for distinction with H.261\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00200000) ? "    Bit3:   '1' => Split screen indicator ON\r\n" : "    Bit3:   '0' => Split screen indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00100000) ? "    Bit4:   '1' => Document camera indicator ON\r\n" : "    Bit4:   '0' => Document camera indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00080000) ? "    Bit5:   '1' => Freeze picture release ON\r\n" : "    Bit5:   '0' => Freeze picture release OFF\r\n");
                                OutputDebugString(szTDebug);
                                switch ((DWORD)(dwTRandPTYPEbytes & 0x00070000) >> 16)
                                {
                                        case 0:
                                                wsprintf(szTDebug, "  Bit6-8: '000' => Source format forbidden!\r\n");
                                                break;
                                        case 1:
                                                wsprintf(szTDebug, "  Bit6-8: '001' => Source format sub-QCIF\r\n");
                                                break;
                                        case 2:
                                                wsprintf(szTDebug, "  Bit6-8: '010' => Source format QCIF\r\n");
                                                break;
                                        case 3:
                                                wsprintf(szTDebug, "  Bit6-8: '011' => Source format CIF\r\n");
                                                break;
                                        case 4:
                                                wsprintf(szTDebug, "  Bit6-8: '100' => Source format 4CIF\r\n");
                                                break;
                                        case 5:
                                                wsprintf(szTDebug, "  Bit6-8: '101' => Source format 16CIF\r\n");
                                                break;
                                        case 6:
                                                wsprintf(szTDebug, "  Bit6-8: '110' => Source format reserved\r\n");
                                                break;
                                        case 7:
                                                wsprintf(szTDebug, "  Bit6-8: '111' => Source format reserved\r\n");
                                                break;
                                        default:
                                                wsprintf(szTDebug, "  Bit6-8: %ld => Source format unknown!\r\n", (DWORD)(dwTRandPTYPEbytes & 0x00070000) >> 16);
                                                break;
                                }
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00008000) ? "    Bit9:   '1' => Picture Coding Type INTER\r\n" : "    Bit9:   '0' => Picture Coding Type INTRA\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00004000) ? "   Bit10:   '1' => Unrestricted Motion Vector mode ON\r\n" : "   Bit10:   '0' => Unrestricted Motion Vector mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00002000) ? "   Bit11:   '1' => Syntax-based Arithmetic Coding mode ON\r\n" : "   Bit11:   '0' => Syntax-based Arithmetic Coding mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00001000) ? "   Bit12:   '1' => Advanced Prediction mode ON\r\n" : "   Bit12:   '0' => Advanced Prediction mode OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00000800) ? "   Bit13:   '1' => PB-frame\r\n" : "   Bit13:   '0' => I- or P-frame\r\n");
                                OutputDebugString(szTDebug);
#endif
                                // Which ITU size is this?
                                dwITUSize = (DWORD)(((BYTE)pbySrc[1]) >> 5);
                        }

                        // The end of a buffer and the start of the next buffer could belong to the
                        // same byte. If this is the case, the first byte of the next buffer was already
                        // copied in the video data buffer, with the previous packet. It should not be copied
                        // twice. The SBIT field of the payload header allows us to figure out if this is the case.
                        dwStartBit = (DWORD)((pbySrc[0] & 0x38) >> 3);
                        if (m_dwCurrFrameSize && dwStartBit)
                                dwPayloadHeaderSize++;
                }
                else if (pRtpHdr->pt == H261_PAYLOAD_TYPE)
                {
                        // Let's reassemble those H.261 packets - strip the header of the packet
                        // and copy the payload in the video buffer

                        // 0                   1                   2                   3
                        // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        //|SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |
                        //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        // But that's the network byte order...

                        // The H.261 payload header size is always 4 bytes long
                        dwPayloadHeaderSize = 4;

                        // Look at the payload header to figure out if the frame is a keyframe
                        // Update our flag to always remember this.
                        fReceivedKeyframe = (BOOL)(pbySrc[0] & 0x02);

#ifdef LOGPAYLOAD_ON
                        // Output some debug stuff
                        wsprintf(szTDebug, "Header content: GOB %0ld\r\n", (DWORD)((pbySrc[1] & 0xF0) >> 4));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0xE0) >> 5));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)((pbySrc[0] & 0x1C) >> 2));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, (pbySrc[0] & 0x02) ? "     I:   '1' => I frame\r\n" : "     I:   '0' => P frame\r\n");
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, (pbySrc[0] & 0x01) ? "     V:   '1' => Motion vectors may be used\r\n" : "     V:   '0' => Motion vectors are not used\r\n");
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  MBAP:    %02ld\r\n", (DWORD)((pbySrc[2] & 0x80) >> 7) | (DWORD)((pbySrc[1] & 0x0F) << 1));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, " QUANT:    %02ld\r\n", (DWORD)((pbySrc[2] & 0x7C) >> 2));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  HMVD:    %02ld\r\n", (DWORD)((pbySrc[3] & 0xE0) >> 5) | (DWORD)((pbySrc[2] & 0x03) << 3));
                        OutputDebugString(szTDebug);
                        wsprintf(szTDebug, "  VMVD:    %02ld\r\n", (DWORD)((pbySrc[3] & 0x1F)));
                        OutputDebugString(szTDebug);
#endif
                        // The purpose of this code is to look for the presence of the
                        // Picture Start Code at the beginning of the frame. If it is
                        // not present, we should break in debug mode.

                        // Only look for PSC at the beginning of the frame
                        if (!m_dwCurrFrameSize)
                        {
                                // The start of the frame may not be at a byte boundary. The SBIT field
                                // of the header ((BYTE)pbySrc[0] & 0xE0) will tell us exactly where
                                // our frame starts. We then look for the PSC (0000 0000 0000 0001 0000 bits)
                                *((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize]);
                                *((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 1]);
                                *((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                dwPSCBytes <<= ((DWORD)((BYTE)pbySrc[0] & 0xE0) >> 5);
                                if ((dwPSCBytes & 0xFFFFF000) != 0x00010000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: The first packet to reassemble is missing a PSC! - Frame not passed to video render filter", _fx_));
#ifdef LOGIFRAME_ON
                                        OutputDebugString("The first packet to reassemble is missing a PSC! - bailing\r\n");
#endif
                                        m_fDiscontinuity = TRUE;
                                        Hr = S_FALSE;
                                        // DebugBreak();
                                        goto MyExit;
                                }

                                // Look for the format and freeze picture release bits
                                *((BYTE *)&dwTRandPTYPEbytes + 3) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 2]);
                                *((BYTE *)&dwTRandPTYPEbytes + 2) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 3]);
                                *((BYTE *)&dwTRandPTYPEbytes + 1) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 4]);
                                *((BYTE *)&dwTRandPTYPEbytes + 0) = *(BYTE *)&(pbySrc[dwPayloadHeaderSize + 5]);
                                dwTRandPTYPEbytes <<= (((DWORD)((BYTE)pbySrc[0] & 0xE0) >> 5) + 4);
                                if (dwTRandPTYPEbytes & 0x01000000)
                                        m_fFreezePicture = FALSE;

#ifdef LOGPAYLOAD_ON
                                wsprintf(szTDebug, "    TR:    %02ld\r\n", (DWORD)(dwTRandPTYPEbytes & 0xF8000000) >> 27);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, " PTYPE:  0X%02lX\r\n", (DWORD)(dwTRandPTYPEbytes & 0x07C00000) >> 21);
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x04000000) ? "    Bit1:   '1' => Split screen indicator ON\r\n" : "    Bit1:   '0' => Split screen indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x02000000) ? "    Bit2:   '1' => Document camera indicator ON\r\n" : "    Bit2:   '0' => Document camera indicator OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x01000000) ? "    Bit3:   '1' => Freeze picture release ON\r\n" : "    Bit3:   '0' => Freeze picture release OFF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? "    Bit4:   '1' => Source format CIF\r\n" : "    Bit4:   '0' => Source format QCIF\r\n");
                                OutputDebugString(szTDebug);
                                wsprintf(szTDebug, (DWORD)(dwTRandPTYPEbytes & 0x00400000) ? "    Bit5:   '1' => HI_RES mode OFF\r\n" : "    Bit5:   '0' => HI_RES mode ON\r\n");
                                OutputDebugString(szTDebug);
#endif
                                // Which ITU size is this?
                                dwITUSize = (DWORD)(dwTRandPTYPEbytes & 0x00800000) ? 3 : 2;
                        }

                        // The end of a buffer and the start of the next buffer could belong to the
                        // same byte. If this is the case, the first byte of the next buffer was already
                        // copied in the video data buffer, with the previous packet. It should not be copied
                        // twice. The SBIT field of the payload header allows us to figure out if this is the case.
                        dwStartBit = (DWORD)((pbySrc[0] & 0xE0) >> 5);
                        if (m_dwCurrFrameSize && dwStartBit)
                                dwPayloadHeaderSize++;
                }
                else
                {
                        // I have no clue how to reassemble and decompress those packets - just bail
                        Hr = VFW_E_TYPE_NOT_ACCEPTED;
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unknown input format data", _fx_));
                        goto MyExit;
                }


                //**cristiai:
                {   long l;
                    if ((l=pIn->GetActualDataLength()) <= (int)(dwPayloadHeaderSize + dwPreambleSize)) {
                            bSkipPacket = TRUE;
                            DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   WARNING: GetActualDataLength too small: %ld", _fx_,l));
                            goto MyExit;    //note that this is not considered an error; the packet is just ignored
                    }
                }

                if ((pRtpHdr->pt == H263_PAYLOAD_TYPE && HEADER(m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R263)
                        || (pRtpHdr->pt == H261_PAYLOAD_TYPE && HEADER(m_pInput->m_mt.pbFormat)->biCompression != FOURCC_R261)
                        || !((m_dwCurrFrameSize || (g_ITUSizes[dwITUSize].biWidth == HEADER(m_pInput->m_mt.pbFormat)->biWidth
                        && g_ITUSizes[dwITUSize].biHeight == HEADER(m_pInput->m_mt.pbFormat)->biHeight))))
                {
                        // Let's reconfigure our decoder.

                        // Change the relevant parameters in the format description
                        VIDEOINFO *pvi = (VIDEOINFO *)m_pOutput->m_mt.Format();

                        pvi->bmiHeader.biWidth = g_ITUSizes[dwITUSize].biWidth;
                        pvi->bmiHeader.biHeight = g_ITUSizes[dwITUSize].biHeight;
                        pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
                        m_pOutput->m_mt.SetSampleSize(pvi->bmiHeader.biSizeImage);

                        if (pvi->rcSource.top || pvi->rcSource.bottom)
                        {
                                pvi->rcSource.bottom = pvi->rcSource.top + pvi->bmiHeader.biHeight;
                        }
                        if (pvi->rcSource.left || pvi->rcSource.right)
                        {
                                pvi->rcSource.right = pvi->rcSource.left + pvi->bmiHeader.biWidth;
                        }
                        if (pvi->rcTarget.top || pvi->rcTarget.bottom)
                        {
                                pvi->rcTarget.bottom = pvi->rcTarget.top + pvi->bmiHeader.biHeight;
                        }
                        if (pvi->rcTarget.left || pvi->rcTarget.right)
                        {
                                pvi->rcTarget.right = pvi->rcTarget.left + pvi->bmiHeader.biWidth;
                        }

                        if (pvi->AvgTimePerFrame)
                                pvi->dwBitRate = (DWORD)((LONGLONG)10000000 * pvi->bmiHeader.biSizeImage / (LONGLONG)pvi->AvgTimePerFrame);

                        // What's the new format of the input packets?
                        for (DWORD dw = 0; dw < NUM_R26X_FORMATS; dw ++)
                        {
                                if (HEADER(R26XFormats[dw]->pbFormat)->biWidth == g_ITUSizes[dwITUSize].biWidth
                                        && HEADER(R26XFormats[dw]->pbFormat)->biHeight == g_ITUSizes[dwITUSize].biHeight
                                        && pRtpHdr->pt == R26XPayloadTypes[dw])
                                        break;
                        }

                        // Remember the new input format if it is a valid one
                        if (dw == NUM_R26X_FORMATS)
                        {
                                Hr = VFW_E_TYPE_NOT_ACCEPTED;
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Unknown input format", _fx_));
                                goto MyExit;
                        }
                        m_pInput->m_mt = *R26XFormats[dw];
                        m_pInput->m_dwRTPPayloadType = R26XPayloadTypes[dw];
            lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);

                        // Reconfigure the H.26X decoder
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(&m_pOutput->m_mt);

                        icDecompress.lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        // Re-init color convertors of our decoder if necessary
                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;

                        // Retry!
                        fFormatChanged = TRUE;

                        // We can't use the current output sample because it has a size that
                        // may be smaller than necessary (example, we just switched from 176x144
                        // to 352x288). We still want to decompress the input buffer though, so
                        // we just let the decoder do the decoding but skip the final color
                        // conversion process used to fill the output buffer.
                        dwFlags |= ICDECOMPRESS_HURRYUP;
                }

                // Decode the frame

                // Re-allocate receive buffer if too small
                if (!(      pIn->GetActualDataLength() >= (int)(dwPayloadHeaderSize + dwPreambleSize)
                        && ((m_dwCurrFrameSize + pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize) <= m_dwMaxFrameSize)
                     )
                   )
                {
                        PVOID pvReconstruct;
                        DWORD dwTest;

                        dwTest = pIn->GetActualDataLength();

                        #ifdef LOGPAYLOAD_ON
                         wsprintf(szTDebug, "Buffer start: 0x%08lX, Copying %ld-%ld-%ld=%ld bytes at 0x%08lX (before ReAlloc)\r\n", (DWORD)m_pbyReconstruct,
                                                (DWORD)pIn->GetActualDataLength(), dwPayloadHeaderSize, dwPreambleSize,
                                                (DWORD)pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize, (DWORD)m_pbyReconstruct + m_dwCurrFrameSize);
                         OutputDebugString(szTDebug);
                        #endif

                        if ((m_dwCurrFrameSize + pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize) > m_dwMaxFrameSize)
                                m_dwMaxFrameSize = m_dwMaxFrameSize + max(1024, m_dwMaxFrameSize - pIn->GetActualDataLength());

                        // Allocate reconstruction buffer - it will be realloced if too small
                        if (!(pvReconstruct = HeapReAlloc(GetProcessHeap(), 0, m_pbyReconstruct, m_dwMaxFrameSize)))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                Hr = E_OUTOFMEMORY;
                                goto MyExit;
                        }

                        m_pbyReconstruct = (PBYTE)pvReconstruct;

                }

                // Copy the payload
                if (dwStartBit > 0)
                {
                        // Combine the end and start bytes
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) >>= (8 - dwStartBit);
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) <<= (8 - dwStartBit);
                        *(pbySrc + dwPayloadHeaderSize - 1) <<= dwStartBit;
                        *(pbySrc + dwPayloadHeaderSize - 1) >>= dwStartBit;
                        *(m_pbyReconstruct + m_dwCurrFrameSize - 1) = *(m_pbyReconstruct + m_dwCurrFrameSize - 1) | *(pbySrc + dwPayloadHeaderSize - 1);
                }

#ifdef LOGPAYLOAD_ON
                wsprintf(szTDebug, "Buffer start: 0x%08lX, Copying %ld-%ld-%ld=%ld bytes at 0x%08lX\r\n", (DWORD)m_pbyReconstruct,
                                                (DWORD)pIn->GetActualDataLength(), dwPayloadHeaderSize, dwPreambleSize,
                                                (DWORD)pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize, (DWORD)m_pbyReconstruct + m_dwCurrFrameSize);
                OutputDebugString(szTDebug);
#endif
                CopyMemory(m_pbyReconstruct + m_dwCurrFrameSize, pbySrc + dwPayloadHeaderSize, pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize);


                // Update the payload size and pointer to the input video packets
                m_dwCurrFrameSize += (DWORD)(pIn->GetActualDataLength() - dwPayloadHeaderSize - dwPreambleSize);

                // Do we have a complete frame? If so, decompress it
                if (pRtpHdr->m)
                {
                        DWORD dwRefTime;
                        DWORD dwDecodeTime;
                        HEVENT hEvent = (HEVENT)(HANDLE)m_EventAdvise;

#ifdef LOGPAYLOAD_ON
                        OutputDebugString("End marker bit found - calling decompression\r\n");
#endif
                        // Measure the incoming frame rate and bitrate
                        m_dwNumFramesReceived++;
                        m_dwNumBytesReceived += m_dwCurrFrameSize;
                        dwRefTime = timeGetTime();
                        if (m_dwNumFramesReceived && ((dwRefTime - m_dwLastRefReceivedTime) > 1000))
                        {
                                ((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame = (dwRefTime - m_dwLastRefReceivedTime) * 10000 / m_dwNumFramesReceived;
                                ((CTAPIInputPin *)m_pInput)->m_lCurrentBitrate = (DWORD)((LONGLONG)m_dwNumBytesReceived * 8000 / ((REFERENCE_TIME)(dwRefTime - m_dwLastRefReceivedTime)));
                                m_dwNumFramesReceived = 0;
                                m_dwNumBytesReceived = 0;
                                m_dwLastRefReceivedTime = dwRefTime;
                        }

                        // The freeze release bit will be an I-frame, so we don't need to keep on
                        // deocding the data. Actually, something may go wrong, so we still decode
                        // the data, just in case... We time out after 6 seconds, like the H.261
                        // and H.263 specs say we should.
                        if (m_fFreezePicture)
                        {
                                if (dwRefTime - m_dwFreezePictureStartTime > 6000)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Freeze picture timed-out (>6s)", _fx_));
                                        m_fFreezePicture = FALSE;
                                }
                                else
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Received freeze picture command", _fx_));
                                        dwFlags |= ICDECOMPRESS_HURRYUP;
                                }
                        }

                        // Do we have a use for this frame?
                        if (((dwRefTime - m_dwLastRenderTime + (DWORD)(((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame / 10000)) < (DWORD)(((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000)))
                                dwFlags |= ICDECOMPRESS_HURRYUP;

                        // Packetized mode - prepare for decompression (I)
                        icDecompress.dwFlags = dwFlags;
                        icDecompress.lpbiSrc = lpbiSrc;
                        lpbiSrc->biSizeImage = m_dwCurrFrameSize;
                        icDecompress.lpSrc = m_pbyReconstruct;
                        icDecompress.lpDst = pbyDst;

#ifdef LOGPAYLOAD_TOFILE
                        g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                        SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
                        wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)(pbySrc[3]));
                        WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
                        j=m_dwCurrFrameSize;
                        for (PBYTE p=m_pbyReconstruct; j>0; j-=4, p+=4)
                        {
                                wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
                                WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
                        }
                        CloseHandle(g_TDebugFile);
#endif

                        // Have we been asked to render to a different format?
                        if (pmtOut != NULL && pmtOut->pbFormat != NULL)
                        {
                                // Save the new format
                                if (m_pMediaType)
                                        DeleteMediaType(m_pMediaType);

                                m_pMediaType = CreateMediaType(pmtOut);

                                // Prepare for decompression (II)
                                lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.lpbiDst = lpbiDst;
                                icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                                icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                                // Re-init color convertors of our decoder if necessary
                                if (m_fICMStarted)
                                {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                        (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                        m_fICMStarted = FALSE;
                                }

#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                                if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                        Hr = E_FAIL;
                                        goto MyExit;
                                }
                                m_fICMStarted = TRUE;
                        }
                        else
                        {
                                // Prepare for decompression (II)
                                icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                                icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                                icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                                icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                                icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                                icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        }

                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Fmt:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  xSrc = %ld, ySrc = %ld, dxSrc = %ld, dySrc = %ld", _fx_, icDecompress.xSrc, icDecompress.ySrc, icDecompress.dxSrc, icDecompress.dySrc));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Fmt: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize, icDecompress.lpbiDst->biSizeImage));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: xDst = %ld, yDst = %ld, dxDst = %ld, dyDst = %ld", _fx_, icDecompress.xDst, icDecompress.yDst, icDecompress.dxDst, icDecompress.dyDst));

                        // Decompress the frame
#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX\r\n");
#endif
                        lRes = (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX, (LPARAM)&icDecompress, sizeof(icDecompress));

                        if (lRes != ICERR_OK && lRes != ICERR_DONTDRAW)
                        {
                                Hr = E_FAIL;
                                m_dwCurrFrameSize = 0UL;
                                m_fDiscontinuity = TRUE;
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompress failed", _fx_));
                                goto MyExit;
                        }

                        // Measure the outgoing frame rate and decoding time
                        dwDecodeTime = timeGetTime();
                        if (lRes != ICERR_DONTDRAW)
                        {
                                m_dwNumFramesDelivered++;
                        }
                        m_dwNumFramesDecompressed++;
                        m_dwNumMsToDecode += (DWORD)(dwDecodeTime - dwRefTime);
                        if ((dwRefTime - m_dwLastRefDeliveredTime) > 1000)
                        {
                                if (m_dwNumFramesDelivered)
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame = (dwRefTime - m_dwLastRefDeliveredTime) * 10000 / m_dwNumFramesDelivered;
#ifdef USE_CPU_CONTROL
                                if (m_dwNumFramesDecompressed)
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentProcessingTime = m_dwNumMsToDecode  * 10000 / m_dwNumFramesDecompressed;
                                if (((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame)
                                {
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad = min((LONG)((LONGLONG)((CTAPIOutputPin *)m_pOutput)->m_lCurrentProcessingTime  * 100 / ((CTAPIOutputPin *)m_pOutput)->m_lCurrentAvgTimePerFrame), 100L);
                                        ((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad = max(((CTAPIOutputPin *)m_pOutput)->m_lCurrentCPULoad, 0L);
                                }
#endif
                                m_dwNumFramesDelivered = 0;
                                m_dwNumFramesDecompressed = 0;
                                m_dwNumMsToDecode = 0;
                                m_dwLastRefDeliveredTime = dwRefTime;
                        }

                        // We've fully decompressed an I-frame - update our flag
                        m_fReceivedKeyframe |= fReceivedKeyframe;
                        if (!m_fReceivedKeyframe)
                        {
                                m_fDiscontinuity = TRUE;
#ifdef LOGIFRAME_ON
                                OutputDebugString("First frame isn't I frame - setting discontinuity\r\n");
#endif
                        }
#ifdef LOGIFRAME_ON
                        else if (fReceivedKeyframe)
                        {
                                OutputDebugString("Received a keyframe\r\n");
                        }
#endif

                        // Reset out RTP reassembly helpers
                        m_dwCurrFrameSize = 0UL;

                        // Check if the decompressor doesn't want this frame drawn
                        // If so, we want to decompress it into the output buffer but not
                        // deliver it. Returning S_FALSE tells the base class not to deliver
                        // this sample.
                        if (lRes == ICERR_DONTDRAW || pIn->GetActualDataLength() <= 0)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: Frame not passed to video render filter", _fx_));
                                Hr = S_FALSE;
                        }
                        else
                        {
                                // Decompressed frames are always key
                                pOut->SetSyncPoint(TRUE);

                                // Update output sample size
                                pOut->SetActualDataLength(lpbiDst->biSizeImage);

                                // Sleep until it is time to deliver a frame downstream
                                // @todo Can't we achieve something similar by messing with the presentation timestamps instead?
                                if (lRes != ICERR_DONTDRAW)
                                {
                                        DWORD dwWaitTime;

                                        if ((dwDecodeTime < (m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000UL)) && (((m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000 - dwDecodeTime) < (DWORD)(((CTAPIInputPin *)m_pInput)->m_lCurrentAvgTimePerFrame / 10000))))
                                                dwWaitTime = m_dwLastRenderTime + (DWORD)((CTAPIOutputPin *)m_pOutput)->m_lMaxAvgTimePerFrame / 10000 - dwDecodeTime;
                                        else
                                                dwWaitTime = 0;
#ifdef LOGSTREAMING_ON
                                        wsprintf(szTDebug, "Waiting %d ms...\r\n", dwWaitTime);
                                        OutputDebugString(szTDebug);
#endif
                                        if ((dwWaitTime > 1) && (timeSetEvent(dwWaitTime, 1, (LPTIMECALLBACK)hEvent, NULL, TIME_ONESHOT | TIME_CALLBACK_EVENT_SET)))
                                        {
                                                m_EventAdvise.Wait();
                                                dwDecodeTime = timeGetTime();
                                        }
                                        m_dwLastRenderTime = dwDecodeTime;
                                }
                                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Complete frame passed to video render filter", _fx_));
                        }
                }
                else
                {
#ifdef LOGPAYLOAD_ON
                        OutputDebugString("No end marker bit found - skip decompression\r\n");
#endif
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: Uncomplete frame not passed to video render filter", _fx_));
                        Hr = S_FALSE;
                        goto MyExit;
                }
        }
        else
        {
                // Non-packetized mode - prepare for decompression (I)
                icDecompress.dwFlags = dwFlags;
                icDecompress.lpbiSrc = lpbiSrc;
                icDecompress.lpSrc = pbySrc;
                icDecompress.lpDst = pbyDst;

                // Have we been asked to render to a different format?
                if (pmtOut != NULL && pmtOut->pbFormat != NULL)
                {
                        // Save the new format
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(pmtOut);

                        // Prepare for decompression (II)
                        lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.lpbiDst = lpbiDst;
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        // Re-init color convertors of our decoder if necessary
                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;
                }
                else
                {
                        // Prepare for decompression (II)
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                }

                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Fmt:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input Rec:  xSrc = %ld, ySrc = %ld, dxSrc = %ld, dySrc = %ld", _fx_, icDecompress.xSrc, icDecompress.ySrc, icDecompress.dxSrc, icDecompress.dySrc));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Fmt: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld, biSizeImage = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize, icDecompress.lpbiDst->biSizeImage));
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output Rec: xDst = %ld, yDst = %ld, dxDst = %ld, dyDst = %ld", _fx_, icDecompress.xDst, icDecompress.yDst, icDecompress.dxDst, icDecompress.dyDst));

                // Decompress the frame
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::Transform - ICM_DECOMPRESSEX\r\n");
#endif
                lRes = (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX, (LPARAM)&icDecompress, sizeof(icDecompress));

                if (lRes != ICERR_OK && lRes != ICERR_DONTDRAW)
                {
                        Hr = E_FAIL;
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompress failed", _fx_));
                        goto MyExit;
                }

                // Decompressed frames are always key
                pOut->SetSyncPoint(TRUE);

                // Check if the decompressor doesn't want this frame drawn
                // If so, we want to decompress it into the output buffer but not
                // deliver it. Returning S_FALSE tells the base class not to deliver
                // this sample.
                if (lRes == ICERR_DONTDRAW || pIn->GetActualDataLength() <= 0)
                {
                        DBGOUT((g_dwVideoDecoderTraceID, WARN, "%s:   WARNING: Frame not passed to video render filter", _fx_));
                        Hr = S_FALSE;
                }

                // Update output sample size
                pOut->SetActualDataLength(lpbiDst->biSizeImage);
        }

MyExit:
        if (pmtOut)
                DeleteMediaType(pmtOut);
        if (pOut)
        {
            if(bSkipPacket) {
                pOut->Release();
            }
            else {
                if (fFormatChanged)
                {
#ifdef USE_DFC
                    pOut->Release();
                    pOut = 0;

                    /*  First check if the downstream pin will accept a dynamic
                    format change
                    */

                    QzCComPtr<IPinConnection> pConnection;

                    Hr = m_pOutput->m_Connected->QueryInterface(IID_IPinConnection, (void **)&pConnection);
                    if(SUCCEEDED(Hr))
                    {
                        Hr = pConnection->DynamicQueryAccept(&m_pOutput->m_mt);
                        if(S_OK == Hr)
                        {
                            Hr = m_pOutput->ChangeMediaTypeHelper(&m_pOutput->m_mt);
                        }
                    }

#else
                    Hr = E_FAIL;
#endif
                }
                else
                {
                    if (SUCCEEDED(Hr))
                    {
                            Hr = m_pOutput->Deliver(pOut);
                    }
                    else
                    {
                            // S_FALSE returned from Transform is a PRIVATE agreement
                            // We should return NOERROR from Receive() in this cause because returning S_FALSE
                            // from Receive() means that this is the end of the stream and no more data should
                            // be sent.
                            if (S_FALSE == Hr)
                            {
                                    //  Release the sample before calling notify to avoid
                                    //  deadlocks if the sample holds a lock on the system
                                    //  such as DirectDraw buffers do
                                    m_bSampleSkipped = TRUE;
                                    Hr = NOERROR;
                            }
                    }
                    pOut->Release();
                }
            }
        }
        if (m_pInput && m_pInput->m_mt.pbFormat && dwImageSize)
        {
                HEADER(m_pInput->m_mt.pbFormat)->biSizeImage = dwImageSize;
        }
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPinCount | This method returns our number
 *    of pins.
 *
 *  @rdesc This method returns 2.
 ***************************************************************************/
int CTAPIVDec::GetPinCount()
{
        return 2;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetPin | This method returns a non-addrefed
 *    pointer to the <c cBasePin> of a pin.
 *
 *  @parm int | n | Specifies the number of the pin.
 *
 *  @rdesc This method returns NULL or a pointer to a <c CBasePin> object.
 ***************************************************************************/
CBasePin *CTAPIVDec::GetPin(IN int n)
{
        HRESULT         Hr;
        CBasePin        *pCBasePin = NULL;

        FX_ENTRY("CTAPIVDec::GetPin")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    // Create the pins if necessary
    if (m_pInput == NULL)
        {
                if (!(m_pInput = new CTAPIInputPin(NAME("H26X Input Pin"), this, &m_csFilter, &Hr, L"H26X In")))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        goto MyExit;
                }

#if 0
                ((CTAPIInputPin *)m_pInput)->TestH245VidC();
#endif

                if (!(m_pOutput = new CTAPIOutputPin(NAME("Video Output Pin"), this, &m_csFilter, &Hr, L"Video Out")))
                {
                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        delete m_pInput, m_pInput = NULL;
                        goto MyExit;
                }
    }

    // Return the appropriate pin
        if (n == 0)
        {
                pCBasePin = m_pInput;
        }
        else if (n == 1)
        {
                pCBasePin = m_pOutput;
        }

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SUCCESS: pCBasePin=0x%08lX", _fx_, pCBasePin));

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return pCBasePin;
}


#if 0
// overridden to properly mark buffers read only or not in NotifyAllocator
// !!! base class changes won't get picked up by me
//
HRESULT CDecOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
            // temporal compression ==> read only buffers
            hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
            // temporal compression ==> read only buffers
            hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }
    return hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Pause | This method lets our filter
 *    know that we're in the process of switching to active mode.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVDec::Pause()
{
        HRESULT                 Hr = NOERROR;
        ICDECOMPRESSEX  icDecompress;

        FX_ENTRY("CTAPIVDec::Pause")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

    CAutoLock Lock(&m_csFilter);

        if (m_State == State_Paused)
        {
        // (This space left deliberately blank)
        }

        // If we have no input pin or it isn't yet connected then when we are
        // asked to pause we deliver an end of stream to the downstream filter.
        // This makes sure that it doesn't sit there forever waiting for
        // samples which we cannot ever deliver without an input connection.

        else if (m_pInput == NULL || m_pInput->IsConnected() == FALSE)
        {
                m_State = State_Paused;
        }

        // We may have an input connection but no output connection
        // However, if we have an input pin we do have an output pin

        else if (m_pOutput->IsConnected() == FALSE)
        {
                m_State = State_Paused;
        }

        else
        {
                if (m_State == State_Stopped)
                {
                        CAutoLock Lock2(&m_csReceive);

                        ASSERT(m_pInput);
                        ASSERT(m_pOutput);
                        ASSERT(m_pInput->m_mt.pbFormat);
                        ASSERT(m_pOutput->m_mt.pbFormat);
                        ASSERT(m_pInstInfo);
                        if (!m_pInstInfo || !m_pInput || !m_pOutput || !m_pInput->m_mt.pbFormat || !m_pOutput->m_mt.pbFormat)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Invalid state", _fx_));
                                Hr = E_UNEXPECTED;
                                goto MyExit;
                        }

                        // Save the output format
                        if (m_pMediaType)
                                DeleteMediaType(m_pMediaType);

                        m_pMediaType = CreateMediaType(&m_pOutput->m_mt);

                        icDecompress.lpbiSrc = HEADER(m_pInput->m_mt.pbFormat);
                        icDecompress.lpbiDst = HEADER(m_pMediaType->pbFormat);
                        icDecompress.xSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.ySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.dxSrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left;
                        icDecompress.dySrc = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top;
                        icDecompress.xDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.yDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;
                        icDecompress.dxDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left;
                        icDecompress.dyDst = ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom - ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top;

                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Input:  biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiSrc->biCompression, icDecompress.lpbiSrc->biBitCount, icDecompress.lpbiSrc->biWidth, icDecompress.lpbiSrc->biHeight, icDecompress.lpbiSrc->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   SrcRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.left, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.top, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.right, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcSource.bottom));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   Output: biCompression = 0x%08lX, biBitCount = %ld, biWidth = %ld, biHeight = %ld, biSize = %ld", _fx_, icDecompress.lpbiDst->biCompression, icDecompress.lpbiDst->biBitCount, icDecompress.lpbiDst->biWidth, icDecompress.lpbiDst->biHeight, icDecompress.lpbiDst->biSize));
                        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s:   DstRc:  left = %ld, top = %ld, right = %ld, bottom = %ld", _fx_, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.left, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.top, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.right, ((VIDEOINFOHEADER *)(m_pMediaType->pbFormat))->rcTarget.bottom));

                        if (m_fICMStarted)
                        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                                OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_END\r\n");
#endif
                                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
                                m_fICMStarted = FALSE;
                        }

#if defined(ICM_LOGGING) && defined(DEBUG)
                        OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_BEGIN\r\n");
#endif
                        if ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_BEGIN, (long)&icDecompress, NULL) != ICERR_OK)
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: ICDecompressBegin failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                        m_fICMStarted = TRUE;

                        // Initialize RTP reassembly helpers if necessary
                        if (HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R263 || HEADER(m_pInput->m_mt.pbFormat)->biCompression == FOURCC_R261)
                        {
                                // Remember the maximum frame size
                                m_dwMaxFrameSize = HEADER(m_pInput->m_mt.pbFormat)->biSizeImage;

                                // Allocate reconstruction buffer - it will be realloced if too small
                                if (!(m_pbyReconstruct = (PBYTE)HeapAlloc(GetProcessHeap(), 0, m_dwMaxFrameSize)))
                                {
                                        DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        Hr = E_OUTOFMEMORY;
                                        goto MyExit;
                                }
                        }

                        // Reset out RTP reassembly helpers
                        m_dwCurrFrameSize = 0UL;
                        m_fReceivedKeyframe = FALSE;
                        m_fDiscontinuity = FALSE;
                        m_dwLastIFrameRequest = 0UL;
                        m_dwLastSeq = 0xFFFFFFFFUL;

                        // Reset statistics helpers
                        m_dwLastRefReceivedTime = timeGetTime();
                        m_dwNumFramesReceived = 0UL;
                        m_dwNumBytesReceived = 0UL;
                        m_dwLastRefDeliveredTime = m_dwLastRefReceivedTime;
                        m_dwNumFramesDelivered = 0UL;
                        m_dwNumFramesDecompressed = 0UL;
                        m_dwNumMsToDecode = 0;
                        m_EventAdvise.Reset();
                        m_dwLastRenderTime = m_dwLastRefReceivedTime;
                }

                if (SUCCEEDED(Hr))
                {
                        Hr = CBaseFilter::Pause();
                }
        }

    m_bSampleSkipped = FALSE;

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | Stop | This method lets our filter
 *    know that we're in the process of leaving active mode and entering
 *    stopped mode.
 *
 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CTAPIVDec::Stop()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIVDec::Stop")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock Lock(&m_csFilter);

        if (m_State == State_Stopped)
        {
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
                return Hr;
        }

    // Succeed the Stop if we are not completely connected
    ASSERT(m_pInput == NULL || m_pOutput != NULL);

    if (m_pInput == NULL || m_pInput->IsConnected() == FALSE || m_pOutput->IsConnected() == FALSE)
        {
                m_State = State_Stopped;
                DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
                return Hr;
    }

    ASSERT(m_pInput);
    ASSERT(m_pOutput);

    // Decommit the input pin before locking or we can deadlock
    m_pInput->Inactive();

    // Synchronize with Receive calls
    CAutoLock Lock2(&m_csReceive);
    m_pOutput->Inactive();

        // Terminate H.26X compression
        ASSERT(m_pInstInfo);
        if (m_pInstInfo)
        {
#if defined(ICM_LOGGING) && defined(DEBUG)
                OutputDebugString("CTAPIVDec::Pause - ICM_DECOMPRESSEX_END\r\n");
#endif
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_DECOMPRESSEX_END, 0L, 0L);
        }

        if (m_pbyReconstruct)
                HeapFree(GetProcessHeap(), 0, m_pbyReconstruct), m_pbyReconstruct = NULL;

        m_State = State_Stopped;

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | GetState | This method retrieves the current
 *    state of the filter. We override GetState to report that we don't send
 *    any data when paused, so renderers won't starve expecting that
 *
 *  @parm DWORD | dwMSecs | Specifies the duration of the time-out, in
 *    milliseconds.
 *
 *  @parm FILTER_STATE* | State | Specifies the state of the filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag VFW_S_CANT_CUE | Lack of data
 *  @flag S_OK | No error
 ***************************************************************************/
HRESULT CTAPIVDec::GetState(DWORD dwMSecs, FILTER_STATE *pState)
{
        HRESULT Hr = S_OK;

        FX_ENTRY("CTAPIVDec::GetState")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pState);
        if (!pState)
        {
                Hr = E_POINTER;
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                goto MyExit;
        }

        *pState = m_State;
        if (m_State == State_Paused)
        {
                Hr = VFW_S_CANT_CUE;
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if 0
/****************************************************************************
 *  @doc INTERNAL CTAPIVDECMETHOD
 *
 *  @mfunc HRESULT | CTAPIVDec | JoinFilterGraph | This method is used to
 *    inform a filter that it has joined a filter graph.
 *
 *  @parm IFilterGraph | pGraph | Specifies a pointer to the filter graph to
 *    join.
 *
 *  @parm LPCWSTR | pName | Specifies the name of the filter being added.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm We don't validate input parameters as both pointers can be
 *    NULL when we leave the graph.
 ***************************************************************************/
STDMETHODIMP CTAPIVDec::JoinFilterGraph(IN IFilterGraph *pGraph, IN LPCWSTR pName)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices = 0UL;
        IGraphConfig *pgc = NULL;

        FX_ENTRY("CTAPIVDec::JoinFilterGraph")

        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: begin", _fx_));

        CAutoLock Lock(&m_csFilter);

        // Verify with the base class
        if (FAILED(Hr = CBaseFilter::JoinFilterGraph(pGraph, pName)))
        {
                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: CBaseFilter::JoinFilterGraph failed", _fx_));
                goto MyExit;
        }

        if (pGraph)
        {
                // Create the pins if necessary
                if (m_pInput == NULL)
                {
                        if (!(m_pInput = new CTAPIInputPin(NAME("H26X Input Pin"), this, &m_csFilter, &Hr, L"H26X In")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                goto MyExit;
                        }

#if 0
                        ((CTAPIInputPin *)m_pInput)->TestH245VidC();
#endif

                        if (!(m_pOutput = new CTAPIOutputPin(NAME("Video Output Pin"), this, &m_csFilter, &Hr, L"Video Out")))
                        {
                                DBGOUT((g_dwVideoDecoderTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                delete m_pInput, m_pInput = NULL;
                                goto MyExit;
                        }
                }

                // Get an IGraphConfig interface pointer for our output pin
                if (S_OK == pGraph->QueryInterface(IID_IGraphConfig, (void **)&pgc))
                {
                        m_pOutput->SetConfigInfo(pgc, m_evStop);
                        pgc->Release();
                }
        }

MyExit:
        DBGOUT((g_dwVideoDecoderTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\asn\h225asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#include <windows.h>
#include "h225asn.h"

ASN1module_t H225ASN_Module = NULL;

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val);
static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val);
static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val);
static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val);
static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val);
static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val);
static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val);
static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val);
static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val);
static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val);
static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val);
static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val);
static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val);
static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val);
static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val);
static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val);
static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val);
static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val);
static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val);
static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val);
static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val);
static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val);
static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val);
static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val);
static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val);
static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val);
static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val);
static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val);
static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val);
#define ASN1Enc_FastStartToken(x,y)      0
static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val);
static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val);
static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val);
static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val);
static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val);
static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val);
static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val);
static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val);
static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val);
static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val);
static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val);
static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val);
static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val);
static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val);
static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val);
static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val);
static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val);
static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val);
static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val);
static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val);
static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val);
static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val);
static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val);
static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val);
static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val);
static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val);
static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val);
static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val);
static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val);
static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val);
static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val);
static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val);
static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val);
static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val);
static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val);
static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val);
static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val);
static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val);
static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val);
static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val);
static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val);
static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val);
static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val);
static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val);
static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val);
static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val);
static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val);
static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val);
static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val);
static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val);
static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val);
static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val);
static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val);
static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val);
static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val);
static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val);
static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val);
static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val);
static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val);
static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val);
static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val);
static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val);
static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val);
static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val);
static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val);
static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val);
static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val);
static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val);
static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val);
static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val);
static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val);
static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val);
#define ASN1Dec_FastStartToken(x,y)      0
static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val);
static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val);
static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val);
static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val);
static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val);
static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val);
static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val);
static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val);
static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val);
static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val);
static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val);
static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val);
static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val);
static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val);
static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val);
static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val);
static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val);
static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val);
static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val);
static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val);
static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val);
static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val);
static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val);
static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val);
static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val);
static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val);
static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val);
static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val);
static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val);
static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val);
static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val);
static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val);
static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val);
static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val);
static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val);
static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val);
static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val);
static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val);
static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val);
static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val);
static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val);
static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val);
static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val);
static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val);
static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val);
static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val);
static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val);
static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val);
static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val);
static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val);
static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val);
static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val);
static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val);
static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val);
static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val);
static void ASN1CALL ASN1Free_DHset(DHset *val);
static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val);
static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val);
static void ASN1CALL ASN1Free_ClearToken(ClearToken *val);
static void ASN1CALL ASN1Free_Params(Params *val);
static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val);
static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ICV(ICV *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val);
static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val);
static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val);
static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val);
static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val);
static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val);
static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val);
static void ASN1CALL ASN1Free_HASHED(HASHED *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val);
static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val);
static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val);
static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val);
static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val);
static void ASN1CALL ASN1Free_H245Security(H245Security *val);
static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val);
static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val);
static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val);
#define ASN1Free_FastStartToken(x)     
static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_DataRate(DataRate *val);
static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val);
static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val);
static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val);
static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val);
static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val);
static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val);
static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val);
static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val);
static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val);
static void ASN1CALL ASN1Free_LocationReject(LocationReject *val);
static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val);
static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val);
static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val);
static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val);
static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val);
static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val);
static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val);
static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val);
static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val);
static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val);
static void ASN1CALL ASN1Free_H310Caps(H310Caps *val);
static void ASN1CALL ASN1Free_H320Caps(H320Caps *val);
static void ASN1CALL ASN1Free_H321Caps(H321Caps *val);
static void ASN1CALL ASN1Free_H322Caps(H322Caps *val);
static void ASN1CALL ASN1Free_H323Caps(H323Caps *val);
static void ASN1CALL ASN1Free_H324Caps(H324Caps *val);
static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val);
static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val);
static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val);
static void ASN1CALL ASN1Free_McuInfo(McuInfo *val);
static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val);
static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val);
static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val);
static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val);
static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val);
static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val);
static void ASN1CALL ASN1Free_RTPSession(RTPSession *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val);
static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val);
static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val);
static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val);
static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val);
static void ASN1CALL ASN1Free_EndpointType(EndpointType *val);
static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_Endpoint(Endpoint *val);
static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val);
static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val);
static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val);
static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val);
static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val);
static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val);
static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val);
static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val);
static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val);
static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val);
static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val);
static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val);
static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val);
static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val);
static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val);
static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val);
static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val);
static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val);
static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val);
static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val);
static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val);
static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val);
static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val);
static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val);
static void ASN1CALL ASN1Free_RasMessage(RasMessage *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val);
static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val);
static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val);
static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val);
static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val);
static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val);
static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val);
static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val);
static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val);
static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_RasMessage,
    (ASN1EncFun_t) ASN1Enc_H323_UserInformation,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_RasMessage,
    (ASN1DecFun_t) ASN1Dec_H323_UserInformation,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_RasMessage,
    (ASN1FreeFun_t) ASN1Free_H323_UserInformation,
};
static const ULONG sizetab[2] = {
    SIZE_H225ASN_Module_PDU_0,
    SIZE_H225ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H225ASN_Module_Startup(void)
{
    H225ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35323268);
}

void ASN1CALL H225ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H225ASN_Module);
    H225ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 16))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 16))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds(ASN1encoding_t enc, PRTPSession_associatedSessionIds *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPSession_associatedSessionIds_ElmFn);
}

static int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PEREncBitVal(enc, 8, val->value - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds(ASN1decoding_t dec, PRTPSession_associatedSessionIds *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPSession_associatedSessionIds_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val)
{
    if (!ASN1PERDecU16Val(dec, 8, &val->value))
    return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds(PRTPSession_associatedSessionIds *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPSession_associatedSessionIds_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_preGrantedARQ(ASN1encoding_t enc, RegistrationConfirm_preGrantedARQ *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->makeCall))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToMakeCall))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->useGKCallSignalAddressToAnswer))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_preGrantedARQ(ASN1decoding_t dec, RegistrationConfirm_preGrantedARQ *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->makeCall))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToMakeCall))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->useGKCallSignalAddressToAnswer))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs(PGatekeeperRequest_algorithmOIDs *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val)
{
    if (val) {
    ASN1objectidentifier_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
    return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
    return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
    ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart(ASN1encoding_t enc, PProgress_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart(ASN1decoding_t dec, PProgress_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart(PProgress_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart(ASN1encoding_t enc, PFacility_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart(ASN1decoding_t dec, PFacility_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart(PFacility_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart(ASN1encoding_t enc, PSetup_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart(ASN1decoding_t dec, PSetup_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart(PSetup_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
    return 0;
    return 1;
}

//nik:change to fix the bug in decoding the extension filds in the CHOICE structure.
int MyASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    ASN1uint32_t x;
    ASN1uint16_t tempVal;

    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        if (ASN1PERDecN16Val(dec, pChoiceVal))
        {
            *pChoiceVal += ExtensionChoice + ASN1_CHOICE_BASE;
            
            /*skip 2 bytes*/
            return ASN1PERDecS16Val( dec, 16, &tempVal );
        }
    }
    return 0;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCRV_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart(ASN1encoding_t enc, PConnect_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart(ASN1decoding_t dec, PConnect_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart(PConnect_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart(PCallProceeding_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart(ASN1encoding_t enc, PAlerting_UUIE_fastStart *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_fastStart_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart(ASN1decoding_t dec, PAlerting_UUIE_fastStart *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_fastStart_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart(PAlerting_UUIE_fastStart *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_fastStart_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control(ASN1encoding_t enc, PH323_UU_PDU_h245Control *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h245Control_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control(ASN1decoding_t dec, PH323_UU_PDU_h245Control *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h245Control_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control(PH323_UU_PDU_h245Control *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h245Control_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PEREncOctetString_NoSize(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val)
{
    if (!ASN1PERDecOctetString_NoSize(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService(PH323_UU_PDU_h4501SupplementaryService *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val)
{
    if (val) {
    ASN1octetstring_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->protocol_discriminator))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->protocol_discriminator))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H235NonStandardParameter(ASN1encoding_t enc, H235NonStandardParameter *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235NonStandardParameter(ASN1decoding_t dec, H235NonStandardParameter *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H235NonStandardParameter(H235NonStandardParameter *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->nonStandardIdentifier);
    ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_DHset(ASN1encoding_t enc, DHset *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->halfkey).length))
    return 0;
    if (!ASN1PEREncBits(enc, ((val)->halfkey).length, ((val)->halfkey).value))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->modSize).length))
    return 0;
    if (!ASN1PEREncBits(enc, ((val)->modSize).length, ((val)->modSize).value))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->generator).length))
    return 0;
    if (!ASN1PEREncBits(enc, ((val)->generator).length, ((val)->generator).value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHset(ASN1decoding_t dec, DHset *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->halfkey).length))
    return 0;
    if (!ASN1PERDecBits(dec, ((val)->halfkey).length, &((val)->halfkey).value))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->modSize).length))
    return 0;
    if (!ASN1PERDecBits(dec, ((val)->modSize).length, &((val)->modSize).value))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->generator).length))
    return 0;
    if (!ASN1PERDecBits(dec, ((val)->generator).length, &((val)->generator).value))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DHset(DHset *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->halfkey);
    ASN1bitstring_free(&(val)->modSize);
    ASN1bitstring_free(&(val)->generator);
    }
}

static int ASN1CALL ASN1Enc_TypedCertificate(ASN1encoding_t enc, TypedCertificate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->type))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->certificate))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TypedCertificate(ASN1decoding_t dec, TypedCertificate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->type))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->certificate))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TypedCertificate(TypedCertificate *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->type);
    ASN1octetstring_free(&(val)->certificate);
    }
}

static int ASN1CALL ASN1Enc_AuthenticationMechanism(ASN1encoding_t enc, AuthenticationMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationMechanism(ASN1decoding_t dec, AuthenticationMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationMechanism(AuthenticationMechanism *val)
{
    if (val) {
    switch ((val)->choice) {
    case 7:
        ASN1Free_H235NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ClearToken(ASN1encoding_t enc, ClearToken *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->password).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->password).length, ((val)->password).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_DHset(enc, &(val)->dhkey))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncInteger(enc, (val)->random))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Enc_TypedCertificate(enc, &(val)->certificate))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->generalID).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->generalID).length, ((val)->generalID).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1Enc_H235NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ClearToken(ASN1decoding_t dec, ClearToken *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
        return 0;
    (val)->timeStamp += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->password).length))
        return 0;
    ((val)->password).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->password).length, &((val)->password).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_DHset(dec, &(val)->dhkey))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->challenge, 8, 128, 7))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecInteger(dec, &(val)->random))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_TypedCertificate(dec, &(val)->certificate))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->generalID).length))
        return 0;
    ((val)->generalID).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->generalID).length, &((val)->generalID).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1Dec_H235NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ClearToken(ClearToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->tokenOID);
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->password);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_DHset(&(val)->dhkey);
    }
    if ((val)->o[0] & 0x10) {
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_TypedCertificate(&(val)->certificate);
    }
    if ((val)->o[0] & 0x2) {
        ASN1char16string_free(&(val)->generalID);
    }
    if ((val)->o[0] & 0x1) {
        ASN1Free_H235NonStandardParameter(&(val)->nonStandard);
    }
    }
}

static int ASN1CALL ASN1Enc_Params(ASN1encoding_t enc, Params *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncInteger(enc, (val)->ranInt))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->iv8, 8))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Params(ASN1decoding_t dec, Params *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecInteger(dec, &(val)->ranInt))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->iv8, 8))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Params(Params *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
    }
    }
}

static int ASN1CALL ASN1Enc_EncodedGeneralToken(ASN1encoding_t enc, EncodedGeneralToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
    return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedGeneralToken(ASN1decoding_t dec, EncodedGeneralToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
    return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->type))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedGeneralToken(EncodedGeneralToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->id);
    ASN1Free_ClearToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_PwdCertToken(ASN1encoding_t enc, PwdCertToken *val)
{
    if (!ASN1Enc_ClearToken(enc, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PwdCertToken(ASN1decoding_t dec, PwdCertToken *val)
{
    if (!ASN1Dec_ClearToken(dec, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PwdCertToken(PwdCertToken *val)
{
    if (val) {
    ASN1Free_ClearToken(val);
    }
}

static int ASN1CALL ASN1Enc_EncodedPwdCertToken(ASN1encoding_t enc, EncodedPwdCertToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
    return 0;
    if (!ASN1Enc_PwdCertToken(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedPwdCertToken(ASN1decoding_t dec, EncodedPwdCertToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
    return 0;
    if (!ASN1Dec_PwdCertToken(dec, &(val)->type))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedPwdCertToken(EncodedPwdCertToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->id);
    ASN1Free_PwdCertToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1objectidentifier_free(&(val)->u.object);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AltGKInfo(ASN1encoding_t enc, AltGKInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_AltGKInfo_alternateGatekeeper(enc, &(val)->alternateGatekeeper))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->altGKisPermanent))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo(ASN1decoding_t dec, AltGKInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_AltGKInfo_alternateGatekeeper(dec, &(val)->alternateGatekeeper))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->altGKisPermanent))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo(AltGKInfo *val)
{
    if (val) {
    ASN1Free_AltGKInfo_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
}

static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conferenceCalling))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threePartyService))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conferenceCalling))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threePartyService))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ICV(ASN1encoding_t enc, ICV *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->icv).length, ((val)->icv).value, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ICV(ASN1decoding_t dec, ICV *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->icv).length, &((val)->icv).value, 1))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ICV(ICV *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1bitstring_free(&(val)->icv);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRejectReason(ASN1encoding_t enc, GatekeeperRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRejectReason(ASN1decoding_t dec, GatekeeperRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason(ASN1encoding_t enc, RegistrationRejectReason *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    if (!ASN1Enc_RegistrationRejectReason_duplicateAlias(enc, &(val)->u.duplicateAlias))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason(ASN1decoding_t dec, RegistrationRejectReason *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    if (!ASN1Dec_RegistrationRejectReason_duplicateAlias(dec, &(val)->u.duplicateAlias))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason(RegistrationRejectReason *val)
{
    if (val) {
    switch ((val)->choice) {
    case 5:
        ASN1Free_RegistrationRejectReason_duplicateAlias(&(val)->u.duplicateAlias);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_UnregRequestReason(ASN1encoding_t enc, UnregRequestReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRequestReason(ASN1decoding_t dec, UnregRequestReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnregRejectReason(ASN1encoding_t enc, UnregRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregRejectReason(ASN1decoding_t dec, UnregRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallModel(ASN1encoding_t enc, CallModel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallModel(ASN1decoding_t dec, CallModel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportQOS(ASN1encoding_t enc, TransportQOS *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportQOS(ASN1decoding_t dec, TransportQOS *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UUIEsRequested(ASN1encoding_t enc, UUIEsRequested *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->setup))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->callProceeding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->connect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alerting))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->information))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->releaseComplete))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->facility))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progress))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->empty))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UUIEsRequested(ASN1decoding_t dec, UUIEsRequested *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->setup))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->callProceeding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->connect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alerting))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->information))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->releaseComplete))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->facility))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progress))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->empty))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AdmissionRejectReason(ASN1encoding_t enc, AdmissionRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRejectReason(ASN1decoding_t dec, AdmissionRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_BandRejectReason(ASN1encoding_t enc, BandRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandRejectReason(ASN1decoding_t dec, BandRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_LocationRejectReason(ASN1encoding_t enc, LocationRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRejectReason(ASN1decoding_t dec, LocationRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageReason(ASN1encoding_t enc, DisengageReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReason(ASN1decoding_t dec, DisengageReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_DisengageRejectReason(ASN1encoding_t enc, DisengageRejectReason *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRejectReason(ASN1decoding_t dec, DisengageRejectReason *val)
{
    //nik:
    if (!MyASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InfoRequestNakReason(ASN1encoding_t enc, InfoRequestNakReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNakReason(ASN1decoding_t dec, InfoRequestNakReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse(ASN1encoding_t enc, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1Enc_UnknownMessageResponse_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1Enc_UnknownMessageResponse_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse(ASN1decoding_t dec, UnknownMessageResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnknownMessageResponse_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnknownMessageResponse_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse(UnknownMessageResponse *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_UnknownMessageResponse_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_UnknownMessageResponse_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(PInfoRequestResponse_perCallInfo_Seq_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens(PResourcesAvailableConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens(PResourcesAvailableIndicate_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens(ASN1encoding_t enc, PRequestInProgress_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens(ASN1decoding_t dec, PRequestInProgress_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens(PRequestInProgress_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens(ASN1encoding_t enc, PUnknownMessageResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens(ASN1decoding_t dec, PUnknownMessageResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens(PUnknownMessageResponse_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens(ASN1encoding_t enc, PH225NonStandardMessage_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens(ASN1decoding_t dec, PH225NonStandardMessage_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens(PH225NonStandardMessage_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens(ASN1encoding_t enc, PInfoRequestNak_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens(ASN1decoding_t dec, PInfoRequestNak_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens(PInfoRequestNak_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens(ASN1encoding_t enc, PInfoRequestAck_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens(ASN1decoding_t dec, PInfoRequestAck_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens(PInfoRequestAck_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens(ASN1encoding_t enc, PInfoRequestResponse_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens(ASN1decoding_t dec, PInfoRequestResponse_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens(PInfoRequestResponse_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens(ASN1encoding_t enc, PInfoRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens(ASN1decoding_t dec, PInfoRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_tokens(PInfoRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens(ASN1encoding_t enc, PDisengageReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens(ASN1decoding_t dec, PDisengageReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_tokens(PDisengageReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens(ASN1encoding_t enc, PDisengageConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens(ASN1decoding_t dec, PDisengageConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens(PDisengageConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens(ASN1encoding_t enc, PDisengageRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens(ASN1decoding_t dec, PDisengageRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens(PDisengageRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_tokens(ASN1encoding_t enc, PLocationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_tokens(ASN1decoding_t dec, PLocationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_tokens(PLocationReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens(ASN1encoding_t enc, PLocationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens(ASN1decoding_t dec, PLocationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens(PLocationConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens(ASN1encoding_t enc, PLocationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens(ASN1decoding_t dec, PLocationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_tokens(PLocationRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens(ASN1encoding_t enc, PBandwidthReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens(ASN1decoding_t dec, PBandwidthReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens(PBandwidthReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens(ASN1encoding_t enc, PBandwidthConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens(ASN1decoding_t dec, PBandwidthConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens(PBandwidthConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens(ASN1encoding_t enc, PBandwidthRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens(ASN1decoding_t dec, PBandwidthRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens(PBandwidthRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens(ASN1encoding_t enc, PAdmissionReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens(ASN1decoding_t dec, PAdmissionReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens(PAdmissionReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens(ASN1encoding_t enc, PAdmissionConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens(ASN1decoding_t dec, PAdmissionConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens(PAdmissionConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens(ASN1encoding_t enc, PAdmissionRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens(ASN1decoding_t dec, PAdmissionRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens(PAdmissionRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens(ASN1encoding_t enc, PUnregistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens(ASN1decoding_t dec, PUnregistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens(PUnregistrationReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens(ASN1encoding_t enc, PUnregistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens(ASN1decoding_t dec, PUnregistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens(PUnregistrationConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens(ASN1encoding_t enc, PUnregistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens(ASN1decoding_t dec, PUnregistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens(PUnregistrationRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens(ASN1encoding_t enc, PRegistrationReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens(ASN1decoding_t dec, PRegistrationReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens(PRegistrationReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens(ASN1encoding_t enc, PRegistrationConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens(ASN1decoding_t dec, PRegistrationConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens(PRegistrationConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens(ASN1encoding_t enc, PRegistrationRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens(ASN1decoding_t dec, PRegistrationRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens(PRegistrationRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens(ASN1encoding_t enc, PGatekeeperReject_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens(ASN1decoding_t dec, PGatekeeperReject_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens(PGatekeeperReject_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens(ASN1encoding_t enc, PGatekeeperConfirm_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens(ASN1decoding_t dec, PGatekeeperConfirm_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens(PGatekeeperConfirm_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Enc_AuthenticationMechanism(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val)
{
    if (!ASN1Dec_AuthenticationMechanism(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability(PGatekeeperRequest_authenticationCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val)
{
    if (val) {
    ASN1Free_AuthenticationMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens(ASN1encoding_t enc, PGatekeeperRequest_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens(ASN1decoding_t dec, PGatekeeperRequest_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens(PGatekeeperRequest_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_tokens(ASN1encoding_t enc, PEndpoint_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_tokens(ASN1decoding_t dec, PEndpoint_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_tokens(PEndpoint_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens(ASN1encoding_t enc, PProgress_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens(ASN1decoding_t dec, PProgress_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens(PProgress_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens(ASN1encoding_t enc, PFacility_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens(ASN1decoding_t dec, PFacility_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens(PFacility_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens(ASN1encoding_t enc, PSetup_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens(ASN1decoding_t dec, PSetup_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens(PSetup_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens(ASN1encoding_t enc, PConnect_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens(ASN1decoding_t dec, PConnect_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens(PConnect_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens(ASN1encoding_t enc, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens(ASN1decoding_t dec, PCallProceeding_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens(PCallProceeding_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens(ASN1encoding_t enc, PAlerting_UUIE_tokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_tokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val)
{
    if (!ASN1Enc_ClearToken(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens(ASN1decoding_t dec, PAlerting_UUIE_tokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_tokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val)
{
    if (!ASN1Dec_ClearToken(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens(PAlerting_UUIE_tokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_tokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val)
{
    if (val) {
    ASN1Free_ClearToken(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedGeneralToken(ASN1encoding_t enc, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Enc_EncodedGeneralToken(enc, &(val)->toBeSigned))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
    return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedGeneralToken(ASN1decoding_t dec, SIGNED_EncodedGeneralToken *val)
{
    if (!ASN1Dec_EncodedGeneralToken(dec, &(val)->toBeSigned))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
    return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedGeneralToken(SIGNED_EncodedGeneralToken *val)
{
    if (val) {
    ASN1Free_EncodedGeneralToken(&(val)->toBeSigned);
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1Free_Params(&(val)->paramS);
    ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_ENCRYPTED(ASN1encoding_t enc, ENCRYPTED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->encryptedData))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ENCRYPTED(ASN1decoding_t dec, ENCRYPTED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->encryptedData))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ENCRYPTED(ENCRYPTED *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1Free_Params(&(val)->paramS);
    ASN1octetstring_free(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_HASHED(ASN1encoding_t enc, HASHED *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
    return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->hash).length, ((val)->hash).value, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HASHED(ASN1decoding_t dec, HASHED *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
    return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->hash).length, &((val)->hash).value, 1))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HASHED(HASHED *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1Free_Params(&(val)->paramS);
    ASN1bitstring_free(&(val)->hash);
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedPwdCertToken(ASN1encoding_t enc, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Enc_EncodedPwdCertToken(enc, &(val)->toBeSigned))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
    return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedPwdCertToken(ASN1decoding_t dec, SIGNED_EncodedPwdCertToken *val)
{
    if (!ASN1Dec_EncodedPwdCertToken(dec, &(val)->toBeSigned))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
    return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedPwdCertToken(SIGNED_EncodedPwdCertToken *val)
{
    if (val) {
    ASN1Free_EncodedPwdCertToken(&(val)->toBeSigned);
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1Free_Params(&(val)->paramS);
    ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_Information_UUIE(ASN1encoding_t enc, Information_UUIE *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Information_UUIE(ASN1decoding_t dec, Information_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_Information_UUIE(Information_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    }
}

static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_ReleaseCompleteReason(enc, &(val)->reason))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_ReleaseCompleteReason(dec, &(val)->reason))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    }
}

static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_H221NonStandard(enc, &(val)->vendor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_H221NonStandard(dec, &(val)->vendor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x40) {
    }
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
    ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
    ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
    return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
    return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->publicNumberDigits) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
    return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
    return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->privateNumberDigits) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SecurityServiceMode(ASN1encoding_t enc, SecurityServiceMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityServiceMode(ASN1decoding_t dec, SecurityServiceMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityServiceMode(SecurityServiceMode *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_SecurityCapabilities(ASN1encoding_t enc, SecurityCapabilities *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->encryption))
    return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->authenticaton))
    return 0;
    if (!ASN1Enc_SecurityServiceMode(enc, &(val)->integrity))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCapabilities(ASN1decoding_t dec, SecurityCapabilities *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->encryption))
    return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->authenticaton))
    return 0;
    if (!ASN1Dec_SecurityServiceMode(dec, &(val)->integrity))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCapabilities(SecurityCapabilities *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandard);
    }
    ASN1Free_SecurityServiceMode(&(val)->encryption);
    ASN1Free_SecurityServiceMode(&(val)->authenticaton);
    ASN1Free_SecurityServiceMode(&(val)->integrity);
    }
}

static int ASN1CALL ASN1Enc_H245Security(ASN1encoding_t enc, H245Security *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.tls))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_SecurityCapabilities(enc, &(val)->u.ipsec))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245Security(ASN1decoding_t dec, H245Security *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.tls))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_SecurityCapabilities(dec, &(val)->u.ipsec))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245Security(H245Security *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1Free_SecurityCapabilities(&(val)->u.tls);
        break;
    case 4:
        ASN1Free_SecurityCapabilities(&(val)->u.ipsec);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q932Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q951Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q952Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q953Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q955Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q956Full))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q957Full))
    return 0;
    if (!ASN1Enc_Q954Details(enc, &(val)->q954Info))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q932Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q951Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q952Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q953Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q955Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q956Full))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q957Full))
    return 0;
    if (!ASN1Dec_Q954Details(dec, &(val)->q954Info))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptIntAlg(ASN1encoding_t enc, EncryptIntAlg *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.isoAlgorithm))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptIntAlg(ASN1decoding_t dec, EncryptIntAlg *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.isoAlgorithm))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptIntAlg(EncryptIntAlg *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1objectidentifier_free(&(val)->u.isoAlgorithm);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_NonIsoIntegrityMechanism(ASN1encoding_t enc, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_s))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_EncryptIntAlg(enc, &(val)->u.hMAC_iso10118_2_l))
        return 0;
    break;
    case 4:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.hMAC_iso10118_3))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonIsoIntegrityMechanism(ASN1decoding_t dec, NonIsoIntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_s))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_EncryptIntAlg(dec, &(val)->u.hMAC_iso10118_2_l))
        return 0;
    break;
    case 4:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.hMAC_iso10118_3))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonIsoIntegrityMechanism(NonIsoIntegrityMechanism *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_s);
        break;
    case 3:
        ASN1Free_EncryptIntAlg(&(val)->u.hMAC_iso10118_2_l);
        break;
    case 4:
        ASN1objectidentifier_free(&(val)->u.hMAC_iso10118_3);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_IntegrityMechanism(ASN1encoding_t enc, IntegrityMechanism *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.iso9797))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_NonIsoIntegrityMechanism(enc, &(val)->u.nonIsoIM))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityMechanism(ASN1decoding_t dec, IntegrityMechanism *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.iso9797))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_NonIsoIntegrityMechanism(dec, &(val)->u.nonIsoIM))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityMechanism(IntegrityMechanism *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1objectidentifier_free(&(val)->u.iso9797);
        break;
    case 4:
        ASN1Free_NonIsoIntegrityMechanism(&(val)->u.nonIsoIM);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncodedFastStartToken(ASN1encoding_t enc, EncodedFastStartToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->id))
    return 0;
    if (!ASN1Enc_FastStartToken(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedFastStartToken(ASN1decoding_t dec, EncodedFastStartToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->id))
    return 0;
    if (!ASN1Dec_FastStartToken(dec, &(val)->type))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedFastStartToken(EncodedFastStartToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->id);
    ASN1Free_FastStartToken(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_DataRate(ASN1encoding_t enc, DataRate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    l = ASN1uint32_uoctets((val)->channelRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->channelRate))
    return 0;
    if ((val)->o[0] & 0x40) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->channelMultiplier - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataRate(ASN1decoding_t dec, DataRate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->channelRate))
    return 0;
    if ((val)->o[0] & 0x40) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->channelMultiplier))
        return 0;
    (val)->channelMultiplier += 1;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataRate(DataRate *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject(ASN1encoding_t enc, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Enc_GatekeeperRejectReason(enc, &(val)->rejectReason))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_GatekeeperReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_GatekeeperReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject(ASN1decoding_t dec, GatekeeperReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Dec_GatekeeperRejectReason(dec, &(val)->rejectReason))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject(GatekeeperReject *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_GatekeeperReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_GatekeeperReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm(ASN1encoding_t enc, RegistrationConfirm *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 3, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_RegistrationConfirm_callSignalAddress(enc, &(val)->callSignalAddress))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_RegistrationConfirm_terminalAlias(enc, &(val)->terminalAlias))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 7, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_RegistrationConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        l = ASN1uint32_uoctets((val)->timeToLive - 1);
        if (!ASN1PEREncBitVal(ee, 2, l - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_RegistrationConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_RegistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_RegistrationConfirm_preGrantedARQ(ee, &(val)->preGrantedARQ))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm(ASN1decoding_t dec, RegistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_RegistrationConfirm_callSignalAddress(dec, &(val)->callSignalAddress))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_RegistrationConfirm_terminalAlias(dec, &(val)->terminalAlias))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 2, &l))
        return 0;
        l += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
        return 0;
        (val)->timeToLive += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationConfirm_preGrantedARQ(dd, &(val)->preGrantedARQ))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm(RegistrationConfirm *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_RegistrationConfirm_callSignalAddress(&(val)->callSignalAddress);
    if ((val)->o[0] & 0x40) {
        ASN1Free_RegistrationConfirm_terminalAlias(&(val)->terminalAlias);
    }
    if ((val)->o[0] & 0x20) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    ASN1char16string_free(&(val)->endpointIdentifier);
    if ((val)->o[1] & 0x80) {
        ASN1Free_RegistrationConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_RegistrationConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_RegistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject(ASN1encoding_t enc, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_RegistrationRejectReason(enc, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_RegistrationReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_RegistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject(ASN1decoding_t dec, RegistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_RegistrationRejectReason(dec, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject(RegistrationReject *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_RegistrationRejectReason(&(val)->rejectReason);
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_RegistrationReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_RegistrationReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest(ASN1encoding_t enc, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_UnregistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_UnregistrationRequest_endpointAlias(enc, &(val)->endpointAlias))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 6, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_UnregistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_UnregistrationRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_UnregistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1Enc_UnregRequestReason(ee, &(val)->reason))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest(ASN1decoding_t dec, UnregistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_UnregistrationRequest_endpointAlias(dec, &(val)->endpointAlias))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
        return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
        ((val)->gatekeeperIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregRequestReason(dd, &(val)->reason))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest(UnregistrationRequest *val)
{
    if (val) {
    ASN1Free_UnregistrationRequest_callSignalAddress(&(val)->callSignalAddress);
    if ((val)->o[0] & 0x80) {
        ASN1Free_UnregistrationRequest_endpointAlias(&(val)->endpointAlias);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x20) {
        ASN1char16string_free(&(val)->endpointIdentifier);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_UnregistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
    }
    if ((val)->o[1] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_UnregistrationRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_UnregistrationRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm(ASN1encoding_t enc, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_UnregistrationConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_UnregistrationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm(ASN1decoding_t dec, UnregistrationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm(UnregistrationConfirm *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_UnregistrationConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_UnregistrationConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject(ASN1encoding_t enc, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_UnregRejectReason(enc, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_UnregistrationReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_UnregistrationReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject(ASN1decoding_t dec, UnregistrationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_UnregRejectReason(dec, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UnregistrationReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject(UnregistrationReject *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_UnregistrationReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_UnregistrationReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject(ASN1encoding_t enc, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_AdmissionRejectReason(enc, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_AdmissionReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_AdmissionReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_AdmissionReject_callSignalAddress(ee, &(val)->callSignalAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject(ASN1decoding_t dec, AdmissionReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_AdmissionRejectReason(dec, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionReject_callSignalAddress(dd, &(val)->callSignalAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject(AdmissionReject *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_AdmissionReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_AdmissionReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_AdmissionReject_callSignalAddress(&(val)->callSignalAddress);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest(ASN1encoding_t enc, BandwidthRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_CallType(enc, &(val)->callType))
        return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_BandwidthRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_BandwidthRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest(ASN1decoding_t dec, BandwidthRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CallType(dec, &(val)->callType))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
        ((val)->gatekeeperIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest(BandwidthRequest *val)
{
    if (val) {
    ASN1char16string_free(&(val)->endpointIdentifier);
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_BandwidthRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_BandwidthRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm(ASN1encoding_t enc, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_BandwidthConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_BandwidthConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm(ASN1decoding_t dec, BandwidthConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm(BandwidthConfirm *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_BandwidthConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_BandwidthConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject(ASN1encoding_t enc, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_BandRejectReason(enc, &(val)->rejectReason))
    return 0;
    l = ASN1uint32_uoctets((val)->allowedBandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->allowedBandWidth))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_BandwidthReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_BandwidthReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject(ASN1decoding_t dec, BandwidthReject *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_BandRejectReason(dec, &(val)->rejectReason))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->allowedBandWidth))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_BandwidthReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject(BandwidthReject *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_BandwidthReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_BandwidthReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_LocationReject(ASN1encoding_t enc, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_LocationRejectReason(enc, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_LocationReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_LocationReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject(ASN1decoding_t dec, LocationReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_LocationRejectReason(dec, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject(LocationReject *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_LocationReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_LocationReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest(ASN1encoding_t enc, DisengageRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
    return 0;
    if (!ASN1Enc_DisengageReason(enc, &(val)->disengageReason))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_DisengageRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_DisengageRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1PEREncBoolean(ee, (val)->answeredCall))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest(ASN1decoding_t dec, DisengageRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
    return 0;
    if (!ASN1Dec_DisengageReason(dec, &(val)->disengageReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
        ((val)->gatekeeperIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->answeredCall))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest(DisengageRequest *val)
{
    if (val) {
    ASN1char16string_free(&(val)->endpointIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_DisengageRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_DisengageRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm(ASN1encoding_t enc, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_DisengageConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_DisengageConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm(ASN1decoding_t dec, DisengageConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm(DisengageConfirm *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_DisengageConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_DisengageConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_DisengageReject(ASN1encoding_t enc, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_DisengageRejectReason(enc, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_AltGKInfo(ee, &(val)->altGKInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_DisengageReject_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_DisengageReject_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject(ASN1decoding_t dec, DisengageReject *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_DisengageRejectReason(dec, &(val)->rejectReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AltGKInfo(dd, &(val)->altGKInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageReject_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_DisengageReject_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject(DisengageReject *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_DisengageReject_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_DisengageReject_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck(ASN1encoding_t enc, InfoRequestAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_InfoRequestAck_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_InfoRequestAck_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck(ASN1decoding_t dec, InfoRequestAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_InfoRequestAck_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_InfoRequestAck_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck(InfoRequestAck *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_InfoRequestAck_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_InfoRequestAck_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak(ASN1encoding_t enc, InfoRequestNak *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_InfoRequestNakReason(enc, &(val)->nakReason))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_AltGKInfo(enc, &(val)->altGKInfo))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_InfoRequestNak_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_InfoRequestNak_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak(ASN1decoding_t dec, InfoRequestNak *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_InfoRequestNakReason(dec, &(val)->nakReason))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_AltGKInfo(dec, &(val)->altGKInfo))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_InfoRequestNak_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_InfoRequestNak_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak(InfoRequestNak *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_AltGKInfo(&(val)->altGKInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_InfoRequestNak_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_InfoRequestNak_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage(ASN1encoding_t enc, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1Enc_H225NonStandardMessage_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1Enc_H225NonStandardMessage_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage(ASN1decoding_t dec, H225NonStandardMessage *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H225NonStandardMessage_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H225NonStandardMessage_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage(H225NonStandardMessage *val)
{
    if (val) {
    ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardMessage_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardMessage_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress(ASN1encoding_t enc, RequestInProgress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_RequestInProgress_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_RequestInProgress_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
        return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->delay - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress(ASN1decoding_t dec, RequestInProgress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_RequestInProgress_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_RequestInProgress_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
        return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->delay))
    return 0;
    (val)->delay += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress(RequestInProgress *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_RequestInProgress_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_RequestInProgress_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate(ASN1encoding_t enc, ResourcesAvailableIndicate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1Enc_ResourcesAvailableIndicate_protocols(enc, &(val)->protocols))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->almostOutOfResources))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_ResourcesAvailableIndicate_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate(ASN1decoding_t dec, ResourcesAvailableIndicate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1Dec_ResourcesAvailableIndicate_protocols(dec, &(val)->protocols))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->almostOutOfResources))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_ResourcesAvailableIndicate_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate(ResourcesAvailableIndicate *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1char16string_free(&(val)->endpointIdentifier);
    ASN1Free_ResourcesAvailableIndicate_protocols(&(val)->protocols);
    if ((val)->o[0] & 0x40) {
        ASN1Free_ResourcesAvailableIndicate_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_ResourcesAvailableIndicate_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm(ASN1encoding_t enc, ResourcesAvailableConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_ResourcesAvailableConfirm_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_ICV(enc, &(val)->integrityCheckValue))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm(ASN1decoding_t dec, ResourcesAvailableConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_ResourcesAvailableConfirm_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_ICV(dec, &(val)->integrityCheckValue))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm(ResourcesAvailableConfirm *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_ResourcesAvailableConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_ResourcesAvailableConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity(ASN1encoding_t enc, PGatekeeperConfirm_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity(ASN1decoding_t dec, PGatekeeperConfirm_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity(PGatekeeperConfirm_integrity *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val)
{
    if (val) {
    ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity(ASN1encoding_t enc, PGatekeeperRequest_integrity *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_integrity_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val)
{
    if (!ASN1Enc_IntegrityMechanism(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity(ASN1decoding_t dec, PGatekeeperRequest_integrity *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_integrity_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val)
{
    if (!ASN1Dec_IntegrityMechanism(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity(PGatekeeperRequest_integrity *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_integrity_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val)
{
    if (val) {
    ASN1Free_IntegrityMechanism(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoGKPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperId).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperId).length, ((val)->gatekeeperId).value, 16))
    return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
    return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoGKPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoGKPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperId).length))
    return 0;
    ((val)->gatekeeperId).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperId).length, &((val)->gatekeeperId).value, 16))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
    return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoGKPwdHash(CryptoH323Token_cryptoGKPwdHash *val)
{
    if (val) {
    ASN1char16string_free(&(val)->gatekeeperId);
    ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported(PNonStandardProtocol_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported(PT120OnlyCaps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported(PVoiceCaps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported(ASN1encoding_t enc, PH324Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported(ASN1decoding_t dec, PH324Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported(PH324Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported(ASN1encoding_t enc, PH323Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported(ASN1decoding_t dec, PH323Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported(PH323Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported(ASN1encoding_t enc, PH322Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported(ASN1decoding_t dec, PH322Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported(PH322Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported(ASN1encoding_t enc, PH321Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported(ASN1decoding_t dec, PH321Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported(PH321Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported(ASN1encoding_t enc, PH320Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported(ASN1decoding_t dec, PH320Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported(PH320Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported(ASN1encoding_t enc, PH310Caps_dataRatesSupported *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_dataRatesSupported_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Enc_DataRate(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported(ASN1decoding_t dec, PH310Caps_dataRatesSupported *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_dataRatesSupported_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val)
{
    if (!ASN1Dec_DataRate(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported(PH310Caps_dataRatesSupported *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_dataRatesSupported_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val)
{
    if (val) {
    ASN1Free_DataRate(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Enc_H245Security(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val)
{
    if (!ASN1Dec_H245Security(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability(PSetup_UUIE_h245SecurityCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val)
{
    if (val) {
    ASN1Free_H245Security(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn);
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Enc_H225NonStandardParameter(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val)
{
    if (!ASN1Dec_H225NonStandardParameter(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl(PH323_UU_PDU_nonStandardControl *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val)
{
    if (val) {
    ASN1Free_H225NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoHashedToken(ASN1encoding_t enc, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
    return 0;
    if (!ASN1Enc_ClearToken(enc, &(val)->hashedVals))
    return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoHashedToken(ASN1decoding_t dec, CryptoToken_cryptoHashedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
    return 0;
    if (!ASN1Dec_ClearToken(dec, &(val)->hashedVals))
    return 0;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoHashedToken(CryptoToken_cryptoHashedToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->tokenOID);
    ASN1Free_ClearToken(&(val)->hashedVals);
    ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoSignedToken(ASN1encoding_t enc, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
    return 0;
    if (!ASN1Enc_SIGNED_EncodedGeneralToken(enc, &(val)->token))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoSignedToken(ASN1decoding_t dec, CryptoToken_cryptoSignedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
    return 0;
    if (!ASN1Dec_SIGNED_EncodedGeneralToken(dec, &(val)->token))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoSignedToken(CryptoToken_cryptoSignedToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->tokenOID);
    ASN1Free_SIGNED_EncodedGeneralToken(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken_cryptoEncryptedToken(ASN1encoding_t enc, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->tokenOID))
    return 0;
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->token))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken_cryptoEncryptedToken(ASN1decoding_t dec, CryptoToken_cryptoEncryptedToken *val)
{
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->tokenOID))
    return 0;
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->token))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken_cryptoEncryptedToken(CryptoToken_cryptoEncryptedToken *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->tokenOID);
    ASN1Free_ENCRYPTED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_CryptoToken(ASN1encoding_t enc, CryptoToken *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_CryptoToken_cryptoEncryptedToken(enc, &(val)->u.cryptoEncryptedToken))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_CryptoToken_cryptoSignedToken(enc, &(val)->u.cryptoSignedToken))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_CryptoToken_cryptoHashedToken(enc, &(val)->u.cryptoHashedToken))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoPwdEncr))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoToken(ASN1decoding_t dec, CryptoToken *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_CryptoToken_cryptoEncryptedToken(dec, &(val)->u.cryptoEncryptedToken))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_CryptoToken_cryptoSignedToken(dec, &(val)->u.cryptoSignedToken))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_CryptoToken_cryptoHashedToken(dec, &(val)->u.cryptoHashedToken))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoPwdEncr))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoToken(CryptoToken *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_CryptoToken_cryptoEncryptedToken(&(val)->u.cryptoEncryptedToken);
        break;
    case 2:
        ASN1Free_CryptoToken_cryptoSignedToken(&(val)->u.cryptoSignedToken);
        break;
    case 3:
        ASN1Free_CryptoToken_cryptoHashedToken(&(val)->u.cryptoHashedToken);
        break;
    case 4:
        ASN1Free_ENCRYPTED(&(val)->u.cryptoPwdEncr);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_SIGNED_EncodedFastStartToken(ASN1encoding_t enc, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Enc_EncodedFastStartToken(enc, &(val)->toBeSigned))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->algorithmOID))
    return 0;
    if (!ASN1Enc_Params(enc, &(val)->paramS))
    return 0;
    if (!ASN1PEREncFragmented(enc, ((val)->signature).length, ((val)->signature).value, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SIGNED_EncodedFastStartToken(ASN1decoding_t dec, SIGNED_EncodedFastStartToken *val)
{
    if (!ASN1Dec_EncodedFastStartToken(dec, &(val)->toBeSigned))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->algorithmOID))
    return 0;
    if (!ASN1Dec_Params(dec, &(val)->paramS))
    return 0;
    if (!ASN1PERDecFragmented(dec, &((val)->signature).length, &((val)->signature).value, 1))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SIGNED_EncodedFastStartToken(SIGNED_EncodedFastStartToken *val)
{
    if (val) {
    ASN1Free_EncodedFastStartToken(&(val)->toBeSigned);
    ASN1objectidentifier_free(&(val)->algorithmOID);
    ASN1Free_Params(&(val)->paramS);
    ASN1bitstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
        return 0;
    break;
    case 5:
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 6:
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
        return 0;
    break;
    case 5:
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 6:
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
        break;
    case 2:
        ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
        break;
    case 3:
        ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
        break;
    case 4:
        ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
        break;
    case 5:
        break;
    case 6:
        break;
    case 7:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_GatewayInfo_protocol(enc, &(val)->protocol))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_GatewayInfo_protocol(dec, &(val)->protocol))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_GatewayInfo_protocol(&(val)->protocol);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H310Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H310Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H310Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H310Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps(H310Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H310Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H310Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H320Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H320Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H320Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H320Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps(H320Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H320Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H320Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H321Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H321Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H321Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H321Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps(H321Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H321Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H321Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H322Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H322Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H322Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H322Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps(H322Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H322Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H322Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H323Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H323Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H323Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H323Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps(H323Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H323Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H323Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H324Caps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H324Caps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H324Caps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H324Caps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps(H324Caps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H324Caps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H324Caps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_VoiceCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_VoiceCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_VoiceCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_VoiceCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_VoiceCaps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_VoiceCaps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_T120OnlyCaps_dataRatesSupported(ee, &(val)->dataRatesSupported))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_T120OnlyCaps_supportedPrefixes(ee, &(val)->supportedPrefixes))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_T120OnlyCaps_dataRatesSupported(dd, &(val)->dataRatesSupported))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_T120OnlyCaps_supportedPrefixes(dd, &(val)->supportedPrefixes))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_T120OnlyCaps_dataRatesSupported(&(val)->dataRatesSupported);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_T120OnlyCaps_supportedPrefixes(&(val)->supportedPrefixes);
    }
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol(ASN1encoding_t enc, NonStandardProtocol *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_NonStandardProtocol_dataRatesSupported(enc, &(val)->dataRatesSupported))
        return 0;
    }
    if (!ASN1Enc_NonStandardProtocol_supportedPrefixes(enc, &(val)->supportedPrefixes))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol(ASN1decoding_t dec, NonStandardProtocol *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_NonStandardProtocol_dataRatesSupported(dec, &(val)->dataRatesSupported))
        return 0;
    }
    if (!ASN1Dec_NonStandardProtocol_supportedPrefixes(dec, &(val)->supportedPrefixes))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol(NonStandardProtocol *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_NonStandardProtocol_dataRatesSupported(&(val)->dataRatesSupported);
    }
    ASN1Free_NonStandardProtocol_supportedPrefixes(&(val)->supportedPrefixes);
    }
}

static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_McuInfo(McuInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
        return 0;
    break;
    case 2:
    t = lstrlenA((val)->u.dataPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
        return 0;
    break;
    case 3:
    t = lstrlenA((val)->u.telexPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
        return 0;
    break;
    case 5:
    t = lstrlenA((val)->u.nationalStandardPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.dataPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.telexPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
        return 0;
    break;
    case 5:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    
    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.nationalStandardPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
        break;
    case 5:
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_AlternateGK(ASN1encoding_t enc, AlternateGK *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->needToRegister))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlternateGK(ASN1decoding_t dec, AlternateGK *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->needToRegister))
    return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternateGK(AlternateGK *val)
{
    if (val) {
    ASN1Free_TransportAddress(&(val)->rasAddress);
    if ((val)->o[0] & 0x80) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm(ASN1encoding_t enc, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ee, &(val)->alternateGatekeeper))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_AuthenticationMechanism(ee, &(val)->authenticationMode))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_GatekeeperConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_GatekeeperConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PEREncObjectIdentifier(ee, &(val)->algorithmOID))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1Enc_GatekeeperConfirm_integrity(ee, &(val)->integrity))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm(ASN1decoding_t dec, GatekeeperConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperConfirm_alternateGatekeeper(dd, &(val)->alternateGatekeeper))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AuthenticationMechanism(dd, &(val)->authenticationMode))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecObjectIdentifier(dd, &(val)->algorithmOID))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperConfirm_integrity(dd, &(val)->integrity))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm(GatekeeperConfirm *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    ASN1Free_TransportAddress(&(val)->rasAddress);
    if ((val)->o[1] & 0x80) {
        ASN1Free_GatekeeperConfirm_alternateGatekeeper(&(val)->alternateGatekeeper);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_AuthenticationMechanism(&(val)->authenticationMode);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_GatekeeperConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_GatekeeperConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1objectidentifier_free(&(val)->algorithmOID);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_GatekeeperConfirm_integrity(&(val)->integrity);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest(ASN1encoding_t enc, AdmissionRequest *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x80;
    o[1] |= 0x40;
    o[2] |= 0x40;
    y = ASN1PEREncCheckExtensions(10, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 7, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
        return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_AdmissionRequest_destinationInfo(enc, &(val)->destinationInfo))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1Enc_AdmissionRequest_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
        return 0;
    }
    if (!ASN1Enc_AdmissionRequest_srcInfo(enc, &(val)->srcInfo))
    return 0;
    if (o[0] & 0x8) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->srcCallSignalAddress))
        return 0;
    }
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
    return 0;
    if (o[0] & 0x4) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (o[0] & 0x2) {
    if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
        return 0;
    }
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->answerCall))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 10, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_AdmissionRequest_srcAlternatives(ee, &(val)->srcAlternatives))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_AdmissionRequest_destAlternatives(ee, &(val)->destAlternatives))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1Enc_AdmissionRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_AdmissionRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x80) {
        if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x40) {
        if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest(ASN1decoding_t dec, AdmissionRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_AdmissionRequest_destinationInfo(dec, &(val)->destinationInfo))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_AdmissionRequest_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
        return 0;
    }
    if (!ASN1Dec_AdmissionRequest_srcInfo(dec, &(val)->srcInfo))
    return 0;
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->srcCallSignalAddress))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
    return 0;
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
        return 0;
    }
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->answerCall))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 2);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 10, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionRequest_srcAlternatives(dd, &(val)->srcAlternatives))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionRequest_destAlternatives(dd, &(val)->destAlternatives))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
        ((val)->gatekeeperIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest(AdmissionRequest *val)
{
    if (val) {
    ASN1char16string_free(&(val)->endpointIdentifier);
    if ((val)->o[0] & 0x40) {
        ASN1Free_AdmissionRequest_destinationInfo(&(val)->destinationInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_AdmissionRequest_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    ASN1Free_AdmissionRequest_srcInfo(&(val)->srcInfo);
    if ((val)->o[0] & 0x8) {
        ASN1Free_TransportAddress(&(val)->srcCallSignalAddress);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_AdmissionRequest_srcAlternatives(&(val)->srcAlternatives);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_AdmissionRequest_destAlternatives(&(val)->destAlternatives);
    }
    if ((val)->o[1] & 0x8) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_AdmissionRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_AdmissionRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x1) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_LocationRequest(ASN1encoding_t enc, LocationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(6, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Enc_LocationRequest_destinationInfo(enc, &(val)->destinationInfo))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 6, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_LocationRequest_sourceInfo(ee, &(val)->sourceInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncBoolean(ee, (val)->canMapAlias))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_LocationRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_LocationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest(ASN1decoding_t dec, LocationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
        return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Dec_LocationRequest_destinationInfo(dec, &(val)->destinationInfo))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 6, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationRequest_sourceInfo(dd, &(val)->sourceInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->canMapAlias))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
        ((val)->gatekeeperIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest(LocationRequest *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1char16string_free(&(val)->endpointIdentifier);
    }
    ASN1Free_LocationRequest_destinationInfo(&(val)->destinationInfo);
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_TransportAddress(&(val)->replyAddress);
    if ((val)->o[1] & 0x80) {
        ASN1Free_LocationRequest_sourceInfo(&(val)->sourceInfo);
    }
    if ((val)->o[1] & 0x20) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_LocationRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_LocationRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequest(ASN1encoding_t enc, InfoRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->replyAddress))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_InfoRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_InfoRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest(ASN1decoding_t dec, InfoRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->replyAddress))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest(InfoRequest *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_TransportAddress(&(val)->replyAddress);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_InfoRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_InfoRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_TransportChannelInfo(ASN1encoding_t enc, TransportChannelInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->sendAddress))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->recvAddress))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportChannelInfo(ASN1decoding_t dec, TransportChannelInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->sendAddress))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->recvAddress))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportChannelInfo(TransportChannelInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->sendAddress);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_TransportAddress(&(val)->recvAddress);
    }
    }
}

static int ASN1CALL ASN1Enc_RTPSession(ASN1encoding_t enc, RTPSession *val)
{
    ASN1uint32_t t;
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtpAddress))
    return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->rtcpAddress))
    return 0;
    t = lstrlenA((val)->cname);
    if (!ASN1PEREncFragmentedCharString(enc, t, (val)->cname, 8))
    return 0;
    l = ASN1uint32_uoctets((val)->ssrc - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->ssrc - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionId - 1))
    return 0;
    if (!ASN1Enc_RTPSession_associatedSessionIds(enc, &(val)->associatedSessionIds))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPSession(ASN1decoding_t dec, RTPSession *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtpAddress))
    return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->rtcpAddress))
    return 0;
    if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->cname, 8))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->ssrc))
    return 0;
    (val)->ssrc += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionId))
    return 0;
    (val)->sessionId += 1;
    if (!ASN1Dec_RTPSession_associatedSessionIds(dec, &(val)->associatedSessionIds))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPSession(RTPSession *val)
{
    if (val) {
    ASN1Free_TransportChannelInfo(&(val)->rtpAddress);
    ASN1Free_TransportChannelInfo(&(val)->rtcpAddress);
    ASN1ztcharstring_free((val)->cname);
    ASN1Free_RTPSession_associatedSessionIds(&(val)->associatedSessionIds);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Enc_TransportChannelInfo(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (!ASN1Dec_TransportChannelInfo(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(PInfoRequestResponse_perCallInfo_Seq_data *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val)
{
    if (val) {
    ASN1Free_TransportChannelInfo(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(PInfoRequestResponse_perCallInfo_Seq_video *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val)
{
    if (val) {
    ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Enc_RTPSession(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (!ASN1Dec_RTPSession(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(PInfoRequestResponse_perCallInfo_Seq_audio *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val)
{
    if (val) {
    ASN1Free_RTPSession(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 5, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->callReferenceValue))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1PEREncBoolean(enc, (val)->originator))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio(enc, &(val)->audio))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video(enc, &(val)->video))
        return 0;
    }
    if (o[0] & 0x8) {
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data(enc, &(val)->data))
        return 0;
    }
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->h245))
    return 0;
    if (!ASN1Enc_TransportChannelInfo(enc, &(val)->callSignaling))
    return 0;
    if (!ASN1Enc_CallType(enc, &(val)->callType))
    return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
    return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(ee, &(val)->substituteConfIDs))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ee, &(val)->pdu))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->callReferenceValue))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecBoolean(dec, &(val)->originator))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio(dec, &(val)->audio))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video(dec, &(val)->video))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data(dec, &(val)->data))
        return 0;
    }
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->h245))
    return 0;
    if (!ASN1Dec_TransportChannelInfo(dec, &(val)->callSignaling))
    return 0;
    if (!ASN1Dec_CallType(dec, &(val)->callType))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
    return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(dd, &(val)->substituteConfIDs))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(dd, &(val)->pdu))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq(InfoRequestResponse_perCallInfo_Seq *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio(&(val)->audio);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_video(&(val)->video);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_data(&(val)->data);
    }
    ASN1Free_TransportChannelInfo(&(val)->h245);
    ASN1Free_TransportChannelInfo(&(val)->callSignaling);
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs(&(val)->substituteConfIDs);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(&(val)->pdu);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo(PInfoRequestResponse_perCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val)
{
    if (val) {
    ASN1Free_InfoRequestResponse_perCallInfo_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress(PInfoRequestResponse_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress(ASN1encoding_t enc, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress(ASN1decoding_t dec, PAdmissionReject_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress(PAdmissionReject_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress(PUnregistrationRequest_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper(PRegistrationConfirm_alternateGatekeeper *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val)
{
    if (val) {
    ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress(PRegistrationConfirm_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress(ASN1encoding_t enc, PRegistrationRequest_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress(ASN1decoding_t dec, PRegistrationRequest_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress(PRegistrationRequest_rasAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress(PRegistrationRequest_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper(PGatekeeperConfirm_alternateGatekeeper *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val)
{
    if (val) {
    ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn);
}

static int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Enc_AlternateGK(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val)
{
    if (!ASN1Dec_AlternateGK(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper(PAltGKInfo_alternateGatekeeper *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val)
{
    if (val) {
    ASN1Free_AlternateGK(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress(ASN1encoding_t enc, PEndpoint_rasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_rasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress(ASN1decoding_t dec, PEndpoint_rasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_rasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress(PEndpoint_rasAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_rasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress(ASN1encoding_t enc, PEndpoint_callSignalAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_callSignalAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val)
{
    if (!ASN1Enc_TransportAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress(ASN1decoding_t dec, PEndpoint_callSignalAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_callSignalAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val)
{
    if (!ASN1Dec_TransportAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress(PEndpoint_callSignalAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_callSignalAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val)
{
    if (val) {
    ASN1Free_TransportAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_VendorIdentifier(enc, &(val)->vendor))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_GatekeeperInfo(enc, &(val)->gatekeeper))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_GatewayInfo(enc, &(val)->gateway))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_McuInfo(enc, &(val)->mcu))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Enc_TerminalInfo(enc, &(val)->terminal))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->mc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->undefinedNode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_VendorIdentifier(dec, &(val)->vendor))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_GatekeeperInfo(dec, &(val)->gatekeeper))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_GatewayInfo(dec, &(val)->gateway))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_McuInfo(dec, &(val)->mcu))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_TerminalInfo(dec, &(val)->terminal))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->mc))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->undefinedNode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointType(EndpointType *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_VendorIdentifier(&(val)->vendor);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_GatekeeperInfo(&(val)->gatekeeper);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_GatewayInfo(&(val)->gateway);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_McuInfo(&(val)->mcu);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_TerminalInfo(&(val)->terminal);
    }
    }
}

static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 9))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H310Caps(enc, &(val)->u.h310))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H320Caps(enc, &(val)->u.h320))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_H321Caps(enc, &(val)->u.h321))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_H322Caps(enc, &(val)->u.h322))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_H323Caps(enc, &(val)->u.h323))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_H324Caps(enc, &(val)->u.h324))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_VoiceCaps(enc, &(val)->u.voice))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_T120OnlyCaps(enc, &(val)->u.t120_only))
        return 0;
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_NonStandardProtocol(ee, &(val)->u.nonStandardProtocol))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 9))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H310Caps(dec, &(val)->u.h310))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H320Caps(dec, &(val)->u.h320))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_H321Caps(dec, &(val)->u.h321))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_H322Caps(dec, &(val)->u.h322))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_H323Caps(dec, &(val)->u.h323))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_H324Caps(dec, &(val)->u.h324))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_VoiceCaps(dec, &(val)->u.voice))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_T120OnlyCaps(dec, &(val)->u.t120_only))
        return 0;
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_NonStandardProtocol(dd, &(val)->u.nonStandardProtocol))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    case 2:
        ASN1Free_H310Caps(&(val)->u.h310);
        break;
    case 3:
        ASN1Free_H320Caps(&(val)->u.h320);
        break;
    case 4:
        ASN1Free_H321Caps(&(val)->u.h321);
        break;
    case 5:
        ASN1Free_H322Caps(&(val)->u.h322);
        break;
    case 6:
        ASN1Free_H323Caps(&(val)->u.h323);
        break;
    case 7:
        ASN1Free_H324Caps(&(val)->u.h324);
        break;
    case 8:
        ASN1Free_VoiceCaps(&(val)->u.voice);
        break;
    case 9:
        ASN1Free_T120OnlyCaps(&(val)->u.t120_only);
        break;
    case 10:
        ASN1Free_NonStandardProtocol(&(val)->u.nonStandardProtocol);
        break;
    }
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    t = lstrlenA((val)->u.e164);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
        return 0;
    break;
    case 2:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
        return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
        return 0;
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    t = lstrlenA((val)->u.url_ID);
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 16, t - 1))
        return 0;
    if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 5:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    t = lstrlenA((val)->u.email_ID);
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 16, t - 1))
        return 0;
    if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 6:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    
    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.e164) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
        return 0;
    break;
    case 2:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
        return 0;
    ((val)->u.h323_ID).length += 1;
    if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU32Val(dd, 16, &l))
        return 0;
    l += 1;

    //NikhilB: Fix for the overflow bug 03/02/26
    if (l >= sizeof((val)->u.url_ID)) { 
        ASN1DecSetError(dd, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 5:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU32Val(dd, 16, &l))
        return 0;
    l += 1;

    //NikhilB: Fix for the overflow bug 03/02/26
    if (l >= sizeof((val)->u.email_ID)) { 
        ASN1DecSetError(dd, ASN1_ERR_LARGE);
        return 0; 
    }
    
    if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 6:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        break;
    case 2:
        ASN1char16string_free(&(val)->u.h323_ID);
        break;
    case 3:
        break;
    case 4:
        ASN1Free_TransportAddress(&(val)->u.transportID);
        break;
    case 5:
        break;
    case 6:
        ASN1Free_PartyNumber(&(val)->u.partyNumber);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_Endpoint(ASN1encoding_t enc, Endpoint *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_Endpoint_aliasAddress(enc, &(val)->aliasAddress))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_Endpoint_callSignalAddress(enc, &(val)->callSignalAddress))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_Endpoint_rasAddress(enc, &(val)->rasAddress))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Enc_Endpoint_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Enc_Endpoint_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1PEREncBitVal(enc, 7, (val)->priority))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1Enc_Endpoint_remoteExtensionAddress(enc, &(val)->remoteExtensionAddress))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1Enc_Endpoint_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint(ASN1decoding_t dec, Endpoint *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_Endpoint_aliasAddress(dec, &(val)->aliasAddress))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_Endpoint_callSignalAddress(dec, &(val)->callSignalAddress))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_Endpoint_rasAddress(dec, &(val)->rasAddress))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_Endpoint_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Dec_Endpoint_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1PERDecU16Val(dec, 7, &(val)->priority))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1Dec_Endpoint_remoteExtensionAddress(dec, &(val)->remoteExtensionAddress))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1Dec_Endpoint_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint(Endpoint *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_Endpoint_aliasAddress(&(val)->aliasAddress);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_Endpoint_callSignalAddress(&(val)->callSignalAddress);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_Endpoint_rasAddress(&(val)->rasAddress);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_EndpointType(&(val)->endpointType);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_Endpoint_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x2) {
        ASN1Free_Endpoint_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_Endpoint_remoteExtensionAddress(&(val)->remoteExtensionAddress);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_Endpoint_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    }
}

static int ASN1CALL ASN1Enc_SupportedPrefix(ASN1encoding_t enc, SupportedPrefix *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_AliasAddress(enc, &(val)->prefix))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedPrefix(ASN1decoding_t dec, SupportedPrefix *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_AliasAddress(dec, &(val)->prefix))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedPrefix(SupportedPrefix *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_AliasAddress(&(val)->prefix);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest(ASN1encoding_t enc, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(7, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_GatekeeperRequest_endpointAlias(enc, &(val)->endpointAlias))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 7, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_GatekeeperRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_GatekeeperRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_GatekeeperRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_GatekeeperRequest_authenticationCapability(ee, &(val)->authenticationCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1Enc_GatekeeperRequest_algorithmOIDs(ee, &(val)->algorithmOIDs))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1Enc_GatekeeperRequest_integrity(ee, &(val)->integrity))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest(ASN1decoding_t dec, GatekeeperRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
    return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_GatekeeperRequest_endpointAlias(dec, &(val)->endpointAlias))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 7, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_authenticationCapability(dd, &(val)->authenticationCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_algorithmOIDs(dd, &(val)->algorithmOIDs))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_GatekeeperRequest_integrity(dd, &(val)->integrity))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest(GatekeeperRequest *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_TransportAddress(&(val)->rasAddress);
    ASN1Free_EndpointType(&(val)->endpointType);
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_GatekeeperRequest_endpointAlias(&(val)->endpointAlias);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_GatekeeperRequest_alternateEndpoints(&(val)->alternateEndpoints);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_GatekeeperRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_GatekeeperRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_GatekeeperRequest_authenticationCapability(&(val)->authenticationCapability);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_GatekeeperRequest_algorithmOIDs(&(val)->algorithmOIDs);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_GatekeeperRequest_integrity(&(val)->integrity);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest(ASN1encoding_t enc, RegistrationRequest *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    ASN1uint32_t l;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    o[1] |= 0x1;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 3, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->discoveryComplete))
    return 0;
    if (!ASN1Enc_RegistrationRequest_callSignalAddress(enc, &(val)->callSignalAddress))
    return 0;
    if (!ASN1Enc_RegistrationRequest_rasAddress(enc, &(val)->rasAddress))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->terminalType))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_RegistrationRequest_terminalAlias(enc, &(val)->terminalAlias))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->gatekeeperIdentifier).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->gatekeeperIdentifier).length, ((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Enc_VendorIdentifier(enc, &(val)->endpointVendor))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_RegistrationRequest_alternateEndpoints(ee, &(val)->alternateEndpoints))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        l = ASN1uint32_uoctets((val)->timeToLive - 1);
        if (!ASN1PEREncBitVal(ee, 2, l - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncBitVal(ee, l * 8, (val)->timeToLive - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_RegistrationRequest_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_RegistrationRequest_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1PEREncBoolean(ee, (val)->keepAlive))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1PEREncBitVal(ee, 7, ((val)->endpointIdentifier).length - 1))
        return 0;
        ASN1PEREncAlignment(ee);
        if (!ASN1PEREncChar16String(ee, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1PEREncBoolean(ee, (val)->willSupplyUUIEs))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest(ASN1decoding_t dec, RegistrationRequest *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->discoveryComplete))
    return 0;
    if (!ASN1Dec_RegistrationRequest_callSignalAddress(dec, &(val)->callSignalAddress))
    return 0;
    if (!ASN1Dec_RegistrationRequest_rasAddress(dec, &(val)->rasAddress))
    return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->terminalType))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_RegistrationRequest_terminalAlias(dec, &(val)->terminalAlias))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->gatekeeperIdentifier).length))
        return 0;
    ((val)->gatekeeperIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->gatekeeperIdentifier).length, &((val)->gatekeeperIdentifier).value, 16))
        return 0;
    }
    if (!ASN1Dec_VendorIdentifier(dec, &(val)->endpointVendor))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationRequest_alternateEndpoints(dd, &(val)->alternateEndpoints))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 2, &l))
        return 0;
        l += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecU32Val(dd, l * 8, &(val)->timeToLive))
        return 0;
        (val)->timeToLive += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationRequest_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RegistrationRequest_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->keepAlive))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU32Val(dd, 7, &((val)->endpointIdentifier).length))
        return 0;
        ((val)->endpointIdentifier).length += 1;
        ASN1PERDecAlignment(dd);
        if (!ASN1PERDecChar16String(dd, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->willSupplyUUIEs))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest(RegistrationRequest *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_RegistrationRequest_callSignalAddress(&(val)->callSignalAddress);
    ASN1Free_RegistrationRequest_rasAddress(&(val)->rasAddress);
    ASN1Free_EndpointType(&(val)->terminalType);
    if ((val)->o[0] & 0x40) {
        ASN1Free_RegistrationRequest_terminalAlias(&(val)->terminalAlias);
    }
    if ((val)->o[0] & 0x20) {
        ASN1char16string_free(&(val)->gatekeeperIdentifier);
    }
    ASN1Free_VendorIdentifier(&(val)->endpointVendor);
    if ((val)->o[1] & 0x80) {
        ASN1Free_RegistrationRequest_alternateEndpoints(&(val)->alternateEndpoints);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_RegistrationRequest_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_RegistrationRequest_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    if ((val)->o[1] & 0x2) {
        ASN1char16string_free(&(val)->endpointIdentifier);
    }
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm(ASN1encoding_t enc, AdmissionConfirm *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[2] |= 0x40;
    o[2] |= 0x20;
    y = ASN1PEREncCheckExtensions(11, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    l = ASN1uint32_uoctets((val)->bandWidth);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bandWidth))
    return 0;
    if (!ASN1Enc_CallModel(enc, &(val)->callModel))
    return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->irrFrequency - 1))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 11, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_AdmissionConfirm_destinationInfo(ee, &(val)->destinationInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_AdmissionConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_AdmissionConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1Enc_AdmissionConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_AdmissionConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x80) {
        if (!ASN1Enc_TransportQOS(ee, &(val)->transportQOS))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x40) {
        if (!ASN1PEREncBoolean(ee, (val)->willRespondToIRR))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x20) {
        if (!ASN1Enc_UUIEsRequested(ee, &(val)->uuiesRequested))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm(ASN1decoding_t dec, AdmissionConfirm *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bandWidth))
    return 0;
    if (!ASN1Dec_CallModel(dec, &(val)->callModel))
    return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->irrFrequency))
        return 0;
    (val)->irrFrequency += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 2);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 11, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_destinationInfo(dd, &(val)->destinationInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AdmissionConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportQOS(dd, &(val)->transportQOS))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->willRespondToIRR))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_UUIEsRequested(dd, &(val)->uuiesRequested))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm(AdmissionConfirm *val)
{
    if (val) {
    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
    if ((val)->o[0] & 0x40) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_AdmissionConfirm_destinationInfo(&(val)->destinationInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_AdmissionConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_EndpointType(&(val)->destinationType);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_AdmissionConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_AdmissionConfirm_alternateEndpoints(&(val)->alternateEndpoints);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_AdmissionConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_AdmissionConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x1) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm(ASN1encoding_t enc, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->callSignalAddress))
    return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 8, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_LocationConfirm_destinationInfo(ee, &(val)->destinationInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_LocationConfirm_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_EndpointType(ee, &(val)->destinationType))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1Enc_LocationConfirm_remoteExtensionAddress(ee, &(val)->remoteExtensionAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1Enc_LocationConfirm_alternateEndpoints(ee, &(val)->alternateEndpoints))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1Enc_LocationConfirm_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1Enc_LocationConfirm_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm(ASN1decoding_t dec, LocationConfirm *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_TransportAddress(dec, &(val)->callSignalAddress))
    return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_destinationInfo(dd, &(val)->destinationInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EndpointType(dd, &(val)->destinationType))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_remoteExtensionAddress(dd, &(val)->remoteExtensionAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_alternateEndpoints(dd, &(val)->alternateEndpoints))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_LocationConfirm_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm(LocationConfirm *val)
{
    if (val) {
    ASN1Free_TransportAddress(&(val)->callSignalAddress);
    ASN1Free_TransportAddress(&(val)->rasAddress);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_LocationConfirm_destinationInfo(&(val)->destinationInfo);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_LocationConfirm_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_EndpointType(&(val)->destinationType);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_LocationConfirm_remoteExtensionAddress(&(val)->remoteExtensionAddress);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_LocationConfirm_alternateEndpoints(&(val)->alternateEndpoints);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_LocationConfirm_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_LocationConfirm_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x1) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse(ASN1encoding_t enc, InfoRequestResponse *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 3, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->requestSeqNum - 1))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->endpointType))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, ((val)->endpointIdentifier).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->endpointIdentifier).length, ((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1Enc_TransportAddress(enc, &(val)->rasAddress))
    return 0;
    if (!ASN1Enc_InfoRequestResponse_callSignalAddress(enc, &(val)->callSignalAddress))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_InfoRequestResponse_endpointAlias(enc, &(val)->endpointAlias))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1Enc_InfoRequestResponse_perCallInfo(enc, &(val)->perCallInfo))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_InfoRequestResponse_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_InfoRequestResponse_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_ICV(ee, &(val)->integrityCheckValue))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1PEREncBoolean(ee, (val)->needResponse))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse(ASN1decoding_t dec, InfoRequestResponse *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requestSeqNum))
    return 0;
    (val)->requestSeqNum += 1;
    if (!ASN1Dec_EndpointType(dec, &(val)->endpointType))
    return 0;
    if (!ASN1PERDecU32Val(dec, 7, &((val)->endpointIdentifier).length))
    return 0;
    ((val)->endpointIdentifier).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->endpointIdentifier).length, &((val)->endpointIdentifier).value, 16))
    return 0;
    if (!ASN1Dec_TransportAddress(dec, &(val)->rasAddress))
    return 0;
    if (!ASN1Dec_InfoRequestResponse_callSignalAddress(dec, &(val)->callSignalAddress))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_InfoRequestResponse_endpointAlias(dec, &(val)->endpointAlias))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_InfoRequestResponse_perCallInfo(dec, &(val)->perCallInfo))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_InfoRequestResponse_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_ICV(dd, &(val)->integrityCheckValue))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->needResponse))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse(InfoRequestResponse *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    ASN1Free_EndpointType(&(val)->endpointType);
    ASN1char16string_free(&(val)->endpointIdentifier);
    ASN1Free_TransportAddress(&(val)->rasAddress);
    ASN1Free_InfoRequestResponse_callSignalAddress(&(val)->callSignalAddress);
    if ((val)->o[0] & 0x40) {
        ASN1Free_InfoRequestResponse_endpointAlias(&(val)->endpointAlias);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_InfoRequestResponse_perCallInfo(&(val)->perCallInfo);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_InfoRequestResponse_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_InfoRequestResponse_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_ICV(&(val)->integrityCheckValue);
    }
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols(PResourcesAvailableIndicate_protocols *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val)
{
    if (val) {
    ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias(PInfoRequestResponse_endpointAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints(PLocationConfirm_alternateEndpoints *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress(PLocationConfirm_remoteExtensionAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo(PLocationConfirm_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo(ASN1encoding_t enc, PLocationConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo(ASN1decoding_t dec, PLocationConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo(PLocationConfirm_destinationInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo(ASN1encoding_t enc, PLocationRequest_sourceInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_sourceInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo(ASN1decoding_t dec, PLocationRequest_sourceInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_sourceInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo(PLocationRequest_sourceInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_sourceInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo(ASN1encoding_t enc, PLocationRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo(ASN1decoding_t dec, PLocationRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo(PLocationRequest_destinationInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints(PAdmissionConfirm_alternateEndpoints *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress(PAdmissionConfirm_remoteExtensionAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo(PAdmissionConfirm_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo(PAdmissionConfirm_destinationInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives(ASN1encoding_t enc, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives(ASN1decoding_t dec, PAdmissionRequest_destAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives(PAdmissionRequest_destAlternatives *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives(PAdmissionRequest_srcAlternatives *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcAlternatives_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo(ASN1encoding_t enc, PAdmissionRequest_srcInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_srcInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo(ASN1decoding_t dec, PAdmissionRequest_srcInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_srcInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo(PAdmissionRequest_srcInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_srcInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo(PAdmissionRequest_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo(ASN1encoding_t enc, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_destinationInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo(ASN1decoding_t dec, PAdmissionRequest_destinationInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_destinationInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo(PAdmissionRequest_destinationInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_destinationInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints(PUnregistrationRequest_alternateEndpoints *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias(PUnregistrationRequest_endpointAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias(PRegistrationRejectReason_duplicateAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias(PRegistrationConfirm_terminalAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints(PRegistrationRequest_alternateEndpoints *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias(ASN1encoding_t enc, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_terminalAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias(ASN1decoding_t dec, PRegistrationRequest_terminalAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_terminalAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias(PRegistrationRequest_terminalAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_terminalAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Enc_Endpoint(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val)
{
    if (!ASN1Dec_Endpoint(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints(PGatekeeperRequest_alternateEndpoints *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val)
{
    if (val) {
    ASN1Free_Endpoint(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias(PGatekeeperRequest_endpointAlias *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_endpointAlias_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token_cryptoEPPwdHash(ASN1encoding_t enc, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Enc_AliasAddress(enc, &(val)->alias))
    return 0;
    l = ASN1uint32_uoctets((val)->timeStamp - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timeStamp - 1))
    return 0;
    if (!ASN1Enc_HASHED(enc, &(val)->token))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token_cryptoEPPwdHash(ASN1decoding_t dec, CryptoH323Token_cryptoEPPwdHash *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_AliasAddress(dec, &(val)->alias))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timeStamp))
    return 0;
    (val)->timeStamp += 1;
    if (!ASN1Dec_HASHED(dec, &(val)->token))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token_cryptoEPPwdHash(CryptoH323Token_cryptoEPPwdHash *val)
{
    if (val) {
    ASN1Free_AliasAddress(&(val)->alias);
    ASN1Free_HASHED(&(val)->token);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo(ASN1encoding_t enc, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo(ASN1decoding_t dec, PEndpoint_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo(PEndpoint_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress(PEndpoint_remoteExtensionAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_remoteExtensionAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress(ASN1encoding_t enc, PEndpoint_aliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_aliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress(ASN1decoding_t dec, PEndpoint_aliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_aliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress(PEndpoint_aliasAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_aliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes(PNonStandardProtocol_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes(PT120OnlyCaps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes(PVoiceCaps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_VoiceCaps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes(ASN1encoding_t enc, PH324Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H324Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes(ASN1decoding_t dec, PH324Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H324Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes(PH324Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H324Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes(ASN1encoding_t enc, PH323Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H323Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes(ASN1decoding_t dec, PH323Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H323Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes(PH323Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H323Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes(ASN1encoding_t enc, PH322Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H322Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes(ASN1decoding_t dec, PH322Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H322Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes(PH322Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H322Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes(ASN1encoding_t enc, PH321Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H321Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes(ASN1decoding_t dec, PH321Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H321Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes(PH321Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H321Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes(ASN1encoding_t enc, PH320Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H320Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes(ASN1decoding_t dec, PH320Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H320Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes(PH320Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H320Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes(ASN1encoding_t enc, PH310Caps_supportedPrefixes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H310Caps_supportedPrefixes_ElmFn);
}

static int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Enc_SupportedPrefix(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes(ASN1decoding_t dec, PH310Caps_supportedPrefixes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H310Caps_supportedPrefixes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val)
{
    if (!ASN1Dec_SupportedPrefix(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes(PH310Caps_supportedPrefixes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H310Caps_supportedPrefixes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val)
{
    if (val) {
    ASN1Free_SupportedPrefix(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatewayInfo_protocol_ElmFn);
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatewayInfo_protocol_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatewayInfo_protocol_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val)
{
    if (val) {
    ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo(PFacility_UUIE_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_sourceAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_sourceAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_sourceAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_Alerting_UUIE_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_Alerting_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_Alerting_UUIE_fastStart(ee, &(val)->fastStart))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Alerting_UUIE_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Alerting_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Alerting_UUIE_fastStart(dd, &(val)->fastStart))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    ASN1Free_EndpointType(&(val)->destinationInfo);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H245Security(&(val)->h245SecurityMode);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_Alerting_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_Alerting_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_Alerting_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_CallProceeding_UUIE_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_CallProceeding_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_CallProceeding_UUIE_fastStart(ee, &(val)->fastStart))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallProceeding_UUIE_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallProceeding_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallProceeding_UUIE_fastStart(dd, &(val)->fastStart))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    ASN1Free_EndpointType(&(val)->destinationInfo);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H245Security(&(val)->h245SecurityMode);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_CallProceeding_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_CallProceeding_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_CallProceeding_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(5, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
        return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 5, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_H245Security(ee, &(val)->h245SecurityMode))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_Connect_UUIE_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_Connect_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_Connect_UUIE_fastStart(ee, &(val)->fastStart))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
        return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 5, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H245Security(dd, &(val)->h245SecurityMode))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Connect_UUIE_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Connect_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Connect_UUIE_fastStart(dd, &(val)->fastStart))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    ASN1Free_EndpointType(&(val)->destinationInfo);
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H245Security(&(val)->h245SecurityMode);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_Connect_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_Connect_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_Connect_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val)
{
    ASN1octet_t o[3];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 3);
    o[1] |= 0x20;
    o[1] |= 0x1;
    o[2] |= 0x80;
    y = ASN1PEREncCheckExtensions(9, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 7, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1Enc_Setup_UUIE_sourceAddress(enc, &(val)->sourceAddress))
        return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->sourceInfo))
    return 0;
    if (o[0] & 0x20) {
    if (!ASN1Enc_Setup_UUIE_destinationAddress(enc, &(val)->destinationAddress))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
        return 0;
    }
    if (o[0] & 0x8) {
    if (!ASN1Enc_Setup_UUIE_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
        return 0;
    }
    if (o[0] & 0x4) {
    if (!ASN1Enc_Setup_UUIE_destExtraCRV(enc, &(val)->destExtraCRV))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1Enc_Setup_UUIE_conferenceGoal(enc, &(val)->conferenceGoal))
    return 0;
    if (o[0] & 0x2) {
    if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
        return 0;
    }
    if (!ASN1Enc_CallType(enc, &(val)->callType))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 9, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_TransportAddress(ee, &(val)->sourceCallSignalAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_Setup_UUIE_h245SecurityCapability(ee, &(val)->h245SecurityCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_Setup_UUIE_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1Enc_Setup_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_Setup_UUIE_fastStart(ee, &(val)->fastStart))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1PEREncBoolean(ee, (val)->mediaWaitForConnect))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[2] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->canOverlapSend))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_Setup_UUIE_sourceAddress(dec, &(val)->sourceAddress))
        return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->sourceInfo))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_Setup_UUIE_destinationAddress(dec, &(val)->destinationAddress))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_Setup_UUIE_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_Setup_UUIE_destExtraCRV(dec, &(val)->destExtraCRV))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
    return 0;
    if (!ASN1Dec_Setup_UUIE_conferenceGoal(dec, &(val)->conferenceGoal))
    return 0;
    if ((val)->o[0] & 0x2) {
    if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
        return 0;
    }
    if (!ASN1Dec_CallType(dec, &(val)->callType))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 2);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 9, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportAddress(dd, &(val)->sourceCallSignalAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Setup_UUIE_h245SecurityCapability(dd, &(val)->h245SecurityCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Setup_UUIE_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Setup_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Setup_UUIE_fastStart(dd, &(val)->fastStart))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->mediaWaitForConnect))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->canOverlapSend))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_Setup_UUIE_sourceAddress(&(val)->sourceAddress);
    }
    ASN1Free_EndpointType(&(val)->sourceInfo);
    if ((val)->o[0] & 0x20) {
        ASN1Free_Setup_UUIE_destinationAddress(&(val)->destinationAddress);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_Setup_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_Setup_UUIE_destExtraCRV(&(val)->destExtraCRV);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_TransportAddress(&(val)->sourceCallSignalAddress);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_Setup_UUIE_h245SecurityCapability(&(val)->h245SecurityCapability);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_Setup_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_Setup_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_Setup_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 3, o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->alternativeAddress))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1Enc_Facility_UUIE_alternativeAliasAddress(enc, &(val)->alternativeAliasAddress))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
        return 0;
    }
    if (!ASN1Enc_FacilityReason(enc, &(val)->reason))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_CallIdentifier(ee, &(val)->callIdentifier))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1Enc_Facility_UUIE_destExtraCallInfo(ee, &(val)->destExtraCallInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_Facility_UUIE_tokens(ee, &(val)->tokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1Enc_Facility_UUIE_cryptoTokens(ee, &(val)->cryptoTokens))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1Enc_Facility_UUIE_conferences(ee, &(val)->conferences))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_TransportAddress(ee, &(val)->h245Address))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1Enc_Facility_UUIE_fastStart(ee, &(val)->fastStart))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->alternativeAddress))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_Facility_UUIE_alternativeAliasAddress(dec, &(val)->alternativeAliasAddress))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
        return 0;
    }
    if (!ASN1Dec_FacilityReason(dec, &(val)->reason))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CallIdentifier(dd, &(val)->callIdentifier))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Facility_UUIE_destExtraCallInfo(dd, &(val)->destExtraCallInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Facility_UUIE_tokens(dd, &(val)->tokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Facility_UUIE_cryptoTokens(dd, &(val)->cryptoTokens))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Facility_UUIE_conferences(dd, &(val)->conferences))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportAddress(dd, &(val)->h245Address))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_Facility_UUIE_fastStart(dd, &(val)->fastStart))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->alternativeAddress);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_Facility_UUIE_alternativeAliasAddress(&(val)->alternativeAliasAddress);
    }
    if ((val)->o[0] & 0x20) {
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callIdentifier);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_Facility_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_Facility_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[1] & 0x8) {
        ASN1Free_Facility_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[1] & 0x4) {
        ASN1Free_Facility_UUIE_conferences(&(val)->conferences);
    }
    if ((val)->o[1] & 0x2) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    if ((val)->o[1] & 0x1) {
        ASN1Free_Facility_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_ConferenceList(ASN1encoding_t enc, ConferenceList *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_AliasAddress(enc, &(val)->conferenceAlias))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceList(ASN1decoding_t dec, ConferenceList *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_AliasAddress(dec, &(val)->conferenceAlias))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceList(ConferenceList *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_AliasAddress(&(val)->conferenceAlias);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE(ASN1encoding_t enc, Progress_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
        return 0;
    }
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callIdentifier))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_H245Security(enc, &(val)->h245SecurityMode))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_Progress_UUIE_tokens(enc, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_Progress_UUIE_cryptoTokens(enc, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_Progress_UUIE_fastStart(enc, &(val)->fastStart))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE(ASN1decoding_t dec, Progress_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
        return 0;
    }
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callIdentifier))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_H245Security(dec, &(val)->h245SecurityMode))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_Progress_UUIE_tokens(dec, &(val)->tokens))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_Progress_UUIE_cryptoTokens(dec, &(val)->cryptoTokens))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_Progress_UUIE_fastStart(dec, &(val)->fastStart))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE(Progress_UUIE *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    ASN1Free_EndpointType(&(val)->destinationInfo);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportAddress(&(val)->h245Address);
    }
    ASN1Free_CallIdentifier(&(val)->callIdentifier);
    if ((val)->o[0] & 0x40) {
        ASN1Free_H245Security(&(val)->h245SecurityMode);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_Progress_UUIE_tokens(&(val)->tokens);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_Progress_UUIE_cryptoTokens(&(val)->cryptoTokens);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_Progress_UUIE_fastStart(&(val)->fastStart);
    }
    }
}

static int ASN1CALL ASN1Enc_CryptoH323Token(ASN1encoding_t enc, CryptoH323Token *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_CryptoH323Token_cryptoEPPwdHash(enc, &(val)->u.cryptoEPPwdHash))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_CryptoH323Token_cryptoGKPwdHash(enc, &(val)->u.cryptoGKPwdHash))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoEPPwdEncr))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_ENCRYPTED(enc, &(val)->u.cryptoGKPwdEncr))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoEPCert))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_SIGNED_EncodedPwdCertToken(enc, &(val)->u.cryptoGKCert))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_SIGNED_EncodedFastStartToken(enc, &(val)->u.cryptoFastStart))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_CryptoToken(enc, &(val)->u.nestedcryptoToken))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CryptoH323Token(ASN1decoding_t dec, CryptoH323Token *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_CryptoH323Token_cryptoEPPwdHash(dec, &(val)->u.cryptoEPPwdHash))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_CryptoH323Token_cryptoGKPwdHash(dec, &(val)->u.cryptoGKPwdHash))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoEPPwdEncr))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_ENCRYPTED(dec, &(val)->u.cryptoGKPwdEncr))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoEPCert))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_SIGNED_EncodedPwdCertToken(dec, &(val)->u.cryptoGKCert))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_SIGNED_EncodedFastStartToken(dec, &(val)->u.cryptoFastStart))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_CryptoToken(dec, &(val)->u.nestedcryptoToken))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CryptoH323Token(CryptoH323Token *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_CryptoH323Token_cryptoEPPwdHash(&(val)->u.cryptoEPPwdHash);
        break;
    case 2:
        ASN1Free_CryptoH323Token_cryptoGKPwdHash(&(val)->u.cryptoGKPwdHash);
        break;
    case 3:
        ASN1Free_ENCRYPTED(&(val)->u.cryptoEPPwdEncr);
        break;
    case 4:
        ASN1Free_ENCRYPTED(&(val)->u.cryptoGKPwdEncr);
        break;
    case 5:
        ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoEPCert);
        break;
    case 6:
        ASN1Free_SIGNED_EncodedPwdCertToken(&(val)->u.cryptoGKCert);
        break;
    case 7:
        ASN1Free_SIGNED_EncodedFastStartToken(&(val)->u.cryptoFastStart);
        break;
    case 8:
        ASN1Free_CryptoToken(&(val)->u.nestedcryptoToken);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_RasMessage(ASN1encoding_t enc, RasMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 25))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_GatekeeperRequest(enc, &(val)->u.gatekeeperRequest))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_GatekeeperConfirm(enc, &(val)->u.gatekeeperConfirm))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_GatekeeperReject(enc, &(val)->u.gatekeeperReject))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_RegistrationRequest(enc, &(val)->u.registrationRequest))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_RegistrationConfirm(enc, &(val)->u.registrationConfirm))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_RegistrationReject(enc, &(val)->u.registrationReject))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_UnregistrationRequest(enc, &(val)->u.unregistrationRequest))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_UnregistrationConfirm(enc, &(val)->u.unregistrationConfirm))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_UnregistrationReject(enc, &(val)->u.unregistrationReject))
        return 0;
    break;
    case 10:
    if (!ASN1Enc_AdmissionRequest(enc, &(val)->u.admissionRequest))
        return 0;
    break;
    case 11:
    if (!ASN1Enc_AdmissionConfirm(enc, &(val)->u.admissionConfirm))
        return 0;
    break;
    case 12:
    if (!ASN1Enc_AdmissionReject(enc, &(val)->u.admissionReject))
        return 0;
    break;
    case 13:
    if (!ASN1Enc_BandwidthRequest(enc, &(val)->u.bandwidthRequest))
        return 0;
    break;
    case 14:
    if (!ASN1Enc_BandwidthConfirm(enc, &(val)->u.bandwidthConfirm))
        return 0;
    break;
    case 15:
    if (!ASN1Enc_BandwidthReject(enc, &(val)->u.bandwidthReject))
        return 0;
    break;
    case 16:
    if (!ASN1Enc_DisengageRequest(enc, &(val)->u.disengageRequest))
        return 0;
    break;
    case 17:
    if (!ASN1Enc_DisengageConfirm(enc, &(val)->u.disengageConfirm))
        return 0;
    break;
    case 18:
    if (!ASN1Enc_DisengageReject(enc, &(val)->u.disengageReject))
        return 0;
    break;
    case 19:
    if (!ASN1Enc_LocationRequest(enc, &(val)->u.locationRequest))
        return 0;
    break;
    case 20:
    if (!ASN1Enc_LocationConfirm(enc, &(val)->u.locationConfirm))
        return 0;
    break;
    case 21:
    if (!ASN1Enc_LocationReject(enc, &(val)->u.locationReject))
        return 0;
    break;
    case 22:
    if (!ASN1Enc_InfoRequest(enc, &(val)->u.infoRequest))
        return 0;
    break;
    case 23:
    if (!ASN1Enc_InfoRequestResponse(enc, &(val)->u.infoRequestResponse))
        return 0;
    break;
    case 24:
    if (!ASN1Enc_H225NonStandardMessage(enc, &(val)->u.nonStandardMessage))
        return 0;
    break;
    case 25:
    if (!ASN1Enc_UnknownMessageResponse(enc, &(val)->u.unknownMessageResponse))
        return 0;
    break;
    case 26:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RequestInProgress(ee, &(val)->u.requestInProgress))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 27:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ResourcesAvailableIndicate(ee, &(val)->u.resourcesAvailableIndicate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 28:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ResourcesAvailableConfirm(ee, &(val)->u.resourcesAvailableConfirm))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 29:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_InfoRequestAck(ee, &(val)->u.infoRequestAck))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 30:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_InfoRequestNak(ee, &(val)->u.infoRequestNak))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RasMessage(ASN1decoding_t dec, RasMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 25))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_GatekeeperRequest(dec, &(val)->u.gatekeeperRequest))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_GatekeeperConfirm(dec, &(val)->u.gatekeeperConfirm))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_GatekeeperReject(dec, &(val)->u.gatekeeperReject))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_RegistrationRequest(dec, &(val)->u.registrationRequest))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_RegistrationConfirm(dec, &(val)->u.registrationConfirm))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_RegistrationReject(dec, &(val)->u.registrationReject))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_UnregistrationRequest(dec, &(val)->u.unregistrationRequest))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_UnregistrationConfirm(dec, &(val)->u.unregistrationConfirm))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_UnregistrationReject(dec, &(val)->u.unregistrationReject))
        return 0;
    break;
    case 10:
    if (!ASN1Dec_AdmissionRequest(dec, &(val)->u.admissionRequest))
        return 0;
    break;
    case 11:
    if (!ASN1Dec_AdmissionConfirm(dec, &(val)->u.admissionConfirm))
        return 0;
    break;
    case 12:
    if (!ASN1Dec_AdmissionReject(dec, &(val)->u.admissionReject))
        return 0;
    break;
    case 13:
    if (!ASN1Dec_BandwidthRequest(dec, &(val)->u.bandwidthRequest))
        return 0;
    break;
    case 14:
    if (!ASN1Dec_BandwidthConfirm(dec, &(val)->u.bandwidthConfirm))
        return 0;
    break;
    case 15:
    if (!ASN1Dec_BandwidthReject(dec, &(val)->u.bandwidthReject))
        return 0;
    break;
    case 16:
    if (!ASN1Dec_DisengageRequest(dec, &(val)->u.disengageRequest))
        return 0;
    break;
    case 17:
    if (!ASN1Dec_DisengageConfirm(dec, &(val)->u.disengageConfirm))
        return 0;
    break;
    case 18:
    if (!ASN1Dec_DisengageReject(dec, &(val)->u.disengageReject))
        return 0;
    break;
    case 19:
    if (!ASN1Dec_LocationRequest(dec, &(val)->u.locationRequest))
        return 0;
    break;
    case 20:
    if (!ASN1Dec_LocationConfirm(dec, &(val)->u.locationConfirm))
        return 0;
    break;
    case 21:
    if (!ASN1Dec_LocationReject(dec, &(val)->u.locationReject))
        return 0;
    break;
    case 22:
    if (!ASN1Dec_InfoRequest(dec, &(val)->u.infoRequest))
        return 0;
    break;
    case 23:
    if (!ASN1Dec_InfoRequestResponse(dec, &(val)->u.infoRequestResponse))
        return 0;
    break;
    case 24:
    if (!ASN1Dec_H225NonStandardMessage(dec, &(val)->u.nonStandardMessage))
        return 0;
    break;
    case 25:
    if (!ASN1Dec_UnknownMessageResponse(dec, &(val)->u.unknownMessageResponse))
        return 0;
    break;
    case 26:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RequestInProgress(dd, &(val)->u.requestInProgress))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 27:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ResourcesAvailableIndicate(dd, &(val)->u.resourcesAvailableIndicate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 28:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ResourcesAvailableConfirm(dd, &(val)->u.resourcesAvailableConfirm))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 29:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_InfoRequestAck(dd, &(val)->u.infoRequestAck))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 30:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_InfoRequestNak(dd, &(val)->u.infoRequestNak))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RasMessage(RasMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_GatekeeperRequest(&(val)->u.gatekeeperRequest);
        break;
    case 2:
        ASN1Free_GatekeeperConfirm(&(val)->u.gatekeeperConfirm);
        break;
    case 3:
        ASN1Free_GatekeeperReject(&(val)->u.gatekeeperReject);
        break;
    case 4:
        ASN1Free_RegistrationRequest(&(val)->u.registrationRequest);
        break;
    case 5:
        ASN1Free_RegistrationConfirm(&(val)->u.registrationConfirm);
        break;
    case 6:
        ASN1Free_RegistrationReject(&(val)->u.registrationReject);
        break;
    case 7:
        ASN1Free_UnregistrationRequest(&(val)->u.unregistrationRequest);
        break;
    case 8:
        ASN1Free_UnregistrationConfirm(&(val)->u.unregistrationConfirm);
        break;
    case 9:
        ASN1Free_UnregistrationReject(&(val)->u.unregistrationReject);
        break;
    case 10:
        ASN1Free_AdmissionRequest(&(val)->u.admissionRequest);
        break;
    case 11:
        ASN1Free_AdmissionConfirm(&(val)->u.admissionConfirm);
        break;
    case 12:
        ASN1Free_AdmissionReject(&(val)->u.admissionReject);
        break;
    case 13:
        ASN1Free_BandwidthRequest(&(val)->u.bandwidthRequest);
        break;
    case 14:
        ASN1Free_BandwidthConfirm(&(val)->u.bandwidthConfirm);
        break;
    case 15:
        ASN1Free_BandwidthReject(&(val)->u.bandwidthReject);
        break;
    case 16:
        ASN1Free_DisengageRequest(&(val)->u.disengageRequest);
        break;
    case 17:
        ASN1Free_DisengageConfirm(&(val)->u.disengageConfirm);
        break;
    case 18:
        ASN1Free_DisengageReject(&(val)->u.disengageReject);
        break;
    case 19:
        ASN1Free_LocationRequest(&(val)->u.locationRequest);
        break;
    case 20:
        ASN1Free_LocationConfirm(&(val)->u.locationConfirm);
        break;
    case 21:
        ASN1Free_LocationReject(&(val)->u.locationReject);
        break;
    case 22:
        ASN1Free_InfoRequest(&(val)->u.infoRequest);
        break;
    case 23:
        ASN1Free_InfoRequestResponse(&(val)->u.infoRequestResponse);
        break;
    case 24:
        ASN1Free_H225NonStandardMessage(&(val)->u.nonStandardMessage);
        break;
    case 25:
        ASN1Free_UnknownMessageResponse(&(val)->u.unknownMessageResponse);
        break;
    case 26:
        ASN1Free_RequestInProgress(&(val)->u.requestInProgress);
        break;
    case 27:
        ASN1Free_ResourcesAvailableIndicate(&(val)->u.resourcesAvailableIndicate);
        break;
    case 28:
        ASN1Free_ResourcesAvailableConfirm(&(val)->u.resourcesAvailableConfirm);
        break;
    case 29:
        ASN1Free_InfoRequestAck(&(val)->u.infoRequestAck);
        break;
    case 30:
        ASN1Free_InfoRequestNak(&(val)->u.infoRequestNak);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens(PResourcesAvailableConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens(PResourcesAvailableIndicate_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens(ASN1encoding_t enc, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestInProgress_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens(ASN1decoding_t dec, PRequestInProgress_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestInProgress_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens(PRequestInProgress_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestInProgress_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens(PUnknownMessageResponse_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens(PH225NonStandardMessage_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens(PInfoRequestNak_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestNak_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens(PInfoRequestAck_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestAck_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens(PInfoRequestResponse_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens(ASN1encoding_t enc, PInfoRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens(ASN1decoding_t dec, PInfoRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens(PInfoRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens(ASN1encoding_t enc, PDisengageReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens(ASN1decoding_t dec, PDisengageReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens(PDisengageReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens(PDisengageConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens(ASN1encoding_t enc, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisengageRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens(ASN1decoding_t dec, PDisengageRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisengageRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens(PDisengageRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisengageRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens(ASN1encoding_t enc, PLocationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens(ASN1decoding_t dec, PLocationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens(PLocationReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens(ASN1encoding_t enc, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens(ASN1decoding_t dec, PLocationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens(PLocationConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens(ASN1encoding_t enc, PLocationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_LocationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens(ASN1decoding_t dec, PLocationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_LocationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens(PLocationRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_LocationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens(ASN1encoding_t enc, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens(ASN1decoding_t dec, PBandwidthReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens(PBandwidthReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens(PBandwidthConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens(PBandwidthRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_BandwidthRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens(ASN1encoding_t enc, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens(ASN1decoding_t dec, PAdmissionReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens(PAdmissionReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens(PAdmissionConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens(PAdmissionRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_AdmissionRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens(PUnregistrationReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens(PUnregistrationConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens(PUnregistrationRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens(ASN1encoding_t enc, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens(ASN1decoding_t dec, PRegistrationReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens(PRegistrationReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens(PRegistrationConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens(PRegistrationRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RegistrationRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens(PGatekeeperReject_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperReject_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens(PGatekeeperConfirm_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens(PGatekeeperRequest_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens(ASN1encoding_t enc, PEndpoint_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Endpoint_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens(ASN1decoding_t dec, PEndpoint_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Endpoint_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens(PEndpoint_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Endpoint_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens(PProgress_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Progress_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences(ASN1encoding_t enc, PFacility_UUIE_conferences *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_conferences_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val)
{
    if (!ASN1Enc_ConferenceList(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences(ASN1decoding_t dec, PFacility_UUIE_conferences *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_conferences_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val)
{
    if (!ASN1Dec_ConferenceList(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences(PFacility_UUIE_conferences *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_conferences_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val)
{
    if (val) {
    ASN1Free_ConferenceList(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens(PFacility_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens(PSetup_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens(PConnect_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Connect_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens(PCallProceeding_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn);
}

static int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Enc_CryptoH323Token(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val)
{
    if (!ASN1Dec_CryptoH323Token(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens(PAlerting_UUIE_cryptoTokens *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val)
{
    if (val) {
    ASN1Free_CryptoH323Token(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_Setup_UUIE(enc, &(val)->u.setup))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_CallProceeding_UUIE(enc, &(val)->u.callProceeding))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_Connect_UUIE(enc, &(val)->u.connect))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_Alerting_UUIE(enc, &(val)->u.alerting))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_Information_UUIE(enc, &(val)->u.information))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_ReleaseComplete_UUIE(enc, &(val)->u.releaseComplete))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_Facility_UUIE(enc, &(val)->u.facility))
        return 0;
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_Progress_UUIE(ee, &(val)->u.progress))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_Setup_UUIE(dec, &(val)->u.setup))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_CallProceeding_UUIE(dec, &(val)->u.callProceeding))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_Connect_UUIE(dec, &(val)->u.connect))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_Alerting_UUIE(dec, &(val)->u.alerting))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_Information_UUIE(dec, &(val)->u.information))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_ReleaseComplete_UUIE(dec, &(val)->u.releaseComplete))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_Facility_UUIE(dec, &(val)->u.facility))
        return 0;
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_Progress_UUIE(dd, &(val)->u.progress))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_Setup_UUIE(&(val)->u.setup);
        break;
    case 2:
        ASN1Free_CallProceeding_UUIE(&(val)->u.callProceeding);
        break;
    case 3:
        ASN1Free_Connect_UUIE(&(val)->u.connect);
        break;
    case 4:
        ASN1Free_Alerting_UUIE(&(val)->u.alerting);
        break;
    case 5:
        ASN1Free_Information_UUIE(&(val)->u.information);
        break;
    case 6:
        ASN1Free_ReleaseComplete_UUIE(&(val)->u.releaseComplete);
        break;
    case 7:
        ASN1Free_Facility_UUIE(&(val)->u.facility);
        break;
    case 8:
        ASN1Free_Progress_UUIE(&(val)->u.progress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (!ASN1Enc_H323_UU_PDU_h323_message_body(enc, &(val)->h323_message_body))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1Enc_H323_UU_PDU_h4501SupplementaryService(ee, &(val)->h4501SupplementaryService))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncBoolean(ee, (val)->h245Tunneling))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1Enc_H323_UU_PDU_h245Control(ee, &(val)->h245Control))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1Enc_H323_UU_PDU_nonStandardControl(ee, &(val)->nonStandardControl))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_H323_UU_PDU_h323_message_body(dec, &(val)->h323_message_body))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H323_UU_PDU_h4501SupplementaryService(dd, &(val)->h4501SupplementaryService))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->h245Tunneling))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H323_UU_PDU_h245Control(dd, &(val)->h245Control))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H323_UU_PDU_nonStandardControl(dd, &(val)->nonStandardControl))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val)
{
    if (val) {
    ASN1Free_H323_UU_PDU_h323_message_body(&(val)->h323_message_body);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H225NonStandardParameter(&(val)->nonStandardData);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_H323_UU_PDU_h4501SupplementaryService(&(val)->h4501SupplementaryService);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_H323_UU_PDU_h245Control(&(val)->h245Control);
    }
    if ((val)->o[1] & 0x10) {
        ASN1Free_H323_UU_PDU_nonStandardControl(&(val)->nonStandardControl);
    }
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1encoding_t enc, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323pdu))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sent))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(ASN1decoding_t dec, InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323pdu))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sent))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(InfoRequestResponse_perCallInfo_Seq_pdu_Seq *val)
{
    if (val) {
    ASN1Free_H323_UU_PDU(&(val)->h323pdu);
    }
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
}

static int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (!ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu(PInfoRequestResponse_perCallInfo_Seq_pdu *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn);
    }
}

static void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val)
{
    if (val) {
    ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_Seq(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323_uu_pdu))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H323_UserInformation_user_data(enc, &(val)->user_data))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323_uu_pdu))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H323_UserInformation_user_data(dec, &(val)->user_data))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val)
{
    if (val) {
    ASN1Free_H323_UU_PDU(&(val)->h323_uu_pdu);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H323_UserInformation_user_data(&(val)->user_data);
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\asn\h4503pp.c ===
#include <windows.h>
#include "h4503pp.h"

#pragma warning ( disable: 4133 )

ASN1module_t H4503PP_Module = NULL;

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_Reject_problem(ASN1encoding_t enc, Reject_problem *val);
static int ASN1CALL ASN1Enc_EntityType(ASN1encoding_t enc, EntityType *val);
static int ASN1CALL ASN1Enc_InterpretationApdu(ASN1encoding_t enc, InterpretationApdu *val);
static int ASN1CALL ASN1Enc_ServiceApdus(ASN1encoding_t enc, ServiceApdus *val);
static int ASN1CALL ASN1Enc_Reject(ASN1encoding_t enc, Reject *val);
static int ASN1CALL ASN1Enc_EXTENSION(ASN1encoding_t enc, EXTENSION *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnRes(ASN1encoding_t enc, GroupIndicationOnRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffRes(ASN1encoding_t enc, GroupIndicationOffRes *val);
static int ASN1CALL ASN1Enc_PickupRes(ASN1encoding_t enc, PickupRes *val);
static int ASN1CALL ASN1Enc_PickExeRes(ASN1encoding_t enc, PickExeRes *val);
static int ASN1CALL ASN1Enc_UserSpecifiedSubaddress(ASN1encoding_t enc, UserSpecifiedSubaddress *val);
static int ASN1CALL ASN1Enc_CODE(ASN1encoding_t enc, CODE *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val);
static int ASN1CALL ASN1Enc_ReturnResult_result(ASN1encoding_t enc, ReturnResult_result *val);
static int ASN1CALL ASN1Enc_Invoke(ASN1encoding_t enc, Invoke *val);
static int ASN1CALL ASN1Enc_ReturnResult(ASN1encoding_t enc, ReturnResult *val);
static int ASN1CALL ASN1Enc_ReturnError(ASN1encoding_t enc, ReturnError *val);
static int ASN1CALL ASN1Enc_ExtensionSeq(ASN1encoding_t enc, PExtensionSeq *val);
static int ASN1CALL ASN1Enc_PickrequRes(ASN1encoding_t enc, PickrequRes *val);
static int ASN1CALL ASN1Enc_PartySubaddress(ASN1encoding_t enc, PartySubaddress *val);
static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_CTActiveArg_argumentExtension(ASN1encoding_t enc, CTActiveArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTCompleteArg_argumentExtension(ASN1encoding_t enc, CTCompleteArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_SubaddressTransferArg_argumentExtension(ASN1encoding_t enc, SubaddressTransferArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTUpdateArg_argumentExtension(ASN1encoding_t enc, CTUpdateArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTIdentifyRes_resultExtension(ASN1encoding_t enc, CTIdentifyRes_resultExtension *val);
static int ASN1CALL ASN1Enc_CTSetupArg_argumentExtension(ASN1encoding_t enc, CTSetupArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_CTInitiateArg_argumentExtension(ASN1encoding_t enc, CTInitiateArg_argumentExtension *val);
static int ASN1CALL ASN1Enc_IntResult_extension(ASN1encoding_t enc, IntResult_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument_extension(ASN1encoding_t enc, DivertingLegInformation4Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument_extension(ASN1encoding_t enc, DivertingLegInformation3Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument_extension(ASN1encoding_t enc, DivertingLegInformation2Argument_extension *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument_extension(ASN1encoding_t enc, DivertingLegInformation1Argument_extension *val);
static int ASN1CALL ASN1Enc_CallReroutingArgument_extension(ASN1encoding_t enc, CallReroutingArgument_extension *val);
static int ASN1CALL ASN1Enc_CheckRestrictionArgument_extension(ASN1encoding_t enc, CheckRestrictionArgument_extension *val);
static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument_extension(ASN1encoding_t enc, InterrogateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument_extension(ASN1encoding_t enc, DeactivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_ActivateDiversionQArgument_extension(ASN1encoding_t enc, ActivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Enc_H4503ROS(ASN1encoding_t enc, H4503ROS *val);
static int ASN1CALL ASN1Enc_DummyArg(ASN1encoding_t enc, DummyArg *val);
static int ASN1CALL ASN1Enc_DummyRes(ASN1encoding_t enc, DummyRes *val);
static int ASN1CALL ASN1Enc_SubaddressTransferArg(ASN1encoding_t enc, SubaddressTransferArg *val);
static int ASN1CALL ASN1Enc_MixedExtension(ASN1encoding_t enc, MixedExtension *val);
static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val);
static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg(ASN1encoding_t enc, PCpNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickExeRes_extensionRes(ASN1encoding_t enc, PPickExeRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickExeArg_extensionArg(ASN1encoding_t enc, PPickExeArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickupRes_extensionRes(ASN1encoding_t enc, PPickupRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickupArg_extensionArg(ASN1encoding_t enc, PPickupArg_extensionArg *val);
static int ASN1CALL ASN1Enc_PickrequRes_extensionRes(ASN1encoding_t enc, PPickrequRes_extensionRes *val);
static int ASN1CALL ASN1Enc_PickrequArg_extensionArg(ASN1encoding_t enc, PPickrequArg_extensionArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes(ASN1encoding_t enc, PCpSetupRes_extensionRes *val);
static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg(ASN1encoding_t enc, PCpSetupArg_extensionArg *val);
static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes(ASN1encoding_t enc, PCpRequestRes_extensionRes *val);
static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg(ASN1encoding_t enc, PCpRequestArg_extensionArg *val);
static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus(ASN1encoding_t enc, PServiceApdus_rosApdus *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress(ASN1encoding_t enc, PEndpointAddress_destinationAddress *val);
static int ASN1CALL ASN1Enc_AddressInformation(ASN1encoding_t enc, AddressInformation *val);
static int ASN1CALL ASN1Enc_EndpointAddress(ASN1encoding_t enc, EndpointAddress *val);
static int ASN1CALL ASN1Enc_NetworkFacilityExtension(ASN1encoding_t enc, NetworkFacilityExtension *val);
static int ASN1CALL ASN1Enc_ActivateDiversionQArgument(ASN1encoding_t enc, ActivateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument(ASN1encoding_t enc, DeactivateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument(ASN1encoding_t enc, InterrogateDiversionQArgument *val);
static int ASN1CALL ASN1Enc_CheckRestrictionArgument(ASN1encoding_t enc, CheckRestrictionArgument *val);
static int ASN1CALL ASN1Enc_CallReroutingArgument(ASN1encoding_t enc, CallReroutingArgument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument(ASN1encoding_t enc, DivertingLegInformation1Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument(ASN1encoding_t enc, DivertingLegInformation2Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument(ASN1encoding_t enc, DivertingLegInformation3Argument *val);
static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument(ASN1encoding_t enc, DivertingLegInformation4Argument *val);
static int ASN1CALL ASN1Enc_IntResult(ASN1encoding_t enc, IntResult *val);
static int ASN1CALL ASN1Enc_CTInitiateArg(ASN1encoding_t enc, CTInitiateArg *val);
static int ASN1CALL ASN1Enc_CTSetupArg(ASN1encoding_t enc, CTSetupArg *val);
static int ASN1CALL ASN1Enc_CTIdentifyRes(ASN1encoding_t enc, CTIdentifyRes *val);
static int ASN1CALL ASN1Enc_CTUpdateArg(ASN1encoding_t enc, CTUpdateArg *val);
static int ASN1CALL ASN1Enc_CTCompleteArg(ASN1encoding_t enc, CTCompleteArg *val);
static int ASN1CALL ASN1Enc_CTActiveArg(ASN1encoding_t enc, CTActiveArg *val);
static int ASN1CALL ASN1Enc_CpRequestArg(ASN1encoding_t enc, CpRequestArg *val);
static int ASN1CALL ASN1Enc_CpRequestRes(ASN1encoding_t enc, CpRequestRes *val);
static int ASN1CALL ASN1Enc_CpSetupArg(ASN1encoding_t enc, CpSetupArg *val);
static int ASN1CALL ASN1Enc_CpSetupRes(ASN1encoding_t enc, CpSetupRes *val);
static int ASN1CALL ASN1Enc_GroupIndicationOnArg(ASN1encoding_t enc, GroupIndicationOnArg *val);
static int ASN1CALL ASN1Enc_GroupIndicationOffArg(ASN1encoding_t enc, GroupIndicationOffArg *val);
static int ASN1CALL ASN1Enc_PickrequArg(ASN1encoding_t enc, PickrequArg *val);
static int ASN1CALL ASN1Enc_PickupArg(ASN1encoding_t enc, PickupArg *val);
static int ASN1CALL ASN1Enc_PickExeArg(ASN1encoding_t enc, PickExeArg *val);
static int ASN1CALL ASN1Enc_CpNotifyArg(ASN1encoding_t enc, CpNotifyArg *val);
static int ASN1CALL ASN1Enc_CpickupNotifyArg(ASN1encoding_t enc, CpickupNotifyArg *val);
static int ASN1CALL ASN1Enc_H4501SupplementaryService(ASN1encoding_t enc, H4501SupplementaryService *val);
static int ASN1CALL ASN1Enc_IntResultList(ASN1encoding_t enc, IntResultList *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_Reject_problem(ASN1decoding_t dec, Reject_problem *val);
static int ASN1CALL ASN1Dec_EntityType(ASN1decoding_t dec, EntityType *val);
static int ASN1CALL ASN1Dec_InterpretationApdu(ASN1decoding_t dec, InterpretationApdu *val);
static int ASN1CALL ASN1Dec_ServiceApdus(ASN1decoding_t dec, ServiceApdus *val);
static int ASN1CALL ASN1Dec_Reject(ASN1decoding_t dec, Reject *val);
static int ASN1CALL ASN1Dec_EXTENSION(ASN1decoding_t dec, EXTENSION *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnRes(ASN1decoding_t dec, GroupIndicationOnRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffRes(ASN1decoding_t dec, GroupIndicationOffRes *val);
static int ASN1CALL ASN1Dec_PickupRes(ASN1decoding_t dec, PickupRes *val);
static int ASN1CALL ASN1Dec_PickExeRes(ASN1decoding_t dec, PickExeRes *val);
static int ASN1CALL ASN1Dec_UserSpecifiedSubaddress(ASN1decoding_t dec, UserSpecifiedSubaddress *val);
static int ASN1CALL ASN1Dec_CODE(ASN1decoding_t dec, CODE *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val);
static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val);
static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val);
static int ASN1CALL ASN1Dec_ReturnResult_result(ASN1decoding_t dec, ReturnResult_result *val);
static int ASN1CALL ASN1Dec_Invoke(ASN1decoding_t dec, Invoke *val);
static int ASN1CALL ASN1Dec_ReturnResult(ASN1decoding_t dec, ReturnResult *val);
static int ASN1CALL ASN1Dec_ReturnError(ASN1decoding_t dec, ReturnError *val);
static int ASN1CALL ASN1Dec_ExtensionSeq(ASN1decoding_t dec, PExtensionSeq *val);
static int ASN1CALL ASN1Dec_PickrequRes(ASN1decoding_t dec, PickrequRes *val);
static int ASN1CALL ASN1Dec_PartySubaddress(ASN1decoding_t dec, PartySubaddress *val);
static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_CTActiveArg_argumentExtension(ASN1decoding_t dec, CTActiveArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTCompleteArg_argumentExtension(ASN1decoding_t dec, CTCompleteArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_SubaddressTransferArg_argumentExtension(ASN1decoding_t dec, SubaddressTransferArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTUpdateArg_argumentExtension(ASN1decoding_t dec, CTUpdateArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTIdentifyRes_resultExtension(ASN1decoding_t dec, CTIdentifyRes_resultExtension *val);
static int ASN1CALL ASN1Dec_CTSetupArg_argumentExtension(ASN1decoding_t dec, CTSetupArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_CTInitiateArg_argumentExtension(ASN1decoding_t dec, CTInitiateArg_argumentExtension *val);
static int ASN1CALL ASN1Dec_IntResult_extension(ASN1decoding_t dec, IntResult_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument_extension(ASN1decoding_t dec, DivertingLegInformation4Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument_extension(ASN1decoding_t dec, DivertingLegInformation3Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument_extension(ASN1decoding_t dec, DivertingLegInformation2Argument_extension *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument_extension(ASN1decoding_t dec, DivertingLegInformation1Argument_extension *val);
static int ASN1CALL ASN1Dec_CallReroutingArgument_extension(ASN1decoding_t dec, CallReroutingArgument_extension *val);
static int ASN1CALL ASN1Dec_CheckRestrictionArgument_extension(ASN1decoding_t dec, CheckRestrictionArgument_extension *val);
static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument_extension(ASN1decoding_t dec, InterrogateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument_extension(ASN1decoding_t dec, DeactivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_ActivateDiversionQArgument_extension(ASN1decoding_t dec, ActivateDiversionQArgument_extension *val);
static int ASN1CALL ASN1Dec_H4503ROS(ASN1decoding_t dec, H4503ROS *val);
static int ASN1CALL ASN1Dec_DummyArg(ASN1decoding_t dec, DummyArg *val);
static int ASN1CALL ASN1Dec_DummyRes(ASN1decoding_t dec, DummyRes *val);
static int ASN1CALL ASN1Dec_SubaddressTransferArg(ASN1decoding_t dec, SubaddressTransferArg *val);
static int ASN1CALL ASN1Dec_MixedExtension(ASN1decoding_t dec, MixedExtension *val);
static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val);
static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg(ASN1decoding_t dec, PCpNotifyArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickExeRes_extensionRes(ASN1decoding_t dec, PPickExeRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickExeArg_extensionArg(ASN1decoding_t dec, PPickExeArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickupRes_extensionRes(ASN1decoding_t dec, PPickupRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickupArg_extensionArg(ASN1decoding_t dec, PPickupArg_extensionArg *val);
static int ASN1CALL ASN1Dec_PickrequRes_extensionRes(ASN1decoding_t dec, PPickrequRes_extensionRes *val);
static int ASN1CALL ASN1Dec_PickrequArg_extensionArg(ASN1decoding_t dec, PPickrequArg_extensionArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes(ASN1decoding_t dec, PCpSetupRes_extensionRes *val);
static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg(ASN1decoding_t dec, PCpSetupArg_extensionArg *val);
static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes(ASN1decoding_t dec, PCpRequestRes_extensionRes *val);
static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg(ASN1decoding_t dec, PCpRequestArg_extensionArg *val);
static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus(ASN1decoding_t dec, PServiceApdus_rosApdus *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress(ASN1decoding_t dec, PEndpointAddress_destinationAddress *val);
static int ASN1CALL ASN1Dec_AddressInformation(ASN1decoding_t dec, AddressInformation *val);
static int ASN1CALL ASN1Dec_EndpointAddress(ASN1decoding_t dec, EndpointAddress *val);
static int ASN1CALL ASN1Dec_NetworkFacilityExtension(ASN1decoding_t dec, NetworkFacilityExtension *val);
static int ASN1CALL ASN1Dec_ActivateDiversionQArgument(ASN1decoding_t dec, ActivateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument(ASN1decoding_t dec, DeactivateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument(ASN1decoding_t dec, InterrogateDiversionQArgument *val);
static int ASN1CALL ASN1Dec_CheckRestrictionArgument(ASN1decoding_t dec, CheckRestrictionArgument *val);
static int ASN1CALL ASN1Dec_CallReroutingArgument(ASN1decoding_t dec, CallReroutingArgument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument(ASN1decoding_t dec, DivertingLegInformation1Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument(ASN1decoding_t dec, DivertingLegInformation2Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument(ASN1decoding_t dec, DivertingLegInformation3Argument *val);
static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument(ASN1decoding_t dec, DivertingLegInformation4Argument *val);
static int ASN1CALL ASN1Dec_IntResult(ASN1decoding_t dec, IntResult *val);
static int ASN1CALL ASN1Dec_CTInitiateArg(ASN1decoding_t dec, CTInitiateArg *val);
static int ASN1CALL ASN1Dec_CTSetupArg(ASN1decoding_t dec, CTSetupArg *val);
static int ASN1CALL ASN1Dec_CTIdentifyRes(ASN1decoding_t dec, CTIdentifyRes *val);
static int ASN1CALL ASN1Dec_CTUpdateArg(ASN1decoding_t dec, CTUpdateArg *val);
static int ASN1CALL ASN1Dec_CTCompleteArg(ASN1decoding_t dec, CTCompleteArg *val);
static int ASN1CALL ASN1Dec_CTActiveArg(ASN1decoding_t dec, CTActiveArg *val);
static int ASN1CALL ASN1Dec_CpRequestArg(ASN1decoding_t dec, CpRequestArg *val);
static int ASN1CALL ASN1Dec_CpRequestRes(ASN1decoding_t dec, CpRequestRes *val);
static int ASN1CALL ASN1Dec_CpSetupArg(ASN1decoding_t dec, CpSetupArg *val);
static int ASN1CALL ASN1Dec_CpSetupRes(ASN1decoding_t dec, CpSetupRes *val);
static int ASN1CALL ASN1Dec_GroupIndicationOnArg(ASN1decoding_t dec, GroupIndicationOnArg *val);
static int ASN1CALL ASN1Dec_GroupIndicationOffArg(ASN1decoding_t dec, GroupIndicationOffArg *val);
static int ASN1CALL ASN1Dec_PickrequArg(ASN1decoding_t dec, PickrequArg *val);
static int ASN1CALL ASN1Dec_PickupArg(ASN1decoding_t dec, PickupArg *val);
static int ASN1CALL ASN1Dec_PickExeArg(ASN1decoding_t dec, PickExeArg *val);
static int ASN1CALL ASN1Dec_CpNotifyArg(ASN1decoding_t dec, CpNotifyArg *val);
static int ASN1CALL ASN1Dec_CpickupNotifyArg(ASN1decoding_t dec, CpickupNotifyArg *val);
static int ASN1CALL ASN1Dec_H4501SupplementaryService(ASN1decoding_t dec, H4501SupplementaryService *val);
static int ASN1CALL ASN1Dec_IntResultList(ASN1decoding_t dec, IntResultList *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_ServiceApdus(ServiceApdus *val);
static void ASN1CALL ASN1Free_EXTENSION(EXTENSION *val);
static void ASN1CALL ASN1Free_GroupIndicationOnRes(GroupIndicationOnRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOffRes(GroupIndicationOffRes *val);
static void ASN1CALL ASN1Free_PickupRes(PickupRes *val);
static void ASN1CALL ASN1Free_PickExeRes(PickExeRes *val);
static void ASN1CALL ASN1Free_UserSpecifiedSubaddress(UserSpecifiedSubaddress *val);
static void ASN1CALL ASN1Free_CODE(CODE *val);
static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val);
static void ASN1CALL ASN1Free_ReturnResult_result(ReturnResult_result *val);
static void ASN1CALL ASN1Free_Invoke(Invoke *val);
static void ASN1CALL ASN1Free_ReturnResult(ReturnResult *val);
static void ASN1CALL ASN1Free_ReturnError(ReturnError *val);
static void ASN1CALL ASN1Free_ExtensionSeq(PExtensionSeq *val);
static void ASN1CALL ASN1Free_PickrequRes(PickrequRes *val);
static void ASN1CALL ASN1Free_PartySubaddress(PartySubaddress *val);
static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val);
static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_CTActiveArg_argumentExtension(CTActiveArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTCompleteArg_argumentExtension(CTCompleteArg_argumentExtension *val);
static void ASN1CALL ASN1Free_SubaddressTransferArg_argumentExtension(SubaddressTransferArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTUpdateArg_argumentExtension(CTUpdateArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTIdentifyRes_resultExtension(CTIdentifyRes_resultExtension *val);
static void ASN1CALL ASN1Free_CTSetupArg_argumentExtension(CTSetupArg_argumentExtension *val);
static void ASN1CALL ASN1Free_CTInitiateArg_argumentExtension(CTInitiateArg_argumentExtension *val);
static void ASN1CALL ASN1Free_IntResult_extension(IntResult_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation4Argument_extension(DivertingLegInformation4Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation3Argument_extension(DivertingLegInformation3Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation2Argument_extension(DivertingLegInformation2Argument_extension *val);
static void ASN1CALL ASN1Free_DivertingLegInformation1Argument_extension(DivertingLegInformation1Argument_extension *val);
static void ASN1CALL ASN1Free_CallReroutingArgument_extension(CallReroutingArgument_extension *val);
static void ASN1CALL ASN1Free_CheckRestrictionArgument_extension(CheckRestrictionArgument_extension *val);
static void ASN1CALL ASN1Free_InterrogateDiversionQArgument_extension(InterrogateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_DeactivateDiversionQArgument_extension(DeactivateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_ActivateDiversionQArgument_extension(ActivateDiversionQArgument_extension *val);
static void ASN1CALL ASN1Free_H4503ROS(H4503ROS *val);
static void ASN1CALL ASN1Free_DummyArg(DummyArg *val);
static void ASN1CALL ASN1Free_DummyRes(DummyRes *val);
static void ASN1CALL ASN1Free_SubaddressTransferArg(SubaddressTransferArg *val);
static void ASN1CALL ASN1Free_MixedExtension(MixedExtension *val);
static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val);
static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg(PCpickupNotifyArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg(PCpNotifyArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickExeRes_extensionRes(PPickExeRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickExeArg_extensionArg(PPickExeArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickupRes_extensionRes(PPickupRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickupArg_extensionArg(PPickupArg_extensionArg *val);
static void ASN1CALL ASN1Free_PickrequRes_extensionRes(PPickrequRes_extensionRes *val);
static void ASN1CALL ASN1Free_PickrequArg_extensionArg(PPickrequArg_extensionArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes(PGroupIndicationOffRes_extensionRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg(PGroupIndicationOffArg_extensionArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes(PGroupIndicationOnRes_extensionRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg(PGroupIndicationOnArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpSetupRes_extensionRes(PCpSetupRes_extensionRes *val);
static void ASN1CALL ASN1Free_CpSetupArg_extensionArg(PCpSetupArg_extensionArg *val);
static void ASN1CALL ASN1Free_CpRequestRes_extensionRes(PCpRequestRes_extensionRes *val);
static void ASN1CALL ASN1Free_CpRequestArg_extensionArg(PCpRequestArg_extensionArg *val);
static void ASN1CALL ASN1Free_ServiceApdus_rosApdus(PServiceApdus_rosApdus *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress(PEndpointAddress_destinationAddress *val);
static void ASN1CALL ASN1Free_AddressInformation(AddressInformation *val);
static void ASN1CALL ASN1Free_EndpointAddress(EndpointAddress *val);
static void ASN1CALL ASN1Free_NetworkFacilityExtension(NetworkFacilityExtension *val);
static void ASN1CALL ASN1Free_ActivateDiversionQArgument(ActivateDiversionQArgument *val);
static void ASN1CALL ASN1Free_DeactivateDiversionQArgument(DeactivateDiversionQArgument *val);
static void ASN1CALL ASN1Free_InterrogateDiversionQArgument(InterrogateDiversionQArgument *val);
static void ASN1CALL ASN1Free_CheckRestrictionArgument(CheckRestrictionArgument *val);
static void ASN1CALL ASN1Free_CallReroutingArgument(CallReroutingArgument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation1Argument(DivertingLegInformation1Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation2Argument(DivertingLegInformation2Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation3Argument(DivertingLegInformation3Argument *val);
static void ASN1CALL ASN1Free_DivertingLegInformation4Argument(DivertingLegInformation4Argument *val);
static void ASN1CALL ASN1Free_IntResult(IntResult *val);
static void ASN1CALL ASN1Free_CTInitiateArg(CTInitiateArg *val);
static void ASN1CALL ASN1Free_CTSetupArg(CTSetupArg *val);
static void ASN1CALL ASN1Free_CTIdentifyRes(CTIdentifyRes *val);
static void ASN1CALL ASN1Free_CTUpdateArg(CTUpdateArg *val);
static void ASN1CALL ASN1Free_CTCompleteArg(CTCompleteArg *val);
static void ASN1CALL ASN1Free_CTActiveArg(CTActiveArg *val);
static void ASN1CALL ASN1Free_CpRequestArg(CpRequestArg *val);
static void ASN1CALL ASN1Free_CpRequestRes(CpRequestRes *val);
static void ASN1CALL ASN1Free_CpSetupArg(CpSetupArg *val);
static void ASN1CALL ASN1Free_CpSetupRes(CpSetupRes *val);
static void ASN1CALL ASN1Free_GroupIndicationOnArg(GroupIndicationOnArg *val);
static void ASN1CALL ASN1Free_GroupIndicationOffArg(GroupIndicationOffArg *val);
static void ASN1CALL ASN1Free_PickrequArg(PickrequArg *val);
static void ASN1CALL ASN1Free_PickupArg(PickupArg *val);
static void ASN1CALL ASN1Free_PickExeArg(PickExeArg *val);
static void ASN1CALL ASN1Free_CpNotifyArg(CpNotifyArg *val);
static void ASN1CALL ASN1Free_CpickupNotifyArg(CpickupNotifyArg *val);
static void ASN1CALL ASN1Free_H4501SupplementaryService(H4501SupplementaryService *val);
static void ASN1CALL ASN1Free_IntResultList(IntResultList *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[36] = {
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOnRes,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOffRes,
    (ASN1EncFun_t) ASN1Enc_PickupRes,
    (ASN1EncFun_t) ASN1Enc_PickExeRes,
    (ASN1EncFun_t) ASN1Enc_PickrequRes,
    (ASN1EncFun_t) ASN1Enc_DummyArg,
    (ASN1EncFun_t) ASN1Enc_DummyRes,
    (ASN1EncFun_t) ASN1Enc_SubaddressTransferArg,
    (ASN1EncFun_t) ASN1Enc_ActivateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_DeactivateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_InterrogateDiversionQArgument,
    (ASN1EncFun_t) ASN1Enc_CheckRestrictionArgument,
    (ASN1EncFun_t) ASN1Enc_CallReroutingArgument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation1Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation2Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation3Argument,
    (ASN1EncFun_t) ASN1Enc_DivertingLegInformation4Argument,
    (ASN1EncFun_t) ASN1Enc_CTInitiateArg,
    (ASN1EncFun_t) ASN1Enc_CTSetupArg,
    (ASN1EncFun_t) ASN1Enc_CTIdentifyRes,
    (ASN1EncFun_t) ASN1Enc_CTUpdateArg,
    (ASN1EncFun_t) ASN1Enc_CTCompleteArg,
    (ASN1EncFun_t) ASN1Enc_CTActiveArg,
    (ASN1EncFun_t) ASN1Enc_CpRequestArg,
    (ASN1EncFun_t) ASN1Enc_CpRequestRes,
    (ASN1EncFun_t) ASN1Enc_CpSetupArg,
    (ASN1EncFun_t) ASN1Enc_CpSetupRes,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOnArg,
    (ASN1EncFun_t) ASN1Enc_GroupIndicationOffArg,
    (ASN1EncFun_t) ASN1Enc_PickrequArg,
    (ASN1EncFun_t) ASN1Enc_PickupArg,
    (ASN1EncFun_t) ASN1Enc_PickExeArg,
    (ASN1EncFun_t) ASN1Enc_CpNotifyArg,
    (ASN1EncFun_t) ASN1Enc_CpickupNotifyArg,
    (ASN1EncFun_t) ASN1Enc_H4501SupplementaryService,
    (ASN1EncFun_t) ASN1Enc_IntResultList,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[36] = {
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOnRes,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOffRes,
    (ASN1DecFun_t) ASN1Dec_PickupRes,
    (ASN1DecFun_t) ASN1Dec_PickExeRes,
    (ASN1DecFun_t) ASN1Dec_PickrequRes,
    (ASN1DecFun_t) ASN1Dec_DummyArg,
    (ASN1DecFun_t) ASN1Dec_DummyRes,
    (ASN1DecFun_t) ASN1Dec_SubaddressTransferArg,
    (ASN1DecFun_t) ASN1Dec_ActivateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_DeactivateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_InterrogateDiversionQArgument,
    (ASN1DecFun_t) ASN1Dec_CheckRestrictionArgument,
    (ASN1DecFun_t) ASN1Dec_CallReroutingArgument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation1Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation2Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation3Argument,
    (ASN1DecFun_t) ASN1Dec_DivertingLegInformation4Argument,
    (ASN1DecFun_t) ASN1Dec_CTInitiateArg,
    (ASN1DecFun_t) ASN1Dec_CTSetupArg,
    (ASN1DecFun_t) ASN1Dec_CTIdentifyRes,
    (ASN1DecFun_t) ASN1Dec_CTUpdateArg,
    (ASN1DecFun_t) ASN1Dec_CTCompleteArg,
    (ASN1DecFun_t) ASN1Dec_CTActiveArg,
    (ASN1DecFun_t) ASN1Dec_CpRequestArg,
    (ASN1DecFun_t) ASN1Dec_CpRequestRes,
    (ASN1DecFun_t) ASN1Dec_CpSetupArg,
    (ASN1DecFun_t) ASN1Dec_CpSetupRes,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOnArg,
    (ASN1DecFun_t) ASN1Dec_GroupIndicationOffArg,
    (ASN1DecFun_t) ASN1Dec_PickrequArg,
    (ASN1DecFun_t) ASN1Dec_PickupArg,
    (ASN1DecFun_t) ASN1Dec_PickExeArg,
    (ASN1DecFun_t) ASN1Dec_CpNotifyArg,
    (ASN1DecFun_t) ASN1Dec_CpickupNotifyArg,
    (ASN1DecFun_t) ASN1Dec_H4501SupplementaryService,
    (ASN1DecFun_t) ASN1Dec_IntResultList,
};
static const ASN1FreeFun_t freefntab[36] = {
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOnRes,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOffRes,
    (ASN1FreeFun_t) ASN1Free_PickupRes,
    (ASN1FreeFun_t) ASN1Free_PickExeRes,
    (ASN1FreeFun_t) ASN1Free_PickrequRes,
    (ASN1FreeFun_t) ASN1Free_DummyArg,
    (ASN1FreeFun_t) ASN1Free_DummyRes,
    (ASN1FreeFun_t) ASN1Free_SubaddressTransferArg,
    (ASN1FreeFun_t) ASN1Free_ActivateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_DeactivateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_InterrogateDiversionQArgument,
    (ASN1FreeFun_t) ASN1Free_CheckRestrictionArgument,
    (ASN1FreeFun_t) ASN1Free_CallReroutingArgument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation1Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation2Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation3Argument,
    (ASN1FreeFun_t) ASN1Free_DivertingLegInformation4Argument,
    (ASN1FreeFun_t) ASN1Free_CTInitiateArg,
    (ASN1FreeFun_t) ASN1Free_CTSetupArg,
    (ASN1FreeFun_t) ASN1Free_CTIdentifyRes,
    (ASN1FreeFun_t) ASN1Free_CTUpdateArg,
    (ASN1FreeFun_t) ASN1Free_CTCompleteArg,
    (ASN1FreeFun_t) ASN1Free_CTActiveArg,
    (ASN1FreeFun_t) ASN1Free_CpRequestArg,
    (ASN1FreeFun_t) ASN1Free_CpRequestRes,
    (ASN1FreeFun_t) ASN1Free_CpSetupArg,
    (ASN1FreeFun_t) ASN1Free_CpSetupRes,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOnArg,
    (ASN1FreeFun_t) ASN1Free_GroupIndicationOffArg,
    (ASN1FreeFun_t) ASN1Free_PickrequArg,
    (ASN1FreeFun_t) ASN1Free_PickupArg,
    (ASN1FreeFun_t) ASN1Free_PickExeArg,
    (ASN1FreeFun_t) ASN1Free_CpNotifyArg,
    (ASN1FreeFun_t) ASN1Free_CpickupNotifyArg,
    (ASN1FreeFun_t) ASN1Free_H4501SupplementaryService,
    (ASN1FreeFun_t) ASN1Free_IntResultList,
};
static const ULONG sizetab[36] = {
    SIZE_H4503PP_Module_PDU_0,
    SIZE_H4503PP_Module_PDU_1,
    SIZE_H4503PP_Module_PDU_2,
    SIZE_H4503PP_Module_PDU_3,
    SIZE_H4503PP_Module_PDU_4,
    SIZE_H4503PP_Module_PDU_5,
    SIZE_H4503PP_Module_PDU_6,
    SIZE_H4503PP_Module_PDU_7,
    SIZE_H4503PP_Module_PDU_8,
    SIZE_H4503PP_Module_PDU_9,
    SIZE_H4503PP_Module_PDU_10,
    SIZE_H4503PP_Module_PDU_11,
    SIZE_H4503PP_Module_PDU_12,
    SIZE_H4503PP_Module_PDU_13,
    SIZE_H4503PP_Module_PDU_14,
    SIZE_H4503PP_Module_PDU_15,
    SIZE_H4503PP_Module_PDU_16,
    SIZE_H4503PP_Module_PDU_17,
    SIZE_H4503PP_Module_PDU_18,
    SIZE_H4503PP_Module_PDU_19,
    SIZE_H4503PP_Module_PDU_20,
    SIZE_H4503PP_Module_PDU_21,
    SIZE_H4503PP_Module_PDU_22,
    SIZE_H4503PP_Module_PDU_23,
    SIZE_H4503PP_Module_PDU_24,
    SIZE_H4503PP_Module_PDU_25,
    SIZE_H4503PP_Module_PDU_26,
    SIZE_H4503PP_Module_PDU_27,
    SIZE_H4503PP_Module_PDU_28,
    SIZE_H4503PP_Module_PDU_29,
    SIZE_H4503PP_Module_PDU_30,
    SIZE_H4503PP_Module_PDU_31,
    SIZE_H4503PP_Module_PDU_32,
    SIZE_H4503PP_Module_PDU_33,
    SIZE_H4503PP_Module_PDU_34,
    SIZE_H4503PP_Module_PDU_35,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
CallStatus CTCompleteArg_callStatus_default = 0;
ASN1bool_t IntResult_remoteEnabled_default = 0;
BasicService InterrogateDiversionQArgument_basicService_default = 0;

void ASN1CALL H4503PP_Module_Startup(void)
{
    H4503PP_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 36, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x30353468);
}

void ASN1CALL H4503PP_Module_Cleanup(void)
{
    ASN1_CloseModule(H4503PP_Module);
    H4503PP_Module = NULL;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
    return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
    return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
    ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Reject_problem(ASN1encoding_t enc, Reject_problem *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncInteger(enc, (val)->u.general))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncInteger(enc, (val)->u.invoke))
        return 0;
    break;
    case 3:
    if (!ASN1PEREncInteger(enc, (val)->u.returnResult))
        return 0;
    break;
    case 4:
    if (!ASN1PEREncInteger(enc, (val)->u.returnError))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Reject_problem(ASN1decoding_t dec, Reject_problem *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecInteger(dec, &(val)->u.general))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecInteger(dec, &(val)->u.invoke))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecInteger(dec, &(val)->u.returnResult))
        return 0;
    break;
    case 4:
    if (!ASN1PERDecInteger(dec, &(val)->u.returnError))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EntityType(ASN1encoding_t enc, EntityType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EntityType(ASN1decoding_t dec, EntityType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_InterpretationApdu(ASN1encoding_t enc, InterpretationApdu *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InterpretationApdu(ASN1decoding_t dec, InterpretationApdu *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ServiceApdus(ASN1encoding_t enc, ServiceApdus *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ServiceApdus_rosApdus(enc, &(val)->u.rosApdus))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ServiceApdus(ASN1decoding_t dec, ServiceApdus *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ServiceApdus_rosApdus(dec, &(val)->u.rosApdus))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ServiceApdus(ServiceApdus *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ServiceApdus_rosApdus(&(val)->u.rosApdus);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_Reject(ASN1encoding_t enc, Reject *val)
{
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
    return 0;
    if (!ASN1Enc_Reject_problem(enc, &(val)->problem))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Reject(ASN1decoding_t dec, Reject *val)
{
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
    return 0;
    if (!ASN1Dec_Reject_problem(dec, &(val)->problem))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EXTENSION(ASN1encoding_t enc, EXTENSION *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->argumentType - 1))
        return 0;
    }
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->extensionID))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EXTENSION(ASN1decoding_t dec, EXTENSION *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->argumentType))
        return 0;
    (val)->argumentType += 1;
    }
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->extensionID))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EXTENSION(EXTENSION *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->extensionID);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes(ASN1encoding_t enc, GroupIndicationOnRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_GroupIndicationOnRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes(ASN1decoding_t dec, GroupIndicationOnRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_GroupIndicationOnRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes(GroupIndicationOnRes *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_GroupIndicationOnRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes(ASN1encoding_t enc, GroupIndicationOffRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_GroupIndicationOffRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes(ASN1decoding_t dec, GroupIndicationOffRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_GroupIndicationOffRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes(GroupIndicationOffRes *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_GroupIndicationOffRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_PickupRes(ASN1encoding_t enc, PickupRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_PickupRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickupRes(ASN1decoding_t dec, PickupRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_PickupRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickupRes(PickupRes *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_PickupRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_PickExeRes(ASN1encoding_t enc, PickExeRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_PickExeRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeRes(ASN1decoding_t dec, PickExeRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_PickExeRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickExeRes(PickExeRes *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_PickExeRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_UserSpecifiedSubaddress(ASN1encoding_t enc, UserSpecifiedSubaddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddressInformation, 1, 20, 5))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBoolean(enc, (val)->oddCountIndicator))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserSpecifiedSubaddress(ASN1decoding_t dec, UserSpecifiedSubaddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddressInformation, 1, 20, 5))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecBoolean(dec, &(val)->oddCountIndicator))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserSpecifiedSubaddress(UserSpecifiedSubaddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CODE(ASN1encoding_t enc, CODE *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncInteger(enc, (val)->u.local))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.global))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CODE(ASN1decoding_t dec, CODE *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecInteger(dec, &(val)->u.local))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.global))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CODE(CODE *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1objectidentifier_free(&(val)->u.global);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H225NonStandardIdentifier(ASN1encoding_t enc, H225NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardIdentifier(ASN1decoding_t dec, H225NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardIdentifier(H225NonStandardIdentifier *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1objectidentifier_free(&(val)->u.object);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_PublicTypeOfNumber(ASN1encoding_t enc, PublicTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicTypeOfNumber(ASN1decoding_t dec, PublicTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_PrivateTypeOfNumber(ASN1encoding_t enc, PrivateTypeOfNumber *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateTypeOfNumber(ASN1decoding_t dec, PrivateTypeOfNumber *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CallIdentifier(ASN1encoding_t enc, CallIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->guid, 16))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallIdentifier(ASN1decoding_t dec, CallIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->guid, 16))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallIdentifier(CallIdentifier *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ReturnResult_result(ASN1encoding_t enc, ReturnResult_result *val)
{
    if (!ASN1Enc_CODE(enc, &(val)->opcode))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->result))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnResult_result(ASN1decoding_t dec, ReturnResult_result *val)
{
    if (!ASN1Dec_CODE(dec, &(val)->opcode))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->result))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReturnResult_result(ReturnResult_result *val)
{
    if (val) {
    ASN1Free_CODE(&(val)->opcode);
    ASN1octetstring_free(&(val)->result);
    }
}

static int ASN1CALL ASN1Enc_Invoke(ASN1encoding_t enc, Invoke *val)
{
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->invokeId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncInteger(enc, (val)->linkedId))
        return 0;
    }
    if (!ASN1Enc_CODE(enc, &(val)->opcode))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->argument))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Invoke(ASN1decoding_t dec, Invoke *val)
{
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->invokeId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecInteger(dec, &(val)->linkedId))
        return 0;
    }
    if (!ASN1Dec_CODE(dec, &(val)->opcode))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->argument))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Invoke(Invoke *val)
{
    if (val) {
    ASN1Free_CODE(&(val)->opcode);
    if ((val)->o[0] & 0x40) {
        ASN1octetstring_free(&(val)->argument);
    }
    }
}

static int ASN1CALL ASN1Enc_ReturnResult(ASN1encoding_t enc, ReturnResult *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_ReturnResult_result(enc, &(val)->result))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnResult(ASN1decoding_t dec, ReturnResult *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_ReturnResult_result(dec, &(val)->result))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReturnResult(ReturnResult *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_ReturnResult_result(&(val)->result);
    }
    }
}

static int ASN1CALL ASN1Enc_ReturnError(ASN1encoding_t enc, ReturnError *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncInteger(enc, (val)->invokeId))
    return 0;
    if (!ASN1Enc_CODE(enc, &(val)->errcode))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->parameter))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReturnError(ASN1decoding_t dec, ReturnError *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecInteger(dec, &(val)->invokeId))
    return 0;
    if (!ASN1Dec_CODE(dec, &(val)->errcode))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->parameter))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReturnError(ReturnError *val)
{
    if (val) {
    ASN1Free_CODE(&(val)->errcode);
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->parameter);
    }
    }
}

static int ASN1CALL ASN1Enc_ExtensionSeq(ASN1encoding_t enc, PExtensionSeq *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ExtensionSeq_ElmFn);
}

static int ASN1CALL ASN1Enc_ExtensionSeq_ElmFn(ASN1encoding_t enc, PExtensionSeq val)
{
    if (!ASN1Enc_EXTENSION(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ExtensionSeq(ASN1decoding_t dec, PExtensionSeq *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ExtensionSeq_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ExtensionSeq_ElmFn(ASN1decoding_t dec, PExtensionSeq val)
{
    if (!ASN1Dec_EXTENSION(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ExtensionSeq(PExtensionSeq *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ExtensionSeq_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ExtensionSeq_ElmFn(PExtensionSeq val)
{
    if (val) {
    ASN1Free_EXTENSION(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequRes(ASN1encoding_t enc, PickrequRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_PickrequRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequRes(ASN1decoding_t dec, PickrequRes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_PickrequRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickrequRes(PickrequRes *val)
{
    if (val) {
    ASN1Free_CallIdentifier(&(val)->callPickupId);
    if ((val)->o[0] & 0x80) {
        ASN1Free_PickrequRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_PartySubaddress(ASN1encoding_t enc, PartySubaddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_UserSpecifiedSubaddress(enc, &(val)->u.userSpecifiedSubaddress))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapSubaddress, 1, 20, 5))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartySubaddress(ASN1decoding_t dec, PartySubaddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_UserSpecifiedSubaddress(dec, &(val)->u.userSpecifiedSubaddress))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapSubaddress, 1, 20, 5))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartySubaddress(PartySubaddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_UserSpecifiedSubaddress(&(val)->u.userSpecifiedSubaddress);
        break;
    case 2:
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H225NonStandardParameter(ASN1encoding_t enc, H225NonStandardParameter *val)
{
    if (!ASN1Enc_H225NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H225NonStandardParameter(ASN1decoding_t dec, H225NonStandardParameter *val)
{
    if (!ASN1Dec_H225NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H225NonStandardParameter(H225NonStandardParameter *val)
{
    if (val) {
    ASN1Free_H225NonStandardIdentifier(&(val)->nonStandardIdentifier);
    ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t PublicPartyNumber_publicNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PublicPartyNumber_publicNumberDigits_StringTable = {
    4, PublicPartyNumber_publicNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PublicPartyNumber(ASN1encoding_t enc, PublicPartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PublicTypeOfNumber(enc, &(val)->publicTypeOfNumber))
    return 0;
    t = lstrlenA((val)->publicNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber(ASN1decoding_t dec, PublicPartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PublicTypeOfNumber(dec, &(val)->publicTypeOfNumber))
    return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->publicNumberDigits) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->publicNumberDigits, 4, &PublicPartyNumber_publicNumberDigits_StringTable))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber(PublicPartyNumber *val)
{
    if (val) {
    }
}

static ASN1stringtableentry_t PrivatePartyNumber_privateNumberDigits_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PrivatePartyNumber_privateNumberDigits_StringTable = {
    4, PrivatePartyNumber_privateNumberDigits_StringTableEntries
};

static int ASN1CALL ASN1Enc_PrivatePartyNumber(ASN1encoding_t enc, PrivatePartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1Enc_PrivateTypeOfNumber(enc, &(val)->privateTypeOfNumber))
    return 0;
    t = lstrlenA((val)->privateNumberDigits);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber(ASN1decoding_t dec, PrivatePartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1Dec_PrivateTypeOfNumber(dec, &(val)->privateTypeOfNumber))
    return 0;
    if (!ASN1PERDecU32Val(dec, 7, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->privateNumberDigits) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->privateNumberDigits, 4, &PrivatePartyNumber_privateNumberDigits_StringTable))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber(PrivatePartyNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
        return 0;
    break;
    case 5:
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 6:
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardAddress))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
        return 0;
    break;
    case 5:
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 6:
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardAddress))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
        break;
    case 2:
        ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
        break;
    case 3:
        ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
        break;
    case 4:
        ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
        break;
    case 5:
        break;
    case 6:
        break;
    case 7:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTActiveArg_argumentExtension(ASN1encoding_t enc, CTActiveArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTActiveArg_argumentExtension(ASN1decoding_t dec, CTActiveArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTActiveArg_argumentExtension(CTActiveArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTCompleteArg_argumentExtension(ASN1encoding_t enc, CTCompleteArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTCompleteArg_argumentExtension(ASN1decoding_t dec, CTCompleteArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTCompleteArg_argumentExtension(CTCompleteArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_SubaddressTransferArg_argumentExtension(ASN1encoding_t enc, SubaddressTransferArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubaddressTransferArg_argumentExtension(ASN1decoding_t dec, SubaddressTransferArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubaddressTransferArg_argumentExtension(SubaddressTransferArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTUpdateArg_argumentExtension(ASN1encoding_t enc, CTUpdateArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTUpdateArg_argumentExtension(ASN1decoding_t dec, CTUpdateArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTUpdateArg_argumentExtension(CTUpdateArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTIdentifyRes_resultExtension(ASN1encoding_t enc, CTIdentifyRes_resultExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTIdentifyRes_resultExtension(ASN1decoding_t dec, CTIdentifyRes_resultExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTIdentifyRes_resultExtension(CTIdentifyRes_resultExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTSetupArg_argumentExtension(ASN1encoding_t enc, CTSetupArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTSetupArg_argumentExtension(ASN1decoding_t dec, CTSetupArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTSetupArg_argumentExtension(CTSetupArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CTInitiateArg_argumentExtension(ASN1encoding_t enc, CTInitiateArg_argumentExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTInitiateArg_argumentExtension(ASN1decoding_t dec, CTInitiateArg_argumentExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTInitiateArg_argumentExtension(CTInitiateArg_argumentExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_IntResult_extension(ASN1encoding_t enc, IntResult_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResult_extension(ASN1decoding_t dec, IntResult_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntResult_extension(IntResult_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument_extension(ASN1encoding_t enc, DivertingLegInformation4Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument_extension(ASN1decoding_t dec, DivertingLegInformation4Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation4Argument_extension(DivertingLegInformation4Argument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument_extension(ASN1encoding_t enc, DivertingLegInformation3Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument_extension(ASN1decoding_t dec, DivertingLegInformation3Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation3Argument_extension(DivertingLegInformation3Argument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument_extension(ASN1encoding_t enc, DivertingLegInformation2Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument_extension(ASN1decoding_t dec, DivertingLegInformation2Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation2Argument_extension(DivertingLegInformation2Argument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument_extension(ASN1encoding_t enc, DivertingLegInformation1Argument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument_extension(ASN1decoding_t dec, DivertingLegInformation1Argument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation1Argument_extension(DivertingLegInformation1Argument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CallReroutingArgument_extension(ASN1encoding_t enc, CallReroutingArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallReroutingArgument_extension(ASN1decoding_t dec, CallReroutingArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallReroutingArgument_extension(CallReroutingArgument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CheckRestrictionArgument_extension(ASN1encoding_t enc, CheckRestrictionArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CheckRestrictionArgument_extension(ASN1decoding_t dec, CheckRestrictionArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CheckRestrictionArgument_extension(CheckRestrictionArgument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument_extension(ASN1encoding_t enc, InterrogateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument_extension(ASN1decoding_t dec, InterrogateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InterrogateDiversionQArgument_extension(InterrogateDiversionQArgument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument_extension(ASN1encoding_t enc, DeactivateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument_extension(ASN1decoding_t dec, DeactivateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DeactivateDiversionQArgument_extension(DeactivateDiversionQArgument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ActivateDiversionQArgument_extension(ASN1encoding_t enc, ActivateDiversionQArgument_extension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ActivateDiversionQArgument_extension(ASN1decoding_t dec, ActivateDiversionQArgument_extension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ActivateDiversionQArgument_extension(ActivateDiversionQArgument_extension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H4503ROS(ASN1encoding_t enc, H4503ROS *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_Invoke(enc, &(val)->u.invoke))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_ReturnResult(enc, &(val)->u.returnResult))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_ReturnError(enc, &(val)->u.returnError))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_Reject(enc, &(val)->u.reject))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H4503ROS(ASN1decoding_t dec, H4503ROS *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_Invoke(dec, &(val)->u.invoke))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_ReturnResult(dec, &(val)->u.returnResult))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_ReturnError(dec, &(val)->u.returnError))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_Reject(dec, &(val)->u.reject))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H4503ROS(H4503ROS *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_Invoke(&(val)->u.invoke);
        break;
    case 2:
        ASN1Free_ReturnResult(&(val)->u.returnResult);
        break;
    case 3:
        ASN1Free_ReturnError(&(val)->u.returnError);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DummyArg(ASN1encoding_t enc, DummyArg *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DummyArg(ASN1decoding_t dec, DummyArg *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DummyArg(DummyArg *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DummyRes(ASN1encoding_t enc, DummyRes *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DummyRes(ASN1decoding_t dec, DummyRes *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DummyRes(DummyRes *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_SubaddressTransferArg(ASN1encoding_t enc, SubaddressTransferArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_PartySubaddress(enc, &(val)->redirectionSubaddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_SubaddressTransferArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SubaddressTransferArg(ASN1decoding_t dec, SubaddressTransferArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_PartySubaddress(dec, &(val)->redirectionSubaddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_SubaddressTransferArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubaddressTransferArg(SubaddressTransferArg *val)
{
    if (val) {
    ASN1Free_PartySubaddress(&(val)->redirectionSubaddress);
    if ((val)->o[0] & 0x80) {
        ASN1Free_SubaddressTransferArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static int ASN1CALL ASN1Enc_MixedExtension(ASN1encoding_t enc, MixedExtension *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ExtensionSeq(enc, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H225NonStandardParameter(enc, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MixedExtension(ASN1decoding_t dec, MixedExtension *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ExtensionSeq(dec, &(val)->u.extensionSeq))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H225NonStandardParameter(dec, &(val)->u.nonStandardData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MixedExtension(MixedExtension *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ExtensionSeq(&(val)->u.extensionSeq);
        break;
    case 2:
        ASN1Free_H225NonStandardParameter(&(val)->u.nonStandardData);
        break;
    }
    }
}

static ASN1stringtableentry_t PartyNumber_dataPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_dataPartyNumber_StringTable = {
    4, PartyNumber_dataPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_telexPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_telexPartyNumber_StringTable = {
    4, PartyNumber_telexPartyNumber_StringTableEntries
};

static ASN1stringtableentry_t PartyNumber_nationalStandardPartyNumber_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t PartyNumber_nationalStandardPartyNumber_StringTable = {
    4, PartyNumber_nationalStandardPartyNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_PartyNumber(ASN1encoding_t enc, PartyNumber *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_PublicPartyNumber(enc, &(val)->u.publicNumber))
        return 0;
    break;
    case 2:
    t = lstrlenA((val)->u.dataPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
        return 0;
    break;
    case 3:
    t = lstrlenA((val)->u.telexPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_PrivatePartyNumber(enc, &(val)->u.privateNumber))
        return 0;
    break;
    case 5:
    t = lstrlenA((val)->u.nationalStandardPartyNumber);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PartyNumber(ASN1decoding_t dec, PartyNumber *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_PublicPartyNumber(dec, &(val)->u.publicNumber))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.dataPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.dataPartyNumber, 4, &PartyNumber_dataPartyNumber_StringTable))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.telexPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.telexPartyNumber, 4, &PartyNumber_telexPartyNumber_StringTable))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_PrivatePartyNumber(dec, &(val)->u.privateNumber))
        return 0;
    break;
    case 5:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.nationalStandardPartyNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.nationalStandardPartyNumber, 4, &PartyNumber_nationalStandardPartyNumber_StringTable))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PartyNumber(PartyNumber *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_PublicPartyNumber(&(val)->u.publicNumber);
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        ASN1Free_PrivatePartyNumber(&(val)->u.privateNumber);
        break;
    case 5:
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg(PCpickupNotifyArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpickupNotifyArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg_ElmFn(PCpickupNotifyArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg(ASN1encoding_t enc, PCpNotifyArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpNotifyArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpNotifyArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg(ASN1decoding_t dec, PCpNotifyArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpNotifyArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpNotifyArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg(PCpNotifyArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpNotifyArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpNotifyArg_extensionArg_ElmFn(PCpNotifyArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickExeRes_extensionRes(ASN1encoding_t enc, PPickExeRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickExeRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickExeRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickExeRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeRes_extensionRes(ASN1decoding_t dec, PPickExeRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickExeRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickExeRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickExeRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickExeRes_extensionRes(PPickExeRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickExeRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickExeRes_extensionRes_ElmFn(PPickExeRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickExeArg_extensionArg(ASN1encoding_t enc, PPickExeArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickExeArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickExeArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickExeArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeArg_extensionArg(ASN1decoding_t dec, PPickExeArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickExeArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickExeArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickExeArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickExeArg_extensionArg(PPickExeArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickExeArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickExeArg_extensionArg_ElmFn(PPickExeArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickupRes_extensionRes(ASN1encoding_t enc, PPickupRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickupRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickupRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickupRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickupRes_extensionRes(ASN1decoding_t dec, PPickupRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickupRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickupRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickupRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickupRes_extensionRes(PPickupRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickupRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickupRes_extensionRes_ElmFn(PPickupRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickupArg_extensionArg(ASN1encoding_t enc, PPickupArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickupArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickupArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickupArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickupArg_extensionArg(ASN1decoding_t dec, PPickupArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickupArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickupArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickupArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickupArg_extensionArg(PPickupArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickupArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickupArg_extensionArg_ElmFn(PPickupArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequRes_extensionRes(ASN1encoding_t enc, PPickrequRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickrequRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_PickrequRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickrequRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequRes_extensionRes(ASN1decoding_t dec, PPickrequRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickrequRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickrequRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickrequRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickrequRes_extensionRes(PPickrequRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickrequRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickrequRes_extensionRes_ElmFn(PPickrequRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PickrequArg_extensionArg(ASN1encoding_t enc, PPickrequArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PickrequArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_PickrequArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickrequArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequArg_extensionArg(ASN1decoding_t dec, PPickrequArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PickrequArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PickrequArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickrequArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PickrequArg_extensionArg(PPickrequArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PickrequArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PickrequArg_extensionArg_ElmFn(PPickrequArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes(PGroupIndicationOffRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn(PGroupIndicationOffRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg(PGroupIndicationOffArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn(PGroupIndicationOffArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes(PGroupIndicationOnRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn(PGroupIndicationOnRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg(PGroupIndicationOnArg_extensionArg